pub fn sub_8249CF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249CF60 size=248
    let mut pc: u32 = 0x8249CF60;
    'dispatch: loop {
        match pc {
            0x8249CF60 => {
    //   block [0x8249CF60..0x8249CF78)
	// 8249CF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249CF64: 48098155  bl 0x825350b8
	ctx.lr = 0x8249CF68;
	sub_82535080(ctx, base);
	// 8249CF68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249CF6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8249CF70: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8249CF74: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	pc = 0x8249CF78; continue 'dispatch;
            }
            0x8249CF78 => {
    //   block [0x8249CF78..0x8249CF98)
	// 8249CF78: 7D64EA14  add r11, r4, r29
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[29].u64;
	// 8249CF7C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8249CF80: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8249CF84: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8249CF88: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249CF8C: 7D6BF02A  ldx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	// 8249CF90: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8249CF94: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8249CF98; continue 'dispatch;
            }
            0x8249CF98 => {
    //   block [0x8249CF98..0x8249CFAC)
	// 8249CF98: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249CF9C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8249CFA0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249CFA4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8249CFA8: 40980018  bge cr6, 0x8249cfc0
	if !ctx.cr[6].lt {
	pc = 0x8249CFC0; continue 'dispatch;
	}
	pc = 0x8249CFAC; continue 'dispatch;
            }
            0x8249CFAC => {
    //   block [0x8249CFAC..0x8249CFC0)
	// 8249CFAC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8249CFB0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8249CFB4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249CFB8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8249CFBC: 4198FFF0  blt cr6, 0x8249cfac
	if ctx.cr[6].lt {
	pc = 0x8249CFAC; continue 'dispatch;
	}
	pc = 0x8249CFC0; continue 'dispatch;
            }
            0x8249CFC0 => {
    //   block [0x8249CFC0..0x8249CFD4)
	// 8249CFC0: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249CFC4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8249CFC8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249CFCC: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8249CFD0: 40980018  bge cr6, 0x8249cfe8
	if !ctx.cr[6].lt {
	pc = 0x8249CFE8; continue 'dispatch;
	}
	pc = 0x8249CFD4; continue 'dispatch;
            }
            0x8249CFD4 => {
    //   block [0x8249CFD4..0x8249CFE8)
	// 8249CFD4: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 8249CFD8: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 8249CFDC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249CFE0: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8249CFE4: 4198FFF0  blt cr6, 0x8249cfd4
	if ctx.cr[6].lt {
	pc = 0x8249CFD4; continue 'dispatch;
	}
	pc = 0x8249CFE8; continue 'dispatch;
            }
            0x8249CFE8 => {
    //   block [0x8249CFE8..0x8249D01C)
	// 8249CFE8: 7F05F800  cmpw cr6, r5, r31
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[31].s32, &mut ctx.xer);
	// 8249CFEC: 41980040  blt cr6, 0x8249d02c
	if ctx.cr[6].lt {
	pc = 0x8249D02C; continue 'dispatch;
	}
	// 8249CFF0: 419A002C  beq cr6, 0x8249d01c
	if ctx.cr[6].eq {
	pc = 0x8249D01C; continue 'dispatch;
	}
	// 8249CFF4: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249CFF8: 54AA1838  slwi r10, r5, 3
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8249CFFC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8249D000: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 8249D004: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249D008: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8249D00C: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8249D010: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249D014: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 8249D018: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	pc = 0x8249D01C; continue 'dispatch;
            }
            0x8249D01C => {
    //   block [0x8249D01C..0x8249D02C)
	// 8249D01C: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 8249D020: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8249D024: 7F1F2800  cmpw cr6, r31, r5
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[5].s32, &mut ctx.xer);
	// 8249D028: 4099FF70  ble cr6, 0x8249cf98
	if !ctx.cr[6].gt {
	pc = 0x8249CF98; continue 'dispatch;
	}
	pc = 0x8249D02C; continue 'dispatch;
            }
            0x8249D02C => {
    //   block [0x8249D02C..0x8249D040)
	// 8249D02C: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 8249D030: 40980010  bge cr6, 0x8249d040
	if !ctx.cr[6].lt {
	pc = 0x8249D040; continue 'dispatch;
	}
	// 8249D034: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8249D038: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8249D03C: 4BFFFF25  bl 0x8249cf60
	ctx.lr = 0x8249D040;
	sub_8249CF60(ctx, base);
	pc = 0x8249D040; continue 'dispatch;
            }
            0x8249D040 => {
    //   block [0x8249D040..0x8249D050)
	// 8249D040: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 8249D044: 4098000C  bge cr6, 0x8249d050
	if !ctx.cr[6].lt {
	pc = 0x8249D050; continue 'dispatch;
	}
	// 8249D048: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8249D04C: 4BFFFF2C  b 0x8249cf78
	pc = 0x8249CF78; continue 'dispatch;
            }
            0x8249D050 => {
    //   block [0x8249D050..0x8249D058)
	// 8249D050: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8249D054: 480980B4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D058 size=64
    let mut pc: u32 = 0x8249D058;
    'dispatch: loop {
        match pc {
            0x8249D058 => {
    //   block [0x8249D058..0x8249D098)
	// 8249D058: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 8249D05C: C1A300C0  lfs f13, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D060: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D098 size=64
    let mut pc: u32 = 0x8249D098;
    'dispatch: loop {
        match pc {
            0x8249D098 => {
    //   block [0x8249D098..0x8249D0D8)
	// 8249D098: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 8249D09C: C1A300C0  lfs f13, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D0A0: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D0D8 size=72
    let mut pc: u32 = 0x8249D0D8;
    'dispatch: loop {
        match pc {
            0x8249D0D8 => {
    //   block [0x8249D0D8..0x8249D110)
	// 8249D0D8: C1A40000  lfs f13, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D0DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8249D0E0: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249D0E4: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8249D0E8: C1840028  lfs f12, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8249D0EC: FC0B036E  fsel f0, f11, f13, f0
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 8249D0F0: EDA06028  fsubs f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8249D0F4: FC0D602E  fsel f0, f13, f0, f12
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[12].f64 };
	// 8249D0F8: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D0FC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8249D100: 40990010  ble cr6, 0x8249d110
	if !ctx.cr[6].gt {
	pc = 0x8249D110; continue 'dispatch;
	}
	// 8249D104: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8249D108: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D10C: EDAD0024  fdivs f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x8249D110; continue 'dispatch;
            }
            0x8249D110 => {
    //   block [0x8249D110..0x8249D120)
	// 8249D110: D1A300C0  stfs f13, 0xc0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8249D114: D1A300C4  stfs f13, 0xc4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8249D118: D1A300C8  stfs f13, 0xc8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8249D11C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D120 size=44
    let mut pc: u32 = 0x8249D120;
    'dispatch: loop {
        match pc {
            0x8249D120 => {
    //   block [0x8249D120..0x8249D14C)
	// 8249D120: C1A40000  lfs f13, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D124: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249D128: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8249D12C: C1840028  lfs f12, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8249D130: FC0B682E  fsel f0, f11, f0, f13
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8249D134: EDA06028  fsubs f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8249D138: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 8249D13C: D00300C0  stfs f0, 0xc0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8249D140: D00300C4  stfs f0, 0xc4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8249D144: D00300C8  stfs f0, 0xc8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8249D148: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D150 size=52
    let mut pc: u32 = 0x8249D150;
    'dispatch: loop {
        match pc {
            0x8249D150 => {
    //   block [0x8249D150..0x8249D184)
	// 8249D150: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 8249D154: C00300C0  lfs f0, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249D158: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D188 size=52
    let mut pc: u32 = 0x8249D188;
    'dispatch: loop {
        match pc {
            0x8249D188 => {
    //   block [0x8249D188..0x8249D1BC)
	// 8249D188: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 8249D18C: C00300C0  lfs f0, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249D190: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249D1C0 size=104
    let mut pc: u32 = 0x8249D1C0;
    'dispatch: loop {
        match pc {
            0x8249D1C0 => {
    //   block [0x8249D1C0..0x8249D228)
	// 8249D1C0: 396300C0  addi r11, r3, 0xc0
	ctx.r[11].s64 = ctx.r[3].s64 + 192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249D228 size=32
    let mut pc: u32 = 0x8249D228;
    'dispatch: loop {
        match pc {
            0x8249D228 => {
    //   block [0x8249D228..0x8249D248)
	// 8249D228: 396300E0  addi r11, r3, 0xe0
	ctx.r[11].s64 = ctx.r[3].s64 + 224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D248 size=56
    let mut pc: u32 = 0x8249D248;
    'dispatch: loop {
        match pc {
            0x8249D248 => {
    //   block [0x8249D248..0x8249D280)
	// 8249D248: 3941001C  addi r10, r1, 0x1c
	ctx.r[10].s64 = ctx.r[1].s64 + 28;
	// 8249D24C: D021001C  stfs f1, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8249D280 size=88
    let mut pc: u32 = 0x8249D280;
    'dispatch: loop {
        match pc {
            0x8249D280 => {
    //   block [0x8249D280..0x8249D2D8)
	// 8249D280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249D284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249D288: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249D28C: 3941008C  addi r10, r1, 0x8c
	ctx.r[10].s64 = ctx.r[1].s64 + 140;
	// 8249D290: D021008C  stfs f1, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8249D294: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8249D298: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 8249D29C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8249D2D8 size=80
    let mut pc: u32 = 0x8249D2D8;
    'dispatch: loop {
        match pc {
            0x8249D2D8 => {
    //   block [0x8249D2D8..0x8249D328)
	// 8249D2D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249D2DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249D2E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249D2E4: 3961008C  addi r11, r1, 0x8c
	ctx.r[11].s64 = ctx.r[1].s64 + 140;
	// 8249D2E8: D021008C  stfs f1, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D328 size=28
    let mut pc: u32 = 0x8249D328;
    'dispatch: loop {
        match pc {
            0x8249D328 => {
    //   block [0x8249D328..0x8249D344)
	// 8249D328: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8249D32C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249D330: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249D334: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8249D338: EC200824  fdivs f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 8249D33C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249D340: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8249D348 size=112
    let mut pc: u32 = 0x8249D348;
    'dispatch: loop {
        match pc {
            0x8249D348 => {
    //   block [0x8249D348..0x8249D3B8)
	// 8249D348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249D34C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249D350: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8249D354: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249D358: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8249D35C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8249D360: 4BFFE269  bl 0x8249b5c8
	ctx.lr = 0x8249D364;
	sub_8249B5C8(ctx, base);
	// 8249D364: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8249D368: 394000C0  li r10, 0xc0
	ctx.r[10].s64 = 192;
	// 8249D36C: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 8249D370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249D374: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249D378: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8249D37C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8249D380: 396BCAEC  addi r11, r11, -0x3514
	ctx.r[11].s64 = ctx.r[11].s64 + -13588;
	// 8249D384: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8249D388: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8249D38C: 993F0008  stb r9, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u8 ) };
	// 8249D390: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8249D394: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8249D398: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D3B8 size=80
    let mut pc: u32 = 0x8249D3B8;
    'dispatch: loop {
        match pc {
            0x8249D3B8 => {
    //   block [0x8249D3B8..0x8249D408)
	// 8249D3B8: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 8249D3BC: C1A300C0  lfs f13, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D3C0: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8249D3C4: C18300C4  lfs f12, 0xc4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8249D3C8: C16300C8  lfs f11, 0xc8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D408 size=72
    let mut pc: u32 = 0x8249D408;
    'dispatch: loop {
        match pc {
            0x8249D408 => {
    //   block [0x8249D408..0x8249D450)
	// 8249D408: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8249D40C: C1A40000  lfs f13, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D410: C1840014  lfs f12, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8249D414: 394000C0  li r10, 0xc0
	ctx.r[10].s64 = 192;
	// 8249D418: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249D41C: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8249D420: D1A1FFF0  stfs f13, -0x10(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8249D424: C1A40028  lfs f13, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D428: ED806024  fdivs f12, f0, f12
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 8249D42C: D181FFF4  stfs f12, -0xc(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8249D430: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8249D434: C18300CC  lfs f12, 0xcc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8249D438: D181FFFC  stfs f12, -4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 8249D43C: D001FFF8  stfs f0, -8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 8249D440: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D450 size=60
    let mut pc: u32 = 0x8249D450;
    'dispatch: loop {
        match pc {
            0x8249D450 => {
    //   block [0x8249D450..0x8249D48C)
	// 8249D450: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 8249D454: C00300C0  lfs f0, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249D458: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8249D45C: C1A300C4  lfs f13, 0xc4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D460: C18300C8  lfs f12, 0xc8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D490 size=52
    let mut pc: u32 = 0x8249D490;
    'dispatch: loop {
        match pc {
            0x8249D490 => {
    //   block [0x8249D490..0x8249D4C4)
	// 8249D490: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249D494: 396000C0  li r11, 0xc0
	ctx.r[11].s64 = 192;
	// 8249D498: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8249D49C: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249D4A0: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8249D4A4: C0040028  lfs f0, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249D4A8: D001FFF8  stfs f0, -8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 8249D4AC: C00300CC  lfs f0, 0xcc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249D4B0: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 8249D4B4: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249D4C8 size=124
    let mut pc: u32 = 0x8249D4C8;
    'dispatch: loop {
        match pc {
            0x8249D4C8 => {
    //   block [0x8249D4C8..0x8249D544)
	// 8249D4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249D4CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249D4D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249D4D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8249D4D8: 394000C0  li r10, 0xc0
	ctx.r[10].s64 = 192;
	// 8249D4DC: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 8249D4E0: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8249D4E4: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 8249D4E8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8249D548 size=120
    let mut pc: u32 = 0x8249D548;
    'dispatch: loop {
        match pc {
            0x8249D548 => {
    //   block [0x8249D548..0x8249D5C0)
	// 8249D548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249D54C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249D550: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249D554: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8249D558: C1A300C0  lfs f13, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D55C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8249D560: C18300C4  lfs f12, 0xc4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8249D564: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8249D568: C16300C8  lfs f11, 0xc8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8249D56C: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 8249D570: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D5C0 size=56
    let mut pc: u32 = 0x8249D5C0;
    'dispatch: loop {
        match pc {
            0x8249D5C0 => {
    //   block [0x8249D5C0..0x8249D5F8)
	// 8249D5C0: 3941001C  addi r10, r1, 0x1c
	ctx.r[10].s64 = ctx.r[1].s64 + 28;
	// 8249D5C4: D021001C  stfs f1, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8249D5F8 size=88
    let mut pc: u32 = 0x8249D5F8;
    'dispatch: loop {
        match pc {
            0x8249D5F8 => {
    //   block [0x8249D5F8..0x8249D650)
	// 8249D5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249D5FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249D600: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249D604: 3941008C  addi r10, r1, 0x8c
	ctx.r[10].s64 = ctx.r[1].s64 + 140;
	// 8249D608: D021008C  stfs f1, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8249D60C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8249D610: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 8249D614: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8249D650 size=80
    let mut pc: u32 = 0x8249D650;
    'dispatch: loop {
        match pc {
            0x8249D650 => {
    //   block [0x8249D650..0x8249D6A0)
	// 8249D650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249D654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249D658: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249D65C: 3961008C  addi r11, r1, 0x8c
	ctx.r[11].s64 = ctx.r[1].s64 + 140;
	// 8249D660: D021008C  stfs f1, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249D6A0 size=212
    let mut pc: u32 = 0x8249D6A0;
    'dispatch: loop {
        match pc {
            0x8249D6A0 => {
    //   block [0x8249D6A0..0x8249D774)
	// 8249D6A0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8249D6A4: 394300C0  addi r10, r3, 0xc0
	ctx.r[10].s64 = ctx.r[3].s64 + 192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249D778 size=128
    let mut pc: u32 = 0x8249D778;
    'dispatch: loop {
        match pc {
            0x8249D778 => {
    //   block [0x8249D778..0x8249D7F8)
	// 8249D778: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249D7F8 size=4
    let mut pc: u32 = 0x8249D7F8;
    'dispatch: loop {
        match pc {
            0x8249D7F8 => {
    //   block [0x8249D7F8..0x8249D7FC)
	// 8249D7F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249D800 size=4
    let mut pc: u32 = 0x8249D800;
    'dispatch: loop {
        match pc {
            0x8249D800 => {
    //   block [0x8249D800..0x8249D804)
	// 8249D800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249D808 size=4
    let mut pc: u32 = 0x8249D808;
    'dispatch: loop {
        match pc {
            0x8249D808 => {
    //   block [0x8249D808..0x8249D80C)
	// 8249D808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249D810 size=68
    let mut pc: u32 = 0x8249D810;
    'dispatch: loop {
        match pc {
            0x8249D810 => {
    //   block [0x8249D810..0x8249D854)
	// 8249D810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249D814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249D818: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8249D81C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249D820: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8249D824: 4BFFE8F5  bl 0x8249c118
	ctx.lr = 0x8249D828;
	sub_8249C118(ctx, base);
	// 8249D828: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8249D82C: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 8249D830: 396BCBBC  addi r11, r11, -0x3444
	ctx.r[11].s64 = ctx.r[11].s64 + -13380;
	// 8249D834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249D838: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 8249D83C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8249D840: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8249D844: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8249D848: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8249D84C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8249D850: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249D858 size=216
    let mut pc: u32 = 0x8249D858;
    'dispatch: loop {
        match pc {
            0x8249D858 => {
    //   block [0x8249D858..0x8249D930)
	// 8249D858: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 8249D85C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8249D860: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 8249D864: 39440010  addi r10, r4, 0x10
	ctx.r[10].s64 = ctx.r[4].s64 + 16;
	// 8249D868: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 8249D86C: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 8249D870: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D930 size=64
    let mut pc: u32 = 0x8249D930;
    'dispatch: loop {
        match pc {
            0x8249D930 => {
    //   block [0x8249D930..0x8249D970)
	// 8249D930: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 8249D934: C1A300C0  lfs f13, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D938: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D970 size=64
    let mut pc: u32 = 0x8249D970;
    'dispatch: loop {
        match pc {
            0x8249D970 => {
    //   block [0x8249D970..0x8249D9B0)
	// 8249D970: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 8249D974: C1A300C0  lfs f13, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D978: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D9B0 size=72
    let mut pc: u32 = 0x8249D9B0;
    'dispatch: loop {
        match pc {
            0x8249D9B0 => {
    //   block [0x8249D9B0..0x8249D9E8)
	// 8249D9B0: C1A40000  lfs f13, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D9B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8249D9B8: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249D9BC: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8249D9C0: C1840028  lfs f12, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8249D9C4: FC0B036E  fsel f0, f11, f13, f0
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 8249D9C8: EDA06028  fsubs f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8249D9CC: FC0D602E  fsel f0, f13, f0, f12
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[12].f64 };
	// 8249D9D0: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D9D4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8249D9D8: 40990010  ble cr6, 0x8249d9e8
	if !ctx.cr[6].gt {
	pc = 0x8249D9E8; continue 'dispatch;
	}
	// 8249D9DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8249D9E0: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D9E4: EDAD0024  fdivs f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x8249D9E8; continue 'dispatch;
            }
            0x8249D9E8 => {
    //   block [0x8249D9E8..0x8249D9F8)
	// 8249D9E8: D1A300C0  stfs f13, 0xc0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8249D9EC: D1A300C4  stfs f13, 0xc4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8249D9F0: D1A300C8  stfs f13, 0xc8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8249D9F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249D9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249D9F8 size=44
    let mut pc: u32 = 0x8249D9F8;
    'dispatch: loop {
        match pc {
            0x8249D9F8 => {
    //   block [0x8249D9F8..0x8249DA24)
	// 8249D9F8: C1A40000  lfs f13, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249D9FC: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249DA00: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8249DA04: C1840028  lfs f12, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8249DA08: FC0B682E  fsel f0, f11, f0, f13
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8249DA0C: EDA06028  fsubs f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8249DA10: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 8249DA14: D00300C0  stfs f0, 0xc0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8249DA18: D00300C4  stfs f0, 0xc4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8249DA1C: D00300C8  stfs f0, 0xc8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8249DA20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249DA28 size=52
    let mut pc: u32 = 0x8249DA28;
    'dispatch: loop {
        match pc {
            0x8249DA28 => {
    //   block [0x8249DA28..0x8249DA5C)
	// 8249DA28: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 8249DA2C: C00300C0  lfs f0, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249DA30: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249DA60 size=52
    let mut pc: u32 = 0x8249DA60;
    'dispatch: loop {
        match pc {
            0x8249DA60 => {
    //   block [0x8249DA60..0x8249DA94)
	// 8249DA60: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 8249DA64: C00300C0  lfs f0, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249DA68: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249DA98 size=104
    let mut pc: u32 = 0x8249DA98;
    'dispatch: loop {
        match pc {
            0x8249DA98 => {
    //   block [0x8249DA98..0x8249DB00)
	// 8249DA98: 396300C0  addi r11, r3, 0xc0
	ctx.r[11].s64 = ctx.r[3].s64 + 192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249DB00 size=32
    let mut pc: u32 = 0x8249DB00;
    'dispatch: loop {
        match pc {
            0x8249DB00 => {
    //   block [0x8249DB00..0x8249DB20)
	// 8249DB00: 396300E0  addi r11, r3, 0xe0
	ctx.r[11].s64 = ctx.r[3].s64 + 224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249DB20 size=56
    let mut pc: u32 = 0x8249DB20;
    'dispatch: loop {
        match pc {
            0x8249DB20 => {
    //   block [0x8249DB20..0x8249DB58)
	// 8249DB20: 3941001C  addi r10, r1, 0x1c
	ctx.r[10].s64 = ctx.r[1].s64 + 28;
	// 8249DB24: D021001C  stfs f1, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8249DB58 size=88
    let mut pc: u32 = 0x8249DB58;
    'dispatch: loop {
        match pc {
            0x8249DB58 => {
    //   block [0x8249DB58..0x8249DBB0)
	// 8249DB58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249DB5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249DB60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249DB64: 3941008C  addi r10, r1, 0x8c
	ctx.r[10].s64 = ctx.r[1].s64 + 140;
	// 8249DB68: D021008C  stfs f1, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8249DB6C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8249DB70: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 8249DB74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8249DBB0 size=80
    let mut pc: u32 = 0x8249DBB0;
    'dispatch: loop {
        match pc {
            0x8249DBB0 => {
    //   block [0x8249DBB0..0x8249DC00)
	// 8249DBB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249DBB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249DBB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249DBBC: 3961008C  addi r11, r1, 0x8c
	ctx.r[11].s64 = ctx.r[1].s64 + 140;
	// 8249DBC0: D021008C  stfs f1, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249DC00 size=68
    let mut pc: u32 = 0x8249DC00;
    'dispatch: loop {
        match pc {
            0x8249DC00 => {
    //   block [0x8249DC00..0x8249DC44)
	// 8249DC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249DC04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249DC08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8249DC0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8249DC10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249DC14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8249DC18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8249DC1C: 4801DD55  bl 0x824bb970
	ctx.lr = 0x8249DC20;
	sub_824BB970(ctx, base);
	// 8249DC20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8249DC24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249DC28: 48006AD1  bl 0x824a46f8
	ctx.lr = 0x8249DC2C;
	sub_824A46F8(ctx, base);
	// 8249DC2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8249DC30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8249DC34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8249DC38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8249DC3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8249DC40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249DC48 size=120
    let mut pc: u32 = 0x8249DC48;
    'dispatch: loop {
        match pc {
            0x8249DC48 => {
    //   block [0x8249DC48..0x8249DC84)
	// 8249DC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249DC4C: 48097471  bl 0x825350bc
	ctx.lr = 0x8249DC50;
	sub_82535080(ctx, base);
	// 8249DC50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249DC54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8249DC58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8249DC5C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8249DC60: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 8249DC64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249DC68: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8249DC6C: 4801DD05  bl 0x824bb970
	ctx.lr = 0x8249DC70;
	sub_824BB970(ctx, base);
	// 8249DC70: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8249DC74: 419A0010  beq cr6, 0x8249dc84
	if ctx.cr[6].eq {
	pc = 0x8249DC84; continue 'dispatch;
	}
	// 8249DC78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8249DC7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249DC80: 48006A79  bl 0x824a46f8
	ctx.lr = 0x8249DC84;
	sub_824A46F8(ctx, base);
	pc = 0x8249DC84; continue 'dispatch;
            }
            0x8249DC84 => {
    //   block [0x8249DC84..0x8249DCB4)
	// 8249DC84: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 8249DC88: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249DC8C: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8249DC90: 40820024  bne 0x8249dcb4
	if !ctx.cr[0].eq {
	pc = 0x8249DCB4; continue 'dispatch;
	}
	// 8249DC94: 897F008C  lbz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 8249DC98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249DC9C: 409A0018  bne cr6, 0x8249dcb4
	if !ctx.cr[6].eq {
	pc = 0x8249DCB4; continue 'dispatch;
	}
	// 8249DCA0: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8249DCA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249DCA8: 419A000C  beq cr6, 0x8249dcb4
	if ctx.cr[6].eq {
	pc = 0x8249DCB4; continue 'dispatch;
	}
	// 8249DCAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249DCB0: 4BFF5511  bl 0x824931c0
	ctx.lr = 0x8249DCB4;
	sub_824931C0(ctx, base);
	pc = 0x8249DCB4; continue 'dispatch;
            }
            0x8249DCB4 => {
    //   block [0x8249DCB4..0x8249DCC0)
	// 8249DCB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8249DCB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8249DCBC: 48097450  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DCC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249DCC0 size=64
    let mut pc: u32 = 0x8249DCC0;
    'dispatch: loop {
        match pc {
            0x8249DCC0 => {
    //   block [0x8249DCC0..0x8249DCE4)
	// 8249DCC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249DCC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249DCC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8249DCCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249DCD0: 81630118  lwz r11, 0x118(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) } as u64;
	// 8249DCD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8249DCD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249DCDC: 419A0008  beq cr6, 0x8249dce4
	if ctx.cr[6].eq {
	pc = 0x8249DCE4; continue 'dispatch;
	}
	// 8249DCE0: 48006AF9  bl 0x824a47d8
	ctx.lr = 0x8249DCE4;
	sub_824A47D8(ctx, base);
	pc = 0x8249DCE4; continue 'dispatch;
            }
            0x8249DCE4 => {
    //   block [0x8249DCE4..0x8249DD00)
	// 8249DCE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249DCE8: 4801D6E1  bl 0x824bb3c8
	ctx.lr = 0x8249DCEC;
	sub_824BB3C8(ctx, base);
	// 8249DCEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8249DCF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8249DCF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8249DCF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8249DCFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249DD00 size=212
    let mut pc: u32 = 0x8249DD00;
    'dispatch: loop {
        match pc {
            0x8249DD00 => {
    //   block [0x8249DD00..0x8249DD54)
	// 8249DD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249DD04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249DD08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8249DD0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8249DD10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249DD14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8249DD18: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8249DD1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8249DD20: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249DD24: 892B0025  lbz r9, 0x25(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 8249DD28: 51493032  rlwimi r9, r10, 6, 0, 0x19
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(6) as u64) & 0x00000000FFFFFFC0) | (ctx.r[9].u64 & 0xFFFFFFFF0000003F);
	// 8249DD2C: 992B0025  stb r9, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[9].u8 ) };
	// 8249DD30: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 8249DD34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249DD38: 419A0028  beq cr6, 0x8249dd60
	if ctx.cr[6].eq {
	pc = 0x8249DD60; continue 'dispatch;
	}
	// 8249DD3C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8249DD40: 419A0014  beq cr6, 0x8249dd54
	if ctx.cr[6].eq {
	pc = 0x8249DD54; continue 'dispatch;
	}
	// 8249DD44: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 8249DD48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249DD4C: 419A0008  beq cr6, 0x8249dd54
	if ctx.cr[6].eq {
	pc = 0x8249DD54; continue 'dispatch;
	}
	// 8249DD50: 48006A89  bl 0x824a47d8
	ctx.lr = 0x8249DD54;
	sub_824A47D8(ctx, base);
	pc = 0x8249DD54; continue 'dispatch;
            }
            0x8249DD54 => {
    //   block [0x8249DD54..0x8249DD60)
	// 8249DD54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8249DD58: 4801D671  bl 0x824bb3c8
	ctx.lr = 0x8249DD5C;
	sub_824BB3C8(ctx, base);
	// 8249DD5C: 48000060  b 0x8249ddbc
	pc = 0x8249DDBC; continue 'dispatch;
            }
            0x8249DD60 => {
    //   block [0x8249DD60..0x8249DD84)
	// 8249DD60: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8249DD64: 915F0084  stw r10, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 8249DD68: 419A001C  beq cr6, 0x8249dd84
	if ctx.cr[6].eq {
	pc = 0x8249DD84; continue 'dispatch;
	}
	// 8249DD6C: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 8249DD70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249DD74: 419A0010  beq cr6, 0x8249dd84
	if ctx.cr[6].eq {
	pc = 0x8249DD84; continue 'dispatch;
	}
	// 8249DD78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8249DD7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249DD80: 48006A59  bl 0x824a47d8
	ctx.lr = 0x8249DD84;
	sub_824A47D8(ctx, base);
	pc = 0x8249DD84; continue 'dispatch;
            }
            0x8249DD84 => {
    //   block [0x8249DD84..0x8249DDBC)
	// 8249DD84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8249DD88: 4801D641  bl 0x824bb3c8
	ctx.lr = 0x8249DD8C;
	sub_824BB3C8(ctx, base);
	// 8249DD8C: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 8249DD90: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249DD94: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8249DD98: 40820024  bne 0x8249ddbc
	if !ctx.cr[0].eq {
	pc = 0x8249DDBC; continue 'dispatch;
	}
	// 8249DD9C: 897F008C  lbz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 8249DDA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249DDA4: 409A0018  bne cr6, 0x8249ddbc
	if !ctx.cr[6].eq {
	pc = 0x8249DDBC; continue 'dispatch;
	}
	// 8249DDA8: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8249DDAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249DDB0: 419A000C  beq cr6, 0x8249ddbc
	if ctx.cr[6].eq {
	pc = 0x8249DDBC; continue 'dispatch;
	}
	// 8249DDB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249DDB8: 4BFF5409  bl 0x824931c0
	ctx.lr = 0x8249DDBC;
	sub_824931C0(ctx, base);
	pc = 0x8249DDBC; continue 'dispatch;
            }
            0x8249DDBC => {
    //   block [0x8249DDBC..0x8249DDD4)
	// 8249DDBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8249DDC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8249DDC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8249DDC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8249DDCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8249DDD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DDD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249DDD8 size=128
    let mut pc: u32 = 0x8249DDD8;
    'dispatch: loop {
        match pc {
            0x8249DDD8 => {
    //   block [0x8249DDD8..0x8249DDFC)
	// 8249DDD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249DDDC: 480972E1  bl 0x825350bc
	ctx.lr = 0x8249DDE0;
	sub_82535080(ctx, base);
	// 8249DDE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249DDE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8249DDE8: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 8249DDEC: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 8249DDF0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8249DDF4: 41980024  blt cr6, 0x8249de18
	if ctx.cr[6].lt {
	pc = 0x8249DE18; continue 'dispatch;
	}
	// 8249DDF8: 57FE103A  slwi r30, r31, 2
	ctx.r[30].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x8249DDFC; continue 'dispatch;
            }
            0x8249DDFC => {
    //   block [0x8249DDFC..0x8249DE18)
	// 8249DDFC: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8249DE00: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8249DE04: 480187DD  bl 0x824b65e0
	ctx.lr = 0x8249DE08;
	sub_824B65E0(ctx, base);
	// 8249DE08: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 8249DE0C: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 8249DE10: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8249DE14: 4098FFE8  bge cr6, 0x8249ddfc
	if !ctx.cr[6].lt {
	pc = 0x8249DDFC; continue 'dispatch;
	}
	pc = 0x8249DE18; continue 'dispatch;
            }
            0x8249DE18 => {
    //   block [0x8249DE18..0x8249DE2C)
	// 8249DE18: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 8249DE1C: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 8249DE20: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8249DE24: 41980024  blt cr6, 0x8249de48
	if ctx.cr[6].lt {
	pc = 0x8249DE48; continue 'dispatch;
	}
	// 8249DE28: 57FE103A  slwi r30, r31, 2
	ctx.r[30].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x8249DE2C; continue 'dispatch;
            }
            0x8249DE2C => {
    //   block [0x8249DE2C..0x8249DE48)
	// 8249DE2C: 817D0034  lwz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 8249DE30: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249DE34: 480187AD  bl 0x824b65e0
	ctx.lr = 0x8249DE38;
	sub_824B65E0(ctx, base);
	// 8249DE38: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 8249DE3C: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 8249DE40: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8249DE44: 4098FFE8  bge cr6, 0x8249de2c
	if !ctx.cr[6].lt {
	pc = 0x8249DE2C; continue 'dispatch;
	}
	pc = 0x8249DE48; continue 'dispatch;
            }
            0x8249DE48 => {
    //   block [0x8249DE48..0x8249DE58)
	// 8249DE48: 807D0020  lwz r3, 0x20(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249DE4C: 48018795  bl 0x824b65e0
	ctx.lr = 0x8249DE50;
	sub_824B65E0(ctx, base);
	// 8249DE50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8249DE54: 480972B8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249DE58 size=188
    let mut pc: u32 = 0x8249DE58;
    'dispatch: loop {
        match pc {
            0x8249DE58 => {
    //   block [0x8249DE58..0x8249DE88)
	// 8249DE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249DE5C: 4809724D  bl 0x825350a8
	ctx.lr = 0x8249DE60;
	sub_82535080(ctx, base);
	// 8249DE60: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249DE64: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8249DE68: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8249DE6C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 8249DE70: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 8249DE74: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8249DE78: 817D0060  lwz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 8249DE7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249DE80: 4099008C  ble cr6, 0x8249df0c
	if !ctx.cr[6].gt {
	pc = 0x8249DF0C; continue 'dispatch;
	}
	// 8249DE84: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8249DE88; continue 'dispatch;
            }
            0x8249DE88 => {
    //   block [0x8249DE88..0x8249DEB4)
	// 8249DE88: 817D005C  lwz r11, 0x5c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 8249DE8C: 7FFC5A14  add r31, r28, r11
	ctx.r[31].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 8249DE90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249DE94: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8249DE98: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 8249DE9C: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8249DEA0: 897E00D8  lbz r11, 0xd8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(216 as u32) ) } as u64;
	// 8249DEA4: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8249DEA8: 409A000C  bne cr6, 0x8249deb4
	if !ctx.cr[6].eq {
	pc = 0x8249DEB4; continue 'dispatch;
	}
	// 8249DEAC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8249DEB0: 48000030  b 0x8249dee0
	pc = 0x8249DEE0; continue 'dispatch;
            }
            0x8249DEB4 => {
    //   block [0x8249DEB4..0x8249DEE0)
	// 8249DEB4: 2F180007  cmpwi cr6, r24, 7
	ctx.cr[6].compare_i32(ctx.r[24].s32, 7, &mut ctx.xer);
	// 8249DEB8: 409A0040  bne cr6, 0x8249def8
	if !ctx.cr[6].eq {
	pc = 0x8249DEF8; continue 'dispatch;
	}
	// 8249DEBC: 80BE00B8  lwz r5, 0xb8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) } as u64;
	// 8249DEC0: 809D00B8  lwz r4, 0xb8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 8249DEC4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249DEC8: 48019E21  bl 0x824b7ce8
	ctx.lr = 0x8249DECC;
	sub_824B7CE8(ctx, base);
	// 8249DECC: 817D00B8  lwz r11, 0xb8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 8249DED0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8249DED4: 409A0024  bne cr6, 0x8249def8
	if !ctx.cr[6].eq {
	pc = 0x8249DEF8; continue 'dispatch;
	}
	// 8249DED8: 817E00B8  lwz r11, 0xb8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) } as u64;
	// 8249DEDC: 386B0058  addi r3, r11, 0x58
	ctx.r[3].s64 = ctx.r[11].s64 + 88;
	pc = 0x8249DEE0; continue 'dispatch;
            }
            0x8249DEE0 => {
    //   block [0x8249DEE0..0x8249DEF8)
	// 8249DEE0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249DEE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8249DEE8: 48037191  bl 0x824d5078
	ctx.lr = 0x8249DEEC;
	sub_824D5078(ctx, base);
	// 8249DEEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8249DEF0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8249DEF4: 48036F3D  bl 0x824d4e30
	ctx.lr = 0x8249DEF8;
	sub_824D4E30(ctx, base);
	pc = 0x8249DEF8; continue 'dispatch;
            }
            0x8249DEF8 => {
    //   block [0x8249DEF8..0x8249DF0C)
	// 8249DEF8: 817D0060  lwz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 8249DEFC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 8249DF00: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 8249DF04: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249DF08: 4198FF80  blt cr6, 0x8249de88
	if ctx.cr[6].lt {
	pc = 0x8249DE88; continue 'dispatch;
	}
	pc = 0x8249DF0C; continue 'dispatch;
            }
            0x8249DF0C => {
    //   block [0x8249DF0C..0x8249DF14)
	// 8249DF0C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8249DF10: 480971E8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249DF18 size=20
    let mut pc: u32 = 0x8249DF18;
    'dispatch: loop {
        match pc {
            0x8249DF18 => {
    //   block [0x8249DF18..0x8249DF2C)
	// 8249DF18: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8249DF1C: 409A0010  bne cr6, 0x8249df2c
	if !ctx.cr[6].eq {
		sub_8249DF2C(ctx, base);
		return;
	}
	// 8249DF20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8249DF24: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 8249DF28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DF2C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249DF2C size=20
    let mut pc: u32 = 0x8249DF2C;
    'dispatch: loop {
        match pc {
            0x8249DF2C => {
    //   block [0x8249DF2C..0x8249DF40)
	// 8249DF2C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8249DF30: 409A0010  bne cr6, 0x8249df40
	if !ctx.cr[6].eq {
		sub_8249DF40(ctx, base);
		return;
	}
	// 8249DF34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8249DF38: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 8249DF3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8249DF40 size=44
    let mut pc: u32 = 0x8249DF40;
    'dispatch: loop {
        match pc {
            0x8249DF40 => {
    //   block [0x8249DF40..0x8249DF6C)
	// 8249DF40: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8249DF44: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8249DF48: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249DF4C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249DF50: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 8249DF54: 814A00C0  lwz r10, 0xc0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(192 as u32) ) } as u64;
	// 8249DF58: 7D6A5810  subfc r11, r10, r11
	ctx.xer.ca = ctx.r[11].u32 >= ctx.r[10].u32;
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8249DF5C: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 8249DF60: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8249DF64: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 8249DF68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249DF70 size=40
    let mut pc: u32 = 0x8249DF70;
    'dispatch: loop {
        match pc {
            0x8249DF70 => {
    //   block [0x8249DF70..0x8249DF98)
	// 8249DF70: A1640022  lhz r11, 0x22(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(34 as u32) ) } as u64;
	// 8249DF74: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 8249DF78: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8249DF7C: 81430040  lwz r10, 0x40(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 8249DF80: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249DF84: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8249DF88: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 8249DF8C: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 8249DF90: B1040022  sth r8, 0x22(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(34 as u32), ctx.r[8].u16 ) };
	// 8249DF94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249DF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249DF98 size=464
    let mut pc: u32 = 0x8249DF98;
    'dispatch: loop {
        match pc {
            0x8249DF98 => {
    //   block [0x8249DF98..0x8249DFCC)
	// 8249DF98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249DF9C: 4809711D  bl 0x825350b8
	ctx.lr = 0x8249DFA0;
	sub_82535080(ctx, base);
	// 8249DFA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249DFA4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8249DFA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8249DFAC: 897C00D8  lbz r11, 0xd8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(216 as u32) ) } as u64;
	// 8249DFB0: 93FC0008  stw r31, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8249DFB4: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8249DFB8: 409A0014  bne cr6, 0x8249dfcc
	if !ctx.cr[6].eq {
	pc = 0x8249DFCC; continue 'dispatch;
	}
	// 8249DFBC: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249DFC0: 48018781  bl 0x824b6740
	ctx.lr = 0x8249DFC4;
	sub_824B6740(ctx, base);
	// 8249DFC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8249DFC8: 48097140  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8249DFCC => {
    //   block [0x8249DFCC..0x8249DFF8)
	// 8249DFCC: 897F00B8  lbz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 8249DFD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249DFD4: 419A0170  beq cr6, 0x8249e144
	if ctx.cr[6].eq {
	pc = 0x8249E144; continue 'dispatch;
	}
	// 8249DFD8: 3965FFFF  addi r11, r5, -1
	ctx.r[11].s64 = ctx.r[5].s64 + -1;
	// 8249DFDC: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 8249DFE0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8249DFE4: 557DDFFE  rlwinm r29, r11, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8249DFE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8249DFEC: 409A000C  bne cr6, 0x8249dff8
	if !ctx.cr[6].eq {
	pc = 0x8249DFF8; continue 'dispatch;
	}
	// 8249DFF0: 3BDF0034  addi r30, r31, 0x34
	ctx.r[30].s64 = ctx.r[31].s64 + 52;
	// 8249DFF4: 419A0094  beq cr6, 0x8249e088
	if ctx.cr[6].eq {
	pc = 0x8249E088; continue 'dispatch;
	}
	pc = 0x8249DFF8; continue 'dispatch;
            }
            0x8249DFF8 => {
    //   block [0x8249DFF8..0x8249E010)
	// 8249DFF8: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249DFFC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8249E000: 3964FFF6  addi r11, r4, -0xa
	ctx.r[11].s64 = ctx.r[4].s64 + -10;
	// 8249E004: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249E008: 41980008  blt cr6, 0x8249e010
	if ctx.cr[6].lt {
	pc = 0x8249E010; continue 'dispatch;
	}
	// 8249E00C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	pc = 0x8249E010; continue 'dispatch;
            }
            0x8249E010 => {
    //   block [0x8249E010..0x8249E028)
	// 8249E010: 38E4FFFF  addi r7, r4, -1
	ctx.r[7].s64 = ctx.r[4].s64 + -1;
	// 8249E014: 7F072800  cmpw cr6, r7, r5
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[5].s32, &mut ctx.xer);
	// 8249E018: 41980070  blt cr6, 0x8249e088
	if ctx.cr[6].lt {
	pc = 0x8249E088; continue 'dispatch;
	}
	// 8249E01C: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E020: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249E024: 7D0B3214  add r8, r11, r6
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	pc = 0x8249E028; continue 'dispatch;
            }
            0x8249E028 => {
    //   block [0x8249E028..0x8249E048)
	// 8249E028: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E02C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8249E030: 812B004C  lwz r9, 0x4c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249E034: 394A0003  addi r10, r10, 3
	ctx.r[10].s64 = ctx.r[10].s64 + 3;
	// 8249E038: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8249E03C: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8249E040: 40990008  ble cr6, 0x8249e048
	if !ctx.cr[6].gt {
	pc = 0x8249E048; continue 'dispatch;
	}
	// 8249E044: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x8249E048; continue 'dispatch;
            }
            0x8249E048 => {
    //   block [0x8249E048..0x8249E06C)
	// 8249E048: 896B0026  lbz r11, 0x26(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249E04C: 556B06B6  rlwinm r11, r11, 0, 0x1a, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8249E050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249E054: 419A0024  beq cr6, 0x8249e078
	if ctx.cr[6].eq {
	pc = 0x8249E078; continue 'dispatch;
	}
	// 8249E058: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 8249E05C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E060: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8249E064: 41980008  blt cr6, 0x8249e06c
	if ctx.cr[6].lt {
	pc = 0x8249E06C; continue 'dispatch;
	}
	// 8249E068: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8249E06C; continue 'dispatch;
            }
            0x8249E06C => {
    //   block [0x8249E06C..0x8249E078)
	// 8249E06C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8249E070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249E074: 409A00A4  bne cr6, 0x8249e118
	if !ctx.cr[6].eq {
	pc = 0x8249E118; continue 'dispatch;
	}
	pc = 0x8249E078; continue 'dispatch;
            }
            0x8249E078 => {
    //   block [0x8249E078..0x8249E088)
	// 8249E078: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 8249E07C: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 8249E080: 7F072800  cmpw cr6, r7, r5
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[5].s32, &mut ctx.xer);
	// 8249E084: 4098FFA4  bge cr6, 0x8249e028
	if !ctx.cr[6].lt {
	pc = 0x8249E028; continue 'dispatch;
	}
	pc = 0x8249E088; continue 'dispatch;
            }
            0x8249E088 => {
    //   block [0x8249E088..0x8249E0F8)
	// 8249E088: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E08C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8249E090: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	// 8249E094: 3880006C  li r4, 0x6c
	ctx.r[4].s64 = 108;
	// 8249E098: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249E09C: 4BFC5F9D  bl 0x82464038
	ctx.lr = 0x8249E0A0;
	sub_82464038(ctx, base);
	// 8249E0A0: 3960006C  li r11, 0x6c
	ctx.r[11].s64 = 108;
	// 8249E0A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8249E0A8: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 8249E0AC: 48018EFD  bl 0x824b6fa8
	ctx.lr = 0x8249E0B0;
	sub_824B6FA8(ctx, base);
	// 8249E0B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8249E0B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8249E0B8: 53AB103A  rlwimi r11, r29, 2, 0, 0x1d
	ctx.r[11].u64 = (((ctx.r[29].u32).rotate_left(2) as u64) & 0x00000000FFFFFFFC) | (ctx.r[11].u64 & 0xFFFFFFFF00000003);
	// 8249E0BC: 895F0026  lbz r10, 0x26(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249E0C0: 516A2036  rlwimi r10, r11, 4, 0, 0x1b
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(4) as u64) & 0x00000000FFFFFFF0) | (ctx.r[10].u64 & 0xFFFFFFFF0000000F);
	// 8249E0C4: 995F0026  stb r10, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[10].u8 ) };
	// 8249E0C8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E0CC: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 8249E0D0: B17F0020  sth r11, 0x20(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u16 ) };
	// 8249E0D4: 997F0024  stb r11, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 8249E0D8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249E0DC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E0E0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249E0E4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E0E8: 409A0010  bne cr6, 0x8249e0f8
	if !ctx.cr[6].eq {
	pc = 0x8249E0F8; continue 'dispatch;
	}
	// 8249E0EC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8249E0F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8249E0F4: 4BFD025D  bl 0x8246e350
	ctx.lr = 0x8249E0F8;
	sub_8246E350(ctx, base);
	pc = 0x8249E0F8; continue 'dispatch;
            }
            0x8249E0F8 => {
    //   block [0x8249E0F8..0x8249E118)
	// 8249E0F8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E0FC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E100: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249E104: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 8249E108: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E10C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249E110: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8249E114: 48000038  b 0x8249e14c
	pc = 0x8249E14C; continue 'dispatch;
            }
            0x8249E118 => {
    //   block [0x8249E118..0x8249E144)
	// 8249E118: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249E11C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8249E120: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 8249E124: 806BFFFC  lwz r3, -4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8249E128: 89630025  lbz r11, 0x25(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(37 as u32) ) } as u64;
	// 8249E12C: 716B00CF  andi. r11, r11, 0xcf
	ctx.r[11].u64 = ctx.r[11].u64 & 207;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249E130: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 8249E134: 99630025  stb r11, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 8249E138: 48018609  bl 0x824b6740
	ctx.lr = 0x8249E13C;
	sub_824B6740(ctx, base);
	// 8249E13C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8249E140: 48096FC8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8249E144 => {
    //   block [0x8249E144..0x8249E14C)
	// 8249E144: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8249E148: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8249E14C; continue 'dispatch;
            }
            0x8249E14C => {
    //   block [0x8249E14C..0x8249E168)
	// 8249E14C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8249E150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249E154: 480185ED  bl 0x824b6740
	ctx.lr = 0x8249E158;
	sub_824B6740(ctx, base);
	// 8249E158: 817C00C0  lwz r11, 0xc0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(192 as u32) ) } as u64;
	// 8249E15C: 997F0024  stb r11, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 8249E160: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8249E164: 48096FA4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249E168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249E168 size=300
    let mut pc: u32 = 0x8249E168;
    'dispatch: loop {
        match pc {
            0x8249E168 => {
    //   block [0x8249E168..0x8249E194)
	// 8249E168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249E16C: 48096F41  bl 0x825350ac
	ctx.lr = 0x8249E170;
	sub_82535080(ctx, base);
	// 8249E170: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249E174: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 8249E178: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8249E17C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8249E180: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8249E184: A17A01FC  lhz r11, 0x1fc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[26].u32.wrapping_add(508 as u32) ) } as u64;
	// 8249E188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249E18C: 419A0100  beq cr6, 0x8249e28c
	if ctx.cr[6].eq {
	pc = 0x8249E28C; continue 'dispatch;
	}
	// 8249E190: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x8249E194; continue 'dispatch;
            }
            0x8249E194 => {
    //   block [0x8249E194..0x8249E1CC)
	// 8249E194: 817A01F8  lwz r11, 0x1f8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(504 as u32) ) } as u64;
	// 8249E198: 815D0020  lwz r10, 0x20(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249E19C: 7FFB582E  lwzx r31, r27, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249E1A0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8249E1A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8249E1A8: 409A00D0  bne cr6, 0x8249e278
	if !ctx.cr[6].eq {
	pc = 0x8249E278; continue 'dispatch;
	}
	// 8249E1AC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249E1B0: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E1B4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249E1B8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E1BC: 409A0010  bne cr6, 0x8249e1cc
	if !ctx.cr[6].eq {
	pc = 0x8249E1CC; continue 'dispatch;
	}
	// 8249E1C0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8249E1C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8249E1C8: 4BFD0189  bl 0x8246e350
	ctx.lr = 0x8249E1CC;
	sub_8246E350(ctx, base);
	pc = 0x8249E1CC; continue 'dispatch;
            }
            0x8249E1CC => {
    //   block [0x8249E1CC..0x8249E200)
	// 8249E1CC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E1D0: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E1D4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249E1D8: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 8249E1DC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E1E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249E1E4: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8249E1E8: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E1EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249E1F0: 419A0010  beq cr6, 0x8249e200
	if ctx.cr[6].eq {
	pc = 0x8249E200; continue 'dispatch;
	}
	// 8249E1F4: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 8249E1F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249E1FC: B17F0006  sth r11, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x8249E200; continue 'dispatch;
            }
            0x8249E200 => {
    //   block [0x8249E200..0x8249E25C)
	// 8249E200: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8249E204: 807D0020  lwz r3, 0x20(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249E208: 48018489  bl 0x824b6690
	ctx.lr = 0x8249E20C;
	sub_824B6690(ctx, base);
	// 8249E20C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249E210: 894B0025  lbz r10, 0x25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 8249E214: 714A00F3  andi. r10, r10, 0xf3
	ctx.r[10].u64 = ctx.r[10].u64 & 243;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8249E218: 614A0004  ori r10, r10, 4
	ctx.r[10].u64 = ctx.r[10].u64 | 4;
	// 8249E21C: 994B0025  stb r10, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8249E220: 83DD0020  lwz r30, 0x20(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249E224: A17E0022  lhz r11, 0x22(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(34 as u32) ) } as u64;
	// 8249E228: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 8249E22C: 409A004C  bne cr6, 0x8249e278
	if !ctx.cr[6].eq {
	pc = 0x8249E278; continue 'dispatch;
	}
	// 8249E230: 817D0044  lwz r11, 0x44(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) } as u64;
	// 8249E234: 3BFD0040  addi r31, r29, 0x40
	ctx.r[31].s64 = ctx.r[29].s64 + 64;
	// 8249E238: B17E0022  sth r11, 0x22(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(34 as u32), ctx.r[11].u16 ) };
	// 8249E23C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249E240: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E244: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249E248: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E24C: 409A0010  bne cr6, 0x8249e25c
	if !ctx.cr[6].eq {
	pc = 0x8249E25C; continue 'dispatch;
	}
	// 8249E250: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8249E254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249E258: 4BFD00F9  bl 0x8246e350
	ctx.lr = 0x8249E25C;
	sub_8246E350(ctx, base);
	pc = 0x8249E25C; continue 'dispatch;
            }
            0x8249E25C => {
    //   block [0x8249E25C..0x8249E278)
	// 8249E25C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E260: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E264: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249E268: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 8249E26C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E270: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249E274: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x8249E278; continue 'dispatch;
            }
            0x8249E278 => {
    //   block [0x8249E278..0x8249E28C)
	// 8249E278: A17A01FC  lhz r11, 0x1fc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[26].u32.wrapping_add(508 as u32) ) } as u64;
	// 8249E27C: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 8249E280: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 8249E284: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E288: 4198FF0C  blt cr6, 0x8249e194
	if ctx.cr[6].lt {
	pc = 0x8249E194; continue 'dispatch;
	}
	pc = 0x8249E28C; continue 'dispatch;
            }
            0x8249E28C => {
    //   block [0x8249E28C..0x8249E294)
	// 8249E28C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8249E290: 48096E6C  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249E298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249E298 size=192
    let mut pc: u32 = 0x8249E298;
    'dispatch: loop {
        match pc {
            0x8249E298 => {
    //   block [0x8249E298..0x8249E2F0)
	// 8249E298: 89640026  lbz r11, 0x26(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249E29C: 556B0032  rlwinm r11, r11, 0, 0, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8249E2A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249E2A4: 409A004C  bne cr6, 0x8249e2f0
	if !ctx.cr[6].eq {
	pc = 0x8249E2F0; continue 'dispatch;
	}
	// 8249E2A8: 81230038  lwz r9, 0x38(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 8249E2AC: 39630034  addi r11, r3, 0x34
	ctx.r[11].s64 = ctx.r[3].s64 + 52;
	// 8249E2B0: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 8249E2B4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8249E2B8: A1040020  lhz r8, 0x20(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249E2BC: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 8249E2C0: 5508103E  rotlwi r8, r8, 2
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(2)) as u64;
	// 8249E2C4: 8129FFFC  lwz r9, -4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8249E2C8: 7D28512E  stwx r9, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 8249E2CC: A1440020  lhz r10, 0x20(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249E2D0: 81230034  lwz r9, 0x34(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 8249E2D4: 5548103E  rotlwi r8, r10, 2
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 8249E2D8: 7D28482E  lwzx r9, r8, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8249E2DC: B1490020  sth r10, 0x20(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[10].u16 ) };
	// 8249E2E0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E2E4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8249E2E8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8249E2EC: 48000044  b 0x8249e330
	pc = 0x8249E330; continue 'dispatch;
            }
            0x8249E2F0 => {
    //   block [0x8249E2F0..0x8249E330)
	// 8249E2F0: A1640020  lhz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249E2F4: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 8249E2F8: 5569103E  rotlwi r9, r11, 2
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 8249E2FC: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 8249E300: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8249E304: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8249E308: 814AFFFC  lwz r10, -4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8249E30C: 7D49592E  stwx r10, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 8249E310: A1640020  lhz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249E314: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 8249E318: 5569103E  rotlwi r9, r11, 2
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 8249E31C: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8249E320: B16A0020  sth r11, 0x20(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[11].u16 ) };
	// 8249E324: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 8249E328: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8249E32C: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	pc = 0x8249E330; continue 'dispatch;
            }
            0x8249E330 => {
    //   block [0x8249E330..0x8249E358)
	// 8249E330: A1640022  lhz r11, 0x22(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(34 as u32) ) } as u64;
	// 8249E334: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 8249E338: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8249E33C: 81430040  lwz r10, 0x40(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 8249E340: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249E344: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8249E348: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 8249E34C: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 8249E350: B1040022  sth r8, 0x22(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(34 as u32), ctx.r[8].u16 ) };
	// 8249E354: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249E358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249E358 size=224
    let mut pc: u32 = 0x8249E358;
    'dispatch: loop {
        match pc {
            0x8249E358 => {
    //   block [0x8249E358..0x8249E374)
	// 8249E358: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 8249E35C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8249E360: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8249E364: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8249E368: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249E36C: 40990020  ble cr6, 0x8249e38c
	if !ctx.cr[6].gt {
	pc = 0x8249E38C; continue 'dispatch;
	}
	// 8249E370: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x8249E374; continue 'dispatch;
            }
            0x8249E374 => {
    //   block [0x8249E374..0x8249E38C)
	// 8249E374: 81070000  lwz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E378: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8249E37C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249E380: 7D2A412E  stwx r9, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u32) };
	// 8249E384: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8249E388: 409AFFEC  bne cr6, 0x8249e374
	if !ctx.cr[6].eq {
	pc = 0x8249E374; continue 'dispatch;
	}
	pc = 0x8249E38C; continue 'dispatch;
            }
            0x8249E38C => {
    //   block [0x8249E38C..0x8249E3A4)
	// 8249E38C: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E390: 38C502C5  addi r6, r5, 0x2c5
	ctx.r[6].s64 = ctx.r[5].s64 + 709;
	// 8249E394: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 8249E398: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249E39C: 40990090  ble cr6, 0x8249e42c
	if !ctx.cr[6].gt {
	pc = 0x8249E42C; continue 'dispatch;
	}
	// 8249E3A0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	pc = 0x8249E3A4; continue 'dispatch;
            }
            0x8249E3A4 => {
    //   block [0x8249E3A4..0x8249E3C4)
	// 8249E3A4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E3A8: 89060001  lbz r8, 1(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(1 as u32) ) } as u64;
	// 8249E3AC: 7D4B482E  lwzx r10, r11, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8249E3B0: A16A00DC  lhz r11, 0xdc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(220 as u32) ) } as u64;
	// 8249E3B4: 7D7E7670  srawi r30, r11, 0xe
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 14) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 14) as i64;
	// 8249E3B8: 7F08F000  cmpw cr6, r8, r30
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[30].s32, &mut ctx.xer);
	// 8249E3BC: 409A0008  bne cr6, 0x8249e3c4
	if !ctx.cr[6].eq {
	pc = 0x8249E3C4; continue 'dispatch;
	}
	// 8249E3C0: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	pc = 0x8249E3C4; continue 'dispatch;
            }
            0x8249E3C4 => {
    //   block [0x8249E3C4..0x8249E3E0)
	// 8249E3C4: 5568067E  clrlwi r8, r11, 0x19
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 8249E3C8: A16A00DA  lhz r11, 0xda(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(218 as u32) ) } as u64;
	// 8249E3CC: 89460000  lbz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E3D0: 7D7E7670  srawi r30, r11, 0xe
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 14) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 14) as i64;
	// 8249E3D4: 7F0AF000  cmpw cr6, r10, r30
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[30].s32, &mut ctx.xer);
	// 8249E3D8: 409A0008  bne cr6, 0x8249e3e0
	if !ctx.cr[6].eq {
	pc = 0x8249E3E0; continue 'dispatch;
	}
	// 8249E3DC: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	pc = 0x8249E3E0; continue 'dispatch;
            }
            0x8249E3E0 => {
    //   block [0x8249E3E0..0x8249E3F8)
	// 8249E3E0: 556A067E  clrlwi r10, r11, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 8249E3E4: 550B067E  clrlwi r11, r8, 0x19
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000007Fu64;
	// 8249E3E8: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 8249E3EC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E3F0: 40990008  ble cr6, 0x8249e3f8
	if !ctx.cr[6].gt {
	pc = 0x8249E3F8; continue 'dispatch;
	}
	// 8249E3F4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x8249E3F8; continue 'dispatch;
            }
            0x8249E3F8 => {
    //   block [0x8249E3F8..0x8249E418)
	// 8249E3F8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 8249E3FC: 4199001C  bgt cr6, 0x8249e418
	if ctx.cr[6].gt {
	pc = 0x8249E418; continue 'dispatch;
	}
	// 8249E400: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E404: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E408: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E40C: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8249E410: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249E414: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	pc = 0x8249E418; continue 'dispatch;
            }
            0x8249E418 => {
    //   block [0x8249E418..0x8249E42C)
	// 8249E418: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E41C: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 8249E420: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 8249E424: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E428: 4198FF7C  blt cr6, 0x8249e3a4
	if ctx.cr[6].lt {
	pc = 0x8249E3A4; continue 'dispatch;
	}
	pc = 0x8249E42C; continue 'dispatch;
            }
            0x8249E42C => {
    //   block [0x8249E42C..0x8249E438)
	// 8249E42C: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8249E430: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 8249E434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249E438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249E438 size=208
    let mut pc: u32 = 0x8249E438;
    'dispatch: loop {
        match pc {
            0x8249E438 => {
    //   block [0x8249E438..0x8249E458)
	// 8249E438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249E43C: 48096C79  bl 0x825350b4
	ctx.lr = 0x8249E440;
	sub_82535080(ctx, base);
	// 8249E440: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E444: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8249E448: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249E44C: 409900B8  ble cr6, 0x8249e504
	if !ctx.cr[6].gt {
	pc = 0x8249E504; continue 'dispatch;
	}
	// 8249E450: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8249E454: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x8249E458; continue 'dispatch;
            }
            0x8249E458 => {
    //   block [0x8249E458..0x8249E484)
	// 8249E458: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E45C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E460: 89280001  lbz r9, 1(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(1 as u32) ) } as u64;
	// 8249E464: 7CABF82E  lwzx r5, r11, r31
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 8249E468: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E46C: 7FABF82E  lwzx r29, r11, r31
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 8249E470: A16500DC  lhz r11, 0xdc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(220 as u32) ) } as u64;
	// 8249E474: 7D6A7670  srawi r10, r11, 0xe
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 14) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 14) as i64;
	// 8249E478: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8249E47C: 409A0008  bne cr6, 0x8249e484
	if !ctx.cr[6].eq {
	pc = 0x8249E484; continue 'dispatch;
	}
	// 8249E480: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	pc = 0x8249E484; continue 'dispatch;
            }
            0x8249E484 => {
    //   block [0x8249E484..0x8249E4A0)
	// 8249E484: 5569067E  clrlwi r9, r11, 0x19
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 8249E488: A16500DA  lhz r11, 0xda(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(218 as u32) ) } as u64;
	// 8249E48C: 89480000  lbz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E490: 7D7B7670  srawi r27, r11, 0xe
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 14) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[11].s32 >> 14) as i64;
	// 8249E494: 7F0AD800  cmpw cr6, r10, r27
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[27].s32, &mut ctx.xer);
	// 8249E498: 409A0008  bne cr6, 0x8249e4a0
	if !ctx.cr[6].eq {
	pc = 0x8249E4A0; continue 'dispatch;
	}
	// 8249E49C: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	pc = 0x8249E4A0; continue 'dispatch;
            }
            0x8249E4A0 => {
    //   block [0x8249E4A0..0x8249E4B8)
	// 8249E4A0: 556A067E  clrlwi r10, r11, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 8249E4A4: 552B067E  clrlwi r11, r9, 0x19
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000007Fu64;
	// 8249E4A8: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 8249E4AC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E4B0: 40990008  ble cr6, 0x8249e4b8
	if !ctx.cr[6].gt {
	pc = 0x8249E4B8; continue 'dispatch;
	}
	// 8249E4B4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x8249E4B8; continue 'dispatch;
            }
            0x8249E4B8 => {
    //   block [0x8249E4B8..0x8249E4CC)
	// 8249E4B8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 8249E4BC: 41990010  bgt cr6, 0x8249e4cc
	if ctx.cr[6].gt {
	pc = 0x8249E4CC; continue 'dispatch;
	}
	// 8249E4C0: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E4C4: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8249E4C8: 7F8A592E  stwx r28, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[28].u32) };
	pc = 0x8249E4CC; continue 'dispatch;
            }
            0x8249E4CC => {
    //   block [0x8249E4CC..0x8249E4DC)
	// 8249E4CC: A0A5009C  lhz r5, 0x9c(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(156 as u32) ) } as u64;
	// 8249E4D0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8249E4D4: 40980008  bge cr6, 0x8249e4dc
	if !ctx.cr[6].lt {
	pc = 0x8249E4DC; continue 'dispatch;
	}
	// 8249E4D8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	pc = 0x8249E4DC; continue 'dispatch;
            }
            0x8249E4DC => {
    //   block [0x8249E4DC..0x8249E504)
	// 8249E4DC: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E4E0: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249E4E4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8249E4E8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 8249E4EC: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8249E4F0: 7D292A14  add r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 8249E4F4: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 8249E4F8: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E4FC: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E500: 4198FF58  blt cr6, 0x8249e458
	if ctx.cr[6].lt {
	pc = 0x8249E458; continue 'dispatch;
	}
	pc = 0x8249E504; continue 'dispatch;
            }
            0x8249E504 => {
    //   block [0x8249E504..0x8249E508)
	// 8249E504: 48096C00  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249E508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8249E508 size=132
    let mut pc: u32 = 0x8249E508;
    'dispatch: loop {
        match pc {
            0x8249E508 => {
    //   block [0x8249E508..0x8249E528)
	// 8249E508: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 8249E50C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8249E510: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E514: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8249E518: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249E51C: 40990064  ble cr6, 0x8249e580
	if !ctx.cr[6].gt {
	pc = 0x8249E580; continue 'dispatch;
	}
	// 8249E520: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8249E524: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x8249E528; continue 'dispatch;
            }
            0x8249E528 => {
    //   block [0x8249E528..0x8249E55C)
	// 8249E528: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E52C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 8249E530: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E534: 81060000  lwz r8, 0(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E538: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E53C: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249E540: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249E544: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8249E548: 7FC8512E  stwx r30, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 8249E54C: A129009C  lhz r9, 0x9c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(156 as u32) ) } as u64;
	// 8249E550: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 8249E554: 41980008  blt cr6, 0x8249e55c
	if ctx.cr[6].lt {
	pc = 0x8249E55C; continue 'dispatch;
	}
	// 8249E558: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	pc = 0x8249E55C; continue 'dispatch;
            }
            0x8249E55C => {
    //   block [0x8249E55C..0x8249E580)
	// 8249E55C: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E560: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 8249E564: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8249E568: 7D0A482E  lwzx r8, r10, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8249E56C: 7D08FA14  add r8, r8, r31
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	// 8249E570: 7D0A492E  stwx r8, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	// 8249E574: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E578: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8249E57C: 4198FFAC  blt cr6, 0x8249e528
	if ctx.cr[6].lt {
	pc = 0x8249E528; continue 'dispatch;
	}
	pc = 0x8249E580; continue 'dispatch;
            }
            0x8249E580 => {
    //   block [0x8249E580..0x8249E58C)
	// 8249E580: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8249E584: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 8249E588: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249E590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249E590 size=492
    let mut pc: u32 = 0x8249E590;
    'dispatch: loop {
        match pc {
            0x8249E590 => {
    //   block [0x8249E590..0x8249E5C8)
	// 8249E590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249E594: 48096B19  bl 0x825350ac
	ctx.lr = 0x8249E598;
	sub_82535080(ctx, base);
	// 8249E598: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249E59C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8249E5A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8249E5A4: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 8249E5A8: A179009C  lhz r11, 0x9c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[25].u32.wrapping_add(156 as u32) ) } as u64;
	// 8249E5AC: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249E5B0: 3B8BFFFF  addi r28, r11, -1
	ctx.r[28].s64 = ctx.r[11].s64 + -1;
	// 8249E5B4: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8249E5B8: 419800DC  blt cr6, 0x8249e694
	if ctx.cr[6].lt {
	pc = 0x8249E694; continue 'dispatch;
	}
	// 8249E5BC: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249E5C0: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 8249E5C4: 557B2036  slwi r27, r11, 4
	ctx.r[27].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	pc = 0x8249E5C8; continue 'dispatch;
            }
            0x8249E5C8 => {
    //   block [0x8249E5C8..0x8249E5E8)
	// 8249E5C8: 81790098  lwz r11, 0x98(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(152 as u32) ) } as u64;
	// 8249E5CC: 7FFB582E  lwzx r31, r27, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249E5D0: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E5D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249E5D8: 419A0010  beq cr6, 0x8249e5e8
	if ctx.cr[6].eq {
	pc = 0x8249E5E8; continue 'dispatch;
	}
	// 8249E5DC: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 8249E5E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249E5E4: B17F0006  sth r11, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x8249E5E8; continue 'dispatch;
            }
            0x8249E5E8 => {
    //   block [0x8249E5E8..0x8249E610)
	// 8249E5E8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249E5EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249E5F0: 894B0025  lbz r10, 0x25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 8249E5F4: 534A3032  rlwimi r10, r26, 6, 0, 0x19
	ctx.r[10].u64 = (((ctx.r[26].u32).rotate_left(6) as u64) & 0x00000000FFFFFFC0) | (ctx.r[10].u64 & 0xFFFFFFFF0000003F);
	// 8249E5F8: 994B0025  stb r10, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8249E5FC: 817D0084  lwz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 8249E600: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249E604: 419A000C  beq cr6, 0x8249e610
	if ctx.cr[6].eq {
	pc = 0x8249E610; continue 'dispatch;
	}
	// 8249E608: 4801CDC1  bl 0x824bb3c8
	ctx.lr = 0x8249E60C;
	sub_824BB3C8(ctx, base);
	// 8249E60C: 4800003C  b 0x8249e648
	pc = 0x8249E648; continue 'dispatch;
            }
            0x8249E610 => {
    //   block [0x8249E610..0x8249E648)
	// 8249E610: 935D0084  stw r26, 0x84(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(132 as u32), ctx.r[26].u32 ) };
	// 8249E614: 4801CDB5  bl 0x824bb3c8
	ctx.lr = 0x8249E618;
	sub_824BB3C8(ctx, base);
	// 8249E618: 817D0084  lwz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 8249E61C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249E620: 917D0084  stw r11, 0x84(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8249E624: 40820024  bne 0x8249e648
	if !ctx.cr[0].eq {
	pc = 0x8249E648; continue 'dispatch;
	}
	// 8249E628: 897D008C  lbz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 8249E62C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249E630: 409A0018  bne cr6, 0x8249e648
	if !ctx.cr[6].eq {
	pc = 0x8249E648; continue 'dispatch;
	}
	// 8249E634: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 8249E638: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249E63C: 419A000C  beq cr6, 0x8249e648
	if ctx.cr[6].eq {
	pc = 0x8249E648; continue 'dispatch;
	}
	// 8249E640: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8249E644: 4BFF4B7D  bl 0x824931c0
	ctx.lr = 0x8249E648;
	sub_824931C0(ctx, base);
	pc = 0x8249E648; continue 'dispatch;
            }
            0x8249E648 => {
    //   block [0x8249E648..0x8249E668)
	// 8249E648: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249E64C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E650: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249E654: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E658: 409A0010  bne cr6, 0x8249e668
	if !ctx.cr[6].eq {
	pc = 0x8249E668; continue 'dispatch;
	}
	// 8249E65C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8249E660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8249E664: 4BFCFCED  bl 0x8246e350
	ctx.lr = 0x8249E668;
	sub_8246E350(ctx, base);
	pc = 0x8249E668; continue 'dispatch;
            }
            0x8249E668 => {
    //   block [0x8249E668..0x8249E694)
	// 8249E668: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E66C: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 8249E670: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E674: 3B7BFFD0  addi r27, r27, -0x30
	ctx.r[27].s64 = ctx.r[27].s64 + -48;
	// 8249E678: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249E67C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8249E680: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 8249E684: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E688: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249E68C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8249E690: 4098FF38  bge cr6, 0x8249e5c8
	if !ctx.cr[6].lt {
	pc = 0x8249E5C8; continue 'dispatch;
	}
	pc = 0x8249E694; continue 'dispatch;
            }
            0x8249E694 => {
    //   block [0x8249E694..0x8249E6A8)
	// 8249E694: 817900A4  lwz r11, 0xa4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(164 as u32) ) } as u64;
	// 8249E698: 3B8BFFFF  addi r28, r11, -1
	ctx.r[28].s64 = ctx.r[11].s64 + -1;
	// 8249E69C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8249E6A0: 419800D4  blt cr6, 0x8249e774
	if ctx.cr[6].lt {
	pc = 0x8249E774; continue 'dispatch;
	}
	// 8249E6A4: 579B103A  slwi r27, r28, 2
	ctx.r[27].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	pc = 0x8249E6A8; continue 'dispatch;
            }
            0x8249E6A8 => {
    //   block [0x8249E6A8..0x8249E6C8)
	// 8249E6A8: 817900A0  lwz r11, 0xa0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(160 as u32) ) } as u64;
	// 8249E6AC: 7FEBD82E  lwzx r31, r11, r27
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 8249E6B0: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E6B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249E6B8: 419A0010  beq cr6, 0x8249e6c8
	if ctx.cr[6].eq {
	pc = 0x8249E6C8; continue 'dispatch;
	}
	// 8249E6BC: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 8249E6C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249E6C4: B17F0006  sth r11, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x8249E6C8; continue 'dispatch;
            }
            0x8249E6C8 => {
    //   block [0x8249E6C8..0x8249E6F0)
	// 8249E6C8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249E6CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249E6D0: 894B0025  lbz r10, 0x25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 8249E6D4: 534A3032  rlwimi r10, r26, 6, 0, 0x19
	ctx.r[10].u64 = (((ctx.r[26].u32).rotate_left(6) as u64) & 0x00000000FFFFFFC0) | (ctx.r[10].u64 & 0xFFFFFFFF0000003F);
	// 8249E6D8: 994B0025  stb r10, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8249E6DC: 817D0084  lwz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 8249E6E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249E6E4: 419A000C  beq cr6, 0x8249e6f0
	if ctx.cr[6].eq {
	pc = 0x8249E6F0; continue 'dispatch;
	}
	// 8249E6E8: 4801CCE1  bl 0x824bb3c8
	ctx.lr = 0x8249E6EC;
	sub_824BB3C8(ctx, base);
	// 8249E6EC: 4800003C  b 0x8249e728
	pc = 0x8249E728; continue 'dispatch;
            }
            0x8249E6F0 => {
    //   block [0x8249E6F0..0x8249E728)
	// 8249E6F0: 935D0084  stw r26, 0x84(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(132 as u32), ctx.r[26].u32 ) };
	// 8249E6F4: 4801CCD5  bl 0x824bb3c8
	ctx.lr = 0x8249E6F8;
	sub_824BB3C8(ctx, base);
	// 8249E6F8: 817D0084  lwz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 8249E6FC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249E700: 917D0084  stw r11, 0x84(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8249E704: 40820024  bne 0x8249e728
	if !ctx.cr[0].eq {
	pc = 0x8249E728; continue 'dispatch;
	}
	// 8249E708: 897D008C  lbz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 8249E70C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249E710: 409A0018  bne cr6, 0x8249e728
	if !ctx.cr[6].eq {
	pc = 0x8249E728; continue 'dispatch;
	}
	// 8249E714: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 8249E718: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249E71C: 419A000C  beq cr6, 0x8249e728
	if ctx.cr[6].eq {
	pc = 0x8249E728; continue 'dispatch;
	}
	// 8249E720: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8249E724: 4BFF4A9D  bl 0x824931c0
	ctx.lr = 0x8249E728;
	sub_824931C0(ctx, base);
	pc = 0x8249E728; continue 'dispatch;
            }
            0x8249E728 => {
    //   block [0x8249E728..0x8249E748)
	// 8249E728: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249E72C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E730: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249E734: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E738: 409A0010  bne cr6, 0x8249e748
	if !ctx.cr[6].eq {
	pc = 0x8249E748; continue 'dispatch;
	}
	// 8249E73C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8249E740: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8249E744: 4BFCFC0D  bl 0x8246e350
	ctx.lr = 0x8249E748;
	sub_8246E350(ctx, base);
	pc = 0x8249E748; continue 'dispatch;
            }
            0x8249E748 => {
    //   block [0x8249E748..0x8249E774)
	// 8249E748: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E74C: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 8249E750: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E754: 3B7BFFFC  addi r27, r27, -4
	ctx.r[27].s64 = ctx.r[27].s64 + -4;
	// 8249E758: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249E75C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8249E760: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 8249E764: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E768: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249E76C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8249E770: 4098FF38  bge cr6, 0x8249e6a8
	if !ctx.cr[6].lt {
	pc = 0x8249E6A8; continue 'dispatch;
	}
	pc = 0x8249E774; continue 'dispatch;
            }
            0x8249E774 => {
    //   block [0x8249E774..0x8249E77C)
	// 8249E774: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8249E778: 48096984  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249E780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8249E780 size=472
    let mut pc: u32 = 0x8249E780;
    'dispatch: loop {
        match pc {
            0x8249E780 => {
    //   block [0x8249E780..0x8249E800)
	// 8249E780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249E784: 48096925  bl 0x825350a8
	ctx.lr = 0x8249E788;
	sub_82535080(ctx, base);
	// 8249E788: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8249E78C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249E790: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8249E794: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8249E798: 397D0034  addi r11, r29, 0x34
	ctx.r[11].s64 = ctx.r[29].s64 + 52;
	// 8249E79C: 3B3D0028  addi r25, r29, 0x28
	ctx.r[25].s64 = ctx.r[29].s64 + 40;
	// 8249E7A0: 813D0038  lwz r9, 0x38(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 8249E7A4: 815D0034  lwz r10, 0x34(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 8249E7A8: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8249E7AC: A11F0020  lhz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249E7B0: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 8249E7B4: 5508103E  rotlwi r8, r8, 2
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(2)) as u64;
	// 8249E7B8: 8129FFFC  lwz r9, -4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8249E7BC: 7D28512E  stwx r9, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 8249E7C0: A15F0020  lhz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249E7C4: 813D0034  lwz r9, 0x34(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 8249E7C8: 5548103E  rotlwi r8, r10, 2
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 8249E7CC: 7D28482E  lwzx r9, r8, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8249E7D0: B1490020  sth r10, 0x20(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[10].u16 ) };
	// 8249E7D4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E7D8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8249E7DC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8249E7E0: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249E7E4: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E7E8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249E7EC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E7F0: 409A0010  bne cr6, 0x8249e800
	if !ctx.cr[6].eq {
	pc = 0x8249E800; continue 'dispatch;
	}
	// 8249E7F4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8249E7F8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8249E7FC: 4BFCFB55  bl 0x8246e350
	ctx.lr = 0x8249E800;
	sub_8246E350(ctx, base);
	pc = 0x8249E800; continue 'dispatch;
            }
            0x8249E800 => {
    //   block [0x8249E800..0x8249E868)
	// 8249E800: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E804: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8249E808: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E80C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8249E810: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8249E814: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8249E818: 7F58D378  mr r24, r26
	ctx.r[24].u64 = ctx.r[26].u64;
	// 8249E81C: 7FE9512E  stwx r31, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 8249E820: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8249E824: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E828: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249E82C: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8249E830: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 8249E834: D3FF0030  stfs f31, 0x30(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8249E838: 895F0026  lbz r10, 0x26(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249E83C: D3FF0034  stfs f31, 0x34(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8249E840: 3D6B0001  addis r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 65536;
	// 8249E844: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249E848: 510A3032  rlwimi r10, r8, 6, 0, 0x19
	ctx.r[10].u64 = (((ctx.r[8].u32).rotate_left(6) as u64) & 0x00000000FFFFFFC0) | (ctx.r[10].u64 & 0xFFFFFFFF0000003F);
	// 8249E84C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8249E850: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8249E854: 995F0026  stb r10, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[10].u8 ) };
	// 8249E858: B17F0020  sth r11, 0x20(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u16 ) };
	// 8249E85C: 4099008C  ble cr6, 0x8249e8e8
	if !ctx.cr[6].gt {
	pc = 0x8249E8E8; continue 'dispatch;
	}
	// 8249E860: 3B7D02C5  addi r27, r29, 0x2c5
	ctx.r[27].s64 = ctx.r[29].s64 + 709;
	// 8249E864: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	pc = 0x8249E868; continue 'dispatch;
            }
            0x8249E868 => {
    //   block [0x8249E868..0x8249E8B0)
	// 8249E868: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8249E86C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8249E870: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8249E874: 7FDC582E  lwzx r30, r28, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249E878: 38BE00E0  addi r5, r30, 0xe0
	ctx.r[5].s64 = ctx.r[30].s64 + 224;
	// 8249E87C: 4810AA9D  bl 0x825a9318
	ctx.lr = 0x8249E880;
	sub_825A9318(ctx, base);
	// 8249E880: 397E00D0  addi r11, r30, 0xd0
	ctx.r[11].s64 = ctx.r[30].s64 + 208;
	// 8249E884: B34B000A  sth r26, 0xa(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), ctx.r[26].u16 ) };
	// 8249E888: B34B000C  sth r26, 0xc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[26].u16 ) };
	// 8249E88C: 895D02C7  lbz r10, 0x2c7(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(711 as u32) ) } as u64;
	// 8249E890: 892B0009  lbz r9, 9(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(9 as u32) ) } as u64;
	// 8249E894: 554607BE  clrlwi r6, r10, 0x1e
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 8249E898: 88FB0001  lbz r7, 1(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(1 as u32) ) } as u64;
	// 8249E89C: 552507BE  clrlwi r5, r9, 0x1e
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 8249E8A0: 891B0000  lbz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E8A4: 7F062840  cmplw cr6, r6, r5
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8249E8A8: 40980008  bge cr6, 0x8249e8b0
	if !ctx.cr[6].lt {
	pc = 0x8249E8B0; continue 'dispatch;
	}
	// 8249E8AC: 7D0840F8  nor r8, r8, r8
	ctx.r[8].u64 = !(ctx.r[8].u64 | ctx.r[8].u64);
	pc = 0x8249E8B0; continue 'dispatch;
            }
            0x8249E8B0 => {
    //   block [0x8249E8B0..0x8249E8C8)
	// 8249E8B0: 55087022  slwi r8, r8, 0xe
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(14);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8249E8B4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8249E8B8: 40980010  bge cr6, 0x8249e8c8
	if !ctx.cr[6].lt {
	pc = 0x8249E8C8; continue 'dispatch;
	}
	// 8249E8BC: 7CEA38F8  nor r10, r7, r7
	ctx.r[10].u64 = !(ctx.r[7].u64 | ctx.r[7].u64);
	// 8249E8C0: 554A7022  slwi r10, r10, 0xe
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(14);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8249E8C4: 48000008  b 0x8249e8cc
	pc = 0x8249E8CC; continue 'dispatch;
            }
            0x8249E8C8 => {
    //   block [0x8249E8C8..0x8249E8CC)
	// 8249E8C8: 54EA7022  slwi r10, r7, 0xe
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(14);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x8249E8CC; continue 'dispatch;
            }
            0x8249E8CC => {
    //   block [0x8249E8CC..0x8249E8E8)
	// 8249E8CC: B10B000A  sth r8, 0xa(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), ctx.r[8].u16 ) };
	// 8249E8D0: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 8249E8D4: B14B000C  sth r10, 0xc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u16 ) };
	// 8249E8D8: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 8249E8DC: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249E8E0: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E8E4: 4198FF84  blt cr6, 0x8249e868
	if ctx.cr[6].lt {
	pc = 0x8249E868; continue 'dispatch;
	}
	pc = 0x8249E8E8; continue 'dispatch;
            }
            0x8249E8E8 => {
    //   block [0x8249E8E8..0x8249E940)
	// 8249E8E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249E8EC: 80DD006C  lwz r6, 0x6c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 8249E8F0: C05D0190  lfs f2, 0x190(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(400 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8249E8F4: C03F0044  lfs f1, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8249E8F8: 480195E1  bl 0x824b7ed8
	ctx.lr = 0x8249E8FC;
	sub_824B7ED8(ctx, base);
	// 8249E8FC: A15F0020  lhz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249E900: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8249E904: 419A003C  beq cr6, 0x8249e940
	if ctx.cr[6].eq {
	pc = 0x8249E940; continue 'dispatch;
	}
	// 8249E908: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E90C: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249E910: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E914: 810B004C  lwz r8, 0x4c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249E918: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 8249E91C: 40990024  ble cr6, 0x8249e940
	if !ctx.cr[6].gt {
	pc = 0x8249E940; continue 'dispatch;
	}
	// 8249E920: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 8249E924: B35F0020  sth r26, 0x20(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[26].u16 ) };
	// 8249E928: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8249E92C: B12B0020  sth r9, 0x20(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u16 ) };
	// 8249E930: 81390000  lwz r9, 0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E934: 93E90000  stw r31, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8249E938: 81390000  lwz r9, 0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E93C: 7D6A492E  stwx r11, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u32) };
	pc = 0x8249E940; continue 'dispatch;
            }
            0x8249E940 => {
    //   block [0x8249E940..0x8249E958)
	// 8249E940: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8249E944: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8249E948: 480063F1  bl 0x824a4d38
	ctx.lr = 0x8249E94C;
	sub_824A4D38(ctx, base);
	// 8249E94C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8249E950: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8249E954: 480967A4  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249E958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8249E958 size=396
    let mut pc: u32 = 0x8249E958;
    'dispatch: loop {
        match pc {
            0x8249E958 => {
    //   block [0x8249E958..0x8249E9A8)
	// 8249E958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249E95C: 48096751  bl 0x825350ac
	ctx.lr = 0x8249E960;
	sub_82535080(ctx, base);
	// 8249E960: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249E964: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8249E968: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8249E96C: 3B7D0190  addi r27, r29, 0x190
	ctx.r[27].s64 = ctx.r[29].s64 + 400;
	// 8249E970: 38C000D0  li r6, 0xd0
	ctx.r[6].s64 = 208;
	// 8249E974: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8249E978: 809F0048  lwz r4, 0x48(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8249E97C: 80BF004C  lwz r5, 0x4c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249E980: 4801D5E9  bl 0x824bbf68
	ctx.lr = 0x8249E984;
	sub_824BBF68(ctx, base);
	// 8249E984: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8249E988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249E98C: 409A001C  bne cr6, 0x8249e9a8
	if !ctx.cr[6].eq {
	pc = 0x8249E9A8; continue 'dispatch;
	}
	// 8249E990: 897F0026  lbz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249E994: 716B00CF  andi. r11, r11, 0xcf
	ctx.r[11].u64 = ctx.r[11].u64 & 207;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249E998: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 8249E99C: 997F0026  stb r11, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[11].u8 ) };
	// 8249E9A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8249E9A4: 48096758  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x8249E9A8 => {
    //   block [0x8249E9A8..0x8249E9CC)
	// 8249E9A8: 3BDD0034  addi r30, r29, 0x34
	ctx.r[30].s64 = ctx.r[29].s64 + 52;
	// 8249E9AC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249E9B0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E9B4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249E9B8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249E9BC: 409A0010  bne cr6, 0x8249e9cc
	if !ctx.cr[6].eq {
	pc = 0x8249E9CC; continue 'dispatch;
	}
	// 8249E9C0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8249E9C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8249E9C8: 4BFCF989  bl 0x8246e350
	ctx.lr = 0x8249E9CC;
	sub_8246E350(ctx, base);
	pc = 0x8249E9CC; continue 'dispatch;
            }
            0x8249E9CC => {
    //   block [0x8249E9CC..0x8249EA6C)
	// 8249E9CC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E9D0: 397D0028  addi r11, r29, 0x28
	ctx.r[11].s64 = ctx.r[29].s64 + 40;
	// 8249E9D4: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249E9D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8249E9DC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8249E9E0: 7FEA492E  stwx r31, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[31].u32) };
	// 8249E9E4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249E9E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8249E9EC: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8249E9F0: 813D002C  lwz r9, 0x2c(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 8249E9F4: 815D0028  lwz r10, 0x28(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8249E9F8: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8249E9FC: A11F0020  lhz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249EA00: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 8249EA04: 5508103E  rotlwi r8, r8, 2
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(2)) as u64;
	// 8249EA08: 8129FFFC  lwz r9, -4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8249EA0C: 7D28512E  stwx r9, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 8249EA10: A15F0020  lhz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249EA14: 813D0028  lwz r9, 0x28(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8249EA18: 5548103E  rotlwi r8, r10, 2
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 8249EA1C: 7D28482E  lwzx r9, r8, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8249EA20: B1490020  sth r10, 0x20(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[10].u16 ) };
	// 8249EA24: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249EA28: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8249EA2C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8249EA30: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 8249EA34: 895F0026  lbz r10, 0x26(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249EA38: 3D6B0001  addis r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 65536;
	// 8249EA3C: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249EA40: 554A06BE  clrlwi r10, r10, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 8249EA44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8249EA48: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8249EA4C: 995F0026  stb r10, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[10].u8 ) };
	// 8249EA50: B17F0020  sth r11, 0x20(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u16 ) };
	// 8249EA54: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249EA58: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8249EA5C: 4099006C  ble cr6, 0x8249eac8
	if !ctx.cr[6].gt {
	pc = 0x8249EAC8; continue 'dispatch;
	}
	// 8249EA60: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8249EA64: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8249EA68: 3B2B9F50  addi r25, r11, -0x60b0
	ctx.r[25].s64 = ctx.r[11].s64 + -24752;
	pc = 0x8249EA6C; continue 'dispatch;
            }
            0x8249EA6C => {
    //   block [0x8249EA6C..0x8249EAC8)
	// 8249EA6C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8249EA70: C03F0044  lfs f1, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8249EA74: 7FDA582E  lwzx r30, r26, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249EA78: 389E00E0  addi r4, r30, 0xe0
	ctx.r[4].s64 = ctx.r[30].s64 + 224;
	// 8249EA7C: 4810B065  bl 0x825a9ae0
	ctx.lr = 0x8249EA80;
	sub_825A9AE0(ctx, base);
	// 8249EA80: 817E00D0  lwz r11, 0xd0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 8249EA84: 3B7E00D0  addi r27, r30, 0xd0
	ctx.r[27].s64 = ctx.r[30].s64 + 208;
	// 8249EA88: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8249EA8C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8249EA90: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8249EA94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249EA98: 4E800421  bctrl
	ctx.lr = 0x8249EA9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8249EA9C: 817E00D0  lwz r11, 0xd0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 8249EAA0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8249EAA4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8249EAA8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 8249EAAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249EAB0: 4E800421  bctrl
	ctx.lr = 0x8249EAB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8249EAB4: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249EAB8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8249EABC: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 8249EAC0: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249EAC4: 4198FFA8  blt cr6, 0x8249ea6c
	if ctx.cr[6].lt {
	pc = 0x8249EA6C; continue 'dispatch;
	}
            }
            0x8249EAC8 => {
    //   block [0x8249EAC8..0x8249EAE4)
	// 8249EAC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8249EACC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8249EAD0: 48006481  bl 0x824a4f50
	ctx.lr = 0x8249EAD4;
	sub_824A4F50(ctx, base);
	// 8249EAD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8249EAD8: 4BFF44C1  bl 0x82492f98
	ctx.lr = 0x8249EADC;
	sub_82492F98(ctx, base);
	// 8249EADC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8249EAE0: 4809661C  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249EAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249EAE8 size=144
    let mut pc: u32 = 0x8249EAE8;
    'dispatch: loop {
        match pc {
            0x8249EAE8 => {
    //   block [0x8249EAE8..0x8249EB44)
	// 8249EAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249EAEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249EAF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8249EAF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8249EAF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249EAFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8249EB00: 897E0026  lbz r11, 0x26(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249EB04: A15E0022  lhz r10, 0x22(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(34 as u32) ) } as u64;
	// 8249EB08: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 8249EB0C: 716B00CF  andi. r11, r11, 0xcf
	ctx.r[11].u64 = ctx.r[11].u64 & 207;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249EB10: 997E0026  stb r11, 0x26(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(38 as u32), ctx.r[11].u8 ) };
	// 8249EB14: 409A004C  bne cr6, 0x8249eb60
	if !ctx.cr[6].eq {
	pc = 0x8249EB60; continue 'dispatch;
	}
	// 8249EB18: 81630044  lwz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 8249EB1C: 3BE30040  addi r31, r3, 0x40
	ctx.r[31].s64 = ctx.r[3].s64 + 64;
	// 8249EB20: B17E0022  sth r11, 0x22(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(34 as u32), ctx.r[11].u16 ) };
	// 8249EB24: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249EB28: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249EB2C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249EB30: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249EB34: 409A0010  bne cr6, 0x8249eb44
	if !ctx.cr[6].eq {
	pc = 0x8249EB44; continue 'dispatch;
	}
	// 8249EB38: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8249EB3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249EB40: 4BFCF811  bl 0x8246e350
	ctx.lr = 0x8249EB44;
	sub_8246E350(ctx, base);
	pc = 0x8249EB44; continue 'dispatch;
            }
            0x8249EB44 => {
    //   block [0x8249EB44..0x8249EB60)
	// 8249EB44: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249EB48: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249EB4C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249EB50: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 8249EB54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249EB58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249EB5C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x8249EB60; continue 'dispatch;
            }
            0x8249EB60 => {
    //   block [0x8249EB60..0x8249EB78)
	// 8249EB60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8249EB64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8249EB68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8249EB6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8249EB70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8249EB74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249EB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249EB78 size=148
    let mut pc: u32 = 0x8249EB78;
    'dispatch: loop {
        match pc {
            0x8249EB78 => {
    //   block [0x8249EB78..0x8249EBD8)
	// 8249EB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249EB7C: 48096541  bl 0x825350bc
	ctx.lr = 0x8249EB80;
	sub_82535080(ctx, base);
	// 8249EB80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249EB84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8249EB88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8249EB8C: 897E0026  lbz r11, 0x26(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249EB90: 716B00CF  andi. r11, r11, 0xcf
	ctx.r[11].u64 = ctx.r[11].u64 & 207;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249EB94: 997E0026  stb r11, 0x26(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(38 as u32), ctx.r[11].u8 ) };
	// 8249EB98: 807D00B0  lwz r3, 0xb0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(176 as u32) ) } as u64;
	// 8249EB9C: 4BFC75DD  bl 0x82466178
	ctx.lr = 0x8249EBA0;
	sub_82466178(ctx, base);
	// 8249EBA0: A17E0022  lhz r11, 0x22(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(34 as u32) ) } as u64;
	// 8249EBA4: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 8249EBA8: 409A004C  bne cr6, 0x8249ebf4
	if !ctx.cr[6].eq {
	pc = 0x8249EBF4; continue 'dispatch;
	}
	// 8249EBAC: 817D0044  lwz r11, 0x44(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) } as u64;
	// 8249EBB0: 3BFD0040  addi r31, r29, 0x40
	ctx.r[31].s64 = ctx.r[29].s64 + 64;
	// 8249EBB4: B17E0022  sth r11, 0x22(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(34 as u32), ctx.r[11].u16 ) };
	// 8249EBB8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249EBBC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249EBC0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249EBC4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249EBC8: 409A0010  bne cr6, 0x8249ebd8
	if !ctx.cr[6].eq {
	pc = 0x8249EBD8; continue 'dispatch;
	}
	// 8249EBCC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8249EBD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249EBD4: 4BFCF77D  bl 0x8246e350
	ctx.lr = 0x8249EBD8;
	sub_8246E350(ctx, base);
	pc = 0x8249EBD8; continue 'dispatch;
            }
            0x8249EBD8 => {
    //   block [0x8249EBD8..0x8249EBF4)
	// 8249EBD8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249EBDC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249EBE0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249EBE4: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 8249EBE8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249EBEC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249EBF0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x8249EBF4; continue 'dispatch;
            }
            0x8249EBF4 => {
    //   block [0x8249EBF4..0x8249EC0C)
	// 8249EBF4: 807D00B0  lwz r3, 0xb0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(176 as u32) ) } as u64;
	// 8249EBF8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8249EBFC: F9630020  std r11, 0x20(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 8249EC00: 4826E66D  bl 0x8270d26c
	ctx.lr = 0x8249EC04;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 8249EC04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8249EC08: 48096504  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249EC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249EC10 size=148
    let mut pc: u32 = 0x8249EC10;
    'dispatch: loop {
        match pc {
            0x8249EC10 => {
    //   block [0x8249EC10..0x8249EC70)
	// 8249EC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249EC14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249EC18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8249EC1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8249EC20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249EC24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8249EC28: 897E0026  lbz r11, 0x26(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249EC2C: A15E0022  lhz r10, 0x22(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(34 as u32) ) } as u64;
	// 8249EC30: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 8249EC34: 716B00CF  andi. r11, r11, 0xcf
	ctx.r[11].u64 = ctx.r[11].u64 & 207;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249EC38: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 8249EC3C: 997E0026  stb r11, 0x26(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(38 as u32), ctx.r[11].u8 ) };
	// 8249EC40: 409A004C  bne cr6, 0x8249ec8c
	if !ctx.cr[6].eq {
	pc = 0x8249EC8C; continue 'dispatch;
	}
	// 8249EC44: 81630044  lwz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 8249EC48: 3BE30040  addi r31, r3, 0x40
	ctx.r[31].s64 = ctx.r[3].s64 + 64;
	// 8249EC4C: B17E0022  sth r11, 0x22(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(34 as u32), ctx.r[11].u16 ) };
	// 8249EC50: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249EC54: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249EC58: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249EC5C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249EC60: 409A0010  bne cr6, 0x8249ec70
	if !ctx.cr[6].eq {
	pc = 0x8249EC70; continue 'dispatch;
	}
	// 8249EC64: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8249EC68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249EC6C: 4BFCF6E5  bl 0x8246e350
	ctx.lr = 0x8249EC70;
	sub_8246E350(ctx, base);
	pc = 0x8249EC70; continue 'dispatch;
            }
            0x8249EC70 => {
    //   block [0x8249EC70..0x8249EC8C)
	// 8249EC70: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249EC74: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249EC78: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249EC7C: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 8249EC80: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249EC84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249EC88: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x8249EC8C; continue 'dispatch;
            }
            0x8249EC8C => {
    //   block [0x8249EC8C..0x8249ECA4)
	// 8249EC8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8249EC90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8249EC94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8249EC98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8249EC9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8249ECA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249ECA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8249ECA8 size=1196
    let mut pc: u32 = 0x8249ECA8;
    'dispatch: loop {
        match pc {
            0x8249ECA8 => {
    //   block [0x8249ECA8..0x8249ED28)
	// 8249ECA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249ECAC: 480963F9  bl 0x825350a4
	ctx.lr = 0x8249ECB0;
	sub_82535080(ctx, base);
	// 8249ECB0: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 8249ECB4: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 8249ECB8: 9421FCD0  stwu r1, -0x330(r1)
	ea = ctx.r[1].u32.wrapping_add(-816 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249ECBC: 7CAB0774  extsb r11, r5
	ctx.r[11].s64 = ctx.r[5].s8 as i64;
	// 8249ECC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8249ECC4: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 8249ECC8: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 8249ECCC: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 8249ECD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249ECD4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8249ECD8: 419A01E0  beq cr6, 0x8249eeb8
	if ctx.cr[6].eq {
	pc = 0x8249EEB8; continue 'dispatch;
	}
	// 8249ECDC: 7F2B0774  extsb r11, r25
	ctx.r[11].s64 = ctx.r[25].s8 as i64;
	// 8249ECE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249ECE4: 409A00CC  bne cr6, 0x8249edb0
	if !ctx.cr[6].eq {
	pc = 0x8249EDB0; continue 'dispatch;
	}
	// 8249ECE8: 3BBF00D0  addi r29, r31, 0xd0
	ctx.r[29].s64 = ctx.r[31].s64 + 208;
	// 8249ECEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8249ECF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249ECF4: 83DD0118  lwz r30, 0x118(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(280 as u32) ) } as u64;
	// 8249ECF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8249ECFC: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 8249ED00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249ED04: 4E800421  bctrl
	ctx.lr = 0x8249ED08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8249ED08: B39E000A  sth r28, 0xa(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(10 as u32), ctx.r[28].u16 ) };
	// 8249ED0C: B39E000C  sth r28, 0xc(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u16 ) };
	// 8249ED10: 39600012  li r11, 0x12
	ctx.r[11].s64 = 18;
	// 8249ED14: A15D011C  lhz r10, 0x11c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(284 as u32) ) } as u64;
	// 8249ED18: B15F002A  sth r10, 0x2a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(42 as u32), ctx.r[10].u16 ) };
	// 8249ED1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249ED20: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 8249ED24: 395F00D8  addi r10, r31, 0xd8
	ctx.r[10].s64 = ctx.r[31].s64 + 216;
            }
            0x8249ED28 => {
    //   block [0x8249ED28..0x8249EDA0)
	// 8249ED28: 812BFFF8  lwz r9, -8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8249ED2C: 912AFFF8  stw r9, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[9].u32 ) };
	// 8249ED30: 812BFFFC  lwz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8249ED34: 912AFFFC  stw r9, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 8249ED38: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249ED3C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8249ED40: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249ED44: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 8249ED48: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8249ED4C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 8249ED50: 4200FFD8  bdnz 0x8249ed28
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8249ED28; continue 'dispatch;
	}
	// 8249ED54: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8249ED58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8249ED5C: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 8249ED60: 4BFCB5D9  bl 0x8246a338
	ctx.lr = 0x8249ED64;
	sub_8246A338(ctx, base);
	// 8249ED64: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249ED68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249ED6C: 419A0034  beq cr6, 0x8249eda0
	if ctx.cr[6].eq {
	pc = 0x8249EDA0; continue 'dispatch;
	}
	// 8249ED70: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 8249ED74: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8249ED78: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8249ED7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249ED80: B17E0006  sth r11, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 8249ED84: 409A001C  bne cr6, 0x8249eda0
	if !ctx.cr[6].eq {
	pc = 0x8249EDA0; continue 'dispatch;
	}
	// 8249ED88: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249ED8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8249ED90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8249ED94: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249ED98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249ED9C: 4E800421  bctrl
	ctx.lr = 0x8249EDA0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8249EDA0 => {
    //   block [0x8249EDA0..0x8249EDB0)
	// 8249EDA0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8249EDA4: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8249EDA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249EDAC: 4BFEF235  bl 0x8248dfe0
	ctx.lr = 0x8249EDB0;
	sub_8248DFE0(ctx, base);
	pc = 0x8249EDB0; continue 'dispatch;
            }
            0x8249EDB0 => {
    //   block [0x8249EDB0..0x8249EDFC)
	// 8249EDB0: 897F00D8  lbz r11, 0xd8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 8249EDB4: 7F0BB800  cmpw cr6, r11, r23
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[23].s32, &mut ctx.xer);
	// 8249EDB8: 419A0318  beq cr6, 0x8249f0d0
	if ctx.cr[6].eq {
	pc = 0x8249F0D0; continue 'dispatch;
	}
	// 8249EDBC: 2F170001  cmpwi cr6, r23, 1
	ctx.cr[6].compare_i32(ctx.r[23].s32, 1, &mut ctx.xer);
	// 8249EDC0: 419A0310  beq cr6, 0x8249f0d0
	if ctx.cr[6].eq {
	pc = 0x8249F0D0; continue 'dispatch;
	}
	// 8249EDC4: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 8249EDC8: 93810298  stw r28, 0x298(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(664 as u32), ctx.r[28].u32 ) };
	// 8249EDCC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8249EDD0: 394AC9AC  addi r10, r10, -0x3654
	ctx.r[10].s64 = ctx.r[10].s64 + -13908;
	// 8249EDD4: 39600012  li r11, 0x12
	ctx.r[11].s64 = 18;
	// 8249EDD8: B1210186  sth r9, 0x186(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(390 as u32), ctx.r[9].u16 ) };
	// 8249EDDC: 91410180  stw r10, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[10].u32 ) };
	// 8249EDE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249EDE4: 3BDF00D0  addi r30, r31, 0xd0
	ctx.r[30].s64 = ctx.r[31].s64 + 208;
	// 8249EDE8: 39210188  addi r9, r1, 0x188
	ctx.r[9].s64 = ctx.r[1].s64 + 392;
	// 8249EDEC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8249EDF0: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 8249EDF4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8249EDF8: 394AFF30  addi r10, r10, -0xd0
	ctx.r[10].s64 = ctx.r[10].s64 + -208;
	pc = 0x8249EDFC; continue 'dispatch;
            }
            0x8249EDFC => {
    //   block [0x8249EDFC..0x8249EEB8)
	// 8249EDFC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249EE00: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249EE04: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249EE08: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8249EE0C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 8249EE10: 912AFFF8  stw r9, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[9].u32 ) };
	// 8249EE14: 910AFFFC  stw r8, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[8].u32 ) };
	// 8249EE18: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8249EE1C: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8249EE20: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 8249EE24: 4200FFD8  bdnz 0x8249edfc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8249EDFC; continue 'dispatch;
	}
	// 8249EE28: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249EE2C: 388102A0  addi r4, r1, 0x2a0
	ctx.r[4].s64 = ctx.r[1].s64 + 672;
	// 8249EE30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8249EE34: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8249EE38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249EE3C: 4E800421  bctrl
	ctx.lr = 0x8249EE40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8249EE40: 8941023D  lbz r10, 0x23d(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(573 as u32) ) } as u64;
	// 8249EE44: 8921023C  lbz r9, 0x23c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(572 as u32) ) } as u64;
	// 8249EE48: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8249EE4C: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 8249EE50: 396B9720  addi r11, r11, -0x68e0
	ctx.r[11].s64 = ctx.r[11].s64 + -26848;
	// 8249EE54: 5529103E  rotlwi r9, r9, 2
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(2)) as u64;
	// 8249EE58: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 8249EE5C: 3BA10210  addi r29, r1, 0x210
	ctx.r[29].s64 = ctx.r[1].s64 + 528;
	// 8249EE60: 3B8102A0  addi r28, r1, 0x2a0
	ctx.r[28].s64 = ctx.r[1].s64 + 672;
	// 8249EE64: 7FEA5C2E  lfsx f31, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8249EE68: 7FC95C2E  lfsx f30, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8249EE6C: 4BFFC6CD  bl 0x8249b538
	ctx.lr = 0x8249EE70;
	sub_8249B538(ctx, base);
	// 8249EE70: 38A10200  addi r5, r1, 0x200
	ctx.r[5].s64 = ctx.r[1].s64 + 512;
	// 8249EE74: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8249EE78: 388101C0  addi r4, r1, 0x1c0
	ctx.r[4].s64 = ctx.r[1].s64 + 448;
	// 8249EE7C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8249EE80: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 8249EE84: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 8249EE88: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8249EE8C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 8249EE90: 4BFF0F19  bl 0x8248fda8
	ctx.lr = 0x8249EE94;
	sub_8248FDA8(ctx, base);
	// 8249EE94: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 8249EE98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8249EE9C: 4BFFC805  bl 0x8249b6a0
	ctx.lr = 0x8249EEA0;
	sub_8249B6A0(ctx, base);
	// 8249EEA0: C0010234  lfs f0, 0x234(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249EEA4: D01E00B4  stfs f0, 0xb4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8249EEA8: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 8249EEAC: C0010238  lfs f0, 0x238(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249EEB0: D01E00B8  stfs f0, 0xb8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8249EEB4: 48000218  b 0x8249f0cc
	pc = 0x8249F0CC; continue 'dispatch;
            }
            0x8249EEB8 => {
    //   block [0x8249EEB8..0x8249EEF0)
	// 8249EEB8: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 8249EEBC: 93810178  stw r28, 0x178(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[28].u32 ) };
	// 8249EEC0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 8249EEC4: 3BCAC9AC  addi r30, r10, -0x3654
	ctx.r[30].s64 = ctx.r[10].s64 + -13908;
	// 8249EEC8: 39600012  li r11, 0x12
	ctx.r[11].s64 = 18;
	// 8249EECC: B3410066  sth r26, 0x66(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[26].u16 ) };
	// 8249EED0: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 8249EED4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249EED8: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 8249EEDC: 39210068  addi r9, r1, 0x68
	ctx.r[9].s64 = ctx.r[1].s64 + 104;
	// 8249EEE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8249EEE4: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 8249EEE8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8249EEEC: 394AFF30  addi r10, r10, -0xd0
	ctx.r[10].s64 = ctx.r[10].s64 + -208;
	pc = 0x8249EEF0; continue 'dispatch;
            }
            0x8249EEF0 => {
    //   block [0x8249EEF0..0x8249EF40)
	// 8249EEF0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249EEF4: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249EEF8: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249EEFC: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8249EF00: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 8249EF04: 912AFFF8  stw r9, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[9].u32 ) };
	// 8249EF08: 910AFFFC  stw r8, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[8].u32 ) };
	// 8249EF0C: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8249EF10: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8249EF14: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 8249EF18: 4200FFD8  bdnz 0x8249eef0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8249EEF0; continue 'dispatch;
	}
	// 8249EF1C: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 8249EF20: 409A008C  bne cr6, 0x8249efac
	if !ctx.cr[6].eq {
	pc = 0x8249EFAC; continue 'dispatch;
	}
	// 8249EF24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8249EF28: 419A0018  beq cr6, 0x8249ef40
	if ctx.cr[6].eq {
	pc = 0x8249EF40; continue 'dispatch;
	}
	// 8249EF2C: 38BF0150  addi r5, r31, 0x150
	ctx.r[5].s64 = ctx.r[31].s64 + 336;
	// 8249EF30: 389F0110  addi r4, r31, 0x110
	ctx.r[4].s64 = ctx.r[31].s64 + 272;
	// 8249EF34: 4BFFE8DD  bl 0x8249d810
	ctx.lr = 0x8249EF38;
	sub_8249D810(ctx, base);
	// 8249EF38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8249EF3C: 48000008  b 0x8249ef44
	pc = 0x8249EF44; continue 'dispatch;
            }
            0x8249EF40 => {
    //   block [0x8249EF40..0x8249EF44)
	// 8249EF40: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	pc = 0x8249EF44; continue 'dispatch;
            }
            0x8249EF44 => {
    //   block [0x8249EF44..0x8249EF8C)
	// 8249EF44: 3B7D0010  addi r27, r29, 0x10
	ctx.r[27].s64 = ctx.r[29].s64 + 16;
	// 8249EF48: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8249EF4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8249EF50: 4BFFC821  bl 0x8249b770
	ctx.lr = 0x8249EF54;
	sub_8249B770(ctx, base);
	// 8249EF54: 89610069  lbz r11, 0x69(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(105 as u32) ) } as u64;
	// 8249EF58: 997D0009  stb r11, 9(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(9 as u32), ctx.r[11].u8 ) };
	// 8249EF5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8249EF60: C1A100CC  lfs f13, 0xcc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249EF64: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249EF68: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8249EF6C: 419A006C  beq cr6, 0x8249efd8
	if ctx.cr[6].eq {
	pc = 0x8249EFD8; continue 'dispatch;
	}
	// 8249EF70: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 8249EF74: 419A0018  beq cr6, 0x8249ef8c
	if ctx.cr[6].eq {
	pc = 0x8249EF8C; continue 'dispatch;
	}
	// 8249EF78: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 8249EF7C: 4BFF3F4D  bl 0x82492ec8
	ctx.lr = 0x8249EF80;
	sub_82492EC8(ctx, base);
	// 8249EF80: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8249EF84: 4810AB5D  bl 0x825a9ae0
	ctx.lr = 0x8249EF88;
	sub_825A9AE0(ctx, base);
	// 8249EF88: 48000050  b 0x8249efd8
	pc = 0x8249EFD8; continue 'dispatch;
            }
            0x8249EF8C => {
    //   block [0x8249EF8C..0x8249EFAC)
	// 8249EF8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8249EF90: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8249EF94: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8249EF98: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8249EF9C: C1A100BC  lfs f13, 0xbc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8249EFA0: EC20682A  fadds f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8249EFA4: 4810AB3D  bl 0x825a9ae0
	ctx.lr = 0x8249EFA8;
	sub_825A9AE0(ctx, base);
	// 8249EFA8: 48000030  b 0x8249efd8
	pc = 0x8249EFD8; continue 'dispatch;
            }
            0x8249EFAC => {
    //   block [0x8249EFAC..0x8249EFC8)
	// 8249EFAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8249EFB0: 419A0018  beq cr6, 0x8249efc8
	if ctx.cr[6].eq {
	pc = 0x8249EFC8; continue 'dispatch;
	}
	// 8249EFB4: 38BF0150  addi r5, r31, 0x150
	ctx.r[5].s64 = ctx.r[31].s64 + 336;
	// 8249EFB8: 389F0110  addi r4, r31, 0x110
	ctx.r[4].s64 = ctx.r[31].s64 + 272;
	// 8249EFBC: 4BFFD15D  bl 0x8249c118
	ctx.lr = 0x8249EFC0;
	sub_8249C118(ctx, base);
	// 8249EFC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8249EFC4: 48000008  b 0x8249efcc
	pc = 0x8249EFCC; continue 'dispatch;
            }
            0x8249EFC8 => {
    //   block [0x8249EFC8..0x8249EFCC)
	// 8249EFC8: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	pc = 0x8249EFCC; continue 'dispatch;
            }
            0x8249EFCC => {
    //   block [0x8249EFCC..0x8249EFD8)
	// 8249EFCC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8249EFD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8249EFD4: 4BFFC6CD  bl 0x8249b6a0
	ctx.lr = 0x8249EFD8;
	sub_8249B6A0(ctx, base);
	pc = 0x8249EFD8; continue 'dispatch;
            }
            0x8249EFD8 => {
    //   block [0x8249EFD8..0x8249F038)
	// 8249EFD8: 7F2B0774  extsb r11, r25
	ctx.r[11].s64 = ctx.r[25].s8 as i64;
	// 8249EFDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249EFE0: 419A00AC  beq cr6, 0x8249f08c
	if ctx.cr[6].eq {
	pc = 0x8249F08C; continue 'dispatch;
	}
	// 8249EFE4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249EFE8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8249EFEC: 38A0002E  li r5, 0x2e
	ctx.r[5].s64 = 46;
	// 8249EFF0: 38800120  li r4, 0x120
	ctx.r[4].s64 = 288;
	// 8249EFF4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249EFF8: 4BFC5041  bl 0x82464038
	ctx.lr = 0x8249EFFC;
	sub_82464038(ctx, base);
	// 8249EFFC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8249F000: 39200120  li r9, 0x120
	ctx.r[9].s64 = 288;
	// 8249F004: 39400012  li r10, 0x12
	ctx.r[10].s64 = 18;
	// 8249F008: 5526043E  clrlwi r6, r9, 0x10
	ctx.r[6].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 8249F00C: B34B0006  sth r26, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[26].u16 ) };
	// 8249F010: B12B0004  sth r9, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 8249F014: 938B0118  stw r28, 0x118(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(280 as u32), ctx.r[28].u32 ) };
	// 8249F018: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8249F01C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8249F020: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 8249F024: 38E10064  addi r7, r1, 0x64
	ctx.r[7].s64 = ctx.r[1].s64 + 100;
	// 8249F028: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 8249F02C: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 8249F030: 7D0B4050  subf r8, r11, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 8249F034: 7CEB3850  subf r7, r11, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	pc = 0x8249F038; continue 'dispatch;
            }
            0x8249F038 => {
    //   block [0x8249F038..0x8249F08C)
	// 8249F038: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F03C: 90AAFFF8  stw r5, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[5].u32 ) };
	// 8249F040: 80A90004  lwz r5, 4(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F044: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 8249F048: 90AAFFFC  stw r5, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[5].u32 ) };
	// 8249F04C: 7CA8502E  lwzx r5, r8, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8249F050: 90AA0000  stw r5, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 8249F054: 7CA7502E  lwzx r5, r7, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8249F058: 90AA0004  stw r5, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 8249F05C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 8249F060: 4200FFD8  bdnz 0x8249f038
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8249F038; continue 'dispatch;
	}
	// 8249F064: B0CB0004  sth r6, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u16 ) };
	// 8249F068: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8249F06C: B34B0006  sth r26, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[26].u16 ) };
	// 8249F070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249F074: 917D0118  stw r11, 0x118(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 8249F078: A17F002A  lhz r11, 0x2a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 8249F07C: B17D011C  sth r11, 0x11c(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(284 as u32), ctx.r[11].u16 ) };
	// 8249F080: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8249F084: 4BFEEF5D  bl 0x8248dfe0
	ctx.lr = 0x8249F088;
	sub_8248DFE0(ctx, base);
	// 8249F088: 48000024  b 0x8249f0ac
	pc = 0x8249F0AC; continue 'dispatch;
            }
            0x8249F08C => {
    //   block [0x8249F08C..0x8249F0AC)
	// 8249F08C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F090: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8249F094: 80810178  lwz r4, 0x178(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) } as u64;
	// 8249F098: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 8249F09C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249F0A0: 4E800421  bctrl
	ctx.lr = 0x8249F0A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8249F0A4: A161017C  lhz r11, 0x17c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(380 as u32) ) } as u64;
	// 8249F0A8: B17D011C  sth r11, 0x11c(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(284 as u32), ctx.r[11].u16 ) };
            }
            0x8249F0AC => {
    //   block [0x8249F0AC..0x8249F0CC)
	// 8249F0AC: 3977FFF9  addi r11, r23, -7
	ctx.r[11].s64 = ctx.r[23].s64 + -7;
	// 8249F0B0: 939F0090  stw r28, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 8249F0B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8249F0B8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8249F0BC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8249F0C0: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 8249F0C4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249F0C8: B17F002A  sth r11, 0x2a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(42 as u32), ctx.r[11].u16 ) };
	pc = 0x8249F0CC; continue 'dispatch;
            }
            0x8249F0CC => {
    //   block [0x8249F0CC..0x8249F0D0)
	// 8249F0CC: 4BFFD0B5  bl 0x8249c180
	ctx.lr = 0x8249F0D0;
	sub_8249C180(ctx, base);
	pc = 0x8249F0D0; continue 'dispatch;
            }
            0x8249F0D0 => {
    //   block [0x8249F0D0..0x8249F108)
	// 8249F0D0: 397F00E0  addi r11, r31, 0xe0
	ctx.r[11].s64 = ctx.r[31].s64 + 224;
	// 8249F0D4: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 8249F0D8: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8249F0DC: 419A0068  beq cr6, 0x8249f144
	if ctx.cr[6].eq {
	pc = 0x8249F144; continue 'dispatch;
	}
	// 8249F0E0: 397801A0  addi r11, r24, 0x1a0
	ctx.r[11].s64 = ctx.r[24].s64 + 416;
	// 8249F0E4: 893F00D9  lbz r9, 0xd9(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(217 as u32) ) } as u64;
	// 8249F0E8: 552607BE  clrlwi r6, r9, 0x1e
	ctx.r[6].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 8249F0EC: 894B0127  lbz r10, 0x127(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(295 as u32) ) } as u64;
	// 8249F0F0: 890B0126  lbz r8, 0x126(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(294 as u32) ) } as u64;
	// 8249F0F4: 554707BE  clrlwi r7, r10, 0x1e
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 8249F0F8: 896B0125  lbz r11, 0x125(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(293 as u32) ) } as u64;
	// 8249F0FC: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8249F100: 40980008  bge cr6, 0x8249f108
	if !ctx.cr[6].lt {
	pc = 0x8249F108; continue 'dispatch;
	}
	// 8249F104: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	pc = 0x8249F108; continue 'dispatch;
            }
            0x8249F108 => {
    //   block [0x8249F108..0x8249F120)
	// 8249F108: 55677022  slwi r7, r11, 0xe
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(14);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8249F10C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8249F110: 40980010  bge cr6, 0x8249f120
	if !ctx.cr[6].lt {
	pc = 0x8249F120; continue 'dispatch;
	}
	// 8249F114: 7D0B40F8  nor r11, r8, r8
	ctx.r[11].u64 = !(ctx.r[8].u64 | ctx.r[8].u64);
	// 8249F118: 556B7022  slwi r11, r11, 0xe
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(14);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249F11C: 48000008  b 0x8249f124
	pc = 0x8249F124; continue 'dispatch;
            }
            0x8249F120 => {
    //   block [0x8249F120..0x8249F124)
	// 8249F120: 550B7022  slwi r11, r8, 0xe
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(14);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x8249F124; continue 'dispatch;
            }
            0x8249F124 => {
    //   block [0x8249F124..0x8249F144)
	// 8249F124: A15F00DA  lhz r10, 0xda(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(218 as u32) ) } as u64;
	// 8249F128: A13F00DC  lhz r9, 0xdc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 8249F12C: 554A04BE  clrlwi r10, r10, 0x12
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00003FFFu64;
	// 8249F130: 552904BE  clrlwi r9, r9, 0x12
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00003FFFu64;
	// 8249F134: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 8249F138: 7D2B5B78  or r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 8249F13C: B15F00DA  sth r10, 0xda(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(218 as u32), ctx.r[10].u16 ) };
	// 8249F140: B17F00DC  sth r11, 0xdc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u16 ) };
	pc = 0x8249F144; continue 'dispatch;
            }
            0x8249F144 => {
    //   block [0x8249F144..0x8249F154)
	// 8249F144: 38210330  addi r1, r1, 0x330
	ctx.r[1].s64 = ctx.r[1].s64 + 816;
	// 8249F148: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 8249F14C: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 8249F150: 48095FA4  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249F158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249F158 size=140
    let mut pc: u32 = 0x8249F158;
    'dispatch: loop {
        match pc {
            0x8249F158 => {
    //   block [0x8249F158..0x8249F1CC)
	// 8249F158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249F15C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8249F160: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8249F164: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8249F168: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249F16C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8249F170: 83E400B8  lwz r31, 0xb8(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(184 as u32) ) } as u64;
	// 8249F174: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8249F178: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249F17C: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8249F180: 480174A9  bl 0x824b6628
	ctx.lr = 0x8249F184;
	sub_824B6628(ctx, base);
	// 8249F184: A17F0020  lhz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249F188: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 8249F18C: 419A0040  beq cr6, 0x8249f1cc
	if ctx.cr[6].eq {
	pc = 0x8249F1CC; continue 'dispatch;
	}
	// 8249F190: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249F194: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249F198: 409A0034  bne cr6, 0x8249f1cc
	if !ctx.cr[6].eq {
	pc = 0x8249F1CC; continue 'dispatch;
	}
	// 8249F19C: 897E00B8  lbz r11, 0xb8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) } as u64;
	// 8249F1A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249F1A4: 419A0028  beq cr6, 0x8249f1cc
	if ctx.cr[6].eq {
	pc = 0x8249F1CC; continue 'dispatch;
	}
	// 8249F1A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8249F1AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8249F1B0: 4BFFF0E9  bl 0x8249e298
	ctx.lr = 0x8249F1B4;
	sub_8249E298(ctx, base);
	// 8249F1B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F1B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8249F1BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249F1C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F1C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249F1C8: 4E800421  bctrl
	ctx.lr = 0x8249F1CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8249F1CC => {
    //   block [0x8249F1CC..0x8249F1E4)
	// 8249F1CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8249F1D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8249F1D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8249F1D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8249F1DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8249F1E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249F1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249F1E8 size=464
    let mut pc: u32 = 0x8249F1E8;
    'dispatch: loop {
        match pc {
            0x8249F1E8 => {
    //   block [0x8249F1E8..0x8249F234)
	// 8249F1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249F1EC: 48095EC1  bl 0x825350ac
	ctx.lr = 0x8249F1F0;
	sub_82535080(ctx, base);
	// 8249F1F0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249F1F4: 3961005C  addi r11, r1, 0x5c
	ctx.r[11].s64 = ctx.r[1].s64 + 92;
	// 8249F1F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8249F1FC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8249F200: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 8249F204: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8249F208: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8249F20C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8249F210: A15E01FC  lhz r10, 0x1fc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 8249F214: 839E00B8  lwz r28, 0xb8(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) } as u64;
	// 8249F218: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8249F21C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8249F220: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 8249F224: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 8249F228: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8249F22C: 419A015C  beq cr6, 0x8249f388
	if ctx.cr[6].eq {
	pc = 0x8249F388; continue 'dispatch;
	}
	// 8249F230: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8249F234; continue 'dispatch;
            }
            0x8249F234 => {
    //   block [0x8249F234..0x8249F26C)
	// 8249F234: 817E01F8  lwz r11, 0x1f8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(504 as u32) ) } as u64;
	// 8249F238: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8249F23C: 7FFD582E  lwzx r31, r29, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249F240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249F244: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F248: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8249F24C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249F250: 4E800421  bctrl
	ctx.lr = 0x8249F254;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8249F254: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8249F258: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8249F25C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8249F260: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8249F264: 4099003C  ble cr6, 0x8249f2a0
	if !ctx.cr[6].gt {
	pc = 0x8249F2A0; continue 'dispatch;
	}
	// 8249F268: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
            }
            0x8249F26C => {
    //   block [0x8249F26C..0x8249F288)
	// 8249F26C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F270: 88E700D8  lbz r7, 0xd8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(216 as u32) ) } as u64;
	// 8249F274: 2B070007  cmplwi cr6, r7, 7
	ctx.cr[6].compare_u32(ctx.r[7].u32, 7 as u32, &mut ctx.xer);
	// 8249F278: 419A0010  beq cr6, 0x8249f288
	if ctx.cr[6].eq {
	pc = 0x8249F288; continue 'dispatch;
	}
	// 8249F27C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F280: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8249F284: 409A0018  bne cr6, 0x8249f29c
	if !ctx.cr[6].eq {
	pc = 0x8249F29C; continue 'dispatch;
	}
	pc = 0x8249F288; continue 'dispatch;
            }
            0x8249F288 => {
    //   block [0x8249F288..0x8249F29C)
	// 8249F288: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8249F28C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8249F290: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8249F294: 4198FFD8  blt cr6, 0x8249f26c
	if ctx.cr[6].lt {
	pc = 0x8249F26C; continue 'dispatch;
	}
	// 8249F298: 48000008  b 0x8249f2a0
	pc = 0x8249F2A0; continue 'dispatch;
            }
            0x8249F29C => {
    //   block [0x8249F29C..0x8249F2A0)
	// 8249F29C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x8249F2A0; continue 'dispatch;
            }
            0x8249F2A0 => {
    //   block [0x8249F2A0..0x8249F2CC)
	// 8249F2A0: 7D0B0774  extsb r11, r8
	ctx.r[11].s64 = ctx.r[8].s8 as i64;
	// 8249F2A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249F2A8: 419A00C8  beq cr6, 0x8249f370
	if ctx.cr[6].eq {
	pc = 0x8249F370; continue 'dispatch;
	}
	// 8249F2AC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249F2B0: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F2B4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249F2B8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249F2BC: 409A0010  bne cr6, 0x8249f2cc
	if !ctx.cr[6].eq {
	pc = 0x8249F2CC; continue 'dispatch;
	}
	// 8249F2C0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8249F2C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8249F2C8: 4BFCF089  bl 0x8246e350
	ctx.lr = 0x8249F2CC;
	sub_8246E350(ctx, base);
	pc = 0x8249F2CC; continue 'dispatch;
            }
            0x8249F2CC => {
    //   block [0x8249F2CC..0x8249F300)
	// 8249F2CC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F2D0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F2D4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249F2D8: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 8249F2DC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F2E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249F2E4: 917B0004  stw r11, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8249F2E8: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F2EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249F2F0: 419A0010  beq cr6, 0x8249f300
	if ctx.cr[6].eq {
	pc = 0x8249F300; continue 'dispatch;
	}
	// 8249F2F4: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 8249F2F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249F2FC: B17F0006  sth r11, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x8249F300; continue 'dispatch;
            }
            0x8249F300 => {
    //   block [0x8249F300..0x8249F354)
	// 8249F300: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8249F304: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8249F308: 48017389  bl 0x824b6690
	ctx.lr = 0x8249F30C;
	sub_824B6690(ctx, base);
	// 8249F30C: 897C0025  lbz r11, 0x25(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(37 as u32) ) } as u64;
	// 8249F310: A15C0022  lhz r10, 0x22(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(34 as u32) ) } as u64;
	// 8249F314: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 8249F318: 716B00F3  andi. r11, r11, 0xf3
	ctx.r[11].u64 = ctx.r[11].u64 & 243;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249F31C: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 8249F320: 997C0025  stb r11, 0x25(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 8249F324: 409A004C  bne cr6, 0x8249f370
	if !ctx.cr[6].eq {
	pc = 0x8249F370; continue 'dispatch;
	}
	// 8249F328: 81790044  lwz r11, 0x44(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(68 as u32) ) } as u64;
	// 8249F32C: 3BF90040  addi r31, r25, 0x40
	ctx.r[31].s64 = ctx.r[25].s64 + 64;
	// 8249F330: B17C0022  sth r11, 0x22(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(34 as u32), ctx.r[11].u16 ) };
	// 8249F334: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249F338: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F33C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249F340: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249F344: 409A0010  bne cr6, 0x8249f354
	if !ctx.cr[6].eq {
	pc = 0x8249F354; continue 'dispatch;
	}
	// 8249F348: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8249F34C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249F350: 4BFCF001  bl 0x8246e350
	ctx.lr = 0x8249F354;
	sub_8246E350(ctx, base);
	pc = 0x8249F354; continue 'dispatch;
            }
            0x8249F354 => {
    //   block [0x8249F354..0x8249F370)
	// 8249F354: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F358: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F35C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249F360: 7F8B512E  stwx r28, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[28].u32) };
	// 8249F364: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F368: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249F36C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x8249F370; continue 'dispatch;
            }
            0x8249F370 => {
    //   block [0x8249F370..0x8249F388)
	// 8249F370: A17E01FC  lhz r11, 0x1fc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 8249F374: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 8249F378: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8249F37C: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249F380: 4198FEB4  blt cr6, 0x8249f234
	if ctx.cr[6].lt {
	pc = 0x8249F234; continue 'dispatch;
	}
	// 8249F384: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x8249F388; continue 'dispatch;
            }
            0x8249F388 => {
    //   block [0x8249F388..0x8249F3B0)
	// 8249F388: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8249F38C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8249F390: 409A0020  bne cr6, 0x8249f3b0
	if !ctx.cr[6].eq {
	pc = 0x8249F3B0; continue 'dispatch;
	}
	// 8249F394: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F398: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8249F39C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 8249F3A0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8249F3A4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8249F3A8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8249F3AC: 4BFC4D0D  bl 0x824640b8
	ctx.lr = 0x8249F3B0;
	sub_824640B8(ctx, base);
	pc = 0x8249F3B0; continue 'dispatch;
            }
            0x8249F3B0 => {
    //   block [0x8249F3B0..0x8249F3B8)
	// 8249F3B0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8249F3B4: 48095D48  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249F3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249F3B8 size=488
    let mut pc: u32 = 0x8249F3B8;
    'dispatch: loop {
        match pc {
            0x8249F3B8 => {
    //   block [0x8249F3B8..0x8249F40C)
	// 8249F3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249F3BC: 48095CED  bl 0x825350a8
	ctx.lr = 0x8249F3C0;
	sub_82535080(ctx, base);
	// 8249F3C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249F3C4: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 8249F3C8: 834D0000  lwz r26, 0(r13)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F3CC: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 8249F3D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8249F3D4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8249F3D8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8249F3DC: 83B80004  lwz r29, 4(r24)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F3E0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 8249F3E4: 7D7BD02E  lwzx r11, r27, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 8249F3E8: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 8249F3EC: 55441036  rlwinm r4, r10, 2, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 8249F3F0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249F3F4: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8249F3F8: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 8249F3FC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8249F400: 4199000C  bgt cr6, 0x8249f40c
	if ctx.cr[6].gt {
	pc = 0x8249F40C; continue 'dispatch;
	}
	// 8249F404: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 8249F408: 4800001C  b 0x8249f424
	pc = 0x8249F424; continue 'dispatch;
            }
            0x8249F40C => {
    //   block [0x8249F40C..0x8249F424)
	// 8249F40C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F410: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8249F414: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8249F418: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249F41C: 4E800421  bctrl
	ctx.lr = 0x8249F420;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8249F420: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            0x8249F424 => {
    //   block [0x8249F424..0x8249F43C)
	// 8249F424: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8249F428: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8249F42C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8249F430: 40990024  ble cr6, 0x8249f454
	if !ctx.cr[6].gt {
	pc = 0x8249F454; continue 'dispatch;
	}
	// 8249F434: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8249F438: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8249F43C; continue 'dispatch;
            }
            0x8249F43C => {
    //   block [0x8249F43C..0x8249F454)
	// 8249F43C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8249F440: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8249F444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249F448: 7C8A492E  stwx r4, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[4].u32) };
	// 8249F44C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8249F450: 409AFFEC  bne cr6, 0x8249f43c
	if !ctx.cr[6].eq {
	pc = 0x8249F43C; continue 'dispatch;
	}
	pc = 0x8249F454; continue 'dispatch;
            }
            0x8249F454 => {
    //   block [0x8249F454..0x8249F470)
	// 8249F454: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F458: 38FF02C5  addi r7, r31, 0x2c5
	ctx.r[7].s64 = ctx.r[31].s64 + 709;
	// 8249F45C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 8249F460: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8249F464: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249F468: 40990090  ble cr6, 0x8249f4f8
	if !ctx.cr[6].gt {
	pc = 0x8249F4F8; continue 'dispatch;
	}
	// 8249F46C: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	pc = 0x8249F470; continue 'dispatch;
            }
            0x8249F470 => {
    //   block [0x8249F470..0x8249F490)
	// 8249F470: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F474: 89270001  lbz r9, 1(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(1 as u32) ) } as u64;
	// 8249F478: 7D48582E  lwzx r10, r8, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249F47C: A16A00DC  lhz r11, 0xdc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(220 as u32) ) } as u64;
	// 8249F480: 7D637670  srawi r3, r11, 0xe
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 14) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 14) as i64;
	// 8249F484: 7F091800  cmpw cr6, r9, r3
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[3].s32, &mut ctx.xer);
	// 8249F488: 409A0008  bne cr6, 0x8249f490
	if !ctx.cr[6].eq {
	pc = 0x8249F490; continue 'dispatch;
	}
	// 8249F48C: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	pc = 0x8249F490; continue 'dispatch;
            }
            0x8249F490 => {
    //   block [0x8249F490..0x8249F4AC)
	// 8249F490: 5569067E  clrlwi r9, r11, 0x19
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 8249F494: A16A00DA  lhz r11, 0xda(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(218 as u32) ) } as u64;
	// 8249F498: 89470000  lbz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F49C: 7D637670  srawi r3, r11, 0xe
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 14) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 14) as i64;
	// 8249F4A0: 7F0A1800  cmpw cr6, r10, r3
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[3].s32, &mut ctx.xer);
	// 8249F4A4: 409A0008  bne cr6, 0x8249f4ac
	if !ctx.cr[6].eq {
	pc = 0x8249F4AC; continue 'dispatch;
	}
	// 8249F4A8: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	pc = 0x8249F4AC; continue 'dispatch;
            }
            0x8249F4AC => {
    //   block [0x8249F4AC..0x8249F4C4)
	// 8249F4AC: 556A067E  clrlwi r10, r11, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 8249F4B0: 552B067E  clrlwi r11, r9, 0x19
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000007Fu64;
	// 8249F4B4: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 8249F4B8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249F4BC: 40990008  ble cr6, 0x8249f4c4
	if !ctx.cr[6].gt {
	pc = 0x8249F4C4; continue 'dispatch;
	}
	// 8249F4C0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x8249F4C4; continue 'dispatch;
            }
            0x8249F4C4 => {
    //   block [0x8249F4C4..0x8249F4E4)
	// 8249F4C4: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 8249F4C8: 4199001C  bgt cr6, 0x8249f4e4
	if ctx.cr[6].gt {
	pc = 0x8249F4E4; continue 'dispatch;
	}
	// 8249F4CC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F4D0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8249F4D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F4D8: 7D6B402E  lwzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8249F4DC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249F4E0: 7CAB512E  stwx r5, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	pc = 0x8249F4E4; continue 'dispatch;
            }
            0x8249F4E4 => {
    //   block [0x8249F4E4..0x8249F4F8)
	// 8249F4E4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F4E8: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 8249F4EC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 8249F4F0: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249F4F4: 4198FF7C  blt cr6, 0x8249f470
	if ctx.cr[6].lt {
	pc = 0x8249F470; continue 'dispatch;
	}
	pc = 0x8249F4F8; continue 'dispatch;
            }
            0x8249F4F8 => {
    //   block [0x8249F4F8..0x8249F514)
	// 8249F4F8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F4FC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8249F500: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8249F504: 98AB0000  stb r5, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8249F508: 40990044  ble cr6, 0x8249f54c
	if !ctx.cr[6].gt {
	pc = 0x8249F54C; continue 'dispatch;
	}
	// 8249F50C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8249F510: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	pc = 0x8249F514; continue 'dispatch;
            }
            0x8249F514 => {
    //   block [0x8249F514..0x8249F52C)
	// 8249F514: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8249F518: 7D0B402E  lwzx r8, r11, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8249F51C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8249F520: 419A000C  beq cr6, 0x8249f52c
	if ctx.cr[6].eq {
	pc = 0x8249F52C; continue 'dispatch;
	}
	// 8249F524: 7C8B512E  stwx r4, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[4].u32) };
	// 8249F528: 48000014  b 0x8249f53c
	pc = 0x8249F53C; continue 'dispatch;
            }
            0x8249F52C => {
    //   block [0x8249F52C..0x8249F53C)
	// 8249F52C: 7CAB512E  stwx r5, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 8249F530: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F534: 7C8829AE  stbx r4, r8, r5
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32), ctx.r[4].u8) };
	// 8249F538: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	pc = 0x8249F53C; continue 'dispatch;
            }
            0x8249F53C => {
    //   block [0x8249F53C..0x8249F54C)
	// 8249F53C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 8249F540: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8249F544: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8249F548: 409AFFCC  bne cr6, 0x8249f514
	if !ctx.cr[6].eq {
	pc = 0x8249F514; continue 'dispatch;
	}
	pc = 0x8249F54C; continue 'dispatch;
            }
            0x8249F54C => {
    //   block [0x8249F54C..0x8249F560)
	// 8249F54C: 7F05E800  cmpw cr6, r5, r29
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[29].s32, &mut ctx.xer);
	// 8249F550: 40990010  ble cr6, 0x8249f560
	if !ctx.cr[6].gt {
	pc = 0x8249F560; continue 'dispatch;
	}
	// 8249F554: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F558: 988B0000  stb r4, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 8249F55C: 48000014  b 0x8249f570
	pc = 0x8249F570; continue 'dispatch;
            }
            0x8249F560 => {
    //   block [0x8249F560..0x8249F570)
	// 8249F560: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 8249F564: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8249F568: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8249F56C: 4810BD9D  bl 0x825ab308
	ctx.lr = 0x8249F570;
	sub_825AB308(ctx, base);
	pc = 0x8249F570; continue 'dispatch;
            }
            0x8249F570 => {
    //   block [0x8249F570..0x8249F598)
	// 8249F570: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 8249F574: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8249F578: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 8249F57C: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 8249F580: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8249F584: 409A0014  bne cr6, 0x8249f598
	if !ctx.cr[6].eq {
	pc = 0x8249F598; continue 'dispatch;
	}
	// 8249F588: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F58C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8249F590: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249F594: 4E800421  bctrl
	ctx.lr = 0x8249F598;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8249F598 => {
    //   block [0x8249F598..0x8249F5A0)
	// 8249F598: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8249F59C: 48095B5C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249F5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249F5A0 size=928
    let mut pc: u32 = 0x8249F5A0;
    'dispatch: loop {
        match pc {
            0x8249F5A0 => {
    //   block [0x8249F5A0..0x8249F5F8)
	// 8249F5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249F5A4: 48095AE9  bl 0x8253508c
	ctx.lr = 0x8249F5A8;
	sub_82535080(ctx, base);
	// 8249F5A8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249F5AC: 7CD13378  mr r17, r6
	ctx.r[17].u64 = ctx.r[6].u64;
	// 8249F5B0: 824D0000  lwz r18, 0(r13)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F5B4: 3A600010  li r19, 0x10
	ctx.r[19].s64 = 16;
	// 8249F5B8: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 8249F5BC: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 8249F5C0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8249F5C4: 82F10004  lwz r23, 4(r17)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F5C8: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 8249F5CC: 7C73902E  lwzx r3, r19, r18
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 8249F5D0: 39770004  addi r11, r23, 4
	ctx.r[11].s64 = ctx.r[23].s64 + 4;
	// 8249F5D4: 557F1036  rlwinm r31, r11, 2, 0, 0x1b
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249F5D8: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249F5DC: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 8249F5E0: 7D4BFA14  add r10, r11, r31
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 8249F5E4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8249F5E8: 41990010  bgt cr6, 0x8249f5f8
	if ctx.cr[6].gt {
	pc = 0x8249F5F8; continue 'dispatch;
	}
	// 8249F5EC: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 8249F5F0: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 8249F5F4: 4800001C  b 0x8249f610
	pc = 0x8249F610; continue 'dispatch;
            }
            0x8249F5F8 => {
    //   block [0x8249F5F8..0x8249F610)
	// 8249F5F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F5FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8249F600: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8249F604: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249F608: 4E800421  bctrl
	ctx.lr = 0x8249F60C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8249F60C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
            }
            0x8249F610 => {
    //   block [0x8249F610..0x8249F630)
	// 8249F610: 7D73902E  lwzx r11, r19, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 8249F614: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249F618: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8249F61C: 7D2AFA14  add r9, r10, r31
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 8249F620: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8249F624: 4199000C  bgt cr6, 0x8249f630
	if ctx.cr[6].gt {
	pc = 0x8249F630; continue 'dispatch;
	}
	// 8249F628: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 8249F62C: 48000020  b 0x8249f64c
	pc = 0x8249F64C; continue 'dispatch;
            }
            0x8249F630 => {
    //   block [0x8249F630..0x8249F64C)
	// 8249F630: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F634: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8249F638: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8249F63C: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8249F640: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249F644: 4E800421  bctrl
	ctx.lr = 0x8249F648;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8249F648: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            0x8249F64C => {
    //   block [0x8249F64C..0x8249F664)
	// 8249F64C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8249F650: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 8249F654: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 8249F658: 40990028  ble cr6, 0x8249f680
	if !ctx.cr[6].gt {
	pc = 0x8249F680; continue 'dispatch;
	}
	// 8249F65C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8249F660: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	pc = 0x8249F664; continue 'dispatch;
            }
            0x8249F664 => {
    //   block [0x8249F664..0x8249F680)
	// 8249F664: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8249F668: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8249F66C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8249F670: 7F0B492E  stwx r24, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[24].u32) };
	// 8249F674: 7F0BC92E  stwx r24, r11, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32), ctx.r[24].u32) };
	// 8249F678: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8249F67C: 409AFFE8  bne cr6, 0x8249f664
	if !ctx.cr[6].eq {
	pc = 0x8249F664; continue 'dispatch;
	}
	pc = 0x8249F680; continue 'dispatch;
            }
            0x8249F680 => {
    //   block [0x8249F680..0x8249F6A8)
	// 8249F680: 897400C5  lbz r11, 0xc5(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[20].u32.wrapping_add(197 as u32) ) } as u64;
	// 8249F684: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 8249F688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249F68C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F690: 419A00C4  beq cr6, 0x8249f754
	if ctx.cr[6].eq {
	pc = 0x8249F754; continue 'dispatch;
	}
	// 8249F694: 389402C5  addi r4, r20, 0x2c5
	ctx.r[4].s64 = ctx.r[20].s64 + 709;
	// 8249F698: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 8249F69C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249F6A0: 40990114  ble cr6, 0x8249f7b4
	if !ctx.cr[6].gt {
	pc = 0x8249F7B4; continue 'dispatch;
	}
	// 8249F6A4: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	pc = 0x8249F6A8; continue 'dispatch;
            }
            0x8249F6A8 => {
    //   block [0x8249F6A8..0x8249F6D4)
	// 8249F6A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F6AC: 81550000  lwz r10, 0(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F6B0: 89240001  lbz r9, 1(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(1 as u32) ) } as u64;
	// 8249F6B4: 7CE8582E  lwzx r7, r8, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249F6B8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F6BC: 7CCB402E  lwzx r6, r11, r8
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8249F6C0: A16700DC  lhz r11, 0xdc(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(220 as u32) ) } as u64;
	// 8249F6C4: 7D6A7670  srawi r10, r11, 0xe
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 14) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 14) as i64;
	// 8249F6C8: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8249F6CC: 409A0008  bne cr6, 0x8249f6d4
	if !ctx.cr[6].eq {
	pc = 0x8249F6D4; continue 'dispatch;
	}
	// 8249F6D0: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	pc = 0x8249F6D4; continue 'dispatch;
            }
            0x8249F6D4 => {
    //   block [0x8249F6D4..0x8249F6F0)
	// 8249F6D4: 5569067E  clrlwi r9, r11, 0x19
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 8249F6D8: A16700DA  lhz r11, 0xda(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(218 as u32) ) } as u64;
	// 8249F6DC: 89440000  lbz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F6E0: 7D637670  srawi r3, r11, 0xe
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 14) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 14) as i64;
	// 8249F6E4: 7F0A1800  cmpw cr6, r10, r3
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[3].s32, &mut ctx.xer);
	// 8249F6E8: 409A0008  bne cr6, 0x8249f6f0
	if !ctx.cr[6].eq {
	pc = 0x8249F6F0; continue 'dispatch;
	}
	// 8249F6EC: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	pc = 0x8249F6F0; continue 'dispatch;
            }
            0x8249F6F0 => {
    //   block [0x8249F6F0..0x8249F708)
	// 8249F6F0: 556A067E  clrlwi r10, r11, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 8249F6F4: 552B067E  clrlwi r11, r9, 0x19
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000007Fu64;
	// 8249F6F8: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 8249F6FC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249F700: 40990008  ble cr6, 0x8249f708
	if !ctx.cr[6].gt {
	pc = 0x8249F708; continue 'dispatch;
	}
	// 8249F704: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x8249F708; continue 'dispatch;
            }
            0x8249F708 => {
    //   block [0x8249F708..0x8249F71C)
	// 8249F708: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 8249F70C: 41990010  bgt cr6, 0x8249f71c
	if ctx.cr[6].gt {
	pc = 0x8249F71C; continue 'dispatch;
	}
	// 8249F710: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8249F714: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249F718: 7F4B512E  stwx r26, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[26].u32) };
	pc = 0x8249F71C; continue 'dispatch;
            }
            0x8249F71C => {
    //   block [0x8249F71C..0x8249F72C)
	// 8249F71C: A127009C  lhz r9, 0x9c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(156 as u32) ) } as u64;
	// 8249F720: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 8249F724: 40980008  bge cr6, 0x8249f72c
	if !ctx.cr[6].lt {
	pc = 0x8249F72C; continue 'dispatch;
	}
	// 8249F728: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x8249F72C; continue 'dispatch;
            }
            0x8249F72C => {
    //   block [0x8249F72C..0x8249F754)
	// 8249F72C: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249F730: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 8249F734: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 8249F738: 7D4BC82E  lwzx r10, r11, r25
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 8249F73C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8249F740: 7D4BC92E  stwx r10, r11, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32), ctx.r[10].u32) };
	// 8249F744: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F748: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249F74C: 4198FF5C  blt cr6, 0x8249f6a8
	if ctx.cr[6].lt {
	pc = 0x8249F6A8; continue 'dispatch;
	}
	// 8249F750: 48000064  b 0x8249f7b4
	pc = 0x8249F7B4; continue 'dispatch;
            }
            0x8249F754 => {
    //   block [0x8249F754..0x8249F764)
	// 8249F754: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 8249F758: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249F75C: 40990058  ble cr6, 0x8249f7b4
	if !ctx.cr[6].gt {
	pc = 0x8249F7B4; continue 'dispatch;
	}
	// 8249F760: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x8249F764; continue 'dispatch;
            }
            0x8249F764 => {
    //   block [0x8249F764..0x8249F794)
	// 8249F764: 81550000  lwz r10, 0(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F768: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F76C: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8249F770: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F774: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8249F778: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249F77C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8249F780: 7F4A412E  stwx r26, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[26].u32) };
	// 8249F784: A129009C  lhz r9, 0x9c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(156 as u32) ) } as u64;
	// 8249F788: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 8249F78C: 40980008  bge cr6, 0x8249f794
	if !ctx.cr[6].lt {
	pc = 0x8249F794; continue 'dispatch;
	}
	// 8249F790: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x8249F794; continue 'dispatch;
            }
            0x8249F794 => {
    //   block [0x8249F794..0x8249F7B4)
	// 8249F794: 7D0AC82E  lwzx r8, r10, r25
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 8249F798: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 8249F79C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8249F7A0: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 8249F7A4: 7D2AC92E  stwx r9, r10, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[25].u32), ctx.r[9].u32) };
	// 8249F7A8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249F7AC: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8249F7B0: 4198FFB4  blt cr6, 0x8249f764
	if ctx.cr[6].lt {
	pc = 0x8249F764; continue 'dispatch;
	}
	pc = 0x8249F7B4; continue 'dispatch;
            }
            0x8249F7B4 => {
    //   block [0x8249F7B4..0x8249F7C8)
	// 8249F7B4: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 8249F7B8: 40990034  ble cr6, 0x8249f7ec
	if !ctx.cr[6].gt {
	pc = 0x8249F7EC; continue 'dispatch;
	}
	// 8249F7BC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8249F7C0: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 8249F7C4: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	pc = 0x8249F7C8; continue 'dispatch;
            }
            0x8249F7C8 => {
    //   block [0x8249F7C8..0x8249F7DC)
	// 8249F7C8: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8249F7CC: 7D0B402E  lwzx r8, r11, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8249F7D0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8249F7D4: 409A0008  bne cr6, 0x8249f7dc
	if !ctx.cr[6].eq {
	pc = 0x8249F7DC; continue 'dispatch;
	}
	// 8249F7D8: 7D2BC92E  stwx r9, r11, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32), ctx.r[9].u32) };
	pc = 0x8249F7DC; continue 'dispatch;
            }
            0x8249F7DC => {
    //   block [0x8249F7DC..0x8249F7EC)
	// 8249F7DC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8249F7E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8249F7E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8249F7E8: 409AFFE0  bne cr6, 0x8249f7c8
	if !ctx.cr[6].eq {
	pc = 0x8249F7C8; continue 'dispatch;
	}
	pc = 0x8249F7EC; continue 'dispatch;
            }
            0x8249F7EC => {
    //   block [0x8249F7EC..0x8249F810)
	// 8249F7EC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8249F7F0: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 8249F7F4: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 8249F7F8: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 8249F7FC: 409900DC  ble cr6, 0x8249f8d8
	if !ctx.cr[6].gt {
	pc = 0x8249F8D8; continue 'dispatch;
	}
	// 8249F800: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 8249F804: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 8249F808: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 8249F80C: 3860FFFE  li r3, -2
	ctx.r[3].s64 = -2;
	pc = 0x8249F810; continue 'dispatch;
            }
            0x8249F810 => {
    //   block [0x8249F810..0x8249F84C)
	// 8249F810: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F814: 2F08FFFE  cmpwi cr6, r8, -2
	ctx.cr[6].compare_i32(ctx.r[8].s32, -2, &mut ctx.xer);
	// 8249F818: 419A00A8  beq cr6, 0x8249f8c0
	if ctx.cr[6].eq {
	pc = 0x8249F8C0; continue 'dispatch;
	}
	// 8249F81C: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F820: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 8249F824: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 8249F828: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8249F82C: 7F0B39AE  stbx r24, r11, r7
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[24].u8) };
	// 8249F830: 90FE0000  stw r7, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8249F834: 4198008C  blt cr6, 0x8249f8c0
	if ctx.cr[6].lt {
	pc = 0x8249F8C0; continue 'dispatch;
	}
	// 8249F838: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8249F83C: 7F1DB800  cmpw cr6, r29, r23
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[23].s32, &mut ctx.xer);
	// 8249F840: 40980080  bge cr6, 0x8249f8c0
	if !ctx.cr[6].lt {
	pc = 0x8249F8C0; continue 'dispatch;
	}
	// 8249F844: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 8249F848: 7CD9D850  subf r6, r25, r27
	ctx.r[6].s64 = ctx.r[27].s64 - ctx.r[25].s64;
	pc = 0x8249F84C; continue 'dispatch;
            }
            0x8249F84C => {
    //   block [0x8249F84C..0x8249F864)
	// 8249F84C: 813400A4  lwz r9, 0xa4(r20)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(164 as u32) ) } as u64;
	// 8249F850: 3968000A  addi r11, r8, 0xa
	ctx.r[11].s64 = ctx.r[8].s64 + 10;
	// 8249F854: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8249F858: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 8249F85C: 41980008  blt cr6, 0x8249f864
	if ctx.cr[6].lt {
	pc = 0x8249F864; continue 'dispatch;
	}
	// 8249F860: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x8249F864; continue 'dispatch;
            }
            0x8249F864 => {
    //   block [0x8249F864..0x8249F890)
	// 8249F864: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8249F868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249F86C: 419A0054  beq cr6, 0x8249f8c0
	if ctx.cr[6].eq {
	pc = 0x8249F8C0; continue 'dispatch;
	}
	// 8249F870: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F874: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249F878: 41980038  blt cr6, 0x8249f8b0
	if ctx.cr[6].lt {
	pc = 0x8249F8B0; continue 'dispatch;
	}
	// 8249F87C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 8249F880: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8249F884: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 8249F888: 41980008  blt cr6, 0x8249f890
	if ctx.cr[6].lt {
	pc = 0x8249F890; continue 'dispatch;
	}
	// 8249F88C: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	pc = 0x8249F890; continue 'dispatch;
            }
            0x8249F890 => {
    //   block [0x8249F890..0x8249F8B0)
	// 8249F890: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 8249F894: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8249F898: 419A0018  beq cr6, 0x8249f8b0
	if ctx.cr[6].eq {
	pc = 0x8249F8B0; continue 'dispatch;
	}
	// 8249F89C: 81360000  lwz r9, 0(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F8A0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 8249F8A4: 7F4939AE  stbx r26, r9, r7
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[26].u8) };
	// 8249F8A8: 7CE6512E  stwx r7, r6, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 8249F8AC: 906A0000  stw r3, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x8249F8B0; continue 'dispatch;
            }
            0x8249F8B0 => {
    //   block [0x8249F8B0..0x8249F8C0)
	// 8249F8B0: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 8249F8B4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8249F8B8: 7F04B800  cmpw cr6, r4, r23
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[23].s32, &mut ctx.xer);
	// 8249F8BC: 4198FF90  blt cr6, 0x8249f84c
	if ctx.cr[6].lt {
	pc = 0x8249F84C; continue 'dispatch;
	}
	pc = 0x8249F8C0; continue 'dispatch;
            }
            0x8249F8C0 => {
    //   block [0x8249F8C0..0x8249F8D8)
	// 8249F8C0: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 8249F8C4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 8249F8C8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 8249F8CC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 8249F8D0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8249F8D4: 409AFF3C  bne cr6, 0x8249f810
	if !ctx.cr[6].eq {
	pc = 0x8249F810; continue 'dispatch;
	}
	pc = 0x8249F8D8; continue 'dispatch;
            }
            0x8249F8D8 => {
    //   block [0x8249F8D8..0x8249F910)
	// 8249F8D8: 7E268B78  mr r6, r17
	ctx.r[6].u64 = ctx.r[17].u64;
	// 8249F8DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8249F8E0: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 8249F8E4: 4810BA25  bl 0x825ab308
	ctx.lr = 0x8249F8E8;
	sub_825AB308(ctx, base);
	// 8249F8E8: 7C73902E  lwzx r3, r19, r18
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 8249F8EC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8249F8F0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 8249F8F4: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 8249F8F8: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8249F8FC: 409A0014  bne cr6, 0x8249f910
	if !ctx.cr[6].eq {
	pc = 0x8249F910; continue 'dispatch;
	}
	// 8249F900: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F904: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8249F908: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249F90C: 4E800421  bctrl
	ctx.lr = 0x8249F910;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8249F910 => {
    //   block [0x8249F910..0x8249F938)
	// 8249F910: 7C73902E  lwzx r3, r19, r18
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 8249F914: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 8249F918: 93230020  stw r25, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[25].u32 ) };
	// 8249F91C: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8249F920: 409A0018  bne cr6, 0x8249f938
	if !ctx.cr[6].eq {
	pc = 0x8249F938; continue 'dispatch;
	}
	// 8249F924: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249F928: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8249F92C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8249F930: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249F934: 4E800421  bctrl
	ctx.lr = 0x8249F938;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8249F938 => {
    //   block [0x8249F938..0x8249F940)
	// 8249F938: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8249F93C: 480957A0  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249F940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249F940 size=1308
    let mut pc: u32 = 0x8249F940;
    'dispatch: loop {
        match pc {
            0x8249F940 => {
    //   block [0x8249F940..0x8249F97C)
	// 8249F940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249F944: 48095765  bl 0x825350a8
	ctx.lr = 0x8249F948;
	sub_82535080(ctx, base);
	// 8249F948: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249F94C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8249F950: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8249F954: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8249F958: 817E004C  lwz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249F95C: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249F960: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8249F964: 41990024  bgt cr6, 0x8249f988
	if ctx.cr[6].gt {
	pc = 0x8249F988; continue 'dispatch;
	}
	// 8249F968: 41980014  blt cr6, 0x8249f97c
	if ctx.cr[6].lt {
	pc = 0x8249F97C; continue 'dispatch;
	}
	// 8249F96C: A17E0020  lhz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249F970: A15F0020  lhz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249F974: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8249F978: 40990010  ble cr6, 0x8249f988
	if !ctx.cr[6].gt {
	pc = 0x8249F988; continue 'dispatch;
	}
	pc = 0x8249F97C; continue 'dispatch;
            }
            0x8249F97C => {
    //   block [0x8249F97C..0x8249F988)
	// 8249F97C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8249F980: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 8249F984: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x8249F988; continue 'dispatch;
            }
            0x8249F988 => {
    //   block [0x8249F988..0x8249F9C0)
	// 8249F988: 817A0084  lwz r11, 0x84(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(132 as u32) ) } as u64;
	// 8249F98C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8249F990: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249F994: 917A0084  stw r11, 0x84(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8249F998: 895E0026  lbz r10, 0x26(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249F99C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8249F9A0: 5569D1BE  srwi r9, r11, 6
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8249F9A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8249F9A8: 409A0018  bne cr6, 0x8249f9c0
	if !ctx.cr[6].eq {
	pc = 0x8249F9C0; continue 'dispatch;
	}
	// 8249F9AC: 891F0026  lbz r8, 0x26(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249F9B0: 55080032  rlwinm r8, r8, 0, 0, 0x19
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 8249F9B4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8249F9B8: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 8249F9BC: 419A0008  beq cr6, 0x8249f9c4
	if ctx.cr[6].eq {
	pc = 0x8249F9C4; continue 'dispatch;
	}
	pc = 0x8249F9C0; continue 'dispatch;
            }
            0x8249F9C0 => {
    //   block [0x8249F9C0..0x8249F9C4)
	// 8249F9C0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x8249F9C4; continue 'dispatch;
            }
            0x8249F9C4 => {
    //   block [0x8249F9C4..0x8249F9E4)
	// 8249F9C4: 556B06B6  rlwinm r11, r11, 0, 0x1a, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8249F9C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249F9CC: 409A0018  bne cr6, 0x8249f9e4
	if !ctx.cr[6].eq {
	pc = 0x8249F9E4; continue 'dispatch;
	}
	// 8249F9D0: 897F0026  lbz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249F9D4: 7F38CB78  mr r24, r25
	ctx.r[24].u64 = ctx.r[25].u64;
	// 8249F9D8: 556B06B6  rlwinm r11, r11, 0, 0x1a, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8249F9DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249F9E0: 419A0008  beq cr6, 0x8249f9e8
	if ctx.cr[6].eq {
	pc = 0x8249F9E8; continue 'dispatch;
	}
	pc = 0x8249F9E4; continue 'dispatch;
            }
            0x8249F9E4 => {
    //   block [0x8249F9E4..0x8249F9E8)
	// 8249F9E4: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	pc = 0x8249F9E8; continue 'dispatch;
            }
            0x8249F9E8 => {
    //   block [0x8249F9E8..0x8249FA10)
	// 8249F9E8: 7D0B0774  extsb r11, r8
	ctx.r[11].s64 = ctx.r[8].s8 as i64;
	// 8249F9EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249F9F0: 419A0048  beq cr6, 0x8249fa38
	if ctx.cr[6].eq {
	pc = 0x8249FA38; continue 'dispatch;
	}
	// 8249F9F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8249F9F8: 409A0018  bne cr6, 0x8249fa10
	if !ctx.cr[6].eq {
	pc = 0x8249FA10; continue 'dispatch;
	}
	// 8249F9FC: 714B00CF  andi. r11, r10, 0xcf
	ctx.r[11].u64 = ctx.r[10].u64 & 207;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249FA00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8249FA04: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 8249FA08: 997E0026  stb r11, 0x26(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(38 as u32), ctx.r[11].u8 ) };
	// 8249FA0C: 48000024  b 0x8249fa30
	pc = 0x8249FA30; continue 'dispatch;
            }
            0x8249FA10 => {
    //   block [0x8249FA10..0x8249FA30)
	// 8249FA10: 897F0026  lbz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249FA14: 556A0032  rlwinm r10, r11, 0, 0, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8249FA18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8249FA1C: 409A001C  bne cr6, 0x8249fa38
	if !ctx.cr[6].eq {
	pc = 0x8249FA38; continue 'dispatch;
	}
	// 8249FA20: 716B00CF  andi. r11, r11, 0xcf
	ctx.r[11].u64 = ctx.r[11].u64 & 207;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249FA24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8249FA28: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 8249FA2C: 997F0026  stb r11, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[11].u8 ) };
	pc = 0x8249FA30; continue 'dispatch;
            }
            0x8249FA30 => {
    //   block [0x8249FA30..0x8249FA38)
	// 8249FA30: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8249FA34: 4BFFED4D  bl 0x8249e780
	ctx.lr = 0x8249FA38;
	sub_8249E780(ctx, base);
	pc = 0x8249FA38; continue 'dispatch;
            }
            0x8249FA38 => {
    //   block [0x8249FA38..0x8249FA8C)
	// 8249FA38: 897F0025  lbz r11, 0x25(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 8249FA3C: 389F0058  addi r4, r31, 0x58
	ctx.r[4].s64 = ctx.r[31].s64 + 88;
	// 8249FA40: 895E0025  lbz r10, 0x25(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(37 as u32) ) } as u64;
	// 8249FA44: 387E0058  addi r3, r30, 0x58
	ctx.r[3].s64 = ctx.r[30].s64 + 88;
	// 8249FA48: 556B06B6  rlwinm r11, r11, 0, 0x1a, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8249FA4C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 8249FA50: 997E0025  stb r11, 0x25(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 8249FA54: 48035CD5  bl 0x824d5728
	ctx.lr = 0x8249FA58;
	sub_824D5728(ctx, base);
	// 8249FA58: 3B9E0048  addi r28, r30, 0x48
	ctx.r[28].s64 = ctx.r[30].s64 + 72;
	// 8249FA5C: 817E004C  lwz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249FA60: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249FA64: 557D043E  clrlwi r29, r11, 0x10
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 8249FA68: 7F6B5214  add r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8249FA6C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249FA70: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249FA74: 7F0BD800  cmpw cr6, r11, r27
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[27].s32, &mut ctx.xer);
	// 8249FA78: 40980024  bge cr6, 0x8249fa9c
	if !ctx.cr[6].lt {
	pc = 0x8249FA9C; continue 'dispatch;
	}
	// 8249FA7C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249FA80: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249FA84: 41980008  blt cr6, 0x8249fa8c
	if ctx.cr[6].lt {
	pc = 0x8249FA8C; continue 'dispatch;
	}
	// 8249FA88: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8249FA8C; continue 'dispatch;
            }
            0x8249FA8C => {
    //   block [0x8249FA8C..0x8249FA9C)
	// 8249FA8C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8249FA90: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8249FA94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8249FA98: 4BFCE831  bl 0x8246e2c8
	ctx.lr = 0x8249FA9C;
	sub_8246E2C8(ctx, base);
	pc = 0x8249FA9C; continue 'dispatch;
            }
            0x8249FA9C => {
    //   block [0x8249FA9C..0x8249FAB4)
	// 8249FA9C: 937C0004  stw r27, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 8249FAA0: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 8249FAA4: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249FAA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249FAAC: 40990054  ble cr6, 0x8249fb00
	if !ctx.cr[6].gt {
	pc = 0x8249FB00; continue 'dispatch;
	}
	// 8249FAB0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x8249FAB4; continue 'dispatch;
            }
            0x8249FAB4 => {
    //   block [0x8249FAB4..0x8249FB00)
	// 8249FAB4: 811F0048  lwz r8, 0x48(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8249FAB8: 57A9043E  clrlwi r9, r29, 0x10
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 8249FABC: 80FC0000  lwz r7, 0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249FAC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8249FAC4: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8249FAC8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8249FACC: 7D08582E  lwzx r8, r8, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249FAD0: 7D06392E  stwx r8, r6, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32), ctx.r[8].u32) };
	// 8249FAD4: 811F0048  lwz r8, 0x48(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8249FAD8: 7D08582E  lwzx r8, r8, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249FADC: 93C800B8  stw r30, 0xb8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(184 as u32), ctx.r[30].u32 ) };
	// 8249FAE0: 811F0048  lwz r8, 0x48(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8249FAE4: 7D08582E  lwzx r8, r8, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249FAE8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8249FAEC: B3A80094  sth r29, 0x94(r8)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[8].u32.wrapping_add(148 as u32), ctx.r[29].u16 ) };
	// 8249FAF0: 553D043E  clrlwi r29, r9, 0x10
	ctx.r[29].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 8249FAF4: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249FAF8: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8249FAFC: 4198FFB8  blt cr6, 0x8249fab4
	if ctx.cr[6].lt {
	pc = 0x8249FAB4; continue 'dispatch;
	}
	pc = 0x8249FB00; continue 'dispatch;
            }
            0x8249FB00 => {
    //   block [0x8249FB00..0x8249FB34)
	// 8249FB00: 3BBE0038  addi r29, r30, 0x38
	ctx.r[29].s64 = ctx.r[30].s64 + 56;
	// 8249FB04: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 8249FB08: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 8249FB0C: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 8249FB10: 7F8A5A14  add r28, r10, r11
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8249FB14: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249FB18: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249FB1C: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 8249FB20: 40980024  bge cr6, 0x8249fb44
	if !ctx.cr[6].lt {
	pc = 0x8249FB44; continue 'dispatch;
	}
	// 8249FB24: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249FB28: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249FB2C: 41980008  blt cr6, 0x8249fb34
	if ctx.cr[6].lt {
	pc = 0x8249FB34; continue 'dispatch;
	}
	// 8249FB30: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8249FB34; continue 'dispatch;
            }
            0x8249FB34 => {
    //   block [0x8249FB34..0x8249FB44)
	// 8249FB34: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8249FB38: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8249FB3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8249FB40: 4BFCE789  bl 0x8246e2c8
	ctx.lr = 0x8249FB44;
	sub_8246E2C8(ctx, base);
	pc = 0x8249FB44; continue 'dispatch;
            }
            0x8249FB44 => {
    //   block [0x8249FB44..0x8249FB60)
	// 8249FB44: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 8249FB48: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 8249FB4C: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 8249FB50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249FB54: 40990050  ble cr6, 0x8249fba4
	if !ctx.cr[6].gt {
	pc = 0x8249FBA4; continue 'dispatch;
	}
	// 8249FB58: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249FB5C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x8249FB60; continue 'dispatch;
            }
            0x8249FB60 => {
    //   block [0x8249FB60..0x8249FB90)
	// 8249FB60: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8249FB64: 7CEA482E  lwzx r7, r10, r9
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8249FB68: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8249FB6C: 419A0024  beq cr6, 0x8249fb90
	if ctx.cr[6].eq {
	pc = 0x8249FB90; continue 'dispatch;
	}
	// 8249FB70: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8249FB74: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 8249FB78: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249FB7C: 7D2B392E  stwx r9, r11, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[9].u32) };
	// 8249FB80: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249FB84: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8249FB88: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8249FB8C: 93C9000C  stw r30, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	pc = 0x8249FB90; continue 'dispatch;
            }
            0x8249FB90 => {
    //   block [0x8249FB90..0x8249FBA4)
	// 8249FB90: 813F003C  lwz r9, 0x3c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 8249FB94: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 8249FB98: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8249FB9C: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8249FBA0: 4198FFC0  blt cr6, 0x8249fb60
	if ctx.cr[6].lt {
	pc = 0x8249FB60; continue 'dispatch;
	}
	pc = 0x8249FBA4; continue 'dispatch;
            }
            0x8249FBA4 => {
    //   block [0x8249FBA4..0x8249FBC4)
	// 8249FBA4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249FBA8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249FBAC: 7F0BD800  cmpw cr6, r11, r27
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[27].s32, &mut ctx.xer);
	// 8249FBB0: 40980024  bge cr6, 0x8249fbd4
	if !ctx.cr[6].lt {
	pc = 0x8249FBD4; continue 'dispatch;
	}
	// 8249FBB4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249FBB8: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249FBBC: 41980008  blt cr6, 0x8249fbc4
	if ctx.cr[6].lt {
	pc = 0x8249FBC4; continue 'dispatch;
	}
	// 8249FBC0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8249FBC4; continue 'dispatch;
            }
            0x8249FBC4 => {
    //   block [0x8249FBC4..0x8249FBD4)
	// 8249FBC4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8249FBC8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8249FBCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8249FBD0: 4BFCE6F9  bl 0x8246e2c8
	ctx.lr = 0x8249FBD4;
	sub_8246E2C8(ctx, base);
	pc = 0x8249FBD4; continue 'dispatch;
            }
            0x8249FBD4 => {
    //   block [0x8249FBD4..0x8249FBEC)
	// 8249FBD4: 937D0004  stw r27, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 8249FBD8: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 8249FBDC: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249FBE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249FBE4: 40990050  ble cr6, 0x8249fc34
	if !ctx.cr[6].gt {
	pc = 0x8249FC34; continue 'dispatch;
	}
	// 8249FBE8: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	pc = 0x8249FBEC; continue 'dispatch;
            }
            0x8249FBEC => {
    //   block [0x8249FBEC..0x8249FC08)
	// 8249FBEC: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8249FBF0: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8249FBF4: A12B009C  lhz r9, 0x9c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 8249FBF8: 814B0098  lwz r10, 0x98(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 8249FBFC: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 8249FC00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249FC04: 4198001C  blt cr6, 0x8249fc20
	if ctx.cr[6].lt {
	pc = 0x8249FC20; continue 'dispatch;
	}
	pc = 0x8249FC08; continue 'dispatch;
            }
            0x8249FC08 => {
    //   block [0x8249FC08..0x8249FC20)
	// 8249FC08: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249FC0C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8249FC10: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 8249FC14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249FC18: 93C90008  stw r30, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 8249FC1C: 4098FFEC  bge cr6, 0x8249fc08
	if !ctx.cr[6].lt {
	pc = 0x8249FC08; continue 'dispatch;
	}
	pc = 0x8249FC20; continue 'dispatch;
            }
            0x8249FC20 => {
    //   block [0x8249FC20..0x8249FC34)
	// 8249FC20: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249FC24: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 8249FC28: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 8249FC2C: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249FC30: 4198FFBC  blt cr6, 0x8249fbec
	if ctx.cr[6].lt {
	pc = 0x8249FBEC; continue 'dispatch;
	}
	pc = 0x8249FC34; continue 'dispatch;
            }
            0x8249FC34 => {
    //   block [0x8249FC34..0x8249FC70)
	// 8249FC34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8249FC38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8249FC3C: 48016AB5  bl 0x824b66f0
	ctx.lr = 0x8249FC40;
	sub_824B66F0(ctx, base);
	// 8249FC40: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8249FC44: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8249FC48: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8249FC4C: 917E001C  stw r11, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8249FC50: 897F0026  lbz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249FC54: A11F0020  lhz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249FC58: 556B0032  rlwinm r11, r11, 0, 0, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8249FC5C: 933F001C  stw r25, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[25].u32 ) };
	// 8249FC60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249FC64: 397A0028  addi r11, r26, 0x28
	ctx.r[11].s64 = ctx.r[26].s64 + 40;
	// 8249FC68: 409A0008  bne cr6, 0x8249fc70
	if !ctx.cr[6].eq {
	pc = 0x8249FC70; continue 'dispatch;
	}
	// 8249FC6C: 397A0034  addi r11, r26, 0x34
	ctx.r[11].s64 = ctx.r[26].s64 + 52;
	pc = 0x8249FC70; continue 'dispatch;
            }
            0x8249FC70 => {
    //   block [0x8249FC70..0x8249FCA8)
	// 8249FC70: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249FC74: 5509043E  clrlwi r9, r8, 0x10
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x0000FFFFu64;
	// 8249FC78: 3947FFFF  addi r10, r7, -1
	ctx.r[10].s64 = ctx.r[7].s64 + -1;
	// 8249FC7C: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8249FC80: 40980028  bge cr6, 0x8249fca8
	if !ctx.cr[6].lt {
	pc = 0x8249FCA8; continue 'dispatch;
	}
	// 8249FC84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249FC88: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8249FC8C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8249FC90: 7CE75214  add r7, r7, r10
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 8249FC94: 80E7FFFC  lwz r7, -4(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8249FC98: 7CE9512E  stwx r7, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 8249FC9C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249FCA0: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8249FCA4: B10A0020  sth r8, 0x20(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[8].u16 ) };
	pc = 0x8249FCA8; continue 'dispatch;
            }
            0x8249FCA8 => {
    //   block [0x8249FCA8..0x8249FCD8)
	// 8249FCA8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249FCAC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8249FCB0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8249FCB4: 895E0025  lbz r10, 0x25(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(37 as u32) ) } as u64;
	// 8249FCB8: 554B0032  rlwinm r11, r10, 0, 0, 0x19
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8249FCBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249FCC0: 409A0018  bne cr6, 0x8249fcd8
	if !ctx.cr[6].eq {
	pc = 0x8249FCD8; continue 'dispatch;
	}
	// 8249FCC4: 897F0025  lbz r11, 0x25(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 8249FCC8: 556B0032  rlwinm r11, r11, 0, 0, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8249FCCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249FCD0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 8249FCD4: 419A0008  beq cr6, 0x8249fcdc
	if ctx.cr[6].eq {
	pc = 0x8249FCDC; continue 'dispatch;
	}
	pc = 0x8249FCD8; continue 'dispatch;
            }
            0x8249FCD8 => {
    //   block [0x8249FCD8..0x8249FCDC)
	// 8249FCD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x8249FCDC; continue 'dispatch;
            }
            0x8249FCDC => {
    //   block [0x8249FCDC..0x8249FD08)
	// 8249FCDC: 516A34B2  rlwimi r10, r11, 6, 0x12, 0x19
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(6) as u64) & 0x0000000000003FC0) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFC03F);
	// 8249FCE0: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8249FCE4: 556A073A  rlwinm r10, r11, 0, 0x1c, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8249FCE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8249FCEC: 997E0025  stb r11, 0x25(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 8249FCF0: 409A0018  bne cr6, 0x8249fd08
	if !ctx.cr[6].eq {
	pc = 0x8249FD08; continue 'dispatch;
	}
	// 8249FCF4: 895F0025  lbz r10, 0x25(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 8249FCF8: 554A073A  rlwinm r10, r10, 0, 0x1c, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8249FCFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8249FD00: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 8249FD04: 419A0008  beq cr6, 0x8249fd0c
	if ctx.cr[6].eq {
	pc = 0x8249FD0C; continue 'dispatch;
	}
	pc = 0x8249FD08; continue 'dispatch;
            }
            0x8249FD08 => {
    //   block [0x8249FD08..0x8249FD0C)
	// 8249FD08: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x8249FD0C; continue 'dispatch;
            }
            0x8249FD0C => {
    //   block [0x8249FD0C..0x8249FD78)
	// 8249FD0C: 7F090774  extsb r9, r24
	ctx.r[9].s64 = ctx.r[24].s8 as i64;
	// 8249FD10: 891E0026  lbz r8, 0x26(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249FD14: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8249FD18: 7D290034  cntlzw r9, r9
	ctx.r[9].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8249FD1C: 514B173A  rlwimi r11, r10, 2, 0x1c, 0x1d
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(2) as u64) & 0x000000000000000C) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFFF3);
	// 8249FD20: 5529DFFE  rlwinm r9, r9, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8249FD24: 692A0001  xori r10, r9, 1
	ctx.r[10].u64 = ctx.r[9].u64 ^ 1;
	// 8249FD28: 514826B6  rlwimi r8, r10, 4, 0x1a, 0x1b
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(4) as u64) & 0x0000000000000030) | (ctx.r[8].u64 & 0xFFFFFFFFFFFFFFCF);
	// 8249FD2C: 997E0025  stb r11, 0x25(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 8249FD30: 991E0026  stb r8, 0x26(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(38 as u32), ctx.r[8].u8 ) };
	// 8249FD34: A17F0022  lhz r11, 0x22(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(34 as u32) ) } as u64;
	// 8249FD38: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 8249FD3C: 419A0058  beq cr6, 0x8249fd94
	if ctx.cr[6].eq {
	pc = 0x8249FD94; continue 'dispatch;
	}
	// 8249FD40: A17E0022  lhz r11, 0x22(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(34 as u32) ) } as u64;
	// 8249FD44: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 8249FD48: 409A004C  bne cr6, 0x8249fd94
	if !ctx.cr[6].eq {
	pc = 0x8249FD94; continue 'dispatch;
	}
	// 8249FD4C: 817A0044  lwz r11, 0x44(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(68 as u32) ) } as u64;
	// 8249FD50: 3BBA0040  addi r29, r26, 0x40
	ctx.r[29].s64 = ctx.r[26].s64 + 64;
	// 8249FD54: B17E0022  sth r11, 0x22(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(34 as u32), ctx.r[11].u16 ) };
	// 8249FD58: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249FD5C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249FD60: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249FD64: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249FD68: 409A0010  bne cr6, 0x8249fd78
	if !ctx.cr[6].eq {
	pc = 0x8249FD78; continue 'dispatch;
	}
	// 8249FD6C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8249FD70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8249FD74: 4BFCE5DD  bl 0x8246e350
	ctx.lr = 0x8249FD78;
	sub_8246E350(ctx, base);
	pc = 0x8249FD78; continue 'dispatch;
            }
            0x8249FD78 => {
    //   block [0x8249FD78..0x8249FD94)
	// 8249FD78: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249FD7C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249FD80: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249FD84: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 8249FD88: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249FD8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249FD90: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x8249FD94; continue 'dispatch;
            }
            0x8249FD94 => {
    //   block [0x8249FD94..0x8249FDB4)
	// 8249FD94: A17F0022  lhz r11, 0x22(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(34 as u32) ) } as u64;
	// 8249FD98: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 8249FD9C: 419A0018  beq cr6, 0x8249fdb4
	if ctx.cr[6].eq {
	pc = 0x8249FDB4; continue 'dispatch;
	}
	// 8249FDA0: 815A0040  lwz r10, 0x40(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 8249FDA4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249FDA8: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 8249FDAC: 7F2B512E  stwx r25, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[25].u32) };
	// 8249FDB0: B13F0022  sth r9, 0x22(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(34 as u32), ctx.r[9].u16 ) };
	pc = 0x8249FDB4; continue 'dispatch;
            }
            0x8249FDB4 => {
    //   block [0x8249FDB4..0x8249FE20)
	// 8249FDB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249FDB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8249FDBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249FDC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249FDC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8249FDC8: 4E800421  bctrl
	ctx.lr = 0x8249FDCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8249FDCC: 897E0026  lbz r11, 0x26(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249FDD0: 556B0032  rlwinm r11, r11, 0, 0, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8249FDD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249FDD8: 419A0048  beq cr6, 0x8249fe20
	if ctx.cr[6].eq {
	pc = 0x8249FE20; continue 'dispatch;
	}
	// 8249FDDC: A15E0020  lhz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 8249FDE0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8249FDE4: 419A003C  beq cr6, 0x8249fe20
	if ctx.cr[6].eq {
	pc = 0x8249FE20; continue 'dispatch;
	}
	// 8249FDE8: 817A0028  lwz r11, 0x28(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 8249FDEC: 813E004C  lwz r9, 0x4c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249FDF0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249FDF4: 810B004C  lwz r8, 0x4c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8249FDF8: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 8249FDFC: 40990024  ble cr6, 0x8249fe20
	if !ctx.cr[6].gt {
	pc = 0x8249FE20; continue 'dispatch;
	}
	// 8249FE00: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 8249FE04: B33E0020  sth r25, 0x20(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[25].u16 ) };
	// 8249FE08: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8249FE0C: B12B0020  sth r9, 0x20(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u16 ) };
	// 8249FE10: 813A0028  lwz r9, 0x28(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 8249FE14: 93C90000  stw r30, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8249FE18: 813A0028  lwz r9, 0x28(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 8249FE1C: 7D6A492E  stwx r11, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u32) };
            }
            0x8249FE20 => {
    //   block [0x8249FE20..0x8249FE50)
	// 8249FE20: 817A0084  lwz r11, 0x84(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(132 as u32) ) } as u64;
	// 8249FE24: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249FE28: 917A0084  stw r11, 0x84(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8249FE2C: 40820024  bne 0x8249fe50
	if !ctx.cr[0].eq {
	pc = 0x8249FE50; continue 'dispatch;
	}
	// 8249FE30: 897A008C  lbz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 8249FE34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249FE38: 409A0018  bne cr6, 0x8249fe50
	if !ctx.cr[6].eq {
	pc = 0x8249FE50; continue 'dispatch;
	}
	// 8249FE3C: 817A0080  lwz r11, 0x80(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(128 as u32) ) } as u64;
	// 8249FE40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249FE44: 419A000C  beq cr6, 0x8249fe50
	if ctx.cr[6].eq {
	pc = 0x8249FE50; continue 'dispatch;
	}
	// 8249FE48: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8249FE4C: 4BFF3375  bl 0x824931c0
	ctx.lr = 0x8249FE50;
	sub_824931C0(ctx, base);
	pc = 0x8249FE50; continue 'dispatch;
            }
            0x8249FE50 => {
    //   block [0x8249FE50..0x8249FE5C)
	// 8249FE50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8249FE54: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8249FE58: 480952A0  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8249FE60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8249FE60 size=412
    let mut pc: u32 = 0x8249FE60;
    'dispatch: loop {
        match pc {
            0x8249FE60 => {
    //   block [0x8249FE60..0x8249FE94)
	// 8249FE60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8249FE64: 4809524D  bl 0x825350b0
	ctx.lr = 0x8249FE68;
	sub_82535080(ctx, base);
	// 8249FE68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8249FE6C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8249FE70: 817B0044  lwz r11, 0x44(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) } as u64;
	// 8249FE74: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8249FE78: 4099001C  ble cr6, 0x8249fe94
	if !ctx.cr[6].gt {
	pc = 0x8249FE94; continue 'dispatch;
	}
	// 8249FE7C: 3D40824A  lis r10, -0x7db6
	ctx.r[10].s64 = -2109079552;
	// 8249FE80: 807B0040  lwz r3, 0x40(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) } as u64;
	// 8249FE84: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 8249FE88: 38CADF18  addi r6, r10, -0x20e8
	ctx.r[6].s64 = ctx.r[10].s64 + -8424;
	// 8249FE8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8249FE90: 4BFCD1B9  bl 0x8246d048
	ctx.lr = 0x8249FE94;
	sub_8246D048(ctx, base);
	pc = 0x8249FE94; continue 'dispatch;
            }
            0x8249FE94 => {
    //   block [0x8249FE94..0x8249FEAC)
	// 8249FE94: 817B0044  lwz r11, 0x44(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) } as u64;
	// 8249FE98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249FE9C: 419A0158  beq cr6, 0x8249fff4
	if ctx.cr[6].eq {
	pc = 0x8249FFF4; continue 'dispatch;
	}
	// 8249FEA0: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 8249FEA4: 3B9B0040  addi r28, r27, 0x40
	ctx.r[28].s64 = ctx.r[27].s64 + 64;
	// 8249FEA8: 617AFFFF  ori r26, r11, 0xffff
	ctx.r[26].u64 = ctx.r[11].u64 | 65535;
	pc = 0x8249FEAC; continue 'dispatch;
            }
            0x8249FEAC => {
    //   block [0x8249FEAC..0x8249FF00)
	// 8249FEAC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249FEB0: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249FEB4: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 8249FEB8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249FEBC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8249FEC0: 83ABFFFC  lwz r29, -4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8249FEC4: 913C0004  stw r9, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8249FEC8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8249FECC: 419A011C  beq cr6, 0x8249ffe8
	if ctx.cr[6].eq {
	pc = 0x8249FFE8; continue 'dispatch;
	}
	// 8249FED0: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 8249FED4: B35D0022  sth r26, 0x22(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(34 as u32), ctx.r[26].u16 ) };
	// 8249FED8: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8249FEDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249FEE0: 419A00D8  beq cr6, 0x8249ffb8
	if ctx.cr[6].eq {
	pc = 0x8249FFB8; continue 'dispatch;
	}
	// 8249FEE4: 3BFD0038  addi r31, r29, 0x38
	ctx.r[31].s64 = ctx.r[29].s64 + 56;
	// 8249FEE8: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 8249FEEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8249FEF0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249FEF4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8249FEF8: 40990034  ble cr6, 0x8249ff2c
	if !ctx.cr[6].gt {
	pc = 0x8249FF2C; continue 'dispatch;
	}
	// 8249FEFC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8249FF00; continue 'dispatch;
            }
            0x8249FF00 => {
    //   block [0x8249FF00..0x8249FF24)
	// 8249FF00: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249FF04: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8249FF08: 419A001C  beq cr6, 0x8249ff24
	if ctx.cr[6].eq {
	pc = 0x8249FF24; continue 'dispatch;
	}
	// 8249FF0C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249FF10: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249FF14: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8249FF18: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 8249FF1C: 4198FFE4  blt cr6, 0x8249ff00
	if ctx.cr[6].lt {
	pc = 0x8249FF00; continue 'dispatch;
	}
	// 8249FF20: 4800000C  b 0x8249ff2c
	pc = 0x8249FF2C; continue 'dispatch;
            }
            0x8249FF24 => {
    //   block [0x8249FF24..0x8249FF2C)
	// 8249FF24: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8249FF28: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	pc = 0x8249FF2C; continue 'dispatch;
            }
            0x8249FF2C => {
    //   block [0x8249FF2C..0x8249FF3C)
	// 8249FF2C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8249FF30: 40980040  bge cr6, 0x8249ff70
	if !ctx.cr[6].lt {
	pc = 0x8249FF70; continue 'dispatch;
	}
	// 8249FF34: 57C8103A  slwi r8, r30, 2
	ctx.r[8].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8249FF38: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x8249FF3C; continue 'dispatch;
            }
            0x8249FF3C => {
    //   block [0x8249FF3C..0x8249FF5C)
	// 8249FF3C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8249FF40: 7CEA482E  lwzx r7, r10, r9
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8249FF44: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8249FF48: 419A0014  beq cr6, 0x8249ff5c
	if ctx.cr[6].eq {
	pc = 0x8249FF5C; continue 'dispatch;
	}
	// 8249FF4C: 54E7003E  slwi r7, r7, 0
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8249FF50: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8249FF54: 7CE8492E  stwx r7, r8, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 8249FF58: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	pc = 0x8249FF5C; continue 'dispatch;
            }
            0x8249FF5C => {
    //   block [0x8249FF5C..0x8249FF70)
	// 8249FF5C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8249FF60: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8249FF64: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8249FF68: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8249FF6C: 4198FFD0  blt cr6, 0x8249ff3c
	if ctx.cr[6].lt {
	pc = 0x8249FF3C; continue 'dispatch;
	}
	pc = 0x8249FF70; continue 'dispatch;
            }
            0x8249FF70 => {
    //   block [0x8249FF70..0x8249FF98)
	// 8249FF70: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 8249FF74: 419A0038  beq cr6, 0x8249ffac
	if ctx.cr[6].eq {
	pc = 0x8249FFAC; continue 'dispatch;
	}
	// 8249FF78: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8249FF7C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8249FF80: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 8249FF84: 40980024  bge cr6, 0x8249ffa8
	if !ctx.cr[6].lt {
	pc = 0x8249FFA8; continue 'dispatch;
	}
	// 8249FF88: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8249FF8C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8249FF90: 41980008  blt cr6, 0x8249ff98
	if ctx.cr[6].lt {
	pc = 0x8249FF98; continue 'dispatch;
	}
	// 8249FF94: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8249FF98; continue 'dispatch;
            }
            0x8249FF98 => {
    //   block [0x8249FF98..0x8249FFA8)
	// 8249FF98: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8249FF9C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8249FFA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8249FFA4: 4BFCE325  bl 0x8246e2c8
	ctx.lr = 0x8249FFA8;
	sub_8246E2C8(ctx, base);
	pc = 0x8249FFA8; continue 'dispatch;
            }
            0x8249FFA8 => {
    //   block [0x8249FFA8..0x8249FFAC)
	// 8249FFA8: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x8249FFAC; continue 'dispatch;
            }
            0x8249FFAC => {
    //   block [0x8249FFAC..0x8249FFB8)
	// 8249FFAC: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 8249FFB0: 716B00F3  andi. r11, r11, 0xf3
	ctx.r[11].u64 = ctx.r[11].u64 & 243;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249FFB4: 997D0025  stb r11, 0x25(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	pc = 0x8249FFB8; continue 'dispatch;
            }
            0x8249FFB8 => {
    //   block [0x8249FFB8..0x8249FFE4)
	// 8249FFB8: 897D0026  lbz r11, 0x26(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(38 as u32) ) } as u64;
	// 8249FFBC: 5569D1BE  srwi r9, r11, 6
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8249FFC0: 556BE7BE  rlwinm r11, r11, 0x1c, 0x1e, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 8249FFC4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8249FFC8: 419A0020  beq cr6, 0x8249ffe8
	if ctx.cr[6].eq {
	pc = 0x8249FFE8; continue 'dispatch;
	}
	// 8249FFCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8249FFD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8249FFD4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8249FFD8: 419A000C  beq cr6, 0x8249ffe4
	if ctx.cr[6].eq {
	pc = 0x8249FFE4; continue 'dispatch;
	}
	// 8249FFDC: 4BFFE7A5  bl 0x8249e780
	ctx.lr = 0x8249FFE0;
	sub_8249E780(ctx, base);
	// 8249FFE0: 48000008  b 0x8249ffe8
	pc = 0x8249FFE8; continue 'dispatch;
            }
            0x8249FFE4 => {
    //   block [0x8249FFE4..0x8249FFE8)
	// 8249FFE4: 4BFFE975  bl 0x8249e958
	ctx.lr = 0x8249FFE8;
	sub_8249E958(ctx, base);
	pc = 0x8249FFE8; continue 'dispatch;
            }
            0x8249FFE8 => {
    //   block [0x8249FFE8..0x8249FFF4)
	// 8249FFE8: 817B0044  lwz r11, 0x44(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) } as u64;
	// 8249FFEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8249FFF0: 409AFEBC  bne cr6, 0x8249feac
	if !ctx.cr[6].eq {
	pc = 0x8249FEAC; continue 'dispatch;
	}
	pc = 0x8249FFF4; continue 'dispatch;
            }
            0x8249FFF4 => {
    //   block [0x8249FFF4..0x8249FFFC)
	// 8249FFF4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8249FFF8: 48095108  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A0000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A0000 size=784
    let mut pc: u32 = 0x824A0000;
    'dispatch: loop {
        match pc {
            0x824A0000 => {
    //   block [0x824A0000..0x824A0040)
	// 824A0000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A0004: 480950A1  bl 0x825350a4
	ctx.lr = 0x824A0008;
	sub_82535080(ctx, base);
	// 824A0008: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A000C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824A0010: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 824A0014: 815B0084  lwz r10, 0x84(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A0018: 9161010C  stw r11, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 824A001C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A0020: 419A0020  beq cr6, 0x824a0040
	if ctx.cr[6].eq {
	pc = 0x824A0040; continue 'dispatch;
	}
	// 824A0024: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 824A0028: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 824A002C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 824A0030: 99410058  stb r10, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 824A0034: 4BFF31A5  bl 0x824931d8
	ctx.lr = 0x824A0038;
	sub_824931D8(ctx, base);
	// 824A0038: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 824A003C: 480950B8  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            0x824A0040 => {
    //   block [0x824A0040..0x824A00A0)
	// 824A0040: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 824A0044: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824A0048: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A004C: 915B0084  stw r10, 0x84(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 824A0050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A0054: 419A0284  beq cr6, 0x824a02d8
	if ctx.cr[6].eq {
	pc = 0x824A02D8; continue 'dispatch;
	}
	// 824A0058: 830D0000  lwz r24, 0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A005C: 3B200010  li r25, 0x10
	ctx.r[25].s64 = 16;
	// 824A0060: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 824A0064: 83DB02F8  lwz r30, 0x2f8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(760 as u32) ) } as u64;
	// 824A0068: 3FA08000  lis r29, -0x8000
	ctx.r[29].s64 = -2147483648;
	// 824A006C: 395E0002  addi r10, r30, 2
	ctx.r[10].s64 = ctx.r[30].s64 + 2;
	// 824A0070: 7D79C02E  lwzx r11, r25, r24
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 824A0074: 55441836  rlwinm r4, r10, 3, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 824A0078: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 824A007C: 93410074  stw r26, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[26].u32 ) };
	// 824A0080: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 824A0084: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A0088: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A008C: 7D432214  add r10, r3, r4
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 824A0090: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A0094: 4199000C  bgt cr6, 0x824a00a0
	if ctx.cr[6].gt {
	pc = 0x824A00A0; continue 'dispatch;
	}
	// 824A0098: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 824A009C: 48000018  b 0x824a00b4
	pc = 0x824A00B4; continue 'dispatch;
            }
            0x824A00A0 => {
    //   block [0x824A00A0..0x824A00B4)
	// 824A00A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A00A4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A00A8: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A00AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A00B0: 4E800421  bctrl
	ctx.lr = 0x824A00B4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A00B4 => {
    //   block [0x824A00B4..0x824A00FC)
	// 824A00B4: 7FCAEB78  or r10, r30, r29
	ctx.r[10].u64 = ctx.r[30].u64 | ctx.r[29].u64;
	// 824A00B8: 7D79C02E  lwzx r11, r25, r24
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 824A00BC: 839B02F8  lwz r28, 0x2f8(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(760 as u32) ) } as u64;
	// 824A00C0: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 824A00C4: 393C0002  addi r9, r28, 2
	ctx.r[9].s64 = ctx.r[28].s64 + 2;
	// 824A00C8: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 824A00CC: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 824A00D0: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 824A00D4: 55241836  rlwinm r4, r9, 3, 0, 0x1b
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 824A00D8: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 824A00DC: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 824A00E0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A00E4: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A00E8: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 824A00EC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824A00F0: 4199000C  bgt cr6, 0x824a00fc
	if ctx.cr[6].gt {
	pc = 0x824A00FC; continue 'dispatch;
	}
	// 824A00F4: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 824A00F8: 4800001C  b 0x824a0114
	pc = 0x824A0114; continue 'dispatch;
            }
            0x824A00FC => {
    //   block [0x824A00FC..0x824A0114)
	// 824A00FC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0100: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A0104: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A0108: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A010C: 4E800421  bctrl
	ctx.lr = 0x824A0110;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A0110: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            0x824A0114 => {
    //   block [0x824A0114..0x824A0144)
	// 824A0114: 7F8BEB78  or r11, r28, r29
	ctx.r[11].u64 = ctx.r[28].u64 | ctx.r[29].u64;
	// 824A0118: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 824A011C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 824A0120: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 824A0124: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A0128: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 824A012C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 824A0130: 40990014  ble cr6, 0x824a0144
	if !ctx.cr[6].gt {
	pc = 0x824A0144; continue 'dispatch;
	}
	// 824A0134: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 824A0138: 807B006C  lwz r3, 0x6c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A013C: 3881010C  addi r4, r1, 0x10c
	ctx.r[4].s64 = ctx.r[1].s64 + 268;
	// 824A0140: 4BFFC1A1  bl 0x8249c2e0
	ctx.lr = 0x824A0144;
	sub_8249C2E0(ctx, base);
	pc = 0x824A0144; continue 'dispatch;
            }
            0x824A0144 => {
    //   block [0x824A0144..0x824A0230)
	// 824A0144: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 824A0148: 895F002D  lbz r10, 0x2d(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 824A014C: 8B9F002C  lbz r28, 0x2c(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A0150: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 824A0154: 893F002E  lbz r9, 0x2e(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 824A0158: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 824A015C: 83DF0024  lwz r30, 0x24(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 824A0160: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 824A0164: 83BF0028  lwz r29, 0x28(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A0168: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 824A016C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824A0170: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824A0174: 897F002F  lbz r11, 0x2f(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(47 as u32) ) } as u64;
	// 824A0178: 82FF0020  lwz r23, 0x20(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A017C: 807B0054  lwz r3, 0x54(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A0180: 7D4A5830  slw r10, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 824A0184: 7D295830  slw r9, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 824A0188: 7D4AF050  subf r10, r10, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[10].s64;
	// 824A018C: 7F9E5830  slw r30, r28, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[30].u64 = 0;
	} else {
		ctx.r[30].u64 = ((ctx.r[28].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 824A0190: 7D29E850  subf r9, r9, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[9].s64;
	// 824A0194: 7FDEB850  subf r30, r30, r23
	ctx.r[30].s64 = ctx.r[23].s64 - ctx.r[30].s64;
	// 824A0198: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 824A019C: 91210088  stw r9, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 824A01A0: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 824A01A4: 895F003D  lbz r10, 0x3d(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(61 as u32) ) } as u64;
	// 824A01A8: 893F003E  lbz r9, 0x3e(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(62 as u32) ) } as u64;
	// 824A01AC: 8B9F003C  lbz r28, 0x3c(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 824A01B0: 83BF0034  lwz r29, 0x34(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 824A01B4: 83DF0038  lwz r30, 0x38(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 824A01B8: 83FF0030  lwz r31, 0x30(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 824A01BC: 7D4A5830  slw r10, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 824A01C0: 7D295830  slw r9, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 824A01C4: 7F8B5830  slw r11, r28, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[28].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 824A01C8: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 824A01CC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 824A01D0: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 824A01D4: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 824A01D8: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 824A01DC: 91210098  stw r9, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[9].u32 ) };
	// 824A01E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A01E4: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A01E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A01EC: 4E800421  bctrl
	ctx.lr = 0x824A01F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A01F0: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824A01F4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824A01F8: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A01FC: 40810044  ble 0x824a0240
	if !ctx.cr[0].gt {
	pc = 0x824A0240; continue 'dispatch;
	}
	// 824A0200: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 824A0204: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 824A0208: 4805E091  bl 0x824fe298
	ctx.lr = 0x824A020C;
	sub_824FE298(ctx, base);
	// 824A020C: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824A0210: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824A0214: 807B0058  lwz r3, 0x58(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A0218: 4805E009  bl 0x824fe220
	ctx.lr = 0x824A021C;
	sub_824FE220(ctx, base);
	// 824A021C: 817B0070  lwz r11, 0x70(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(112 as u32) ) } as u64;
	// 824A0220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A0224: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 824A0228: 409A0008  bne cr6, 0x824a0230
	if !ctx.cr[6].eq {
	pc = 0x824A0230; continue 'dispatch;
	}
	// 824A022C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
            }
            0x824A0230 => {
    //   block [0x824A0230..0x824A0240)
	// 824A0230: 807B0058  lwz r3, 0x58(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A0234: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824A0238: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824A023C: 4805DF25  bl 0x824fe160
	ctx.lr = 0x824A0240;
	sub_824FE160(ctx, base);
	pc = 0x824A0240; continue 'dispatch;
            }
            0x824A0240 => {
    //   block [0x824A0240..0x824A0268)
	// 824A0240: 7C79C02E  lwzx r3, r25, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 824A0244: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A0248: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A024C: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824A0250: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A0254: 409A0014  bne cr6, 0x824a0268
	if !ctx.cr[6].eq {
	pc = 0x824A0268; continue 'dispatch;
	}
	// 824A0258: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A025C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A0260: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A0264: 4E800421  bctrl
	ctx.lr = 0x824A0268;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A0268 => {
    //   block [0x824A0268..0x824A028C)
	// 824A0268: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 824A026C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A0270: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A0274: 409A0018  bne cr6, 0x824a028c
	if !ctx.cr[6].eq {
	pc = 0x824A028C; continue 'dispatch;
	}
	// 824A0278: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A027C: 7C79C02E  lwzx r3, r25, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 824A0280: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A0284: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824A0288: 4BFC3E31  bl 0x824640b8
	ctx.lr = 0x824A028C;
	sub_824640B8(ctx, base);
	pc = 0x824A028C; continue 'dispatch;
            }
            0x824A028C => {
    //   block [0x824A028C..0x824A02B4)
	// 824A028C: 7C79C02E  lwzx r3, r25, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 824A0290: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 824A0294: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A0298: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824A029C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A02A0: 409A0014  bne cr6, 0x824a02b4
	if !ctx.cr[6].eq {
	pc = 0x824A02B4; continue 'dispatch;
	}
	// 824A02A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A02A8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A02AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A02B0: 4E800421  bctrl
	ctx.lr = 0x824A02B4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A02B4 => {
    //   block [0x824A02B4..0x824A02D8)
	// 824A02B4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 824A02B8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A02BC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A02C0: 409A0018  bne cr6, 0x824a02d8
	if !ctx.cr[6].eq {
	pc = 0x824A02D8; continue 'dispatch;
	}
	// 824A02C4: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A02C8: 7C79C02E  lwzx r3, r25, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 824A02CC: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A02D0: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824A02D4: 4BFC3DE5  bl 0x824640b8
	ctx.lr = 0x824A02D8;
	sub_824640B8(ctx, base);
	pc = 0x824A02D8; continue 'dispatch;
            }
            0x824A02D8 => {
    //   block [0x824A02D8..0x824A0308)
	// 824A02D8: 817B0084  lwz r11, 0x84(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A02DC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A02E0: 917B0084  stw r11, 0x84(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A02E4: 40820024  bne 0x824a0308
	if !ctx.cr[0].eq {
	pc = 0x824A0308; continue 'dispatch;
	}
	// 824A02E8: 897B008C  lbz r11, 0x8c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A02EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A02F0: 409A0018  bne cr6, 0x824a0308
	if !ctx.cr[6].eq {
	pc = 0x824A0308; continue 'dispatch;
	}
	// 824A02F4: 817B0080  lwz r11, 0x80(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A02F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A02FC: 419A000C  beq cr6, 0x824a0308
	if ctx.cr[6].eq {
	pc = 0x824A0308; continue 'dispatch;
	}
	// 824A0300: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 824A0304: 4BFF2EBD  bl 0x824931c0
	ctx.lr = 0x824A0308;
	sub_824931C0(ctx, base);
	pc = 0x824A0308; continue 'dispatch;
            }
            0x824A0308 => {
    //   block [0x824A0308..0x824A0310)
	// 824A0308: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 824A030C: 48094DE8  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A0310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A0310 size=364
    let mut pc: u32 = 0x824A0310;
    'dispatch: loop {
        match pc {
            0x824A0310 => {
    //   block [0x824A0310..0x824A037C)
	// 824A0310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A0314: 48094D99  bl 0x825350ac
	ctx.lr = 0x824A0318;
	sub_82535080(ctx, base);
	// 824A0318: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A031C: 3B640010  addi r27, r4, 0x10
	ctx.r[27].s64 = ctx.r[4].s64 + 16;
	// 824A0320: 908100DC  stw r4, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[4].u32 ) };
	// 824A0324: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A0328: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A032C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A0330: 419A0144  beq cr6, 0x824a0474
	if ctx.cr[6].eq {
	pc = 0x824A0474; continue 'dispatch;
	}
	// 824A0334: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0338: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 824A033C: 83DF02F8  lwz r30, 0x2f8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(760 as u32) ) } as u64;
	// 824A0340: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 824A0344: 3FA08000  lis r29, -0x8000
	ctx.r[29].s64 = -2147483648;
	// 824A0348: 397E0002  addi r11, r30, 2
	ctx.r[11].s64 = ctx.r[30].s64 + 2;
	// 824A034C: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A0350: 55641836  rlwinm r4, r11, 3, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 824A0354: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 824A0358: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 824A035C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 824A0360: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A0364: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A0368: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 824A036C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A0370: 4199000C  bgt cr6, 0x824a037c
	if ctx.cr[6].gt {
	pc = 0x824A037C; continue 'dispatch;
	}
	// 824A0374: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 824A0378: 48000018  b 0x824a0390
	pc = 0x824A0390; continue 'dispatch;
            }
            0x824A037C => {
    //   block [0x824A037C..0x824A0390)
	// 824A037C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0380: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A0384: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A0388: 4E800421  bctrl
	ctx.lr = 0x824A038C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A038C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            0x824A0390 => {
    //   block [0x824A0390..0x824A041C)
	// 824A0390: 7FCAEB78  or r10, r30, r29
	ctx.r[10].u64 = ctx.r[30].u64 | ctx.r[29].u64;
	// 824A0394: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A0398: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 824A039C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824A03A0: 388100DC  addi r4, r1, 0xdc
	ctx.r[4].s64 = ctx.r[1].s64 + 220;
	// 824A03A4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 824A03A8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 824A03AC: 4BFFBF35  bl 0x8249c2e0
	ctx.lr = 0x824A03B0;
	sub_8249C2E0(ctx, base);
	// 824A03B0: 816100DC  lwz r11, 0xdc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 824A03B4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 824A03B8: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A03BC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824A03C0: 394B0030  addi r10, r11, 0x30
	ctx.r[10].s64 = ctx.r[11].s64 + 48;
	// 824A03C4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 824A03C8: 389B0014  addi r4, r27, 0x14
	ctx.r[4].s64 = ctx.r[27].s64 + 20;
	// 824A03CC: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 824A03D0: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 824A03D4: E92A0008  ld r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 824A03D8: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 824A03DC: E92A0010  ld r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	// 824A03E0: F92B0010  std r9, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u64 ) };
	// 824A03E4: E94A0018  ld r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	// 824A03E8: F94B0018  std r10, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 824A03EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A03F0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A03F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A03F8: 4E800421  bctrl
	ctx.lr = 0x824A03FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A03FC: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A0400: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824A0404: 40990024  ble cr6, 0x824a0428
	if !ctx.cr[6].gt {
	pc = 0x824A0428; continue 'dispatch;
	}
	// 824A0408: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 824A040C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A0410: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 824A0414: 409A0008  bne cr6, 0x824a041c
	if !ctx.cr[6].eq {
	pc = 0x824A041C; continue 'dispatch;
	}
	// 824A0418: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
            }
            0x824A041C => {
    //   block [0x824A041C..0x824A0428)
	// 824A041C: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A0420: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824A0424: 4805DD3D  bl 0x824fe160
	ctx.lr = 0x824A0428;
	sub_824FE160(ctx, base);
	pc = 0x824A0428; continue 'dispatch;
            }
            0x824A0428 => {
    //   block [0x824A0428..0x824A0450)
	// 824A0428: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A042C: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 824A0430: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A0434: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824A0438: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A043C: 409A0014  bne cr6, 0x824a0450
	if !ctx.cr[6].eq {
	pc = 0x824A0450; continue 'dispatch;
	}
	// 824A0440: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0444: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A0448: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A044C: 4E800421  bctrl
	ctx.lr = 0x824A0450;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A0450 => {
    //   block [0x824A0450..0x824A0474)
	// 824A0450: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A0454: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A0458: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A045C: 409A0018  bne cr6, 0x824a0474
	if !ctx.cr[6].eq {
	pc = 0x824A0474; continue 'dispatch;
	}
	// 824A0460: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A0464: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A0468: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A046C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824A0470: 4BFC3C49  bl 0x824640b8
	ctx.lr = 0x824A0474;
	sub_824640B8(ctx, base);
	pc = 0x824A0474; continue 'dispatch;
            }
            0x824A0474 => {
    //   block [0x824A0474..0x824A047C)
	// 824A0474: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 824A0478: 48094C84  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A0480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A0480 size=316
    let mut pc: u32 = 0x824A0480;
    'dispatch: loop {
        match pc {
            0x824A0480 => {
    //   block [0x824A0480..0x824A04DC)
	// 824A0480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A0484: 48094C29  bl 0x825350ac
	ctx.lr = 0x824A0488;
	sub_82535080(ctx, base);
	// 824A0488: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A048C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824A0490: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0494: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 824A0498: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 824A049C: 3F808000  lis r28, -0x8000
	ctx.r[28].s64 = -2147483648;
	// 824A04A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824A04A4: 83BE02F8  lwz r29, 0x2f8(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(760 as u32) ) } as u64;
	// 824A04A8: 7D7AC82E  lwzx r11, r26, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A04AC: 395D0002  addi r10, r29, 2
	ctx.r[10].s64 = ctx.r[29].s64 + 2;
	// 824A04B0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 824A04B4: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 824A04B8: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 824A04BC: 55441836  rlwinm r4, r10, 3, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 824A04C0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A04C4: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A04C8: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 824A04CC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824A04D0: 4199000C  bgt cr6, 0x824a04dc
	if ctx.cr[6].gt {
	pc = 0x824A04DC; continue 'dispatch;
	}
	// 824A04D4: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 824A04D8: 4800001C  b 0x824a04f4
	pc = 0x824A04F4; continue 'dispatch;
            }
            0x824A04DC => {
    //   block [0x824A04DC..0x824A04F4)
	// 824A04DC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A04E0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A04E4: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A04E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A04EC: 4E800421  bctrl
	ctx.lr = 0x824A04F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A04F0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            0x824A04F4 => {
    //   block [0x824A04F4..0x824A055C)
	// 824A04F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A04F8: 7FA9E378  or r9, r29, r28
	ctx.r[9].u64 = ctx.r[29].u64 | ctx.r[28].u64;
	// 824A04FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 824A0500: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 824A0504: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 824A0508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A050C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A0510: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 824A0514: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A0518: 4E800421  bctrl
	ctx.lr = 0x824A051C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A051C: 807E0054  lwz r3, 0x54(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A0520: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 824A0524: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824A0528: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 824A052C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0530: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A0534: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A0538: 4E800421  bctrl
	ctx.lr = 0x824A053C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A053C: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A0540: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824A0544: 419A0024  beq cr6, 0x824a0568
	if ctx.cr[6].eq {
	pc = 0x824A0568; continue 'dispatch;
	}
	// 824A0548: 817E0070  lwz r11, 0x70(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 824A054C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A0550: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 824A0554: 409A0008  bne cr6, 0x824a055c
	if !ctx.cr[6].eq {
	pc = 0x824A055C; continue 'dispatch;
	}
	// 824A0558: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
            }
            0x824A055C => {
    //   block [0x824A055C..0x824A0568)
	// 824A055C: 807E0058  lwz r3, 0x58(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A0560: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824A0564: 4805DBFD  bl 0x824fe160
	ctx.lr = 0x824A0568;
	sub_824FE160(ctx, base);
	pc = 0x824A0568; continue 'dispatch;
            }
            0x824A0568 => {
    //   block [0x824A0568..0x824A0590)
	// 824A0568: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A056C: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 824A0570: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A0574: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824A0578: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A057C: 409A0014  bne cr6, 0x824a0590
	if !ctx.cr[6].eq {
	pc = 0x824A0590; continue 'dispatch;
	}
	// 824A0580: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0584: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A0588: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A058C: 4E800421  bctrl
	ctx.lr = 0x824A0590;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A0590 => {
    //   block [0x824A0590..0x824A05B4)
	// 824A0590: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A0594: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A0598: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A059C: 409A0018  bne cr6, 0x824a05b4
	if !ctx.cr[6].eq {
	pc = 0x824A05B4; continue 'dispatch;
	}
	// 824A05A0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A05A4: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A05A8: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A05AC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824A05B0: 4BFC3B09  bl 0x824640b8
	ctx.lr = 0x824A05B4;
	sub_824640B8(ctx, base);
	pc = 0x824A05B4; continue 'dispatch;
            }
            0x824A05B4 => {
    //   block [0x824A05B4..0x824A05BC)
	// 824A05B4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 824A05B8: 48094B44  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A05C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A05C0 size=336
    let mut pc: u32 = 0x824A05C0;
    'dispatch: loop {
        match pc {
            0x824A05C0 => {
    //   block [0x824A05C0..0x824A065C)
	// 824A05C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A05C4: 48094AED  bl 0x825350b0
	ctx.lr = 0x824A05C8;
	sub_82535080(ctx, base);
	// 824A05C8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A05CC: 3B440010  addi r26, r4, 0x10
	ctx.r[26].s64 = ctx.r[4].s64 + 16;
	// 824A05D0: 908100CC  stw r4, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[4].u32 ) };
	// 824A05D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A05D8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A05DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A05E0: 419A0128  beq cr6, 0x824a0708
	if ctx.cr[6].eq {
	pc = 0x824A0708; continue 'dispatch;
	}
	// 824A05E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824A05E8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A05EC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 824A05F0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 824A05F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 824A05F8: 388100CC  addi r4, r1, 0xcc
	ctx.r[4].s64 = ctx.r[1].s64 + 204;
	// 824A05FC: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 824A0600: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0604: 88EB0000  lbz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0608: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A060C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A0610: 4E800421  bctrl
	ctx.lr = 0x824A0614;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A0614: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A0618: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A061C: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 824A0620: 83DF02F8  lwz r30, 0x2f8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(760 as u32) ) } as u64;
	// 824A0624: 3F608000  lis r27, -0x8000
	ctx.r[27].s64 = -2147483648;
	// 824A0628: 395E0002  addi r10, r30, 2
	ctx.r[10].s64 = ctx.r[30].s64 + 2;
	// 824A062C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824A0630: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 824A0634: 55441836  rlwinm r4, r10, 3, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 824A0638: 7D7DE02E  lwzx r11, r29, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A063C: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 824A0640: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A0644: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A0648: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 824A064C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824A0650: 4199000C  bgt cr6, 0x824a065c
	if ctx.cr[6].gt {
	pc = 0x824A065C; continue 'dispatch;
	}
	// 824A0654: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 824A0658: 4800001C  b 0x824a0674
	pc = 0x824A0674; continue 'dispatch;
            }
            0x824A065C => {
    //   block [0x824A065C..0x824A0674)
	// 824A065C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0660: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A0664: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A0668: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A066C: 4E800421  bctrl
	ctx.lr = 0x824A0670;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A0670: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            0x824A0674 => {
    //   block [0x824A0674..0x824A06BC)
	// 824A0674: 7FC9DB78  or r9, r30, r27
	ctx.r[9].u64 = ctx.r[30].u64 | ctx.r[27].u64;
	// 824A0678: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A067C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 824A0680: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824A0684: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 824A0688: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A068C: 389A0014  addi r4, r26, 0x14
	ctx.r[4].s64 = ctx.r[26].s64 + 20;
	// 824A0690: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 824A0694: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0698: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 824A069C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A06A0: 4E800421  bctrl
	ctx.lr = 0x824A06A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A06A4: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824A06A8: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824A06AC: 40990010  ble cr6, 0x824a06bc
	if !ctx.cr[6].gt {
	pc = 0x824A06BC; continue 'dispatch;
	}
	// 824A06B0: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824A06B4: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A06B8: 4805DB69  bl 0x824fe220
	ctx.lr = 0x824A06BC;
	sub_824FE220(ctx, base);
            }
            0x824A06BC => {
    //   block [0x824A06BC..0x824A06E4)
	// 824A06BC: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A06C0: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A06C4: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A06C8: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824A06CC: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A06D0: 409A0014  bne cr6, 0x824a06e4
	if !ctx.cr[6].eq {
	pc = 0x824A06E4; continue 'dispatch;
	}
	// 824A06D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A06D8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A06DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A06E0: 4E800421  bctrl
	ctx.lr = 0x824A06E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A06E4 => {
    //   block [0x824A06E4..0x824A0708)
	// 824A06E4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 824A06E8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A06EC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A06F0: 409A0018  bne cr6, 0x824a0708
	if !ctx.cr[6].eq {
	pc = 0x824A0708; continue 'dispatch;
	}
	// 824A06F4: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A06F8: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A06FC: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A0700: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824A0704: 4BFC39B5  bl 0x824640b8
	ctx.lr = 0x824A0708;
	sub_824640B8(ctx, base);
	pc = 0x824A0708; continue 'dispatch;
            }
            0x824A0708 => {
    //   block [0x824A0708..0x824A0710)
	// 824A0708: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 824A070C: 480949F4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A0710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A0710 size=272
    let mut pc: u32 = 0x824A0710;
    'dispatch: loop {
        match pc {
            0x824A0710 => {
    //   block [0x824A0710..0x824A076C)
	// 824A0710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A0714: 4809499D  bl 0x825350b0
	ctx.lr = 0x824A0718;
	sub_82535080(ctx, base);
	// 824A0718: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A071C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A0720: 836D0000  lwz r27, 0(r13)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0724: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A0728: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 824A072C: 3F408000  lis r26, -0x8000
	ctx.r[26].s64 = -2147483648;
	// 824A0730: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824A0734: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824A0738: 83DF02F8  lwz r30, 0x2f8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(760 as u32) ) } as u64;
	// 824A073C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 824A0740: 7D7CD82E  lwzx r11, r28, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 824A0744: 395E0002  addi r10, r30, 2
	ctx.r[10].s64 = ctx.r[30].s64 + 2;
	// 824A0748: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 824A074C: 55441836  rlwinm r4, r10, 3, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 824A0750: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A0754: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A0758: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 824A075C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824A0760: 4199000C  bgt cr6, 0x824a076c
	if ctx.cr[6].gt {
	pc = 0x824A076C; continue 'dispatch;
	}
	// 824A0764: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 824A0768: 4800001C  b 0x824a0784
	pc = 0x824A0784; continue 'dispatch;
            }
            0x824A076C => {
    //   block [0x824A076C..0x824A0784)
	// 824A076C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0770: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A0774: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A0778: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A077C: 4E800421  bctrl
	ctx.lr = 0x824A0780;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A0780: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            0x824A0784 => {
    //   block [0x824A0784..0x824A07CC)
	// 824A0784: 7FC9D378  or r9, r30, r26
	ctx.r[9].u64 = ctx.r[30].u64 | ctx.r[26].u64;
	// 824A0788: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A078C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 824A0790: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824A0794: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 824A0798: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A079C: 389D0024  addi r4, r29, 0x24
	ctx.r[4].s64 = ctx.r[29].s64 + 36;
	// 824A07A0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 824A07A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A07A8: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 824A07AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A07B0: 4E800421  bctrl
	ctx.lr = 0x824A07B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A07B4: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A07B8: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824A07BC: 419A0010  beq cr6, 0x824a07cc
	if ctx.cr[6].eq {
	pc = 0x824A07CC; continue 'dispatch;
	}
	// 824A07C0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824A07C4: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A07C8: 4805DA59  bl 0x824fe220
	ctx.lr = 0x824A07CC;
	sub_824FE220(ctx, base);
            }
            0x824A07CC => {
    //   block [0x824A07CC..0x824A07F4)
	// 824A07CC: 7C7CD82E  lwzx r3, r28, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 824A07D0: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 824A07D4: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A07D8: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824A07DC: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A07E0: 409A0014  bne cr6, 0x824a07f4
	if !ctx.cr[6].eq {
	pc = 0x824A07F4; continue 'dispatch;
	}
	// 824A07E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A07E8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A07EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A07F0: 4E800421  bctrl
	ctx.lr = 0x824A07F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A07F4 => {
    //   block [0x824A07F4..0x824A0818)
	// 824A07F4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A07F8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A07FC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A0800: 409A0018  bne cr6, 0x824a0818
	if !ctx.cr[6].eq {
	pc = 0x824A0818; continue 'dispatch;
	}
	// 824A0804: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A0808: 7C7CD82E  lwzx r3, r28, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 824A080C: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A0810: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824A0814: 4BFC38A5  bl 0x824640b8
	ctx.lr = 0x824A0818;
	sub_824640B8(ctx, base);
	pc = 0x824A0818; continue 'dispatch;
            }
            0x824A0818 => {
    //   block [0x824A0818..0x824A0820)
	// 824A0818: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A081C: 480948E4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A0820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A0820 size=3732
    let mut pc: u32 = 0x824A0820;
    'dispatch: loop {
        match pc {
            0x824A0820 => {
    //   block [0x824A0820..0x824A0874)
	// 824A0820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A0824: 4809485D  bl 0x82535080
	ctx.lr = 0x824A0828;
	sub_82535080(ctx, base);
	// 824A0828: 9421FDE0  stwu r1, -0x220(r1)
	ea = ctx.r[1].u32.wrapping_add(-544 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A082C: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 824A0830: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0834: 39C00010  li r14, 0x10
	ctx.r[14].s64 = 16;
	// 824A0838: 7C902378  mr r16, r4
	ctx.r[16].u64 = ctx.r[4].u64;
	// 824A083C: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 824A0840: 7CD13378  mr r17, r6
	ctx.r[17].u64 = ctx.r[6].u64;
	// 824A0844: 8172004C  lwz r11, 0x4c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A0848: 7C6EE02E  lwzx r3, r14, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A084C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824A0850: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 824A0854: 55641036  rlwinm r4, r11, 2, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824A0858: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A085C: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A0860: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 824A0864: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A0868: 4199000C  bgt cr6, 0x824a0874
	if ctx.cr[6].gt {
	pc = 0x824A0874; continue 'dispatch;
	}
	// 824A086C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 824A0870: 48000018  b 0x824a0888
	pc = 0x824A0888; continue 'dispatch;
            }
            0x824A0874 => {
    //   block [0x824A0874..0x824A0888)
	// 824A0874: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0878: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A087C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A0880: 4E800421  bctrl
	ctx.lr = 0x824A0884;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A0884: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            0x824A0888 => {
    //   block [0x824A0888..0x824A08C8)
	// 824A0888: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 824A088C: 80B2004C  lwz r5, 0x4c(r18)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A0890: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 824A0894: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 824A0898: 4810A641  bl 0x825aaed8
	ctx.lr = 0x824A089C;
	sub_825AAED8(ctx, base);
	// 824A089C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 824A08A0: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 824A08A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 824A08A8: 48016301  bl 0x824b6ba8
	ctx.lr = 0x824A08AC;
	sub_824B6BA8(ctx, base);
	// 824A08AC: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A08B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A08B4: 419A0014  beq cr6, 0x824a08c8
	if ctx.cr[6].eq {
	pc = 0x824A08C8; continue 'dispatch;
	}
	// 824A08B8: 89720025  lbz r11, 0x25(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[18].u32.wrapping_add(37 as u32) ) } as u64;
	// 824A08BC: 716B00CF  andi. r11, r11, 0xcf
	ctx.r[11].u64 = ctx.r[11].u64 & 207;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A08C0: 99720025  stb r11, 0x25(r18)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[18].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 824A08C4: 48000DC0  b 0x824a1684
	pc = 0x824A1684; continue 'dispatch;
            }
            0x824A08C8 => {
    //   block [0x824A08C8..0x824A0920)
	// 824A08C8: 396100AC  addi r11, r1, 0xac
	ctx.r[11].s64 = ctx.r[1].s64 + 172;
	// 824A08CC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 824A08D0: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 824A08D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 824A08D8: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 824A08DC: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 824A08E0: 936100A4  stw r27, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[27].u32 ) };
	// 824A08E4: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 824A08E8: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 824A08EC: 4810A7E5  bl 0x825ab0d0
	ctx.lr = 0x824A08F0;
	sub_825AB0D0(ctx, base);
	// 824A08F0: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 824A08F4: 7C6EE02E  lwzx r3, r14, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A08F8: 396B0011  addi r11, r11, 0x11
	ctx.r[11].s64 = ctx.r[11].s64 + 17;
	// 824A08FC: 55640036  rlwinm r4, r11, 0, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A0900: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A0904: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A0908: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 824A090C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A0910: 41990010  bgt cr6, 0x824a0920
	if ctx.cr[6].gt {
	pc = 0x824A0920; continue 'dispatch;
	}
	// 824A0914: 7D6F5B78  mr r15, r11
	ctx.r[15].u64 = ctx.r[11].u64;
	// 824A0918: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 824A091C: 48000018  b 0x824a0934
	pc = 0x824A0934; continue 'dispatch;
            }
            0x824A0920 => {
    //   block [0x824A0920..0x824A0934)
	// 824A0920: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0924: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A0928: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A092C: 4E800421  bctrl
	ctx.lr = 0x824A0930;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A0930: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
            }
            0x824A0934 => {
    //   block [0x824A0934..0x824A0984)
	// 824A0934: 89720025  lbz r11, 0x25(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[18].u32.wrapping_add(37 as u32) ) } as u64;
	// 824A0938: 556B06B6  rlwinm r11, r11, 0, 0x1a, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A093C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A0940: 419A01D4  beq cr6, 0x824a0b14
	if ctx.cr[6].eq {
	pc = 0x824A0B14; continue 'dispatch;
	}
	// 824A0944: 897000C5  lbz r11, 0xc5(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[16].u32.wrapping_add(197 as u32) ) } as u64;
	// 824A0948: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A094C: 419A0CEC  beq cr6, 0x824a1638
	if ctx.cr[6].eq {
	pc = 0x824A1638; continue 'dispatch;
	}
	// 824A0950: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 824A0954: 3BF20048  addi r31, r18, 0x48
	ctx.r[31].s64 = ctx.r[18].s64 + 72;
	// 824A0958: 7D6EE02E  lwzx r11, r14, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A095C: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 824A0960: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 824A0964: 55241036  rlwinm r4, r9, 2, 0, 0x1b
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x3FFFFFFFu64;
	// 824A0968: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A096C: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A0970: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 824A0974: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824A0978: 4199000C  bgt cr6, 0x824a0984
	if ctx.cr[6].gt {
	pc = 0x824A0984; continue 'dispatch;
	}
	// 824A097C: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 824A0980: 4800001C  b 0x824a099c
	pc = 0x824A099C; continue 'dispatch;
            }
            0x824A0984 => {
    //   block [0x824A0984..0x824A099C)
	// 824A0984: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0988: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A098C: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A0990: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A0994: 4E800421  bctrl
	ctx.lr = 0x824A0998;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A0998: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            0x824A099C => {
    //   block [0x824A099C..0x824A09B0)
	// 824A099C: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 824A09A0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824A09A4: 40990024  ble cr6, 0x824a09c8
	if !ctx.cr[6].gt {
	pc = 0x824A09C8; continue 'dispatch;
	}
	// 824A09A8: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 824A09AC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x824A09B0; continue 'dispatch;
            }
            0x824A09B0 => {
    //   block [0x824A09B0..0x824A09C8)
	// 824A09B0: 81210080  lwz r9, 0x80(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A09B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824A09B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A09BC: 7F6A492E  stwx r27, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[27].u32) };
	// 824A09C0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824A09C4: 409AFFEC  bne cr6, 0x824a09b0
	if !ctx.cr[6].eq {
	pc = 0x824A09B0; continue 'dispatch;
	}
	pc = 0x824A09C8; continue 'dispatch;
            }
            0x824A09C8 => {
    //   block [0x824A09C8..0x824A09E0)
	// 824A09C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A09CC: 38F002C5  addi r7, r16, 0x2c5
	ctx.r[7].s64 = ctx.r[16].s64 + 709;
	// 824A09D0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 824A09D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A09D8: 40990094  ble cr6, 0x824a0a6c
	if !ctx.cr[6].gt {
	pc = 0x824A0A6C; continue 'dispatch;
	}
	// 824A09DC: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	pc = 0x824A09E0; continue 'dispatch;
            }
            0x824A09E0 => {
    //   block [0x824A09E0..0x824A0A00)
	// 824A09E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A09E4: 89270001  lbz r9, 1(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(1 as u32) ) } as u64;
	// 824A09E8: 7D4B402E  lwzx r10, r11, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 824A09EC: A16A00DC  lhz r11, 0xdc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(220 as u32) ) } as u64;
	// 824A09F0: 7D657670  srawi r5, r11, 0xe
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 14) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 14) as i64;
	// 824A09F4: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 824A09F8: 409A0008  bne cr6, 0x824a0a00
	if !ctx.cr[6].eq {
	pc = 0x824A0A00; continue 'dispatch;
	}
	// 824A09FC: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	pc = 0x824A0A00; continue 'dispatch;
            }
            0x824A0A00 => {
    //   block [0x824A0A00..0x824A0A1C)
	// 824A0A00: 5569067E  clrlwi r9, r11, 0x19
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 824A0A04: A16A00DA  lhz r11, 0xda(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(218 as u32) ) } as u64;
	// 824A0A08: 89470000  lbz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0A0C: 7D657670  srawi r5, r11, 0xe
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 14) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 14) as i64;
	// 824A0A10: 7F0A2800  cmpw cr6, r10, r5
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[5].s32, &mut ctx.xer);
	// 824A0A14: 409A0008  bne cr6, 0x824a0a1c
	if !ctx.cr[6].eq {
	pc = 0x824A0A1C; continue 'dispatch;
	}
	// 824A0A18: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	pc = 0x824A0A1C; continue 'dispatch;
            }
            0x824A0A1C => {
    //   block [0x824A0A1C..0x824A0A34)
	// 824A0A1C: 556A067E  clrlwi r10, r11, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 824A0A20: 552B067E  clrlwi r11, r9, 0x19
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000007Fu64;
	// 824A0A24: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 824A0A28: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A0A2C: 40990008  ble cr6, 0x824a0a34
	if !ctx.cr[6].gt {
	pc = 0x824A0A34; continue 'dispatch;
	}
	// 824A0A30: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x824A0A34; continue 'dispatch;
            }
            0x824A0A34 => {
    //   block [0x824A0A34..0x824A0A58)
	// 824A0A34: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 824A0A38: 41990020  bgt cr6, 0x824a0a58
	if ctx.cr[6].gt {
	pc = 0x824A0A58; continue 'dispatch;
	}
	// 824A0A3C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A0A40: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824A0A44: 81210080  lwz r9, 0x80(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A0A48: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0A4C: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A0A50: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A0A54: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	pc = 0x824A0A58; continue 'dispatch;
            }
            0x824A0A58 => {
    //   block [0x824A0A58..0x824A0A6C)
	// 824A0A58: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A0A5C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 824A0A60: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 824A0A64: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A0A68: 4198FF78  blt cr6, 0x824a09e0
	if ctx.cr[6].lt {
	pc = 0x824A09E0; continue 'dispatch;
	}
	pc = 0x824A0A6C; continue 'dispatch;
            }
            0x824A0A6C => {
    //   block [0x824A0A6C..0x824A0A88)
	// 824A0A6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 824A0A70: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A0A74: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824A0A78: 98AF0000  stb r5, 0(r15)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[15].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 824A0A7C: 40990040  ble cr6, 0x824a0abc
	if !ctx.cr[6].gt {
	pc = 0x824A0ABC; continue 'dispatch;
	}
	// 824A0A80: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 824A0A84: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x824A0A88; continue 'dispatch;
            }
            0x824A0A88 => {
    //   block [0x824A0A88..0x824A0AA0)
	// 824A0A88: 81010080  lwz r8, 0x80(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A0A8C: 7D0B402E  lwzx r8, r11, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 824A0A90: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824A0A94: 419A000C  beq cr6, 0x824a0aa0
	if ctx.cr[6].eq {
	pc = 0x824A0AA0; continue 'dispatch;
	}
	// 824A0A98: 7F6B512E  stwx r27, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[27].u32) };
	// 824A0A9C: 48000010  b 0x824a0aac
	pc = 0x824A0AAC; continue 'dispatch;
            }
            0x824A0AA0 => {
    //   block [0x824A0AA0..0x824A0AAC)
	// 824A0AA0: 7CAB512E  stwx r5, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 824A0AA4: 7F6579AE  stbx r27, r5, r15
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[15].u32), ctx.r[27].u8) };
	// 824A0AA8: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	pc = 0x824A0AAC; continue 'dispatch;
            }
            0x824A0AAC => {
    //   block [0x824A0AAC..0x824A0ABC)
	// 824A0AAC: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 824A0AB0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824A0AB4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 824A0AB8: 409AFFD0  bne cr6, 0x824a0a88
	if !ctx.cr[6].eq {
	pc = 0x824A0A88; continue 'dispatch;
	}
	pc = 0x824A0ABC; continue 'dispatch;
            }
            0x824A0ABC => {
    //   block [0x824A0ABC..0x824A0ACC)
	// 824A0ABC: 7F05F000  cmpw cr6, r5, r30
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[30].s32, &mut ctx.xer);
	// 824A0AC0: 4099000C  ble cr6, 0x824a0acc
	if !ctx.cr[6].gt {
	pc = 0x824A0ACC; continue 'dispatch;
	}
	// 824A0AC4: 9B6F0000  stb r27, 0(r15)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[15].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	// 824A0AC8: 48000014  b 0x824a0adc
	pc = 0x824A0ADC; continue 'dispatch;
            }
            0x824A0ACC => {
    //   block [0x824A0ACC..0x824A0ADC)
	// 824A0ACC: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 824A0AD0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 824A0AD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 824A0AD8: 4810A831  bl 0x825ab308
	ctx.lr = 0x824A0ADC;
	sub_825AB308(ctx, base);
	pc = 0x824A0ADC; continue 'dispatch;
            }
            0x824A0ADC => {
    //   block [0x824A0ADC..0x824A0B04)
	// 824A0ADC: 7C6EE02E  lwzx r3, r14, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A0AE0: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A0AE4: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A0AE8: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824A0AEC: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A0AF0: 409A0014  bne cr6, 0x824a0b04
	if !ctx.cr[6].eq {
	pc = 0x824A0B04; continue 'dispatch;
	}
	// 824A0AF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0AF8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A0AFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A0B00: 4E800421  bctrl
	ctx.lr = 0x824A0B04;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A0B04 => {
    //   block [0x824A0B04..0x824A0B14)
	// 824A0B04: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 824A0B08: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 824A0B0C: 409A039C  bne cr6, 0x824a0ea8
	if !ctx.cr[6].eq {
	pc = 0x824A0EA8; continue 'dispatch;
	}
	// 824A0B10: 48000B28  b 0x824a1638
	pc = 0x824A1638; continue 'dispatch;
            }
            0x824A0B14 => {
    //   block [0x824A0B14..0x824A0B58)
	// 824A0B14: 817000A4  lwz r11, 0xa4(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(164 as u32) ) } as u64;
	// 824A0B18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A0B1C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 824A0B20: 419A0378  beq cr6, 0x824a0e98
	if ctx.cr[6].eq {
	pc = 0x824A0E98; continue 'dispatch;
	}
	// 824A0B24: 7C6EE02E  lwzx r3, r14, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A0B28: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 824A0B2C: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 824A0B30: 57E41036  rlwinm r4, r31, 2, 0, 0x1b
	ctx.r[4].u64 = ctx.r[31].u32 as u64 & 0x3FFFFFFFu64;
	// 824A0B34: 3BD20048  addi r30, r18, 0x48
	ctx.r[30].s64 = ctx.r[18].s64 + 72;
	// 824A0B38: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A0B3C: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A0B40: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 824A0B44: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A0B48: 41990010  bgt cr6, 0x824a0b58
	if ctx.cr[6].gt {
	pc = 0x824A0B58; continue 'dispatch;
	}
	// 824A0B4C: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 824A0B50: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 824A0B54: 48000018  b 0x824a0b6c
	pc = 0x824A0B6C; continue 'dispatch;
            }
            0x824A0B58 => {
    //   block [0x824A0B58..0x824A0B6C)
	// 824A0B58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0B5C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A0B60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A0B64: 4E800421  bctrl
	ctx.lr = 0x824A0B68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A0B68: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
            }
            0x824A0B6C => {
    //   block [0x824A0B6C..0x824A0B90)
	// 824A0B6C: 7D6EE02E  lwzx r11, r14, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A0B70: 57E41036  rlwinm r4, r31, 2, 0, 0x1b
	ctx.r[4].u64 = ctx.r[31].u32 as u64 & 0x3FFFFFFFu64;
	// 824A0B74: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A0B78: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A0B7C: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 824A0B80: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824A0B84: 4199000C  bgt cr6, 0x824a0b90
	if ctx.cr[6].gt {
	pc = 0x824A0B90; continue 'dispatch;
	}
	// 824A0B88: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 824A0B8C: 4800001C  b 0x824a0ba8
	pc = 0x824A0BA8; continue 'dispatch;
            }
            0x824A0B90 => {
    //   block [0x824A0B90..0x824A0BA8)
	// 824A0B90: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0B94: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A0B98: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A0B9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A0BA0: 4E800421  bctrl
	ctx.lr = 0x824A0BA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A0BA4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            0x824A0BA8 => {
    //   block [0x824A0BA8..0x824A0BBC)
	// 824A0BA8: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 824A0BAC: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 824A0BB0: 40990028  ble cr6, 0x824a0bd8
	if !ctx.cr[6].gt {
	pc = 0x824A0BD8; continue 'dispatch;
	}
	// 824A0BB4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 824A0BB8: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	pc = 0x824A0BBC; continue 'dispatch;
            }
            0x824A0BBC => {
    //   block [0x824A0BBC..0x824A0BD8)
	// 824A0BBC: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 824A0BC0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824A0BC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824A0BC8: 7F6B492E  stwx r27, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[27].u32) };
	// 824A0BCC: 7F6BC92E  stwx r27, r11, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32), ctx.r[27].u32) };
	// 824A0BD0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824A0BD4: 409AFFE8  bne cr6, 0x824a0bbc
	if !ctx.cr[6].eq {
	pc = 0x824A0BBC; continue 'dispatch;
	}
	pc = 0x824A0BD8; continue 'dispatch;
            }
            0x824A0BD8 => {
    //   block [0x824A0BD8..0x824A0BFC)
	// 824A0BD8: 897000C5  lbz r11, 0xc5(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[16].u32.wrapping_add(197 as u32) ) } as u64;
	// 824A0BDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A0BE0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A0BE4: 419A00C8  beq cr6, 0x824a0cac
	if ctx.cr[6].eq {
	pc = 0x824A0CAC; continue 'dispatch;
	}
	// 824A0BE8: 389002C5  addi r4, r16, 0x2c5
	ctx.r[4].s64 = ctx.r[16].s64 + 709;
	// 824A0BEC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 824A0BF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A0BF4: 4099011C  ble cr6, 0x824a0d10
	if !ctx.cr[6].gt {
	pc = 0x824A0D10; continue 'dispatch;
	}
	// 824A0BF8: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	pc = 0x824A0BFC; continue 'dispatch;
            }
            0x824A0BFC => {
    //   block [0x824A0BFC..0x824A0C28)
	// 824A0BFC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0C00: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A0C04: 89240001  lbz r9, 1(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(1 as u32) ) } as u64;
	// 824A0C08: 7CE8582E  lwzx r7, r8, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A0C0C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0C10: A16700DC  lhz r11, 0xdc(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(220 as u32) ) } as u64;
	// 824A0C14: 7CC8502E  lwzx r6, r8, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824A0C18: 7D6A7670  srawi r10, r11, 0xe
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 14) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 14) as i64;
	// 824A0C1C: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824A0C20: 409A0008  bne cr6, 0x824a0c28
	if !ctx.cr[6].eq {
	pc = 0x824A0C28; continue 'dispatch;
	}
	// 824A0C24: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	pc = 0x824A0C28; continue 'dispatch;
            }
            0x824A0C28 => {
    //   block [0x824A0C28..0x824A0C44)
	// 824A0C28: 5569067E  clrlwi r9, r11, 0x19
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 824A0C2C: A16700DA  lhz r11, 0xda(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(218 as u32) ) } as u64;
	// 824A0C30: 89440000  lbz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0C34: 7D637670  srawi r3, r11, 0xe
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 14) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 14) as i64;
	// 824A0C38: 7F0A1800  cmpw cr6, r10, r3
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[3].s32, &mut ctx.xer);
	// 824A0C3C: 409A0008  bne cr6, 0x824a0c44
	if !ctx.cr[6].eq {
	pc = 0x824A0C44; continue 'dispatch;
	}
	// 824A0C40: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	pc = 0x824A0C44; continue 'dispatch;
            }
            0x824A0C44 => {
    //   block [0x824A0C44..0x824A0C5C)
	// 824A0C44: 556A067E  clrlwi r10, r11, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 824A0C48: 552B067E  clrlwi r11, r9, 0x19
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000007Fu64;
	// 824A0C4C: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 824A0C50: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A0C54: 40990008  ble cr6, 0x824a0c5c
	if !ctx.cr[6].gt {
	pc = 0x824A0C5C; continue 'dispatch;
	}
	// 824A0C58: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x824A0C5C; continue 'dispatch;
            }
            0x824A0C5C => {
    //   block [0x824A0C5C..0x824A0C74)
	// 824A0C5C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 824A0C60: 41990014  bgt cr6, 0x824a0c74
	if ctx.cr[6].gt {
	pc = 0x824A0C74; continue 'dispatch;
	}
	// 824A0C64: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 824A0C68: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A0C6C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824A0C70: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	pc = 0x824A0C74; continue 'dispatch;
            }
            0x824A0C74 => {
    //   block [0x824A0C74..0x824A0C84)
	// 824A0C74: A127009C  lhz r9, 0x9c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(156 as u32) ) } as u64;
	// 824A0C78: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 824A0C7C: 40980008  bge cr6, 0x824a0c84
	if !ctx.cr[6].lt {
	pc = 0x824A0C84; continue 'dispatch;
	}
	// 824A0C80: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x824A0C84; continue 'dispatch;
            }
            0x824A0C84 => {
    //   block [0x824A0C84..0x824A0CAC)
	// 824A0C84: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A0C88: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 824A0C8C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 824A0C90: 7D4BC82E  lwzx r10, r11, r25
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A0C94: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 824A0C98: 7D4BC92E  stwx r10, r11, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32), ctx.r[10].u32) };
	// 824A0C9C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A0CA0: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A0CA4: 4198FF58  blt cr6, 0x824a0bfc
	if ctx.cr[6].lt {
	pc = 0x824A0BFC; continue 'dispatch;
	}
	// 824A0CA8: 48000068  b 0x824a0d10
	pc = 0x824A0D10; continue 'dispatch;
            }
            0x824A0CAC => {
    //   block [0x824A0CAC..0x824A0CBC)
	// 824A0CAC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 824A0CB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A0CB4: 4099005C  ble cr6, 0x824a0d10
	if !ctx.cr[6].gt {
	pc = 0x824A0D10; continue 'dispatch;
	}
	// 824A0CB8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x824A0CBC; continue 'dispatch;
            }
            0x824A0CBC => {
    //   block [0x824A0CBC..0x824A0CF0)
	// 824A0CBC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A0CC0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 824A0CC4: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0CC8: 81010078  lwz r8, 0x78(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 824A0CCC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0CD0: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 824A0CD4: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824A0CD8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824A0CDC: 7CC8512E  stwx r6, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 824A0CE0: A129009C  lhz r9, 0x9c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(156 as u32) ) } as u64;
	// 824A0CE4: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 824A0CE8: 40980008  bge cr6, 0x824a0cf0
	if !ctx.cr[6].lt {
	pc = 0x824A0CF0; continue 'dispatch;
	}
	// 824A0CEC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x824A0CF0; continue 'dispatch;
            }
            0x824A0CF0 => {
    //   block [0x824A0CF0..0x824A0D10)
	// 824A0CF0: 7D19502E  lwzx r8, r25, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824A0CF4: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 824A0CF8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824A0CFC: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 824A0D00: 7D39512E  stwx r9, r25, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[25].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 824A0D04: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A0D08: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824A0D0C: 4198FFB0  blt cr6, 0x824a0cbc
	if ctx.cr[6].lt {
	pc = 0x824A0CBC; continue 'dispatch;
	}
	pc = 0x824A0D10; continue 'dispatch;
            }
            0x824A0D10 => {
    //   block [0x824A0D10..0x824A0D24)
	// 824A0D10: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 824A0D14: 40990034  ble cr6, 0x824a0d48
	if !ctx.cr[6].gt {
	pc = 0x824A0D48; continue 'dispatch;
	}
	// 824A0D18: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 824A0D1C: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 824A0D20: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	pc = 0x824A0D24; continue 'dispatch;
            }
            0x824A0D24 => {
    //   block [0x824A0D24..0x824A0D38)
	// 824A0D24: 81010078  lwz r8, 0x78(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 824A0D28: 7D0B402E  lwzx r8, r11, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 824A0D2C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824A0D30: 409A0008  bne cr6, 0x824a0d38
	if !ctx.cr[6].eq {
	pc = 0x824A0D38; continue 'dispatch;
	}
	// 824A0D34: 7D2BC92E  stwx r9, r11, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32), ctx.r[9].u32) };
	pc = 0x824A0D38; continue 'dispatch;
            }
            0x824A0D38 => {
    //   block [0x824A0D38..0x824A0D48)
	// 824A0D38: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824A0D3C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824A0D40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824A0D44: 409AFFE0  bne cr6, 0x824a0d24
	if !ctx.cr[6].eq {
	pc = 0x824A0D24; continue 'dispatch;
	}
	pc = 0x824A0D48; continue 'dispatch;
            }
            0x824A0D48 => {
    //   block [0x824A0D48..0x824A0D70)
	// 824A0D48: 83C10078  lwz r30, 0x78(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 824A0D4C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 824A0D50: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 824A0D54: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 824A0D58: 409900DC  ble cr6, 0x824a0e34
	if !ctx.cr[6].gt {
	pc = 0x824A0E34; continue 'dispatch;
	}
	// 824A0D5C: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 824A0D60: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 824A0D64: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 824A0D68: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 824A0D6C: 3860FFFE  li r3, -2
	ctx.r[3].s64 = -2;
	pc = 0x824A0D70; continue 'dispatch;
            }
            0x824A0D70 => {
    //   block [0x824A0D70..0x824A0DA8)
	// 824A0D70: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0D74: 2F08FFFE  cmpwi cr6, r8, -2
	ctx.cr[6].compare_i32(ctx.r[8].s32, -2, &mut ctx.xer);
	// 824A0D78: 419A00A0  beq cr6, 0x824a0e18
	if ctx.cr[6].eq {
	pc = 0x824A0E18; continue 'dispatch;
	}
	// 824A0D7C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 824A0D80: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 824A0D84: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824A0D88: 7F6779AE  stbx r27, r7, r15
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[15].u32), ctx.r[27].u8) };
	// 824A0D8C: 90FE0000  stw r7, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 824A0D90: 41980088  blt cr6, 0x824a0e18
	if ctx.cr[6].lt {
	pc = 0x824A0E18; continue 'dispatch;
	}
	// 824A0D94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824A0D98: 7F1DC000  cmpw cr6, r29, r24
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[24].s32, &mut ctx.xer);
	// 824A0D9C: 4098007C  bge cr6, 0x824a0e18
	if !ctx.cr[6].lt {
	pc = 0x824A0E18; continue 'dispatch;
	}
	// 824A0DA0: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 824A0DA4: 7CD9D050  subf r6, r25, r26
	ctx.r[6].s64 = ctx.r[26].s64 - ctx.r[25].s64;
	pc = 0x824A0DA8; continue 'dispatch;
            }
            0x824A0DA8 => {
    //   block [0x824A0DA8..0x824A0DC0)
	// 824A0DA8: 813000A4  lwz r9, 0xa4(r16)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(164 as u32) ) } as u64;
	// 824A0DAC: 3968000A  addi r11, r8, 0xa
	ctx.r[11].s64 = ctx.r[8].s64 + 10;
	// 824A0DB0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A0DB4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 824A0DB8: 41980008  blt cr6, 0x824a0dc0
	if ctx.cr[6].lt {
	pc = 0x824A0DC0; continue 'dispatch;
	}
	// 824A0DBC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x824A0DC0; continue 'dispatch;
            }
            0x824A0DC0 => {
    //   block [0x824A0DC0..0x824A0DEC)
	// 824A0DC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 824A0DC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A0DC8: 419A0050  beq cr6, 0x824a0e18
	if ctx.cr[6].eq {
	pc = 0x824A0E18; continue 'dispatch;
	}
	// 824A0DCC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0DD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A0DD4: 41980034  blt cr6, 0x824a0e08
	if ctx.cr[6].lt {
	pc = 0x824A0E08; continue 'dispatch;
	}
	// 824A0DD8: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824A0DDC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A0DE0: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 824A0DE4: 41980008  blt cr6, 0x824a0dec
	if ctx.cr[6].lt {
	pc = 0x824A0DEC; continue 'dispatch;
	}
	// 824A0DE8: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	pc = 0x824A0DEC; continue 'dispatch;
            }
            0x824A0DEC => {
    //   block [0x824A0DEC..0x824A0E08)
	// 824A0DEC: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 824A0DF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 824A0DF4: 419A0014  beq cr6, 0x824a0e08
	if ctx.cr[6].eq {
	pc = 0x824A0E08; continue 'dispatch;
	}
	// 824A0DF8: 7EE779AE  stbx r23, r7, r15
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[15].u32), ctx.r[23].u8) };
	// 824A0DFC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 824A0E00: 7CE6512E  stwx r7, r6, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 824A0E04: 906A0000  stw r3, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x824A0E08; continue 'dispatch;
            }
            0x824A0E08 => {
    //   block [0x824A0E08..0x824A0E18)
	// 824A0E08: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 824A0E0C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824A0E10: 7F04C000  cmpw cr6, r4, r24
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[24].s32, &mut ctx.xer);
	// 824A0E14: 4198FF94  blt cr6, 0x824a0da8
	if ctx.cr[6].lt {
	pc = 0x824A0DA8; continue 'dispatch;
	}
	pc = 0x824A0E18; continue 'dispatch;
            }
            0x824A0E18 => {
    //   block [0x824A0E18..0x824A0E34)
	// 824A0E18: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 824A0E1C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824A0E20: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 824A0E24: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 824A0E28: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 824A0E2C: 409AFF44  bne cr6, 0x824a0d70
	if !ctx.cr[6].eq {
	pc = 0x824A0D70; continue 'dispatch;
	}
	// 824A0E30: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x824A0E34; continue 'dispatch;
            }
            0x824A0E34 => {
    //   block [0x824A0E34..0x824A0E6C)
	// 824A0E34: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 824A0E38: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 824A0E3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 824A0E40: 4810A4C9  bl 0x825ab308
	ctx.lr = 0x824A0E44;
	sub_825AB308(ctx, base);
	// 824A0E44: 7C6EE02E  lwzx r3, r14, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A0E48: 80810078  lwz r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 824A0E4C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A0E50: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824A0E54: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A0E58: 409A0014  bne cr6, 0x824a0e6c
	if !ctx.cr[6].eq {
	pc = 0x824A0E6C; continue 'dispatch;
	}
	// 824A0E5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0E60: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A0E64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A0E68: 4E800421  bctrl
	ctx.lr = 0x824A0E6C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A0E6C => {
    //   block [0x824A0E6C..0x824A0E98)
	// 824A0E6C: 7C6EE02E  lwzx r3, r14, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A0E70: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A0E74: 93230020  stw r25, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[25].u32 ) };
	// 824A0E78: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A0E7C: 409A002C  bne cr6, 0x824a0ea8
	if !ctx.cr[6].eq {
	pc = 0x824A0EA8; continue 'dispatch;
	}
	// 824A0E80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0E84: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 824A0E88: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A0E8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A0E90: 4E800421  bctrl
	ctx.lr = 0x824A0E94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A0E94: 48000014  b 0x824a0ea8
	pc = 0x824A0EA8; continue 'dispatch;
            }
            0x824A0E98 => {
    //   block [0x824A0E98..0x824A0EA8)
	// 824A0E98: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 824A0E9C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824A0EA0: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 824A0EA4: 4BFC9495  bl 0x8246a338
	ctx.lr = 0x824A0EA8;
	sub_8246A338(ctx, base);
	pc = 0x824A0EA8; continue 'dispatch;
            }
            0x824A0EA8 => {
    //   block [0x824A0EA8..0x824A0F0C)
	// 824A0EA8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 824A0EAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 824A0EB0: 4810A2E1  bl 0x825ab190
	ctx.lr = 0x824A0EB4;
	sub_825AB190(ctx, base);
	// 824A0EB4: 7D4F18AE  lbzx r10, r15, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[15].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 824A0EB8: 896F0000  lbz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0EBC: 994F0000  stb r10, 0(r15)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[15].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 824A0EC0: 7D6F19AE  stbx r11, r15, r3
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[15].u32.wrapping_add(ctx.r[3].u32), ctx.r[11].u8) };
	// 824A0EC4: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 824A0EC8: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 824A0ECC: 82F2004C  lwz r23, 0x4c(r18)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A0ED0: 7C6EE02E  lwzx r3, r14, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A0ED4: 7D735B78  mr r19, r11
	ctx.r[19].u64 = ctx.r[11].u64;
	// 824A0ED8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 824A0EDC: 82CA0000  lwz r22, 0(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0EE0: 419A075C  beq cr6, 0x824a163c
	if ctx.cr[6].eq {
	pc = 0x824A163C; continue 'dispatch;
	}
	// 824A0EE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824A0EE8: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A0EEC: 55641036  rlwinm r4, r11, 2, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824A0EF0: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A0EF4: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 824A0EF8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A0EFC: 41990010  bgt cr6, 0x824a0f0c
	if ctx.cr[6].gt {
	pc = 0x824A0F0C; continue 'dispatch;
	}
	// 824A0F00: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 824A0F04: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 824A0F08: 48000018  b 0x824a0f20
	pc = 0x824A0F20; continue 'dispatch;
            }
            0x824A0F0C => {
    //   block [0x824A0F0C..0x824A0F20)
	// 824A0F0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0F10: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A0F14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A0F18: 4E800421  bctrl
	ctx.lr = 0x824A0F1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A0F1C: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
            }
            0x824A0F20 => {
    //   block [0x824A0F20..0x824A0F5C)
	// 824A0F20: 896F0000  lbz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0F24: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 824A0F28: 89520025  lbz r10, 0x25(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[18].u32.wrapping_add(37 as u32) ) } as u64;
	// 824A0F2C: 2F130001  cmpwi cr6, r19, 1
	ctx.cr[6].compare_i32(ctx.r[19].s32, 1, &mut ctx.xer);
	// 824A0F30: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824A0F34: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 824A0F38: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 824A0F3C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 824A0F40: 516A26B6  rlwimi r10, r11, 4, 0x1a, 0x1b
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(4) as u64) & 0x0000000000000030) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFCF);
	// 824A0F44: 99520025  stb r10, 0x25(r18)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[18].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 824A0F48: 92550000  stw r18, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[18].u32 ) };
	// 824A0F4C: 409900E0  ble cr6, 0x824a102c
	if !ctx.cr[6].gt {
	pc = 0x824A102C; continue 'dispatch;
	}
	// 824A0F50: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 824A0F54: 3B40006C  li r26, 0x6c
	ctx.r[26].s64 = 108;
	// 824A0F58: 3B800005  li r28, 5
	ctx.r[28].s64 = 5;
	pc = 0x824A0F5C; continue 'dispatch;
            }
            0x824A0F5C => {
    //   block [0x824A0F5C..0x824A0FD4)
	// 824A0F5C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824A0F60: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	// 824A0F64: 3880006C  li r4, 0x6c
	ctx.r[4].s64 = 108;
	// 824A0F68: 7C6E582E  lwzx r3, r14, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A0F6C: 4BFC30CD  bl 0x82464038
	ctx.lr = 0x824A0F70;
	sub_82464038(ctx, base);
	// 824A0F70: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 824A0F74: B3430004  sth r26, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[26].u16 ) };
	// 824A0F78: 48016031  bl 0x824b6fa8
	ctx.lr = 0x824A0F7C;
	sub_824B6FA8(ctx, base);
	// 824A0F7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A0F80: 897F0026  lbz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 824A0F84: 895F0025  lbz r10, 0x25(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 824A0F88: 538B2036  rlwimi r11, r28, 4, 0, 0x1b
	ctx.r[11].u64 = (((ctx.r[28].u32).rotate_left(4) as u64) & 0x00000000FFFFFFF0) | (ctx.r[11].u64 & 0xFFFFFFFF0000000F);
	// 824A0F8C: 997F0026  stb r11, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[11].u8 ) };
	// 824A0F90: 7D6FF0AE  lbzx r11, r15, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[15].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A0F94: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824A0F98: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 824A0F9C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 824A0FA0: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 824A0FA4: 516A26B6  rlwimi r10, r11, 4, 0x1a, 0x1b
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(4) as u64) & 0x0000000000000030) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFCF);
	// 824A0FA8: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 824A0FAC: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A0FB0: B17F0020  sth r11, 0x20(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u16 ) };
	// 824A0FB4: 81740008  lwz r11, 8(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A0FB8: 81540004  lwz r10, 4(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A0FBC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824A0FC0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A0FC4: 409A0010  bne cr6, 0x824a0fd4
	if !ctx.cr[6].eq {
	pc = 0x824A0FD4; continue 'dispatch;
	}
	// 824A0FC8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824A0FCC: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 824A0FD0: 4BFCD381  bl 0x8246e350
	ctx.lr = 0x824A0FD4;
	sub_8246E350(ctx, base);
	pc = 0x824A0FD4; continue 'dispatch;
            }
            0x824A0FD4 => {
    //   block [0x824A0FD4..0x824A1018)
	// 824A0FD4: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A0FD8: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 824A0FDC: 81540000  lwz r10, 0(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A0FE0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A0FE4: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 824A0FE8: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A0FEC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A0FF0: 91740004  stw r11, 4(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A0FF4: 7FFDA92E  stwx r31, r29, r21
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[21].u32), ctx.r[31].u32) };
	// 824A0FF8: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 824A0FFC: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A1000: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1004: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824A1008: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 824A100C: 4098000C  bge cr6, 0x824a1018
	if !ctx.cr[6].lt {
	pc = 0x824A1018; continue 'dispatch;
	}
	// 824A1010: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824A1014: 4BFCD2B5  bl 0x8246e2c8
	ctx.lr = 0x824A1018;
	sub_8246E2C8(ctx, base);
	pc = 0x824A1018; continue 'dispatch;
            }
            0x824A1018 => {
    //   block [0x824A1018..0x824A102C)
	// 824A1018: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824A101C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 824A1020: 7F1E9800  cmpw cr6, r30, r19
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[19].s32, &mut ctx.xer);
	// 824A1024: 4198FF38  blt cr6, 0x824a0f5c
	if ctx.cr[6].lt {
	pc = 0x824A0F5C; continue 'dispatch;
	}
	// 824A1028: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x824A102C; continue 'dispatch;
            }
            0x824A102C => {
    //   block [0x824A102C..0x824A1098)
	// 824A102C: 83120048  lwz r24, 0x48(r18)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(72 as u32) ) } as u64;
	// 824A1030: 38720048  addi r3, r18, 0x48
	ctx.r[3].s64 = ctx.r[18].s64 + 72;
	// 824A1034: 83F2004C  lwz r31, 0x4c(r18)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A1038: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 824A103C: 419A005C  beq cr6, 0x824a1098
	if ctx.cr[6].eq {
	pc = 0x824A1098; continue 'dispatch;
	}
	// 824A1040: 81510000  lwz r10, 0(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1044: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1048: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824A104C: 81510004  lwz r10, 4(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1050: 91710000  stw r11, 0(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A1054: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1058: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824A105C: 81510008  lwz r10, 8(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1060: 91710004  stw r11, 4(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A1064: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1068: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 824A106C: 91710008  stw r11, 8(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824A1070: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 824A1074: 9372004C  stw r27, 0x4c(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(76 as u32), ctx.r[27].u32 ) };
	// 824A1078: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A107C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1080: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824A1084: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 824A1088: 40980014  bge cr6, 0x824a109c
	if !ctx.cr[6].lt {
	pc = 0x824A109C; continue 'dispatch;
	}
	// 824A108C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824A1090: 4BFCD239  bl 0x8246e2c8
	ctx.lr = 0x824A1094;
	sub_8246E2C8(ctx, base);
	// 824A1094: 48000008  b 0x824a109c
	pc = 0x824A109C; continue 'dispatch;
            }
            0x824A1098 => {
    //   block [0x824A1098..0x824A109C)
	// 824A1098: 9372004C  stw r27, 0x4c(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(76 as u32), ctx.r[27].u32 ) };
	pc = 0x824A109C; continue 'dispatch;
            }
            0x824A109C => {
    //   block [0x824A109C..0x824A10AC)
	// 824A109C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824A10A0: 40990138  ble cr6, 0x824a11d8
	if !ctx.cr[6].gt {
	pc = 0x824A11D8; continue 'dispatch;
	}
	// 824A10A4: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 824A10A8: 7FF9FB78  mr r25, r31
	ctx.r[25].u64 = ctx.r[31].u64;
	pc = 0x824A10AC; continue 'dispatch;
            }
            0x824A10AC => {
    //   block [0x824A10AC..0x824A1104)
	// 824A10AC: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 824A10B0: 7FBAC02E  lwzx r29, r26, r24
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 824A10B4: 7D7A582E  lwzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A10B8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A10BC: 7FCBA82E  lwzx r30, r11, r21
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 824A10C0: 7F12F040  cmplw cr6, r18, r30
	ctx.cr[6].compare_u32(ctx.r[18].u32, ctx.r[30].u32, &mut ctx.xer);
	// 824A10C4: 93DD00B8  stw r30, 0xb8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(184 as u32), ctx.r[30].u32 ) };
	// 824A10C8: 817E004C  lwz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A10CC: B17D0094  sth r11, 0x94(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(148 as u32), ctx.r[11].u16 ) };
	// 824A10D0: 817E004C  lwz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A10D4: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 824A10D8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A10DC: 7FAB512E  stwx r29, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 824A10E0: 817E004C  lwz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A10E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A10E8: 917E004C  stw r11, 0x4c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 824A10EC: 419A00DC  beq cr6, 0x824a11c8
	if ctx.cr[6].eq {
	pc = 0x824A11C8; continue 'dispatch;
	}
	// 824A10F0: A17D009C  lhz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 824A10F4: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 824A10F8: 83FD0098  lwz r31, 0x98(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(152 as u32) ) } as u64;
	// 824A10FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A1100: 419A00C4  beq cr6, 0x824a11c4
	if ctx.cr[6].eq {
	pc = 0x824A11C4; continue 'dispatch;
	}
	pc = 0x824A1104; continue 'dispatch;
            }
            0x824A1104 => {
    //   block [0x824A1104..0x824A118C)
	// 824A1104: 8172001C  lwz r11, 0x1c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28 as u32) ) } as u64;
	// 824A1108: A15F0014  lhz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A110C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824A1110: A13F0016  lhz r9, 0x16(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 824A1114: A11F0018  lhz r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A1118: 80F20008  lwz r7, 8(r18)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A111C: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 824A1120: 9172001C  stw r11, 0x1c(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 824A1124: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1128: 90E10090  stw r7, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u32 ) };
	// 824A112C: 91210098  stw r9, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[9].u32 ) };
	// 824A1130: 9101009C  stw r8, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[8].u32 ) };
	// 824A1134: 80EB0028  lwz r7, 0x28(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A1138: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 824A113C: 419A0050  beq cr6, 0x824a118c
	if ctx.cr[6].eq {
	pc = 0x824A118C; continue 'dispatch;
	}
	// 824A1140: 80F2000C  lwz r7, 0xc(r18)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A1144: 80D20010  lwz r6, 0x10(r18)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A1148: 80B20014  lwz r5, 0x14(r18)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A114C: 7CEA3850  subf r7, r10, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 824A1150: 7CC93050  subf r6, r9, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 824A1154: 7CA82850  subf r5, r8, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	// 824A1158: 90F2000C  stw r7, 0xc(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 824A115C: 90D20010  stw r6, 0x10(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 824A1160: 90B20014  stw r5, 0x14(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 824A1164: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A1168: A0EB0016  lhz r7, 0x16(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 824A116C: A0CB0018  lhz r6, 0x18(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A1170: A0AB0014  lhz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A1174: 7D293850  subf r9, r9, r7
	ctx.r[9].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 824A1178: 7D083050  subf r8, r8, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[8].s64;
	// 824A117C: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 824A1180: B12B0016  sth r9, 0x16(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(22 as u32), ctx.r[9].u16 ) };
	// 824A1184: B10B0018  sth r8, 0x18(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u16 ) };
	// 824A1188: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x824A118C; continue 'dispatch;
            }
            0x824A118C => {
    //   block [0x824A118C..0x824A11C4)
	// 824A118C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 824A1190: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 824A1194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824A1198: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A119C: 917E001C  stw r11, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 824A11A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A11A4: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 824A11A8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A11AC: 48000DE5  bl 0x824a1f90
	ctx.lr = 0x824A11B0;
	sub_824A1F90(ctx, base);
	// 824A11B0: A17D009C  lhz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 824A11B4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 824A11B8: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 824A11BC: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A11C0: 4198FF44  blt cr6, 0x824a1104
	if ctx.cr[6].lt {
	pc = 0x824A1104; continue 'dispatch;
	}
	pc = 0x824A11C4; continue 'dispatch;
            }
            0x824A11C4 => {
    //   block [0x824A11C4..0x824A11C8)
	// 824A11C4: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x824A11C8; continue 'dispatch;
            }
            0x824A11C8 => {
    //   block [0x824A11C8..0x824A11D8)
	// 824A11C8: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 824A11CC: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 824A11D0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 824A11D4: 409AFED8  bne cr6, 0x824a10ac
	if !ctx.cr[6].eq {
	pc = 0x824A10AC; continue 'dispatch;
	}
	pc = 0x824A11D8; continue 'dispatch;
            }
            0x824A11D8 => {
    //   block [0x824A11D8..0x824A1200)
	// 824A11D8: 8172003C  lwz r11, 0x3c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(60 as u32) ) } as u64;
	// 824A11DC: 83500020  lwz r26, 0x20(r16)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A11E0: 81520038  lwz r10, 0x38(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(56 as u32) ) } as u64;
	// 824A11E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A11E8: 9372003C  stw r27, 0x3c(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(60 as u32), ctx.r[27].u32 ) };
	// 824A11EC: 40990100  ble cr6, 0x824a12ec
	if !ctx.cr[6].gt {
	pc = 0x824A12EC; continue 'dispatch;
	}
	// 824A11F0: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 824A11F4: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 824A11F8: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 824A11FC: 617C0010  ori r28, r11, 0x10
	ctx.r[28].u64 = ctx.r[11].u64 | 16;
	pc = 0x824A1200; continue 'dispatch;
            }
            0x824A1200 => {
    //   block [0x824A1200..0x824A1250)
	// 824A1200: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1204: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 824A1208: 419A00D0  beq cr6, 0x824a12d8
	if ctx.cr[6].eq {
	pc = 0x824A12D8; continue 'dispatch;
	}
	// 824A120C: 3961013C  addi r11, r1, 0x13c
	ctx.r[11].s64 = ctx.r[1].s64 + 316;
	// 824A1210: 93610134  stw r27, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[27].u32 ) };
	// 824A1214: 93810138  stw r28, 0x138(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[28].u32 ) };
	// 824A1218: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 824A121C: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 824A1220: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824A1224: 91610130  stw r11, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 824A1228: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A122C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A1230: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A1234: 4E800421  bctrl
	ctx.lr = 0x824A1238;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A1238: 81210134  lwz r9, 0x134(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 824A123C: 80810130  lwz r4, 0x130(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(304 as u32) ) } as u64;
	// 824A1240: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 824A1244: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824A1248: 40990028  ble cr6, 0x824a1270
	if !ctx.cr[6].gt {
	pc = 0x824A1270; continue 'dispatch;
	}
	// 824A124C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
            }
            0x824A1250 => {
    //   block [0x824A1250..0x824A1270)
	// 824A1250: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1254: 83C800B8  lwz r30, 0xb8(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A1258: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 824A125C: 409A0014  bne cr6, 0x824a1270
	if !ctx.cr[6].eq {
	pc = 0x824A1270; continue 'dispatch;
	}
	// 824A1260: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824A1264: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824A1268: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A126C: 4198FFE4  blt cr6, 0x824a1250
	if ctx.cr[6].lt {
	pc = 0x824A1250; continue 'dispatch;
	}
	pc = 0x824A1270; continue 'dispatch;
            }
            0x824A1270 => {
    //   block [0x824A1270..0x824A1294)
	// 824A1270: 81610138  lwz r11, 0x138(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(312 as u32) ) } as u64;
	// 824A1274: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A1278: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A127C: 409A0018  bne cr6, 0x824a1294
	if !ctx.cr[6].eq {
	pc = 0x824A1294; continue 'dispatch;
	}
	// 824A1280: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A1284: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824A1288: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A128C: 7C6E582E  lwzx r3, r14, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A1290: 4BFC2E29  bl 0x824640b8
	ctx.lr = 0x824A1294;
	sub_824640B8(ctx, base);
	pc = 0x824A1294; continue 'dispatch;
            }
            0x824A1294 => {
    //   block [0x824A1294..0x824A12BC)
	// 824A1294: 3BFE0038  addi r31, r30, 0x38
	ctx.r[31].s64 = ctx.r[30].s64 + 56;
	// 824A1298: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 824A129C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A12A0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A12A4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824A12A8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A12AC: 409A0010  bne cr6, 0x824a12bc
	if !ctx.cr[6].eq {
	pc = 0x824A12BC; continue 'dispatch;
	}
	// 824A12B0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824A12B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A12B8: 4BFCD099  bl 0x8246e350
	ctx.lr = 0x824A12BC;
	sub_8246E350(ctx, base);
	pc = 0x824A12BC; continue 'dispatch;
            }
            0x824A12BC => {
    //   block [0x824A12BC..0x824A12D8)
	// 824A12BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A12C0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A12C4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A12C8: 7FAB512E  stwx r29, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 824A12CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A12D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A12D4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x824A12D8; continue 'dispatch;
            }
            0x824A12D8 => {
    //   block [0x824A12D8..0x824A12EC)
	// 824A12D8: 3B18FFFF  addi r24, r24, -1
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	// 824A12DC: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 824A12E0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 824A12E4: 409AFF1C  bne cr6, 0x824a1200
	if !ctx.cr[6].eq {
	pc = 0x824A1200; continue 'dispatch;
	}
	// 824A12E8: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x824A12EC; continue 'dispatch;
            }
            0x824A12EC => {
    //   block [0x824A12EC..0x824A1310)
	// 824A12EC: 7D76B850  subf r11, r22, r23
	ctx.r[11].s64 = ctx.r[23].s64 - ctx.r[22].s64;
	// 824A12F0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A12F4: 7F0BB800  cmpw cr6, r11, r23
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[23].s32, &mut ctx.xer);
	// 824A12F8: 409800F4  bge cr6, 0x824a13ec
	if !ctx.cr[6].lt {
	pc = 0x824A13EC; continue 'dispatch;
	}
	// 824A12FC: 3BB20058  addi r29, r18, 0x58
	ctx.r[29].s64 = ctx.r[18].s64 + 88;
	// 824A1300: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1304: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A1308: 40990264  ble cr6, 0x824a156c
	if !ctx.cr[6].gt {
	pc = 0x824A156C; continue 'dispatch;
	}
	// 824A130C: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	pc = 0x824A1310; continue 'dispatch;
            }
            0x824A1310 => {
    //   block [0x824A1310..0x824A1334)
	// 824A1310: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1314: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A1318: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824A131C: 7FDA582E  lwzx r30, r26, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A1320: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 824A1324: 48000BD5  bl 0x824a1ef8
	ctx.lr = 0x824A1328;
	sub_824A1EF8(ctx, base);
	// 824A1328: 7D63F214  add r11, r3, r30
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 824A132C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A1330: 409800A4  bge cr6, 0x824a13d4
	if !ctx.cr[6].lt {
	pc = 0x824A13D4; continue 'dispatch;
	}
	pc = 0x824A1334; continue 'dispatch;
            }
            0x824A1334 => {
    //   block [0x824A1334..0x824A1368)
	// 824A1334: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A1338: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A133C: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 824A1340: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824A1344: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A1348: A14B0020  lhz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A134C: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 824A1350: 409A0018  bne cr6, 0x824a1368
	if !ctx.cr[6].eq {
	pc = 0x824A1368; continue 'dispatch;
	}
	// 824A1354: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A1358: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A135C: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 824A1360: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824A1364: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	pc = 0x824A1368; continue 'dispatch;
            }
            0x824A1368 => {
    //   block [0x824A1368..0x824A137C)
	// 824A1368: 7F0B9040  cmplw cr6, r11, r18
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[18].u32, &mut ctx.xer);
	// 824A136C: 409A0010  bne cr6, 0x824a137c
	if !ctx.cr[6].eq {
	pc = 0x824A137C; continue 'dispatch;
	}
	// 824A1370: 897F0003  lbz r11, 3(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 824A1374: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 824A1378: 4800003C  b 0x824a13b4
	pc = 0x824A13B4; continue 'dispatch;
            }
            0x824A137C => {
    //   block [0x824A137C..0x824A13B4)
	// 824A137C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824A1380: 386B0058  addi r3, r11, 0x58
	ctx.r[3].s64 = ctx.r[11].s64 + 88;
	// 824A1384: 7F9EF850  subf r28, r30, r31
	ctx.r[28].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 824A1388: 48033CF1  bl 0x824d5078
	ctx.lr = 0x824A138C;
	sub_824D5078(ctx, base);
	// 824A138C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824A1390: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824A1394: 48033A9D  bl 0x824d4e30
	ctx.lr = 0x824A1398;
	sub_824D4E30(ctx, base);
	// 824A1398: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A139C: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A13A0: 40980030  bge cr6, 0x824a13d0
	if !ctx.cr[6].lt {
	pc = 0x824A13D0; continue 'dispatch;
	}
	// 824A13A4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A13A8: 7FDA582E  lwzx r30, r26, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A13AC: 7FFCF214  add r31, r28, r30
	ctx.r[31].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 824A13B0: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x824A13B4; continue 'dispatch;
            }
            0x824A13B4 => {
    //   block [0x824A13B4..0x824A13D0)
	// 824A13B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A13B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824A13BC: 48000B3D  bl 0x824a1ef8
	ctx.lr = 0x824A13C0;
	sub_824A1EF8(ctx, base);
	// 824A13C0: 7D63F214  add r11, r3, r30
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 824A13C4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A13C8: 4198FF6C  blt cr6, 0x824a1334
	if ctx.cr[6].lt {
	pc = 0x824A1334; continue 'dispatch;
	}
	// 824A13CC: 48000008  b 0x824a13d4
	pc = 0x824A13D4; continue 'dispatch;
            }
            0x824A13D0 => {
    //   block [0x824A13D0..0x824A13D4)
	// 824A13D0: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x824A13D4; continue 'dispatch;
            }
            0x824A13D4 => {
    //   block [0x824A13D4..0x824A13EC)
	// 824A13D4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A13D8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 824A13DC: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 824A13E0: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A13E4: 4198FF2C  blt cr6, 0x824a1310
	if ctx.cr[6].lt {
	pc = 0x824A1310; continue 'dispatch;
	}
	// 824A13E8: 48000184  b 0x824a156c
	pc = 0x824A156C; continue 'dispatch;
            }
            0x824A13EC => {
    //   block [0x824A13EC..0x824A1434)
	// 824A13EC: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 824A13F0: 81520060  lwz r10, 0x60(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(96 as u32) ) } as u64;
	// 824A13F4: 3CE08000  lis r7, -0x8000
	ctx.r[7].s64 = -2147483648;
	// 824A13F8: 39200200  li r9, 0x200
	ctx.r[9].s64 = 512;
	// 824A13FC: 60E70001  ori r7, r7, 1
	ctx.r[7].u64 = ctx.r[7].u64 | 1;
	// 824A1400: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 824A1404: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 824A1408: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 824A140C: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 824A1410: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 824A1414: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 824A1418: 409A001C  bne cr6, 0x824a1434
	if !ctx.cr[6].eq {
	pc = 0x824A1434; continue 'dispatch;
	}
	// 824A141C: 8172005C  lwz r11, 0x5c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(92 as u32) ) } as u64;
	// 824A1420: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1424: 93720060  stw r27, 0x60(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 824A1428: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 824A142C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A1430: 48000044  b 0x824a1474
	pc = 0x824A1474; continue 'dispatch;
            }
            0x824A1434 => {
    //   block [0x824A1434..0x824A1474)
	// 824A1434: 40990044  ble cr6, 0x824a1478
	if !ctx.cr[6].gt {
	pc = 0x824A1478; continue 'dispatch;
	}
	// 824A1438: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824A143C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 824A1440: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 824A1444: 4BFCCE85  bl 0x8246e2c8
	ctx.lr = 0x824A1448;
	sub_8246E2C8(ctx, base);
	// 824A1448: 8172005C  lwz r11, 0x5c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(92 as u32) ) } as u64;
	// 824A144C: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824A1450: 8101006C  lwz r8, 0x6c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A1454: 80F20064  lwz r7, 0x64(r18)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(100 as u32) ) } as u64;
	// 824A1458: 81210068  lwz r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 824A145C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 824A1460: 81720060  lwz r11, 0x60(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(96 as u32) ) } as u64;
	// 824A1464: 9152005C  stw r10, 0x5c(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 824A1468: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 824A146C: 91320060  stw r9, 0x60(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 824A1470: 91120064  stw r8, 0x64(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	pc = 0x824A1474; continue 'dispatch;
            }
            0x824A1474 => {
    //   block [0x824A1474..0x824A1478)
	// 824A1474: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	pc = 0x824A1478; continue 'dispatch;
            }
            0x824A1478 => {
    //   block [0x824A1478..0x824A1498)
	// 824A1478: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824A147C: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 824A1480: 81120058  lwz r8, 0x58(r18)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A1484: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A1488: 91320058  stw r9, 0x58(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 824A148C: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 824A1490: 409900B8  ble cr6, 0x824a1548
	if !ctx.cr[6].gt {
	pc = 0x824A1548; continue 'dispatch;
	}
	// 824A1494: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	pc = 0x824A1498; continue 'dispatch;
            }
            0x824A1498 => {
    //   block [0x824A1498..0x824A14B8)
	// 824A1498: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824A149C: 3B8A0001  addi r28, r10, 1
	ctx.r[28].s64 = ctx.r[10].s64 + 1;
	// 824A14A0: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A14A4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824A14A8: 7FC9D02E  lwzx r30, r9, r26
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 824A14AC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 824A14B0: 419A0008  beq cr6, 0x824a14b8
	if ctx.cr[6].eq {
	pc = 0x824A14B8; continue 'dispatch;
	}
	// 824A14B4: 39600200  li r11, 0x200
	ctx.r[11].s64 = 512;
	pc = 0x824A14B8; continue 'dispatch;
            }
            0x824A14B8 => {
    //   block [0x824A14B8..0x824A14C4)
	// 824A14B8: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 824A14BC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 824A14C0: 40980054  bge cr6, 0x824a1514
	if !ctx.cr[6].lt {
	pc = 0x824A1514; continue 'dispatch;
	}
	pc = 0x824A14C4; continue 'dispatch;
            }
            0x824A14C4 => {
    //   block [0x824A14C4..0x824A14F8)
	// 824A14C4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A14C8: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A14CC: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 824A14D0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824A14D4: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A14D8: A14B0020  lhz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A14DC: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 824A14E0: 409A0018  bne cr6, 0x824a14f8
	if !ctx.cr[6].eq {
	pc = 0x824A14F8; continue 'dispatch;
	}
	// 824A14E4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A14E8: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A14EC: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 824A14F0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824A14F4: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	pc = 0x824A14F8; continue 'dispatch;
            }
            0x824A14F8 => {
    //   block [0x824A14F8..0x824A1514)
	// 824A14F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824A14FC: 386B0058  addi r3, r11, 0x58
	ctx.r[3].s64 = ctx.r[11].s64 + 88;
	// 824A1500: 48033B79  bl 0x824d5078
	ctx.lr = 0x824A1504;
	sub_824D5078(ctx, base);
	// 824A1504: 897F0003  lbz r11, 3(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 824A1508: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 824A150C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 824A1510: 4198FFB4  blt cr6, 0x824a14c4
	if ctx.cr[6].lt {
	pc = 0x824A14C4; continue 'dispatch;
	}
	pc = 0x824A1514; continue 'dispatch;
            }
            0x824A1514 => {
    //   block [0x824A1514..0x824A1548)
	// 824A1514: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824A1518: 38C00027  li r6, 0x27
	ctx.r[6].s64 = 39;
	// 824A151C: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 824A1520: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824A1524: 7C6E582E  lwzx r3, r14, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A1528: 4BFC2B91  bl 0x824640b8
	ctx.lr = 0x824A152C;
	sub_824640B8(ctx, base);
	// 824A152C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 824A1530: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 824A1534: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 824A1538: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A153C: 4198FF5C  blt cr6, 0x824a1498
	if ctx.cr[6].lt {
	pc = 0x824A1498; continue 'dispatch;
	}
	// 824A1540: 80E1006C  lwz r7, 0x6c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A1544: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x824A1548; continue 'dispatch;
            }
            0x824A1548 => {
    //   block [0x824A1548..0x824A156C)
	// 824A1548: 54EB0000  rlwinm r11, r7, 0, 0, 0
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 824A154C: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 824A1550: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A1554: 409A0018  bne cr6, 0x824a156c
	if !ctx.cr[6].eq {
	pc = 0x824A156C; continue 'dispatch;
	}
	// 824A1558: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A155C: 7C6EE02E  lwzx r3, r14, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A1560: 54E5103A  slwi r5, r7, 2
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A1564: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824A1568: 4BFC2B51  bl 0x824640b8
	ctx.lr = 0x824A156C;
	sub_824640B8(ctx, base);
	pc = 0x824A156C; continue 'dispatch;
            }
            0x824A156C => {
    //   block [0x824A156C..0x824A15C8)
	// 824A156C: 3872005C  addi r3, r18, 0x5c
	ctx.r[3].s64 = ctx.r[18].s64 + 92;
	// 824A1570: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1574: 554B0000  rlwinm r11, r10, 0, 0, 0
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 824A1578: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A157C: 409A0064  bne cr6, 0x824a15e0
	if !ctx.cr[6].eq {
	pc = 0x824A15E0; continue 'dispatch;
	}
	// 824A1580: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1584: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 824A1588: 5569843E  srwi r9, r11, 0x10
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(16);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824A158C: 7D2B5B78  or r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 824A1590: 5569C23E  srwi r9, r11, 8
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824A1594: 7D2B5B78  or r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 824A1598: 5569E13E  srwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824A159C: 7D2B5B78  or r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 824A15A0: 5569F0BE  srwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824A15A4: 7D2B5B78  or r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 824A15A8: 5569F87E  srwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824A15AC: 7D2B5B78  or r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 824A15B0: 38CB0001  addi r6, r11, 1
	ctx.r[6].s64 = ctx.r[11].s64 + 1;
	// 824A15B4: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 824A15B8: 40980010  bge cr6, 0x824a15c8
	if !ctx.cr[6].lt {
	pc = 0x824A15C8; continue 'dispatch;
	}
	// 824A15BC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 824A15C0: 38A3000C  addi r5, r3, 0xc
	ctx.r[5].s64 = ctx.r[3].s64 + 12;
	// 824A15C4: 48000014  b 0x824a15d8
	pc = 0x824A15D8; continue 'dispatch;
            }
            0x824A15C8 => {
    //   block [0x824A15C8..0x824A15D8)
	// 824A15C8: 554B00BE  clrlwi r11, r10, 2
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 824A15CC: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A15D0: 40980010  bge cr6, 0x824a15e0
	if !ctx.cr[6].lt {
	pc = 0x824A15E0; continue 'dispatch;
	}
	// 824A15D4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	pc = 0x824A15D8; continue 'dispatch;
            }
            0x824A15D8 => {
    //   block [0x824A15D8..0x824A15E0)
	// 824A15D8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824A15DC: 4BFCCE0D  bl 0x8246e3e8
	ctx.lr = 0x824A15E0;
	sub_8246E3E8(ctx, base);
	pc = 0x824A15E0; continue 'dispatch;
            }
            0x824A15E0 => {
    //   block [0x824A15E0..0x824A15F0)
	// 824A15E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A15E4: 2F130001  cmpwi cr6, r19, 1
	ctx.cr[6].compare_i32(ctx.r[19].s32, 1, &mut ctx.xer);
	// 824A15E8: 40990028  ble cr6, 0x824a1610
	if !ctx.cr[6].gt {
	pc = 0x824A1610; continue 'dispatch;
	}
	// 824A15EC: 39550004  addi r10, r21, 4
	ctx.r[10].s64 = ctx.r[21].s64 + 4;
	pc = 0x824A15F0; continue 'dispatch;
            }
            0x824A15F0 => {
    //   block [0x824A15F0..0x824A1610)
	// 824A15F0: 89320024  lbz r9, 0x24(r18)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[18].u32.wrapping_add(36 as u32) ) } as u64;
	// 824A15F4: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A15F8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824A15FC: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824A1600: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A1604: 7F0B9800  cmpw cr6, r11, r19
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[19].s32, &mut ctx.xer);
	// 824A1608: 99280024  stb r9, 0x24(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(36 as u32), ctx.r[9].u8 ) };
	// 824A160C: 4198FFE4  blt cr6, 0x824a15f0
	if ctx.cr[6].lt {
	pc = 0x824A15F0; continue 'dispatch;
	}
	pc = 0x824A1610; continue 'dispatch;
            }
            0x824A1610 => {
    //   block [0x824A1610..0x824A1638)
	// 824A1610: 7C6EE02E  lwzx r3, r14, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A1614: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A1618: 92A30020  stw r21, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[21].u32 ) };
	// 824A161C: 7F155840  cmplw cr6, r21, r11
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A1620: 409A0018  bne cr6, 0x824a1638
	if !ctx.cr[6].eq {
	pc = 0x824A1638; continue 'dispatch;
	}
	// 824A1624: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1628: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 824A162C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A1630: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A1634: 4E800421  bctrl
	ctx.lr = 0x824A1638;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A1638 => {
    //   block [0x824A1638..0x824A163C)
	// 824A1638: 7C6EE02E  lwzx r3, r14, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	pc = 0x824A163C; continue 'dispatch;
            }
            0x824A163C => {
    //   block [0x824A163C..0x824A1660)
	// 824A163C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A1640: 91E30020  stw r15, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[15].u32 ) };
	// 824A1644: 7F0F5840  cmplw cr6, r15, r11
	ctx.cr[6].compare_u32(ctx.r[15].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A1648: 409A0018  bne cr6, 0x824a1660
	if !ctx.cr[6].eq {
	pc = 0x824A1660; continue 'dispatch;
	}
	// 824A164C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1650: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 824A1654: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A1658: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A165C: 4E800421  bctrl
	ctx.lr = 0x824A1660;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A1660 => {
    //   block [0x824A1660..0x824A1684)
	// 824A1660: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 824A1664: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A1668: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A166C: 409A0018  bne cr6, 0x824a1684
	if !ctx.cr[6].eq {
	pc = 0x824A1684; continue 'dispatch;
	}
	// 824A1670: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A1674: 808100A0  lwz r4, 0xa0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 824A1678: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A167C: 7C6EE02E  lwzx r3, r14, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A1680: 4BFC2A39  bl 0x824640b8
	ctx.lr = 0x824A1684;
	sub_824640B8(ctx, base);
	pc = 0x824A1684; continue 'dispatch;
            }
            0x824A1684 => {
    //   block [0x824A1684..0x824A16AC)
	// 824A1684: 7C6EE02E  lwzx r3, r14, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A1688: 80810088  lwz r4, 0x88(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 824A168C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A1690: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824A1694: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A1698: 409A0014  bne cr6, 0x824a16ac
	if !ctx.cr[6].eq {
	pc = 0x824A16AC; continue 'dispatch;
	}
	// 824A169C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A16A0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A16A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A16A8: 4E800421  bctrl
	ctx.lr = 0x824A16AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A16AC => {
    //   block [0x824A16AC..0x824A16B4)
	// 824A16AC: 38210220  addi r1, r1, 0x220
	ctx.r[1].s64 = ctx.r[1].s64 + 544;
	// 824A16B0: 48093A20  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A16B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A16B8 size=228
    let mut pc: u32 = 0x824A16B8;
    'dispatch: loop {
        match pc {
            0x824A16B8 => {
    //   block [0x824A16B8..0x824A16E8)
	// 824A16B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A16BC: 480939E1  bl 0x8253509c
	ctx.lr = 0x824A16C0;
	sub_82535080(ctx, base);
	// 824A16C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A16C4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 824A16C8: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 824A16CC: 3B960028  addi r28, r22, 0x28
	ctx.r[28].s64 = ctx.r[22].s64 + 40;
	// 824A16D0: 897A0026  lbz r11, 0x26(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(38 as u32) ) } as u64;
	// 824A16D4: 556BD1BE  srwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A16D8: 5579063E  clrlwi r25, r11, 0x18
	ctx.r[25].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 824A16DC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 824A16E0: 409A0008  bne cr6, 0x824a16e8
	if !ctx.cr[6].eq {
	pc = 0x824A16E8; continue 'dispatch;
	}
	// 824A16E4: 3B960034  addi r28, r22, 0x34
	ctx.r[28].s64 = ctx.r[22].s64 + 52;
	pc = 0x824A16E8; continue 'dispatch;
            }
            0x824A16E8 => {
    //   block [0x824A16E8..0x824A1730)
	// 824A16E8: 897A0025  lbz r11, 0x25(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(37 as u32) ) } as u64;
	// 824A16EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824A16F0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 824A16F4: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 824A16F8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 824A16FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 824A1700: 997A0025  stb r11, 0x25(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 824A1704: 837C0004  lwz r27, 4(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1708: 4BFFF119  bl 0x824a0820
	ctx.lr = 0x824A170C;
	sub_824A0820(ctx, base);
	// 824A170C: 897A0026  lbz r11, 0x26(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(38 as u32) ) } as u64;
	// 824A1710: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 824A1714: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1718: 5575E7BE  rlwinm r21, r11, 0x1c, 0x1e, 0x1f
	ctx.r[21].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 824A171C: 7F1B5000  cmpw cr6, r27, r10
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824A1720: 40980074  bge cr6, 0x824a1794
	if !ctx.cr[6].lt {
	pc = 0x824A1794; continue 'dispatch;
	}
	// 824A1724: 573826B6  rlwinm r24, r25, 4, 0x1a, 0x1b
	ctx.r[24].u64 = ctx.r[25].u32 as u64 & 0x0FFFFFFFu64;
	// 824A1728: 57373032  slwi r23, r25, 6
	ctx.r[23].u32 = ctx.r[25].u32.wrapping_shl(6);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	// 824A172C: 577D103A  slwi r29, r27, 2
	ctx.r[29].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	pc = 0x824A1730; continue 'dispatch;
            }
            0x824A1730 => {
    //   block [0x824A1730..0x824A1770)
	// 824A1730: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1734: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 824A1738: 7FEBE82E  lwzx r31, r11, r29
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A173C: 897F0026  lbz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 824A1740: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 824A1744: 7D6BC378  or r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[24].u64;
	// 824A1748: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 824A174C: 7D6BBB78  or r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[23].u64;
	// 824A1750: 997F0026  stb r11, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[11].u8 ) };
	// 824A1754: 419A001C  beq cr6, 0x824a1770
	if ctx.cr[6].eq {
	pc = 0x824A1770; continue 'dispatch;
	}
	// 824A1758: 7EAB0774  extsb r11, r21
	ctx.r[11].s64 = ctx.r[21].s8 as i64;
	// 824A175C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A1760: 409A0010  bne cr6, 0x824a1770
	if !ctx.cr[6].eq {
	pc = 0x824A1770; continue 'dispatch;
	}
	// 824A1764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824A1768: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 824A176C: 4BFFD37D  bl 0x8249eae8
	ctx.lr = 0x824A1770;
	sub_8249EAE8(ctx, base);
	pc = 0x824A1770; continue 'dispatch;
            }
            0x824A1770 => {
    //   block [0x824A1770..0x824A1794)
	// 824A1770: 895A0024  lbz r10, 0x24(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 824A1774: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 824A1778: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824A177C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824A1780: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 824A1784: 997F0024  stb r11, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 824A1788: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A178C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A1790: 4198FFA0  blt cr6, 0x824a1730
	if ctx.cr[6].lt {
	pc = 0x824A1730; continue 'dispatch;
	}
	pc = 0x824A1794; continue 'dispatch;
            }
            0x824A1794 => {
    //   block [0x824A1794..0x824A179C)
	// 824A1794: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 824A1798: 48093954  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A17A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A17A0 size=104
    let mut pc: u32 = 0x824A17A0;
    'dispatch: loop {
        match pc {
            0x824A17A0 => {
    //   block [0x824A17A0..0x824A17D0)
	// 824A17A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A17A4: 48093919  bl 0x825350bc
	ctx.lr = 0x824A17A8;
	sub_82535080(ctx, base);
	// 824A17A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A17AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824A17B0: 897D00B8  lbz r11, 0xb8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A17B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A17B8: 419A0048  beq cr6, 0x824a1800
	if ctx.cr[6].eq {
	pc = 0x824A1800; continue 'dispatch;
	}
	// 824A17BC: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A17C0: 3BCBFFFF  addi r30, r11, -1
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	// 824A17C4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824A17C8: 41980038  blt cr6, 0x824a1800
	if ctx.cr[6].lt {
	pc = 0x824A1800; continue 'dispatch;
	}
	// 824A17CC: 57DF103A  slwi r31, r30, 2
	ctx.r[31].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x824A17D0; continue 'dispatch;
            }
            0x824A17D0 => {
    //   block [0x824A17D0..0x824A17F0)
	// 824A17D0: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A17D4: 7C8BF82E  lwzx r4, r11, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 824A17D8: 89640025  lbz r11, 0x25(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(37 as u32) ) } as u64;
	// 824A17DC: 556B0032  rlwinm r11, r11, 0, 0, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A17E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A17E4: 419A000C  beq cr6, 0x824a17f0
	if ctx.cr[6].eq {
	pc = 0x824A17F0; continue 'dispatch;
	}
	// 824A17E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824A17EC: 4BFFFECD  bl 0x824a16b8
	ctx.lr = 0x824A17F0;
	sub_824A16B8(ctx, base);
	pc = 0x824A17F0; continue 'dispatch;
            }
            0x824A17F0 => {
    //   block [0x824A17F0..0x824A1800)
	// 824A17F0: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 824A17F4: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 824A17F8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824A17FC: 4098FFD4  bge cr6, 0x824a17d0
	if !ctx.cr[6].lt {
	pc = 0x824A17D0; continue 'dispatch;
	}
	pc = 0x824A1800; continue 'dispatch;
            }
            0x824A1800 => {
    //   block [0x824A1800..0x824A1808)
	// 824A1800: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A1804: 48093908  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A1808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A1808 size=100
    let mut pc: u32 = 0x824A1808;
    'dispatch: loop {
        match pc {
            0x824A1808 => {
    //   block [0x824A1808..0x824A1858)
	// 824A1808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A180C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A1810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A1814: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 824A1818: 81230084  lwz r9, 0x84(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A181C: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 824A1820: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824A1824: 808B00B8  lwz r4, 0xb8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A1828: 80AA00B8  lwz r5, 0xb8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A182C: 419A002C  beq cr6, 0x824a1858
	if ctx.cr[6].eq {
	pc = 0x824A1858; continue 'dispatch;
	}
	// 824A1830: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 824A1834: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 824A1838: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824A183C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 824A1840: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 824A1844: 4BFF1995  bl 0x824931d8
	ctx.lr = 0x824A1848;
	sub_824931D8(ctx, base);
	// 824A1848: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A184C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A1850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A1854: 4E800020  blr
	return;
            }
            0x824A1858 => {
    //   block [0x824A1858..0x824A186C)
	// 824A1858: 4BFFE0E9  bl 0x8249f940
	ctx.lr = 0x824A185C;
	sub_8249F940(ctx, base);
	// 824A185C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A1860: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A1864: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A1868: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A1870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A1870 size=460
    let mut pc: u32 = 0x824A1870;
    'dispatch: loop {
        match pc {
            0x824A1870 => {
    //   block [0x824A1870..0x824A18BC)
	// 824A1870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A1874: 48093831  bl 0x825350a4
	ctx.lr = 0x824A1878;
	sub_82535080(ctx, base);
	// 824A1878: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A187C: 3961005C  addi r11, r1, 0x5c
	ctx.r[11].s64 = ctx.r[1].s64 + 92;
	// 824A1880: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824A1884: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 824A1888: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824A188C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 824A1890: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824A1894: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 824A1898: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A189C: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 824A18A0: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 824A18A4: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 824A18A8: 835D00B8  lwz r26, 0xb8(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A18AC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A18B0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 824A18B4: 40990158  ble cr6, 0x824a1a0c
	if !ctx.cr[6].gt {
	pc = 0x824A1A0C; continue 'dispatch;
	}
	// 824A18B8: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	pc = 0x824A18BC; continue 'dispatch;
            }
            0x824A18BC => {
    //   block [0x824A18BC..0x824A1918)
	// 824A18BC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A18C0: 80780020  lwz r3, 0x20(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A18C4: 7F1A1840  cmplw cr6, r26, r3
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[3].u32, &mut ctx.xer);
	// 824A18C8: 7FFB582E  lwzx r31, r27, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A18CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824A18D0: 419A00E4  beq cr6, 0x824a19b4
	if ctx.cr[6].eq {
	pc = 0x824A19B4; continue 'dispatch;
	}
	// 824A18D4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 824A18D8: 48015271  bl 0x824b6b48
	ctx.lr = 0x824A18DC;
	sub_824B6B48(ctx, base);
	// 824A18DC: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A18E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A18E4: 419A0034  beq cr6, 0x824a1918
	if ctx.cr[6].eq {
	pc = 0x824A1918; continue 'dispatch;
	}
	// 824A18E8: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 824A18EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824A18F0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824A18F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A18F8: B17F0006  sth r11, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824A18FC: 409A001C  bne cr6, 0x824a1918
	if !ctx.cr[6].eq {
	pc = 0x824A1918; continue 'dispatch;
	}
	// 824A1900: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1904: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824A1908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A190C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1910: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A1914: 4E800421  bctrl
	ctx.lr = 0x824A1918;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A1918 => {
    //   block [0x824A1918..0x824A1948)
	// 824A1918: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 824A191C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824A1920: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A1928: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A192C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A1930: 4E800421  bctrl
	ctx.lr = 0x824A1934;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A1934: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A1938: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 824A193C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A1940: 409900B4  ble cr6, 0x824a19f4
	if !ctx.cr[6].gt {
	pc = 0x824A19F4; continue 'dispatch;
	}
	// 824A1944: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
            }
            0x824A1948 => {
    //   block [0x824A1948..0x824A199C)
	// 824A1948: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824A194C: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A1950: 894400D8  lbz r10, 0xd8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(216 as u32) ) } as u64;
	// 824A1954: 2B0A0007  cmplwi cr6, r10, 7
	ctx.cr[6].compare_u32(ctx.r[10].u32, 7 as u32, &mut ctx.xer);
	// 824A1958: 419A0044  beq cr6, 0x824a199c
	if ctx.cr[6].eq {
	pc = 0x824A199C; continue 'dispatch;
	}
	// 824A195C: 548B003E  slwi r11, r4, 0
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A1960: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 824A1964: 419A0038  beq cr6, 0x824a199c
	if ctx.cr[6].eq {
	pc = 0x824A199C; continue 'dispatch;
	}
	// 824A1968: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 824A196C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 824A1970: 419A002C  beq cr6, 0x824a199c
	if ctx.cr[6].eq {
	pc = 0x824A199C; continue 'dispatch;
	}
	// 824A1974: 897D00D8  lbz r11, 0xd8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(216 as u32) ) } as u64;
	// 824A1978: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 824A197C: 419A0020  beq cr6, 0x824a199c
	if ctx.cr[6].eq {
	pc = 0x824A199C; continue 'dispatch;
	}
	// 824A1980: 816400B8  lwz r11, 0xb8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A1984: 815D00B8  lwz r10, 0xb8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A1988: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824A198C: 419A0010  beq cr6, 0x824a199c
	if ctx.cr[6].eq {
	pc = 0x824A199C; continue 'dispatch;
	}
	// 824A1990: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 824A1994: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1998: 4BFFFE71  bl 0x824a1808
	ctx.lr = 0x824A199C;
	sub_824A1808(ctx, base);
	pc = 0x824A199C; continue 'dispatch;
            }
            0x824A199C => {
    //   block [0x824A199C..0x824A19B4)
	// 824A199C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A19A0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824A19A4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824A19A8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A19AC: 4198FF9C  blt cr6, 0x824a1948
	if ctx.cr[6].lt {
	pc = 0x824A1948; continue 'dispatch;
	}
	// 824A19B0: 48000044  b 0x824a19f4
	pc = 0x824A19F4; continue 'dispatch;
            }
            0x824A19B4 => {
    //   block [0x824A19B4..0x824A19F4)
	// 824A19B4: 48015195  bl 0x824b6b48
	ctx.lr = 0x824A19B8;
	sub_824B6B48(ctx, base);
	// 824A19B8: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A19BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A19C0: 419A0034  beq cr6, 0x824a19f4
	if ctx.cr[6].eq {
	pc = 0x824A19F4; continue 'dispatch;
	}
	// 824A19C4: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 824A19C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824A19CC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824A19D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A19D4: B17F0006  sth r11, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824A19D8: 409A001C  bne cr6, 0x824a19f4
	if !ctx.cr[6].eq {
	pc = 0x824A19F4; continue 'dispatch;
	}
	// 824A19DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A19E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824A19E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A19E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A19EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A19F0: 4E800421  bctrl
	ctx.lr = 0x824A19F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A19F4 => {
    //   block [0x824A19F4..0x824A1A0C)
	// 824A19F4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A19F8: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 824A19FC: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 824A1A00: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A1A04: 4198FEB8  blt cr6, 0x824a18bc
	if ctx.cr[6].lt {
	pc = 0x824A18BC; continue 'dispatch;
	}
	// 824A1A08: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x824A1A0C; continue 'dispatch;
            }
            0x824A1A0C => {
    //   block [0x824A1A0C..0x824A1A34)
	// 824A1A0C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A1A10: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A1A14: 409A0020  bne cr6, 0x824a1a34
	if !ctx.cr[6].eq {
	pc = 0x824A1A34; continue 'dispatch;
	}
	// 824A1A18: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1A1C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824A1A20: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A1A24: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824A1A28: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A1A2C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824A1A30: 4BFC2689  bl 0x824640b8
	ctx.lr = 0x824A1A34;
	sub_824640B8(ctx, base);
	pc = 0x824A1A34; continue 'dispatch;
            }
            0x824A1A34 => {
    //   block [0x824A1A34..0x824A1A3C)
	// 824A1A34: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 824A1A38: 480936BC  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A1A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A1A40 size=1204
    let mut pc: u32 = 0x824A1A40;
    'dispatch: loop {
        match pc {
            0x824A1A40 => {
    //   block [0x824A1A40..0x824A1A84)
	// 824A1A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A1A44: 48093661  bl 0x825350a4
	ctx.lr = 0x824A1A48;
	sub_82535080(ctx, base);
	// 824A1A48: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A1A4C: 90610184  stw r3, 0x184(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), ctx.r[3].u32 ) };
	// 824A1A50: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 824A1A54: 8B8300D8  lbz r28, 0xd8(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(216 as u32) ) } as u64;
	// 824A1A58: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 824A1A5C: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 824A1A60: 7F1CC800  cmpw cr6, r28, r25
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[25].s32, &mut ctx.xer);
	// 824A1A64: 419A0488  beq cr6, 0x824a1eec
	if ctx.cr[6].eq {
	pc = 0x824A1EEC; continue 'dispatch;
	}
	// 824A1A68: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 824A1A6C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 824A1A70: 2F190007  cmpwi cr6, r25, 7
	ctx.cr[6].compare_i32(ctx.r[25].s32, 7, &mut ctx.xer);
	// 824A1A74: 419A0010  beq cr6, 0x824a1a84
	if ctx.cr[6].eq {
	pc = 0x824A1A84; continue 'dispatch;
	}
	// 824A1A78: 2F190006  cmpwi cr6, r25, 6
	ctx.cr[6].compare_i32(ctx.r[25].s32, 6, &mut ctx.xer);
	// 824A1A7C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 824A1A80: 409A0008  bne cr6, 0x824a1a88
	if !ctx.cr[6].eq {
	pc = 0x824A1A88; continue 'dispatch;
	}
	pc = 0x824A1A84; continue 'dispatch;
            }
            0x824A1A84 => {
    //   block [0x824A1A84..0x824A1A88)
	// 824A1A84: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x824A1A88; continue 'dispatch;
            }
            0x824A1A88 => {
    //   block [0x824A1A88..0x824A1AA0)
	// 824A1A88: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 824A1A8C: 2F1C0007  cmpwi cr6, r28, 7
	ctx.cr[6].compare_i32(ctx.r[28].s32, 7, &mut ctx.xer);
	// 824A1A90: 419A0010  beq cr6, 0x824a1aa0
	if ctx.cr[6].eq {
	pc = 0x824A1AA0; continue 'dispatch;
	}
	// 824A1A94: 2F1C0006  cmpwi cr6, r28, 6
	ctx.cr[6].compare_i32(ctx.r[28].s32, 6, &mut ctx.xer);
	// 824A1A98: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 824A1A9C: 409A0008  bne cr6, 0x824a1aa4
	if !ctx.cr[6].eq {
	pc = 0x824A1AA4; continue 'dispatch;
	}
	pc = 0x824A1AA0; continue 'dispatch;
            }
            0x824A1AA0 => {
    //   block [0x824A1AA0..0x824A1AA4)
	// 824A1AA0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x824A1AA4; continue 'dispatch;
            }
            0x824A1AA4 => {
    //   block [0x824A1AA4..0x824A1ACC)
	// 824A1AA4: 57AA063E  clrlwi r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 824A1AA8: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 824A1AAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824A1AB0: 419A001C  beq cr6, 0x824a1acc
	if ctx.cr[6].eq {
	pc = 0x824A1ACC; continue 'dispatch;
	}
	// 824A1AB4: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 824A1AB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A1ABC: 409A0010  bne cr6, 0x824a1acc
	if !ctx.cr[6].eq {
	pc = 0x824A1ACC; continue 'dispatch;
	}
	// 824A1AC0: 816301E8  lwz r11, 0x1e8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(488 as u32) ) } as u64;
	// 824A1AC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A1AC8: 419A0424  beq cr6, 0x824a1eec
	if ctx.cr[6].eq {
	pc = 0x824A1EEC; continue 'dispatch;
	}
	pc = 0x824A1ACC; continue 'dispatch;
            }
            0x824A1ACC => {
    //   block [0x824A1ACC..0x824A1B78)
	// 824A1ACC: 4BFF9F65  bl 0x8249ba30
	ctx.lr = 0x824A1AD0;
	sub_8249BA30(ctx, base);
	// 824A1AD0: 80610184  lwz r3, 0x184(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1AD4: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1AD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824A1ADC: 419A03C8  beq cr6, 0x824a1ea4
	if ctx.cr[6].eq {
	pc = 0x824A1EA4; continue 'dispatch;
	}
	// 824A1AE0: 397CFFF9  addi r11, r28, -7
	ctx.r[11].s64 = ctx.r[28].s64 + -7;
	// 824A1AE4: 3959FFF9  addi r10, r25, -7
	ctx.r[10].s64 = ctx.r[25].s64 + -7;
	// 824A1AE8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 824A1AEC: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 824A1AF0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 824A1AF4: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 824A1AF8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824A1AFC: 419A03A8  beq cr6, 0x824a1ea4
	if ctx.cr[6].eq {
	pc = 0x824A1EA4; continue 'dispatch;
	}
	// 824A1B00: 3961008C  addi r11, r1, 0x8c
	ctx.r[11].s64 = ctx.r[1].s64 + 140;
	// 824A1B04: 93010084  stw r24, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[24].u32 ) };
	// 824A1B08: 394100DC  addi r10, r1, 0xdc
	ctx.r[10].s64 = ctx.r[1].s64 + 220;
	// 824A1B0C: 930100D4  stw r24, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[24].u32 ) };
	// 824A1B10: 93010068  stw r24, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u32 ) };
	// 824A1B14: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 824A1B18: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 824A1B1C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 824A1B20: 914100D0  stw r10, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 824A1B24: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 824A1B28: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 824A1B2C: 916100D8  stw r11, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 824A1B30: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 824A1B34: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 824A1B38: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 824A1B3C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 824A1B40: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 824A1B44: 39600200  li r11, 0x200
	ctx.r[11].s64 = 512;
	// 824A1B48: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824A1B4C: 9B7F008C  stb r27, 0x8c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[27].u8 ) };
	// 824A1B50: 9B1F008D  stb r24, 0x8d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(141 as u32), ctx.r[24].u8 ) };
	// 824A1B54: 80610184  lwz r3, 0x184(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1B58: 4BFFCA39  bl 0x8249e590
	ctx.lr = 0x824A1B5C;
	sub_8249E590(ctx, base);
	// 824A1B5C: 80810184  lwz r4, 0x184(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1B60: 2F190007  cmpwi cr6, r25, 7
	ctx.cr[6].compare_i32(ctx.r[25].s32, 7, &mut ctx.xer);
	// 824A1B64: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 824A1B68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A1B6C: 419A000C  beq cr6, 0x824a1b78
	if ctx.cr[6].eq {
	pc = 0x824A1B78; continue 'dispatch;
	}
	// 824A1B70: 4BFFC5F9  bl 0x8249e168
	ctx.lr = 0x824A1B74;
	sub_8249E168(ctx, base);
	// 824A1B74: 48000008  b 0x824a1b7c
	pc = 0x824A1B7C; continue 'dispatch;
            }
            0x824A1B78 => {
    //   block [0x824A1B78..0x824A1B7C)
	// 824A1B78: 4BFFD671  bl 0x8249f1e8
	ctx.lr = 0x824A1B7C;
	sub_8249F1E8(ctx, base);
	pc = 0x824A1B7C; continue 'dispatch;
            }
            0x824A1B7C => {
    //   block [0x824A1B7C..0x824A1BC0)
	// 824A1B7C: 80810184  lwz r4, 0x184(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1B80: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 824A1B84: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824A1B88: 816400B8  lwz r11, 0xb8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A1B8C: 386B0058  addi r3, r11, 0x58
	ctx.r[3].s64 = ctx.r[11].s64 + 88;
	// 824A1B90: 4BFFC2C9  bl 0x8249de58
	ctx.lr = 0x824A1B94;
	sub_8249DE58(ctx, base);
	// 824A1B94: 2F1C0007  cmpwi cr6, r28, 7
	ctx.cr[6].compare_i32(ctx.r[28].s32, 7, &mut ctx.xer);
	// 824A1B98: 419A0028  beq cr6, 0x824a1bc0
	if ctx.cr[6].eq {
	pc = 0x824A1BC0; continue 'dispatch;
	}
	// 824A1B9C: 81610184  lwz r11, 0x184(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1BA0: 814B00B8  lwz r10, 0xb8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A1BA4: 814A004C  lwz r10, 0x4c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A1BA8: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 824A1BAC: 40990014  ble cr6, 0x824a1bc0
	if !ctx.cr[6].gt {
	pc = 0x824A1BC0; continue 'dispatch;
	}
	// 824A1BB0: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A1BB4: 894B0025  lbz r10, 0x25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 824A1BB8: 536A3032  rlwimi r10, r27, 6, 0, 0x19
	ctx.r[10].u64 = (((ctx.r[27].u32).rotate_left(6) as u64) & 0x00000000FFFFFFC0) | (ctx.r[10].u64 & 0xFFFFFFFF0000003F);
	// 824A1BBC: 994B0025  stb r10, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x824A1BC0; continue 'dispatch;
            }
            0x824A1BC0 => {
    //   block [0x824A1BC0..0x824A1C2C)
	// 824A1BC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A1BC4: 80810184  lwz r4, 0x184(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1BC8: 4BFFD591  bl 0x8249f158
	ctx.lr = 0x824A1BCC;
	sub_8249F158(ctx, base);
	// 824A1BCC: 39610051  addi r11, r1, 0x51
	ctx.r[11].s64 = ctx.r[1].s64 + 81;
	// 824A1BD0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 824A1BD4: 9BC10051  stb r30, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[30].u8 ) };
	// 824A1BD8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 824A1BDC: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 824A1BE0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 824A1BE4: 80610184  lwz r3, 0x184(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1BE8: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1BEC: 88AA0000  lbz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1BF0: 4BFFD0B9  bl 0x8249eca8
	ctx.lr = 0x824A1BF4;
	sub_8249ECA8(ctx, base);
	// 824A1BF4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 824A1BF8: 80810184  lwz r4, 0x184(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1BFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A1C00: 4BFFC399  bl 0x8249df98
	ctx.lr = 0x824A1C04;
	sub_8249DF98(ctx, base);
	// 824A1C04: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 824A1C08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A1C0C: 80810184  lwz r4, 0x184(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1C10: 4BFFFC61  bl 0x824a1870
	ctx.lr = 0x824A1C14;
	sub_824A1870(ctx, base);
	// 824A1C14: 9B7F008D  stb r27, 0x8d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(141 as u32), ctx.r[27].u8 ) };
	// 824A1C18: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A1C1C: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 824A1C20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A1C24: 409900A8  ble cr6, 0x824a1ccc
	if !ctx.cr[6].gt {
	pc = 0x824A1CCC; continue 'dispatch;
	}
	// 824A1C28: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	pc = 0x824A1C2C; continue 'dispatch;
            }
            0x824A1C2C => {
    //   block [0x824A1C2C..0x824A1C7C)
	// 824A1C2C: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A1C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A1C34: 7FDD582E  lwzx r30, r29, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A1C38: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A1C3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824A1C40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A1C44: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A1C48: 48019D29  bl 0x824bb970
	ctx.lr = 0x824A1C4C;
	sub_824BB970(ctx, base);
	// 824A1C4C: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A1C50: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A1C54: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A1C58: 40820024  bne 0x824a1c7c
	if !ctx.cr[0].eq {
	pc = 0x824A1C7C; continue 'dispatch;
	}
	// 824A1C5C: 897F008C  lbz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A1C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A1C64: 409A0018  bne cr6, 0x824a1c7c
	if !ctx.cr[6].eq {
	pc = 0x824A1C7C; continue 'dispatch;
	}
	// 824A1C68: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A1C6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A1C70: 419A000C  beq cr6, 0x824a1c7c
	if ctx.cr[6].eq {
	pc = 0x824A1C7C; continue 'dispatch;
	}
	// 824A1C74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A1C78: 4BFF1549  bl 0x824931c0
	ctx.lr = 0x824A1C7C;
	sub_824931C0(ctx, base);
	pc = 0x824A1C7C; continue 'dispatch;
            }
            0x824A1C7C => {
    //   block [0x824A1C7C..0x824A1CB8)
	// 824A1C7C: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1C80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A1C84: 419A0034  beq cr6, 0x824a1cb8
	if ctx.cr[6].eq {
	pc = 0x824A1CB8; continue 'dispatch;
	}
	// 824A1C88: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 824A1C8C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824A1C90: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824A1C94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A1C98: B17E0006  sth r11, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824A1C9C: 409A001C  bne cr6, 0x824a1cb8
	if !ctx.cr[6].eq {
	pc = 0x824A1CB8; continue 'dispatch;
	}
	// 824A1CA0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1CA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824A1CA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824A1CAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1CB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A1CB4: 4E800421  bctrl
	ctx.lr = 0x824A1CB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A1CB8 => {
    //   block [0x824A1CB8..0x824A1CCC)
	// 824A1CB8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A1CBC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 824A1CC0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 824A1CC4: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A1CC8: 4198FF64  blt cr6, 0x824a1c2c
	if ctx.cr[6].lt {
	pc = 0x824A1C2C; continue 'dispatch;
	}
	pc = 0x824A1CCC; continue 'dispatch;
            }
            0x824A1CCC => {
    //   block [0x824A1CCC..0x824A1CF0)
	// 824A1CCC: 80810184  lwz r4, 0x184(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1CD0: 2F190007  cmpwi cr6, r25, 7
	ctx.cr[6].compare_i32(ctx.r[25].s32, 7, &mut ctx.xer);
	// 824A1CD4: 419A007C  beq cr6, 0x824a1d50
	if ctx.cr[6].eq {
	pc = 0x824A1D50; continue 'dispatch;
	}
	// 824A1CD8: 3BA4005C  addi r29, r4, 0x5c
	ctx.r[29].s64 = ctx.r[4].s64 + 92;
	// 824A1CDC: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 824A1CE0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1CE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A1CE8: 40990068  ble cr6, 0x824a1d50
	if !ctx.cr[6].gt {
	pc = 0x824A1D50; continue 'dispatch;
	}
	// 824A1CEC: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	pc = 0x824A1CF0; continue 'dispatch;
            }
            0x824A1CF0 => {
    //   block [0x824A1CF0..0x824A1D3C)
	// 824A1CF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1CF4: 894400D8  lbz r10, 0xd8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(216 as u32) ) } as u64;
	// 824A1CF8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 824A1CFC: 2B0A0007  cmplwi cr6, r10, 7
	ctx.cr[6].compare_u32(ctx.r[10].u32, 7 as u32, &mut ctx.xer);
	// 824A1D00: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1D04: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A1D08: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 824A1D0C: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824A1D10: 419A002C  beq cr6, 0x824a1d3c
	if ctx.cr[6].eq {
	pc = 0x824A1D3C; continue 'dispatch;
	}
	// 824A1D14: 896500D8  lbz r11, 0xd8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(216 as u32) ) } as u64;
	// 824A1D18: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 824A1D1C: 419A0020  beq cr6, 0x824a1d3c
	if ctx.cr[6].eq {
	pc = 0x824A1D3C; continue 'dispatch;
	}
	// 824A1D20: 816400B8  lwz r11, 0xb8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A1D24: 814500B8  lwz r10, 0xb8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A1D28: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824A1D2C: 419A0010  beq cr6, 0x824a1d3c
	if ctx.cr[6].eq {
	pc = 0x824A1D3C; continue 'dispatch;
	}
	// 824A1D30: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1D34: 4BFFFAD5  bl 0x824a1808
	ctx.lr = 0x824A1D38;
	sub_824A1808(ctx, base);
	// 824A1D38: 80810184  lwz r4, 0x184(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	pc = 0x824A1D3C; continue 'dispatch;
            }
            0x824A1D3C => {
    //   block [0x824A1D3C..0x824A1D50)
	// 824A1D3C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1D40: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 824A1D44: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 824A1D48: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A1D4C: 4198FFA4  blt cr6, 0x824a1cf0
	if ctx.cr[6].lt {
	pc = 0x824A1CF0; continue 'dispatch;
	}
	pc = 0x824A1D50; continue 'dispatch;
            }
            0x824A1D50 => {
    //   block [0x824A1D50..0x824A1DD8)
	// 824A1D50: 816400B8  lwz r11, 0xb8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A1D54: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 824A1D58: 386B0058  addi r3, r11, 0x58
	ctx.r[3].s64 = ctx.r[11].s64 + 88;
	// 824A1D5C: 480339CD  bl 0x824d5728
	ctx.lr = 0x824A1D60;
	sub_824D5728(ctx, base);
	// 824A1D60: 2F190007  cmpwi cr6, r25, 7
	ctx.cr[6].compare_i32(ctx.r[25].s32, 7, &mut ctx.xer);
	// 824A1D64: 409A0074  bne cr6, 0x824a1dd8
	if !ctx.cr[6].eq {
	pc = 0x824A1DD8; continue 'dispatch;
	}
	// 824A1D68: 81610184  lwz r11, 0x184(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1D6C: C03F0190  lfs f1, 0x190(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824A1D70: 388B00E0  addi r4, r11, 0xe0
	ctx.r[4].s64 = ctx.r[11].s64 + 224;
	// 824A1D74: 48107D6D  bl 0x825a9ae0
	ctx.lr = 0x824A1D78;
	sub_825A9AE0(ctx, base);
	// 824A1D78: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A1D7C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1D80: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 824A1D84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824A1D88: 9B010050  stb r24, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u8 ) };
	// 824A1D8C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 824A1D90: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 824A1D94: 38810184  addi r4, r1, 0x184
	ctx.r[4].s64 = ctx.r[1].s64 + 388;
	// 824A1D98: 88EB0000  lbz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1D9C: 915F0084  stw r10, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 824A1DA0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1DA4: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A1DA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A1DAC: 4E800421  bctrl
	ctx.lr = 0x824A1DB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A1DB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824A1DB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824A1DB8: 38610184  addi r3, r1, 0x184
	ctx.r[3].s64 = ctx.r[1].s64 + 388;
	// 824A1DBC: 48005115  bl 0x824a6ed0
	ctx.lr = 0x824A1DC0;
	sub_824A6ED0(ctx, base);
	// 824A1DC0: 80810184  lwz r4, 0x184(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1DC4: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1DC8: 48003921  bl 0x824a56e8
	ctx.lr = 0x824A1DCC;
	sub_824A56E8(ctx, base);
	// 824A1DCC: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A1DD0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824A1DD4: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
            }
            0x824A1DD8 => {
    //   block [0x824A1DD8..0x824A1E10)
	// 824A1DD8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 824A1DDC: 80810184  lwz r4, 0x184(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1DE0: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 824A1DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A1DE8: 4BFF5F59  bl 0x82497d40
	ctx.lr = 0x824A1DEC;
	sub_82497D40(ctx, base);
	// 824A1DEC: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A1DF0: 9B1F008C  stb r24, 0x8c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[24].u8 ) };
	// 824A1DF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A1DF8: 409A0018  bne cr6, 0x824a1e10
	if !ctx.cr[6].eq {
	pc = 0x824A1E10; continue 'dispatch;
	}
	// 824A1DFC: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A1E00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A1E04: 419A000C  beq cr6, 0x824a1e10
	if ctx.cr[6].eq {
	pc = 0x824A1E10; continue 'dispatch;
	}
	// 824A1E08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A1E0C: 4BFF13B5  bl 0x824931c0
	ctx.lr = 0x824A1E10;
	sub_824931C0(ctx, base);
	pc = 0x824A1E10; continue 'dispatch;
            }
            0x824A1E10 => {
    //   block [0x824A1E10..0x824A1E3C)
	// 824A1E10: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A1E14: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A1E18: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A1E1C: 409A0020  bne cr6, 0x824a1e3c
	if !ctx.cr[6].eq {
	pc = 0x824A1E3C; continue 'dispatch;
	}
	// 824A1E20: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1E24: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824A1E28: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A1E2C: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824A1E30: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A1E34: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824A1E38: 4BFC2281  bl 0x824640b8
	ctx.lr = 0x824A1E3C;
	sub_824640B8(ctx, base);
	pc = 0x824A1E3C; continue 'dispatch;
            }
            0x824A1E3C => {
    //   block [0x824A1E3C..0x824A1E68)
	// 824A1E3C: 816100D8  lwz r11, 0xd8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) } as u64;
	// 824A1E40: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A1E44: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A1E48: 409A0020  bne cr6, 0x824a1e68
	if !ctx.cr[6].eq {
	pc = 0x824A1E68; continue 'dispatch;
	}
	// 824A1E4C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1E50: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824A1E54: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A1E58: 808100D0  lwz r4, 0xd0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 824A1E5C: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A1E60: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824A1E64: 4BFC2255  bl 0x824640b8
	ctx.lr = 0x824A1E68;
	sub_824640B8(ctx, base);
	pc = 0x824A1E68; continue 'dispatch;
            }
            0x824A1E68 => {
    //   block [0x824A1E68..0x824A1EA4)
	// 824A1E68: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 824A1E6C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A1E70: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A1E74: 409A0070  bne cr6, 0x824a1ee4
	if !ctx.cr[6].eq {
	pc = 0x824A1EE4; continue 'dispatch;
	}
	// 824A1E78: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1E7C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824A1E80: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A1E84: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A1E88: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A1E8C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824A1E90: 4BFC2229  bl 0x824640b8
	ctx.lr = 0x824A1E94;
	sub_824640B8(ctx, base);
	// 824A1E94: 80610184  lwz r3, 0x184(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1E98: 4BFF9BB9  bl 0x8249ba50
	ctx.lr = 0x824A1E9C;
	sub_8249BA50(ctx, base);
	// 824A1E9C: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 824A1EA0: 48093254  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            0x824A1EA4 => {
    //   block [0x824A1EA4..0x824A1EE4)
	// 824A1EA4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 824A1EA8: 9BC10050  stb r30, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 824A1EAC: 39410051  addi r10, r1, 0x51
	ctx.r[10].s64 = ctx.r[1].s64 + 81;
	// 824A1EB0: 9BA10051  stb r29, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[29].u8 ) };
	// 824A1EB4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 824A1EB8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 824A1EBC: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1EC0: 88AA0000  lbz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1EC4: 4BFFCDE5  bl 0x8249eca8
	ctx.lr = 0x824A1EC8;
	sub_8249ECA8(ctx, base);
	// 824A1EC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824A1ECC: 419A0018  beq cr6, 0x824a1ee4
	if ctx.cr[6].eq {
	pc = 0x824A1EE4; continue 'dispatch;
	}
	// 824A1ED0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 824A1ED4: 80810184  lwz r4, 0x184(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1ED8: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 824A1EDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A1EE0: 4BFF5E61  bl 0x82497d40
	ctx.lr = 0x824A1EE4;
	sub_82497D40(ctx, base);
	pc = 0x824A1EE4; continue 'dispatch;
            }
            0x824A1EE4 => {
    //   block [0x824A1EE4..0x824A1EEC)
	// 824A1EE4: 80610184  lwz r3, 0x184(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824A1EE8: 4BFF9B69  bl 0x8249ba50
	ctx.lr = 0x824A1EEC;
	sub_8249BA50(ctx, base);
	pc = 0x824A1EEC; continue 'dispatch;
            }
            0x824A1EEC => {
    //   block [0x824A1EEC..0x824A1EF4)
	// 824A1EEC: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 824A1EF0: 48093204  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A1EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A1EF8 size=24
    let mut pc: u32 = 0x824A1EF8;
    'dispatch: loop {
        match pc {
            0x824A1EF8 => {
    //   block [0x824A1EF8..0x824A1F10)
	// 824A1EF8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1EFC: 39440001  addi r10, r4, 1
	ctx.r[10].s64 = ctx.r[4].s64 + 1;
	// 824A1F00: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A1F04: 409A000C  bne cr6, 0x824a1f10
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x824A1F10);
		return;
	}
	// 824A1F08: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1F0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A1F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A1F18 size=116
    let mut pc: u32 = 0x824A1F18;
    'dispatch: loop {
        match pc {
            0x824A1F18 => {
    //   block [0x824A1F18..0x824A1F8C)
	// 824A1F18: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A1F1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A1F20: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 824A1F24: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1F28: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A1F2C: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A1F30: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 824A1F34: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A1F38: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824A1F3C: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1F40: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 824A1F44: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 824A1F48: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A1F4C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 824A1F50: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 824A1F54: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A1F58: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A1F5C: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1F60: 81050008  lwz r8, 8(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1F64: A0EB0018  lhz r7, 0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A1F68: A0CB0014  lhz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A1F6C: 7D4A3850  subf r10, r10, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 824A1F70: A0EB0016  lhz r7, 0x16(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 824A1F74: 7D293050  subf r9, r9, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 824A1F78: 7D083850  subf r8, r8, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 824A1F7C: B14B0018  sth r10, 0x18(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u16 ) };
	// 824A1F80: B12B0014  sth r9, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	// 824A1F84: B10B0016  sth r8, 0x16(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(22 as u32), ctx.r[8].u16 ) };
	// 824A1F88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A1F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A1F90 size=188
    let mut pc: u32 = 0x824A1F90;
    'dispatch: loop {
        match pc {
            0x824A1F90 => {
    //   block [0x824A1F90..0x824A1FB0)
	// 824A1F90: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A1F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A1F98: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 824A1F9C: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A1FA0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1FA4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A1FA8: 40990008  ble cr6, 0x824a1fb0
	if !ctx.cr[6].gt {
	pc = 0x824A1FB0; continue 'dispatch;
	}
	// 824A1FAC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x824A1FB0; continue 'dispatch;
            }
            0x824A1FB0 => {
    //   block [0x824A1FB0..0x824A1FC4)
	// 824A1FB0: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824A1FB4: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1FB8: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 824A1FBC: 40990008  ble cr6, 0x824a1fc4
	if !ctx.cr[6].gt {
	pc = 0x824A1FC4; continue 'dispatch;
	}
	// 824A1FC0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	pc = 0x824A1FC4; continue 'dispatch;
            }
            0x824A1FC4 => {
    //   block [0x824A1FC4..0x824A2044)
	// 824A1FC4: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 824A1FC8: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A1FCC: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A1FD0: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A1FD4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 824A1FD8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A1FDC: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A1FE0: 81450008  lwz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A1FE4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824A1FE8: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 824A1FEC: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A1FF0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824A1FF4: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 824A1FF8: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A1FFC: 8105000C  lwz r8, 0xc(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2000: 80C50004  lwz r6, 4(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2004: 80E50008  lwz r7, 8(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2008: A14B0018  lhz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A200C: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A2010: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 824A2014: A10B0016  lhz r8, 0x16(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 824A2018: 7D293214  add r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	// 824A201C: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 824A2020: B14B0018  sth r10, 0x18(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u16 ) };
	// 824A2024: B12B0014  sth r9, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	// 824A2028: B10B0016  sth r8, 0x16(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(22 as u32), ctx.r[8].u16 ) };
	// 824A202C: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A2030: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2034: A14A0014  lhz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A2038: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824A203C: 41990008  bgt cr6, 0x824a2044
	if ctx.cr[6].gt {
	pc = 0x824A2044; continue 'dispatch;
	}
	// 824A2040: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x824A2044; continue 'dispatch;
            }
            0x824A2044 => {
    //   block [0x824A2044..0x824A204C)
	// 824A2044: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824A2048: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A2050 size=136
    let mut pc: u32 = 0x824A2050;
    'dispatch: loop {
        match pc {
            0x824A2050 => {
    //   block [0x824A2050..0x824A206C)
	// 824A2050: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2054: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 824A2058: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824A205C: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 824A2060: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 824A2064: 5506103A  slwi r6, r8, 2
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 824A2068: 6167FFFF  ori r7, r11, 0xffff
	ctx.r[7].u64 = ctx.r[11].u64 | 65535;
	pc = 0x824A206C; continue 'dispatch;
            }
            0x824A206C => {
    //   block [0x824A206C..0x824A20A0)
	// 824A206C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2070: 7D66582E  lwzx r11, r6, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A2074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A2078: 409A004C  bne cr6, 0x824a20c4
	if !ctx.cr[6].eq {
	pc = 0x824A20C4; continue 'dispatch;
	}
	// 824A207C: A1430004  lhz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2080: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 824A2084: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 824A2088: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 824A208C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 824A2090: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A2094: B1430004  sth r10, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 824A2098: 4098002C  bge cr6, 0x824a20c4
	if !ctx.cr[6].lt {
	pc = 0x824A20C4; continue 'dispatch;
	}
	// 824A209C: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	pc = 0x824A20A0; continue 'dispatch;
            }
            0x824A20A0 => {
    //   block [0x824A20A0..0x824A20C4)
	// 824A20A0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A20A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A20A8: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824A20AC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824A20B0: 80A90004  lwz r5, 4(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A20B4: 90A90000  stw r5, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 824A20B8: A1230004  lhz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A20BC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A20C0: 4198FFE0  blt cr6, 0x824a20a0
	if ctx.cr[6].lt {
	pc = 0x824A20A0; continue 'dispatch;
	}
	pc = 0x824A20C4; continue 'dispatch;
            }
            0x824A20C4 => {
    //   block [0x824A20C4..0x824A20D8)
	// 824A20C4: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 824A20C8: 38C6FFFC  addi r6, r6, -4
	ctx.r[6].s64 = ctx.r[6].s64 + -4;
	// 824A20CC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824A20D0: 4098FF9C  bge cr6, 0x824a206c
	if !ctx.cr[6].lt {
	pc = 0x824A206C; continue 'dispatch;
	}
	// 824A20D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A20D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A20D8 size=220
    let mut pc: u32 = 0x824A20D8;
    'dispatch: loop {
        match pc {
            0x824A20D8 => {
    //   block [0x824A20D8..0x824A2118)
	// 824A20D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A20DC: 48092FCD  bl 0x825350a8
	ctx.lr = 0x824A20E0;
	sub_82535080(ctx, base);
	// 824A20E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A20E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824A20E8: 839B00CC  lwz r28, 0xcc(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(204 as u32) ) } as u64;
	// 824A20EC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 824A20F0: 419A00BC  beq cr6, 0x824a21ac
	if ctx.cr[6].eq {
	pc = 0x824A21AC; continue 'dispatch;
	}
	// 824A20F4: A17C000C  lhz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A20F8: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A20FC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A2100: 419800AC  blt cr6, 0x824a21ac
	if ctx.cr[6].lt {
	pc = 0x824A21AC; continue 'dispatch;
	}
	// 824A2104: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A2108: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A210C: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A2110: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A2114: 3B0B0580  addi r24, r11, 0x580
	ctx.r[24].s64 = ctx.r[11].s64 + 1408;
	pc = 0x824A2118; continue 'dispatch;
            }
            0x824A2118 => {
    //   block [0x824A2118..0x824A2158)
	// 824A2118: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A211C: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A2120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A2124: 419A0078  beq cr6, 0x824a219c
	if ctx.cr[6].eq {
	pc = 0x824A219C; continue 'dispatch;
	}
	// 824A2128: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A212C: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A2130: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A2134: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2138: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A213C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A2140: 40980018  bge cr6, 0x824a2158
	if !ctx.cr[6].lt {
	pc = 0x824A2158; continue 'dispatch;
	}
	// 824A2144: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A2148: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A214C: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A2150: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A2154: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A2158; continue 'dispatch;
            }
            0x824A2158 => {
    //   block [0x824A2158..0x824A219C)
	// 824A2158: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A215C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A2160: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A2164: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2168: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A216C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A2170: 4E800421  bctrl
	ctx.lr = 0x824A2174;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A2174: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A2178: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A217C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2180: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A2184: 40980018  bge cr6, 0x824a219c
	if !ctx.cr[6].lt {
	pc = 0x824A219C; continue 'dispatch;
	}
	// 824A2188: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A218C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A2190: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A2194: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A2198: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A219C => {
    //   block [0x824A219C..0x824A21AC)
	// 824A219C: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A21A0: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A21A4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A21A8: 4098FF70  bge cr6, 0x824a2118
	if !ctx.cr[6].lt {
	pc = 0x824A2118; continue 'dispatch;
	}
	pc = 0x824A21AC; continue 'dispatch;
            }
            0x824A21AC => {
    //   block [0x824A21AC..0x824A21B4)
	// 824A21AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A21B0: 48092F48  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A21B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A21B8 size=652
    let mut pc: u32 = 0x824A21B8;
    'dispatch: loop {
        match pc {
            0x824A21B8 => {
    //   block [0x824A21B8..0x824A21F8)
	// 824A21B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A21BC: 48092EED  bl 0x825350a8
	ctx.lr = 0x824A21C0;
	sub_82535080(ctx, base);
	// 824A21C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A21C4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 824A21C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A21CC: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A21D0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A21D4: 839A00CC  lwz r28, 0xcc(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(204 as u32) ) } as u64;
	// 824A21D8: 3B0B058C  addi r24, r11, 0x58c
	ctx.r[24].s64 = ctx.r[11].s64 + 1420;
	// 824A21DC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 824A21E0: 419A00AC  beq cr6, 0x824a228c
	if ctx.cr[6].eq {
	pc = 0x824A228C; continue 'dispatch;
	}
	// 824A21E4: A17C000C  lhz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A21E8: 3B6BFFFF  addi r27, r11, -1
	ctx.r[27].s64 = ctx.r[11].s64 + -1;
	// 824A21EC: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 824A21F0: 4198009C  blt cr6, 0x824a228c
	if ctx.cr[6].lt {
	pc = 0x824A228C; continue 'dispatch;
	}
	// 824A21F4: 577D103A  slwi r29, r27, 2
	ctx.r[29].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	pc = 0x824A21F8; continue 'dispatch;
            }
            0x824A21F8 => {
    //   block [0x824A21F8..0x824A2238)
	// 824A21F8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A21FC: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A2200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A2204: 419A0078  beq cr6, 0x824a227c
	if ctx.cr[6].eq {
	pc = 0x824A227C; continue 'dispatch;
	}
	// 824A2208: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A220C: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A2210: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A2214: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2218: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A221C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A2220: 40980018  bge cr6, 0x824a2238
	if !ctx.cr[6].lt {
	pc = 0x824A2238; continue 'dispatch;
	}
	// 824A2224: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A2228: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A222C: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A2230: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A2234: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A2238; continue 'dispatch;
            }
            0x824A2238 => {
    //   block [0x824A2238..0x824A227C)
	// 824A2238: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A223C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 824A2240: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A2244: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2248: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A224C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A2250: 4E800421  bctrl
	ctx.lr = 0x824A2254;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A2254: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A2258: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A225C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2260: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A2264: 40980018  bge cr6, 0x824a227c
	if !ctx.cr[6].lt {
	pc = 0x824A227C; continue 'dispatch;
	}
	// 824A2268: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A226C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A2270: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A2274: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A2278: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A227C => {
    //   block [0x824A227C..0x824A228C)
	// 824A227C: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 824A2280: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A2284: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 824A2288: 4098FF70  bge cr6, 0x824a21f8
	if !ctx.cr[6].lt {
	pc = 0x824A21F8; continue 'dispatch;
	}
	pc = 0x824A228C; continue 'dispatch;
            }
            0x824A228C => {
    //   block [0x824A228C..0x824A22A4)
	// 824A228C: 3BBA0098  addi r29, r26, 0x98
	ctx.r[29].s64 = ctx.r[26].s64 + 152;
	// 824A2290: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A2298: 419A0084  beq cr6, 0x824a231c
	if ctx.cr[6].eq {
	pc = 0x824A231C; continue 'dispatch;
	}
	// 824A229C: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A22A0: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	pc = 0x824A22A4; continue 'dispatch;
            }
            0x824A22A4 => {
    //   block [0x824A22A4..0x824A22CC)
	// 824A22A4: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A22A8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A22AC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A22B0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A22B4: 40980018  bge cr6, 0x824a22cc
	if !ctx.cr[6].lt {
	pc = 0x824A22CC; continue 'dispatch;
	}
	// 824A22B8: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A22BC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A22C0: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A22C4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A22C8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A22CC; continue 'dispatch;
            }
            0x824A22CC => {
    //   block [0x824A22CC..0x824A2310)
	// 824A22CC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A22D0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 824A22D4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A22D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A22DC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A22E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A22E4: 4E800421  bctrl
	ctx.lr = 0x824A22E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A22E8: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A22EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A22F0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A22F4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A22F8: 40980018  bge cr6, 0x824a2310
	if !ctx.cr[6].lt {
	pc = 0x824A2310; continue 'dispatch;
	}
	// 824A22FC: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A2300: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A2304: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A2308: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A230C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A2310 => {
    //   block [0x824A2310..0x824A231C)
	// 824A2310: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A2318: 409AFF8C  bne cr6, 0x824a22a4
	if !ctx.cr[6].eq {
	pc = 0x824A22A4; continue 'dispatch;
	}
	pc = 0x824A231C; continue 'dispatch;
            }
            0x824A231C => {
    //   block [0x824A231C..0x824A2334)
	// 824A231C: 3BBA00A0  addi r29, r26, 0xa0
	ctx.r[29].s64 = ctx.r[26].s64 + 160;
	// 824A2320: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2324: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A2328: 419A0084  beq cr6, 0x824a23ac
	if ctx.cr[6].eq {
	pc = 0x824A23AC; continue 'dispatch;
	}
	// 824A232C: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2330: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	pc = 0x824A2334; continue 'dispatch;
            }
            0x824A2334 => {
    //   block [0x824A2334..0x824A235C)
	// 824A2334: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A2338: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A233C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2340: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A2344: 40980018  bge cr6, 0x824a235c
	if !ctx.cr[6].lt {
	pc = 0x824A235C; continue 'dispatch;
	}
	// 824A2348: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A234C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A2350: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A2354: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A2358: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A235C; continue 'dispatch;
            }
            0x824A235C => {
    //   block [0x824A235C..0x824A23A0)
	// 824A235C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2360: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 824A2364: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2368: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A236C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A2370: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A2374: 4E800421  bctrl
	ctx.lr = 0x824A2378;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A2378: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A237C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2380: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2384: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A2388: 40980018  bge cr6, 0x824a23a0
	if !ctx.cr[6].lt {
	pc = 0x824A23A0; continue 'dispatch;
	}
	// 824A238C: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A2390: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A2394: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A2398: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A239C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A23A0 => {
    //   block [0x824A23A0..0x824A23AC)
	// 824A23A0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A23A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A23A8: 409AFF8C  bne cr6, 0x824a2334
	if !ctx.cr[6].eq {
	pc = 0x824A2334; continue 'dispatch;
	}
	pc = 0x824A23AC; continue 'dispatch;
            }
            0x824A23AC => {
    //   block [0x824A23AC..0x824A23C4)
	// 824A23AC: 3BBA01F8  addi r29, r26, 0x1f8
	ctx.r[29].s64 = ctx.r[26].s64 + 504;
	// 824A23B0: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A23B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A23B8: 419A0084  beq cr6, 0x824a243c
	if ctx.cr[6].eq {
	pc = 0x824A243C; continue 'dispatch;
	}
	// 824A23BC: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A23C0: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	pc = 0x824A23C4; continue 'dispatch;
            }
            0x824A23C4 => {
    //   block [0x824A23C4..0x824A23EC)
	// 824A23C4: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A23C8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A23CC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A23D0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A23D4: 40980018  bge cr6, 0x824a23ec
	if !ctx.cr[6].lt {
	pc = 0x824A23EC; continue 'dispatch;
	}
	// 824A23D8: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A23DC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A23E0: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A23E4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A23E8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A23EC; continue 'dispatch;
            }
            0x824A23EC => {
    //   block [0x824A23EC..0x824A2430)
	// 824A23EC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A23F0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 824A23F4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A23F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A23FC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A2400: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A2404: 4E800421  bctrl
	ctx.lr = 0x824A2408;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A2408: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A240C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2410: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2414: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A2418: 40980018  bge cr6, 0x824a2430
	if !ctx.cr[6].lt {
	pc = 0x824A2430; continue 'dispatch;
	}
	// 824A241C: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A2420: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A2424: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A2428: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A242C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A2430 => {
    //   block [0x824A2430..0x824A243C)
	// 824A2430: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A2438: 409AFF8C  bne cr6, 0x824a23c4
	if !ctx.cr[6].eq {
	pc = 0x824A23C4; continue 'dispatch;
	}
	pc = 0x824A243C; continue 'dispatch;
            }
            0x824A243C => {
    //   block [0x824A243C..0x824A2444)
	// 824A243C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A2440: 48092CB8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A2448 size=220
    let mut pc: u32 = 0x824A2448;
    'dispatch: loop {
        match pc {
            0x824A2448 => {
    //   block [0x824A2448..0x824A2488)
	// 824A2448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A244C: 48092C5D  bl 0x825350a8
	ctx.lr = 0x824A2450;
	sub_82535080(ctx, base);
	// 824A2450: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A2454: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824A2458: 839B00CC  lwz r28, 0xcc(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(204 as u32) ) } as u64;
	// 824A245C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 824A2460: 419A00BC  beq cr6, 0x824a251c
	if ctx.cr[6].eq {
	pc = 0x824A251C; continue 'dispatch;
	}
	// 824A2464: A17C000C  lhz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2468: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A246C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A2470: 419800AC  blt cr6, 0x824a251c
	if ctx.cr[6].lt {
	pc = 0x824A251C; continue 'dispatch;
	}
	// 824A2474: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A2478: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A247C: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A2480: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A2484: 3B0B0598  addi r24, r11, 0x598
	ctx.r[24].s64 = ctx.r[11].s64 + 1432;
	pc = 0x824A2488; continue 'dispatch;
            }
            0x824A2488 => {
    //   block [0x824A2488..0x824A24C8)
	// 824A2488: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A248C: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A2490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A2494: 419A0078  beq cr6, 0x824a250c
	if ctx.cr[6].eq {
	pc = 0x824A250C; continue 'dispatch;
	}
	// 824A2498: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A249C: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A24A0: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A24A4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A24A8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A24AC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A24B0: 40980018  bge cr6, 0x824a24c8
	if !ctx.cr[6].lt {
	pc = 0x824A24C8; continue 'dispatch;
	}
	// 824A24B4: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A24B8: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A24BC: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A24C0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A24C4: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A24C8; continue 'dispatch;
            }
            0x824A24C8 => {
    //   block [0x824A24C8..0x824A250C)
	// 824A24C8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A24CC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A24D0: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A24D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A24D8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A24DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A24E0: 4E800421  bctrl
	ctx.lr = 0x824A24E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A24E4: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A24E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A24EC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A24F0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A24F4: 40980018  bge cr6, 0x824a250c
	if !ctx.cr[6].lt {
	pc = 0x824A250C; continue 'dispatch;
	}
	// 824A24F8: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A24FC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A2500: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A2504: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A2508: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A250C => {
    //   block [0x824A250C..0x824A251C)
	// 824A250C: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A2510: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A2514: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A2518: 4098FF70  bge cr6, 0x824a2488
	if !ctx.cr[6].lt {
	pc = 0x824A2488; continue 'dispatch;
	}
	pc = 0x824A251C; continue 'dispatch;
            }
            0x824A251C => {
    //   block [0x824A251C..0x824A2524)
	// 824A251C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A2520: 48092BD8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A2528 size=220
    let mut pc: u32 = 0x824A2528;
    'dispatch: loop {
        match pc {
            0x824A2528 => {
    //   block [0x824A2528..0x824A2568)
	// 824A2528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A252C: 48092B7D  bl 0x825350a8
	ctx.lr = 0x824A2530;
	sub_82535080(ctx, base);
	// 824A2530: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A2534: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824A2538: 839B00CC  lwz r28, 0xcc(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(204 as u32) ) } as u64;
	// 824A253C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 824A2540: 419A00BC  beq cr6, 0x824a25fc
	if ctx.cr[6].eq {
	pc = 0x824A25FC; continue 'dispatch;
	}
	// 824A2544: A17C000C  lhz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2548: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A254C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A2550: 419800AC  blt cr6, 0x824a25fc
	if ctx.cr[6].lt {
	pc = 0x824A25FC; continue 'dispatch;
	}
	// 824A2554: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A2558: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A255C: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A2560: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A2564: 3B0B05A8  addi r24, r11, 0x5a8
	ctx.r[24].s64 = ctx.r[11].s64 + 1448;
	pc = 0x824A2568; continue 'dispatch;
            }
            0x824A2568 => {
    //   block [0x824A2568..0x824A25A8)
	// 824A2568: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A256C: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A2570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A2574: 419A0078  beq cr6, 0x824a25ec
	if ctx.cr[6].eq {
	pc = 0x824A25EC; continue 'dispatch;
	}
	// 824A2578: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A257C: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A2580: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A2584: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2588: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A258C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A2590: 40980018  bge cr6, 0x824a25a8
	if !ctx.cr[6].lt {
	pc = 0x824A25A8; continue 'dispatch;
	}
	// 824A2594: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A2598: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A259C: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A25A0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A25A4: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A25A8; continue 'dispatch;
            }
            0x824A25A8 => {
    //   block [0x824A25A8..0x824A25EC)
	// 824A25A8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A25AC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A25B0: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A25B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A25B8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A25BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A25C0: 4E800421  bctrl
	ctx.lr = 0x824A25C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A25C4: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A25C8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A25CC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A25D0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A25D4: 40980018  bge cr6, 0x824a25ec
	if !ctx.cr[6].lt {
	pc = 0x824A25EC; continue 'dispatch;
	}
	// 824A25D8: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A25DC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A25E0: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A25E4: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A25E8: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A25EC => {
    //   block [0x824A25EC..0x824A25FC)
	// 824A25EC: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A25F0: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A25F4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A25F8: 4098FF70  bge cr6, 0x824a2568
	if !ctx.cr[6].lt {
	pc = 0x824A2568; continue 'dispatch;
	}
	pc = 0x824A25FC; continue 'dispatch;
            }
            0x824A25FC => {
    //   block [0x824A25FC..0x824A2604)
	// 824A25FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A2600: 48092AF8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A2608 size=224
    let mut pc: u32 = 0x824A2608;
    'dispatch: loop {
        match pc {
            0x824A2608 => {
    //   block [0x824A2608..0x824A2644)
	// 824A2608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A260C: 48092A9D  bl 0x825350a8
	ctx.lr = 0x824A2610;
	sub_82535080(ctx, base);
	// 824A2610: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A2614: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A2618: 3B8301F0  addi r28, r3, 0x1f0
	ctx.r[28].s64 = ctx.r[3].s64 + 496;
	// 824A261C: 907B000C  stw r3, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 824A2620: A17C0004  lhz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2624: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A2628: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A262C: 419800AC  blt cr6, 0x824a26d8
	if ctx.cr[6].lt {
	pc = 0x824A26D8; continue 'dispatch;
	}
	// 824A2630: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A2634: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A2638: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A263C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A2640: 3B0B05B4  addi r24, r11, 0x5b4
	ctx.r[24].s64 = ctx.r[11].s64 + 1460;
	pc = 0x824A2644; continue 'dispatch;
            }
            0x824A2644 => {
    //   block [0x824A2644..0x824A2684)
	// 824A2644: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2648: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A264C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A2650: 419A0078  beq cr6, 0x824a26c8
	if ctx.cr[6].eq {
	pc = 0x824A26C8; continue 'dispatch;
	}
	// 824A2654: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2658: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A265C: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A2660: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2664: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2668: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A266C: 40980018  bge cr6, 0x824a2684
	if !ctx.cr[6].lt {
	pc = 0x824A2684; continue 'dispatch;
	}
	// 824A2670: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A2674: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A2678: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A267C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A2680: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A2684; continue 'dispatch;
            }
            0x824A2684 => {
    //   block [0x824A2684..0x824A26C8)
	// 824A2684: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2688: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A268C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A2690: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2694: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2698: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A269C: 4E800421  bctrl
	ctx.lr = 0x824A26A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A26A0: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A26A4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A26A8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A26AC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A26B0: 40980018  bge cr6, 0x824a26c8
	if !ctx.cr[6].lt {
	pc = 0x824A26C8; continue 'dispatch;
	}
	// 824A26B4: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A26B8: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A26BC: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A26C0: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A26C4: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A26C8 => {
    //   block [0x824A26C8..0x824A26D8)
	// 824A26C8: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A26CC: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A26D0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A26D4: 4098FF70  bge cr6, 0x824a2644
	if !ctx.cr[6].lt {
	pc = 0x824A2644; continue 'dispatch;
	}
	pc = 0x824A26D8; continue 'dispatch;
            }
            0x824A26D8 => {
    //   block [0x824A26D8..0x824A26E8)
	// 824A26D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A26DC: 4BFFF975  bl 0x824a2050
	ctx.lr = 0x824A26E0;
	sub_824A2050(ctx, base);
	// 824A26E0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A26E4: 48092A14  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A26E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A26E8 size=224
    let mut pc: u32 = 0x824A26E8;
    'dispatch: loop {
        match pc {
            0x824A26E8 => {
    //   block [0x824A26E8..0x824A2724)
	// 824A26E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A26EC: 480929BD  bl 0x825350a8
	ctx.lr = 0x824A26F0;
	sub_82535080(ctx, base);
	// 824A26F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A26F4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A26F8: 3B8301F0  addi r28, r3, 0x1f0
	ctx.r[28].s64 = ctx.r[3].s64 + 496;
	// 824A26FC: 907B0008  stw r3, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 824A2700: A17C0004  lhz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2704: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A2708: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A270C: 419800AC  blt cr6, 0x824a27b8
	if ctx.cr[6].lt {
	pc = 0x824A27B8; continue 'dispatch;
	}
	// 824A2710: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A2714: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A2718: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A271C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A2720: 3B0B05C0  addi r24, r11, 0x5c0
	ctx.r[24].s64 = ctx.r[11].s64 + 1472;
	pc = 0x824A2724; continue 'dispatch;
            }
            0x824A2724 => {
    //   block [0x824A2724..0x824A2764)
	// 824A2724: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2728: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A272C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A2730: 419A0078  beq cr6, 0x824a27a8
	if ctx.cr[6].eq {
	pc = 0x824A27A8; continue 'dispatch;
	}
	// 824A2734: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2738: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A273C: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A2740: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2744: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2748: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A274C: 40980018  bge cr6, 0x824a2764
	if !ctx.cr[6].lt {
	pc = 0x824A2764; continue 'dispatch;
	}
	// 824A2750: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A2754: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A2758: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A275C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A2760: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A2764; continue 'dispatch;
            }
            0x824A2764 => {
    //   block [0x824A2764..0x824A27A8)
	// 824A2764: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2768: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A276C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A2770: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2774: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2778: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A277C: 4E800421  bctrl
	ctx.lr = 0x824A2780;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A2780: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A2784: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2788: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A278C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A2790: 40980018  bge cr6, 0x824a27a8
	if !ctx.cr[6].lt {
	pc = 0x824A27A8; continue 'dispatch;
	}
	// 824A2794: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A2798: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A279C: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A27A0: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A27A4: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A27A8 => {
    //   block [0x824A27A8..0x824A27B8)
	// 824A27A8: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A27AC: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A27B0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A27B4: 4098FF70  bge cr6, 0x824a2724
	if !ctx.cr[6].lt {
	pc = 0x824A2724; continue 'dispatch;
	}
	pc = 0x824A27B8; continue 'dispatch;
            }
            0x824A27B8 => {
    //   block [0x824A27B8..0x824A27C8)
	// 824A27B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A27BC: 4BFFF895  bl 0x824a2050
	ctx.lr = 0x824A27C0;
	sub_824A2050(ctx, base);
	// 824A27C0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A27C4: 48092934  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A27C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A27C8 size=224
    let mut pc: u32 = 0x824A27C8;
    'dispatch: loop {
        match pc {
            0x824A27C8 => {
    //   block [0x824A27C8..0x824A2804)
	// 824A27C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A27CC: 480928DD  bl 0x825350a8
	ctx.lr = 0x824A27D0;
	sub_82535080(ctx, base);
	// 824A27D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A27D4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A27D8: 3B8301F0  addi r28, r3, 0x1f0
	ctx.r[28].s64 = ctx.r[3].s64 + 496;
	// 824A27DC: 907B0010  stw r3, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 824A27E0: A17C0004  lhz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A27E4: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A27E8: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A27EC: 419800AC  blt cr6, 0x824a2898
	if ctx.cr[6].lt {
	pc = 0x824A2898; continue 'dispatch;
	}
	// 824A27F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A27F4: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A27F8: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A27FC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A2800: 3B0B05CC  addi r24, r11, 0x5cc
	ctx.r[24].s64 = ctx.r[11].s64 + 1484;
	pc = 0x824A2804; continue 'dispatch;
            }
            0x824A2804 => {
    //   block [0x824A2804..0x824A2844)
	// 824A2804: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2808: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A280C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A2810: 419A0078  beq cr6, 0x824a2888
	if ctx.cr[6].eq {
	pc = 0x824A2888; continue 'dispatch;
	}
	// 824A2814: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2818: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A281C: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A2820: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2824: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2828: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A282C: 40980018  bge cr6, 0x824a2844
	if !ctx.cr[6].lt {
	pc = 0x824A2844; continue 'dispatch;
	}
	// 824A2830: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A2834: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A2838: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A283C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A2840: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A2844; continue 'dispatch;
            }
            0x824A2844 => {
    //   block [0x824A2844..0x824A2888)
	// 824A2844: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2848: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A284C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A2850: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2854: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2858: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A285C: 4E800421  bctrl
	ctx.lr = 0x824A2860;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A2860: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A2864: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2868: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A286C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A2870: 40980018  bge cr6, 0x824a2888
	if !ctx.cr[6].lt {
	pc = 0x824A2888; continue 'dispatch;
	}
	// 824A2874: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A2878: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A287C: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A2880: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A2884: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A2888 => {
    //   block [0x824A2888..0x824A2898)
	// 824A2888: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A288C: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A2890: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A2894: 4098FF70  bge cr6, 0x824a2804
	if !ctx.cr[6].lt {
	pc = 0x824A2804; continue 'dispatch;
	}
	pc = 0x824A2898; continue 'dispatch;
            }
            0x824A2898 => {
    //   block [0x824A2898..0x824A28A8)
	// 824A2898: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A289C: 4BFFF7B5  bl 0x824a2050
	ctx.lr = 0x824A28A0;
	sub_824A2050(ctx, base);
	// 824A28A0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A28A4: 48092854  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A28A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A28A8 size=224
    let mut pc: u32 = 0x824A28A8;
    'dispatch: loop {
        match pc {
            0x824A28A8 => {
    //   block [0x824A28A8..0x824A28E4)
	// 824A28A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A28AC: 480927FD  bl 0x825350a8
	ctx.lr = 0x824A28B0;
	sub_82535080(ctx, base);
	// 824A28B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A28B4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A28B8: 3B8301F0  addi r28, r3, 0x1f0
	ctx.r[28].s64 = ctx.r[3].s64 + 496;
	// 824A28BC: 907B0008  stw r3, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 824A28C0: A17C0004  lhz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A28C4: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A28C8: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A28CC: 419800AC  blt cr6, 0x824a2978
	if ctx.cr[6].lt {
	pc = 0x824A2978; continue 'dispatch;
	}
	// 824A28D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A28D4: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A28D8: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A28DC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A28E0: 3B0B05D8  addi r24, r11, 0x5d8
	ctx.r[24].s64 = ctx.r[11].s64 + 1496;
	pc = 0x824A28E4; continue 'dispatch;
            }
            0x824A28E4 => {
    //   block [0x824A28E4..0x824A2924)
	// 824A28E4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A28E8: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A28EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A28F0: 419A0078  beq cr6, 0x824a2968
	if ctx.cr[6].eq {
	pc = 0x824A2968; continue 'dispatch;
	}
	// 824A28F4: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A28F8: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A28FC: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A2900: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2904: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2908: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A290C: 40980018  bge cr6, 0x824a2924
	if !ctx.cr[6].lt {
	pc = 0x824A2924; continue 'dispatch;
	}
	// 824A2910: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A2914: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A2918: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A291C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A2920: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A2924; continue 'dispatch;
            }
            0x824A2924 => {
    //   block [0x824A2924..0x824A2968)
	// 824A2924: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2928: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A292C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A2930: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2934: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2938: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A293C: 4E800421  bctrl
	ctx.lr = 0x824A2940;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A2940: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A2944: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2948: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A294C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A2950: 40980018  bge cr6, 0x824a2968
	if !ctx.cr[6].lt {
	pc = 0x824A2968; continue 'dispatch;
	}
	// 824A2954: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A2958: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A295C: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A2960: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A2964: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A2968 => {
    //   block [0x824A2968..0x824A2978)
	// 824A2968: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A296C: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A2970: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A2974: 4098FF70  bge cr6, 0x824a28e4
	if !ctx.cr[6].lt {
	pc = 0x824A28E4; continue 'dispatch;
	}
	pc = 0x824A2978; continue 'dispatch;
            }
            0x824A2978 => {
    //   block [0x824A2978..0x824A2988)
	// 824A2978: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A297C: 4BFFF6D5  bl 0x824a2050
	ctx.lr = 0x824A2980;
	sub_824A2050(ctx, base);
	// 824A2980: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A2984: 48092774  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A2988 size=24
    let mut pc: u32 = 0x824A2988;
    'dispatch: loop {
        match pc {
            0x824A2988 => {
    //   block [0x824A2988..0x824A29A0)
	// 824A2988: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 824A298C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824A2990: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 824A2994: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 824A2998: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824A299C: 4BFC799C  b 0x8246a338
	sub_8246A338(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A29A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A29A8 size=8
    let mut pc: u32 = 0x824A29A8;
    'dispatch: loop {
        match pc {
            0x824A29A8 => {
    //   block [0x824A29A8..0x824A29B0)
	// 824A29A8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 824A29AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A29B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A29B0 size=144
    let mut pc: u32 = 0x824A29B0;
    'dispatch: loop {
        match pc {
            0x824A29B0 => {
    //   block [0x824A29B0..0x824A2A40)
	// 824A29B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824A29B4: 90850014  stw r4, 0x14(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	// 824A29B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824A29BC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824A29C0: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824A29C4: 91650010  stw r11, 0x10(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 824A29C8: 91450008  stw r10, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 824A29CC: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A29D0: 91250004  stw r9, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A29D4: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A29D8: 2B0A0016  cmplwi cr6, r10, 0x16
	ctx.cr[6].compare_u32(ctx.r[10].u32, 22 as u32, &mut ctx.xer);
	// 824A29DC: 409A0064  bne cr6, 0x824a2a40
	if !ctx.cr[6].eq {
		sub_824A2A40(ctx, base);
		return;
	}
	// 824A29E0: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A29E4: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 824A29E8: 7D680E70  srawi r8, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 824A29EC: 394A0003  addi r10, r10, 3
	ctx.r[10].s64 = ctx.r[10].s64 + 3;
	// 824A29F0: 1CE80070  mulli r7, r8, 0x70
	ctx.r[7].s32 = ((ctx.r[8].s32 as i64 * 112 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 824A29F4: 392B0002  addi r9, r11, 2
	ctx.r[9].s64 = ctx.r[11].s64 + 2;
	// 824A29F8: 390B0003  addi r8, r11, 3
	ctx.r[8].s64 = ctx.r[11].s64 + 3;
	// 824A29FC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 824A2A00: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A2A04: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824A2A08: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2A0C: 9105000C  stw r8, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 824A2A10: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A2A14: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 824A2A18: 394B0020  addi r10, r11, 0x20
	ctx.r[10].s64 = ctx.r[11].s64 + 32;
	// 824A2A1C: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A2A20: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824A2A24: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 824A2A28: 39690001  addi r11, r9, 1
	ctx.r[11].s64 = ctx.r[9].s64 + 1;
	// 824A2A2C: 91450004  stw r10, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824A2A30: 39280001  addi r9, r8, 1
	ctx.r[9].s64 = ctx.r[8].s64 + 1;
	// 824A2A34: 91650008  stw r11, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824A2A38: 9125000C  stw r9, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 824A2A3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A2A40 size=868
    let mut pc: u32 = 0x824A2A40;
    'dispatch: loop {
        match pc {
            0x824A2A40 => {
    //   block [0x824A2A40..0x824A2A4C)
	// 824A2A40: 7C6B2214  add r3, r11, r4
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 824A2A44: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 824A2A48: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	pc = 0x824A2A4C; continue 'dispatch;
            }
            0x824A2A4C => {
    //   block [0x824A2A4C..0x824A2A58)
	// 824A2A4C: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2A50: 2B0A001B  cmplwi cr6, r10, 0x1b
	ctx.cr[6].compare_u32(ctx.r[10].u32, 27 as u32, &mut ctx.xer);
	// 824A2A54: 41990344  bgt cr6, 0x824a2d98
	if ctx.cr[6].gt {
	pc = 0x824A2D98; continue 'dispatch;
	}
	pc = 0x824A2A58; continue 'dispatch;
            }
            0x824A2A58 => {
    //   block [0x824A2A58..0x824A2AE0)
	// 824A2A58: 3D80824A  lis r12, -0x7db6
	ctx.r[12].s64 = -2109079552;
	// 824A2A5C: 398C2A70  addi r12, r12, 0x2a70
	ctx.r[12].s64 = ctx.r[12].s64 + 10864;
	// 824A2A60: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 824A2A64: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 824A2A68: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 824A2A6C: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x824A2AE0; continue 'dispatch;
		},
		1 => {
	pc = 0x824A2DA0; continue 'dispatch;
		},
		2 => {
	pc = 0x824A2D84; continue 'dispatch;
		},
		3 => {
	pc = 0x824A2D94; continue 'dispatch;
		},
		4 => {
	pc = 0x824A2D8C; continue 'dispatch;
		},
		5 => {
	pc = 0x824A2AF8; continue 'dispatch;
		},
		6 => {
	pc = 0x824A2B24; continue 'dispatch;
		},
		7 => {
	pc = 0x824A2B50; continue 'dispatch;
		},
		8 => {
	pc = 0x824A2B7C; continue 'dispatch;
		},
		9 => {
	pc = 0x824A2B7C; continue 'dispatch;
		},
		10 => {
	pc = 0x824A2BA8; continue 'dispatch;
		},
		11 => {
	pc = 0x824A2BD4; continue 'dispatch;
		},
		12 => {
	pc = 0x824A2C00; continue 'dispatch;
		},
		13 => {
	pc = 0x824A2C2C; continue 'dispatch;
		},
		14 => {
	pc = 0x824A2C68; continue 'dispatch;
		},
		15 => {
	pc = 0x824A2C94; continue 'dispatch;
		},
		16 => {
	pc = 0x824A2C94; continue 'dispatch;
		},
		17 => {
	pc = 0x824A2CC0; continue 'dispatch;
		},
		18 => {
	pc = 0x824A2D00; continue 'dispatch;
		},
		19 => {
	pc = 0x824A2D2C; continue 'dispatch;
		},
		20 => {
	pc = 0x824A2D58; continue 'dispatch;
		},
		21 => {
	pc = 0x824A2D98; continue 'dispatch;
		},
		22 => {
	pc = 0x824A2D98; continue 'dispatch;
		},
		23 => {
	pc = 0x824A2DA0; continue 'dispatch;
		},
		24 => {
	pc = 0x824A2DA0; continue 'dispatch;
		},
		25 => {
	pc = 0x824A2DA0; continue 'dispatch;
		},
		26 => {
	pc = 0x824A2DA0; continue 'dispatch;
		},
		27 => {
	pc = 0x824A2DA0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 824A2A70: 824A2AE0  lwz r18, 0x2ae0(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10976 as u32) ) } as u64;
	// 824A2A74: 824A2DA0  lwz r18, 0x2da0(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11680 as u32) ) } as u64;
	// 824A2A78: 824A2D84  lwz r18, 0x2d84(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11652 as u32) ) } as u64;
	// 824A2A7C: 824A2D94  lwz r18, 0x2d94(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11668 as u32) ) } as u64;
	// 824A2A80: 824A2D8C  lwz r18, 0x2d8c(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11660 as u32) ) } as u64;
	// 824A2A84: 824A2AF8  lwz r18, 0x2af8(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11000 as u32) ) } as u64;
	// 824A2A88: 824A2B24  lwz r18, 0x2b24(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11044 as u32) ) } as u64;
	// 824A2A8C: 824A2B50  lwz r18, 0x2b50(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11088 as u32) ) } as u64;
	// 824A2A90: 824A2B7C  lwz r18, 0x2b7c(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11132 as u32) ) } as u64;
	// 824A2A94: 824A2B7C  lwz r18, 0x2b7c(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11132 as u32) ) } as u64;
	// 824A2A98: 824A2BA8  lwz r18, 0x2ba8(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11176 as u32) ) } as u64;
	// 824A2A9C: 824A2BD4  lwz r18, 0x2bd4(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11220 as u32) ) } as u64;
	// 824A2AA0: 824A2C00  lwz r18, 0x2c00(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11264 as u32) ) } as u64;
	// 824A2AA4: 824A2C2C  lwz r18, 0x2c2c(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11308 as u32) ) } as u64;
	// 824A2AA8: 824A2C68  lwz r18, 0x2c68(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11368 as u32) ) } as u64;
	// 824A2AAC: 824A2C94  lwz r18, 0x2c94(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11412 as u32) ) } as u64;
	// 824A2AB0: 824A2C94  lwz r18, 0x2c94(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11412 as u32) ) } as u64;
	// 824A2AB4: 824A2CC0  lwz r18, 0x2cc0(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11456 as u32) ) } as u64;
	// 824A2AB8: 824A2D00  lwz r18, 0x2d00(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11520 as u32) ) } as u64;
	// 824A2ABC: 824A2D2C  lwz r18, 0x2d2c(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11564 as u32) ) } as u64;
	// 824A2AC0: 824A2D58  lwz r18, 0x2d58(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11608 as u32) ) } as u64;
	// 824A2AC4: 824A2D98  lwz r18, 0x2d98(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11672 as u32) ) } as u64;
	// 824A2AC8: 824A2D98  lwz r18, 0x2d98(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11672 as u32) ) } as u64;
	// 824A2ACC: 824A2DA0  lwz r18, 0x2da0(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11680 as u32) ) } as u64;
	// 824A2AD0: 824A2DA0  lwz r18, 0x2da0(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11680 as u32) ) } as u64;
	// 824A2AD4: 824A2DA0  lwz r18, 0x2da0(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11680 as u32) ) } as u64;
	// 824A2AD8: 824A2DA0  lwz r18, 0x2da0(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11680 as u32) ) } as u64;
	// 824A2ADC: 824A2DA0  lwz r18, 0x2da0(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11680 as u32) ) } as u64;
            }
            0x824A2AE0 => {
    //   block [0x824A2AE0..0x824A2AF8)
	// 824A2AE0: 396B000F  addi r11, r11, 0xf
	ctx.r[11].s64 = ctx.r[11].s64 + 15;
	// 824A2AE4: 556B0036  rlwinm r11, r11, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A2AE8: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2AEC: 2B0A001B  cmplwi cr6, r10, 0x1b
	ctx.cr[6].compare_u32(ctx.r[10].u32, 27 as u32, &mut ctx.xer);
	// 824A2AF0: 4099FF68  ble cr6, 0x824a2a58
	if !ctx.cr[6].gt {
	pc = 0x824A2A58; continue 'dispatch;
	}
	// 824A2AF4: 480002A4  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2AF8 => {
    //   block [0x824A2AF8..0x824A2B24)
	// 824A2AF8: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2AFC: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 824A2B00: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2B04: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2B08: 39080090  addi r8, r8, 0x90
	ctx.r[8].s64 = ctx.r[8].s64 + 144;
	// 824A2B0C: 39290003  addi r9, r9, 3
	ctx.r[9].s64 = ctx.r[9].s64 + 3;
	// 824A2B10: 394A0003  addi r10, r10, 3
	ctx.r[10].s64 = ctx.r[10].s64 + 3;
	// 824A2B14: 91050004  stw r8, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A2B18: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2B1C: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A2B20: 48000278  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2B24 => {
    //   block [0x824A2B24..0x824A2B50)
	// 824A2B24: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2B28: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824A2B2C: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2B30: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2B34: 39080030  addi r8, r8, 0x30
	ctx.r[8].s64 = ctx.r[8].s64 + 48;
	// 824A2B38: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 824A2B3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824A2B40: 91050004  stw r8, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A2B44: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2B48: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A2B4C: 4800024C  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2B50 => {
    //   block [0x824A2B50..0x824A2B7C)
	// 824A2B50: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2B54: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824A2B58: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2B5C: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2B60: 39080030  addi r8, r8, 0x30
	ctx.r[8].s64 = ctx.r[8].s64 + 48;
	// 824A2B64: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 824A2B68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824A2B6C: 91050004  stw r8, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A2B70: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2B74: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A2B78: 48000220  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2B7C => {
    //   block [0x824A2B7C..0x824A2BA8)
	// 824A2B7C: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2B80: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 824A2B84: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2B88: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2B8C: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 824A2B90: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 824A2B94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824A2B98: 91050004  stw r8, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A2B9C: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2BA0: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A2BA4: 480001F4  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2BA8 => {
    //   block [0x824A2BA8..0x824A2BD4)
	// 824A2BA8: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2BAC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824A2BB0: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2BB4: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2BB8: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 824A2BBC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 824A2BC0: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 824A2BC4: 91050004  stw r8, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A2BC8: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2BCC: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A2BD0: 480001C8  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2BD4 => {
    //   block [0x824A2BD4..0x824A2C00)
	// 824A2BD4: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2BD8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 824A2BDC: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2BE0: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2BE4: 39080050  addi r8, r8, 0x50
	ctx.r[8].s64 = ctx.r[8].s64 + 80;
	// 824A2BE8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 824A2BEC: 394A0003  addi r10, r10, 3
	ctx.r[10].s64 = ctx.r[10].s64 + 3;
	// 824A2BF0: 91050004  stw r8, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A2BF4: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2BF8: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A2BFC: 4800019C  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2C00 => {
    //   block [0x824A2C00..0x824A2C2C)
	// 824A2C00: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2C04: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824A2C08: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2C0C: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2C10: 39080060  addi r8, r8, 0x60
	ctx.r[8].s64 = ctx.r[8].s64 + 96;
	// 824A2C14: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 824A2C18: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 824A2C1C: 91050004  stw r8, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A2C20: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2C24: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A2C28: 48000170  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2C2C => {
    //   block [0x824A2C2C..0x824A2C68)
	// 824A2C2C: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 824A2C30: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824A2C34: 8105000C  lwz r8, 0xc(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2C38: 5547083E  rotlwi r7, r10, 1
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 824A2C3C: 80C50004  lwz r6, 4(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2C40: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2C44: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824A2C48: 7CEA3A14  add r7, r10, r7
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 824A2C4C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 824A2C50: 54E72036  slwi r7, r7, 4
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 824A2C54: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 824A2C58: 9105000C  stw r8, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 824A2C5C: 91450008  stw r10, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 824A2C60: 90E50004  stw r7, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 824A2C64: 48000134  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2C68 => {
    //   block [0x824A2C68..0x824A2C94)
	// 824A2C68: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2C6C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 824A2C70: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2C74: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2C78: 39080030  addi r8, r8, 0x30
	ctx.r[8].s64 = ctx.r[8].s64 + 48;
	// 824A2C7C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 824A2C80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824A2C84: 91050004  stw r8, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A2C88: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2C8C: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A2C90: 48000108  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2C94 => {
    //   block [0x824A2C94..0x824A2CC0)
	// 824A2C94: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2C98: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 824A2C9C: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2CA0: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2CA4: 39080030  addi r8, r8, 0x30
	ctx.r[8].s64 = ctx.r[8].s64 + 48;
	// 824A2CA8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 824A2CAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824A2CB0: 91050004  stw r8, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A2CB4: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2CB8: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A2CBC: 480000DC  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2CC0 => {
    //   block [0x824A2CC0..0x824A2D00)
	// 824A2CC0: 894B0004  lbz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2CC4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 824A2CC8: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2CCC: 5546083E  rotlwi r6, r10, 1
	ctx.r[6].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 824A2CD0: 81050008  lwz r8, 8(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2CD4: 80E5000C  lwz r7, 0xc(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2CD8: 5549083E  rotlwi r9, r10, 1
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 824A2CDC: 7CCA3214  add r6, r10, r6
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 824A2CE0: 7D274A14  add r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 824A2CE4: 54C62036  slwi r6, r6, 4
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 824A2CE8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824A2CEC: 7CC62214  add r6, r6, r4
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[4].u64;
	// 824A2CF0: 9125000C  stw r9, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 824A2CF4: 91450008  stw r10, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 824A2CF8: 90C50004  stw r6, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 824A2CFC: 4800009C  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2D00 => {
    //   block [0x824A2D00..0x824A2D2C)
	// 824A2D00: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2D04: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 824A2D08: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2D0C: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2D10: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 824A2D14: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 824A2D18: 394A0003  addi r10, r10, 3
	ctx.r[10].s64 = ctx.r[10].s64 + 3;
	// 824A2D1C: 91050004  stw r8, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A2D20: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2D24: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A2D28: 48000070  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2D2C => {
    //   block [0x824A2D2C..0x824A2D58)
	// 824A2D2C: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2D30: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 824A2D34: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2D38: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2D3C: 390800C0  addi r8, r8, 0xc0
	ctx.r[8].s64 = ctx.r[8].s64 + 192;
	// 824A2D40: 39290003  addi r9, r9, 3
	ctx.r[9].s64 = ctx.r[9].s64 + 3;
	// 824A2D44: 394A0009  addi r10, r10, 9
	ctx.r[10].s64 = ctx.r[10].s64 + 9;
	// 824A2D48: 91050004  stw r8, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A2D4C: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2D50: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A2D54: 48000044  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2D58 => {
    //   block [0x824A2D58..0x824A2D84)
	// 824A2D58: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A2D5C: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 824A2D60: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A2D64: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A2D68: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 824A2D6C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 824A2D70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824A2D74: 91050004  stw r8, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A2D78: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2D7C: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824A2D80: 48000018  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2D84 => {
    //   block [0x824A2D84..0x824A2D8C)
	// 824A2D84: 396B0090  addi r11, r11, 0x90
	ctx.r[11].s64 = ctx.r[11].s64 + 144;
	// 824A2D88: 48000010  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2D8C => {
    //   block [0x824A2D8C..0x824A2D94)
	// 824A2D8C: 396B0070  addi r11, r11, 0x70
	ctx.r[11].s64 = ctx.r[11].s64 + 112;
	// 824A2D90: 48000008  b 0x824a2d98
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2D94 => {
    //   block [0x824A2D94..0x824A2D98)
	// 824A2D94: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	pc = 0x824A2D98; continue 'dispatch;
            }
            0x824A2D98 => {
    //   block [0x824A2D98..0x824A2DA0)
	// 824A2D98: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 824A2D9C: 4198FCB0  blt cr6, 0x824a2a4c
	if ctx.cr[6].lt {
	pc = 0x824A2A4C; continue 'dispatch;
	}
	pc = 0x824A2DA0; continue 'dispatch;
            }
            0x824A2DA0 => {
    //   block [0x824A2DA0..0x824A2DA4)
	// 824A2DA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A2DA8 size=16
    let mut pc: u32 = 0x824A2DA8;
    'dispatch: loop {
        match pc {
            0x824A2DA8 => {
    //   block [0x824A2DA8..0x824A2DB8)
	// 824A2DA8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824A2DAC: 38800070  li r4, 0x70
	ctx.r[4].s64 = 112;
	// 824A2DB0: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 824A2DB4: 4BFFFBFC  b 0x824a29b0
	sub_824A29B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A2DB8 size=32
    let mut pc: u32 = 0x824A2DB8;
    'dispatch: loop {
        match pc {
            0x824A2DB8 => {
    //   block [0x824A2DB8..0x824A2DD8)
	// 824A2DB8: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 824A2DBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A2DC0: 419A0018  beq cr6, 0x824a2dd8
	if ctx.cr[6].eq {
		sub_824A2DD8(ctx, base);
		return;
	}
	// 824A2DC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A2DC8: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 824A2DCC: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A2DD0: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824A2DD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A2DD8 size=16
    let mut pc: u32 = 0x824A2DD8;
    'dispatch: loop {
        match pc {
            0x824A2DD8 => {
    //   block [0x824A2DD8..0x824A2DE8)
	// 824A2DD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A2DDC: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A2DE0: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A2DE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824A2DE8 size=48
    let mut pc: u32 = 0x824A2DE8;
    'dispatch: loop {
        match pc {
            0x824A2DE8 => {
    //   block [0x824A2DE8..0x824A2E0C)
	// 824A2DE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A2DEC: C1A40070  lfs f13, 0x70(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A2DF0: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A2DF4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824A2DF8: 40990014  ble cr6, 0x824a2e0c
	if !ctx.cr[6].gt {
	pc = 0x824A2E0C; continue 'dispatch;
	}
	// 824A2DFC: C1A40074  lfs f13, 0x74(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A2E00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A2E04: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824A2E08: 41990008  bgt cr6, 0x824a2e10
	if ctx.cr[6].gt {
	pc = 0x824A2E10; continue 'dispatch;
	}
	pc = 0x824A2E0C; continue 'dispatch;
            }
            0x824A2E0C => {
    //   block [0x824A2E0C..0x824A2E10)
	// 824A2E0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824A2E10; continue 'dispatch;
            }
            0x824A2E10 => {
    //   block [0x824A2E10..0x824A2E18)
	// 824A2E10: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824A2E14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A2E18 size=8
    let mut pc: u32 = 0x824A2E18;
    'dispatch: loop {
        match pc {
            0x824A2E18 => {
    //   block [0x824A2E18..0x824A2E20)
	// 824A2E18: 3860000F  li r3, 0xf
	ctx.r[3].s64 = 15;
	// 824A2E1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824A2E20 size=136
    let mut pc: u32 = 0x824A2E20;
    'dispatch: loop {
        match pc {
            0x824A2E20 => {
    //   block [0x824A2E20..0x824A2EA8)
	// 824A2E20: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 824A2E24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A2E28: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 824A2E2C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 824A2E30: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 824A2E34: C1AA1850  lfs f13, 0x1850(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A2E38: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824A2E3C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A2E40: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	// 824A2E44: 390ACDE0  addi r8, r10, -0x3220
	ctx.r[8].s64 = ctx.r[10].s64 + -12832;
	// 824A2E48: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824A2E4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824A2E50: 39230050  addi r9, r3, 0x50
	ctx.r[9].s64 = ctx.r[3].s64 + 80;
	// 824A2E54: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824A2E58: 39030060  addi r8, r3, 0x60
	ctx.r[8].s64 = ctx.r[3].s64 + 96;
	// 824A2E5C: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824A2E60: 39430030  addi r10, r3, 0x30
	ctx.r[10].s64 = ctx.r[3].s64 + 48;
	// 824A2E64: B0E30010  sth r7, 0x10(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u16 ) };
	// 824A2E68: B0C30040  sth r6, 0x40(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[6].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A2EA8 size=16
    let mut pc: u32 = 0x824A2EA8;
    'dispatch: loop {
        match pc {
            0x824A2EA8 => {
    //   block [0x824A2EA8..0x824A2EB8)
	// 824A2EA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A2EAC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A2EB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A2EB4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A2EB8 size=20
    let mut pc: u32 = 0x824A2EB8;
    'dispatch: loop {
        match pc {
            0x824A2EB8 => {
    //   block [0x824A2EB8..0x824A2ECC)
	// 824A2EB8: 3D60824A  lis r11, -0x7db6
	ctx.r[11].s64 = -2109079552;
	// 824A2EBC: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 824A2EC0: 396B2EA8  addi r11, r11, 0x2ea8
	ctx.r[11].s64 = ctx.r[11].s64 + 11944;
	// 824A2EC4: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A2EC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A2ED0 size=156
    let mut pc: u32 = 0x824A2ED0;
    'dispatch: loop {
        match pc {
            0x824A2ED0 => {
    //   block [0x824A2ED0..0x824A2F6C)
	// 824A2ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A2ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A2ED8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A2EDC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 824A2EE0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A2EE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824A2EE8: C1A50040  lfs f13, 0x40(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A2EEC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 824A2EF0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 824A2EF4: 38650010  addi r3, r5, 0x10
	ctx.r[3].s64 = ctx.r[5].s64 + 16;
	// 824A2EF8: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 824A2EFC: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A2F00: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824A2F04: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A2F70 size=4
    let mut pc: u32 = 0x824A2F70;
    'dispatch: loop {
        match pc {
            0x824A2F70 => {
    //   block [0x824A2F70..0x824A2F74)
	// 824A2F70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A2F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824A2F78 size=224
    let mut pc: u32 = 0x824A2F78;
    'dispatch: loop {
        match pc {
            0x824A2F78 => {
    //   block [0x824A2F78..0x824A3058)
	// 824A2F78: 38C1FFF0  addi r6, r1, -0x10
	ctx.r[6].s64 = ctx.r[1].s64 + -16;
	// 824A2F7C: C0030020  lfs f0, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A2F80: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 824A2F84: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 824A2F88: 3D40829A  lis r10, -0x7d66
	ctx.r[10].s64 = -2103836672;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A3058 size=32
    let mut pc: u32 = 0x824A3058;
    'dispatch: loop {
        match pc {
            0x824A3058 => {
    //   block [0x824A3058..0x824A3078)
	// 824A3058: 89630009  lbz r11, 9(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(9 as u32) ) } as u64;
	// 824A305C: 89430008  lbz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A3060: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 824A3064: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824A3068: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 824A306C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A3070: 9963000A  stb r11, 0xa(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(10 as u32), ctx.r[11].u8 ) };
	// 824A3074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A3078 size=60
    let mut pc: u32 = 0x824A3078;
    'dispatch: loop {
        match pc {
            0x824A3078 => {
    //   block [0x824A3078..0x824A30B4)
	// 824A3078: 3D60829A  lis r11, -0x7d66
	ctx.r[11].s64 = -2103836672;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A30B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A30B8 size=68
    let mut pc: u32 = 0x824A30B8;
    'dispatch: loop {
        match pc {
            0x824A30B8 => {
    //   block [0x824A30B8..0x824A30FC)
	// 824A30B8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A3100 size=68
    let mut pc: u32 = 0x824A3100;
    'dispatch: loop {
        match pc {
            0x824A3100 => {
    //   block [0x824A3100..0x824A3144)
	// 824A3100: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A3148 size=148
    let mut pc: u32 = 0x824A3148;
    'dispatch: loop {
        match pc {
            0x824A3148 => {
    //   block [0x824A3148..0x824A3160)
	// 824A3148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A314C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A3150: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A3154: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A3158: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824A315C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x824A3160; continue 'dispatch;
            }
            0x824A3160 => {
    //   block [0x824A3160..0x824A3178)
	// 824A3160: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A3164: 2B0B0017  cmplwi cr6, r11, 0x17
	ctx.cr[6].compare_u32(ctx.r[11].u32, 23 as u32, &mut ctx.xer);
	// 824A3168: 41980010  blt cr6, 0x824a3178
	if ctx.cr[6].lt {
	pc = 0x824A3178; continue 'dispatch;
	}
	// 824A316C: A0830012  lhz r4, 0x12(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(18 as u32) ) } as u64;
	// 824A3170: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A3174: 4BFFFFEC  b 0x824a3160
	pc = 0x824A3160; continue 'dispatch;
            }
            0x824A3178 => {
    //   block [0x824A3178..0x824A31C4)
	// 824A3178: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A317C: 2B0B0016  cmplwi cr6, r11, 0x16
	ctx.cr[6].compare_u32(ctx.r[11].u32, 22 as u32, &mut ctx.xer);
	// 824A3180: 419A0044  beq cr6, 0x824a31c4
	if ctx.cr[6].eq {
	pc = 0x824A31C4; continue 'dispatch;
	}
	// 824A3184: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 824A3188: 419A003C  beq cr6, 0x824a31c4
	if ctx.cr[6].eq {
	pc = 0x824A31C4; continue 'dispatch;
	}
	// 824A318C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824A3190: 4BFFF821  bl 0x824a29b0
	ctx.lr = 0x824A3194;
	sub_824A29B0(ctx, base);
	// 824A3194: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A3198: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 824A319C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A31A0: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 824A31A4: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A31A8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A31AC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 824A31B0: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A31B4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 824A31B8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824A31BC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 824A31C0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x824A31C4; continue 'dispatch;
            }
            0x824A31C4 => {
    //   block [0x824A31C4..0x824A31DC)
	// 824A31C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824A31C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824A31CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A31D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A31D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A31D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A31E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A31E0 size=96
    let mut pc: u32 = 0x824A31E0;
    'dispatch: loop {
        match pc {
            0x824A31E0 => {
    //   block [0x824A31E0..0x824A3224)
	// 824A31E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824A31E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824A31E8: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A31EC: 394AFFE9  addi r10, r10, -0x17
	ctx.r[10].s64 = ctx.r[10].s64 + -23;
	// 824A31F0: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 824A31F4: 41990034  bgt cr6, 0x824a3228
	if ctx.cr[6].gt {
	pc = 0x824A3228; continue 'dispatch;
	}
	// 824A31F8: 3D80824A  lis r12, -0x7db6
	ctx.r[12].s64 = -2109079552;
	// 824A31FC: 398C3210  addi r12, r12, 0x3210
	ctx.r[12].s64 = ctx.r[12].s64 + 12816;
	// 824A3200: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 824A3204: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 824A3208: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 824A320C: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x824A3224; continue 'dispatch;
		},
		1 => {
	pc = 0x824A322C; continue 'dispatch;
		},
		2 => {
	pc = 0x824A3224; continue 'dispatch;
		},
		3 => {
	pc = 0x824A322C; continue 'dispatch;
		},
		4 => {
	pc = 0x824A323C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 824A3210: 824A3224  lwz r18, 0x3224(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12836 as u32) ) } as u64;
	// 824A3214: 824A322C  lwz r18, 0x322c(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12844 as u32) ) } as u64;
	// 824A3218: 824A3224  lwz r18, 0x3224(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12836 as u32) ) } as u64;
	// 824A321C: 824A322C  lwz r18, 0x322c(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12844 as u32) ) } as u64;
	// 824A3220: 824A323C  lwz r18, 0x323c(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12860 as u32) ) } as u64;
            }
            0x824A3224 => {
    //   block [0x824A3224..0x824A3228)
	// 824A3224: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	pc = 0x824A3228; continue 'dispatch;
            }
            0x824A3228 => {
    //   block [0x824A3228..0x824A322C)
	// 824A3228: 4E800020  blr
	return;
            }
            0x824A322C => {
    //   block [0x824A322C..0x824A323C)
	// 824A322C: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A3230: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 824A3234: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A3238: 4E800020  blr
	return;
            }
            0x824A323C => {
    //   block [0x824A323C..0x824A3240)
	// 824A323C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A3248 size=172
    let mut pc: u32 = 0x824A3248;
    'dispatch: loop {
        match pc {
            0x824A3248 => {
    //   block [0x824A3248..0x824A3260)
	// 824A3248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A324C: 48091E71  bl 0x825350bc
	ctx.lr = 0x824A3250;
	sub_82535080(ctx, base);
	// 824A3250: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A3254: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A3258: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824A325C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x824A3260; continue 'dispatch;
            }
            0x824A3260 => {
    //   block [0x824A3260..0x824A32A8)
	// 824A3260: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A3264: 2B0B0017  cmplwi cr6, r11, 0x17
	ctx.cr[6].compare_u32(ctx.r[11].u32, 23 as u32, &mut ctx.xer);
	// 824A3268: 41980080  blt cr6, 0x824a32e8
	if ctx.cr[6].lt {
	pc = 0x824A32E8; continue 'dispatch;
	}
	// 824A326C: 396BFFE9  addi r11, r11, -0x17
	ctx.r[11].s64 = ctx.r[11].s64 + -23;
	// 824A3270: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824A3274: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 824A3278: 41990064  bgt cr6, 0x824a32dc
	if ctx.cr[6].gt {
	pc = 0x824A32DC; continue 'dispatch;
	}
	// 824A327C: 3D80824A  lis r12, -0x7db6
	ctx.r[12].s64 = -2109079552;
	// 824A3280: 398C3294  addi r12, r12, 0x3294
	ctx.r[12].s64 = ctx.r[12].s64 + 12948;
	// 824A3284: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 824A3288: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 824A328C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 824A3290: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x824A32A8; continue 'dispatch;
		},
		1 => {
	pc = 0x824A32B8; continue 'dispatch;
		},
		2 => {
	pc = 0x824A32A8; continue 'dispatch;
		},
		3 => {
	pc = 0x824A32B8; continue 'dispatch;
		},
		4 => {
	pc = 0x824A32D0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 824A3294: 824A32A8  lwz r18, 0x32a8(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12968 as u32) ) } as u64;
	// 824A3298: 824A32B8  lwz r18, 0x32b8(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12984 as u32) ) } as u64;
	// 824A329C: 824A32A8  lwz r18, 0x32a8(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12968 as u32) ) } as u64;
	// 824A32A0: 824A32B8  lwz r18, 0x32b8(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12984 as u32) ) } as u64;
	// 824A32A4: 824A32D0  lwz r18, 0x32d0(r10)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(13008 as u32) ) } as u64;
            }
            0x824A32A8 => {
    //   block [0x824A32A8..0x824A32B8)
	// 824A32A8: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 824A32AC: 83FF0014  lwz r31, 0x14(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A32B0: 7C7DEB78  or r29, r3, r29
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[29].u64;
	// 824A32B4: 4BFFFFAC  b 0x824a3260
	pc = 0x824A3260; continue 'dispatch;
            }
            0x824A32B8 => {
    //   block [0x824A32B8..0x824A32D0)
	// 824A32B8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A32BC: 7C7DEB78  or r29, r3, r29
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[29].u64;
	// 824A32C0: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 824A32C4: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A32C8: 83FF0014  lwz r31, 0x14(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A32CC: 4BFFFF94  b 0x824a3260
	pc = 0x824A3260; continue 'dispatch;
            }
            0x824A32D0 => {
    //   block [0x824A32D0..0x824A32DC)
	// 824A32D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824A32D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A32D8: 4BFFFE71  bl 0x824a3148
	ctx.lr = 0x824A32DC;
	sub_824A3148(ctx, base);
	pc = 0x824A32DC; continue 'dispatch;
            }
            0x824A32DC => {
    //   block [0x824A32DC..0x824A32E8)
	// 824A32DC: 83FF0014  lwz r31, 0x14(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A32E0: 7C7DEB78  or r29, r3, r29
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[29].u64;
	// 824A32E4: 4BFFFF7C  b 0x824a3260
	pc = 0x824A3260; continue 'dispatch;
            }
            0x824A32E8 => {
    //   block [0x824A32E8..0x824A32F4)
	// 824A32E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824A32EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A32F0: 48091E1C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A32F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A32F8 size=200
    let mut pc: u32 = 0x824A32F8;
    'dispatch: loop {
        match pc {
            0x824A32F8 => {
    //   block [0x824A32F8..0x824A33C0)
	// 824A32F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A32FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A3300: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A3304: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A3308: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A330C: 48092F4D  bl 0x82536258
	ctx.lr = 0x824A3310;
	sub_82536258(ctx, base);
	// 824A3310: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 824A3314: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 824A3318: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824A331C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 824A3320: 397F0140  addi r11, r31, 0x140
	ctx.r[11].s64 = ctx.r[31].s64 + 320;
	// 824A3324: 395F0150  addi r10, r31, 0x150
	ctx.r[10].s64 = ctx.r[31].s64 + 336;
	// 824A3328: 38E00100  li r7, 0x100
	ctx.r[7].s64 = 256;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A33C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A33C0 size=16
    let mut pc: u32 = 0x824A33C0;
    'dispatch: loop {
        match pc {
            0x824A33C0 => {
    //   block [0x824A33C0..0x824A33D0)
	// 824A33C0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824A33C4: 38800124  li r4, 0x124
	ctx.r[4].s64 = 292;
	// 824A33C8: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 824A33CC: 4BFFF5E4  b 0x824a29b0
	sub_824A29B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A33D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A33D0 size=32
    let mut pc: u32 = 0x824A33D0;
    'dispatch: loop {
        match pc {
            0x824A33D0 => {
    //   block [0x824A33D0..0x824A33F0)
	// 824A33D0: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 824A33D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A33D8: 419A0018  beq cr6, 0x824a33f0
	if ctx.cr[6].eq {
		sub_824A33F0(ctx, base);
		return;
	}
	// 824A33DC: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 824A33E0: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 824A33E4: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A33E8: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824A33EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A33F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A33F0 size=16
    let mut pc: u32 = 0x824A33F0;
    'dispatch: loop {
        match pc {
            0x824A33F0 => {
    //   block [0x824A33F0..0x824A3400)
	// 824A33F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A33F4: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A33F8: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A33FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A3400 size=8
    let mut pc: u32 = 0x824A3400;
    'dispatch: loop {
        match pc {
            0x824A3400 => {
    //   block [0x824A3400..0x824A3408)
	// 824A3400: 38600009  li r3, 9
	ctx.r[3].s64 = 9;
	// 824A3404: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A3408 size=904
    let mut pc: u32 = 0x824A3408;
    'dispatch: loop {
        match pc {
            0x824A3408 => {
    //   block [0x824A3408..0x824A3790)
	// 824A3408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A340C: 48091C91  bl 0x8253509c
	ctx.lr = 0x824A3410;
	sub_82535080(ctx, base);
	// 824A3410: 3B200030  li r25, 0x30
	ctx.r[25].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A3790 size=736
    let mut pc: u32 = 0x824A3790;
    'dispatch: loop {
        match pc {
            0x824A3790 => {
    //   block [0x824A3790..0x824A3A70)
	// 824A3790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A3794: 4809191D  bl 0x825350b0
	ctx.lr = 0x824A3798;
	sub_82535080(ctx, base);
	// 824A3798: 3961FFB0  addi r11, r1, -0x50
	ctx.r[11].s64 = ctx.r[1].s64 + -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A3A70 size=332
    let mut pc: u32 = 0x824A3A70;
    'dispatch: loop {
        match pc {
            0x824A3A70 => {
    //   block [0x824A3A70..0x824A3BBC)
	// 824A3A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A3A74: 48091641  bl 0x825350b4
	ctx.lr = 0x824A3A78;
	sub_82535080(ctx, base);
	// 824A3A78: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 824A3A7C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A3A80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 824A3A84: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824A3A88: 396B9F50  addi r11, r11, -0x60b0
	ctx.r[11].s64 = ctx.r[11].s64 + -24752;
	// 824A3A8C: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 824A3A90: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 824A3A94: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 824A3A98: 397F00D0  addi r11, r31, 0xd0
	ctx.r[11].s64 = ctx.r[31].s64 + 208;
	// 824A3A9C: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 824A3AA0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824A3AA4: EB890000  ld r28, 0(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 824A3AA8: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 824A3AAC: EB680000  ld r27, 0(r8)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 824A3AB0: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A3BC0 size=416
    let mut pc: u32 = 0x824A3BC0;
    'dispatch: loop {
        match pc {
            0x824A3BC0 => {
    //   block [0x824A3BC0..0x824A3C3C)
	// 824A3BC0: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 824A3BC4: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 824A3BC8: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824A3BCC: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 824A3BD0: 394AD854  addi r10, r10, -0x27ac
	ctx.r[10].s64 = ctx.r[10].s64 + -10156;
	// 824A3BD4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824A3BD8: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 824A3BDC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 824A3BE0: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 824A3BE4: B3E30006  sth r31, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[31].u16 ) };
	// 824A3BE8: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 824A3BEC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824A3BF0: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 824A3BF4: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 824A3BF8: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 824A3BFC: B08B0000  sth r4, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u16 ) };
	// 824A3C00: 3BC0000C  li r30, 0xc
	ctx.r[30].s64 = 12;
	// 824A3C04: B10B0090  sth r8, 0x90(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[8].u16 ) };
	// 824A3C08: 394B00B0  addi r10, r11, 0xb0
	ctx.r[10].s64 = ctx.r[11].s64 + 176;
	// 824A3C0C: B0EB009C  sth r7, 0x9c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[7].u16 ) };
	// 824A3C10: B12B00A8  sth r9, 0xa8(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), ctx.r[9].u16 ) };
	// 824A3C14: 7F0A5040  cmplw cr6, r10, r10
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[10].u32, &mut ctx.xer);
	// 824A3C18: B12B00AC  sth r9, 0xac(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), ctx.r[9].u16 ) };
	// 824A3C1C: B0CB00B0  sth r6, 0xb0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[6].u16 ) };
	// 824A3C20: B3CB0120  sth r30, 0x120(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(288 as u32), ctx.r[30].u16 ) };
	// 824A3C24: 40980024  bge cr6, 0x824a3c48
	if !ctx.cr[6].lt {
	pc = 0x824A3C48; continue 'dispatch;
	}
	// 824A3C28: 7D6A5050  subf r11, r10, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[10].s64;
	// 824A3C2C: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 824A3C30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A3C34: 419A0014  beq cr6, 0x824a3c48
	if ctx.cr[6].eq {
	pc = 0x824A3C48; continue 'dispatch;
	}
	// 824A3C38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x824A3C3C; continue 'dispatch;
            }
            0x824A3C3C => {
    //   block [0x824A3C3C..0x824A3C48)
	// 824A3C3C: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 824A3C40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824A3C44: 4200FFF8  bdnz 0x824a3c3c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824A3C3C; continue 'dispatch;
	}
	pc = 0x824A3C48; continue 'dispatch;
            }
            0x824A3C48 => {
    //   block [0x824A3C48..0x824A3D60)
	// 824A3C48: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 824A3C4C: 988300BE  stb r4, 0xbe(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(190 as u32), ctx.r[4].u8 ) };
	// 824A3C50: 392300D0  addi r9, r3, 0xd0
	ctx.r[9].s64 = ctx.r[3].s64 + 208;
	// 824A3C54: 98A300A2  stb r5, 0xa2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(162 as u32), ctx.r[5].u8 ) };
	// 824A3C58: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 824A3C5C: 98A300AE  stb r5, 0xae(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(174 as u32), ctx.r[5].u8 ) };
	// 824A3C60: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 824A3C64: 9BE300BA  stb r31, 0xba(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(186 as u32), ctx.r[31].u8 ) };
	// 824A3C68: 39030100  addi r8, r3, 0x100
	ctx.r[8].s64 = ctx.r[3].s64 + 256;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A3D60 size=4
    let mut pc: u32 = 0x824A3D60;
    'dispatch: loop {
        match pc {
            0x824A3D60 => {
    //   block [0x824A3D60..0x824A3D64)
	// 824A3D60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A3D68 size=8
    let mut pc: u32 = 0x824A3D68;
    'dispatch: loop {
        match pc {
            0x824A3D68 => {
    //   block [0x824A3D68..0x824A3D70)
	// 824A3D68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824A3D6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A3D70 size=20
    let mut pc: u32 = 0x824A3D70;
    'dispatch: loop {
        match pc {
            0x824A3D70 => {
    //   block [0x824A3D70..0x824A3D84)
	// 824A3D70: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A3D74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A3D78: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A3D7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A3D80: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A3D88 size=220
    let mut pc: u32 = 0x824A3D88;
    'dispatch: loop {
        match pc {
            0x824A3D88 => {
    //   block [0x824A3D88..0x824A3DE4)
	// 824A3D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A3D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A3D90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824A3D94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A3D98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A3D9C: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A3DA0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824A3DA4: 3BCA002C  addi r30, r10, 0x2c
	ctx.r[30].s64 = ctx.r[10].s64 + 44;
	// 824A3DA8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A3DAC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A3DB0: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824A3DB4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A3DB8: 40980060  bge cr6, 0x824a3e18
	if !ctx.cr[6].lt {
	pc = 0x824A3E18; continue 'dispatch;
	}
	// 824A3DBC: 556B0000  rlwinm r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A3DC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A3DC4: 409A0020  bne cr6, 0x824a3de4
	if !ctx.cr[6].eq {
	pc = 0x824A3DE4; continue 'dispatch;
	}
	// 824A3DC8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A3DCC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824A3DD0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A3DD4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A3DD8: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A3DDC: 7C69582E  lwzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A3DE0: 4BFC02D9  bl 0x824640b8
	ctx.lr = 0x824A3DE4;
	sub_824640B8(ctx, base);
	pc = 0x824A3DE4; continue 'dispatch;
            }
            0x824A3DE4 => {
    //   block [0x824A3DE4..0x824A3E18)
	// 824A3DE4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A3DE8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824A3DEC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A3DF0: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 824A3DF4: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 824A3DF8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A3DFC: 4BFC023D  bl 0x82464038
	ctx.lr = 0x824A3E00;
	sub_82464038(ctx, base);
	// 824A3E00: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A3E04: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824A3E08: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A3E0C: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A3E10: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 824A3E14: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x824A3E18; continue 'dispatch;
            }
            0x824A3E18 => {
    //   block [0x824A3E18..0x824A3E34)
	// 824A3E18: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A3E1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A3E20: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A3E24: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824A3E28: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A3E2C: 40990020  ble cr6, 0x824a3e4c
	if !ctx.cr[6].gt {
	pc = 0x824A3E4C; continue 'dispatch;
	}
	// 824A3E30: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x824A3E34; continue 'dispatch;
            }
            0x824A3E34 => {
    //   block [0x824A3E34..0x824A3E4C)
	// 824A3E34: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A3E38: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824A3E3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824A3E40: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824A3E44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824A3E48: 409AFFEC  bne cr6, 0x824a3e34
	if !ctx.cr[6].eq {
	pc = 0x824A3E34; continue 'dispatch;
	}
	pc = 0x824A3E4C; continue 'dispatch;
            }
            0x824A3E4C => {
    //   block [0x824A3E4C..0x824A3E64)
	// 824A3E4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A3E50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A3E54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A3E58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824A3E5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A3E60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A3E68 size=68
    let mut pc: u32 = 0x824A3E68;
    'dispatch: loop {
        match pc {
            0x824A3E68 => {
    //   block [0x824A3E68..0x824A3EAC)
	// 824A3E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A3E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A3E70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A3E74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A3E78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A3E7C: 4BFF94CD  bl 0x8249d348
	ctx.lr = 0x824A3E80;
	sub_8249D348(ctx, base);
	// 824A3E80: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A3E84: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 824A3E88: 396BCB54  addi r11, r11, -0x34ac
	ctx.r[11].s64 = ctx.r[11].s64 + -13484;
	// 824A3E8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A3E90: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 824A3E94: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A3E98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824A3E9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A3EA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A3EA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A3EA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A3EB0 size=68
    let mut pc: u32 = 0x824A3EB0;
    'dispatch: loop {
        match pc {
            0x824A3EB0 => {
    //   block [0x824A3EB0..0x824A3EF4)
	// 824A3EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A3EB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A3EB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A3EBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A3EC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A3EC4: 4BFF9485  bl 0x8249d348
	ctx.lr = 0x824A3EC8;
	sub_8249D348(ctx, base);
	// 824A3EC8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A3ECC: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 824A3ED0: 396BCC34  addi r11, r11, -0x33cc
	ctx.r[11].s64 = ctx.r[11].s64 + -13260;
	// 824A3ED4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A3ED8: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 824A3EDC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A3EE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824A3EE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A3EE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A3EEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A3EF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A3EF8 size=120
    let mut pc: u32 = 0x824A3EF8;
    'dispatch: loop {
        match pc {
            0x824A3EF8 => {
    //   block [0x824A3EF8..0x824A3F0C)
	// 824A3EF8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A3EFC: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 824A3F00: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824A3F04: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 824A3F08: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	pc = 0x824A3F0C; continue 'dispatch;
            }
            0x824A3F0C => {
    //   block [0x824A3F0C..0x824A3F38)
	// 824A3F0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A3F10: 7D67582E  lwzx r11, r7, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A3F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A3F18: 409A0044  bne cr6, 0x824a3f5c
	if !ctx.cr[6].eq {
	pc = 0x824A3F5C; continue 'dispatch;
	}
	// 824A3F1C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A3F20: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 824A3F24: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824A3F28: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824A3F2C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824A3F30: 4098002C  bge cr6, 0x824a3f5c
	if !ctx.cr[6].lt {
	pc = 0x824A3F5C; continue 'dispatch;
	}
	// 824A3F34: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	pc = 0x824A3F38; continue 'dispatch;
            }
            0x824A3F38 => {
    //   block [0x824A3F38..0x824A3F5C)
	// 824A3F38: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A3F3C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A3F40: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824A3F44: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824A3F48: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A3F4C: 90C90000  stw r6, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 824A3F50: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A3F54: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A3F58: 4198FFE0  blt cr6, 0x824a3f38
	if ctx.cr[6].lt {
	pc = 0x824A3F38; continue 'dispatch;
	}
	pc = 0x824A3F5C; continue 'dispatch;
            }
            0x824A3F5C => {
    //   block [0x824A3F5C..0x824A3F70)
	// 824A3F5C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 824A3F60: 38E7FFFC  addi r7, r7, -4
	ctx.r[7].s64 = ctx.r[7].s64 + -4;
	// 824A3F64: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824A3F68: 4098FFA4  bge cr6, 0x824a3f0c
	if !ctx.cr[6].lt {
	pc = 0x824A3F0C; continue 'dispatch;
	}
	// 824A3F6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A3F70 size=136
    let mut pc: u32 = 0x824A3F70;
    'dispatch: loop {
        match pc {
            0x824A3F70 => {
    //   block [0x824A3F70..0x824A3F8C)
	// 824A3F70: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A3F74: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 824A3F78: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824A3F7C: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 824A3F80: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 824A3F84: 5506103A  slwi r6, r8, 2
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 824A3F88: 6167FFFF  ori r7, r11, 0xffff
	ctx.r[7].u64 = ctx.r[11].u64 | 65535;
	pc = 0x824A3F8C; continue 'dispatch;
            }
            0x824A3F8C => {
    //   block [0x824A3F8C..0x824A3FC0)
	// 824A3F8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A3F90: 7D66582E  lwzx r11, r6, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A3F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A3F98: 409A004C  bne cr6, 0x824a3fe4
	if !ctx.cr[6].eq {
	pc = 0x824A3FE4; continue 'dispatch;
	}
	// 824A3F9C: A1430004  lhz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A3FA0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 824A3FA4: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 824A3FA8: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 824A3FAC: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 824A3FB0: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A3FB4: B1430004  sth r10, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 824A3FB8: 4098002C  bge cr6, 0x824a3fe4
	if !ctx.cr[6].lt {
	pc = 0x824A3FE4; continue 'dispatch;
	}
	// 824A3FBC: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	pc = 0x824A3FC0; continue 'dispatch;
            }
            0x824A3FC0 => {
    //   block [0x824A3FC0..0x824A3FE4)
	// 824A3FC0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A3FC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A3FC8: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824A3FCC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824A3FD0: 80A90004  lwz r5, 4(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A3FD4: 90A90000  stw r5, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 824A3FD8: A1230004  lhz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A3FDC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A3FE0: 4198FFE0  blt cr6, 0x824a3fc0
	if ctx.cr[6].lt {
	pc = 0x824A3FC0; continue 'dispatch;
	}
	pc = 0x824A3FE4; continue 'dispatch;
            }
            0x824A3FE4 => {
    //   block [0x824A3FE4..0x824A3FF8)
	// 824A3FE4: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 824A3FE8: 38C6FFFC  addi r6, r6, -4
	ctx.r[6].s64 = ctx.r[6].s64 + -4;
	// 824A3FEC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824A3FF0: 4098FF9C  bge cr6, 0x824a3f8c
	if !ctx.cr[6].lt {
	pc = 0x824A3F8C; continue 'dispatch;
	}
	// 824A3FF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A3FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A3FF8 size=220
    let mut pc: u32 = 0x824A3FF8;
    'dispatch: loop {
        match pc {
            0x824A3FF8 => {
    //   block [0x824A3FF8..0x824A4030)
	// 824A3FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A3FFC: 480910AD  bl 0x825350a8
	ctx.lr = 0x824A4000;
	sub_82535080(ctx, base);
	// 824A4000: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A4004: 3B8300F0  addi r28, r3, 0xf0
	ctx.r[28].s64 = ctx.r[3].s64 + 240;
	// 824A4008: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A400C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4010: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A4014: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4018: 419800AC  blt cr6, 0x824a40c4
	if ctx.cr[6].lt {
	pc = 0x824A40C4; continue 'dispatch;
	}
	// 824A401C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A4020: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A4024: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A4028: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A402C: 3B0B0600  addi r24, r11, 0x600
	ctx.r[24].s64 = ctx.r[11].s64 + 1536;
	pc = 0x824A4030; continue 'dispatch;
            }
            0x824A4030 => {
    //   block [0x824A4030..0x824A4070)
	// 824A4030: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4034: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A403C: 419A0078  beq cr6, 0x824a40b4
	if ctx.cr[6].eq {
	pc = 0x824A40B4; continue 'dispatch;
	}
	// 824A4040: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4044: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4048: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A404C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4050: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4054: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4058: 40980018  bge cr6, 0x824a4070
	if !ctx.cr[6].lt {
	pc = 0x824A4070; continue 'dispatch;
	}
	// 824A405C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A4060: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4064: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4068: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A406C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4070; continue 'dispatch;
            }
            0x824A4070 => {
    //   block [0x824A4070..0x824A40B4)
	// 824A4070: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4074: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A4078: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A407C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4080: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4084: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4088: 4E800421  bctrl
	ctx.lr = 0x824A408C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A408C: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4090: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4094: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4098: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A409C: 40980018  bge cr6, 0x824a40b4
	if !ctx.cr[6].lt {
	pc = 0x824A40B4; continue 'dispatch;
	}
	// 824A40A0: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A40A4: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A40A8: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A40AC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A40B0: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A40B4 => {
    //   block [0x824A40B4..0x824A40C4)
	// 824A40B4: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A40B8: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A40BC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A40C0: 4098FF70  bge cr6, 0x824a4030
	if !ctx.cr[6].lt {
	pc = 0x824A4030; continue 'dispatch;
	}
	pc = 0x824A40C4; continue 'dispatch;
            }
            0x824A40C4 => {
    //   block [0x824A40C4..0x824A40D4)
	// 824A40C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A40C8: 4BFFFE31  bl 0x824a3ef8
	ctx.lr = 0x824A40CC;
	sub_824A3EF8(ctx, base);
	// 824A40CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A40D0: 48091028  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A40D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A40D8 size=220
    let mut pc: u32 = 0x824A40D8;
    'dispatch: loop {
        match pc {
            0x824A40D8 => {
    //   block [0x824A40D8..0x824A4110)
	// 824A40D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A40DC: 48090FCD  bl 0x825350a8
	ctx.lr = 0x824A40E0;
	sub_82535080(ctx, base);
	// 824A40E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A40E4: 3B8300F0  addi r28, r3, 0xf0
	ctx.r[28].s64 = ctx.r[3].s64 + 240;
	// 824A40E8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A40EC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A40F0: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A40F4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A40F8: 419800AC  blt cr6, 0x824a41a4
	if ctx.cr[6].lt {
	pc = 0x824A41A4; continue 'dispatch;
	}
	// 824A40FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A4100: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A4104: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A4108: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A410C: 3B0B060C  addi r24, r11, 0x60c
	ctx.r[24].s64 = ctx.r[11].s64 + 1548;
	pc = 0x824A4110; continue 'dispatch;
            }
            0x824A4110 => {
    //   block [0x824A4110..0x824A4150)
	// 824A4110: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4114: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A411C: 419A0078  beq cr6, 0x824a4194
	if ctx.cr[6].eq {
	pc = 0x824A4194; continue 'dispatch;
	}
	// 824A4120: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4124: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4128: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A412C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4130: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4134: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4138: 40980018  bge cr6, 0x824a4150
	if !ctx.cr[6].lt {
	pc = 0x824A4150; continue 'dispatch;
	}
	// 824A413C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A4140: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4144: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4148: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A414C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4150; continue 'dispatch;
            }
            0x824A4150 => {
    //   block [0x824A4150..0x824A4194)
	// 824A4150: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4154: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A4158: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A415C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4160: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A4164: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4168: 4E800421  bctrl
	ctx.lr = 0x824A416C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A416C: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4170: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4174: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4178: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A417C: 40980018  bge cr6, 0x824a4194
	if !ctx.cr[6].lt {
	pc = 0x824A4194; continue 'dispatch;
	}
	// 824A4180: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A4184: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4188: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A418C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4190: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A4194 => {
    //   block [0x824A4194..0x824A41A4)
	// 824A4194: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A4198: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A419C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A41A0: 4098FF70  bge cr6, 0x824a4110
	if !ctx.cr[6].lt {
	pc = 0x824A4110; continue 'dispatch;
	}
	pc = 0x824A41A4; continue 'dispatch;
            }
            0x824A41A4 => {
    //   block [0x824A41A4..0x824A41B4)
	// 824A41A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A41A8: 4BFFFD51  bl 0x824a3ef8
	ctx.lr = 0x824A41AC;
	sub_824A3EF8(ctx, base);
	// 824A41AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A41B0: 48090F48  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A41B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A41B8 size=220
    let mut pc: u32 = 0x824A41B8;
    'dispatch: loop {
        match pc {
            0x824A41B8 => {
    //   block [0x824A41B8..0x824A41F0)
	// 824A41B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A41BC: 48090EED  bl 0x825350a8
	ctx.lr = 0x824A41C0;
	sub_82535080(ctx, base);
	// 824A41C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A41C4: 3B8300FC  addi r28, r3, 0xfc
	ctx.r[28].s64 = ctx.r[3].s64 + 252;
	// 824A41C8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A41CC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A41D0: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A41D4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A41D8: 419800AC  blt cr6, 0x824a4284
	if ctx.cr[6].lt {
	pc = 0x824A4284; continue 'dispatch;
	}
	// 824A41DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A41E0: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A41E4: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A41E8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A41EC: 3B0B0580  addi r24, r11, 0x580
	ctx.r[24].s64 = ctx.r[11].s64 + 1408;
	pc = 0x824A41F0; continue 'dispatch;
            }
            0x824A41F0 => {
    //   block [0x824A41F0..0x824A4230)
	// 824A41F0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A41F4: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A41F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A41FC: 419A0078  beq cr6, 0x824a4274
	if ctx.cr[6].eq {
	pc = 0x824A4274; continue 'dispatch;
	}
	// 824A4200: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4204: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4208: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A420C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4210: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4214: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4218: 40980018  bge cr6, 0x824a4230
	if !ctx.cr[6].lt {
	pc = 0x824A4230; continue 'dispatch;
	}
	// 824A421C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A4220: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4224: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4228: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A422C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4230; continue 'dispatch;
            }
            0x824A4230 => {
    //   block [0x824A4230..0x824A4274)
	// 824A4230: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4234: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A4238: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A423C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4240: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4244: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4248: 4E800421  bctrl
	ctx.lr = 0x824A424C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A424C: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4250: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4254: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4258: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A425C: 40980018  bge cr6, 0x824a4274
	if !ctx.cr[6].lt {
	pc = 0x824A4274; continue 'dispatch;
	}
	// 824A4260: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A4264: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4268: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A426C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4270: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A4274 => {
    //   block [0x824A4274..0x824A4284)
	// 824A4274: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A4278: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A427C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4280: 4098FF70  bge cr6, 0x824a41f0
	if !ctx.cr[6].lt {
	pc = 0x824A41F0; continue 'dispatch;
	}
	pc = 0x824A4284; continue 'dispatch;
            }
            0x824A4284 => {
    //   block [0x824A4284..0x824A4294)
	// 824A4284: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A4288: 4BFFFC71  bl 0x824a3ef8
	ctx.lr = 0x824A428C;
	sub_824A3EF8(ctx, base);
	// 824A428C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A4290: 48090E68  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A4298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A4298 size=220
    let mut pc: u32 = 0x824A4298;
    'dispatch: loop {
        match pc {
            0x824A4298 => {
    //   block [0x824A4298..0x824A42D0)
	// 824A4298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A429C: 48090E0D  bl 0x825350a8
	ctx.lr = 0x824A42A0;
	sub_82535080(ctx, base);
	// 824A42A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A42A4: 3B8300FC  addi r28, r3, 0xfc
	ctx.r[28].s64 = ctx.r[3].s64 + 252;
	// 824A42A8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A42AC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A42B0: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A42B4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A42B8: 419800AC  blt cr6, 0x824a4364
	if ctx.cr[6].lt {
	pc = 0x824A4364; continue 'dispatch;
	}
	// 824A42BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A42C0: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A42C4: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A42C8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A42CC: 3B0B058C  addi r24, r11, 0x58c
	ctx.r[24].s64 = ctx.r[11].s64 + 1420;
	pc = 0x824A42D0; continue 'dispatch;
            }
            0x824A42D0 => {
    //   block [0x824A42D0..0x824A4310)
	// 824A42D0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A42D4: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A42D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A42DC: 419A0078  beq cr6, 0x824a4354
	if ctx.cr[6].eq {
	pc = 0x824A4354; continue 'dispatch;
	}
	// 824A42E0: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A42E4: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A42E8: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A42EC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A42F0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A42F4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A42F8: 40980018  bge cr6, 0x824a4310
	if !ctx.cr[6].lt {
	pc = 0x824A4310; continue 'dispatch;
	}
	// 824A42FC: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A4300: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4304: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4308: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A430C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4310; continue 'dispatch;
            }
            0x824A4310 => {
    //   block [0x824A4310..0x824A4354)
	// 824A4310: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4314: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A4318: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A431C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4320: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A4324: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4328: 4E800421  bctrl
	ctx.lr = 0x824A432C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A432C: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4330: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4334: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4338: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A433C: 40980018  bge cr6, 0x824a4354
	if !ctx.cr[6].lt {
	pc = 0x824A4354; continue 'dispatch;
	}
	// 824A4340: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A4344: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4348: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A434C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4350: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A4354 => {
    //   block [0x824A4354..0x824A4364)
	// 824A4354: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A4358: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A435C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4360: 4098FF70  bge cr6, 0x824a42d0
	if !ctx.cr[6].lt {
	pc = 0x824A42D0; continue 'dispatch;
	}
	pc = 0x824A4364; continue 'dispatch;
            }
            0x824A4364 => {
    //   block [0x824A4364..0x824A4374)
	// 824A4364: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A4368: 4BFFFB91  bl 0x824a3ef8
	ctx.lr = 0x824A436C;
	sub_824A3EF8(ctx, base);
	// 824A436C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A4370: 48090D88  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A4378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A4378 size=220
    let mut pc: u32 = 0x824A4378;
    'dispatch: loop {
        match pc {
            0x824A4378 => {
    //   block [0x824A4378..0x824A43B0)
	// 824A4378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A437C: 48090D2D  bl 0x825350a8
	ctx.lr = 0x824A4380;
	sub_82535080(ctx, base);
	// 824A4380: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A4384: 3B8300FC  addi r28, r3, 0xfc
	ctx.r[28].s64 = ctx.r[3].s64 + 252;
	// 824A4388: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A438C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4390: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A4394: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4398: 419800AC  blt cr6, 0x824a4444
	if ctx.cr[6].lt {
	pc = 0x824A4444; continue 'dispatch;
	}
	// 824A439C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A43A0: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A43A4: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A43A8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A43AC: 3B0B0598  addi r24, r11, 0x598
	ctx.r[24].s64 = ctx.r[11].s64 + 1432;
	pc = 0x824A43B0; continue 'dispatch;
            }
            0x824A43B0 => {
    //   block [0x824A43B0..0x824A43F0)
	// 824A43B0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A43B4: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A43B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A43BC: 419A0078  beq cr6, 0x824a4434
	if ctx.cr[6].eq {
	pc = 0x824A4434; continue 'dispatch;
	}
	// 824A43C0: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A43C4: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A43C8: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A43CC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A43D0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A43D4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A43D8: 40980018  bge cr6, 0x824a43f0
	if !ctx.cr[6].lt {
	pc = 0x824A43F0; continue 'dispatch;
	}
	// 824A43DC: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A43E0: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A43E4: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A43E8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A43EC: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A43F0; continue 'dispatch;
            }
            0x824A43F0 => {
    //   block [0x824A43F0..0x824A4434)
	// 824A43F0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A43F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A43F8: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A43FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4400: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4404: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4408: 4E800421  bctrl
	ctx.lr = 0x824A440C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A440C: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4410: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4414: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4418: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A441C: 40980018  bge cr6, 0x824a4434
	if !ctx.cr[6].lt {
	pc = 0x824A4434; continue 'dispatch;
	}
	// 824A4420: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A4424: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4428: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A442C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4430: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A4434 => {
    //   block [0x824A4434..0x824A4444)
	// 824A4434: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A4438: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A443C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4440: 4098FF70  bge cr6, 0x824a43b0
	if !ctx.cr[6].lt {
	pc = 0x824A43B0; continue 'dispatch;
	}
	pc = 0x824A4444; continue 'dispatch;
            }
            0x824A4444 => {
    //   block [0x824A4444..0x824A4454)
	// 824A4444: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A4448: 4BFFFAB1  bl 0x824a3ef8
	ctx.lr = 0x824A444C;
	sub_824A3EF8(ctx, base);
	// 824A444C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A4450: 48090CA8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A4458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A4458 size=220
    let mut pc: u32 = 0x824A4458;
    'dispatch: loop {
        match pc {
            0x824A4458 => {
    //   block [0x824A4458..0x824A4490)
	// 824A4458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A445C: 48090C4D  bl 0x825350a8
	ctx.lr = 0x824A4460;
	sub_82535080(ctx, base);
	// 824A4460: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A4464: 3B830108  addi r28, r3, 0x108
	ctx.r[28].s64 = ctx.r[3].s64 + 264;
	// 824A4468: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A446C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4470: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A4474: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4478: 419800AC  blt cr6, 0x824a4524
	if ctx.cr[6].lt {
	pc = 0x824A4524; continue 'dispatch;
	}
	// 824A447C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A4480: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A4484: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A4488: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A448C: 3B0B0618  addi r24, r11, 0x618
	ctx.r[24].s64 = ctx.r[11].s64 + 1560;
	pc = 0x824A4490; continue 'dispatch;
            }
            0x824A4490 => {
    //   block [0x824A4490..0x824A44D0)
	// 824A4490: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4494: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4498: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A449C: 419A0078  beq cr6, 0x824a4514
	if ctx.cr[6].eq {
	pc = 0x824A4514; continue 'dispatch;
	}
	// 824A44A0: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A44A4: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A44A8: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A44AC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A44B0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A44B4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A44B8: 40980018  bge cr6, 0x824a44d0
	if !ctx.cr[6].lt {
	pc = 0x824A44D0; continue 'dispatch;
	}
	// 824A44BC: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A44C0: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A44C4: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A44C8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A44CC: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A44D0; continue 'dispatch;
            }
            0x824A44D0 => {
    //   block [0x824A44D0..0x824A4514)
	// 824A44D0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A44D4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A44D8: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A44DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A44E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A44E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A44E8: 4E800421  bctrl
	ctx.lr = 0x824A44EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A44EC: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A44F0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A44F4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A44F8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A44FC: 40980018  bge cr6, 0x824a4514
	if !ctx.cr[6].lt {
	pc = 0x824A4514; continue 'dispatch;
	}
	// 824A4500: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A4504: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4508: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A450C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4510: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A4514 => {
    //   block [0x824A4514..0x824A4524)
	// 824A4514: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A4518: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A451C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4520: 4098FF70  bge cr6, 0x824a4490
	if !ctx.cr[6].lt {
	pc = 0x824A4490; continue 'dispatch;
	}
	pc = 0x824A4524; continue 'dispatch;
            }
            0x824A4524 => {
    //   block [0x824A4524..0x824A4534)
	// 824A4524: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A4528: 4BFFF9D1  bl 0x824a3ef8
	ctx.lr = 0x824A452C;
	sub_824A3EF8(ctx, base);
	// 824A452C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A4530: 48090BC8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A4538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A4538 size=220
    let mut pc: u32 = 0x824A4538;
    'dispatch: loop {
        match pc {
            0x824A4538 => {
    //   block [0x824A4538..0x824A4570)
	// 824A4538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A453C: 48090B6D  bl 0x825350a8
	ctx.lr = 0x824A4540;
	sub_82535080(ctx, base);
	// 824A4540: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A4544: 3B830108  addi r28, r3, 0x108
	ctx.r[28].s64 = ctx.r[3].s64 + 264;
	// 824A4548: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A454C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4550: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A4554: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4558: 419800AC  blt cr6, 0x824a4604
	if ctx.cr[6].lt {
	pc = 0x824A4604; continue 'dispatch;
	}
	// 824A455C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A4560: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A4564: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A4568: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A456C: 3B0B0624  addi r24, r11, 0x624
	ctx.r[24].s64 = ctx.r[11].s64 + 1572;
	pc = 0x824A4570; continue 'dispatch;
            }
            0x824A4570 => {
    //   block [0x824A4570..0x824A45B0)
	// 824A4570: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4574: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A457C: 419A0078  beq cr6, 0x824a45f4
	if ctx.cr[6].eq {
	pc = 0x824A45F4; continue 'dispatch;
	}
	// 824A4580: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4584: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4588: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A458C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4590: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4594: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4598: 40980018  bge cr6, 0x824a45b0
	if !ctx.cr[6].lt {
	pc = 0x824A45B0; continue 'dispatch;
	}
	// 824A459C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A45A0: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A45A4: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A45A8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A45AC: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A45B0; continue 'dispatch;
            }
            0x824A45B0 => {
    //   block [0x824A45B0..0x824A45F4)
	// 824A45B0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A45B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A45B8: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A45BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A45C0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A45C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A45C8: 4E800421  bctrl
	ctx.lr = 0x824A45CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A45CC: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A45D0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A45D4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A45D8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A45DC: 40980018  bge cr6, 0x824a45f4
	if !ctx.cr[6].lt {
	pc = 0x824A45F4; continue 'dispatch;
	}
	// 824A45E0: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A45E4: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A45E8: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A45EC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A45F0: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A45F4 => {
    //   block [0x824A45F4..0x824A4604)
	// 824A45F4: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A45F8: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A45FC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4600: 4098FF70  bge cr6, 0x824a4570
	if !ctx.cr[6].lt {
	pc = 0x824A4570; continue 'dispatch;
	}
	pc = 0x824A4604; continue 'dispatch;
            }
            0x824A4604 => {
    //   block [0x824A4604..0x824A4614)
	// 824A4604: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A4608: 4BFFF8F1  bl 0x824a3ef8
	ctx.lr = 0x824A460C;
	sub_824A3EF8(ctx, base);
	// 824A460C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A4610: 48090AE8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A4618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A4618 size=220
    let mut pc: u32 = 0x824A4618;
    'dispatch: loop {
        match pc {
            0x824A4618 => {
    //   block [0x824A4618..0x824A4650)
	// 824A4618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A461C: 48090A8D  bl 0x825350a8
	ctx.lr = 0x824A4620;
	sub_82535080(ctx, base);
	// 824A4620: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A4624: 3B830108  addi r28, r3, 0x108
	ctx.r[28].s64 = ctx.r[3].s64 + 264;
	// 824A4628: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A462C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4630: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A4634: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4638: 419800AC  blt cr6, 0x824a46e4
	if ctx.cr[6].lt {
	pc = 0x824A46E4; continue 'dispatch;
	}
	// 824A463C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A4640: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A4644: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A4648: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A464C: 3B0B0598  addi r24, r11, 0x598
	ctx.r[24].s64 = ctx.r[11].s64 + 1432;
	pc = 0x824A4650; continue 'dispatch;
            }
            0x824A4650 => {
    //   block [0x824A4650..0x824A4690)
	// 824A4650: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4654: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A465C: 419A0078  beq cr6, 0x824a46d4
	if ctx.cr[6].eq {
	pc = 0x824A46D4; continue 'dispatch;
	}
	// 824A4660: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4664: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4668: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A466C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4670: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4674: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4678: 40980018  bge cr6, 0x824a4690
	if !ctx.cr[6].lt {
	pc = 0x824A4690; continue 'dispatch;
	}
	// 824A467C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A4680: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4684: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4688: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A468C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4690; continue 'dispatch;
            }
            0x824A4690 => {
    //   block [0x824A4690..0x824A46D4)
	// 824A4690: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4694: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A4698: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A469C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A46A0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A46A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A46A8: 4E800421  bctrl
	ctx.lr = 0x824A46AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A46AC: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A46B0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A46B4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A46B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A46BC: 40980018  bge cr6, 0x824a46d4
	if !ctx.cr[6].lt {
	pc = 0x824A46D4; continue 'dispatch;
	}
	// 824A46C0: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A46C4: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A46C8: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A46CC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A46D0: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A46D4 => {
    //   block [0x824A46D4..0x824A46E4)
	// 824A46D4: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A46D8: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A46DC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A46E0: 4098FF70  bge cr6, 0x824a4650
	if !ctx.cr[6].lt {
	pc = 0x824A4650; continue 'dispatch;
	}
	pc = 0x824A46E4; continue 'dispatch;
            }
            0x824A46E4 => {
    //   block [0x824A46E4..0x824A46F4)
	// 824A46E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A46E8: 4BFFF811  bl 0x824a3ef8
	ctx.lr = 0x824A46EC;
	sub_824A3EF8(ctx, base);
	// 824A46EC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A46F0: 48090A08  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A46F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A46F8 size=220
    let mut pc: u32 = 0x824A46F8;
    'dispatch: loop {
        match pc {
            0x824A46F8 => {
    //   block [0x824A46F8..0x824A4730)
	// 824A46F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A46FC: 480909AD  bl 0x825350a8
	ctx.lr = 0x824A4700;
	sub_82535080(ctx, base);
	// 824A4700: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A4704: 3B830114  addi r28, r3, 0x114
	ctx.r[28].s64 = ctx.r[3].s64 + 276;
	// 824A4708: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A470C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4710: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A4714: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4718: 419800AC  blt cr6, 0x824a47c4
	if ctx.cr[6].lt {
	pc = 0x824A47C4; continue 'dispatch;
	}
	// 824A471C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A4720: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A4724: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A4728: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A472C: 3B0B0630  addi r24, r11, 0x630
	ctx.r[24].s64 = ctx.r[11].s64 + 1584;
	pc = 0x824A4730; continue 'dispatch;
            }
            0x824A4730 => {
    //   block [0x824A4730..0x824A4770)
	// 824A4730: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4734: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4738: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A473C: 419A0078  beq cr6, 0x824a47b4
	if ctx.cr[6].eq {
	pc = 0x824A47B4; continue 'dispatch;
	}
	// 824A4740: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4744: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4748: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A474C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4750: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4754: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4758: 40980018  bge cr6, 0x824a4770
	if !ctx.cr[6].lt {
	pc = 0x824A4770; continue 'dispatch;
	}
	// 824A475C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A4760: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4764: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4768: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A476C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4770; continue 'dispatch;
            }
            0x824A4770 => {
    //   block [0x824A4770..0x824A47B4)
	// 824A4770: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4774: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A4778: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A477C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4780: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4784: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4788: 4E800421  bctrl
	ctx.lr = 0x824A478C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A478C: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4790: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4794: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4798: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A479C: 40980018  bge cr6, 0x824a47b4
	if !ctx.cr[6].lt {
	pc = 0x824A47B4; continue 'dispatch;
	}
	// 824A47A0: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A47A4: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A47A8: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A47AC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A47B0: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A47B4 => {
    //   block [0x824A47B4..0x824A47C4)
	// 824A47B4: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A47B8: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A47BC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A47C0: 4098FF70  bge cr6, 0x824a4730
	if !ctx.cr[6].lt {
	pc = 0x824A4730; continue 'dispatch;
	}
	pc = 0x824A47C4; continue 'dispatch;
            }
            0x824A47C4 => {
    //   block [0x824A47C4..0x824A47D4)
	// 824A47C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A47C8: 4BFFF731  bl 0x824a3ef8
	ctx.lr = 0x824A47CC;
	sub_824A3EF8(ctx, base);
	// 824A47CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A47D0: 48090928  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A47D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A47D8 size=220
    let mut pc: u32 = 0x824A47D8;
    'dispatch: loop {
        match pc {
            0x824A47D8 => {
    //   block [0x824A47D8..0x824A4810)
	// 824A47D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A47DC: 480908CD  bl 0x825350a8
	ctx.lr = 0x824A47E0;
	sub_82535080(ctx, base);
	// 824A47E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A47E4: 3B830114  addi r28, r3, 0x114
	ctx.r[28].s64 = ctx.r[3].s64 + 276;
	// 824A47E8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A47EC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A47F0: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A47F4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A47F8: 419800AC  blt cr6, 0x824a48a4
	if ctx.cr[6].lt {
	pc = 0x824A48A4; continue 'dispatch;
	}
	// 824A47FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A4800: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A4804: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A4808: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A480C: 3B0B063C  addi r24, r11, 0x63c
	ctx.r[24].s64 = ctx.r[11].s64 + 1596;
	pc = 0x824A4810; continue 'dispatch;
            }
            0x824A4810 => {
    //   block [0x824A4810..0x824A4850)
	// 824A4810: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4814: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A481C: 419A0078  beq cr6, 0x824a4894
	if ctx.cr[6].eq {
	pc = 0x824A4894; continue 'dispatch;
	}
	// 824A4820: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4824: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4828: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A482C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4830: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4834: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4838: 40980018  bge cr6, 0x824a4850
	if !ctx.cr[6].lt {
	pc = 0x824A4850; continue 'dispatch;
	}
	// 824A483C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A4840: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4844: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4848: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A484C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4850; continue 'dispatch;
            }
            0x824A4850 => {
    //   block [0x824A4850..0x824A4894)
	// 824A4850: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4854: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A4858: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A485C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4860: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A4864: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4868: 4E800421  bctrl
	ctx.lr = 0x824A486C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A486C: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4870: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4874: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4878: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A487C: 40980018  bge cr6, 0x824a4894
	if !ctx.cr[6].lt {
	pc = 0x824A4894; continue 'dispatch;
	}
	// 824A4880: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A4884: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4888: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A488C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4890: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A4894 => {
    //   block [0x824A4894..0x824A48A4)
	// 824A4894: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A4898: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A489C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A48A0: 4098FF70  bge cr6, 0x824a4810
	if !ctx.cr[6].lt {
	pc = 0x824A4810; continue 'dispatch;
	}
	pc = 0x824A48A4; continue 'dispatch;
            }
            0x824A48A4 => {
    //   block [0x824A48A4..0x824A48B4)
	// 824A48A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A48A8: 4BFFF651  bl 0x824a3ef8
	ctx.lr = 0x824A48AC;
	sub_824A3EF8(ctx, base);
	// 824A48AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A48B0: 48090848  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A48B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A48B8 size=228
    let mut pc: u32 = 0x824A48B8;
    'dispatch: loop {
        match pc {
            0x824A48B8 => {
    //   block [0x824A48B8..0x824A48F8)
	// 824A48B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A48BC: 480907ED  bl 0x825350a8
	ctx.lr = 0x824A48C0;
	sub_82535080(ctx, base);
	// 824A48C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A48C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A48C8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A48CC: 3B830174  addi r28, r3, 0x174
	ctx.r[28].s64 = ctx.r[3].s64 + 372;
	// 824A48D0: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824A48D4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A48D8: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A48DC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A48E0: 419800AC  blt cr6, 0x824a498c
	if ctx.cr[6].lt {
	pc = 0x824A498C; continue 'dispatch;
	}
	// 824A48E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A48E8: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A48EC: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A48F0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A48F4: 3B0B05B4  addi r24, r11, 0x5b4
	ctx.r[24].s64 = ctx.r[11].s64 + 1460;
	pc = 0x824A48F8; continue 'dispatch;
            }
            0x824A48F8 => {
    //   block [0x824A48F8..0x824A4938)
	// 824A48F8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A48FC: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A4904: 419A0078  beq cr6, 0x824a497c
	if ctx.cr[6].eq {
	pc = 0x824A497C; continue 'dispatch;
	}
	// 824A4908: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A490C: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4910: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4914: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4918: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A491C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4920: 40980018  bge cr6, 0x824a4938
	if !ctx.cr[6].lt {
	pc = 0x824A4938; continue 'dispatch;
	}
	// 824A4924: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A4928: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A492C: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4930: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4934: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4938; continue 'dispatch;
            }
            0x824A4938 => {
    //   block [0x824A4938..0x824A497C)
	// 824A4938: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A493C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A4940: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4944: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4948: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A494C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4950: 4E800421  bctrl
	ctx.lr = 0x824A4954;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A4954: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4958: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A495C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4960: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4964: 40980018  bge cr6, 0x824a497c
	if !ctx.cr[6].lt {
	pc = 0x824A497C; continue 'dispatch;
	}
	// 824A4968: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A496C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4970: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A4974: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4978: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A497C => {
    //   block [0x824A497C..0x824A498C)
	// 824A497C: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A4980: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A4984: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4988: 4098FF70  bge cr6, 0x824a48f8
	if !ctx.cr[6].lt {
	pc = 0x824A48F8; continue 'dispatch;
	}
	pc = 0x824A498C; continue 'dispatch;
            }
            0x824A498C => {
    //   block [0x824A498C..0x824A499C)
	// 824A498C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A4990: 4BFFF569  bl 0x824a3ef8
	ctx.lr = 0x824A4994;
	sub_824A3EF8(ctx, base);
	// 824A4994: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A4998: 48090760  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A49A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A49A0 size=228
    let mut pc: u32 = 0x824A49A0;
    'dispatch: loop {
        match pc {
            0x824A49A0 => {
    //   block [0x824A49A0..0x824A49E0)
	// 824A49A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A49A4: 48090705  bl 0x825350a8
	ctx.lr = 0x824A49A8;
	sub_82535080(ctx, base);
	// 824A49A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A49AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A49B0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A49B4: 3B830174  addi r28, r3, 0x174
	ctx.r[28].s64 = ctx.r[3].s64 + 372;
	// 824A49B8: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824A49BC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A49C0: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A49C4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A49C8: 419800AC  blt cr6, 0x824a4a74
	if ctx.cr[6].lt {
	pc = 0x824A4A74; continue 'dispatch;
	}
	// 824A49CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A49D0: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A49D4: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A49D8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A49DC: 3B0B05C0  addi r24, r11, 0x5c0
	ctx.r[24].s64 = ctx.r[11].s64 + 1472;
	pc = 0x824A49E0; continue 'dispatch;
            }
            0x824A49E0 => {
    //   block [0x824A49E0..0x824A4A20)
	// 824A49E0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A49E4: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A49E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A49EC: 419A0078  beq cr6, 0x824a4a64
	if ctx.cr[6].eq {
	pc = 0x824A4A64; continue 'dispatch;
	}
	// 824A49F0: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A49F4: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A49F8: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A49FC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4A00: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4A04: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4A08: 40980018  bge cr6, 0x824a4a20
	if !ctx.cr[6].lt {
	pc = 0x824A4A20; continue 'dispatch;
	}
	// 824A4A0C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A4A10: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4A14: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4A18: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4A1C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4A20; continue 'dispatch;
            }
            0x824A4A20 => {
    //   block [0x824A4A20..0x824A4A64)
	// 824A4A20: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4A24: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A4A28: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4A2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4A30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4A34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4A38: 4E800421  bctrl
	ctx.lr = 0x824A4A3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A4A3C: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4A40: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4A44: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4A48: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4A4C: 40980018  bge cr6, 0x824a4a64
	if !ctx.cr[6].lt {
	pc = 0x824A4A64; continue 'dispatch;
	}
	// 824A4A50: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A4A54: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4A58: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A4A5C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4A60: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A4A64 => {
    //   block [0x824A4A64..0x824A4A74)
	// 824A4A64: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A4A68: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A4A6C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4A70: 4098FF70  bge cr6, 0x824a49e0
	if !ctx.cr[6].lt {
	pc = 0x824A49E0; continue 'dispatch;
	}
	pc = 0x824A4A74; continue 'dispatch;
            }
            0x824A4A74 => {
    //   block [0x824A4A74..0x824A4A84)
	// 824A4A74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A4A78: 4BFFF481  bl 0x824a3ef8
	ctx.lr = 0x824A4A7C;
	sub_824A3EF8(ctx, base);
	// 824A4A7C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A4A80: 48090678  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A4A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A4A88 size=228
    let mut pc: u32 = 0x824A4A88;
    'dispatch: loop {
        match pc {
            0x824A4A88 => {
    //   block [0x824A4A88..0x824A4AC8)
	// 824A4A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A4A8C: 4809061D  bl 0x825350a8
	ctx.lr = 0x824A4A90;
	sub_82535080(ctx, base);
	// 824A4A90: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A4A94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A4A98: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A4A9C: 3B830174  addi r28, r3, 0x174
	ctx.r[28].s64 = ctx.r[3].s64 + 372;
	// 824A4AA0: 917B0010  stw r11, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 824A4AA4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4AA8: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A4AAC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4AB0: 419800AC  blt cr6, 0x824a4b5c
	if ctx.cr[6].lt {
	pc = 0x824A4B5C; continue 'dispatch;
	}
	// 824A4AB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A4AB8: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A4ABC: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A4AC0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A4AC4: 3B0B05CC  addi r24, r11, 0x5cc
	ctx.r[24].s64 = ctx.r[11].s64 + 1484;
	pc = 0x824A4AC8; continue 'dispatch;
            }
            0x824A4AC8 => {
    //   block [0x824A4AC8..0x824A4B08)
	// 824A4AC8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4ACC: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4AD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A4AD4: 419A0078  beq cr6, 0x824a4b4c
	if ctx.cr[6].eq {
	pc = 0x824A4B4C; continue 'dispatch;
	}
	// 824A4AD8: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4ADC: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4AE0: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4AE4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4AE8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4AEC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4AF0: 40980018  bge cr6, 0x824a4b08
	if !ctx.cr[6].lt {
	pc = 0x824A4B08; continue 'dispatch;
	}
	// 824A4AF4: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A4AF8: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4AFC: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4B00: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4B04: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4B08; continue 'dispatch;
            }
            0x824A4B08 => {
    //   block [0x824A4B08..0x824A4B4C)
	// 824A4B08: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4B0C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A4B10: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4B14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4B18: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A4B1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4B20: 4E800421  bctrl
	ctx.lr = 0x824A4B24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A4B24: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4B28: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4B2C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4B30: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4B34: 40980018  bge cr6, 0x824a4b4c
	if !ctx.cr[6].lt {
	pc = 0x824A4B4C; continue 'dispatch;
	}
	// 824A4B38: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A4B3C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4B40: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A4B44: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4B48: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A4B4C => {
    //   block [0x824A4B4C..0x824A4B5C)
	// 824A4B4C: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A4B50: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A4B54: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4B58: 4098FF70  bge cr6, 0x824a4ac8
	if !ctx.cr[6].lt {
	pc = 0x824A4AC8; continue 'dispatch;
	}
	pc = 0x824A4B5C; continue 'dispatch;
            }
            0x824A4B5C => {
    //   block [0x824A4B5C..0x824A4B6C)
	// 824A4B5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A4B60: 4BFFF399  bl 0x824a3ef8
	ctx.lr = 0x824A4B64;
	sub_824A3EF8(ctx, base);
	// 824A4B64: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A4B68: 48090590  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A4B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A4B70 size=228
    let mut pc: u32 = 0x824A4B70;
    'dispatch: loop {
        match pc {
            0x824A4B70 => {
    //   block [0x824A4B70..0x824A4BB0)
	// 824A4B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A4B74: 48090535  bl 0x825350a8
	ctx.lr = 0x824A4B78;
	sub_82535080(ctx, base);
	// 824A4B78: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A4B7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A4B80: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A4B84: 3B830174  addi r28, r3, 0x174
	ctx.r[28].s64 = ctx.r[3].s64 + 372;
	// 824A4B88: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824A4B8C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4B90: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A4B94: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4B98: 419800AC  blt cr6, 0x824a4c44
	if ctx.cr[6].lt {
	pc = 0x824A4C44; continue 'dispatch;
	}
	// 824A4B9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A4BA0: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A4BA4: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A4BA8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A4BAC: 3B0B0648  addi r24, r11, 0x648
	ctx.r[24].s64 = ctx.r[11].s64 + 1608;
	pc = 0x824A4BB0; continue 'dispatch;
            }
            0x824A4BB0 => {
    //   block [0x824A4BB0..0x824A4BF0)
	// 824A4BB0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4BB4: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A4BBC: 419A0078  beq cr6, 0x824a4c34
	if ctx.cr[6].eq {
	pc = 0x824A4C34; continue 'dispatch;
	}
	// 824A4BC0: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4BC4: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4BC8: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4BCC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4BD0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4BD4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4BD8: 40980018  bge cr6, 0x824a4bf0
	if !ctx.cr[6].lt {
	pc = 0x824A4BF0; continue 'dispatch;
	}
	// 824A4BDC: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A4BE0: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4BE4: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4BE8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4BEC: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4BF0; continue 'dispatch;
            }
            0x824A4BF0 => {
    //   block [0x824A4BF0..0x824A4C34)
	// 824A4BF0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4BF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A4BF8: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A4BFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4C00: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4C04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4C08: 4E800421  bctrl
	ctx.lr = 0x824A4C0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A4C0C: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4C10: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4C14: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4C18: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4C1C: 40980018  bge cr6, 0x824a4c34
	if !ctx.cr[6].lt {
	pc = 0x824A4C34; continue 'dispatch;
	}
	// 824A4C20: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A4C24: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4C28: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A4C2C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4C30: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A4C34 => {
    //   block [0x824A4C34..0x824A4C44)
	// 824A4C34: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A4C38: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A4C3C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4C40: 4098FF70  bge cr6, 0x824a4bb0
	if !ctx.cr[6].lt {
	pc = 0x824A4BB0; continue 'dispatch;
	}
	pc = 0x824A4C44; continue 'dispatch;
            }
            0x824A4C44 => {
    //   block [0x824A4C44..0x824A4C54)
	// 824A4C44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A4C48: 4BFFF2B1  bl 0x824a3ef8
	ctx.lr = 0x824A4C4C;
	sub_824A3EF8(ctx, base);
	// 824A4C4C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A4C50: 480904A8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A4C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A4C58 size=220
    let mut pc: u32 = 0x824A4C58;
    'dispatch: loop {
        match pc {
            0x824A4C58 => {
    //   block [0x824A4C58..0x824A4C90)
	// 824A4C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A4C5C: 4809044D  bl 0x825350a8
	ctx.lr = 0x824A4C60;
	sub_82535080(ctx, base);
	// 824A4C60: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A4C64: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824A4C68: 3B9B0120  addi r28, r27, 0x120
	ctx.r[28].s64 = ctx.r[27].s64 + 288;
	// 824A4C6C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4C70: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A4C74: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4C78: 419800AC  blt cr6, 0x824a4d24
	if ctx.cr[6].lt {
	pc = 0x824A4D24; continue 'dispatch;
	}
	// 824A4C7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A4C80: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A4C84: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A4C88: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A4C8C: 3B0B0654  addi r24, r11, 0x654
	ctx.r[24].s64 = ctx.r[11].s64 + 1620;
	pc = 0x824A4C90; continue 'dispatch;
            }
            0x824A4C90 => {
    //   block [0x824A4C90..0x824A4CD0)
	// 824A4C90: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4C94: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A4C98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A4C9C: 419A0078  beq cr6, 0x824a4d14
	if ctx.cr[6].eq {
	pc = 0x824A4D14; continue 'dispatch;
	}
	// 824A4CA0: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4CA4: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4CA8: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4CAC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4CB0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4CB4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4CB8: 40980018  bge cr6, 0x824a4cd0
	if !ctx.cr[6].lt {
	pc = 0x824A4CD0; continue 'dispatch;
	}
	// 824A4CBC: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A4CC0: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4CC4: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4CC8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4CCC: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4CD0; continue 'dispatch;
            }
            0x824A4CD0 => {
    //   block [0x824A4CD0..0x824A4D14)
	// 824A4CD0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4CD4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A4CD8: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A4CDC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4CE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4CE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4CE8: 4E800421  bctrl
	ctx.lr = 0x824A4CEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A4CEC: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4CF0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4CF4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4CF8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4CFC: 40980018  bge cr6, 0x824a4d14
	if !ctx.cr[6].lt {
	pc = 0x824A4D14; continue 'dispatch;
	}
	// 824A4D00: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A4D04: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4D08: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A4D0C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4D10: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A4D14 => {
    //   block [0x824A4D14..0x824A4D24)
	// 824A4D14: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A4D18: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A4D1C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A4D20: 4098FF70  bge cr6, 0x824a4c90
	if !ctx.cr[6].lt {
	pc = 0x824A4C90; continue 'dispatch;
	}
	pc = 0x824A4D24; continue 'dispatch;
            }
            0x824A4D24 => {
    //   block [0x824A4D24..0x824A4D34)
	// 824A4D24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A4D28: 4BFFF1D1  bl 0x824a3ef8
	ctx.lr = 0x824A4D2C;
	sub_824A3EF8(ctx, base);
	// 824A4D2C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A4D30: 480903C8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A4D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A4D38 size=532
    let mut pc: u32 = 0x824A4D38;
    'dispatch: loop {
        match pc {
            0x824A4D38 => {
    //   block [0x824A4D38..0x824A4D80)
	// 824A4D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A4D3C: 48090361  bl 0x8253509c
	ctx.lr = 0x824A4D40;
	sub_82535080(ctx, base);
	// 824A4D40: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A4D44: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 824A4D48: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 824A4D4C: 3BB5012C  addi r29, r21, 0x12c
	ctx.r[29].s64 = ctx.r[21].s64 + 300;
	// 824A4D50: 81750084  lwz r11, 0x84(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A4D54: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A4D58: 91750084  stw r11, 0x84(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A4D5C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4D60: 3B6BFFFF  addi r27, r11, -1
	ctx.r[27].s64 = ctx.r[11].s64 + -1;
	// 824A4D64: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A4D68: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 824A4D6C: 3ACB74DC  addi r22, r11, 0x74dc
	ctx.r[22].s64 = ctx.r[11].s64 + 29916;
	// 824A4D70: 419800A4  blt cr6, 0x824a4e14
	if ctx.cr[6].lt {
	pc = 0x824A4E14; continue 'dispatch;
	}
	// 824A4D74: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A4D78: 577C103A  slwi r28, r27, 2
	ctx.r[28].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 824A4D7C: 3B2B0670  addi r25, r11, 0x670
	ctx.r[25].s64 = ctx.r[11].s64 + 1648;
	pc = 0x824A4D80; continue 'dispatch;
            }
            0x824A4D80 => {
    //   block [0x824A4D80..0x824A4DC0)
	// 824A4D80: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4D84: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A4D88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A4D8C: 419A0078  beq cr6, 0x824a4e04
	if ctx.cr[6].eq {
	pc = 0x824A4E04; continue 'dispatch;
	}
	// 824A4D90: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4D94: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4D98: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4D9C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4DA0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4DA4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4DA8: 40980018  bge cr6, 0x824a4dc0
	if !ctx.cr[6].lt {
	pc = 0x824A4DC0; continue 'dispatch;
	}
	// 824A4DAC: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A4DB0: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4DB4: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4DB8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4DBC: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4DC0; continue 'dispatch;
            }
            0x824A4DC0 => {
    //   block [0x824A4DC0..0x824A4E04)
	// 824A4DC0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4DC4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 824A4DC8: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A4DCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4DD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4DD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4DD8: 4E800421  bctrl
	ctx.lr = 0x824A4DDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A4DDC: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4DE0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4DE4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4DE8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4DEC: 40980018  bge cr6, 0x824a4e04
	if !ctx.cr[6].lt {
	pc = 0x824A4E04; continue 'dispatch;
	}
	// 824A4DF0: 92CA0000  stw r22, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 824A4DF4: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4DF8: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A4DFC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4E00: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A4E04 => {
    //   block [0x824A4E04..0x824A4E14)
	// 824A4E04: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 824A4E08: 3B9CFFFC  addi r28, r28, -4
	ctx.r[28].s64 = ctx.r[28].s64 + -4;
	// 824A4E0C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 824A4E10: 4098FF70  bge cr6, 0x824a4d80
	if !ctx.cr[6].lt {
	pc = 0x824A4D80; continue 'dispatch;
	}
	pc = 0x824A4E14; continue 'dispatch;
            }
            0x824A4E14 => {
    //   block [0x824A4E14..0x824A4E38)
	// 824A4E14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824A4E18: 4BFFF0E1  bl 0x824a3ef8
	ctx.lr = 0x824A4E1C;
	sub_824A3EF8(ctx, base);
	// 824A4E1C: 817A004C  lwz r11, 0x4c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A4E20: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 824A4E24: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A4E28: 409900EC  ble cr6, 0x824a4f14
	if !ctx.cr[6].gt {
	pc = 0x824A4F14; continue 'dispatch;
	}
	// 824A4E2C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A4E30: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 824A4E34: 3B0B0664  addi r24, r11, 0x664
	ctx.r[24].s64 = ctx.r[11].s64 + 1636;
	pc = 0x824A4E38; continue 'dispatch;
            }
            0x824A4E38 => {
    //   block [0x824A4E38..0x824A4E60)
	// 824A4E38: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 824A4E3C: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 824A4E40: 838B00CC  lwz r28, 0xcc(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(204 as u32) ) } as u64;
	// 824A4E44: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 824A4E48: 419A00B8  beq cr6, 0x824a4f00
	if ctx.cr[6].eq {
	pc = 0x824A4F00; continue 'dispatch;
	}
	// 824A4E4C: A17C0004  lhz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4E50: 3B2BFFFF  addi r25, r11, -1
	ctx.r[25].s64 = ctx.r[11].s64 + -1;
	// 824A4E54: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A4E58: 419800A0  blt cr6, 0x824a4ef8
	if ctx.cr[6].lt {
	pc = 0x824A4EF8; continue 'dispatch;
	}
	// 824A4E5C: 573D103A  slwi r29, r25, 2
	ctx.r[29].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	pc = 0x824A4E60; continue 'dispatch;
            }
            0x824A4E60 => {
    //   block [0x824A4E60..0x824A4EA0)
	// 824A4E60: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4E64: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A4E68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A4E6C: 419A007C  beq cr6, 0x824a4ee8
	if ctx.cr[6].eq {
	pc = 0x824A4EE8; continue 'dispatch;
	}
	// 824A4E70: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4E74: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4E78: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4E7C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4E80: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4E84: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4E88: 40980018  bge cr6, 0x824a4ea0
	if !ctx.cr[6].lt {
	pc = 0x824A4EA0; continue 'dispatch;
	}
	// 824A4E8C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A4E90: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4E94: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4E98: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4E9C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4EA0; continue 'dispatch;
            }
            0x824A4EA0 => {
    //   block [0x824A4EA0..0x824A4EE8)
	// 824A4EA0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4EA4: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 824A4EA8: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A4EAC: 7C8AD82E  lwzx r4, r10, r27
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 824A4EB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4EB4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A4EB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4EBC: 4E800421  bctrl
	ctx.lr = 0x824A4EC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A4EC0: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4EC4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4EC8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4ECC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4ED0: 40980018  bge cr6, 0x824a4ee8
	if !ctx.cr[6].lt {
	pc = 0x824A4EE8; continue 'dispatch;
	}
	// 824A4ED4: 92CA0000  stw r22, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 824A4ED8: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4EDC: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A4EE0: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4EE4: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A4EE8 => {
    //   block [0x824A4EE8..0x824A4EF8)
	// 824A4EE8: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 824A4EEC: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A4EF0: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A4EF4: 4098FF6C  bge cr6, 0x824a4e60
	if !ctx.cr[6].lt {
	pc = 0x824A4E60; continue 'dispatch;
	}
	pc = 0x824A4EF8; continue 'dispatch;
            }
            0x824A4EF8 => {
    //   block [0x824A4EF8..0x824A4F00)
	// 824A4EF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A4EFC: 4BFFF075  bl 0x824a3f70
	ctx.lr = 0x824A4F00;
	sub_824A3F70(ctx, base);
	pc = 0x824A4F00; continue 'dispatch;
            }
            0x824A4F00 => {
    //   block [0x824A4F00..0x824A4F14)
	// 824A4F00: 817A004C  lwz r11, 0x4c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A4F04: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 824A4F08: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 824A4F0C: 7F175800  cmpw cr6, r23, r11
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A4F10: 4198FF28  blt cr6, 0x824a4e38
	if ctx.cr[6].lt {
	pc = 0x824A4E38; continue 'dispatch;
	}
	pc = 0x824A4F14; continue 'dispatch;
            }
            0x824A4F14 => {
    //   block [0x824A4F14..0x824A4F44)
	// 824A4F14: 81750084  lwz r11, 0x84(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A4F18: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A4F1C: 91750084  stw r11, 0x84(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A4F20: 40820024  bne 0x824a4f44
	if !ctx.cr[0].eq {
	pc = 0x824A4F44; continue 'dispatch;
	}
	// 824A4F24: 8975008C  lbz r11, 0x8c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A4F28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A4F2C: 409A0018  bne cr6, 0x824a4f44
	if !ctx.cr[6].eq {
	pc = 0x824A4F44; continue 'dispatch;
	}
	// 824A4F30: 81750080  lwz r11, 0x80(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A4F34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A4F38: 419A000C  beq cr6, 0x824a4f44
	if ctx.cr[6].eq {
	pc = 0x824A4F44; continue 'dispatch;
	}
	// 824A4F3C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 824A4F40: 4BFEE281  bl 0x824931c0
	ctx.lr = 0x824A4F44;
	sub_824931C0(ctx, base);
	pc = 0x824A4F44; continue 'dispatch;
            }
            0x824A4F44 => {
    //   block [0x824A4F44..0x824A4F4C)
	// 824A4F44: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 824A4F48: 480901A4  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A4F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A4F50 size=532
    let mut pc: u32 = 0x824A4F50;
    'dispatch: loop {
        match pc {
            0x824A4F50 => {
    //   block [0x824A4F50..0x824A4F98)
	// 824A4F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A4F54: 48090149  bl 0x8253509c
	ctx.lr = 0x824A4F58;
	sub_82535080(ctx, base);
	// 824A4F58: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A4F5C: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 824A4F60: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 824A4F64: 3BB5012C  addi r29, r21, 0x12c
	ctx.r[29].s64 = ctx.r[21].s64 + 300;
	// 824A4F68: 81750084  lwz r11, 0x84(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A4F6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A4F70: 91750084  stw r11, 0x84(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A4F74: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4F78: 3B6BFFFF  addi r27, r11, -1
	ctx.r[27].s64 = ctx.r[11].s64 + -1;
	// 824A4F7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A4F80: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 824A4F84: 3ACB74DC  addi r22, r11, 0x74dc
	ctx.r[22].s64 = ctx.r[11].s64 + 29916;
	// 824A4F88: 419800A4  blt cr6, 0x824a502c
	if ctx.cr[6].lt {
	pc = 0x824A502C; continue 'dispatch;
	}
	// 824A4F8C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A4F90: 577C103A  slwi r28, r27, 2
	ctx.r[28].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 824A4F94: 3B2B0688  addi r25, r11, 0x688
	ctx.r[25].s64 = ctx.r[11].s64 + 1672;
	pc = 0x824A4F98; continue 'dispatch;
            }
            0x824A4F98 => {
    //   block [0x824A4F98..0x824A4FD8)
	// 824A4F98: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4F9C: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A4FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A4FA4: 419A0078  beq cr6, 0x824a501c
	if ctx.cr[6].eq {
	pc = 0x824A501C; continue 'dispatch;
	}
	// 824A4FA8: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4FAC: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A4FB0: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4FB4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4FB8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A4FBC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A4FC0: 40980018  bge cr6, 0x824a4fd8
	if !ctx.cr[6].lt {
	pc = 0x824A4FD8; continue 'dispatch;
	}
	// 824A4FC4: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A4FC8: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A4FCC: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A4FD0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A4FD4: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A4FD8; continue 'dispatch;
            }
            0x824A4FD8 => {
    //   block [0x824A4FD8..0x824A501C)
	// 824A4FD8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4FDC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 824A4FE0: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A4FE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A4FE8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A4FEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A4FF0: 4E800421  bctrl
	ctx.lr = 0x824A4FF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A4FF4: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A4FF8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A4FFC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5000: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5004: 40980018  bge cr6, 0x824a501c
	if !ctx.cr[6].lt {
	pc = 0x824A501C; continue 'dispatch;
	}
	// 824A5008: 92CA0000  stw r22, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 824A500C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5010: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A5014: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5018: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A501C => {
    //   block [0x824A501C..0x824A502C)
	// 824A501C: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 824A5020: 3B9CFFFC  addi r28, r28, -4
	ctx.r[28].s64 = ctx.r[28].s64 + -4;
	// 824A5024: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 824A5028: 4098FF70  bge cr6, 0x824a4f98
	if !ctx.cr[6].lt {
	pc = 0x824A4F98; continue 'dispatch;
	}
	pc = 0x824A502C; continue 'dispatch;
            }
            0x824A502C => {
    //   block [0x824A502C..0x824A5050)
	// 824A502C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824A5030: 4BFFEEC9  bl 0x824a3ef8
	ctx.lr = 0x824A5034;
	sub_824A3EF8(ctx, base);
	// 824A5034: 817A004C  lwz r11, 0x4c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A5038: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 824A503C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A5040: 409900EC  ble cr6, 0x824a512c
	if !ctx.cr[6].gt {
	pc = 0x824A512C; continue 'dispatch;
	}
	// 824A5044: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A5048: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 824A504C: 3B0B067C  addi r24, r11, 0x67c
	ctx.r[24].s64 = ctx.r[11].s64 + 1660;
	pc = 0x824A5050; continue 'dispatch;
            }
            0x824A5050 => {
    //   block [0x824A5050..0x824A5078)
	// 824A5050: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 824A5054: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 824A5058: 838B00CC  lwz r28, 0xcc(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(204 as u32) ) } as u64;
	// 824A505C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 824A5060: 419A00B8  beq cr6, 0x824a5118
	if ctx.cr[6].eq {
	pc = 0x824A5118; continue 'dispatch;
	}
	// 824A5064: A17C0004  lhz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5068: 3B2BFFFF  addi r25, r11, -1
	ctx.r[25].s64 = ctx.r[11].s64 + -1;
	// 824A506C: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A5070: 419800A0  blt cr6, 0x824a5110
	if ctx.cr[6].lt {
	pc = 0x824A5110; continue 'dispatch;
	}
	// 824A5074: 573D103A  slwi r29, r25, 2
	ctx.r[29].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	pc = 0x824A5078; continue 'dispatch;
            }
            0x824A5078 => {
    //   block [0x824A5078..0x824A50B8)
	// 824A5078: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A507C: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A5080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A5084: 419A007C  beq cr6, 0x824a5100
	if ctx.cr[6].eq {
	pc = 0x824A5100; continue 'dispatch;
	}
	// 824A5088: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A508C: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A5090: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A5094: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5098: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A509C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A50A0: 40980018  bge cr6, 0x824a50b8
	if !ctx.cr[6].lt {
	pc = 0x824A50B8; continue 'dispatch;
	}
	// 824A50A4: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A50A8: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A50AC: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A50B0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A50B4: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A50B8; continue 'dispatch;
            }
            0x824A50B8 => {
    //   block [0x824A50B8..0x824A5100)
	// 824A50B8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A50BC: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 824A50C0: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A50C4: 7C8AD82E  lwzx r4, r10, r27
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 824A50C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A50CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A50D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A50D4: 4E800421  bctrl
	ctx.lr = 0x824A50D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A50D8: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A50DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A50E0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A50E4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A50E8: 40980018  bge cr6, 0x824a5100
	if !ctx.cr[6].lt {
	pc = 0x824A5100; continue 'dispatch;
	}
	// 824A50EC: 92CA0000  stw r22, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 824A50F0: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A50F4: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A50F8: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A50FC: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A5100 => {
    //   block [0x824A5100..0x824A5110)
	// 824A5100: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 824A5104: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A5108: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A510C: 4098FF6C  bge cr6, 0x824a5078
	if !ctx.cr[6].lt {
	pc = 0x824A5078; continue 'dispatch;
	}
	pc = 0x824A5110; continue 'dispatch;
            }
            0x824A5110 => {
    //   block [0x824A5110..0x824A5118)
	// 824A5110: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A5114: 4BFFEE5D  bl 0x824a3f70
	ctx.lr = 0x824A5118;
	sub_824A3F70(ctx, base);
	pc = 0x824A5118; continue 'dispatch;
            }
            0x824A5118 => {
    //   block [0x824A5118..0x824A512C)
	// 824A5118: 817A004C  lwz r11, 0x4c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A511C: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 824A5120: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 824A5124: 7F175800  cmpw cr6, r23, r11
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A5128: 4198FF28  blt cr6, 0x824a5050
	if ctx.cr[6].lt {
	pc = 0x824A5050; continue 'dispatch;
	}
	pc = 0x824A512C; continue 'dispatch;
            }
            0x824A512C => {
    //   block [0x824A512C..0x824A515C)
	// 824A512C: 81750084  lwz r11, 0x84(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A5130: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A5134: 91750084  stw r11, 0x84(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A5138: 40820024  bne 0x824a515c
	if !ctx.cr[0].eq {
	pc = 0x824A515C; continue 'dispatch;
	}
	// 824A513C: 8975008C  lbz r11, 0x8c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A5140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A5144: 409A0018  bne cr6, 0x824a515c
	if !ctx.cr[6].eq {
	pc = 0x824A515C; continue 'dispatch;
	}
	// 824A5148: 81750080  lwz r11, 0x80(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A514C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A5150: 419A000C  beq cr6, 0x824a515c
	if ctx.cr[6].eq {
	pc = 0x824A515C; continue 'dispatch;
	}
	// 824A5154: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 824A5158: 4BFEE069  bl 0x824931c0
	ctx.lr = 0x824A515C;
	sub_824931C0(ctx, base);
	pc = 0x824A515C; continue 'dispatch;
            }
            0x824A515C => {
    //   block [0x824A515C..0x824A5164)
	// 824A515C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 824A5160: 4808FF8C  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A5168 size=248
    let mut pc: u32 = 0x824A5168;
    'dispatch: loop {
        match pc {
            0x824A5168 => {
    //   block [0x824A5168..0x824A51A0)
	// 824A5168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A516C: 4808FF3D  bl 0x825350a8
	ctx.lr = 0x824A5170;
	sub_82535080(ctx, base);
	// 824A5170: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A5174: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 824A5178: 3BBA0138  addi r29, r26, 0x138
	ctx.r[29].s64 = ctx.r[26].s64 + 312;
	// 824A517C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5180: 3B8BFFFF  addi r28, r11, -1
	ctx.r[28].s64 = ctx.r[11].s64 + -1;
	// 824A5184: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 824A5188: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 824A518C: 419800C4  blt cr6, 0x824a5250
	if ctx.cr[6].lt {
	pc = 0x824A5250; continue 'dispatch;
	}
	// 824A5190: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A5194: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A5198: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A519C: 3B0B0694  addi r24, r11, 0x694
	ctx.r[24].s64 = ctx.r[11].s64 + 1684;
	pc = 0x824A51A0; continue 'dispatch;
            }
            0x824A51A0 => {
    //   block [0x824A51A0..0x824A51BC)
	// 824A51A0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A51A4: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A51A8: 40990014  ble cr6, 0x824a51bc
	if !ctx.cr[6].gt {
	pc = 0x824A51BC; continue 'dispatch;
	}
	// 824A51AC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A51B0: 7D5B5850  subf r10, r27, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 824A51B4: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 824A51B8: 7F8AE214  add r28, r10, r28
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	pc = 0x824A51BC; continue 'dispatch;
            }
            0x824A51BC => {
    //   block [0x824A51BC..0x824A5200)
	// 824A51BC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A51C0: 5789103A  slwi r9, r28, 2
	ctx.r[9].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824A51C4: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 824A51C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A51CC: 419A0078  beq cr6, 0x824a5244
	if ctx.cr[6].eq {
	pc = 0x824A5244; continue 'dispatch;
	}
	// 824A51D0: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A51D4: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A51D8: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A51DC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A51E0: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A51E4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824A51E8: 40980018  bge cr6, 0x824a5200
	if !ctx.cr[6].lt {
	pc = 0x824A5200; continue 'dispatch;
	}
	// 824A51EC: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A51F0: 7D0C42E6  mftb r8, 0x10c
	ctx.r[8].u64 = crate::rt::rdtsc_u64();
	// 824A51F4: 38EB000C  addi r7, r11, 0xc
	ctx.r[7].s64 = ctx.r[11].s64 + 12;
	// 824A51F8: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A51FC: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x824A5200; continue 'dispatch;
            }
            0x824A5200 => {
    //   block [0x824A5200..0x824A5244)
	// 824A5200: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5204: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 824A5208: 7C6B482E  lwzx r3, r11, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 824A520C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5210: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5214: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A5218: 4E800421  bctrl
	ctx.lr = 0x824A521C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A521C: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A5220: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5224: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5228: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A522C: 40980018  bge cr6, 0x824a5244
	if !ctx.cr[6].lt {
	pc = 0x824A5244; continue 'dispatch;
	}
	// 824A5230: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A5234: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5238: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A523C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5240: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A5244 => {
    //   block [0x824A5244..0x824A5250)
	// 824A5244: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 824A5248: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 824A524C: 4098FF54  bge cr6, 0x824a51a0
	if !ctx.cr[6].lt {
	pc = 0x824A51A0; continue 'dispatch;
	}
	pc = 0x824A5250; continue 'dispatch;
            }
            0x824A5250 => {
    //   block [0x824A5250..0x824A5260)
	// 824A5250: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824A5254: 4BFFECA5  bl 0x824a3ef8
	ctx.lr = 0x824A5258;
	sub_824A3EF8(ctx, base);
	// 824A5258: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A525C: 4808FE9C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A5260 size=228
    let mut pc: u32 = 0x824A5260;
    'dispatch: loop {
        match pc {
            0x824A5260 => {
    //   block [0x824A5260..0x824A529C)
	// 824A5260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A5264: 4808FE41  bl 0x825350a4
	ctx.lr = 0x824A5268;
	sub_82535080(ctx, base);
	// 824A5268: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A526C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824A5270: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 824A5274: 3B9B0144  addi r28, r27, 0x144
	ctx.r[28].s64 = ctx.r[27].s64 + 324;
	// 824A5278: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A527C: 3B2BFFFF  addi r25, r11, -1
	ctx.r[25].s64 = ctx.r[11].s64 + -1;
	// 824A5280: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A5284: 419800B0  blt cr6, 0x824a5334
	if ctx.cr[6].lt {
	pc = 0x824A5334; continue 'dispatch;
	}
	// 824A5288: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A528C: 573D103A  slwi r29, r25, 2
	ctx.r[29].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A5290: 3B0B74DC  addi r24, r11, 0x74dc
	ctx.r[24].s64 = ctx.r[11].s64 + 29916;
	// 824A5294: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A5298: 3AEB06A0  addi r23, r11, 0x6a0
	ctx.r[23].s64 = ctx.r[11].s64 + 1696;
	pc = 0x824A529C; continue 'dispatch;
            }
            0x824A529C => {
    //   block [0x824A529C..0x824A52DC)
	// 824A529C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A52A0: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A52A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A52A8: 419A007C  beq cr6, 0x824a5324
	if ctx.cr[6].eq {
	pc = 0x824A5324; continue 'dispatch;
	}
	// 824A52AC: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A52B0: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A52B4: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A52B8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A52BC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A52C0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A52C4: 40980018  bge cr6, 0x824a52dc
	if !ctx.cr[6].lt {
	pc = 0x824A52DC; continue 'dispatch;
	}
	// 824A52C8: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 824A52CC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A52D0: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A52D4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A52D8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A52DC; continue 'dispatch;
            }
            0x824A52DC => {
    //   block [0x824A52DC..0x824A5324)
	// 824A52DC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A52E0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 824A52E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A52E8: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A52EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A52F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A52F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A52F8: 4E800421  bctrl
	ctx.lr = 0x824A52FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A52FC: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A5300: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5304: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5308: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A530C: 40980018  bge cr6, 0x824a5324
	if !ctx.cr[6].lt {
	pc = 0x824A5324; continue 'dispatch;
	}
	// 824A5310: 930A0000  stw r24, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A5314: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5318: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A531C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5320: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A5324 => {
    //   block [0x824A5324..0x824A5334)
	// 824A5324: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 824A5328: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A532C: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A5330: 4098FF6C  bge cr6, 0x824a529c
	if !ctx.cr[6].lt {
	pc = 0x824A529C; continue 'dispatch;
	}
	pc = 0x824A5334; continue 'dispatch;
            }
            0x824A5334 => {
    //   block [0x824A5334..0x824A5344)
	// 824A5334: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A5338: 4BFFEBC1  bl 0x824a3ef8
	ctx.lr = 0x824A533C;
	sub_824A3EF8(ctx, base);
	// 824A533C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A5340: 4808FDB4  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A5348 size=228
    let mut pc: u32 = 0x824A5348;
    'dispatch: loop {
        match pc {
            0x824A5348 => {
    //   block [0x824A5348..0x824A5384)
	// 824A5348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A534C: 4808FD59  bl 0x825350a4
	ctx.lr = 0x824A5350;
	sub_82535080(ctx, base);
	// 824A5350: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A5354: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824A5358: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 824A535C: 3B9B0150  addi r28, r27, 0x150
	ctx.r[28].s64 = ctx.r[27].s64 + 336;
	// 824A5360: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5364: 3B2BFFFF  addi r25, r11, -1
	ctx.r[25].s64 = ctx.r[11].s64 + -1;
	// 824A5368: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A536C: 419800B0  blt cr6, 0x824a541c
	if ctx.cr[6].lt {
	pc = 0x824A541C; continue 'dispatch;
	}
	// 824A5370: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A5374: 573D103A  slwi r29, r25, 2
	ctx.r[29].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A5378: 3B0B74DC  addi r24, r11, 0x74dc
	ctx.r[24].s64 = ctx.r[11].s64 + 29916;
	// 824A537C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A5380: 3AEB06AC  addi r23, r11, 0x6ac
	ctx.r[23].s64 = ctx.r[11].s64 + 1708;
	pc = 0x824A5384; continue 'dispatch;
            }
            0x824A5384 => {
    //   block [0x824A5384..0x824A53C4)
	// 824A5384: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5388: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A538C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A5390: 419A007C  beq cr6, 0x824a540c
	if ctx.cr[6].eq {
	pc = 0x824A540C; continue 'dispatch;
	}
	// 824A5394: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5398: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A539C: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A53A0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A53A4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A53A8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A53AC: 40980018  bge cr6, 0x824a53c4
	if !ctx.cr[6].lt {
	pc = 0x824A53C4; continue 'dispatch;
	}
	// 824A53B0: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 824A53B4: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A53B8: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A53BC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A53C0: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A53C4; continue 'dispatch;
            }
            0x824A53C4 => {
    //   block [0x824A53C4..0x824A540C)
	// 824A53C4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A53C8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 824A53CC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A53D0: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A53D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A53D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A53DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A53E0: 4E800421  bctrl
	ctx.lr = 0x824A53E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A53E4: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A53E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A53EC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A53F0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A53F4: 40980018  bge cr6, 0x824a540c
	if !ctx.cr[6].lt {
	pc = 0x824A540C; continue 'dispatch;
	}
	// 824A53F8: 930A0000  stw r24, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A53FC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5400: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A5404: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5408: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A540C => {
    //   block [0x824A540C..0x824A541C)
	// 824A540C: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 824A5410: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A5414: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A5418: 4098FF6C  bge cr6, 0x824a5384
	if !ctx.cr[6].lt {
	pc = 0x824A5384; continue 'dispatch;
	}
	pc = 0x824A541C; continue 'dispatch;
            }
            0x824A541C => {
    //   block [0x824A541C..0x824A542C)
	// 824A541C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A5420: 4BFFEAD9  bl 0x824a3ef8
	ctx.lr = 0x824A5424;
	sub_824A3EF8(ctx, base);
	// 824A5424: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A5428: 4808FCCC  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A5430 size=228
    let mut pc: u32 = 0x824A5430;
    'dispatch: loop {
        match pc {
            0x824A5430 => {
    //   block [0x824A5430..0x824A546C)
	// 824A5430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A5434: 4808FC71  bl 0x825350a4
	ctx.lr = 0x824A5438;
	sub_82535080(ctx, base);
	// 824A5438: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A543C: 3B83015C  addi r28, r3, 0x15c
	ctx.r[28].s64 = ctx.r[3].s64 + 348;
	// 824A5440: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A5444: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 824A5448: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A544C: 3B2BFFFF  addi r25, r11, -1
	ctx.r[25].s64 = ctx.r[11].s64 + -1;
	// 824A5450: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A5454: 419800B0  blt cr6, 0x824a5504
	if ctx.cr[6].lt {
	pc = 0x824A5504; continue 'dispatch;
	}
	// 824A5458: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A545C: 573D103A  slwi r29, r25, 2
	ctx.r[29].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A5460: 3B0B74DC  addi r24, r11, 0x74dc
	ctx.r[24].s64 = ctx.r[11].s64 + 29916;
	// 824A5464: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A5468: 3AEB06A0  addi r23, r11, 0x6a0
	ctx.r[23].s64 = ctx.r[11].s64 + 1696;
	pc = 0x824A546C; continue 'dispatch;
            }
            0x824A546C => {
    //   block [0x824A546C..0x824A54AC)
	// 824A546C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5470: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A5474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A5478: 419A007C  beq cr6, 0x824a54f4
	if ctx.cr[6].eq {
	pc = 0x824A54F4; continue 'dispatch;
	}
	// 824A547C: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5480: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A5484: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A5488: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A548C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5490: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5494: 40980018  bge cr6, 0x824a54ac
	if !ctx.cr[6].lt {
	pc = 0x824A54AC; continue 'dispatch;
	}
	// 824A5498: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 824A549C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A54A0: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A54A4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A54A8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A54AC; continue 'dispatch;
            }
            0x824A54AC => {
    //   block [0x824A54AC..0x824A54F4)
	// 824A54AC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A54B0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 824A54B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A54B8: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A54BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A54C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A54C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A54C8: 4E800421  bctrl
	ctx.lr = 0x824A54CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A54CC: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A54D0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A54D4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A54D8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A54DC: 40980018  bge cr6, 0x824a54f4
	if !ctx.cr[6].lt {
	pc = 0x824A54F4; continue 'dispatch;
	}
	// 824A54E0: 930A0000  stw r24, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A54E4: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A54E8: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A54EC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A54F0: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A54F4 => {
    //   block [0x824A54F4..0x824A5504)
	// 824A54F4: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 824A54F8: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A54FC: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A5500: 4098FF6C  bge cr6, 0x824a546c
	if !ctx.cr[6].lt {
	pc = 0x824A546C; continue 'dispatch;
	}
	pc = 0x824A5504; continue 'dispatch;
            }
            0x824A5504 => {
    //   block [0x824A5504..0x824A5514)
	// 824A5504: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A5508: 4BFFE9F1  bl 0x824a3ef8
	ctx.lr = 0x824A550C;
	sub_824A3EF8(ctx, base);
	// 824A550C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A5510: 4808FBE4  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A5518 size=228
    let mut pc: u32 = 0x824A5518;
    'dispatch: loop {
        match pc {
            0x824A5518 => {
    //   block [0x824A5518..0x824A5554)
	// 824A5518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A551C: 4808FB89  bl 0x825350a4
	ctx.lr = 0x824A5520;
	sub_82535080(ctx, base);
	// 824A5520: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A5524: 3B830168  addi r28, r3, 0x168
	ctx.r[28].s64 = ctx.r[3].s64 + 360;
	// 824A5528: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A552C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 824A5530: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5534: 3B2BFFFF  addi r25, r11, -1
	ctx.r[25].s64 = ctx.r[11].s64 + -1;
	// 824A5538: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A553C: 419800B0  blt cr6, 0x824a55ec
	if ctx.cr[6].lt {
	pc = 0x824A55EC; continue 'dispatch;
	}
	// 824A5540: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A5544: 573D103A  slwi r29, r25, 2
	ctx.r[29].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A5548: 3B0B74DC  addi r24, r11, 0x74dc
	ctx.r[24].s64 = ctx.r[11].s64 + 29916;
	// 824A554C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A5550: 3AEB06AC  addi r23, r11, 0x6ac
	ctx.r[23].s64 = ctx.r[11].s64 + 1708;
	pc = 0x824A5554; continue 'dispatch;
            }
            0x824A5554 => {
    //   block [0x824A5554..0x824A5594)
	// 824A5554: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5558: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A555C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A5560: 419A007C  beq cr6, 0x824a55dc
	if ctx.cr[6].eq {
	pc = 0x824A55DC; continue 'dispatch;
	}
	// 824A5564: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5568: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A556C: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A5570: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5574: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5578: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A557C: 40980018  bge cr6, 0x824a5594
	if !ctx.cr[6].lt {
	pc = 0x824A5594; continue 'dispatch;
	}
	// 824A5580: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 824A5584: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5588: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A558C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5590: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A5594; continue 'dispatch;
            }
            0x824A5594 => {
    //   block [0x824A5594..0x824A55DC)
	// 824A5594: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5598: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 824A559C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A55A0: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A55A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A55A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A55AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A55B0: 4E800421  bctrl
	ctx.lr = 0x824A55B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A55B4: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A55B8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A55BC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A55C0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A55C4: 40980018  bge cr6, 0x824a55dc
	if !ctx.cr[6].lt {
	pc = 0x824A55DC; continue 'dispatch;
	}
	// 824A55C8: 930A0000  stw r24, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A55CC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A55D0: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A55D4: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A55D8: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A55DC => {
    //   block [0x824A55DC..0x824A55EC)
	// 824A55DC: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 824A55E0: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A55E4: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A55E8: 4098FF6C  bge cr6, 0x824a5554
	if !ctx.cr[6].lt {
	pc = 0x824A5554; continue 'dispatch;
	}
	pc = 0x824A55EC; continue 'dispatch;
            }
            0x824A55EC => {
    //   block [0x824A55EC..0x824A55FC)
	// 824A55EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A55F0: 4BFFE909  bl 0x824a3ef8
	ctx.lr = 0x824A55F4;
	sub_824A3EF8(ctx, base);
	// 824A55F4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A55F8: 4808FAFC  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A5600 size=228
    let mut pc: u32 = 0x824A5600;
    'dispatch: loop {
        match pc {
            0x824A5600 => {
    //   block [0x824A5600..0x824A563C)
	// 824A5600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A5604: 4808FAA1  bl 0x825350a4
	ctx.lr = 0x824A5608;
	sub_82535080(ctx, base);
	// 824A5608: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A560C: 3B830180  addi r28, r3, 0x180
	ctx.r[28].s64 = ctx.r[3].s64 + 384;
	// 824A5610: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A5614: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 824A5618: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A561C: 3B2BFFFF  addi r25, r11, -1
	ctx.r[25].s64 = ctx.r[11].s64 + -1;
	// 824A5620: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A5624: 419800B0  blt cr6, 0x824a56d4
	if ctx.cr[6].lt {
	pc = 0x824A56D4; continue 'dispatch;
	}
	// 824A5628: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A562C: 573D103A  slwi r29, r25, 2
	ctx.r[29].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A5630: 3B0B74DC  addi r24, r11, 0x74dc
	ctx.r[24].s64 = ctx.r[11].s64 + 29916;
	// 824A5634: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A5638: 3AEB06BC  addi r23, r11, 0x6bc
	ctx.r[23].s64 = ctx.r[11].s64 + 1724;
	pc = 0x824A563C; continue 'dispatch;
            }
            0x824A563C => {
    //   block [0x824A563C..0x824A567C)
	// 824A563C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5640: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A5644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A5648: 419A007C  beq cr6, 0x824a56c4
	if ctx.cr[6].eq {
	pc = 0x824A56C4; continue 'dispatch;
	}
	// 824A564C: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5650: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A5654: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A5658: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A565C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5660: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5664: 40980018  bge cr6, 0x824a567c
	if !ctx.cr[6].lt {
	pc = 0x824A567C; continue 'dispatch;
	}
	// 824A5668: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 824A566C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5670: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A5674: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5678: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A567C; continue 'dispatch;
            }
            0x824A567C => {
    //   block [0x824A567C..0x824A56C4)
	// 824A567C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5680: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 824A5684: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A5688: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A568C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5690: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5694: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A5698: 4E800421  bctrl
	ctx.lr = 0x824A569C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A569C: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A56A0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A56A4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A56A8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A56AC: 40980018  bge cr6, 0x824a56c4
	if !ctx.cr[6].lt {
	pc = 0x824A56C4; continue 'dispatch;
	}
	// 824A56B0: 930A0000  stw r24, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A56B4: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A56B8: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A56BC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A56C0: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A56C4 => {
    //   block [0x824A56C4..0x824A56D4)
	// 824A56C4: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 824A56C8: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A56CC: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824A56D0: 4098FF6C  bge cr6, 0x824a563c
	if !ctx.cr[6].lt {
	pc = 0x824A563C; continue 'dispatch;
	}
	pc = 0x824A56D4; continue 'dispatch;
            }
            0x824A56D4 => {
    //   block [0x824A56D4..0x824A56E4)
	// 824A56D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A56D8: 4BFFE821  bl 0x824a3ef8
	ctx.lr = 0x824A56DC;
	sub_824A3EF8(ctx, base);
	// 824A56DC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A56E0: 4808FA14  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A56E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A56E8 size=220
    let mut pc: u32 = 0x824A56E8;
    'dispatch: loop {
        match pc {
            0x824A56E8 => {
    //   block [0x824A56E8..0x824A5720)
	// 824A56E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A56EC: 4808F9BD  bl 0x825350a8
	ctx.lr = 0x824A56F0;
	sub_82535080(ctx, base);
	// 824A56F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A56F4: 3B830138  addi r28, r3, 0x138
	ctx.r[28].s64 = ctx.r[3].s64 + 312;
	// 824A56F8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A56FC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5700: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824A5704: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A5708: 419800AC  blt cr6, 0x824a57b4
	if ctx.cr[6].lt {
	pc = 0x824A57B4; continue 'dispatch;
	}
	// 824A570C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A5710: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824A5714: 3B2B74DC  addi r25, r11, 0x74dc
	ctx.r[25].s64 = ctx.r[11].s64 + 29916;
	// 824A5718: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A571C: 3B0B06CC  addi r24, r11, 0x6cc
	ctx.r[24].s64 = ctx.r[11].s64 + 1740;
	pc = 0x824A5720; continue 'dispatch;
            }
            0x824A5720 => {
    //   block [0x824A5720..0x824A5760)
	// 824A5720: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5724: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A5728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A572C: 419A0078  beq cr6, 0x824a57a4
	if ctx.cr[6].eq {
	pc = 0x824A57A4; continue 'dispatch;
	}
	// 824A5730: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5734: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A5738: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A573C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5740: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5744: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5748: 40980018  bge cr6, 0x824a5760
	if !ctx.cr[6].lt {
	pc = 0x824A5760; continue 'dispatch;
	}
	// 824A574C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824A5750: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5754: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A5758: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A575C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A5760; continue 'dispatch;
            }
            0x824A5760 => {
    //   block [0x824A5760..0x824A57A4)
	// 824A5760: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5764: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A5768: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A576C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5770: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A5774: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A5778: 4E800421  bctrl
	ctx.lr = 0x824A577C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A577C: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A5780: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5784: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5788: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A578C: 40980018  bge cr6, 0x824a57a4
	if !ctx.cr[6].lt {
	pc = 0x824A57A4; continue 'dispatch;
	}
	// 824A5790: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 824A5794: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5798: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A579C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A57A0: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A57A4 => {
    //   block [0x824A57A4..0x824A57B4)
	// 824A57A4: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824A57A8: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 824A57AC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824A57B0: 4098FF70  bge cr6, 0x824a5720
	if !ctx.cr[6].lt {
	pc = 0x824A5720; continue 'dispatch;
	}
	pc = 0x824A57B4; continue 'dispatch;
            }
            0x824A57B4 => {
    //   block [0x824A57B4..0x824A57C4)
	// 824A57B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824A57B8: 4BFFE741  bl 0x824a3ef8
	ctx.lr = 0x824A57BC;
	sub_824A3EF8(ctx, base);
	// 824A57BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A57C0: 4808F938  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A57C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A57C8 size=116
    let mut pc: u32 = 0x824A57C8;
    'dispatch: loop {
        match pc {
            0x824A57C8 => {
    //   block [0x824A57C8..0x824A57F8)
	// 824A57C8: 89630127  lbz r11, 0x127(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(295 as u32) ) } as u64;
	// 824A57CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A57D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 824A57D4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 824A57D8: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 824A57DC: 99630127  stb r11, 0x127(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(295 as u32), ctx.r[11].u8 ) };
	// 824A57E0: 554A077E  clrlwi r10, r10, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 824A57E4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A57E8: 409A0010  bne cr6, 0x824a57f8
	if !ctx.cr[6].eq {
	pc = 0x824A57F8; continue 'dispatch;
	}
	// 824A57EC: 89630125  lbz r11, 0x125(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(293 as u32) ) } as u64;
	// 824A57F0: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 824A57F4: 99630125  stb r11, 0x125(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(293 as u32), ctx.r[11].u8 ) };
	pc = 0x824A57F8; continue 'dispatch;
            }
            0x824A57F8 => {
    //   block [0x824A57F8..0x824A5814)
	// 824A57F8: 89630127  lbz r11, 0x127(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(295 as u32) ) } as u64;
	// 824A57FC: 556B077E  clrlwi r11, r11, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 824A5800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A5804: 409A0010  bne cr6, 0x824a5814
	if !ctx.cr[6].eq {
	pc = 0x824A5814; continue 'dispatch;
	}
	// 824A5808: 89630125  lbz r11, 0x125(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(293 as u32) ) } as u64;
	// 824A580C: 696B0002  xori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 ^ 2;
	// 824A5810: 99630125  stb r11, 0x125(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(293 as u32), ctx.r[11].u8 ) };
	pc = 0x824A5814; continue 'dispatch;
            }
            0x824A5814 => {
    //   block [0x824A5814..0x824A583C)
	// 824A5814: 89630127  lbz r11, 0x127(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(295 as u32) ) } as u64;
	// 824A5818: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 824A581C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A5820: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 824A5824: 89630126  lbz r11, 0x126(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(294 as u32) ) } as u64;
	// 824A5828: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824A582C: 216B0001  subfic r11, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[11].s64 = (1 as i64) - ctx.r[11].s64;
	// 824A5830: 99430127  stb r10, 0x127(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(295 as u32), ctx.r[10].u8 ) };
	// 824A5834: 99630126  stb r11, 0x126(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(294 as u32), ctx.r[11].u8 ) };
	// 824A5838: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A5840 size=16
    let mut pc: u32 = 0x824A5840;
    'dispatch: loop {
        match pc {
            0x824A5840 => {
    //   block [0x824A5840..0x824A5850)
	// 824A5840: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A5844: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824A5848: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A584C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824A5850 size=16
    let mut pc: u32 = 0x824A5850;
    'dispatch: loop {
        match pc {
            0x824A5850 => {
    //   block [0x824A5850..0x824A5860)
	// 824A5850: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A5854: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 824A5858: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 824A585C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824A5860 size=32
    let mut pc: u32 = 0x824A5860;
    'dispatch: loop {
        match pc {
            0x824A5860 => {
    //   block [0x824A5860..0x824A5878)
	// 824A5860: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A5864: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A5868: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A586C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824A5870: 419A0008  beq cr6, 0x824a5878
	if ctx.cr[6].eq {
	pc = 0x824A5878; continue 'dispatch;
	}
	// 824A5874: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824A5878; continue 'dispatch;
            }
            0x824A5878 => {
    //   block [0x824A5878..0x824A5880)
	// 824A5878: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 824A587C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824A5880 size=32
    let mut pc: u32 = 0x824A5880;
    'dispatch: loop {
        match pc {
            0x824A5880 => {
    //   block [0x824A5880..0x824A5898)
	// 824A5880: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A5884: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A5888: C1A30014  lfs f13, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A588C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824A5890: 419A0008  beq cr6, 0x824a5898
	if ctx.cr[6].eq {
	pc = 0x824A5898; continue 'dispatch;
	}
	// 824A5894: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824A5898; continue 'dispatch;
            }
            0x824A5898 => {
    //   block [0x824A5898..0x824A58A0)
	// 824A5898: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 824A589C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A58A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824A58A0 size=68
    let mut pc: u32 = 0x824A58A0;
    'dispatch: loop {
        match pc {
            0x824A58A0 => {
    //   block [0x824A58A0..0x824A58D0)
	// 824A58A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A58A4: C0030020  lfs f0, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A58A8: C18B2074  lfs f12, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824A58AC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 824A58B0: 419A0020  beq cr6, 0x824a58d0
	if ctx.cr[6].eq {
	pc = 0x824A58D0; continue 'dispatch;
	}
	// 824A58B4: C1A30018  lfs f13, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A58B8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 824A58BC: C1630024  lfs f11, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824A58C0: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 824A58C4: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 824A58C8: 40980008  bge cr6, 0x824a58d0
	if !ctx.cr[6].lt {
	pc = 0x824A58D0; continue 'dispatch;
	}
	// 824A58CC: D1A30020  stfs f13, 0x20(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	pc = 0x824A58D0; continue 'dispatch;
            }
            0x824A58D0 => {
    //   block [0x824A58D0..0x824A58E4)
	// 824A58D0: C0030020  lfs f0, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A58D4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 824A58D8: 409A000C  bne cr6, 0x824a58e4
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x824A58E4);
		return;
	}
	// 824A58DC: C0230018  lfs f1, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824A58E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A58F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A58F8 size=164
    let mut pc: u32 = 0x824A58F8;
    'dispatch: loop {
        match pc {
            0x824A58F8 => {
    //   block [0x824A58F8..0x824A5920)
	// 824A58F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A58FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A5900: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A5904: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A5908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A590C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A5910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A5914: 419A000C  beq cr6, 0x824a5920
	if ctx.cr[6].eq {
	pc = 0x824A5920; continue 'dispatch;
	}
	// 824A5918: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 824A591C: 409A0018  bne cr6, 0x824a5934
	if !ctx.cr[6].eq {
	pc = 0x824A5934; continue 'dispatch;
	}
	pc = 0x824A5920; continue 'dispatch;
            }
            0x824A5920 => {
    //   block [0x824A5920..0x824A5934)
	// 824A5920: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A5928: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A592C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A5930: 4E800421  bctrl
	ctx.lr = 0x824A5934;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A5934 => {
    //   block [0x824A5934..0x824A5948)
	// 824A5934: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A5938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A593C: 419A000C  beq cr6, 0x824a5948
	if ctx.cr[6].eq {
	pc = 0x824A5948; continue 'dispatch;
	}
	// 824A5940: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 824A5944: 409A0018  bne cr6, 0x824a595c
	if !ctx.cr[6].eq {
	pc = 0x824A595C; continue 'dispatch;
	}
	pc = 0x824A5948; continue 'dispatch;
            }
            0x824A5948 => {
    //   block [0x824A5948..0x824A595C)
	// 824A5948: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A594C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A5950: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A5954: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A5958: 4E800421  bctrl
	ctx.lr = 0x824A595C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A595C => {
    //   block [0x824A595C..0x824A5970)
	// 824A595C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A5960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A5964: 419A000C  beq cr6, 0x824a5970
	if ctx.cr[6].eq {
	pc = 0x824A5970; continue 'dispatch;
	}
	// 824A5968: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 824A596C: 409A0018  bne cr6, 0x824a5984
	if !ctx.cr[6].eq {
	pc = 0x824A5984; continue 'dispatch;
	}
	pc = 0x824A5970; continue 'dispatch;
            }
            0x824A5970 => {
    //   block [0x824A5970..0x824A5984)
	// 824A5970: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A5978: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A597C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A5980: 4E800421  bctrl
	ctx.lr = 0x824A5984;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A5984 => {
    //   block [0x824A5984..0x824A599C)
	// 824A5984: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A5988: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824A598C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A5990: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A5994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A5998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A59B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824A59B0 size=84
    let mut pc: u32 = 0x824A59B0;
    'dispatch: loop {
        match pc {
            0x824A59B0 => {
    //   block [0x824A59B0..0x824A5A04)
	// 824A59B0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824A59B4: 9083000C  stw r4, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 824A59B8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A59BC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824A59C0: 396BE39C  addi r11, r11, -0x1c64
	ctx.r[11].s64 = ctx.r[11].s64 + -7268;
	// 824A59C4: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A59C8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824A59CC: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 824A59D0: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824A59D4: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 824A59D8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A59DC: 99230010  stb r9, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[9].u8 ) };
	// 824A59E0: C1AA2074  lfs f13, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A59E4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824A59E8: D1A30020  stfs f13, 0x20(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 824A59EC: C18A20AC  lfs f12, 0x20ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8364 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824A59F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824A59F4: D1830024  stfs f12, 0x24(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 824A59F8: 91430028  stw r10, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 824A59FC: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 824A5A00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A5A10 size=456
    let mut pc: u32 = 0x824A5A10;
    'dispatch: loop {
        match pc {
            0x824A5A10 => {
    //   block [0x824A5A10..0x824A5A70)
	// 824A5A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A5A14: 4808F6A9  bl 0x825350bc
	ctx.lr = 0x824A5A18;
	sub_82535080(ctx, base);
	// 824A5A18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A5A1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A5A20: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 824A5A24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824A5A28: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5A2C: 4BFF31F5  bl 0x82498c20
	ctx.lr = 0x824A5A30;
	sub_82498C20(ctx, base);
	// 824A5A30: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A5A34: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A5A38: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 824A5A3C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A5A40: 409A0038  bne cr6, 0x824a5a78
	if !ctx.cr[6].eq {
	pc = 0x824A5A78; continue 'dispatch;
	}
	// 824A5A44: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A5A48: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 824A5A4C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 824A5A50: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824A5A54: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A5A58: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 824A5A5C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824A5A60: 419A0010  beq cr6, 0x824a5a70
	if ctx.cr[6].eq {
	pc = 0x824A5A70; continue 'dispatch;
	}
	// 824A5A64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824A5A68: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A5A6C: EDAD0024  fdivs f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x824A5A70; continue 'dispatch;
            }
            0x824A5A70 => {
    //   block [0x824A5A70..0x824A5A78)
	// 824A5A70: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 824A5A74: 48000038  b 0x824a5aac
	pc = 0x824A5AAC; continue 'dispatch;
            }
            0x824A5A78 => {
    //   block [0x824A5A78..0x824A5AA8)
	// 824A5A78: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A5A7C: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 824A5A80: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 824A5A84: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824A5A88: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 824A5A8C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A5A90: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 824A5A94: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824A5A98: 419A0010  beq cr6, 0x824a5aa8
	if ctx.cr[6].eq {
	pc = 0x824A5AA8; continue 'dispatch;
	}
	// 824A5A9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824A5AA0: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A5AA4: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	pc = 0x824A5AA8; continue 'dispatch;
            }
            0x824A5AA8 => {
    //   block [0x824A5AA8..0x824A5AAC)
	// 824A5AA8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	pc = 0x824A5AAC; continue 'dispatch;
            }
            0x824A5AAC => {
    //   block [0x824A5AAC..0x824A5B10)
	// 824A5AAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5AB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824A5AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A5AB8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 824A5ABC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A5AC0: 4E800421  bctrl
	ctx.lr = 0x824A5AC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A5AC4: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 824A5AC8: 816B9004  lwz r11, -0x6ffc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28668 as u32) ) } as u64;
	// 824A5ACC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5AD0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 824A5AD4: 409A0048  bne cr6, 0x824a5b1c
	if !ctx.cr[6].eq {
	pc = 0x824A5B1C; continue 'dispatch;
	}
	// 824A5AD8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5ADC: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 824A5AE0: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A5AE4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5AE8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5AEC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5AF0: 40980020  bge cr6, 0x824a5b10
	if !ctx.cr[6].lt {
	pc = 0x824A5B10; continue 'dispatch;
	}
	// 824A5AF4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 824A5AF8: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 824A5AFC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A5B00: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5B04: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A5B08: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5B0C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A5B10 => {
    //   block [0x824A5B10..0x824A5B1C)
	// 824A5B10: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A5B14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824A5B18: 4808F5F4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x824A5B1C => {
    //   block [0x824A5B1C..0x824A5B80)
	// 824A5B1C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A5B20: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 824A5B24: 409A00A0  bne cr6, 0x824a5bc4
	if !ctx.cr[6].eq {
	pc = 0x824A5BC4; continue 'dispatch;
	}
	// 824A5B28: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5B2C: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A5B30: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A5B34: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 824A5B38: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824A5B3C: 816B0154  lwz r11, 0x154(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(340 as u32) ) } as u64;
	// 824A5B40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A5B44: 419A0078  beq cr6, 0x824a5bbc
	if ctx.cr[6].eq {
	pc = 0x824A5BBC; continue 'dispatch;
	}
	// 824A5B48: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5B4C: 3BC00014  li r30, 0x14
	ctx.r[30].s64 = 20;
	// 824A5B50: 7D5EE82E  lwzx r10, r30, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A5B54: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5B58: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5B5C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5B60: 40980020  bge cr6, 0x824a5b80
	if !ctx.cr[6].lt {
	pc = 0x824A5B80; continue 'dispatch;
	}
	// 824A5B64: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A5B68: 392906F0  addi r9, r9, 0x6f0
	ctx.r[9].s64 = ctx.r[9].s64 + 1776;
	// 824A5B6C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A5B70: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5B74: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A5B78: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5B7C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A5B80; continue 'dispatch;
            }
            0x824A5B80 => {
    //   block [0x824A5B80..0x824A5BBC)
	// 824A5B80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824A5B84: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5B88: 4BFFF7C1  bl 0x824a5348
	ctx.lr = 0x824A5B8C;
	sub_824A5348(ctx, base);
	// 824A5B8C: 7D5EE82E  lwzx r10, r30, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A5B90: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5B94: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5B98: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5B9C: 40980020  bge cr6, 0x824a5bbc
	if !ctx.cr[6].lt {
	pc = 0x824A5BBC; continue 'dispatch;
	}
	// 824A5BA0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 824A5BA4: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 824A5BA8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A5BAC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5BB0: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A5BB4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5BB8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A5BBC; continue 'dispatch;
            }
            0x824A5BBC => {
    //   block [0x824A5BBC..0x824A5BC4)
	// 824A5BBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A5BC0: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	pc = 0x824A5BC4; continue 'dispatch;
            }
            0x824A5BC4 => {
    //   block [0x824A5BC4..0x824A5BD8)
	// 824A5BC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A5BC8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824A5BCC: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 824A5BD0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824A5BD4: 4808F538  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A5BD8 size=248
    let mut pc: u32 = 0x824A5BD8;
    'dispatch: loop {
        match pc {
            0x824A5BD8 => {
    //   block [0x824A5BD8..0x824A5C18)
	// 824A5BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A5BDC: 4808F4E1  bl 0x825350bc
	ctx.lr = 0x824A5BE0;
	sub_82535080(ctx, base);
	// 824A5BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A5BE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824A5BE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A5BEC: C01D0020  lfs f0, 0x20(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A5BF0: C18B2074  lfs f12, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824A5BF4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 824A5BF8: 419A0020  beq cr6, 0x824a5c18
	if ctx.cr[6].eq {
	pc = 0x824A5C18; continue 'dispatch;
	}
	// 824A5BFC: C1BD0018  lfs f13, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A5C00: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 824A5C04: C17D0024  lfs f11, 0x24(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824A5C08: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 824A5C0C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 824A5C10: 40980008  bge cr6, 0x824a5c18
	if !ctx.cr[6].lt {
	pc = 0x824A5C18; continue 'dispatch;
	}
	// 824A5C14: D1BD0020  stfs f13, 0x20(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), tmp.u32 ) };
	pc = 0x824A5C18; continue 'dispatch;
            }
            0x824A5C18 => {
    //   block [0x824A5C18..0x824A5C30)
	// 824A5C18: C01D0020  lfs f0, 0x20(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A5C1C: C1BD0018  lfs f13, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A5C20: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 824A5C24: 419A000C  beq cr6, 0x824a5c30
	if ctx.cr[6].eq {
	pc = 0x824A5C30; continue 'dispatch;
	}
	// 824A5C28: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 824A5C2C: FDAC682E  fsel f13, f12, f0, f13
	ctx.f[13].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	pc = 0x824A5C30; continue 'dispatch;
            }
            0x824A5C30 => {
    //   block [0x824A5C30..0x824A5C84)
	// 824A5C30: D1BD0014  stfs f13, 0x14(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 824A5C34: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824A5C38: 41980084  blt cr6, 0x824a5cbc
	if ctx.cr[6].lt {
	pc = 0x824A5CBC; continue 'dispatch;
	}
	// 824A5C3C: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5C40: 816B013C  lwz r11, 0x13c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(316 as u32) ) } as u64;
	// 824A5C44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A5C48: 419A0074  beq cr6, 0x824a5cbc
	if ctx.cr[6].eq {
	pc = 0x824A5CBC; continue 'dispatch;
	}
	// 824A5C4C: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5C50: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824A5C54: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A5C58: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5C5C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5C60: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5C64: 40980020  bge cr6, 0x824a5c84
	if !ctx.cr[6].lt {
	pc = 0x824A5C84; continue 'dispatch;
	}
	// 824A5C68: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A5C6C: 39290700  addi r9, r9, 0x700
	ctx.r[9].s64 = ctx.r[9].s64 + 1792;
	// 824A5C70: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A5C74: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5C78: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A5C7C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5C80: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A5C84; continue 'dispatch;
            }
            0x824A5C84 => {
    //   block [0x824A5C84..0x824A5CBC)
	// 824A5C84: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5C88: 4BFFF4E1  bl 0x824a5168
	ctx.lr = 0x824A5C8C;
	sub_824A5168(ctx, base);
	// 824A5C8C: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A5C90: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5C94: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5C98: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5C9C: 40980020  bge cr6, 0x824a5cbc
	if !ctx.cr[6].lt {
	pc = 0x824A5CBC; continue 'dispatch;
	}
	// 824A5CA0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 824A5CA4: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 824A5CA8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A5CAC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5CB0: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A5CB4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5CB8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A5CBC; continue 'dispatch;
            }
            0x824A5CBC => {
    //   block [0x824A5CBC..0x824A5CD0)
	// 824A5CBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A5CC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824A5CC4: 917D0028  stw r11, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 824A5CC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A5CCC: 4808F440  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A5CD0 size=156
    let mut pc: u32 = 0x824A5CD0;
    'dispatch: loop {
        match pc {
            0x824A5CD0 => {
    //   block [0x824A5CD0..0x824A5CFC)
	// 824A5CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A5CD4: 4808F3D9  bl 0x825350ac
	ctx.lr = 0x824A5CD8;
	sub_82535080(ctx, base);
	// 824A5CD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A5CDC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824A5CE0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 824A5CE4: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5CE8: 3B4B0028  addi r26, r11, 0x28
	ctx.r[26].s64 = ctx.r[11].s64 + 40;
	// 824A5CEC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5CF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A5CF4: 40990070  ble cr6, 0x824a5d64
	if !ctx.cr[6].gt {
	pc = 0x824A5D64; continue 'dispatch;
	}
	// 824A5CF8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x824A5CFC; continue 'dispatch;
            }
            0x824A5CFC => {
    //   block [0x824A5CFC..0x824A5D1C)
	// 824A5CFC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5D00: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 824A5D04: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 824A5D08: 3BAB0038  addi r29, r11, 0x38
	ctx.r[29].s64 = ctx.r[11].s64 + 56;
	// 824A5D0C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5D10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A5D14: 4099003C  ble cr6, 0x824a5d50
	if !ctx.cr[6].gt {
	pc = 0x824A5D50; continue 'dispatch;
	}
	// 824A5D18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x824A5D1C; continue 'dispatch;
            }
            0x824A5D1C => {
    //   block [0x824A5D1C..0x824A5D50)
	// 824A5D1C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5D20: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5D24: 388B0190  addi r4, r11, 0x190
	ctx.r[4].s64 = ctx.r[11].s64 + 400;
	// 824A5D28: 7C6AF02E  lwzx r3, r10, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824A5D2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5D30: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5D34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A5D38: 4E800421  bctrl
	ctx.lr = 0x824A5D3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A5D3C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5D40: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 824A5D44: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 824A5D48: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A5D4C: 4198FFD0  blt cr6, 0x824a5d1c
	if ctx.cr[6].lt {
	pc = 0x824A5D1C; continue 'dispatch;
	}
            }
            0x824A5D50 => {
    //   block [0x824A5D50..0x824A5D64)
	// 824A5D50: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5D54: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 824A5D58: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 824A5D5C: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A5D60: 4198FF9C  blt cr6, 0x824a5cfc
	if ctx.cr[6].lt {
	pc = 0x824A5CFC; continue 'dispatch;
	}
	pc = 0x824A5D64; continue 'dispatch;
            }
            0x824A5D64 => {
    //   block [0x824A5D64..0x824A5D6C)
	// 824A5D64: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824A5D68: 4808F394  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A5D70 size=132
    let mut pc: u32 = 0x824A5D70;
    'dispatch: loop {
        match pc {
            0x824A5D70 => {
    //   block [0x824A5D70..0x824A5DF4)
	// 824A5D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A5D74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A5D78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824A5D7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A5D80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A5D84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824A5D88: 3BFE00E0  addi r31, r30, 0xe0
	ctx.r[31].s64 = ctx.r[30].s64 + 224;
	// 824A5D8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A5D90: 48105871  bl 0x825ab600
	ctx.lr = 0x824A5D94;
	sub_825AB600(ctx, base);
	// 824A5D94: 397E0160  addi r11, r30, 0x160
	ctx.r[11].s64 = ctx.r[30].s64 + 352;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A5DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A5DF8 size=528
    let mut pc: u32 = 0x824A5DF8;
    'dispatch: loop {
        match pc {
            0x824A5DF8 => {
    //   block [0x824A5DF8..0x824A5E40)
	// 824A5DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A5DFC: 4808F2BD  bl 0x825350b8
	ctx.lr = 0x824A5E00;
	sub_82535080(ctx, base);
	// 824A5E00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A5E04: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5E08: 3BC00014  li r30, 0x14
	ctx.r[30].s64 = 20;
	// 824A5E0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A5E10: 7D5EE82E  lwzx r10, r30, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A5E14: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5E18: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5E1C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5E20: 40980020  bge cr6, 0x824a5e40
	if !ctx.cr[6].lt {
	pc = 0x824A5E40; continue 'dispatch;
	}
	// 824A5E24: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A5E28: 39290728  addi r9, r9, 0x728
	ctx.r[9].s64 = ctx.r[9].s64 + 1832;
	// 824A5E2C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A5E30: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5E34: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A5E38: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5E3C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A5E40; continue 'dispatch;
            }
            0x824A5E40 => {
    //   block [0x824A5E40..0x824A5E8C)
	// 824A5E40: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A5E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A5E48: 419A0044  beq cr6, 0x824a5e8c
	if ctx.cr[6].eq {
	pc = 0x824A5E8C; continue 'dispatch;
	}
	// 824A5E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A5E50: 4BFFFBC1  bl 0x824a5a10
	ctx.lr = 0x824A5E54;
	sub_824A5A10(ctx, base);
	// 824A5E54: 7D5EE82E  lwzx r10, r30, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A5E58: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5E5C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5E60: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5E64: 4098019C  bge cr6, 0x824a6000
	if !ctx.cr[6].lt {
	pc = 0x824A6000; continue 'dispatch;
	}
	// 824A5E68: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 824A5E6C: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 824A5E70: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A5E74: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5E78: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A5E7C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5E80: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A5E84: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824A5E88: 4808F280  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x824A5E8C => {
    //   block [0x824A5E8C..0x824A5EC4)
	// 824A5E8C: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A5E90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A5E94: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A5E98: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 824A5E9C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 824A5EA0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824A5EA4: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 824A5EA8: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A5EAC: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 824A5EB0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824A5EB4: 419A0010  beq cr6, 0x824a5ec4
	if ctx.cr[6].eq {
	pc = 0x824A5EC4; continue 'dispatch;
	}
	// 824A5EB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824A5EBC: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A5EC0: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	pc = 0x824A5EC4; continue 'dispatch;
            }
            0x824A5EC4 => {
    //   block [0x824A5EC4..0x824A5F2C)
	// 824A5EC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A5EC8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 824A5ECC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824A5ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A5ED4: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 824A5ED8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A5EDC: 4E800421  bctrl
	ctx.lr = 0x824A5EE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A5EE0: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 824A5EE4: 816B9004  lwz r11, -0x6ffc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28668 as u32) ) } as u64;
	// 824A5EE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5EEC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 824A5EF0: 409A0048  bne cr6, 0x824a5f38
	if !ctx.cr[6].eq {
	pc = 0x824A5F38; continue 'dispatch;
	}
	// 824A5EF4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 824A5EF8: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 824A5EFC: 7D5EE82E  lwzx r10, r30, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A5F00: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5F04: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5F08: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5F0C: 40980020  bge cr6, 0x824a5f2c
	if !ctx.cr[6].lt {
	pc = 0x824A5F2C; continue 'dispatch;
	}
	// 824A5F10: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 824A5F14: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 824A5F18: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A5F1C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5F20: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A5F24: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5F28: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A5F2C => {
    //   block [0x824A5F2C..0x824A5F38)
	// 824A5F2C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 824A5F30: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824A5F34: 4808F1D4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x824A5F38 => {
    //   block [0x824A5F38..0x824A5F90)
	// 824A5F38: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5F3C: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A5F40: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A5F44: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 824A5F48: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824A5F4C: 816B0154  lwz r11, 0x154(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(340 as u32) ) } as u64;
	// 824A5F50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A5F54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A5F58: 3B8B74DC  addi r28, r11, 0x74dc
	ctx.r[28].s64 = ctx.r[11].s64 + 29916;
	// 824A5F5C: 419A0068  beq cr6, 0x824a5fc4
	if ctx.cr[6].eq {
	pc = 0x824A5FC4; continue 'dispatch;
	}
	// 824A5F60: 7D5EE82E  lwzx r10, r30, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A5F64: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5F68: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5F6C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5F70: 40980020  bge cr6, 0x824a5f90
	if !ctx.cr[6].lt {
	pc = 0x824A5F90; continue 'dispatch;
	}
	// 824A5F74: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A5F78: 392906F0  addi r9, r9, 0x6f0
	ctx.r[9].s64 = ctx.r[9].s64 + 1776;
	// 824A5F7C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A5F80: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5F84: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A5F88: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5F8C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A5F90; continue 'dispatch;
            }
            0x824A5F90 => {
    //   block [0x824A5F90..0x824A5FC4)
	// 824A5F90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824A5F94: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5F98: 4BFFF3B1  bl 0x824a5348
	ctx.lr = 0x824A5F9C;
	sub_824A5348(ctx, base);
	// 824A5F9C: 7D5EE82E  lwzx r10, r30, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A5FA0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5FA4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5FA8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5FAC: 40980018  bge cr6, 0x824a5fc4
	if !ctx.cr[6].lt {
	pc = 0x824A5FC4; continue 'dispatch;
	}
	// 824A5FB0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 824A5FB4: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5FB8: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A5FBC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5FC0: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A5FC4; continue 'dispatch;
            }
            0x824A5FC4 => {
    //   block [0x824A5FC4..0x824A5FFC)
	// 824A5FC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A5FC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824A5FCC: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 824A5FD0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 824A5FD4: 7D5EE82E  lwzx r10, r30, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824A5FD8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A5FDC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A5FE0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A5FE4: 40980018  bge cr6, 0x824a5ffc
	if !ctx.cr[6].lt {
	pc = 0x824A5FFC; continue 'dispatch;
	}
	// 824A5FE8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 824A5FEC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A5FF0: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A5FF4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A5FF8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A5FFC; continue 'dispatch;
            }
            0x824A5FFC => {
    //   block [0x824A5FFC..0x824A6000)
	// 824A5FFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x824A6000; continue 'dispatch;
            }
            0x824A6000 => {
    //   block [0x824A6000..0x824A6008)
	// 824A6000: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824A6004: 4808F104  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A6008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A6008 size=1212
    let mut pc: u32 = 0x824A6008;
    'dispatch: loop {
        match pc {
            0x824A6008 => {
    //   block [0x824A6008..0x824A6060)
	// 824A6008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A600C: 4808F08D  bl 0x82535098
	ctx.lr = 0x824A6010;
	sub_82535080(ctx, base);
	// 824A6010: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A6014: 834D0000  lwz r26, 0(r13)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A6018: 3B600014  li r27, 0x14
	ctx.r[27].s64 = 20;
	// 824A601C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824A6020: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 824A6024: 7D5BD02E  lwzx r10, r27, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 824A6028: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A602C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A6030: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A6034: 4098002C  bge cr6, 0x824a6060
	if !ctx.cr[6].lt {
	pc = 0x824A6060; continue 'dispatch;
	}
	// 824A6038: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A603C: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 824A6040: 39290784  addi r9, r9, 0x784
	ctx.r[9].s64 = ctx.r[9].s64 + 1924;
	// 824A6044: 3908077C  addi r8, r8, 0x77c
	ctx.r[8].s64 = ctx.r[8].s64 + 1916;
	// 824A6048: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A604C: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 824A6050: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A6054: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 824A6058: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A605C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A6060; continue 'dispatch;
            }
            0x824A6060 => {
    //   block [0x824A6060..0x824A64C4)
	// 824A6060: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A6064: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824A6068: E93C0000  ld r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 824A606C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 824A6070: 396B0190  addi r11, r11, 0x190
	ctx.r[11].s64 = ctx.r[11].s64 + 400;
	// 824A6074: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 824A6078: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 824A607C: E93C0008  ld r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	// 824A6080: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 824A6084: C01C0008  lfs f0, 8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A6088: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A608C: 396B01A0  addi r11, r11, 0x1a0
	ctx.r[11].s64 = ctx.r[11].s64 + 416;
	// 824A6090: 392B010C  addi r9, r11, 0x10c
	ctx.r[9].s64 = ctx.r[11].s64 + 268;
	// 824A6094: 80CB0114  lwz r6, 0x114(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) } as u64;
	// 824A6098: C1AB0120  lfs f13, 0x120(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(288 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A609C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824A60A0: D00B010C  stfs f0, 0x10c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 824A60A4: 7CC607B4  extsw r6, r6
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 824A60A8: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A60AC: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 824A60B0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 824A60B4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 824A60B8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 824A60BC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824A60C0: D00B0110  stfs f0, 0x110(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 824A60C4: 80DE000C  lwz r6, 0xc(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A64C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A64C8 size=236
    let mut pc: u32 = 0x824A64C8;
    'dispatch: loop {
        match pc {
            0x824A64C8 => {
    //   block [0x824A64C8..0x824A656C)
	// 824A64C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A64CC: 4808EBE9  bl 0x825350b4
	ctx.lr = 0x824A64D0;
	sub_82535080(ctx, base);
	// 824A64D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A64D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A64D8: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 824A64DC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 824A64E0: 3B7F0010  addi r27, r31, 0x10
	ctx.r[27].s64 = ctx.r[31].s64 + 16;
	// 824A64E4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824A64E8: C00B8CB4  lfs f0, -0x734c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A64EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A64F0: D01F3030  stfs f0, 0x3030(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12336 as u32), tmp.u32 ) };
	// 824A64F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824A64F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824A64FC: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 824A6500: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824A6504: 917F3080  stw r11, 0x3080(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12416 as u32), ctx.r[11].u32 ) };
	// 824A6508: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A650C: 394B1C60  addi r10, r11, 0x1c60
	ctx.r[10].s64 = ctx.r[11].s64 + 7264;
	// 824A6510: 915E0060  stw r10, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 824A6514: 895D000C  lbz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A6518: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 824A651C: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824A6520: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824A6524: 816B1C30  lwz r11, 0x1c30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7216 as u32) ) } as u64;
	// 824A6528: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 824A652C: 80DD0008  lwz r6, 8(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A6530: 4802F3C9  bl 0x824d58f8
	ctx.lr = 0x824A6534;
	sub_824D58F8(ctx, base);
	// 824A6534: 3F808293  lis r28, -0x7d6d
	ctx.r[28].s64 = -2104295424;
	// 824A6538: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824A653C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824A6540: 809C9004  lwz r4, -0x6ffc(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-28668 as u32) ) } as u64;
	// 824A6544: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A6548: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 824A654C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A6550: 4E800421  bctrl
	ctx.lr = 0x824A6554;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A6554: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A6558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A655C: 409A0010  bne cr6, 0x824a656c
	if !ctx.cr[6].eq {
	pc = 0x824A656C; continue 'dispatch;
	}
	// 824A6560: 817C9004  lwz r11, -0x6ffc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-28668 as u32) ) } as u64;
	// 824A6564: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824A6568: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
            }
            0x824A656C => {
    //   block [0x824A656C..0x824A65AC)
	// 824A656C: 817C9004  lwz r11, -0x6ffc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-28668 as u32) ) } as u64;
	// 824A6570: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A6574: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 824A6578: 419A0034  beq cr6, 0x824a65ac
	if ctx.cr[6].eq {
	pc = 0x824A65AC; continue 'dispatch;
	}
	// 824A657C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A6580: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 824A6584: 419A0028  beq cr6, 0x824a65ac
	if ctx.cr[6].eq {
	pc = 0x824A65AC; continue 'dispatch;
	}
	// 824A6588: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A658C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 824A6590: 80BD0014  lwz r5, 0x14(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A6594: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 824A6598: 809D0010  lwz r4, 0x10(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A659C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A65A0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A65A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A65A8: 4E800421  bctrl
	ctx.lr = 0x824A65AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A65AC => {
    //   block [0x824A65AC..0x824A65B4)
	// 824A65AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824A65B0: 4808EB54  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A65B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A65B8 size=468
    let mut pc: u32 = 0x824A65B8;
    'dispatch: loop {
        match pc {
            0x824A65B8 => {
    //   block [0x824A65B8..0x824A6600)
	// 824A65B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A65BC: 4808EAFD  bl 0x825350b8
	ctx.lr = 0x824A65C0;
	sub_82535080(ctx, base);
	// 824A65C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A65C4: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A65C8: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 824A65CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A65D0: 7D5EE02E  lwzx r10, r30, r28
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A65D4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A65D8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A65DC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A65E0: 40980020  bge cr6, 0x824a6600
	if !ctx.cr[6].lt {
	pc = 0x824A6600; continue 'dispatch;
	}
	// 824A65E4: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A65E8: 39290728  addi r9, r9, 0x728
	ctx.r[9].s64 = ctx.r[9].s64 + 1832;
	// 824A65EC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A65F0: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A65F4: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A65F8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A65FC: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A6600; continue 'dispatch;
            }
            0x824A6600 => {
    //   block [0x824A6600..0x824A6698)
	// 824A6600: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A6604: D03F001C  stfs f1, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 824A6608: 4BFEE341  bl 0x82494948
	ctx.lr = 0x824A660C;
	sub_82494948(ctx, base);
	// 824A660C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 824A6610: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 824A6614: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A6618: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A661C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A6620: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 824A6624: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 824A6628: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A662C: 40990078  ble cr6, 0x824a66a4
	if !ctx.cr[6].gt {
	pc = 0x824A66A4; continue 'dispatch;
	}
	// 824A6630: 3FA08293  lis r29, -0x7d6d
	ctx.r[29].s64 = -2104295424;
	// 824A6634: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824A6638: 809D9004  lwz r4, -0x6ffc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-28668 as u32) ) } as u64;
	// 824A663C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A6640: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 824A6644: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A6648: 4E800421  bctrl
	ctx.lr = 0x824A664C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A664C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A6650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A6654: 409A0050  bne cr6, 0x824a66a4
	if !ctx.cr[6].eq {
	pc = 0x824A66A4; continue 'dispatch;
	}
	// 824A6658: 817D9004  lwz r11, -0x6ffc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-28668 as u32) ) } as u64;
	// 824A665C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824A6660: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824A6664: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 824A6668: 7D7EE02E  lwzx r11, r30, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A666C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A6670: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A6674: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A6678: 40980020  bge cr6, 0x824a6698
	if !ctx.cr[6].lt {
	pc = 0x824A6698; continue 'dispatch;
	}
	// 824A667C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 824A6680: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 824A6684: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A6688: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A668C: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A6690: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A6694: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A6698 => {
    //   block [0x824A6698..0x824A66A4)
	// 824A6698: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 824A669C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A66A0: 4808EA68  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x824A66A4 => {
    //   block [0x824A66A4..0x824A66DC)
	// 824A66A4: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A66A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A66AC: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A66B0: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 824A66B4: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 824A66B8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 824A66BC: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 824A66C0: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A66C4: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 824A66C8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824A66CC: 419A0010  beq cr6, 0x824a66dc
	if ctx.cr[6].eq {
	pc = 0x824A66DC; continue 'dispatch;
	}
	// 824A66D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824A66D4: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A66D8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	pc = 0x824A66DC; continue 'dispatch;
            }
            0x824A66DC => {
    //   block [0x824A66DC..0x824A6780)
	// 824A66DC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 824A66E0: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A66E4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 824A66E8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 824A66EC: 39290190  addi r9, r9, 0x190
	ctx.r[9].s64 = ctx.r[9].s64 + 400;
	// 824A66F0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824A66F4: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 824A66F8: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 824A66FC: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 824A6700: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 824A6704: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A6708: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 824A670C: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A6710: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 824A6714: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 824A6718: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 824A671C: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 824A6720: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A6724: 8064004C  lwz r3, 0x4c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A6728: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A672C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A6730: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A6734: 4E800421  bctrl
	ctx.lr = 0x824A6738;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A6738: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 824A673C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A6740: 4BFFF8C9  bl 0x824a6008
	ctx.lr = 0x824A6744;
	sub_824A6008(ctx, base);
	// 824A6744: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A6748: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 824A674C: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 824A6750: 7D7EE02E  lwzx r11, r30, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A6754: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A6758: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A675C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A6760: 40980020  bge cr6, 0x824a6780
	if !ctx.cr[6].lt {
	pc = 0x824A6780; continue 'dispatch;
	}
	// 824A6764: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 824A6768: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 824A676C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A6770: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A6774: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A6778: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A677C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x824A6780 => {
    //   block [0x824A6780..0x824A678C)
	// 824A6780: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824A6784: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A6788: 4808E980  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A6790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A6790 size=1856
    let mut pc: u32 = 0x824A6790;
    'dispatch: loop {
        match pc {
            0x824A6790 => {
    //   block [0x824A6790..0x824A68B8)
	// 824A6790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A6794: 4808E8ED  bl 0x82535080
	ctx.lr = 0x824A6798;
	sub_82535080(ctx, base);
	// 824A6798: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 824A679C: 4808F82D  bl 0x82535fc8
	ctx.lr = 0x824A67A0;
	sub_82535FB0(ctx, base);
	// 824A67A0: 3981FF00  addi r12, r1, -0x100
	ctx.r[12].s64 = ctx.r[1].s64 + -256;
	// 824A67A4: 48092C01  bl 0x825393a4
	ctx.lr = 0x824A67A8;
	sub_82539130(ctx, base);
	// 824A67A8: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 824A67AC: E981E000  ld r12, -0x2000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8192 as u32) ) };
	// 824A67B0: E981D000  ld r12, -0x3000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-12288 as u32) ) };
	// 824A67B4: 9421CC70  stwu r1, -0x3390(r1)
	ea = ctx.r[1].u32.wrapping_add(-13200 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A67B8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 824A67BC: 910133CC  stw r8, 0x33cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(13260 as u32), ctx.r[8].u32 ) };
	// 824A67C0: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 824A67C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824A67C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824A67CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 824A67D0: 93A133B4  stw r29, 0x33b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(13236 as u32), ctx.r[29].u32 ) };
	// 824A67D4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 824A67D8: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 824A67DC: 4BFC6AA5  bl 0x8246d280
	ctx.lr = 0x824A67E0;
	sub_8246D280(ctx, base);
	// 824A67E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A67E4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 824A67E8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 824A67EC: C00B8CB4  lfs f0, -0x734c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A67F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A67F4: D00131F0  stfs f0, 0x31f0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(12784 as u32), tmp.u32 ) };
	// 824A67F8: 938101C4  stw r28, 0x1c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), ctx.r[28].u32 ) };
	// 824A67FC: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 824A6800: C2EB1FF8  lfs f23, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 824A6804: D2E13210  stfs f23, 0x3210(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(12816 as u32), tmp.u32 ) };
	// 824A6808: D2E13214  stfs f23, 0x3214(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(12820 as u32), tmp.u32 ) };
	// 824A680C: 409906A4  ble cr6, 0x824a6eb0
	if !ctx.cr[6].gt {
	pc = 0x824A6EB0; continue 'dispatch;
	}
	// 824A6810: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 824A6814: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 824A6818: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 824A681C: 396B9004  addi r11, r11, -0x6ffc
	ctx.r[11].s64 = ctx.r[11].s64 + -28668;
	// 824A6820: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 824A6824: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 824A6828: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 824A682C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 824A6830: C3062954  lfs f24, 0x2954(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(10580 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 824A6834: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 824A6838: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A683C: C3272938  lfs f25, 0x2938(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(10552 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 824A6840: 3AA00010  li r21, 0x10
	ctx.r[21].s64 = 16;
	// 824A6844: 396BFA60  addi r11, r11, -0x5a0
	ctx.r[11].s64 = ctx.r[11].s64 + -1440;
	// 824A6848: C2A82968  lfs f21, 0x2968(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(10600 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 824A684C: C2C92298  lfs f22, 0x2298(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8856 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 824A6850: 3AC00020  li r22, 0x20
	ctx.r[22].s64 = 32;
	// 824A6854: C3AA1850  lfs f29, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 824A6858: 3AE00030  li r23, 0x30
	ctx.r[23].s64 = 48;
	// 824A685C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 824A6860: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A6864: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824A6868: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 824A686C: 3A9A0010  addi r20, r26, 0x10
	ctx.r[20].s64 = ctx.r[26].s64 + 16;
	// 824A6870: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 824A6874: 4BFC6B8D  bl 0x8246d400
	ctx.lr = 0x824A6878;
	sub_8246D400(ctx, base);
	// 824A6878: 81740050  lwz r11, 0x50(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(80 as u32) ) } as u64;
	// 824A687C: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 824A6880: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A6884: 40990614  ble cr6, 0x824a6e98
	if !ctx.cr[6].gt {
	pc = 0x824A6E98; continue 'dispatch;
	}
	// 824A6888: 3A54004C  addi r18, r20, 0x4c
	ctx.r[18].s64 = ctx.r[20].s64 + 76;
	// 824A688C: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 824A6890: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A6894: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 824A6898: 7F6B9A14  add r27, r11, r19
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 824A689C: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A68A0: 4BFC6C39  bl 0x8246d4d8
	ctx.lr = 0x824A68A4;
	sub_8246D4D8(ctx, base);
	// 824A68A4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 824A68A8: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A68AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A68B0: 40990008  ble cr6, 0x824a68b8
	if !ctx.cr[6].gt {
	pc = 0x824A68B8; continue 'dispatch;
	}
	// 824A68B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824A68B8; continue 'dispatch;
            }
            0x824A68B8 => {
    //   block [0x824A68B8..0x824A68F4)
	// 824A68B8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824A68BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A68C0: 409A05B4  bne cr6, 0x824a6e74
	if !ctx.cr[6].eq {
	pc = 0x824A6E74; continue 'dispatch;
	}
	// 824A68C4: 83BB0000  lwz r29, 0(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A68C8: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A68CC: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A68D0: 892B0010  lbz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A68D4: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 824A68D8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824A68DC: 892B00D8  lbz r9, 0xd8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) } as u64;
	// 824A68E0: 2B090007  cmplwi cr6, r9, 7
	ctx.cr[6].compare_u32(ctx.r[9].u32, 7 as u32, &mut ctx.xer);
	// 824A68E4: 409A0010  bne cr6, 0x824a68f4
	if !ctx.cr[6].eq {
	pc = 0x824A68F4; continue 'dispatch;
	}
	// 824A68E8: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A68EC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824A68F0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x824A68F4; continue 'dispatch;
            }
            0x824A68F4 => {
    //   block [0x824A68F4..0x824A6E60)
	// 824A68F4: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 824A68F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824A68FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824A6900: 916101C4  stw r11, 0x1c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), ctx.r[11].u32 ) };
	// 824A6904: 4802DDF5  bl 0x824d46f8
	ctx.lr = 0x824A6908;
	sub_824D46F8(ctx, base);
	// 824A6908: 38C101C0  addi r6, r1, 0x1c0
	ctx.r[6].s64 = ctx.r[1].s64 + 448;
	// 824A690C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 824A6910: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824A6914: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 824A6918: 7F0903A6  mtctr r24
	ctx.ctr.u64 = ctx.r[24].u64;
	// 824A691C: 4E800421  bctrl
	ctx.lr = 0x824A6920;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A6920: 816133CC  lwz r11, 0x33cc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(13260 as u32) ) } as u64;
	// 824A6924: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 824A6928: 409A0538  bne cr6, 0x824a6e60
	if !ctx.cr[6].eq {
	pc = 0x824A6E60; continue 'dispatch;
	}
	// 824A692C: 814101C0  lwz r10, 0x1c0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(448 as u32) ) } as u64;
	// 824A6930: 396101D0  addi r11, r1, 0x1d0
	ctx.r[11].s64 = ctx.r[1].s64 + 464;
	// 824A6934: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A6938: 419A0528  beq cr6, 0x824a6e60
	if ctx.cr[6].eq {
	pc = 0x824A6E60; continue 'dispatch;
	}
	// 824A693C: 3B9A0150  addi r28, r26, 0x150
	ctx.r[28].s64 = ctx.r[26].s64 + 336;
	// 824A6940: 38E101E0  addi r7, r1, 0x1e0
	ctx.r[7].s64 = ctx.r[1].s64 + 480;
	// 824A6944: 38C10150  addi r6, r1, 0x150
	ctx.r[6].s64 = ctx.r[1].s64 + 336;
	// 824A6948: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 824A694C: 3BFA00E0  addi r31, r26, 0xe0
	ctx.r[31].s64 = ctx.r[26].s64 + 224;
	// 824A6950: E87C0000  ld r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 824A6954: 39610160  addi r11, r1, 0x160
	ctx.r[11].s64 = ctx.r[1].s64 + 352;
	// 824A6958: EA1C0008  ld r16, 8(r28)
	ctx.r[16].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	// 824A695C: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 824A6960: E8870000  ld r4, 0(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 824A6964: 39210170  addi r9, r1, 0x170
	ctx.r[9].s64 = ctx.r[1].s64 + 368;
	// 824A6968: E8E70008  ld r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 824A696C: 39010120  addi r8, r1, 0x120
	ctx.r[8].s64 = ctx.r[1].s64 + 288;
	// 824A6970: E9DF0008  ld r14, 8(r31)
	ctx.r[14].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 824A6974: F8660000  std r3, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 824A6978: FA060008  std r16, 8(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[16].u64 ) };
	// 824A697C: F8850000  std r4, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 824A6980: 389F0030  addi r4, r31, 0x30
	ctx.r[4].s64 = ctx.r[31].s64 + 48;
	// 824A6984: E8DF0000  ld r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 824A6988: F8E50008  std r7, 8(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 824A698C: 38FF0010  addi r7, r31, 0x10
	ctx.r[7].s64 = ctx.r[31].s64 + 16;
	// 824A6990: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 824A6994: E9E40000  ld r15, 0(r4)
	ctx.r[15].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 824A6998: F8CB0000  std r6, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 824A699C: E8670000  ld r3, 0(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 824A69A0: F9CB0008  std r14, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[14].u64 ) };
	// 824A69A4: 38C10160  addi r6, r1, 0x160
	ctx.r[6].s64 = ctx.r[1].s64 + 352;
	// 824A69A8: E8E70008  ld r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 824A69AC: 39610180  addi r11, r1, 0x180
	ctx.r[11].s64 = ctx.r[1].s64 + 384;
	// 824A69B0: EA050000  ld r16, 0(r5)
	ctx.r[16].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	// 824A69B4: E8A50008  ld r5, 8(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	// 824A69B8: F86A0000  std r3, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 824A69BC: E8840008  ld r4, 8(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
            }
            0x824A6E60 => {
    //   block [0x824A6E60..0x824A6E74)
	// 824A6E60: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 824A6E64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A6E68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A6E6C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 824A6E70: 419A0040  beq cr6, 0x824a6eb0
	if ctx.cr[6].eq {
	pc = 0x824A6EB0; continue 'dispatch;
	}
	pc = 0x824A6E74; continue 'dispatch;
            }
            0x824A6E74 => {
    //   block [0x824A6E74..0x824A6E98)
	// 824A6E74: 39740050  addi r11, r20, 0x50
	ctx.r[11].s64 = ctx.r[20].s64 + 80;
	// 824A6E78: 3A310001  addi r17, r17, 1
	ctx.r[17].s64 = ctx.r[17].s64 + 1;
	// 824A6E7C: 3A730008  addi r19, r19, 8
	ctx.r[19].s64 = ctx.r[19].s64 + 8;
	// 824A6E80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A6E84: 7F115800  cmpw cr6, r17, r11
	ctx.cr[6].compare_i32(ctx.r[17].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A6E88: 4198FA08  blt cr6, 0x824a6890
	if ctx.cr[6].lt {
	pc = 0x824A6890; continue 'dispatch;
	}
	// 824A6E8C: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 824A6E90: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A6E94: 83A133B4  lwz r29, 0x33b4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(13236 as u32) ) } as u64;
	pc = 0x824A6E98; continue 'dispatch;
            }
            0x824A6E98 => {
    //   block [0x824A6E98..0x824A6EB0)
	// 824A6E98: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 824A6E9C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824A6EA0: 7F1CE800  cmpw cr6, r28, r29
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[29].s32, &mut ctx.xer);
	// 824A6EA4: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 824A6EA8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 824A6EAC: 4198F9B4  blt cr6, 0x824a6860
	if ctx.cr[6].lt {
	pc = 0x824A6860; continue 'dispatch;
	}
	pc = 0x824A6EB0; continue 'dispatch;
            }
            0x824A6EB0 => {
    //   block [0x824A6EB0..0x824A6ED0)
	// 824A6EB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 824A6EB4: 4BFC6515  bl 0x8246d3c8
	ctx.lr = 0x824A6EB8;
	sub_8246D3C8(ctx, base);
	// 824A6EB8: 38213390  addi r1, r1, 0x3390
	ctx.r[1].s64 = ctx.r[1].s64 + 13200;
	// 824A6EBC: 3981FF00  addi r12, r1, -0x100
	ctx.r[12].s64 = ctx.r[1].s64 + -256;
	// 824A6EC0: 4809277D  bl 0x8253963c
	ctx.lr = 0x824A6EC4;
	sub_825393C8(ctx, base);
	// 824A6EC4: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 824A6EC8: 4808F14D  bl 0x82536014
	ctx.lr = 0x824A6ECC;
	sub_82535FFC(ctx, base);
	// 824A6ECC: 4808E204  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A6ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A6ED0 size=1308
    let mut pc: u32 = 0x824A6ED0;
    'dispatch: loop {
        match pc {
            0x824A6ED0 => {
    //   block [0x824A6ED0..0x824A6F2C)
	// 824A6ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A6ED4: 4808E1BD  bl 0x82535090
	ctx.lr = 0x824A6ED8;
	sub_82535080(ctx, base);
	// 824A6ED8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A6EDC: 834D0000  lwz r26, 0(r13)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A6EE0: 3A400014  li r18, 0x14
	ctx.r[18].s64 = 20;
	// 824A6EE4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824A6EE8: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 824A6EEC: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 824A6EF0: 7D5A902E  lwzx r10, r26, r18
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 824A6EF4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A6EF8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A6EFC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A6F00: 4098002C  bge cr6, 0x824a6f2c
	if !ctx.cr[6].lt {
	pc = 0x824A6F2C; continue 'dispatch;
	}
	// 824A6F04: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A6F08: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 824A6F0C: 392907DC  addi r9, r9, 0x7dc
	ctx.r[9].s64 = ctx.r[9].s64 + 2012;
	// 824A6F10: 390807D0  addi r8, r8, 0x7d0
	ctx.r[8].s64 = ctx.r[8].s64 + 2000;
	// 824A6F14: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A6F18: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 824A6F1C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A6F20: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 824A6F24: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A6F28: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A6F2C; continue 'dispatch;
            }
            0x824A6F2C => {
    //   block [0x824A6F2C..0x824A6F70)
	// 824A6F2C: 3AC00010  li r22, 0x10
	ctx.r[22].s64 = 16;
	// 824A6F30: 83B402FC  lwz r29, 0x2fc(r20)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(764 as u32) ) } as u64;
	// 824A6F34: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 824A6F38: 3FE08000  lis r31, -0x8000
	ctx.r[31].s64 = -2147483648;
	// 824A6F3C: 395D0002  addi r10, r29, 2
	ctx.r[10].s64 = ctx.r[29].s64 + 2;
	// 824A6F40: 7D7AB02E  lwzx r11, r26, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 824A6F44: 55441836  rlwinm r4, r10, 3, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 824A6F48: 92610060  stw r19, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[19].u32 ) };
	// 824A6F4C: 92610064  stw r19, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[19].u32 ) };
	// 824A6F50: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 824A6F54: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A6F58: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A6F5C: 7D432214  add r10, r3, r4
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 824A6F60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A6F64: 4199000C  bgt cr6, 0x824a6f70
	if ctx.cr[6].gt {
	pc = 0x824A6F70; continue 'dispatch;
	}
	// 824A6F68: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 824A6F6C: 48000018  b 0x824a6f84
	pc = 0x824A6F84; continue 'dispatch;
            }
            0x824A6F70 => {
    //   block [0x824A6F70..0x824A6F84)
	// 824A6F70: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A6F74: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A6F78: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A6F7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A6F80: 4E800421  bctrl
	ctx.lr = 0x824A6F84;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A6F84 => {
    //   block [0x824A6F84..0x824A6FCC)
	// 824A6F84: 7FAAFB78  or r10, r29, r31
	ctx.r[10].u64 = ctx.r[29].u64 | ctx.r[31].u64;
	// 824A6F88: 7D7AB02E  lwzx r11, r26, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 824A6F8C: 83D402FC  lwz r30, 0x2fc(r20)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(764 as u32) ) } as u64;
	// 824A6F90: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 824A6F94: 9061006C  stw r3, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[3].u32 ) };
	// 824A6F98: 92610070  stw r19, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[19].u32 ) };
	// 824A6F9C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 824A6FA0: 395E0002  addi r10, r30, 2
	ctx.r[10].s64 = ctx.r[30].s64 + 2;
	// 824A6FA4: 92610074  stw r19, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[19].u32 ) };
	// 824A6FA8: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 824A6FAC: 55441836  rlwinm r4, r10, 3, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 824A6FB0: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A6FB4: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A6FB8: 7D432214  add r10, r3, r4
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 824A6FBC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A6FC0: 4199000C  bgt cr6, 0x824a6fcc
	if ctx.cr[6].gt {
	pc = 0x824A6FCC; continue 'dispatch;
	}
	// 824A6FC4: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 824A6FC8: 48000018  b 0x824a6fe0
	pc = 0x824A6FE0; continue 'dispatch;
            }
            0x824A6FCC => {
    //   block [0x824A6FCC..0x824A6FE0)
	// 824A6FCC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A6FD0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A6FD4: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A6FD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A6FDC: 4E800421  bctrl
	ctx.lr = 0x824A6FE0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A6FE0 => {
    //   block [0x824A6FE0..0x824A7020)
	// 824A6FE0: 7FC9FB78  or r9, r30, r31
	ctx.r[9].u64 = ctx.r[30].u64 | ctx.r[31].u64;
	// 824A6FE4: 7D7AB02E  lwzx r11, r26, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 824A6FE8: 56AA2834  slwi r10, r21, 5
	ctx.r[10].u32 = ctx.r[21].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824A6FEC: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 824A6FF0: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 824A6FF4: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 824A6FF8: 91210078  stw r9, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 824A6FFC: 55440036  rlwinm r4, r10, 0, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 824A7000: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A7004: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A7008: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 824A700C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824A7010: 41990010  bgt cr6, 0x824a7020
	if ctx.cr[6].gt {
	pc = 0x824A7020; continue 'dispatch;
	}
	// 824A7014: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 824A7018: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 824A701C: 4800001C  b 0x824a7038
	pc = 0x824A7038; continue 'dispatch;
            }
            0x824A7020 => {
    //   block [0x824A7020..0x824A7038)
	// 824A7020: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A7024: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A7028: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A702C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A7030: 4E800421  bctrl
	ctx.lr = 0x824A7034;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A7034: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
            }
            0x824A7038 => {
    //   block [0x824A7038..0x824A7064)
	// 824A7038: 7C7AB02E  lwzx r3, r26, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 824A703C: 39750004  addi r11, r21, 4
	ctx.r[11].s64 = ctx.r[21].s64 + 4;
	// 824A7040: 55641036  rlwinm r4, r11, 2, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824A7044: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A7048: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A704C: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 824A7050: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A7054: 41990010  bgt cr6, 0x824a7064
	if ctx.cr[6].gt {
	pc = 0x824A7064; continue 'dispatch;
	}
	// 824A7058: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 824A705C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 824A7060: 48000018  b 0x824a7078
	pc = 0x824A7078; continue 'dispatch;
            }
            0x824A7064 => {
    //   block [0x824A7064..0x824A7078)
	// 824A7064: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A7068: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A706C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A7070: 4E800421  bctrl
	ctx.lr = 0x824A7074;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A7074: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
            }
            0x824A7078 => {
    //   block [0x824A7078..0x824A70A8)
	// 824A7078: 7D5A902E  lwzx r10, r26, r18
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 824A707C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A7080: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7084: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A7088: 40980020  bge cr6, 0x824a70a8
	if !ctx.cr[6].lt {
	pc = 0x824A70A8; continue 'dispatch;
	}
	// 824A708C: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A7090: 392907C4  addi r9, r9, 0x7c4
	ctx.r[9].s64 = ctx.r[9].s64 + 1988;
	// 824A7094: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A7098: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A709C: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A70A0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A70A4: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A70A8; continue 'dispatch;
            }
            0x824A70A8 => {
    //   block [0x824A70A8..0x824A70BC)
	// 824A70A8: 3B75FFFF  addi r27, r21, -1
	ctx.r[27].s64 = ctx.r[21].s64 + -1;
	// 824A70AC: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 824A70B0: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 824A70B4: 41980098  blt cr6, 0x824a714c
	if ctx.cr[6].lt {
	pc = 0x824A714C; continue 'dispatch;
	}
	// 824A70B8: 7F3CC050  subf r25, r28, r24
	ctx.r[25].s64 = ctx.r[24].s64 - ctx.r[28].s64;
	pc = 0x824A70BC; continue 'dispatch;
            }
            0x824A70BC => {
    //   block [0x824A70BC..0x824A70F4)
	// 824A70BC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A70C0: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 824A70C4: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 824A70C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 824A70CC: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 824A70D0: 7D79E12E  stwx r11, r25, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[25].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u32) };
	// 824A70D4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A70D8: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A70DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 824A70E0: 40990014  ble cr6, 0x824a70f4
	if !ctx.cr[6].gt {
	pc = 0x824A70F4; continue 'dispatch;
	}
	// 824A70E4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 824A70E8: 8074006C  lwz r3, 0x6c(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A70EC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 824A70F0: 4BFF51F1  bl 0x8249c2e0
	ctx.lr = 0x824A70F4;
	sub_8249C2E0(ctx, base);
	pc = 0x824A70F4; continue 'dispatch;
            }
            0x824A70F4 => {
    //   block [0x824A70F4..0x824A710C)
	// 824A70F4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 824A70F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A70FC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 824A7100: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 824A7104: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 824A7108: 394AFFE8  addi r10, r10, -0x18
	ctx.r[10].s64 = ctx.r[10].s64 + -24;
	pc = 0x824A710C; continue 'dispatch;
            }
            0x824A710C => {
    //   block [0x824A710C..0x824A714C)
	// 824A710C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A7110: 912AFFF8  stw r9, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[9].u32 ) };
	// 824A7114: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A7118: 912AFFFC  stw r9, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 824A711C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A7120: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A7124: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7128: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 824A712C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A7130: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 824A7134: 4200FFD8  bdnz 0x824a710c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824A710C; continue 'dispatch;
	}
	// 824A7138: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 824A713C: 3BBD0020  addi r29, r29, 0x20
	ctx.r[29].s64 = ctx.r[29].s64 + 32;
	// 824A7140: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 824A7144: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 824A7148: 4098FF74  bge cr6, 0x824a70bc
	if !ctx.cr[6].lt {
	pc = 0x824A70BC; continue 'dispatch;
	}
	pc = 0x824A714C; continue 'dispatch;
            }
            0x824A714C => {
    //   block [0x824A714C..0x824A717C)
	// 824A714C: 7D5A902E  lwzx r10, r26, r18
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 824A7150: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A7154: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7158: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A715C: 40980020  bge cr6, 0x824a717c
	if !ctx.cr[6].lt {
	pc = 0x824A717C; continue 'dispatch;
	}
	// 824A7160: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A7164: 392907B4  addi r9, r9, 0x7b4
	ctx.r[9].s64 = ctx.r[9].s64 + 1972;
	// 824A7168: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A716C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A7170: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A7174: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A7178: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A717C; continue 'dispatch;
            }
            0x824A717C => {
    //   block [0x824A717C..0x824A71CC)
	// 824A717C: 80740054  lwz r3, 0x54(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A7180: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 824A7184: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 824A7188: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 824A718C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 824A7190: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 824A7194: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A7198: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A719C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A71A0: 4E800421  bctrl
	ctx.lr = 0x824A71A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A71A4: 7C7AB02E  lwzx r3, r26, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 824A71A8: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A71AC: 93030020  stw r24, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[24].u32 ) };
	// 824A71B0: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A71B4: 409A0018  bne cr6, 0x824a71cc
	if !ctx.cr[6].eq {
	pc = 0x824A71CC; continue 'dispatch;
	}
	// 824A71B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A71BC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 824A71C0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A71C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A71C8: 4E800421  bctrl
	ctx.lr = 0x824A71CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A71CC => {
    //   block [0x824A71CC..0x824A71F4)
	// 824A71CC: 7C7AB02E  lwzx r3, r26, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 824A71D0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A71D4: 92E30020  stw r23, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[23].u32 ) };
	// 824A71D8: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A71DC: 409A0018  bne cr6, 0x824a71f4
	if !ctx.cr[6].eq {
	pc = 0x824A71F4; continue 'dispatch;
	}
	// 824A71E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A71E4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 824A71E8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A71EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A71F0: 4E800421  bctrl
	ctx.lr = 0x824A71F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A71F4 => {
    //   block [0x824A71F4..0x824A7234)
	// 824A71F4: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824A71F8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824A71FC: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A7200: 4081011C  ble 0x824a731c
	if !ctx.cr[0].gt {
	pc = 0x824A731C; continue 'dispatch;
	}
	// 824A7204: 7D5A902E  lwzx r10, r26, r18
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 824A7208: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A720C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7210: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A7214: 40980020  bge cr6, 0x824a7234
	if !ctx.cr[6].lt {
	pc = 0x824A7234; continue 'dispatch;
	}
	// 824A7218: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A721C: 392907A8  addi r9, r9, 0x7a8
	ctx.r[9].s64 = ctx.r[9].s64 + 1960;
	// 824A7220: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A7224: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A7228: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A722C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A7230: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A7234; continue 'dispatch;
            }
            0x824A7234 => {
    //   block [0x824A7234..0x824A7270)
	// 824A7234: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 824A7238: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 824A723C: 4805705D  bl 0x824fe298
	ctx.lr = 0x824A7240;
	sub_824FE298(ctx, base);
	// 824A7240: 7D5A902E  lwzx r10, r26, r18
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 824A7244: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A7248: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A724C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A7250: 40980020  bge cr6, 0x824a7270
	if !ctx.cr[6].lt {
	pc = 0x824A7270; continue 'dispatch;
	}
	// 824A7254: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A7258: 3929079C  addi r9, r9, 0x79c
	ctx.r[9].s64 = ctx.r[9].s64 + 1948;
	// 824A725C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A7260: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A7264: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A7268: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A726C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A7270; continue 'dispatch;
            }
            0x824A7270 => {
    //   block [0x824A7270..0x824A72C8)
	// 824A7270: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824A7274: 80740058  lwz r3, 0x58(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A7278: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824A727C: 48056FA5  bl 0x824fe220
	ctx.lr = 0x824A7280;
	sub_824FE220(ctx, base);
	// 824A7280: 3FE08293  lis r31, -0x7d6d
	ctx.r[31].s64 = -2104295424;
	// 824A7284: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824A7288: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824A728C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824A7290: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824A7294: 809F9004  lwz r4, -0x6ffc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-28668 as u32) ) } as u64;
	// 824A7298: 55653830  slwi r5, r11, 7
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A729C: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A72A0: 81490060  lwz r10, 0x60(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(96 as u32) ) } as u64;
	// 824A72A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 824A72A8: 4E800421  bctrl
	ctx.lr = 0x824A72AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A72AC: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A72B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A72B4: 409A0014  bne cr6, 0x824a72c8
	if !ctx.cr[6].eq {
	pc = 0x824A72C8; continue 'dispatch;
	}
	// 824A72B8: 817F9004  lwz r11, -0x6ffc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-28668 as u32) ) } as u64;
	// 824A72BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824A72C0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824A72C4: 48000058  b 0x824a731c
	pc = 0x824A731C; continue 'dispatch;
            }
            0x824A72C8 => {
    //   block [0x824A72C8..0x824A72F8)
	// 824A72C8: 7D5A902E  lwzx r10, r26, r18
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 824A72CC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A72D0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A72D4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A72D8: 40980020  bge cr6, 0x824a72f8
	if !ctx.cr[6].lt {
	pc = 0x824A72F8; continue 'dispatch;
	}
	// 824A72DC: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A72E0: 39290790  addi r9, r9, 0x790
	ctx.r[9].s64 = ctx.r[9].s64 + 1936;
	// 824A72E4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A72E8: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A72EC: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A72F0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A72F4: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A72F8; continue 'dispatch;
            }
            0x824A72F8 => {
    //   block [0x824A72F8..0x824A730C)
	// 824A72F8: 81740070  lwz r11, 0x70(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(112 as u32) ) } as u64;
	// 824A72FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A7300: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 824A7304: 409A0008  bne cr6, 0x824a730c
	if !ctx.cr[6].eq {
	pc = 0x824A730C; continue 'dispatch;
	}
	// 824A7308: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	pc = 0x824A730C; continue 'dispatch;
            }
            0x824A730C => {
    //   block [0x824A730C..0x824A731C)
	// 824A730C: 80740058  lwz r3, 0x58(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A7310: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824A7314: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824A7318: 48056E49  bl 0x824fe160
	ctx.lr = 0x824A731C;
	sub_824FE160(ctx, base);
	pc = 0x824A731C; continue 'dispatch;
            }
            0x824A731C => {
    //   block [0x824A731C..0x824A734C)
	// 824A731C: 7D5A902E  lwzx r10, r26, r18
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 824A7320: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7324: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A7328: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A732C: 40980020  bge cr6, 0x824a734c
	if !ctx.cr[6].lt {
	pc = 0x824A734C; continue 'dispatch;
	}
	// 824A7330: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A7334: 3929FE14  addi r9, r9, -0x1ec
	ctx.r[9].s64 = ctx.r[9].s64 + -492;
	// 824A7338: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A733C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A7340: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A7344: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A7348: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A734C; continue 'dispatch;
            }
            0x824A734C => {
    //   block [0x824A734C..0x824A7374)
	// 824A734C: 7C7AB02E  lwzx r3, r26, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 824A7350: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 824A7354: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A7358: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824A735C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A7360: 409A0014  bne cr6, 0x824a7374
	if !ctx.cr[6].eq {
	pc = 0x824A7374; continue 'dispatch;
	}
	// 824A7364: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A7368: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A736C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A7370: 4E800421  bctrl
	ctx.lr = 0x824A7374;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A7374 => {
    //   block [0x824A7374..0x824A7398)
	// 824A7374: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 824A7378: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A737C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A7380: 409A0018  bne cr6, 0x824a7398
	if !ctx.cr[6].eq {
	pc = 0x824A7398; continue 'dispatch;
	}
	// 824A7384: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A7388: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824A738C: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A7390: 7C7AB02E  lwzx r3, r26, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 824A7394: 4BFBCD25  bl 0x824640b8
	ctx.lr = 0x824A7398;
	sub_824640B8(ctx, base);
	pc = 0x824A7398; continue 'dispatch;
            }
            0x824A7398 => {
    //   block [0x824A7398..0x824A73C0)
	// 824A7398: 7C7AB02E  lwzx r3, r26, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 824A739C: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A73A0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A73A4: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824A73A8: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A73AC: 409A0014  bne cr6, 0x824a73c0
	if !ctx.cr[6].eq {
	pc = 0x824A73C0; continue 'dispatch;
	}
	// 824A73B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A73B4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A73B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A73BC: 4E800421  bctrl
	ctx.lr = 0x824A73C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A73C0 => {
    //   block [0x824A73C0..0x824A73E4)
	// 824A73C0: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 824A73C4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A73C8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A73CC: 409A0018  bne cr6, 0x824a73e4
	if !ctx.cr[6].eq {
	pc = 0x824A73E4; continue 'dispatch;
	}
	// 824A73D0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A73D4: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824A73D8: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A73DC: 7C7AB02E  lwzx r3, r26, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 824A73E0: 4BFBCCD9  bl 0x824640b8
	ctx.lr = 0x824A73E4;
	sub_824640B8(ctx, base);
	pc = 0x824A73E4; continue 'dispatch;
            }
            0x824A73E4 => {
    //   block [0x824A73E4..0x824A73EC)
	// 824A73E4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 824A73E8: 4808DCF8  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A73F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A73F0 size=864
    let mut pc: u32 = 0x824A73F0;
    'dispatch: loop {
        match pc {
            0x824A73F0 => {
    //   block [0x824A73F0..0x824A743C)
	// 824A73F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A73F4: 4808DCA1  bl 0x82535094
	ctx.lr = 0x824A73F8;
	sub_82535080(ctx, base);
	// 824A73F8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A73FC: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A7400: 3B400014  li r26, 0x14
	ctx.r[26].s64 = 20;
	// 824A7404: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A7408: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824A740C: 7D5AC82E  lwzx r10, r26, r25
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A7410: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A7414: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7418: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A741C: 40980020  bge cr6, 0x824a743c
	if !ctx.cr[6].lt {
	pc = 0x824A743C; continue 'dispatch;
	}
	// 824A7420: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A7424: 39290804  addi r9, r9, 0x804
	ctx.r[9].s64 = ctx.r[9].s64 + 2052;
	// 824A7428: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A742C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A7430: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A7434: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A7438: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A743C; continue 'dispatch;
            }
            0x824A743C => {
    //   block [0x824A743C..0x824A74DC)
	// 824A743C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7440: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 824A7444: E95B0000  ld r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 824A7448: 3E808293  lis r20, -0x7d6d
	ctx.r[20].s64 = -2104295424;
	// 824A744C: 396B0190  addi r11, r11, 0x190
	ctx.r[11].s64 = ctx.r[11].s64 + 400;
	// 824A7450: 7E7C9B78  mr r28, r19
	ctx.r[28].u64 = ctx.r[19].u64;
	// 824A7454: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 824A7458: E95B0008  ld r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	// 824A745C: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 824A7460: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7464: E95B0000  ld r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 824A7468: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A746C: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 824A7470: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 824A7474: E95B0008  ld r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	// 824A7478: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 824A747C: C01B0008  lfs f0, 8(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A7480: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7484: 814B02B4  lwz r10, 0x2b4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(692 as u32) ) } as u64;
	// 824A7488: C1AB02C0  lfs f13, 0x2c0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(704 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A748C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824A7490: D00B02AC  stfs f0, 0x2ac(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(684 as u32), tmp.u32 ) };
	// 824A7494: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 824A7498: C01B000C  lfs f0, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A749C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 824A74A0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 824A74A4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 824A74A8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 824A74AC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824A74B0: D00B02B0  stfs f0, 0x2b0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(688 as u32), tmp.u32 ) };
	// 824A74B4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A74B8: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A74BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824A74C0: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 824A74C4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A74C8: 3BCB0028  addi r30, r11, 0x28
	ctx.r[30].s64 = ctx.r[11].s64 + 40;
	// 824A74CC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A74D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A74D4: 40990044  ble cr6, 0x824a7518
	if !ctx.cr[6].gt {
	pc = 0x824A7518; continue 'dispatch;
	}
	// 824A74D8: 7E7D9B78  mr r29, r19
	ctx.r[29].u64 = ctx.r[19].u64;
	pc = 0x824A74DC; continue 'dispatch;
            }
            0x824A74DC => {
    //   block [0x824A74DC..0x824A7518)
	// 824A74DC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A74E0: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A74E4: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A74E8: 808B004C  lwz r4, 0x4c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 824A74EC: 806B0048  lwz r3, 0x48(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 824A74F0: 4BFFF9E1  bl 0x824a6ed0
	ctx.lr = 0x824A74F4;
	sub_824A6ED0(ctx, base);
	// 824A74F4: 81749004  lwz r11, -0x6ffc(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-28668 as u32) ) } as u64;
	// 824A74F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A74FC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 824A7500: 419A01FC  beq cr6, 0x824a76fc
	if ctx.cr[6].eq {
	pc = 0x824A76FC; continue 'dispatch;
	}
	// 824A7504: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A7508: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 824A750C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 824A7510: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A7514: 4198FFC8  blt cr6, 0x824a74dc
	if ctx.cr[6].lt {
	pc = 0x824A74DC; continue 'dispatch;
	}
	pc = 0x824A7518; continue 'dispatch;
            }
            0x824A7518 => {
    //   block [0x824A7518..0x824A7548)
	// 824A7518: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A751C: 81630084  lwz r11, 0x84(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A7520: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A7524: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A7528: 40820020  bne 0x824a7548
	if !ctx.cr[0].eq {
	pc = 0x824A7548; continue 'dispatch;
	}
	// 824A752C: 8963008C  lbz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A7530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A7534: 409A0014  bne cr6, 0x824a7548
	if !ctx.cr[6].eq {
	pc = 0x824A7548; continue 'dispatch;
	}
	// 824A7538: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A753C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A7540: 419A0008  beq cr6, 0x824a7548
	if ctx.cr[6].eq {
	pc = 0x824A7548; continue 'dispatch;
	}
	// 824A7544: 4BFEBC7D  bl 0x824931c0
	ctx.lr = 0x824A7548;
	sub_824931C0(ctx, base);
	pc = 0x824A7548; continue 'dispatch;
            }
            0x824A7548 => {
    //   block [0x824A7548..0x824A758C)
	// 824A7548: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A754C: 7E789B78  mr r24, r19
	ctx.r[24].u64 = ctx.r[19].u64;
	// 824A7550: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A7554: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824A7558: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 824A755C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7560: 3BAB0028  addi r29, r11, 0x28
	ctx.r[29].s64 = ctx.r[11].s64 + 40;
	// 824A7564: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A7568: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A756C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A7570: 3AAB74DC  addi r21, r11, 0x74dc
	ctx.r[21].s64 = ctx.r[11].s64 + 29916;
	// 824A7574: 40990128  ble cr6, 0x824a769c
	if !ctx.cr[6].gt {
	pc = 0x824A769C; continue 'dispatch;
	}
	// 824A7578: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A757C: 7E7C9B78  mr r28, r19
	ctx.r[28].u64 = ctx.r[19].u64;
	// 824A7580: 3AEB070C  addi r23, r11, 0x70c
	ctx.r[23].s64 = ctx.r[11].s64 + 1804;
	// 824A7584: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A7588: 3ACB07EC  addi r22, r11, 0x7ec
	ctx.r[22].s64 = ctx.r[11].s64 + 2028;
	pc = 0x824A758C; continue 'dispatch;
            }
            0x824A758C => {
    //   block [0x824A758C..0x824A75C4)
	// 824A758C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A7590: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7594: 7D7AC82E  lwzx r11, r26, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A7598: 7FCAE02E  lwzx r30, r10, r28
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824A759C: 80A9006C  lwz r5, 0x6c(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A75A0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A75A4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A75A8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A75AC: 40980018  bge cr6, 0x824a75c4
	if !ctx.cr[6].lt {
	pc = 0x824A75C4; continue 'dispatch;
	}
	// 824A75B0: 92EA0000  stw r23, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 824A75B4: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A75B8: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A75BC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A75C0: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A75C4; continue 'dispatch;
            }
            0x824A75C4 => {
    //   block [0x824A75C4..0x824A7608)
	// 824A75C4: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A75C8: 389E0058  addi r4, r30, 0x58
	ctx.r[4].s64 = ctx.r[30].s64 + 88;
	// 824A75CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824A75D0: 92650010  stw r19, 0x10(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[19].u32 ) };
	// 824A75D4: 396B1C60  addi r11, r11, 0x1c60
	ctx.r[11].s64 = ctx.r[11].s64 + 7264;
	// 824A75D8: 91650060  stw r11, 0x60(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824A75DC: 4802E70D  bl 0x824d5ce8
	ctx.lr = 0x824A75E0;
	sub_824D5CE8(ctx, base);
	// 824A75E0: 7D7AC82E  lwzx r11, r26, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A75E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A75E8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A75EC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A75F0: 40980018  bge cr6, 0x824a7608
	if !ctx.cr[6].lt {
	pc = 0x824A7608; continue 'dispatch;
	}
	// 824A75F4: 92AA0000  stw r21, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 824A75F8: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A75FC: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A7600: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A7604: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A7608; continue 'dispatch;
            }
            0x824A7608 => {
    //   block [0x824A7608..0x824A7650)
	// 824A7608: 81749004  lwz r11, -0x6ffc(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-28668 as u32) ) } as u64;
	// 824A760C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A7610: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 824A7614: 419A0088  beq cr6, 0x824a769c
	if ctx.cr[6].eq {
	pc = 0x824A769C; continue 'dispatch;
	}
	// 824A7618: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A761C: 816B016C  lwz r11, 0x16c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(364 as u32) ) } as u64;
	// 824A7620: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A7624: 419A0064  beq cr6, 0x824a7688
	if ctx.cr[6].eq {
	pc = 0x824A7688; continue 'dispatch;
	}
	// 824A7628: 7D5AC82E  lwzx r10, r26, r25
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A762C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A7630: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7634: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A7638: 40980018  bge cr6, 0x824a7650
	if !ctx.cr[6].lt {
	pc = 0x824A7650; continue 'dispatch;
	}
	// 824A763C: 92CB0000  stw r22, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 824A7640: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A7644: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A7648: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A764C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A7650; continue 'dispatch;
            }
            0x824A7650 => {
    //   block [0x824A7650..0x824A7688)
	// 824A7650: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 824A7654: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7658: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824A765C: 4BFFDEBD  bl 0x824a5518
	ctx.lr = 0x824A7660;
	sub_824A5518(ctx, base);
	// 824A7660: 7D7AC82E  lwzx r11, r26, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A7664: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A7668: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A766C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A7670: 40980018  bge cr6, 0x824a7688
	if !ctx.cr[6].lt {
	pc = 0x824A7688; continue 'dispatch;
	}
	// 824A7674: 92AA0000  stw r21, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 824A7678: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A767C: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824A7680: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A7684: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A7688; continue 'dispatch;
            }
            0x824A7688 => {
    //   block [0x824A7688..0x824A769C)
	// 824A7688: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A768C: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 824A7690: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 824A7694: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A7698: 4198FEF4  blt cr6, 0x824a758c
	if ctx.cr[6].lt {
	pc = 0x824A758C; continue 'dispatch;
	}
	pc = 0x824A769C; continue 'dispatch;
            }
            0x824A769C => {
    //   block [0x824A769C..0x824A76CC)
	// 824A769C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A76A0: 81630084  lwz r11, 0x84(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A76A4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A76A8: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A76AC: 40820020  bne 0x824a76cc
	if !ctx.cr[0].eq {
	pc = 0x824A76CC; continue 'dispatch;
	}
	// 824A76B0: 8963008C  lbz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A76B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A76B8: 409A0014  bne cr6, 0x824a76cc
	if !ctx.cr[6].eq {
	pc = 0x824A76CC; continue 'dispatch;
	}
	// 824A76BC: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A76C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A76C4: 419A0008  beq cr6, 0x824a76cc
	if ctx.cr[6].eq {
	pc = 0x824A76CC; continue 'dispatch;
	}
	// 824A76C8: 4BFEBAF9  bl 0x824931c0
	ctx.lr = 0x824A76CC;
	sub_824931C0(ctx, base);
	pc = 0x824A76CC; continue 'dispatch;
            }
            0x824A76CC => {
    //   block [0x824A76CC..0x824A76E4)
	// 824A76CC: 7D5AC82E  lwzx r10, r26, r25
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A76D0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A76D4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A76D8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A76DC: 40980018  bge cr6, 0x824a76f4
	if !ctx.cr[6].lt {
	pc = 0x824A76F4; continue 'dispatch;
	}
	// 824A76E0: 92AB0000  stw r21, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	pc = 0x824A76E4; continue 'dispatch;
            }
            0x824A76E4 => {
    //   block [0x824A76E4..0x824A76F4)
	// 824A76E4: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824A76E8: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824A76EC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824A76F0: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824A76F4; continue 'dispatch;
            }
            0x824A76F4 => {
    //   block [0x824A76F4..0x824A76FC)
	// 824A76F4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 824A76F8: 4808D9EC  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            0x824A76FC => {
    //   block [0x824A76FC..0x824A772C)
	// 824A76FC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7700: 81630084  lwz r11, 0x84(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A7704: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A7708: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A770C: 40820020  bne 0x824a772c
	if !ctx.cr[0].eq {
	pc = 0x824A772C; continue 'dispatch;
	}
	// 824A7710: 8963008C  lbz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A7714: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A7718: 409A0014  bne cr6, 0x824a772c
	if !ctx.cr[6].eq {
	pc = 0x824A772C; continue 'dispatch;
	}
	// 824A771C: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A7720: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A7724: 419A0008  beq cr6, 0x824a772c
	if ctx.cr[6].eq {
	pc = 0x824A772C; continue 'dispatch;
	}
	// 824A7728: 4BFEBA99  bl 0x824931c0
	ctx.lr = 0x824A772C;
	sub_824931C0(ctx, base);
	pc = 0x824A772C; continue 'dispatch;
            }
            0x824A772C => {
    //   block [0x824A772C..0x824A7750)
	// 824A772C: 7D5AC82E  lwzx r10, r26, r25
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824A7730: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A7734: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A7738: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A773C: 4098FFB8  bge cr6, 0x824a76f4
	if !ctx.cr[6].lt {
	pc = 0x824A76F4; continue 'dispatch;
	}
	// 824A7740: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 824A7744: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 824A7748: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A774C: 4BFFFF98  b 0x824a76e4
	pc = 0x824A76E4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A7760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A7760 size=96
    let mut pc: u32 = 0x824A7760;
    'dispatch: loop {
        match pc {
            0x824A7760 => {
    //   block [0x824A7760..0x824A779C)
	// 824A7760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A7764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A7768: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824A776C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A7770: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A7774: 7CEB0774  extsb r11, r7
	ctx.r[11].s64 = ctx.r[7].s8 as i64;
	// 824A7778: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824A777C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 824A7780: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A7784: 409A0018  bne cr6, 0x824a779c
	if !ctx.cr[6].eq {
	pc = 0x824A779C; continue 'dispatch;
	}
	// 824A7788: 3D60824A  lis r11, -0x7db6
	ctx.r[11].s64 = -2109079552;
	// 824A778C: 80C6006C  lwz r6, 0x6c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A7790: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 824A7794: 38EB59A0  addi r7, r11, 0x59a0
	ctx.r[7].s64 = ctx.r[11].s64 + 22944;
	// 824A7798: 4BFFEFF9  bl 0x824a6790
	ctx.lr = 0x824A779C;
	sub_824A6790(ctx, base);
	pc = 0x824A779C; continue 'dispatch;
            }
            0x824A779C => {
    //   block [0x824A779C..0x824A77C0)
	// 824A779C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824A77A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A77A4: 4BFF4B05  bl 0x8249c2a8
	ctx.lr = 0x824A77A8;
	sub_8249C2A8(ctx, base);
	// 824A77A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A77AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A77B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A77B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824A77B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A77BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A77C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A77C0 size=424
    let mut pc: u32 = 0x824A77C0;
    'dispatch: loop {
        match pc {
            0x824A77C0 => {
    //   block [0x824A77C0..0x824A7830)
	// 824A77C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A77C4: 4808D8E5  bl 0x825350a8
	ctx.lr = 0x824A77C8;
	sub_82535080(ctx, base);
	// 824A77C8: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 824A77CC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A77D0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 824A77D4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 824A77D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A77DC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 824A77E0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 824A77E4: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A77E8: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 824A77EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A77F0: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A77F4: 4BFEB6E5  bl 0x82492ed8
	ctx.lr = 0x824A77F8;
	sub_82492ED8(ctx, base);
	// 824A77F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A77FC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 824A7800: 4BFEB6C9  bl 0x82492ec8
	ctx.lr = 0x824A7804;
	sub_82492EC8(ctx, base);
	// 824A7804: EC1F0828  fsubs f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 824A7808: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A780C: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 824A7810: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 824A7814: D0210050  stfs f1, 0x50(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824A7818: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A781C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824A7820: 419A0010  beq cr6, 0x824a7830
	if ctx.cr[6].eq {
	pc = 0x824A7830; continue 'dispatch;
	}
	// 824A7824: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824A7828: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A782C: EDAD0024  fdivs f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x824A7830; continue 'dispatch;
            }
            0x824A7830 => {
    //   block [0x824A7830..0x824A786C)
	// 824A7830: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 824A7834: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A7838: 572907FE  clrlwi r9, r25, 0x1f
	ctx.r[9].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	// 824A783C: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 824A7840: 394A0050  addi r10, r10, 0x50
	ctx.r[10].s64 = ctx.r[10].s64 + 80;
	// 824A7844: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824A7848: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 824A784C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 824A7850: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 824A7854: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 824A7858: 419A0060  beq cr6, 0x824a78b8
	if ctx.cr[6].eq {
	pc = 0x824A78B8; continue 'dispatch;
	}
	// 824A785C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 824A7860: 40990034  ble cr6, 0x824a7894
	if !ctx.cr[6].gt {
	pc = 0x824A7894; continue 'dispatch;
	}
	// 824A7864: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 824A7868: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x824A786C; continue 'dispatch;
            }
            0x824A786C => {
    //   block [0x824A786C..0x824A7894)
	// 824A786C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A7870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A7874: 3B8B00E0  addi r28, r11, 0xe0
	ctx.r[28].s64 = ctx.r[11].s64 + 224;
	// 824A7878: 4BFEB651  bl 0x82492ec8
	ctx.lr = 0x824A787C;
	sub_82492EC8(ctx, base);
	// 824A787C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 824A7880: 48102061  bl 0x825a98e0
	ctx.lr = 0x824A7884;
	sub_825A98E0(ctx, base);
	// 824A7884: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 824A7888: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 824A788C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824A7890: 409AFFDC  bne cr6, 0x824a786c
	if !ctx.cr[6].eq {
	pc = 0x824A786C; continue 'dispatch;
	}
	pc = 0x824A7894; continue 'dispatch;
            }
            0x824A7894 => {
    //   block [0x824A7894..0x824A78B8)
	// 824A7894: 38C000D0  li r6, 0xd0
	ctx.r[6].s64 = 208;
	// 824A7898: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 824A789C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 824A78A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824A78A4: 48014785  bl 0x824bc028
	ctx.lr = 0x824A78A8;
	sub_824BC028(ctx, base);
	// 824A78A8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 824A78AC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 824A78B0: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A78B4: 4BFF4A2D  bl 0x8249c2e0
	ctx.lr = 0x824A78B8;
	sub_8249C2E0(ctx, base);
	pc = 0x824A78B8; continue 'dispatch;
            }
            0x824A78B8 => {
    //   block [0x824A78B8..0x824A78D4)
	// 824A78B8: 572B07BC  rlwinm r11, r25, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 824A78BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A78C0: 419A0014  beq cr6, 0x824a78d4
	if ctx.cr[6].eq {
	pc = 0x824A78D4; continue 'dispatch;
	}
	// 824A78C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824A78C8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824A78CC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 824A78D0: 4BFFF601  bl 0x824a6ed0
	ctx.lr = 0x824A78D4;
	sub_824A6ED0(ctx, base);
	pc = 0x824A78D4; continue 'dispatch;
            }
            0x824A78D4 => {
    //   block [0x824A78D4..0x824A78E4)
	// 824A78D4: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 824A78D8: 40990028  ble cr6, 0x824a7900
	if !ctx.cr[6].gt {
	pc = 0x824A7900; continue 'dispatch;
	}
	// 824A78DC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 824A78E0: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x824A78E4; continue 'dispatch;
            }
            0x824A78E4 => {
    //   block [0x824A78E4..0x824A7900)
	// 824A78E4: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A78E8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A78EC: 48010595  bl 0x824b7e80
	ctx.lr = 0x824A78F0;
	sub_824B7E80(ctx, base);
	// 824A78F0: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 824A78F4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 824A78F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824A78FC: 409AFFE8  bne cr6, 0x824a78e4
	if !ctx.cr[6].eq {
	pc = 0x824A78E4; continue 'dispatch;
	}
	pc = 0x824A7900; continue 'dispatch;
            }
            0x824A7900 => {
    //   block [0x824A7900..0x824A792C)
	// 824A7900: 572B077A  rlwinm r11, r25, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 824A7904: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A7908: 419A0024  beq cr6, 0x824a792c
	if ctx.cr[6].eq {
	pc = 0x824A792C; continue 'dispatch;
	}
	// 824A790C: 3D60824A  lis r11, -0x7db6
	ctx.r[11].s64 = -2109079552;
	// 824A7910: 80DF006C  lwz r6, 0x6c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A7914: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 824A7918: 38EB64C8  addi r7, r11, 0x64c8
	ctx.r[7].s64 = ctx.r[11].s64 + 25800;
	// 824A791C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 824A7920: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 824A7924: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 824A7928: 4BFFEE69  bl 0x824a6790
	ctx.lr = 0x824A792C;
	sub_824A6790(ctx, base);
	pc = 0x824A792C; continue 'dispatch;
            }
            0x824A792C => {
    //   block [0x824A792C..0x824A795C)
	// 824A792C: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A7930: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A7934: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A7938: 40820024  bne 0x824a795c
	if !ctx.cr[0].eq {
	pc = 0x824A795C; continue 'dispatch;
	}
	// 824A793C: 897F008C  lbz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A7940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A7944: 409A0018  bne cr6, 0x824a795c
	if !ctx.cr[6].eq {
	pc = 0x824A795C; continue 'dispatch;
	}
	// 824A7948: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A794C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A7950: 419A000C  beq cr6, 0x824a795c
	if ctx.cr[6].eq {
	pc = 0x824A795C; continue 'dispatch;
	}
	// 824A7954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A7958: 4BFEB869  bl 0x824931c0
	ctx.lr = 0x824A795C;
	sub_824931C0(ctx, base);
	pc = 0x824A795C; continue 'dispatch;
            }
            0x824A795C => {
    //   block [0x824A795C..0x824A7968)
	// 824A795C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 824A7960: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 824A7964: 4808D794  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A7968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A7968 size=208
    let mut pc: u32 = 0x824A7968;
    'dispatch: loop {
        match pc {
            0x824A7968 => {
    //   block [0x824A7968..0x824A7A1C)
	// 824A7968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A796C: 4808D745  bl 0x825350b0
	ctx.lr = 0x824A7970;
	sub_82535080(ctx, base);
	// 824A7970: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A7974: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 824A7978: E9470000  ld r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 824A797C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 824A7980: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 824A7984: E9070008  ld r8, 8(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 824A7988: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 824A798C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824A7990: 83DF006C  lwz r30, 0x6c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 824A7994: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824A7998: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824A799C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824A79A0: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 824A79A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 824A79A8: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 824A79AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824A79B0: F95E0050  std r10, 0x50(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 824A79B4: E9670008  ld r11, 8(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 824A79B8: F97E0058  std r11, 0x58(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 824A79BC: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A79C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A79C4: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A79C8: 4BFFF509  bl 0x824a6ed0
	ctx.lr = 0x824A79CC;
	sub_824A6ED0(ctx, base);
	// 824A79CC: 3D60824A  lis r11, -0x7db6
	ctx.r[11].s64 = -2109079552;
	// 824A79D0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 824A79D4: 38EB64C8  addi r7, r11, 0x64c8
	ctx.r[7].s64 = ctx.r[11].s64 + 25800;
	// 824A79D8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 824A79DC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 824A79E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824A79E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 824A79E8: 4BFFEDA9  bl 0x824a6790
	ctx.lr = 0x824A79EC;
	sub_824A6790(ctx, base);
	// 824A79EC: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A79F0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A79F4: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A79F8: 40820024  bne 0x824a7a1c
	if !ctx.cr[0].eq {
	pc = 0x824A7A1C; continue 'dispatch;
	}
	// 824A79FC: 897F008C  lbz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A7A00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A7A04: 409A0018  bne cr6, 0x824a7a1c
	if !ctx.cr[6].eq {
	pc = 0x824A7A1C; continue 'dispatch;
	}
	// 824A7A08: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A7A0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A7A10: 419A000C  beq cr6, 0x824a7a1c
	if ctx.cr[6].eq {
	pc = 0x824A7A1C; continue 'dispatch;
	}
	// 824A7A14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A7A18: 4BFEB7A9  bl 0x824931c0
	ctx.lr = 0x824A7A1C;
	sub_824931C0(ctx, base);
	pc = 0x824A7A1C; continue 'dispatch;
            }
            0x824A7A1C => {
    //   block [0x824A7A1C..0x824A7A38)
	// 824A7A1C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 824A7A20: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 824A7A24: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 824A7A28: F95E0050  std r10, 0x50(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 824A7A2C: F97E0058  std r11, 0x58(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 824A7A30: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824A7A34: 4808D6CC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A7A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A7A38 size=396
    let mut pc: u32 = 0x824A7A38;
    'dispatch: loop {
        match pc {
            0x824A7A38 => {
    //   block [0x824A7A38..0x824A7BC4)
	// 824A7A38: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 824A7A3C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 824A7A40: 3961FFE0  addi r11, r1, -0x20
	ctx.r[11].s64 = ctx.r[1].s64 + -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A7BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A7BC8 size=16
    let mut pc: u32 = 0x824A7BC8;
    'dispatch: loop {
        match pc {
            0x824A7BC8 => {
    //   block [0x824A7BC8..0x824A7BD8)
	// 824A7BC8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824A7BCC: 38800094  li r4, 0x94
	ctx.r[4].s64 = 148;
	// 824A7BD0: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 824A7BD4: 4BFFADDC  b 0x824a29b0
	sub_824A29B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A7BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A7BD8 size=32
    let mut pc: u32 = 0x824A7BD8;
    'dispatch: loop {
        match pc {
            0x824A7BD8 => {
    //   block [0x824A7BD8..0x824A7BF8)
	// 824A7BD8: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 824A7BDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A7BE0: 419A0018  beq cr6, 0x824a7bf8
	if ctx.cr[6].eq {
		sub_824A7BF8(ctx, base);
		return;
	}
	// 824A7BE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A7BE8: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 824A7BEC: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A7BF0: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824A7BF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A7BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A7BF8 size=16
    let mut pc: u32 = 0x824A7BF8;
    'dispatch: loop {
        match pc {
            0x824A7BF8 => {
    //   block [0x824A7BF8..0x824A7C08)
	// 824A7BF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A7BFC: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A7C00: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A7C04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A7C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A7C08 size=140
    let mut pc: u32 = 0x824A7C08;
    'dispatch: loop {
        match pc {
            0x824A7C08 => {
    //   block [0x824A7C08..0x824A7C6C)
	// 824A7C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A7C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A7C10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824A7C14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A7C18: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 824A7C1C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A7C20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A7C24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824A7C28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824A7C2C: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 824A7C30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824A7C34: C3EB2238  lfs f31, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824A7C38: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824A7C3C: 48103B25  bl 0x825ab760
	ctx.lr = 0x824A7C40;
	sub_825AB760(ctx, base);
	// 824A7C40: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A7C44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A7C48: 419A0024  beq cr6, 0x824a7c6c
	if ctx.cr[6].eq {
	pc = 0x824A7C6C; continue 'dispatch;
	}
	// 824A7C4C: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 824A7C50: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824A7C54: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 824A7C58: 48103B09  bl 0x825ab760
	ctx.lr = 0x824A7C5C;
	sub_825AB760(ctx, base);
	// 824A7C5C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A7C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A7C64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A7C68: 409A0008  bne cr6, 0x824a7c70
	if !ctx.cr[6].eq {
	pc = 0x824A7C70; continue 'dispatch;
	}
	pc = 0x824A7C6C; continue 'dispatch;
            }
            0x824A7C6C => {
    //   block [0x824A7C6C..0x824A7C70)
	// 824A7C6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824A7C70; continue 'dispatch;
            }
            0x824A7C70 => {
    //   block [0x824A7C70..0x824A7C94)
	// 824A7C70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824A7C74: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824A7C78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824A7C7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A7C80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A7C84: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 824A7C88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824A7C8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A7C90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A7C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A7C98 size=8
    let mut pc: u32 = 0x824A7C98;
    'dispatch: loop {
        match pc {
            0x824A7C98 => {
    //   block [0x824A7C98..0x824A7CA0)
	// 824A7C98: 3860000E  li r3, 0xe
	ctx.r[3].s64 = 14;
	// 824A7C9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A7CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A7CA0 size=464
    let mut pc: u32 = 0x824A7CA0;
    'dispatch: loop {
        match pc {
            0x824A7CA0 => {
    //   block [0x824A7CA0..0x824A7E70)
	// 824A7CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A7CA4: 4808D415  bl 0x825350b8
	ctx.lr = 0x824A7CA8;
	sub_82535080(ctx, base);
	// 824A7CA8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A7CAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A7CB0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 824A7CB4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 824A7CB8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 824A7CBC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 824A7CC0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 824A7CC4: 48103E8D  bl 0x825abb50
	ctx.lr = 0x824A7CC8;
	sub_825ABB50(ctx, base);
	// 824A7CC8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 824A7CCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824A7CD0: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 824A7CD4: 48103E7D  bl 0x825abb50
	ctx.lr = 0x824A7CD8;
	sub_825ABB50(ctx, base);
	// 824A7CD8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 824A7CDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 824A7CE0: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 824A7CE4: 3D005555  lis r8, 0x5555
	ctx.r[8].s64 = 1431633920;
	// 824A7CE8: 393F0060  addi r9, r31, 0x60
	ctx.r[9].s64 = ctx.r[31].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A7E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A7E70 size=188
    let mut pc: u32 = 0x824A7E70;
    'dispatch: loop {
        match pc {
            0x824A7E70 => {
    //   block [0x824A7E70..0x824A7F2C)
	// 824A7E70: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 824A7E74: 3921FFE0  addi r9, r1, -0x20
	ctx.r[9].s64 = ctx.r[1].s64 + -32;
	// 824A7E78: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 824A7E7C: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 824A7E80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824A7E84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A7F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A7F30 size=356
    let mut pc: u32 = 0x824A7F30;
    'dispatch: loop {
        match pc {
            0x824A7F30 => {
    //   block [0x824A7F30..0x824A8094)
	// 824A7F30: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 824A7F34: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A8098 size=16
    let mut pc: u32 = 0x824A8098;
    'dispatch: loop {
        match pc {
            0x824A8098 => {
    //   block [0x824A8098..0x824A80A8)
	// 824A8098: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824A809C: 38800084  li r4, 0x84
	ctx.r[4].s64 = 132;
	// 824A80A0: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 824A80A4: 4BFFA90C  b 0x824a29b0
	sub_824A29B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A80A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A80A8 size=20
    let mut pc: u32 = 0x824A80A8;
    'dispatch: loop {
        match pc {
            0x824A80A8 => {
    //   block [0x824A80A8..0x824A80BC)
	// 824A80A8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 824A80AC: 3940001C  li r10, 0x1c
	ctx.r[10].s64 = 28;
	// 824A80B0: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A80B4: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824A80B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A80C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A80C0 size=140
    let mut pc: u32 = 0x824A80C0;
    'dispatch: loop {
        match pc {
            0x824A80C0 => {
    //   block [0x824A80C0..0x824A8124)
	// 824A80C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A80C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A80C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824A80CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A80D0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 824A80D4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A80D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A80DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824A80E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824A80E4: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 824A80E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824A80EC: C3EB2238  lfs f31, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824A80F0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824A80F4: 4810366D  bl 0x825ab760
	ctx.lr = 0x824A80F8;
	sub_825AB760(ctx, base);
	// 824A80F8: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A80FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A8100: 419A0024  beq cr6, 0x824a8124
	if ctx.cr[6].eq {
	pc = 0x824A8124; continue 'dispatch;
	}
	// 824A8104: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 824A8108: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824A810C: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 824A8110: 48103651  bl 0x825ab760
	ctx.lr = 0x824A8114;
	sub_825AB760(ctx, base);
	// 824A8114: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A8118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A811C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A8120: 409A0008  bne cr6, 0x824a8128
	if !ctx.cr[6].eq {
	pc = 0x824A8128; continue 'dispatch;
	}
	pc = 0x824A8124; continue 'dispatch;
            }
            0x824A8124 => {
    //   block [0x824A8124..0x824A8128)
	// 824A8124: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824A8128; continue 'dispatch;
            }
            0x824A8128 => {
    //   block [0x824A8128..0x824A814C)
	// 824A8128: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824A812C: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824A8130: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824A8134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A8138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A813C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 824A8140: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824A8144: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A8148: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A8150 size=8
    let mut pc: u32 = 0x824A8150;
    'dispatch: loop {
        match pc {
            0x824A8150 => {
    //   block [0x824A8150..0x824A8158)
	// 824A8150: 38600012  li r3, 0x12
	ctx.r[3].s64 = 18;
	// 824A8154: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A8158 size=204
    let mut pc: u32 = 0x824A8158;
    'dispatch: loop {
        match pc {
            0x824A8158 => {
    //   block [0x824A8158..0x824A8224)
	// 824A8158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A815C: 4808CF61  bl 0x825350bc
	ctx.lr = 0x824A8160;
	sub_82535080(ctx, base);
	// 824A8160: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 824A8164: 3961FFD0  addi r11, r1, -0x30
	ctx.r[11].s64 = ctx.r[1].s64 + -48;
	// 824A8168: 38E8E1B4  addi r7, r8, -0x1e4c
	ctx.r[7].s64 = ctx.r[8].s64 + -7756;
	// 824A816C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 824A8170: 3941FFD0  addi r10, r1, -0x30
	ctx.r[10].s64 = ctx.r[1].s64 + -48;
	// 824A8174: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824A8178: 39230010  addi r9, r3, 0x10
	ctx.r[9].s64 = ctx.r[3].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824A8228 size=544
    let mut pc: u32 = 0x824A8228;
    'dispatch: loop {
        match pc {
            0x824A8228 => {
    //   block [0x824A8228..0x824A8268)
	// 824A8228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A822C: 4808CE89  bl 0x825350b4
	ctx.lr = 0x824A8230;
	sub_82535080(ctx, base);
	// 824A8230: C0060000  lfs f0, 0(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A8234: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 824A8238: C1A60004  lfs f13, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A823C: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 824A8240: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 824A8244: C1860008  lfs f12, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824A8248: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A824C: FD806210  fabs f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 824A8250: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 824A8254: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824A8258: 40980010  bge cr6, 0x824a8268
	if !ctx.cr[6].lt {
	pc = 0x824A8268; continue 'dispatch;
	}
	// 824A825C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A8260: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 824A8264: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x824A8268; continue 'dispatch;
            }
            0x824A8268 => {
    //   block [0x824A8268..0x824A8274)
	// 824A8268: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 824A826C: 40980008  bge cr6, 0x824a8274
	if !ctx.cr[6].lt {
	pc = 0x824A8274; continue 'dispatch;
	}
	// 824A8270: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x824A8274; continue 'dispatch;
            }
            0x824A8274 => {
    //   block [0x824A8274..0x824A8448)
	// 824A8274: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A8448 size=328
    let mut pc: u32 = 0x824A8448;
    'dispatch: loop {
        match pc {
            0x824A8448 => {
    //   block [0x824A8448..0x824A8590)
	// 824A8448: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A8590 size=16
    let mut pc: u32 = 0x824A8590;
    'dispatch: loop {
        match pc {
            0x824A8590 => {
    //   block [0x824A8590..0x824A85A0)
	// 824A8590: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824A8594: 388000AC  li r4, 0xac
	ctx.r[4].s64 = 172;
	// 824A8598: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 824A859C: 4BFFA414  b 0x824a29b0
	sub_824A29B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A85A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A85A0 size=20
    let mut pc: u32 = 0x824A85A0;
    'dispatch: loop {
        match pc {
            0x824A85A0 => {
    //   block [0x824A85A0..0x824A85B4)
	// 824A85A0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 824A85A4: 3940001C  li r10, 0x1c
	ctx.r[10].s64 = 28;
	// 824A85A8: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A85AC: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824A85B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A85B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A85B8 size=384
    let mut pc: u32 = 0x824A85B8;
    'dispatch: loop {
        match pc {
            0x824A85B8 => {
    //   block [0x824A85B8..0x824A863C)
	// 824A85B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A85BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A85C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824A85C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A85C8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 824A85CC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A85D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A85D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A85D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824A85DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824A85E0: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 824A85E4: C3EB2238  lfs f31, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824A85E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A85EC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824A85F0: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824A85F4: 4810316D  bl 0x825ab760
	ctx.lr = 0x824A85F8;
	sub_825AB760(ctx, base);
	// 824A85F8: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A85FC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824A8600: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 824A8604: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 824A8608: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 824A860C: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824A8610: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A8614: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824A8618: 419A0024  beq cr6, 0x824a863c
	if ctx.cr[6].eq {
	pc = 0x824A863C; continue 'dispatch;
	}
	// 824A861C: 389E0050  addi r4, r30, 0x50
	ctx.r[4].s64 = ctx.r[30].s64 + 80;
	// 824A8620: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824A8624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824A8628: 48103139  bl 0x825ab760
	ctx.lr = 0x824A862C;
	sub_825AB760(ctx, base);
	// 824A862C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A8630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A8634: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A8638: 409A0008  bne cr6, 0x824a8640
	if !ctx.cr[6].eq {
	pc = 0x824A8640; continue 'dispatch;
	}
	pc = 0x824A863C; continue 'dispatch;
            }
            0x824A863C => {
    //   block [0x824A863C..0x824A8640)
	// 824A863C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824A8640; continue 'dispatch;
            }
            0x824A8640 => {
    //   block [0x824A8640..0x824A8668)
	// 824A8640: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824A8644: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824A8648: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A864C: 419A001C  beq cr6, 0x824a8668
	if ctx.cr[6].eq {
	pc = 0x824A8668; continue 'dispatch;
	}
	// 824A8650: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A8654: C1BE009C  lfs f13, 0x9c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A8658: C00B233C  lfs f0, 0x233c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9020 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A865C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A8660: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824A8664: 419A0008  beq cr6, 0x824a866c
	if ctx.cr[6].eq {
	pc = 0x824A866C; continue 'dispatch;
	}
	pc = 0x824A8668; continue 'dispatch;
            }
            0x824A8668 => {
    //   block [0x824A8668..0x824A866C)
	// 824A8668: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824A866C; continue 'dispatch;
            }
            0x824A866C => {
    //   block [0x824A866C..0x824A8694)
	// 824A866C: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824A8670: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824A8674: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A8678: 419A001C  beq cr6, 0x824a8694
	if ctx.cr[6].eq {
	pc = 0x824A8694; continue 'dispatch;
	}
	// 824A867C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824A8680: C1BE00A0  lfs f13, 0xa0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A8684: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A8688: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A868C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824A8690: 40980008  bge cr6, 0x824a8698
	if !ctx.cr[6].lt {
	pc = 0x824A8698; continue 'dispatch;
	}
	pc = 0x824A8694; continue 'dispatch;
            }
            0x824A8694 => {
    //   block [0x824A8694..0x824A8698)
	// 824A8694: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824A8698; continue 'dispatch;
            }
            0x824A8698 => {
    //   block [0x824A8698..0x824A86C0)
	// 824A8698: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824A869C: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824A86A0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A86A4: 419A001C  beq cr6, 0x824a86c0
	if ctx.cr[6].eq {
	pc = 0x824A86C0; continue 'dispatch;
	}
	// 824A86A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824A86AC: C1BE00A0  lfs f13, 0xa0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A86B0: C00B2930  lfs f0, 0x2930(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A86B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A86B8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824A86BC: 41980008  blt cr6, 0x824a86c4
	if ctx.cr[6].lt {
	pc = 0x824A86C4; continue 'dispatch;
	}
	pc = 0x824A86C0; continue 'dispatch;
            }
            0x824A86C0 => {
    //   block [0x824A86C0..0x824A86C4)
	// 824A86C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824A86C4; continue 'dispatch;
            }
            0x824A86C4 => {
    //   block [0x824A86C4..0x824A86E8)
	// 824A86C4: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824A86C8: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824A86CC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A86D0: 419A0018  beq cr6, 0x824a86e8
	if ctx.cr[6].eq {
	pc = 0x824A86E8; continue 'dispatch;
	}
	// 824A86D4: C01E00B0  lfs f0, 0xb0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A86D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A86DC: C1BE00B4  lfs f13, 0xb4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A86E0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824A86E4: 40990008  ble cr6, 0x824a86ec
	if !ctx.cr[6].gt {
	pc = 0x824A86EC; continue 'dispatch;
	}
	pc = 0x824A86E8; continue 'dispatch;
            }
            0x824A86E8 => {
    //   block [0x824A86E8..0x824A86EC)
	// 824A86E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824A86EC; continue 'dispatch;
            }
            0x824A86EC => {
    //   block [0x824A86EC..0x824A8710)
	// 824A86EC: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824A86F0: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824A86F4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A86F8: 419A0018  beq cr6, 0x824a8710
	if ctx.cr[6].eq {
	pc = 0x824A8710; continue 'dispatch;
	}
	// 824A86FC: C01E0088  lfs f0, 0x88(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A8700: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A8704: C1BE008C  lfs f13, 0x8c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A8708: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824A870C: 40990008  ble cr6, 0x824a8714
	if !ctx.cr[6].gt {
	pc = 0x824A8714; continue 'dispatch;
	}
	pc = 0x824A8710; continue 'dispatch;
            }
            0x824A8710 => {
    //   block [0x824A8710..0x824A8714)
	// 824A8710: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824A8714; continue 'dispatch;
            }
            0x824A8714 => {
    //   block [0x824A8714..0x824A8738)
	// 824A8714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A8718: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824A871C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824A8720: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A8724: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A8728: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 824A872C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824A8730: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A8734: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A8738 size=28
    let mut pc: u32 = 0x824A8738;
    'dispatch: loop {
        match pc {
            0x824A8738 => {
    //   block [0x824A8738..0x824A8754)
	// 824A8738: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 824A873C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 824A8740: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 824A8744: 556B2636  rlwinm r11, r11, 4, 0x18, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 824A8748: 696B0010  xori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 ^ 16;
	// 824A874C: 9963009A  stb r11, 0x9a(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(154 as u32), ctx.r[11].u8 ) };
	// 824A8750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A8758 size=40
    let mut pc: u32 = 0x824A8758;
    'dispatch: loop {
        match pc {
            0x824A8758 => {
    //   block [0x824A8758..0x824A8780)
	// 824A8758: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	// 824A875C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824A8760: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A8780 size=40
    let mut pc: u32 = 0x824A8780;
    'dispatch: loop {
        match pc {
            0x824A8780 => {
    //   block [0x824A8780..0x824A87A8)
	// 824A8780: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 824A8784: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824A8788: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A87A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A87A8 size=8
    let mut pc: u32 = 0x824A87A8;
    'dispatch: loop {
        match pc {
            0x824A87A8 => {
    //   block [0x824A87A8..0x824A87B0)
	// 824A87A8: 38600013  li r3, 0x13
	ctx.r[3].s64 = 19;
	// 824A87AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A87B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A87B0 size=312
    let mut pc: u32 = 0x824A87B0;
    'dispatch: loop {
        match pc {
            0x824A87B0 => {
    //   block [0x824A87B0..0x824A88E8)
	// 824A87B0: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 824A87B4: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 824A87B8: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 824A87BC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824A87C0: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 824A87C4: 3BE00004  li r31, 4
	ctx.r[31].s64 = 4;
	// 824A87C8: 3BC0000F  li r30, 0xf
	ctx.r[30].s64 = 15;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A88E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A88E8 size=336
    let mut pc: u32 = 0x824A88E8;
    'dispatch: loop {
        match pc {
            0x824A88E8 => {
    //   block [0x824A88E8..0x824A8A38)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824A8A38 size=80
    let mut pc: u32 = 0x824A8A38;
    'dispatch: loop {
        match pc {
            0x824A8A38 => {
    //   block [0x824A8A38..0x824A8A88)
	// 824A8A38: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824A8A3C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A8A40: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824A8A44: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 824A8A48: 396BE320  addi r11, r11, -0x1ce0
	ctx.r[11].s64 = ctx.r[11].s64 + -7392;
	// 824A8A4C: C1AA0858  lfs f13, 0x858(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824A8A50: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824A8A54: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 824A8A58: 99030008  stb r8, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u8 ) };
	// 824A8A5C: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824A8A60: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A8A64: C18A24B0  lfs f12, 0x24b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9392 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824A8A68: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824A8A6C: D1830010  stfs f12, 0x10(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 824A8A70: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A8A74: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 824A8A78: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 824A8A7C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824A8A80: 99430008  stb r10, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 824A8A84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824A8A88 size=60
    let mut pc: u32 = 0x824A8A88;
    'dispatch: loop {
        match pc {
            0x824A8A88 => {
    //   block [0x824A8A88..0x824A8AC4)
	// 824A8A88: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A8A8C: FC001850  fneg f0, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[3].u64 ^ 0x8000_0000_0000_0000u64;
	// 824A8A90: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824A8A94: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 824A8A98: 396BE320  addi r11, r11, -0x1ce0
	ctx.r[11].s64 = ctx.r[11].s64 + -7392;
	// 824A8A9C: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 824A8AA0: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824A8AA4: 99230008  stb r9, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u8 ) };
	// 824A8AA8: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824A8AAC: D0630010  stfs f3, 0x10(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 824A8AB0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A8AB4: D0230014  stfs f1, 0x14(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 824A8AB8: 99030008  stb r8, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u8 ) };
	// 824A8ABC: D0430018  stfs f2, 0x18(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824A8AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824A8AC8 size=156
    let mut pc: u32 = 0x824A8AC8;
    'dispatch: loop {
        match pc {
            0x824A8AC8 => {
    //   block [0x824A8AC8..0x824A8B64)
	// 824A8AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A8ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A8AD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A8AD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A8AD8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A8ADC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824A8AE0: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 824A8AE4: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 824A8AE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A8AEC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A8AF0: 4BFBB549  bl 0x82464038
	ctx.lr = 0x824A8AF4;
	sub_82464038(ctx, base);
	// 824A8AF4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A8AF8: 3900001C  li r8, 0x1c
	ctx.r[8].s64 = 28;
	// 824A8AFC: 396BE2F8  addi r11, r11, -0x1d08
	ctx.r[11].s64 = ctx.r[11].s64 + -7432;
	// 824A8B00: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824A8B04: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824A8B08: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A8B0C: B1030004  sth r8, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u16 ) };
	// 824A8B10: 394AE30C  addi r10, r10, -0x1cf4
	ctx.r[10].s64 = ctx.r[10].s64 + -7412;
	// 824A8B14: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A8B18: 3929E320  addi r9, r9, -0x1ce0
	ctx.r[9].s64 = ctx.r[9].s64 + -7392;
	// 824A8B1C: B0E30006  sth r7, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[7].u16 ) };
	// 824A8B20: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A8B24: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824A8B28: 99630008  stb r11, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 824A8B2C: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A8B30: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824A8B34: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A8B38: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A8B3C: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 824A8B40: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A8B44: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 824A8B48: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824A8B4C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824A8B50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824A8B54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A8B58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A8B5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A8B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A8B68 size=156
    let mut pc: u32 = 0x824A8B68;
    'dispatch: loop {
        match pc {
            0x824A8B68 => {
    //   block [0x824A8B68..0x824A8BA4)
	// 824A8B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A8B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A8B70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824A8B74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A8B78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A8B7C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824A8B80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824A8B84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824A8B88: 419A001C  beq cr6, 0x824a8ba4
	if ctx.cr[6].eq {
	pc = 0x824A8BA4; continue 'dispatch;
	}
	// 824A8B8C: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A8B90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A8B94: 419A0010  beq cr6, 0x824a8ba4
	if ctx.cr[6].eq {
	pc = 0x824A8BA4; continue 'dispatch;
	}
	// 824A8B98: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 824A8B9C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A8BA0: B17F0006  sth r11, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x824A8BA4; continue 'dispatch;
            }
            0x824A8BA4 => {
    //   block [0x824A8BA4..0x824A8BE8)
	// 824A8BA4: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A8BA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824A8BAC: 419A003C  beq cr6, 0x824a8be8
	if ctx.cr[6].eq {
	pc = 0x824A8BE8; continue 'dispatch;
	}
	// 824A8BB0: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A8BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A8BB8: 419A0030  beq cr6, 0x824a8be8
	if ctx.cr[6].eq {
	pc = 0x824A8BE8; continue 'dispatch;
	}
	// 824A8BBC: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824A8BC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824A8BC4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824A8BC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A8BCC: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824A8BD0: 409A0018  bne cr6, 0x824a8be8
	if !ctx.cr[6].eq {
	pc = 0x824A8BE8; continue 'dispatch;
	}
	// 824A8BD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A8BD8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824A8BDC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A8BE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A8BE4: 4E800421  bctrl
	ctx.lr = 0x824A8BE8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A8BE8 => {
    //   block [0x824A8BE8..0x824A8C04)
	// 824A8BE8: 93FE0018  stw r31, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 824A8BEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A8BF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A8BF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A8BF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824A8BFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A8C00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A8C08 size=20
    let mut pc: u32 = 0x824A8C08;
    'dispatch: loop {
        match pc {
            0x824A8C08 => {
    //   block [0x824A8C08..0x824A8C1C)
	// 824A8C08: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 824A8C0C: 3940003C  li r10, 0x3c
	ctx.r[10].s64 = 60;
	// 824A8C10: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A8C14: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824A8C18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A8C30 size=8
    let mut pc: u32 = 0x824A8C30;
    'dispatch: loop {
        match pc {
            0x824A8C30 => {
    //   block [0x824A8C30..0x824A8C38)
	// 824A8C30: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 824A8C34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A8C38 size=292
    let mut pc: u32 = 0x824A8C38;
    'dispatch: loop {
        match pc {
            0x824A8C38 => {
    //   block [0x824A8C38..0x824A8C74)
	// 824A8C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A8C3C: 4808C47D  bl 0x825350b8
	ctx.lr = 0x824A8C40;
	sub_82535080(ctx, base);
	// 824A8C40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A8C44: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 824A8C48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A8C4C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824A8C50: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824A8C54: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824A8C58: 419A001C  beq cr6, 0x824a8c74
	if ctx.cr[6].eq {
	pc = 0x824A8C74; continue 'dispatch;
	}
	// 824A8C5C: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A8C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A8C64: 419A0010  beq cr6, 0x824a8c74
	if ctx.cr[6].eq {
	pc = 0x824A8C74; continue 'dispatch;
	}
	// 824A8C68: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 824A8C6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A8C70: B17E0006  sth r11, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x824A8C74; continue 'dispatch;
            }
            0x824A8C74 => {
    //   block [0x824A8C74..0x824A8CB8)
	// 824A8C74: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A8C78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824A8C7C: 419A003C  beq cr6, 0x824a8cb8
	if ctx.cr[6].eq {
	pc = 0x824A8CB8; continue 'dispatch;
	}
	// 824A8C80: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A8C84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A8C88: 419A0030  beq cr6, 0x824a8cb8
	if ctx.cr[6].eq {
	pc = 0x824A8CB8; continue 'dispatch;
	}
	// 824A8C8C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824A8C90: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824A8C94: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824A8C98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A8C9C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824A8CA0: 409A0018  bne cr6, 0x824a8cb8
	if !ctx.cr[6].eq {
	pc = 0x824A8CB8; continue 'dispatch;
	}
	// 824A8CA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A8CA8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824A8CAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A8CB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A8CB4: 4E800421  bctrl
	ctx.lr = 0x824A8CB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A8CB8 => {
    //   block [0x824A8CB8..0x824A8D5C)
	// 824A8CB8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 824A8CBC: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 824A8CC0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 824A8CC4: 397F0030  addi r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
	// 824A8CC8: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 824A8CCC: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A8D60 size=236
    let mut pc: u32 = 0x824A8D60;
    'dispatch: loop {
        match pc {
            0x824A8D60 => {
    //   block [0x824A8D60..0x824A8E4C)
	// 824A8D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A8D64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A8D68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A8D6C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A8D70: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824A8D74: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 824A8D78: 3909E418  addi r8, r9, -0x1be8
	ctx.r[8].s64 = ctx.r[9].s64 + -7144;
	// 824A8D7C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 824A8D80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A8D84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A8E50 size=132
    let mut pc: u32 = 0x824A8E50;
    'dispatch: loop {
        match pc {
            0x824A8E50 => {
    //   block [0x824A8E50..0x824A8EB4)
	// 824A8E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A8E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A8E58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A8E5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A8E60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A8E64: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A8E68: 396BE418  addi r11, r11, -0x1be8
	ctx.r[11].s64 = ctx.r[11].s64 + -7144;
	// 824A8E6C: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A8E70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824A8E74: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A8E78: 419A003C  beq cr6, 0x824a8eb4
	if ctx.cr[6].eq {
	pc = 0x824A8EB4; continue 'dispatch;
	}
	// 824A8E7C: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A8E80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A8E84: 419A0030  beq cr6, 0x824a8eb4
	if ctx.cr[6].eq {
	pc = 0x824A8EB4; continue 'dispatch;
	}
	// 824A8E88: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824A8E8C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824A8E90: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824A8E94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A8E98: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824A8E9C: 409A0018  bne cr6, 0x824a8eb4
	if !ctx.cr[6].eq {
	pc = 0x824A8EB4; continue 'dispatch;
	}
	// 824A8EA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A8EA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824A8EA8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A8EAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A8EB0: 4E800421  bctrl
	ctx.lr = 0x824A8EB4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A8EB4 => {
    //   block [0x824A8EB4..0x824A8ED4)
	// 824A8EB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824A8EB8: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824A8EBC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A8EC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824A8EC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A8EC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A8ECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A8ED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A8ED8 size=52
    let mut pc: u32 = 0x824A8ED8;
    'dispatch: loop {
        match pc {
            0x824A8ED8 => {
    //   block [0x824A8ED8..0x824A8F0C)
	// 824A8ED8: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 824A8EDC: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 824A8EE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 824A8EE4: 39000180  li r8, 0x180
	ctx.r[8].s64 = 384;
	// 824A8EE8: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 824A8EEC: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 824A8EF0: 91640010  stw r11, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 824A8EF4: 91440014  stw r10, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 824A8EF8: 91240000  stw r9, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824A8EFC: 91040004  stw r8, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824A8F00: 90E40008  stw r7, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 824A8F04: 90C4000C  stw r6, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 824A8F08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A8F10 size=40
    let mut pc: u32 = 0x824A8F10;
    'dispatch: loop {
        match pc {
            0x824A8F10 => {
    //   block [0x824A8F10..0x824A8F2C)
	// 824A8F10: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A8F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A8F18: 419A0014  beq cr6, 0x824a8f2c
	if ctx.cr[6].eq {
	pc = 0x824A8F2C; continue 'dispatch;
	}
	// 824A8F1C: 89640020  lbz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A8F20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A8F24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824A8F28: 409A0008  bne cr6, 0x824a8f30
	if !ctx.cr[6].eq {
	pc = 0x824A8F30; continue 'dispatch;
	}
	pc = 0x824A8F2C; continue 'dispatch;
            }
            0x824A8F2C => {
    //   block [0x824A8F2C..0x824A8F30)
	// 824A8F2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824A8F30; continue 'dispatch;
            }
            0x824A8F30 => {
    //   block [0x824A8F30..0x824A8F38)
	// 824A8F30: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824A8F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A8F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A8F38 size=512
    let mut pc: u32 = 0x824A8F38;
    'dispatch: loop {
        match pc {
            0x824A8F38 => {
    //   block [0x824A8F38..0x824A8F80)
	// 824A8F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A8F3C: 4808C16D  bl 0x825350a8
	ctx.lr = 0x824A8F40;
	sub_82535080(ctx, base);
	// 824A8F40: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 824A8F44: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A8F48: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 824A8F4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A8F50: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 824A8F54: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 824A8F58: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 824A8F5C: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 824A8F60: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 824A8F64: 419A001C  beq cr6, 0x824a8f80
	if ctx.cr[6].eq {
	pc = 0x824A8F80; continue 'dispatch;
	}
	// 824A8F68: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A8F6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A8F70: 419A0010  beq cr6, 0x824a8f80
	if ctx.cr[6].eq {
	pc = 0x824A8F80; continue 'dispatch;
	}
	// 824A8F74: A17D0006  lhz r11, 6(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(6 as u32) ) } as u64;
	// 824A8F78: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A8F7C: B17D0006  sth r11, 6(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x824A8F80; continue 'dispatch;
            }
            0x824A8F80 => {
    //   block [0x824A8F80..0x824A8FC4)
	// 824A8F80: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A8F84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824A8F88: 419A003C  beq cr6, 0x824a8fc4
	if ctx.cr[6].eq {
	pc = 0x824A8FC4; continue 'dispatch;
	}
	// 824A8F8C: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A8F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A8F94: 419A0030  beq cr6, 0x824a8fc4
	if ctx.cr[6].eq {
	pc = 0x824A8FC4; continue 'dispatch;
	}
	// 824A8F98: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824A8F9C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824A8FA0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824A8FA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A8FA8: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824A8FAC: 409A0018  bne cr6, 0x824a8fc4
	if !ctx.cr[6].eq {
	pc = 0x824A8FC4; continue 'dispatch;
	}
	// 824A8FB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A8FB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824A8FB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A8FBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A8FC0: 4E800421  bctrl
	ctx.lr = 0x824A8FC4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A8FC4 => {
    //   block [0x824A8FC4..0x824A9138)
	// 824A8FC4: 397F0070  addi r11, r31, 0x70
	ctx.r[11].s64 = ctx.r[31].s64 + 112;
	// 824A8FC8: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 824A8FCC: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A9138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A9138 size=1140
    let mut pc: u32 = 0x824A9138;
    'dispatch: loop {
        match pc {
            0x824A9138 => {
    //   block [0x824A9138..0x824A95AC)
	// 824A9138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A913C: 4808BF79  bl 0x825350b4
	ctx.lr = 0x824A9140;
	sub_82535080(ctx, base);
	// 824A9140: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A95B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A95B0 size=120
    let mut pc: u32 = 0x824A95B0;
    'dispatch: loop {
        match pc {
            0x824A95B0 => {
    //   block [0x824A95B0..0x824A95C4)
	// 824A95B0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A95B4: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 824A95B8: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824A95BC: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 824A95C0: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	pc = 0x824A95C4; continue 'dispatch;
            }
            0x824A95C4 => {
    //   block [0x824A95C4..0x824A95F0)
	// 824A95C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A95C8: 7D67582E  lwzx r11, r7, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A95CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A95D0: 409A0044  bne cr6, 0x824a9614
	if !ctx.cr[6].eq {
	pc = 0x824A9614; continue 'dispatch;
	}
	// 824A95D4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A95D8: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 824A95DC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824A95E0: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824A95E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824A95E8: 4098002C  bge cr6, 0x824a9614
	if !ctx.cr[6].lt {
	pc = 0x824A9614; continue 'dispatch;
	}
	// 824A95EC: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	pc = 0x824A95F0; continue 'dispatch;
            }
            0x824A95F0 => {
    //   block [0x824A95F0..0x824A9614)
	// 824A95F0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A95F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A95F8: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824A95FC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824A9600: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A9604: 90C90000  stw r6, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 824A9608: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A960C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A9610: 4198FFE0  blt cr6, 0x824a95f0
	if ctx.cr[6].lt {
	pc = 0x824A95F0; continue 'dispatch;
	}
	pc = 0x824A9614; continue 'dispatch;
            }
            0x824A9614 => {
    //   block [0x824A9614..0x824A9628)
	// 824A9614: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 824A9618: 38E7FFFC  addi r7, r7, -4
	ctx.r[7].s64 = ctx.r[7].s64 + -4;
	// 824A961C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824A9620: 4098FFA4  bge cr6, 0x824a95c4
	if !ctx.cr[6].lt {
	pc = 0x824A95C4; continue 'dispatch;
	}
	// 824A9624: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A9628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A9628 size=120
    let mut pc: u32 = 0x824A9628;
    'dispatch: loop {
        match pc {
            0x824A9628 => {
    //   block [0x824A9628..0x824A963C)
	// 824A9628: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A962C: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 824A9630: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824A9634: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 824A9638: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	pc = 0x824A963C; continue 'dispatch;
            }
            0x824A963C => {
    //   block [0x824A963C..0x824A9668)
	// 824A963C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9640: 7D67582E  lwzx r11, r7, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824A9644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A9648: 409A0044  bne cr6, 0x824a968c
	if !ctx.cr[6].eq {
	pc = 0x824A968C; continue 'dispatch;
	}
	// 824A964C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A9650: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 824A9654: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824A9658: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824A965C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824A9660: 4098002C  bge cr6, 0x824a968c
	if !ctx.cr[6].lt {
	pc = 0x824A968C; continue 'dispatch;
	}
	// 824A9664: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	pc = 0x824A9668; continue 'dispatch;
            }
            0x824A9668 => {
    //   block [0x824A9668..0x824A968C)
	// 824A9668: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A966C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A9670: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824A9674: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824A9678: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A967C: 90C90000  stw r6, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 824A9680: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A9684: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A9688: 4198FFE0  blt cr6, 0x824a9668
	if ctx.cr[6].lt {
	pc = 0x824A9668; continue 'dispatch;
	}
	pc = 0x824A968C; continue 'dispatch;
            }
            0x824A968C => {
    //   block [0x824A968C..0x824A96A0)
	// 824A968C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 824A9690: 38E7FFFC  addi r7, r7, -4
	ctx.r[7].s64 = ctx.r[7].s64 + -4;
	// 824A9694: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824A9698: 4098FFA4  bge cr6, 0x824a963c
	if !ctx.cr[6].lt {
	pc = 0x824A963C; continue 'dispatch;
	}
	// 824A969C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A96A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A96A0 size=100
    let mut pc: u32 = 0x824A96A0;
    'dispatch: loop {
        match pc {
            0x824A96A0 => {
    //   block [0x824A96A0..0x824A96C4)
	// 824A96A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A96A4: 4808BA19  bl 0x825350bc
	ctx.lr = 0x824A96A8;
	sub_82535080(ctx, base);
	// 824A96A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A96AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824A96B0: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 824A96B4: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 824A96B8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 824A96BC: 41980040  blt cr6, 0x824a96fc
	if ctx.cr[6].lt {
	pc = 0x824A96FC; continue 'dispatch;
	}
	// 824A96C0: 57BF103A  slwi r31, r29, 2
	ctx.r[31].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x824A96C4; continue 'dispatch;
            }
            0x824A96C4 => {
    //   block [0x824A96C4..0x824A96EC)
	// 824A96C4: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A96C8: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 824A96CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824A96D0: 419A001C  beq cr6, 0x824a96ec
	if ctx.cr[6].eq {
	pc = 0x824A96EC; continue 'dispatch;
	}
	// 824A96D4: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 824A96D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824A96DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A96E0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A96E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A96E8: 4E800421  bctrl
	ctx.lr = 0x824A96EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A96EC => {
    //   block [0x824A96EC..0x824A96FC)
	// 824A96EC: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 824A96F0: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 824A96F4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 824A96F8: 4098FFCC  bge cr6, 0x824a96c4
	if !ctx.cr[6].lt {
	pc = 0x824A96C4; continue 'dispatch;
	}
	pc = 0x824A96FC; continue 'dispatch;
            }
            0x824A96FC => {
    //   block [0x824A96FC..0x824A9704)
	// 824A96FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A9700: 4808BA0C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A9708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A9708 size=108
    let mut pc: u32 = 0x824A9708;
    'dispatch: loop {
        match pc {
            0x824A9708 => {
    //   block [0x824A9708..0x824A972C)
	// 824A9708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A970C: 4808B9B1  bl 0x825350bc
	ctx.lr = 0x824A9710;
	sub_82535080(ctx, base);
	// 824A9710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A9714: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824A9718: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 824A971C: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 824A9720: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 824A9724: 41980040  blt cr6, 0x824a9764
	if ctx.cr[6].lt {
	pc = 0x824A9764; continue 'dispatch;
	}
	// 824A9728: 57BF103A  slwi r31, r29, 2
	ctx.r[31].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x824A972C; continue 'dispatch;
            }
            0x824A972C => {
    //   block [0x824A972C..0x824A9754)
	// 824A972C: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A9730: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 824A9734: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824A9738: 419A001C  beq cr6, 0x824a9754
	if ctx.cr[6].eq {
	pc = 0x824A9754; continue 'dispatch;
	}
	// 824A973C: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 824A9740: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824A9744: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9748: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A974C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A9750: 4E800421  bctrl
	ctx.lr = 0x824A9754;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A9754 => {
    //   block [0x824A9754..0x824A9764)
	// 824A9754: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 824A9758: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 824A975C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 824A9760: 4098FFCC  bge cr6, 0x824a972c
	if !ctx.cr[6].lt {
	pc = 0x824A972C; continue 'dispatch;
	}
	pc = 0x824A9764; continue 'dispatch;
            }
            0x824A9764 => {
    //   block [0x824A9764..0x824A9774)
	// 824A9764: 387E008C  addi r3, r30, 0x8c
	ctx.r[3].s64 = ctx.r[30].s64 + 140;
	// 824A9768: 4BFFFE49  bl 0x824a95b0
	ctx.lr = 0x824A976C;
	sub_824A95B0(ctx, base);
	// 824A976C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A9770: 4808B99C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A9778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A9778 size=108
    let mut pc: u32 = 0x824A9778;
    'dispatch: loop {
        match pc {
            0x824A9778 => {
    //   block [0x824A9778..0x824A979C)
	// 824A9778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A977C: 4808B941  bl 0x825350bc
	ctx.lr = 0x824A9780;
	sub_82535080(ctx, base);
	// 824A9780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A9784: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824A9788: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 824A978C: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 824A9790: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 824A9794: 41980040  blt cr6, 0x824a97d4
	if ctx.cr[6].lt {
	pc = 0x824A97D4; continue 'dispatch;
	}
	// 824A9798: 57BF103A  slwi r31, r29, 2
	ctx.r[31].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x824A979C; continue 'dispatch;
            }
            0x824A979C => {
    //   block [0x824A979C..0x824A97C4)
	// 824A979C: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A97A0: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 824A97A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824A97A8: 419A001C  beq cr6, 0x824a97c4
	if ctx.cr[6].eq {
	pc = 0x824A97C4; continue 'dispatch;
	}
	// 824A97AC: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 824A97B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824A97B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A97B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A97BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A97C0: 4E800421  bctrl
	ctx.lr = 0x824A97C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A97C4 => {
    //   block [0x824A97C4..0x824A97D4)
	// 824A97C4: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 824A97C8: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 824A97CC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 824A97D0: 4098FFCC  bge cr6, 0x824a979c
	if !ctx.cr[6].lt {
	pc = 0x824A979C; continue 'dispatch;
	}
	pc = 0x824A97D4; continue 'dispatch;
            }
            0x824A97D4 => {
    //   block [0x824A97D4..0x824A97E4)
	// 824A97D4: 387E008C  addi r3, r30, 0x8c
	ctx.r[3].s64 = ctx.r[30].s64 + 140;
	// 824A97D8: 4BFFFDD9  bl 0x824a95b0
	ctx.lr = 0x824A97DC;
	sub_824A95B0(ctx, base);
	// 824A97DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A97E0: 4808B92C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A97E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A97E8 size=108
    let mut pc: u32 = 0x824A97E8;
    'dispatch: loop {
        match pc {
            0x824A97E8 => {
    //   block [0x824A97E8..0x824A980C)
	// 824A97E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A97EC: 4808B8D1  bl 0x825350bc
	ctx.lr = 0x824A97F0;
	sub_82535080(ctx, base);
	// 824A97F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A97F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824A97F8: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 824A97FC: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 824A9800: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 824A9804: 41980040  blt cr6, 0x824a9844
	if ctx.cr[6].lt {
	pc = 0x824A9844; continue 'dispatch;
	}
	// 824A9808: 57BF103A  slwi r31, r29, 2
	ctx.r[31].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x824A980C; continue 'dispatch;
            }
            0x824A980C => {
    //   block [0x824A980C..0x824A9834)
	// 824A980C: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A9810: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 824A9814: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824A9818: 419A001C  beq cr6, 0x824a9834
	if ctx.cr[6].eq {
	pc = 0x824A9834; continue 'dispatch;
	}
	// 824A981C: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 824A9820: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824A9824: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9828: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824A982C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A9830: 4E800421  bctrl
	ctx.lr = 0x824A9834;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A9834 => {
    //   block [0x824A9834..0x824A9844)
	// 824A9834: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 824A9838: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 824A983C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 824A9840: 4098FFCC  bge cr6, 0x824a980c
	if !ctx.cr[6].lt {
	pc = 0x824A980C; continue 'dispatch;
	}
	pc = 0x824A9844; continue 'dispatch;
            }
            0x824A9844 => {
    //   block [0x824A9844..0x824A9854)
	// 824A9844: 387E008C  addi r3, r30, 0x8c
	ctx.r[3].s64 = ctx.r[30].s64 + 140;
	// 824A9848: 4BFFFD69  bl 0x824a95b0
	ctx.lr = 0x824A984C;
	sub_824A95B0(ctx, base);
	// 824A984C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A9850: 4808B8BC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A9858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A9858 size=120
    let mut pc: u32 = 0x824A9858;
    'dispatch: loop {
        match pc {
            0x824A9858 => {
    //   block [0x824A9858..0x824A9870)
	// 824A9858: 3903008C  addi r8, r3, 0x8c
	ctx.r[8].s64 = ctx.r[3].s64 + 140;
	// 824A985C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A9860: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A9864: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824A9868: 40990024  ble cr6, 0x824a988c
	if !ctx.cr[6].gt {
	pc = 0x824A988C; continue 'dispatch;
	}
	// 824A986C: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x824A9870; continue 'dispatch;
            }
            0x824A9870 => {
    //   block [0x824A9870..0x824A988C)
	// 824A9870: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9874: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 824A9878: 419A0018  beq cr6, 0x824a9890
	if ctx.cr[6].eq {
	pc = 0x824A9890; continue 'dispatch;
	}
	// 824A987C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A9880: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824A9884: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A9888: 4198FFE8  blt cr6, 0x824a9870
	if ctx.cr[6].lt {
	pc = 0x824A9870; continue 'dispatch;
	}
	pc = 0x824A988C; continue 'dispatch;
            }
            0x824A988C => {
    //   block [0x824A988C..0x824A9890)
	// 824A988C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x824A9890; continue 'dispatch;
            }
            0x824A9890 => {
    //   block [0x824A9890..0x824A98A8)
	// 824A9890: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A9894: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824A9898: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824A989C: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824A98A0: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 824A98A4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x824A98A8; continue 'dispatch;
            }
            0x824A98A8 => {
    //   block [0x824A98A8..0x824A98D0)
	// 824A98A8: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A98AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A98B0: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 824A98B4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824A98B8: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A98BC: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 824A98C0: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A98C4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A98C8: 4198FFE0  blt cr6, 0x824a98a8
	if ctx.cr[6].lt {
	pc = 0x824A98A8; continue 'dispatch;
	}
	// 824A98CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A98D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A98D0 size=120
    let mut pc: u32 = 0x824A98D0;
    'dispatch: loop {
        match pc {
            0x824A98D0 => {
    //   block [0x824A98D0..0x824A98E8)
	// 824A98D0: 39030080  addi r8, r3, 0x80
	ctx.r[8].s64 = ctx.r[3].s64 + 128;
	// 824A98D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824A98D8: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A98DC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824A98E0: 40990024  ble cr6, 0x824a9904
	if !ctx.cr[6].gt {
	pc = 0x824A9904; continue 'dispatch;
	}
	// 824A98E4: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x824A98E8; continue 'dispatch;
            }
            0x824A98E8 => {
    //   block [0x824A98E8..0x824A9904)
	// 824A98E8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A98EC: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 824A98F0: 419A0018  beq cr6, 0x824a9908
	if ctx.cr[6].eq {
	pc = 0x824A9908; continue 'dispatch;
	}
	// 824A98F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A98F8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824A98FC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A9900: 4198FFE8  blt cr6, 0x824a98e8
	if ctx.cr[6].lt {
	pc = 0x824A98E8; continue 'dispatch;
	}
	pc = 0x824A9904; continue 'dispatch;
            }
            0x824A9904 => {
    //   block [0x824A9904..0x824A9908)
	// 824A9904: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x824A9908; continue 'dispatch;
            }
            0x824A9908 => {
    //   block [0x824A9908..0x824A9920)
	// 824A9908: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A990C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824A9910: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824A9914: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824A9918: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 824A991C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x824A9920; continue 'dispatch;
            }
            0x824A9920 => {
    //   block [0x824A9920..0x824A9948)
	// 824A9920: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9924: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A9928: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 824A992C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824A9930: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A9934: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 824A9938: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A993C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824A9940: 4198FFE0  blt cr6, 0x824a9920
	if ctx.cr[6].lt {
	pc = 0x824A9920; continue 'dispatch;
	}
	// 824A9944: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A9948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A9948 size=112
    let mut pc: u32 = 0x824A9948;
    'dispatch: loop {
        match pc {
            0x824A9948 => {
    //   block [0x824A9948..0x824A9984)
	// 824A9948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A994C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A9950: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824A9954: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A9958: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A995C: 3BE3008C  addi r31, r3, 0x8c
	ctx.r[31].s64 = ctx.r[3].s64 + 140;
	// 824A9960: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824A9964: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9968: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A996C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824A9970: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A9974: 409A0010  bne cr6, 0x824a9984
	if !ctx.cr[6].eq {
	pc = 0x824A9984; continue 'dispatch;
	}
	// 824A9978: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824A997C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A9980: 4BFC49D1  bl 0x8246e350
	ctx.lr = 0x824A9984;
	sub_8246E350(ctx, base);
	pc = 0x824A9984; continue 'dispatch;
            }
            0x824A9984 => {
    //   block [0x824A9984..0x824A99B8)
	// 824A9984: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A9988: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A998C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A9990: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 824A9994: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A9998: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A999C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A99A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A99A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A99A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A99AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824A99B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A99B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A99B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A99B8 size=112
    let mut pc: u32 = 0x824A99B8;
    'dispatch: loop {
        match pc {
            0x824A99B8 => {
    //   block [0x824A99B8..0x824A99F4)
	// 824A99B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A99BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A99C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824A99C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A99C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A99CC: 3BE30080  addi r31, r3, 0x80
	ctx.r[31].s64 = ctx.r[3].s64 + 128;
	// 824A99D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824A99D4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A99D8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A99DC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824A99E0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824A99E4: 409A0010  bne cr6, 0x824a99f4
	if !ctx.cr[6].eq {
	pc = 0x824A99F4; continue 'dispatch;
	}
	// 824A99E8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824A99EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A99F0: 4BFC4961  bl 0x8246e350
	ctx.lr = 0x824A99F4;
	sub_8246E350(ctx, base);
	pc = 0x824A99F4; continue 'dispatch;
            }
            0x824A99F4 => {
    //   block [0x824A99F4..0x824A9A28)
	// 824A99F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A99F8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A99FC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824A9A00: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 824A9A04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A9A08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A9A0C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824A9A10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A9A14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A9A18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A9A1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824A9A20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A9A24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A9A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A9A28 size=184
    let mut pc: u32 = 0x824A9A28;
    'dispatch: loop {
        match pc {
            0x824A9A28 => {
    //   block [0x824A9A28..0x824A9A88)
	// 824A9A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A9A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A9A30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824A9A34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A9A38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A9A3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A9A40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824A9A44: 4BFF231D  bl 0x8249bd60
	ctx.lr = 0x824A9A48;
	sub_8249BD60(ctx, base);
	// 824A9A48: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 824A9A4C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A9A50: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A9A54: 409A0034  bne cr6, 0x824a9a88
	if !ctx.cr[6].eq {
	pc = 0x824A9A88; continue 'dispatch;
	}
	// 824A9A58: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9A5C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824A9A60: 80FF0084  lwz r7, 0x84(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A9A64: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824A9A68: 80DF0080  lwz r6, 0x80(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A9A6C: 388A0880  addi r4, r10, 0x880
	ctx.r[4].s64 = ctx.r[10].s64 + 2176;
	// 824A9A70: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 824A9A74: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824A9A78: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9A7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824A9A80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A9A84: 4E800421  bctrl
	ctx.lr = 0x824A9A88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A9A88 => {
    //   block [0x824A9A88..0x824A9AC8)
	// 824A9A88: 815F0094  lwz r10, 0x94(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 824A9A8C: 554B0000  rlwinm r11, r10, 0, 0, 0
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 824A9A90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A9A94: 409A0034  bne cr6, 0x824a9ac8
	if !ctx.cr[6].eq {
	pc = 0x824A9AC8; continue 'dispatch;
	}
	// 824A9A98: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9A9C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A9AA0: 80FF0090  lwz r7, 0x90(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 824A9AA4: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824A9AA8: 388B0870  addi r4, r11, 0x870
	ctx.r[4].s64 = ctx.r[11].s64 + 2160;
	// 824A9AAC: 80DF008C  lwz r6, 0x8c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A9AB0: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 824A9AB4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824A9AB8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9ABC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824A9AC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A9AC4: 4E800421  bctrl
	ctx.lr = 0x824A9AC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A9AC8 => {
    //   block [0x824A9AC8..0x824A9AE0)
	// 824A9AC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824A9ACC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A9AD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A9AD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824A9AD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A9ADC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A9AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A9AE0 size=192
    let mut pc: u32 = 0x824A9AE0;
    'dispatch: loop {
        match pc {
            0x824A9AE0 => {
    //   block [0x824A9AE0..0x824A9B34)
	// 824A9AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A9AE4: 4808B5D5  bl 0x825350b8
	ctx.lr = 0x824A9AE8;
	sub_82535080(ctx, base);
	// 824A9AE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A9AEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824A9AF0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 824A9AF4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 824A9AF8: 817E0084  lwz r11, 0x84(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A9AFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A9B00: 409A0048  bne cr6, 0x824a9b48
	if !ctx.cr[6].eq {
	pc = 0x824A9B48; continue 'dispatch;
	}
	// 824A9B04: 3BFE0080  addi r31, r30, 0x80
	ctx.r[31].s64 = ctx.r[30].s64 + 128;
	// 824A9B08: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9B0C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A9B10: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A9B14: 409A0020  bne cr6, 0x824a9b34
	if !ctx.cr[6].eq {
	pc = 0x824A9B34; continue 'dispatch;
	}
	// 824A9B18: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9B1C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824A9B20: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A9B24: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9B28: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A9B2C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824A9B30: 4BFBA589  bl 0x824640b8
	ctx.lr = 0x824A9B34;
	sub_824640B8(ctx, base);
	pc = 0x824A9B34; continue 'dispatch;
            }
            0x824A9B34 => {
    //   block [0x824A9B34..0x824A9B48)
	// 824A9B34: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9B38: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 824A9B3C: 538BF880  rlwimi r11, r28, 0x1f, 2, 0
	ctx.r[11].u64 = (((ctx.r[28].u32).rotate_left(31) as u64) & 0xFFFFFFFFBFFFFFFF) | (ctx.r[11].u64 & 0x0000000040000000);
	// 824A9B40: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 824A9B44: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x824A9B48; continue 'dispatch;
            }
            0x824A9B48 => {
    //   block [0x824A9B48..0x824A9B84)
	// 824A9B48: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 824A9B4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A9B50: 409A0048  bne cr6, 0x824a9b98
	if !ctx.cr[6].eq {
	pc = 0x824A9B98; continue 'dispatch;
	}
	// 824A9B54: 3BFE008C  addi r31, r30, 0x8c
	ctx.r[31].s64 = ctx.r[30].s64 + 140;
	// 824A9B58: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9B5C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A9B60: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A9B64: 409A0020  bne cr6, 0x824a9b84
	if !ctx.cr[6].eq {
	pc = 0x824A9B84; continue 'dispatch;
	}
	// 824A9B68: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9B6C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824A9B70: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A9B74: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9B78: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A9B7C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824A9B80: 4BFBA539  bl 0x824640b8
	ctx.lr = 0x824A9B84;
	sub_824640B8(ctx, base);
	pc = 0x824A9B84; continue 'dispatch;
            }
            0x824A9B84 => {
    //   block [0x824A9B84..0x824A9B98)
	// 824A9B84: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9B88: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 824A9B8C: 538BF880  rlwimi r11, r28, 0x1f, 2, 0
	ctx.r[11].u64 = (((ctx.r[28].u32).rotate_left(31) as u64) & 0xFFFFFFFFBFFFFFFF) | (ctx.r[11].u64 & 0x0000000040000000);
	// 824A9B90: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 824A9B94: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x824A9B98; continue 'dispatch;
            }
            0x824A9B98 => {
    //   block [0x824A9B98..0x824A9BA0)
	// 824A9B98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824A9B9C: 4808B56C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A9BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A9BA0 size=152
    let mut pc: u32 = 0x824A9BA0;
    'dispatch: loop {
        match pc {
            0x824A9BA0 => {
    //   block [0x824A9BA0..0x824A9BF0)
	// 824A9BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A9BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A9BA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A9BAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A9BB0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824A9BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A9BB8: 396BE47C  addi r11, r11, -0x1b84
	ctx.r[11].s64 = ctx.r[11].s64 + -7044;
	// 824A9BBC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824A9BC0: 4BFFFAE1  bl 0x824a96a0
	ctx.lr = 0x824A9BC4;
	sub_824A96A0(ctx, base);
	// 824A9BC4: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 824A9BC8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A9BCC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A9BD0: 409A0020  bne cr6, 0x824a9bf0
	if !ctx.cr[6].eq {
	pc = 0x824A9BF0; continue 'dispatch;
	}
	// 824A9BD4: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9BD8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824A9BDC: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A9BE0: 809F008C  lwz r4, 0x8c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A9BE4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A9BE8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824A9BEC: 4BFBA4CD  bl 0x824640b8
	ctx.lr = 0x824A9BF0;
	sub_824640B8(ctx, base);
	pc = 0x824A9BF0; continue 'dispatch;
            }
            0x824A9BF0 => {
    //   block [0x824A9BF0..0x824A9C1C)
	// 824A9BF0: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 824A9BF4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A9BF8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A9BFC: 409A0020  bne cr6, 0x824a9c1c
	if !ctx.cr[6].eq {
	pc = 0x824A9C1C; continue 'dispatch;
	}
	// 824A9C00: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9C04: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824A9C08: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A9C0C: 809F0080  lwz r4, 0x80(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A9C10: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A9C14: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824A9C18: 4BFBA4A1  bl 0x824640b8
	ctx.lr = 0x824A9C1C;
	sub_824640B8(ctx, base);
	pc = 0x824A9C1C; continue 'dispatch;
            }
            0x824A9C1C => {
    //   block [0x824A9C1C..0x824A9C38)
	// 824A9C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824A9C20: 4BFE5841  bl 0x8248f460
	ctx.lr = 0x824A9C24;
	sub_8248F460(ctx, base);
	// 824A9C24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824A9C28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824A9C2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824A9C30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824A9C34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A9C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A9C38 size=720
    let mut pc: u32 = 0x824A9C38;
    'dispatch: loop {
        match pc {
            0x824A9C38 => {
    //   block [0x824A9C38..0x824A9C88)
	// 824A9C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A9C3C: 4808B471  bl 0x825350ac
	ctx.lr = 0x824A9C40;
	sub_82535080(ctx, base);
	// 824A9C40: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A9C44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A9C48: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 824A9C4C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9C50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824A9C54: 419A02AC  beq cr6, 0x824a9f00
	if ctx.cr[6].eq {
	pc = 0x824A9F00; continue 'dispatch;
	}
	// 824A9C58: 81630088  lwz r11, 0x88(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 824A9C5C: 81430084  lwz r10, 0x84(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A9C60: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A9C64: 41820024  beq 0x824a9c88
	if ctx.cr[0].eq {
	pc = 0x824A9C88; continue 'dispatch;
	}
	// 824A9C68: 39600011  li r11, 0x11
	ctx.r[11].s64 = 17;
	// 824A9C6C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 824A9C70: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 824A9C74: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 824A9C78: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 824A9C7C: 4BFE955D  bl 0x824931d8
	ctx.lr = 0x824A9C80;
	sub_824931D8(ctx, base);
	// 824A9C80: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 824A9C84: 4808B478  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x824A9C88 => {
    //   block [0x824A9C88..0x824A9CE4)
	// 824A9C88: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9C8C: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 824A9C90: 834D0000  lwz r26, 0(r13)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9C94: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 824A9C98: 3FA08000  lis r29, -0x8000
	ctx.r[29].s64 = -2147483648;
	// 824A9C9C: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A9CA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824A9CA4: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 824A9CA8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9CAC: 7D7BD02E  lwzx r11, r27, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 824A9CB0: 83CA02FC  lwz r30, 0x2fc(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(764 as u32) ) } as u64;
	// 824A9CB4: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 824A9CB8: 395E0002  addi r10, r30, 2
	ctx.r[10].s64 = ctx.r[30].s64 + 2;
	// 824A9CBC: 93810084  stw r28, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[28].u32 ) };
	// 824A9CC0: 93A10088  stw r29, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	// 824A9CC4: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A9CC8: 55441836  rlwinm r4, r10, 3, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 824A9CCC: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A9CD0: 7D432214  add r10, r3, r4
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 824A9CD4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824A9CD8: 4199000C  bgt cr6, 0x824a9ce4
	if ctx.cr[6].gt {
	pc = 0x824A9CE4; continue 'dispatch;
	}
	// 824A9CDC: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 824A9CE0: 48000018  b 0x824a9cf8
	pc = 0x824A9CF8; continue 'dispatch;
            }
            0x824A9CE4 => {
    //   block [0x824A9CE4..0x824A9CF8)
	// 824A9CE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9CE8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A9CEC: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A9CF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A9CF4: 4E800421  bctrl
	ctx.lr = 0x824A9CF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A9CF8 => {
    //   block [0x824A9CF8..0x824A9D44)
	// 824A9CF8: 7FC9EB78  or r9, r30, r29
	ctx.r[9].u64 = ctx.r[30].u64 | ctx.r[29].u64;
	// 824A9CFC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9D00: 90610080  stw r3, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 824A9D04: 9061008C  stw r3, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 824A9D08: 7D7BD02E  lwzx r11, r27, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 824A9D0C: 91210088  stw r9, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 824A9D10: 83CA02FC  lwz r30, 0x2fc(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(764 as u32) ) } as u64;
	// 824A9D14: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 824A9D18: 393E0002  addi r9, r30, 2
	ctx.r[9].s64 = ctx.r[30].s64 + 2;
	// 824A9D1C: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 824A9D20: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 824A9D24: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824A9D28: 55241836  rlwinm r4, r9, 3, 0, 0x1b
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 824A9D2C: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824A9D30: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 824A9D34: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824A9D38: 4199000C  bgt cr6, 0x824a9d44
	if ctx.cr[6].gt {
	pc = 0x824A9D44; continue 'dispatch;
	}
	// 824A9D3C: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 824A9D40: 4800001C  b 0x824a9d5c
	pc = 0x824A9D5C; continue 'dispatch;
            }
            0x824A9D44 => {
    //   block [0x824A9D44..0x824A9D5C)
	// 824A9D44: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9D48: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824A9D4C: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824A9D50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A9D54: 4E800421  bctrl
	ctx.lr = 0x824A9D58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A9D58: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            0x824A9D5C => {
    //   block [0x824A9D5C..0x824A9D8C)
	// 824A9D5C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 824A9D60: 7FC9EB78  or r9, r30, r29
	ctx.r[9].u64 = ctx.r[30].u64 | ctx.r[29].u64;
	// 824A9D64: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 824A9D68: 395F0024  addi r10, r31, 0x24
	ctx.r[10].s64 = ctx.r[31].s64 + 36;
	// 824A9D6C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9D70: 91210078  stw r9, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 824A9D74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 824A9D78: 806B0054  lwz r3, 0x54(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A9D7C: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A9D80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A9D84: 419A0008  beq cr6, 0x824a9d8c
	if ctx.cr[6].eq {
	pc = 0x824A9D8C; continue 'dispatch;
	}
	// 824A9D88: 4802C559  bl 0x824d62e0
	ctx.lr = 0x824A9D8C;
	sub_824D62E0(ctx, base);
	pc = 0x824A9D8C; continue 'dispatch;
            }
            0x824A9D8C => {
    //   block [0x824A9D8C..0x824A9DD0)
	// 824A9D8C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9D90: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 824A9D94: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 824A9D98: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 824A9D9C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 824A9DA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824A9DA4: 806B0054  lwz r3, 0x54(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A9DA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9DAC: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A9DB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A9DB4: 4E800421  bctrl
	ctx.lr = 0x824A9DB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824A9DB8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A9DBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A9DC0: 409A0010  bne cr6, 0x824a9dd0
	if !ctx.cr[6].eq {
	pc = 0x824A9DD0; continue 'dispatch;
	}
	// 824A9DC4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824A9DC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A9DCC: 419A0054  beq cr6, 0x824a9e20
	if ctx.cr[6].eq {
	pc = 0x824A9E20; continue 'dispatch;
	}
            }
            0x824A9DD0 => {
    //   block [0x824A9DD0..0x824A9E08)
	// 824A9DD0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 824A9DD4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 824A9DD8: 480544C1  bl 0x824fe298
	ctx.lr = 0x824A9DDC;
	sub_824FE298(ctx, base);
	// 824A9DDC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9DE0: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824A9DE4: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824A9DE8: 806B0058  lwz r3, 0x58(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A9DEC: 48054435  bl 0x824fe220
	ctx.lr = 0x824A9DF0;
	sub_824FE220(ctx, base);
	// 824A9DF0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9DF4: 816A0070  lwz r11, 0x70(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(112 as u32) ) } as u64;
	// 824A9DF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A9DFC: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 824A9E00: 409A0008  bne cr6, 0x824a9e08
	if !ctx.cr[6].eq {
	pc = 0x824A9E08; continue 'dispatch;
	}
	// 824A9E04: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x824A9E08; continue 'dispatch;
            }
            0x824A9E08 => {
    //   block [0x824A9E08..0x824A9E20)
	// 824A9E08: 806A0058  lwz r3, 0x58(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 824A9E0C: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A9E10: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A9E14: 4805434D  bl 0x824fe160
	ctx.lr = 0x824A9E18;
	sub_824FE160(ctx, base);
	// 824A9E18: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 824A9E1C: 4BFFF80D  bl 0x824a9628
	ctx.lr = 0x824A9E20;
	sub_824A9628(ctx, base);
	pc = 0x824A9E20; continue 'dispatch;
            }
            0x824A9E20 => {
    //   block [0x824A9E20..0x824A9E38)
	// 824A9E20: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9E24: 806B0054  lwz r3, 0x54(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 824A9E28: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A9E2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A9E30: 419A0008  beq cr6, 0x824a9e38
	if ctx.cr[6].eq {
	pc = 0x824A9E38; continue 'dispatch;
	}
	// 824A9E34: 4802C49D  bl 0x824d62d0
	ctx.lr = 0x824A9E38;
	sub_824D62D0(ctx, base);
	pc = 0x824A9E38; continue 'dispatch;
            }
            0x824A9E38 => {
    //   block [0x824A9E38..0x824A9E68)
	// 824A9E38: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9E3C: 81630084  lwz r11, 0x84(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A9E40: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A9E44: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A9E48: 40820020  bne 0x824a9e68
	if !ctx.cr[0].eq {
	pc = 0x824A9E68; continue 'dispatch;
	}
	// 824A9E4C: 8963008C  lbz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A9E50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A9E54: 409A0014  bne cr6, 0x824a9e68
	if !ctx.cr[6].eq {
	pc = 0x824A9E68; continue 'dispatch;
	}
	// 824A9E58: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A9E5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A9E60: 419A0008  beq cr6, 0x824a9e68
	if ctx.cr[6].eq {
	pc = 0x824A9E68; continue 'dispatch;
	}
	// 824A9E64: 4BFE935D  bl 0x824931c0
	ctx.lr = 0x824A9E68;
	sub_824931C0(ctx, base);
	pc = 0x824A9E68; continue 'dispatch;
            }
            0x824A9E68 => {
    //   block [0x824A9E68..0x824A9E90)
	// 824A9E68: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 824A9E6C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 824A9E70: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A9E74: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824A9E78: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A9E7C: 409A0014  bne cr6, 0x824a9e90
	if !ctx.cr[6].eq {
	pc = 0x824A9E90; continue 'dispatch;
	}
	// 824A9E80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9E84: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A9E88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A9E8C: 4E800421  bctrl
	ctx.lr = 0x824A9E90;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A9E90 => {
    //   block [0x824A9E90..0x824A9EB4)
	// 824A9E90: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 824A9E94: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A9E98: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A9E9C: 409A0018  bne cr6, 0x824a9eb4
	if !ctx.cr[6].eq {
	pc = 0x824A9EB4; continue 'dispatch;
	}
	// 824A9EA0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A9EA4: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 824A9EA8: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A9EAC: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824A9EB0: 4BFBA209  bl 0x824640b8
	ctx.lr = 0x824A9EB4;
	sub_824640B8(ctx, base);
	pc = 0x824A9EB4; continue 'dispatch;
            }
            0x824A9EB4 => {
    //   block [0x824A9EB4..0x824A9EDC)
	// 824A9EB4: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 824A9EB8: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 824A9EBC: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824A9EC0: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824A9EC4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824A9EC8: 409A0014  bne cr6, 0x824a9edc
	if !ctx.cr[6].eq {
	pc = 0x824A9EDC; continue 'dispatch;
	}
	// 824A9ECC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9ED0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824A9ED4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A9ED8: 4E800421  bctrl
	ctx.lr = 0x824A9EDC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A9EDC => {
    //   block [0x824A9EDC..0x824A9F00)
	// 824A9EDC: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 824A9EE0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824A9EE4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824A9EE8: 409A0018  bne cr6, 0x824a9f00
	if !ctx.cr[6].eq {
	pc = 0x824A9F00; continue 'dispatch;
	}
	// 824A9EEC: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824A9EF0: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 824A9EF4: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824A9EF8: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 824A9EFC: 4BFBA1BD  bl 0x824640b8
	ctx.lr = 0x824A9F00;
	sub_824640B8(ctx, base);
	pc = 0x824A9F00; continue 'dispatch;
            }
            0x824A9F00 => {
    //   block [0x824A9F00..0x824A9F08)
	// 824A9F00: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 824A9F04: 4808B1F8  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A9F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A9F08 size=8
    let mut pc: u32 = 0x824A9F08;
    'dispatch: loop {
        match pc {
            0x824A9F08 => {
    //   block [0x824A9F08..0x824A9F10)
	// 824A9F08: 386300A0  addi r3, r3, 0xa0
	ctx.r[3].s64 = ctx.r[3].s64 + 160;
	// 824A9F0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A9F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824A9F10 size=4
    let mut pc: u32 = 0x824A9F10;
    'dispatch: loop {
        match pc {
            0x824A9F10 => {
    //   block [0x824A9F10..0x824A9F14)
	// 824A9F10: 4BFFFBD0  b 0x824a9ae0
	sub_824A9AE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824A9F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824A9F18 size=336
    let mut pc: u32 = 0x824A9F18;
    'dispatch: loop {
        match pc {
            0x824A9F18 => {
    //   block [0x824A9F18..0x824A9F6C)
	// 824A9F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824A9F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824A9F20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824A9F24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824A9F28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824A9F2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824A9F30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824A9F34: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9F38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824A9F3C: 419A0050  beq cr6, 0x824a9f8c
	if ctx.cr[6].eq {
	pc = 0x824A9F8C; continue 'dispatch;
	}
	// 824A9F40: 81630084  lwz r11, 0x84(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A9F44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A9F48: 419A0024  beq cr6, 0x824a9f6c
	if ctx.cr[6].eq {
	pc = 0x824A9F6C; continue 'dispatch;
	}
	// 824A9F4C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 824A9F50: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 824A9F54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824A9F58: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 824A9F5C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 824A9F60: 4BFE9279  bl 0x824931d8
	ctx.lr = 0x824A9F64;
	sub_824931D8(ctx, base);
	// 824A9F64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824A9F68: 480000E8  b 0x824aa050
	pc = 0x824AA050; continue 'dispatch;
            }
            0x824A9F6C => {
    //   block [0x824A9F6C..0x824A9F8C)
	// 824A9F6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824A9F70: 419A001C  beq cr6, 0x824a9f8c
	if ctx.cr[6].eq {
	pc = 0x824A9F8C; continue 'dispatch;
	}
	// 824A9F74: 81630084  lwz r11, 0x84(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 824A9F78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824A9F7C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A9F80: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824A9F84: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9F88: 4BFF6789  bl 0x824a0710
	ctx.lr = 0x824A9F8C;
	sub_824A0710(ctx, base);
	pc = 0x824A9F8C; continue 'dispatch;
            }
            0x824A9F8C => {
    //   block [0x824A9F8C..0x824A9FA4)
	// 824A9F8C: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A9F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A9F94: 419A0010  beq cr6, 0x824a9fa4
	if ctx.cr[6].eq {
	pc = 0x824A9FA4; continue 'dispatch;
	}
	// 824A9F98: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 824A9F9C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824A9FA0: B17E0006  sth r11, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x824A9FA4; continue 'dispatch;
            }
            0x824A9FA4 => {
    //   block [0x824A9FA4..0x824A9FE8)
	// 824A9FA4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 824A9FA8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824A9FAC: 419A003C  beq cr6, 0x824a9fe8
	if ctx.cr[6].eq {
	pc = 0x824A9FE8; continue 'dispatch;
	}
	// 824A9FB0: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824A9FB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824A9FB8: 419A0030  beq cr6, 0x824a9fe8
	if ctx.cr[6].eq {
	pc = 0x824A9FE8; continue 'dispatch;
	}
	// 824A9FBC: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824A9FC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824A9FC4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824A9FC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824A9FCC: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824A9FD0: 409A0018  bne cr6, 0x824a9fe8
	if !ctx.cr[6].eq {
	pc = 0x824A9FE8; continue 'dispatch;
	}
	// 824A9FD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9FD8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824A9FDC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824A9FE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824A9FE4: 4E800421  bctrl
	ctx.lr = 0x824A9FE8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824A9FE8 => {
    //   block [0x824A9FE8..0x824AA000)
	// 824A9FE8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824A9FEC: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 824A9FF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824A9FF4: 419A000C  beq cr6, 0x824aa000
	if ctx.cr[6].eq {
	pc = 0x824AA000; continue 'dispatch;
	}
	// 824A9FF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824A9FFC: 4BFFA61D  bl 0x824a4618
	ctx.lr = 0x824AA000;
	sub_824A4618(ctx, base);
	pc = 0x824AA000; continue 'dispatch;
            }
            0x824AA000 => {
    //   block [0x824AA000..0x824AA04C)
	// 824AA000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AA004: 4BFFF7E5  bl 0x824a97e8
	ctx.lr = 0x824AA008;
	sub_824A97E8(ctx, base);
	// 824AA008: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AA00C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824AA010: 419A003C  beq cr6, 0x824aa04c
	if ctx.cr[6].eq {
	pc = 0x824AA04C; continue 'dispatch;
	}
	// 824AA014: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824AA018: 4BFF6469  bl 0x824a0480
	ctx.lr = 0x824AA01C;
	sub_824A0480(ctx, base);
	// 824AA01C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AA020: 81630084  lwz r11, 0x84(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 824AA024: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AA028: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824AA02C: 40820020  bne 0x824aa04c
	if !ctx.cr[0].eq {
	pc = 0x824AA04C; continue 'dispatch;
	}
	// 824AA030: 8963008C  lbz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 824AA034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AA038: 409A0014  bne cr6, 0x824aa04c
	if !ctx.cr[6].eq {
	pc = 0x824AA04C; continue 'dispatch;
	}
	// 824AA03C: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 824AA040: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AA044: 419A0008  beq cr6, 0x824aa04c
	if ctx.cr[6].eq {
	pc = 0x824AA04C; continue 'dispatch;
	}
	// 824AA048: 4BFE9179  bl 0x824931c0
	ctx.lr = 0x824AA04C;
	sub_824931C0(ctx, base);
	pc = 0x824AA04C; continue 'dispatch;
            }
            0x824AA04C => {
    //   block [0x824AA04C..0x824AA050)
	// 824AA04C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x824AA050; continue 'dispatch;
            }
            0x824AA050 => {
    //   block [0x824AA050..0x824AA068)
	// 824AA050: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824AA054: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AA058: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AA05C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AA060: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AA064: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AA068 size=156
    let mut pc: u32 = 0x824AA068;
    'dispatch: loop {
        match pc {
            0x824AA068 => {
    //   block [0x824AA068..0x824AA104)
	// 824AA068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AA06C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AA070: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AA074: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AA078: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AA108 size=124
    let mut pc: u32 = 0x824AA108;
    'dispatch: loop {
        match pc {
            0x824AA108 => {
    //   block [0x824AA108..0x824AA184)
	// 824AA108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AA10C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AA110: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AA114: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AA118: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824AA188 size=56
    let mut pc: u32 = 0x824AA188;
    'dispatch: loop {
        match pc {
            0x824AA188 => {
    //   block [0x824AA188..0x824AA1C0)
	// 824AA188: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824AA18C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 824AA190: 388B00A0  addi r4, r11, 0xa0
	ctx.r[4].s64 = ctx.r[11].s64 + 160;
	// 824AA194: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AA198: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824AA19C: 816A006C  lwz r11, 0x6c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(108 as u32) ) } as u64;
	// 824AA1A0: C1AB0004  lfs f13, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824AA1A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824AA1A8: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AA1AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA1B0: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824AA1B4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AA1B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AA1BC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AA1C0 size=132
    let mut pc: u32 = 0x824AA1C0;
    'dispatch: loop {
        match pc {
            0x824AA1C0 => {
    //   block [0x824AA1C0..0x824AA244)
	// 824AA1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AA1C4: 4808AEF9  bl 0x825350bc
	ctx.lr = 0x824AA1C8;
	sub_82535080(ctx, base);
	// 824AA1C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AA1CC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 824AA1D0: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 824AA1D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AA1D8: 4BFF1D21  bl 0x8249bef8
	ctx.lr = 0x824AA1DC;
	sub_8249BEF8(ctx, base);
	// 824AA1DC: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 824AA1E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AA1E4: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 824AA1E8: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824AA1EC: 7CEAF850  subf r7, r10, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 824AA1F0: 3929E4B4  addi r9, r9, -0x1b4c
	ctx.r[9].s64 = ctx.r[9].s64 + -6988;
	// 824AA1F4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 824AA1F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824AA1FC: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824AA200: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824AA204: 911F0088  stw r8, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 824AA208: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 824AA20C: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 824AA210: 911F0094  stw r8, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[8].u32 ) };
	// 824AA214: 98EA0010  stb r7, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[7].u8 ) };
	// 824AA218: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824AA21C: 480FE535  bl 0x825a8750
	ctx.lr = 0x824AA220;
	sub_825A8750(ctx, base);
	// 824AA220: 3BBF00A0  addi r29, r31, 0xa0
	ctx.r[29].s64 = ctx.r[31].s64 + 160;
	// 824AA224: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824AA228: 389E0030  addi r4, r30, 0x30
	ctx.r[4].s64 = ctx.r[30].s64 + 48;
	// 824AA22C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824AA230: 48100549  bl 0x825aa778
	ctx.lr = 0x824AA234;
	sub_825AA778(ctx, base);
	// 824AA234: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AA238: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 824AA23C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824AA240: 4808AECC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AA248 size=8
    let mut pc: u32 = 0x824AA248;
    'dispatch: loop {
        match pc {
            0x824AA248 => {
    //   block [0x824AA248..0x824AA250)
	// 824AA248: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 824AA24C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AA250 size=132
    let mut pc: u32 = 0x824AA250;
    'dispatch: loop {
        match pc {
            0x824AA250 => {
    //   block [0x824AA250..0x824AA278)
	// 824AA250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AA254: 4808AE5D  bl 0x825350b0
	ctx.lr = 0x824AA258;
	sub_82535080(ctx, base);
	// 824AA258: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AA25C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 824AA260: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824AA264: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 824AA268: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 824AA26C: 409A000C  bne cr6, 0x824aa278
	if !ctx.cr[6].eq {
	pc = 0x824AA278; continue 'dispatch;
	}
	// 824AA270: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AA274: 836B006C  lwz r27, 0x6c(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x824AA278; continue 'dispatch;
            }
            0x824AA278 => {
    //   block [0x824AA278..0x824AA290)
	// 824AA278: 817D0154  lwz r11, 0x154(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AA27C: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 824AA280: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824AA284: 41980048  blt cr6, 0x824aa2cc
	if ctx.cr[6].lt {
	pc = 0x824AA2CC; continue 'dispatch;
	}
	// 824AA288: 3B9D0010  addi r28, r29, 0x10
	ctx.r[28].s64 = ctx.r[29].s64 + 16;
	// 824AA28C: 57FE1838  slwi r30, r31, 3
	ctx.r[30].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x824AA290; continue 'dispatch;
            }
            0x824AA290 => {
    //   block [0x824AA290..0x824AA2CC)
	// 824AA290: 817D0150  lwz r11, 0x150(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AA294: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 824AA298: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 824AA29C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 824AA2A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 824AA2A4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA2A8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA2AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA2B0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824AA2B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AA2B8: 4E800421  bctrl
	ctx.lr = 0x824AA2BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AA2BC: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 824AA2C0: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 824AA2C4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824AA2C8: 4098FFC8  bge cr6, 0x824aa290
	if !ctx.cr[6].lt {
	pc = 0x824AA290; continue 'dispatch;
	}
            }
            0x824AA2CC => {
    //   block [0x824AA2CC..0x824AA2D4)
	// 824AA2CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824AA2D0: 4808AE30  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AA2D8 size=144
    let mut pc: u32 = 0x824AA2D8;
    'dispatch: loop {
        match pc {
            0x824AA2D8 => {
    //   block [0x824AA2D8..0x824AA300)
	// 824AA2D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AA2DC: 4808ADD5  bl 0x825350b0
	ctx.lr = 0x824AA2E0;
	sub_82535080(ctx, base);
	// 824AA2E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AA2E4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 824AA2E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824AA2EC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824AA2F0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 824AA2F4: 409A000C  bne cr6, 0x824aa300
	if !ctx.cr[6].eq {
	pc = 0x824AA300; continue 'dispatch;
	}
	// 824AA2F8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AA2FC: 836B006C  lwz r27, 0x6c(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x824AA300; continue 'dispatch;
            }
            0x824AA300 => {
    //   block [0x824AA300..0x824AA318)
	// 824AA300: 817E0154  lwz r11, 0x154(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AA304: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 824AA308: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824AA30C: 41980054  blt cr6, 0x824aa360
	if ctx.cr[6].lt {
	pc = 0x824AA360; continue 'dispatch;
	}
	// 824AA310: 3B9E0010  addi r28, r30, 0x10
	ctx.r[28].s64 = ctx.r[30].s64 + 16;
	// 824AA314: 575F1838  slwi r31, r26, 3
	ctx.r[31].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x824AA318; continue 'dispatch;
            }
            0x824AA318 => {
    //   block [0x824AA318..0x824AA360)
	// 824AA318: 817E0150  lwz r11, 0x150(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AA31C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 824AA320: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 824AA324: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 824AA328: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 824AA32C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA330: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA334: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA338: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AA33C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AA340: 4E800421  bctrl
	ctx.lr = 0x824AA344;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AA344: 897D0004  lbz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AA34C: 409A0014  bne cr6, 0x824aa360
	if !ctx.cr[6].eq {
	pc = 0x824AA360; continue 'dispatch;
	}
	// 824AA350: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 824AA354: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 824AA358: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824AA35C: 4098FFBC  bge cr6, 0x824aa318
	if !ctx.cr[6].lt {
	pc = 0x824AA318; continue 'dispatch;
	}
            }
            0x824AA360 => {
    //   block [0x824AA360..0x824AA368)
	// 824AA360: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824AA364: 4808AD9C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AA368 size=64
    let mut pc: u32 = 0x824AA368;
    'dispatch: loop {
        match pc {
            0x824AA368 => {
    //   block [0x824AA368..0x824AA380)
	// 824AA368: 81240154  lwz r9, 0x154(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AA36C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824AA370: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824AA374: 40990028  ble cr6, 0x824aa39c
	if !ctx.cr[6].gt {
	pc = 0x824AA39C; continue 'dispatch;
	}
	// 824AA378: 81640150  lwz r11, 0x150(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AA37C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x824AA380; continue 'dispatch;
            }
            0x824AA380 => {
    //   block [0x824AA380..0x824AA39C)
	// 824AA380: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA384: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 824AA388: 419A0020  beq cr6, 0x824aa3a8
	if ctx.cr[6].eq {
		sub_824AA3A8(ctx, base);
		return;
	}
	// 824AA38C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824AA390: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824AA394: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AA398: 4198FFE8  blt cr6, 0x824aa380
	if ctx.cr[6].lt {
	pc = 0x824AA380; continue 'dispatch;
	}
	pc = 0x824AA39C; continue 'dispatch;
            }
            0x824AA39C => {
    //   block [0x824AA39C..0x824AA3A8)
	// 824AA39C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AA3A0: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AA3A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AA3A8 size=12
    let mut pc: u32 = 0x824AA3A8;
    'dispatch: loop {
        match pc {
            0x824AA3A8 => {
    //   block [0x824AA3A8..0x824AA3B4)
	// 824AA3A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824AA3AC: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AA3B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AA3B8 size=272
    let mut pc: u32 = 0x824AA3B8;
    'dispatch: loop {
        match pc {
            0x824AA3B8 => {
    //   block [0x824AA3B8..0x824AA410)
	// 824AA3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AA3BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AA3C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AA3C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AA3C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AA3CC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AA3D0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA3D4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824AA3D8: 396B0894  addi r11, r11, 0x894
	ctx.r[11].s64 = ctx.r[11].s64 + 2196;
	// 824AA3DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AA3E0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AA3E4: B1210066  sth r9, 0x66(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[9].u16 ) };
	// 824AA3E8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824AA3EC: 419A0058  beq cr6, 0x824aa444
	if ctx.cr[6].eq {
	pc = 0x824AA444; continue 'dispatch;
	}
	// 824AA3F0: 817F0154  lwz r11, 0x154(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AA3F4: 3BCBFFFF  addi r30, r11, -1
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	// 824AA3F8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824AA3FC: 41980030  blt cr6, 0x824aa42c
	if ctx.cr[6].lt {
	pc = 0x824AA42C; continue 'dispatch;
	}
	// 824AA400: 815F0150  lwz r10, 0x150(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AA404: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AA408: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824AA40C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x824AA410; continue 'dispatch;
            }
            0x824AA410 => {
    //   block [0x824AA410..0x824AA42C)
	// 824AA410: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA414: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 824AA418: 419A0044  beq cr6, 0x824aa45c
	if ctx.cr[6].eq {
	pc = 0x824AA45C; continue 'dispatch;
	}
	// 824AA41C: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 824AA420: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 824AA424: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824AA428: 4098FFE8  bge cr6, 0x824aa410
	if !ctx.cr[6].lt {
	pc = 0x824AA410; continue 'dispatch;
	}
	pc = 0x824AA42C; continue 'dispatch;
            }
            0x824AA42C => {
    //   block [0x824AA42C..0x824AA444)
	// 824AA42C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824AA430: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 824AA434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AA438: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 824AA43C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA440: 48000901  bl 0x824aad40
	ctx.lr = 0x824AA444;
	sub_824AAD40(ctx, base);
	pc = 0x824AA444; continue 'dispatch;
            }
            0x824AA444 => {
    //   block [0x824AA444..0x824AA45C)
	// 824AA444: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824AA448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AA44C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AA450: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AA454: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AA458: 4E800020  blr
	return;
            }
            0x824AA45C => {
    //   block [0x824AA45C..0x824AA498)
	// 824AA45C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 824AA460: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 824AA464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AA468: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA46C: 480008D5  bl 0x824aad40
	ctx.lr = 0x824AA470;
	sub_824AAD40(ctx, base);
	// 824AA470: 817F0150  lwz r11, 0x150(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AA474: 57DE1838  slwi r30, r30, 3
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 824AA478: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AA47C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824AA480: 419A0018  beq cr6, 0x824aa498
	if ctx.cr[6].eq {
	pc = 0x824AA498; continue 'dispatch;
	}
	// 824AA484: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA488: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 824AA48C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AA490: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AA494: 4E800421  bctrl
	ctx.lr = 0x824AA498;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824AA498 => {
    //   block [0x824AA498..0x824AA4C8)
	// 824AA498: 815F0154  lwz r10, 0x154(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AA49C: 817F0150  lwz r11, 0x150(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AA4A0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824AA4A4: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 824AA4A8: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824AA4AC: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824AA4B0: 915F0154  stw r10, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 824AA4B4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA4B8: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824AA4BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA4C0: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AA4C4: 4BFFFF80  b 0x824aa444
	pc = 0x824AA444; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AA4C8 size=172
    let mut pc: u32 = 0x824AA4C8;
    'dispatch: loop {
        match pc {
            0x824AA4C8 => {
    //   block [0x824AA4C8..0x824AA4EC)
	// 824AA4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AA4CC: 4808ABED  bl 0x825350b8
	ctx.lr = 0x824AA4D0;
	sub_82535080(ctx, base);
	// 824AA4D0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AA4D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824AA4D8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 824AA4DC: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 824AA4E0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AA4E4: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 824AA4E8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x824AA4EC; continue 'dispatch;
            }
            0x824AA4EC => {
    //   block [0x824AA4EC..0x824AA52C)
	// 824AA4EC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 824AA4F0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824AA4F4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 824AA4F8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 824AA4FC: 4200FFF0  bdnz 0x824aa4ec
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824AA4EC; continue 'dispatch;
	}
	// 824AA500: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AA504: 815D0154  lwz r10, 0x154(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AA508: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824AA50C: 396B0894  addi r11, r11, 0x894
	ctx.r[11].s64 = ctx.r[11].s64 + 2196;
	// 824AA510: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 824AA514: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AA518: B1210056  sth r9, 0x56(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[9].u16 ) };
	// 824AA51C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824AA520: 4099004C  ble cr6, 0x824aa56c
	if !ctx.cr[6].gt {
	pc = 0x824AA56C; continue 'dispatch;
	}
	// 824AA524: 3B9D0010  addi r28, r29, 0x10
	ctx.r[28].s64 = ctx.r[29].s64 + 16;
	// 824AA528: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x824AA52C; continue 'dispatch;
            }
            0x824AA52C => {
    //   block [0x824AA52C..0x824AA56C)
	// 824AA52C: 817D0150  lwz r11, 0x150(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AA530: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 824AA534: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 824AA538: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 824AA53C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 824AA540: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA544: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA548: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA54C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824AA550: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AA554: 4E800421  bctrl
	ctx.lr = 0x824AA558;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AA558: 817D0154  lwz r11, 0x154(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AA55C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824AA560: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 824AA564: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AA568: 4198FFC4  blt cr6, 0x824aa52c
	if ctx.cr[6].lt {
	pc = 0x824AA52C; continue 'dispatch;
	}
            }
            0x824AA56C => {
    //   block [0x824AA56C..0x824AA574)
	// 824AA56C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 824AA570: 4808AB98  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AA578 size=96
    let mut pc: u32 = 0x824AA578;
    'dispatch: loop {
        match pc {
            0x824AA578 => {
    //   block [0x824AA578..0x824AA5D8)
	// 824AA578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AA57C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AA580: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AA584: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AA588: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AA58C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AA590: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 824AA594: 4BFFFC2D  bl 0x824aa1c0
	ctx.lr = 0x824AA598;
	sub_824AA1C0(ctx, base);
	// 824AA598: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AA59C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824AA5A0: 396BE4FC  addi r11, r11, -0x1b04
	ctx.r[11].s64 = ctx.r[11].s64 + -6916;
	// 824AA5A4: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 824AA5A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AA5AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AA5B0: 915F0150  stw r10, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[10].u32 ) };
	// 824AA5B4: 915F0154  stw r10, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 824AA5B8: 913F0158  stw r9, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[9].u32 ) };
	// 824AA5BC: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 824AA5C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AA5C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AA5C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AA5CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AA5D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AA5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AA5D8 size=192
    let mut pc: u32 = 0x824AA5D8;
    'dispatch: loop {
        match pc {
            0x824AA5D8 => {
    //   block [0x824AA5D8..0x824AA61C)
	// 824AA5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AA5DC: 4808AAE1  bl 0x825350bc
	ctx.lr = 0x824AA5E0;
	sub_82535080(ctx, base);
	// 824AA5E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AA5E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824AA5E8: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824AA5EC: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824AA5F0: 394AE4FC  addi r10, r10, -0x1b04
	ctx.r[10].s64 = ctx.r[10].s64 + -6916;
	// 824AA5F4: 39290894  addi r9, r9, 0x894
	ctx.r[9].s64 = ctx.r[9].s64 + 2196;
	// 824AA5F8: 817E0154  lwz r11, 0x154(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AA5FC: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 824AA600: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824AA604: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824AA608: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 824AA60C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824AA610: B1610056  sth r11, 0x56(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[11].u16 ) };
	// 824AA614: 41980034  blt cr6, 0x824aa648
	if ctx.cr[6].lt {
	pc = 0x824AA648; continue 'dispatch;
	}
	// 824AA618: 57FD1838  slwi r29, r31, 3
	ctx.r[29].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	pc = 0x824AA61C; continue 'dispatch;
            }
            0x824AA61C => {
    //   block [0x824AA61C..0x824AA648)
	// 824AA61C: 817E0150  lwz r11, 0x150(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AA620: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824AA624: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824AA628: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA62C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AA630: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AA634: 4E800421  bctrl
	ctx.lr = 0x824AA638;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AA638: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 824AA63C: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 824AA640: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824AA644: 4098FFD8  bge cr6, 0x824aa61c
	if !ctx.cr[6].lt {
	pc = 0x824AA61C; continue 'dispatch;
	}
            }
            0x824AA648 => {
    //   block [0x824AA648..0x824AA688)
	// 824AA648: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824AA64C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824AA650: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824AA654: 915E0154  stw r10, 0x154(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 824AA658: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824AA65C: 817E0158  lwz r11, 0x158(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(344 as u32) ) } as u64;
	// 824AA660: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AA664: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AA668: 409A0020  bne cr6, 0x824aa688
	if !ctx.cr[6].eq {
	pc = 0x824AA688; continue 'dispatch;
	}
	// 824AA66C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA670: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AA674: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AA678: 809E0150  lwz r4, 0x150(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AA67C: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AA680: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AA684: 4BFB9A35  bl 0x824640b8
	ctx.lr = 0x824AA688;
	sub_824640B8(ctx, base);
	pc = 0x824AA688; continue 'dispatch;
            }
            0x824AA688 => {
    //   block [0x824AA688..0x824AA698)
	// 824AA688: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AA68C: 4BFFF515  bl 0x824a9ba0
	ctx.lr = 0x824AA690;
	sub_824A9BA0(ctx, base);
	// 824AA690: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824AA694: 4808AA78  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AA698 size=440
    let mut pc: u32 = 0x824AA698;
    'dispatch: loop {
        match pc {
            0x824AA698 => {
    //   block [0x824AA698..0x824AA73C)
	// 824AA698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AA69C: 4808AA11  bl 0x825350ac
	ctx.lr = 0x824AA6A0;
	sub_82535080(ctx, base);
	// 824AA6A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AA6A4: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA6A8: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 824AA6AC: 38A00031  li r5, 0x31
	ctx.r[5].s64 = 49;
	// 824AA6B0: 38800160  li r4, 0x160
	ctx.r[4].s64 = 352;
	// 824AA6B4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824AA6B8: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824AA6BC: 4BFB997D  bl 0x82464038
	ctx.lr = 0x824AA6C0;
	sub_82464038(ctx, base);
	// 824AA6C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AA6C4: 39600160  li r11, 0x160
	ctx.r[11].s64 = 352;
	// 824AA6C8: 38BB00A0  addi r5, r27, 0xa0
	ctx.r[5].s64 = ctx.r[27].s64 + 160;
	// 824AA6CC: B17F0004  sth r11, 4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 824AA6D0: 839B002C  lwz r28, 0x2c(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 824AA6D4: 809B0010  lwz r4, 0x10(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 824AA6D8: 4BFFFAE9  bl 0x824aa1c0
	ctx.lr = 0x824AA6DC;
	sub_824AA1C0(ctx, base);
	// 824AA6DC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AA6E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824AA6E4: 396BE4FC  addi r11, r11, -0x1b04
	ctx.r[11].s64 = ctx.r[11].s64 + -6916;
	// 824AA6E8: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 824AA6EC: 3BDF0080  addi r30, r31, 0x80
	ctx.r[30].s64 = ctx.r[31].s64 + 128;
	// 824AA6F0: 3BBB0080  addi r29, r27, 0x80
	ctx.r[29].s64 = ctx.r[27].s64 + 128;
	// 824AA6F4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AA6F8: 915F0150  stw r10, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[10].u32 ) };
	// 824AA6FC: 915F0154  stw r10, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 824AA700: 913F0158  stw r9, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[9].u32 ) };
	// 824AA704: 939F002C  stw r28, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[28].u32 ) };
	// 824AA708: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AA70C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA710: 554B00BE  clrlwi r11, r10, 2
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 824AA714: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AA718: 40980050  bge cr6, 0x824aa768
	if !ctx.cr[6].lt {
	pc = 0x824AA768; continue 'dispatch;
	}
	// 824AA71C: 554A0000  rlwinm r10, r10, 0, 0, 0
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 824AA720: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AA724: 409A0018  bne cr6, 0x824aa73c
	if !ctx.cr[6].eq {
	pc = 0x824AA73C; continue 'dispatch;
	}
	// 824AA728: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AA72C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA730: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AA734: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824AA738: 4BFB9981  bl 0x824640b8
	ctx.lr = 0x824AA73C;
	sub_824640B8(ctx, base);
	pc = 0x824AA73C; continue 'dispatch;
            }
            0x824AA73C => {
    //   block [0x824AA73C..0x824AA768)
	// 824AA73C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA740: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 824AA744: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824AA748: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 824AA74C: 4BFB98ED  bl 0x82464038
	ctx.lr = 0x824AA750;
	sub_82464038(ctx, base);
	// 824AA750: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AA754: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824AA758: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA75C: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AA760: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 824AA764: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x824AA768; continue 'dispatch;
            }
            0x824AA768 => {
    //   block [0x824AA768..0x824AA784)
	// 824AA768: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA76C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA770: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AA774: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824AA778: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA77C: 40990020  ble cr6, 0x824aa79c
	if !ctx.cr[6].gt {
	pc = 0x824AA79C; continue 'dispatch;
	}
	// 824AA780: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x824AA784; continue 'dispatch;
            }
            0x824AA784 => {
    //   block [0x824AA784..0x824AA79C)
	// 824AA784: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AA788: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824AA78C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AA790: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824AA794: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824AA798: 409AFFEC  bne cr6, 0x824aa784
	if !ctx.cr[6].eq {
	pc = 0x824AA784; continue 'dispatch;
	}
	pc = 0x824AA79C; continue 'dispatch;
            }
            0x824AA79C => {
    //   block [0x824AA79C..0x824AA7D8)
	// 824AA79C: 3BDF008C  addi r30, r31, 0x8c
	ctx.r[30].s64 = ctx.r[31].s64 + 140;
	// 824AA7A0: 3BBB008C  addi r29, r27, 0x8c
	ctx.r[29].s64 = ctx.r[27].s64 + 140;
	// 824AA7A4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AA7A8: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA7AC: 554B00BE  clrlwi r11, r10, 2
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 824AA7B0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AA7B4: 40980050  bge cr6, 0x824aa804
	if !ctx.cr[6].lt {
	pc = 0x824AA804; continue 'dispatch;
	}
	// 824AA7B8: 554A0000  rlwinm r10, r10, 0, 0, 0
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 824AA7BC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AA7C0: 409A0018  bne cr6, 0x824aa7d8
	if !ctx.cr[6].eq {
	pc = 0x824AA7D8; continue 'dispatch;
	}
	// 824AA7C4: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AA7C8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA7CC: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AA7D0: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824AA7D4: 4BFB98E5  bl 0x824640b8
	ctx.lr = 0x824AA7D8;
	sub_824640B8(ctx, base);
	pc = 0x824AA7D8; continue 'dispatch;
            }
            0x824AA7D8 => {
    //   block [0x824AA7D8..0x824AA804)
	// 824AA7D8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA7DC: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 824AA7E0: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824AA7E4: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 824AA7E8: 4BFB9851  bl 0x82464038
	ctx.lr = 0x824AA7EC;
	sub_82464038(ctx, base);
	// 824AA7EC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AA7F0: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824AA7F4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA7F8: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AA7FC: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 824AA800: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x824AA804; continue 'dispatch;
            }
            0x824AA804 => {
    //   block [0x824AA804..0x824AA820)
	// 824AA804: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA808: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA80C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AA810: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824AA814: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA818: 40990020  ble cr6, 0x824aa838
	if !ctx.cr[6].gt {
	pc = 0x824AA838; continue 'dispatch;
	}
	// 824AA81C: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x824AA820; continue 'dispatch;
            }
            0x824AA820 => {
    //   block [0x824AA820..0x824AA838)
	// 824AA820: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AA824: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824AA828: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AA82C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824AA830: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824AA834: 409AFFEC  bne cr6, 0x824aa820
	if !ctx.cr[6].eq {
	pc = 0x824AA820; continue 'dispatch;
	}
	pc = 0x824AA838; continue 'dispatch;
            }
            0x824AA838 => {
    //   block [0x824AA838..0x824AA850)
	// 824AA838: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824AA83C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AA840: 4BFE67B1  bl 0x82490ff0
	ctx.lr = 0x824AA844;
	sub_82490FF0(ctx, base);
	// 824AA844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AA848: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824AA84C: 4808A8B0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AA850 size=256
    let mut pc: u32 = 0x824AA850;
    'dispatch: loop {
        match pc {
            0x824AA850 => {
    //   block [0x824AA850..0x824AA8A0)
	// 824AA850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AA854: 4808A865  bl 0x825350b8
	ctx.lr = 0x824AA858;
	sub_82535080(ctx, base);
	// 824AA858: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AA85C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824AA860: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824AA864: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA868: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AA86C: 419A00DC  beq cr6, 0x824aa948
	if ctx.cr[6].eq {
	pc = 0x824AA948; continue 'dispatch;
	}
	// 824AA870: 48000459  bl 0x824aacc8
	ctx.lr = 0x824AA874;
	sub_824AACC8(ctx, base);
	// 824AA874: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824AA878: 409A00D0  bne cr6, 0x824aa948
	if !ctx.cr[6].eq {
	pc = 0x824AA948; continue 'dispatch;
	}
	// 824AA87C: 3BFC0150  addi r31, r28, 0x150
	ctx.r[31].s64 = ctx.r[28].s64 + 336;
	// 824AA880: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AA884: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA888: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AA88C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AA890: 409A0010  bne cr6, 0x824aa8a0
	if !ctx.cr[6].eq {
	pc = 0x824AA8A0; continue 'dispatch;
	}
	// 824AA894: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 824AA898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AA89C: 4BFC3AB5  bl 0x8246e350
	ctx.lr = 0x824AA8A0;
	sub_8246E350(ctx, base);
	pc = 0x824AA8A0; continue 'dispatch;
            }
            0x824AA8A0 => {
    //   block [0x824AA8A0..0x824AA8CC)
	// 824AA8A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA8A4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 824AA8A8: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA8AC: 3920000E  li r9, 0xe
	ctx.r[9].s64 = 14;
	// 824AA8B0: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 824AA8B4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AA8B8: 7FCB4214  add r30, r11, r8
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824AA8BC: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 824AA8C0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AA8C4: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 824AA8C8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x824AA8CC; continue 'dispatch;
            }
            0x824AA8CC => {
    //   block [0x824AA8CC..0x824AA948)
	// 824AA8CC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 824AA8D0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824AA8D4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 824AA8D8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 824AA8DC: 4200FFF0  bdnz 0x824aa8cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824AA8CC; continue 'dispatch;
	}
	// 824AA8E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824AA8E4: 387C0010  addi r3, r28, 0x10
	ctx.r[3].s64 = ctx.r[28].s64 + 16;
	// 824AA8E8: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA8EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824AA8F0: 394B1C60  addi r10, r11, 0x1c60
	ctx.r[10].s64 = ctx.r[11].s64 + 7264;
	// 824AA8F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824AA8F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824AA8FC: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA900: 914100B0  stw r10, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 824AA904: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824AA908: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 824AA90C: 394B01A0  addi r10, r11, 0x1a0
	ctx.r[10].s64 = ctx.r[11].s64 + 416;
	// 824AA910: 8108000C  lwz r8, 0xc(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AA914: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AA918: 55082834  slwi r8, r8, 5
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824AA91C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824AA920: 7D4A48AE  lbzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 824AA924: 5549103E  rotlwi r9, r10, 2
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 824AA928: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824AA92C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824AA930: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824AA934: 816B09A0  lwz r11, 0x9a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2464 as u32) ) } as u64;
	// 824AA938: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AA93C: 4E800421  bctrl
	ctx.lr = 0x824AA940;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AA940: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824AA944: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
            }
            0x824AA948 => {
    //   block [0x824AA948..0x824AA950)
	// 824AA948: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 824AA94C: 4808A7BC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AA950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AA950 size=244
    let mut pc: u32 = 0x824AA950;
    'dispatch: loop {
        match pc {
            0x824AA950 => {
    //   block [0x824AA950..0x824AA9D4)
	// 824AA950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AA954: 4808A761  bl 0x825350b4
	ctx.lr = 0x824AA958;
	sub_82535080(ctx, base);
	// 824AA958: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AA95C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824AA960: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AA964: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AA968: 388B08C4  addi r4, r11, 0x8c4
	ctx.r[4].s64 = ctx.r[11].s64 + 2244;
	// 824AA96C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 824AA970: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA974: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 824AA978: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AA97C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AA980: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AA984: 4E800421  bctrl
	ctx.lr = 0x824AA988;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AA988: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824AA98C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AA990: 4BFFF099  bl 0x824a9a28
	ctx.lr = 0x824AA994;
	sub_824A9A28(ctx, base);
	// 824AA994: 817F0158  lwz r11, 0x158(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 824AA998: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AA99C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AA9A0: 409A0034  bne cr6, 0x824aa9d4
	if !ctx.cr[6].eq {
	pc = 0x824AA9D4; continue 'dispatch;
	}
	// 824AA9A4: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA9A8: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824AA9AC: 80FF0154  lwz r7, 0x154(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AA9B0: 55681838  slwi r8, r11, 3
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824AA9B4: 80DF0150  lwz r6, 0x150(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AA9B8: 388A08B8  addi r4, r10, 0x8b8
	ctx.r[4].s64 = ctx.r[10].s64 + 2232;
	// 824AA9BC: 54E71838  slwi r7, r7, 3
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 824AA9C0: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 824AA9C4: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AA9C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AA9CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AA9D0: 4E800421  bctrl
	ctx.lr = 0x824AA9D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824AA9D4 => {
    //   block [0x824AA9D4..0x824AA9F0)
	// 824AA9D4: 817F0154  lwz r11, 0x154(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AA9D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 824AA9DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AA9E0: 40990048  ble cr6, 0x824aaa28
	if !ctx.cr[6].gt {
	pc = 0x824AAA28; continue 'dispatch;
	}
	// 824AA9E4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AA9E8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 824AA9EC: 3B6B08B0  addi r27, r11, 0x8b0
	ctx.r[27].s64 = ctx.r[11].s64 + 2224;
	pc = 0x824AA9F0; continue 'dispatch;
            }
            0x824AA9F0 => {
    //   block [0x824AA9F0..0x824AAA28)
	// 824AA9F0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AA9F4: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 824AA9F8: 815F0150  lwz r10, 0x150(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AA9FC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824AAA00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AAA04: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AAA08: 7CCAE82E  lwzx r6, r10, r29
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824AAA0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AAA10: 4E800421  bctrl
	ctx.lr = 0x824AAA14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AAA14: 817F0154  lwz r11, 0x154(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AAA18: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 824AAA1C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 824AAA20: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AAA24: 4198FFCC  blt cr6, 0x824aa9f0
	if ctx.cr[6].lt {
	pc = 0x824AA9F0; continue 'dispatch;
	}
            }
            0x824AAA28 => {
    //   block [0x824AAA28..0x824AAA44)
	// 824AAA28: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AAA2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AAA30: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824AAA34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AAA38: 4E800421  bctrl
	ctx.lr = 0x824AAA3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AAA3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824AAA40: 4808A6C4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AAA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AAA48 size=144
    let mut pc: u32 = 0x824AAA48;
    'dispatch: loop {
        match pc {
            0x824AAA48 => {
    //   block [0x824AAA48..0x824AAA9C)
	// 824AAA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AAA4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AAA50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AAA54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AAA58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AAA5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824AAA60: 817E0154  lwz r11, 0x154(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AAA64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AAA68: 409A0050  bne cr6, 0x824aaab8
	if !ctx.cr[6].eq {
	pc = 0x824AAAB8; continue 'dispatch;
	}
	// 824AAA6C: 3BFE0150  addi r31, r30, 0x150
	ctx.r[31].s64 = ctx.r[30].s64 + 336;
	// 824AAA70: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AAA74: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AAA78: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AAA7C: 409A0020  bne cr6, 0x824aaa9c
	if !ctx.cr[6].eq {
	pc = 0x824AAA9C; continue 'dispatch;
	}
	// 824AAA80: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AAA84: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AAA88: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AAA8C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AAA90: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AAA94: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AAA98: 4BFB9621  bl 0x824640b8
	ctx.lr = 0x824AAA9C;
	sub_824640B8(ctx, base);
	pc = 0x824AAA9C; continue 'dispatch;
            }
            0x824AAA9C => {
    //   block [0x824AAA9C..0x824AAAB8)
	// 824AAA9C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AAAA0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824AAAA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AAAA8: 512AF880  rlwimi r10, r9, 0x1f, 2, 0
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(31) as u64) & 0xFFFFFFFFBFFFFFFF) | (ctx.r[10].u64 & 0x0000000040000000);
	// 824AAAAC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AAAB0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AAAB4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x824AAAB8; continue 'dispatch;
            }
            0x824AAAB8 => {
    //   block [0x824AAAB8..0x824AAAD8)
	// 824AAAB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AAABC: 4BFFF455  bl 0x824a9f10
	ctx.lr = 0x824AAAC0;
	sub_824A9F10(ctx, base);
	// 824AAAC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AAAC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AAAC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AAACC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AAAD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AAAD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


