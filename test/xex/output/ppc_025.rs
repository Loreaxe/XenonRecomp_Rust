pub fn sub_82322570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82322570 size=128
    let mut pc: u32 = 0x82322570;
    'dispatch: loop {
        match pc {
            0x82322570 => {
    //   block [0x82322570..0x8232259C)
	// 82322570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82322574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82322578: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232257C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82322580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82322584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82322588: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8232258C: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82322590: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82322594: 419A0008  beq cr6, 0x8232259c
	if ctx.cr[6].eq {
	pc = 0x8232259C; continue 'dispatch;
	}
	// 82322598: 4BDFAAC1  bl 0x8211d058
	ctx.lr = 0x8232259C;
	sub_8211D058(ctx, base);
	pc = 0x8232259C; continue 'dispatch;
            }
            0x8232259C => {
    //   block [0x8232259C..0x823225D8)
	// 8232259C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 823225A0: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 823225A4: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 823225A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823225AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823225B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823225B4: 419A0024  beq cr6, 0x823225d8
	if ctx.cr[6].eq {
	pc = 0x823225D8; continue 'dispatch;
	}
	// 823225B8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 823225BC: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 823225C0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 823225C4: 409A0014  bne cr6, 0x823225d8
	if !ctx.cr[6].eq {
	pc = 0x823225D8; continue 'dispatch;
	}
	// 823225C8: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 823225CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823225D0: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 823225D4: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x823225D8; continue 'dispatch;
            }
            0x823225D8 => {
    //   block [0x823225D8..0x823225F0)
	// 823225D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823225DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823225E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823225E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823225E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823225EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823225F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823225F0 size=2256
    let mut pc: u32 = 0x823225F0;
    'dispatch: loop {
        match pc {
            0x823225F0 => {
    //   block [0x823225F0..0x82322648)
	// 823225F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823225F4: 48212A95  bl 0x82535088
	ctx.lr = 0x823225F8;
	sub_82535080(ctx, base);
	// 823225F8: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 823225FC: 482139C1  bl 0x82535fbc
	ctx.lr = 0x82322600;
	sub_82535FB0(ctx, base);
	// 82322600: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82322604: 3E00829F  lis r16, -0x7d61
	ctx.r[16].s64 = -2103508992;
	// 82322608: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8232260C: 8170B514  lwz r11, -0x4aec(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-19180 as u32) ) } as u64;
	// 82322610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82322614: 409A0034  bne cr6, 0x82322648
	if !ctx.cr[6].eq {
	pc = 0x82322648; continue 'dispatch;
	}
	// 82322618: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232261C: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82322620: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82322624: 409A088C  bne cr6, 0x82322eb0
	if !ctx.cr[6].eq {
	pc = 0x82322EB0; continue 'dispatch;
	}
	// 82322628: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8232262C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82322630: 997E0019  stb r11, 0x19(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82322634: 995E0025  stb r10, 0x25(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 82322638: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 8232263C: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 82322640: 482139C9  bl 0x82536008
	ctx.lr = 0x82322644;
	sub_82535FFC(ctx, base);
	// 82322644: 48212A94  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x82322648 => {
    //   block [0x82322648..0x8232290C)
	// 82322648: 48210BC9  bl 0x82533210
	ctx.lr = 0x8232264C;
	sub_82533210(ctx, base);
	// 8232264C: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82322650: C1BE00A0  lfs f13, 0xa0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322654: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82322658: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8232265C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82322660: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82322664: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82322668: C3AB206C  lfs f29, 0x206c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8300 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8232266C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82322670: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82322674: C3EBD6C8  lfs f31, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82322678: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8232267C: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82322680: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82322684: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82322688: C00BA078  lfs f0, -0x5f88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24456 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232268C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82322690: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82322694: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82322698: 48210B79  bl 0x82533210
	ctx.lr = 0x8232269C;
	sub_82533210(ctx, base);
	// 8232269C: 5469047E  clrlwi r9, r3, 0x11
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 823226A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823226A4: C1BE00A0  lfs f13, 0xa0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823226A8: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 823226AC: 38CBD76C  addi r6, r11, -0x2894
	ctx.r[6].s64 = ctx.r[11].s64 + -10388;
	// 823226B0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 823226B4: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 823226B8: 3BFE0080  addi r31, r30, 0x80
	ctx.r[31].s64 = ctx.r[30].s64 + 128;
	// 823226BC: 386BDBE0  addi r3, r11, -0x2420
	ctx.r[3].s64 = ctx.r[11].s64 + -9248;
	// 823226C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823226C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823226C8: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 823226CC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823226D0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823226D4: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 823226D8: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 823226DC: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823226E0: C00B2094  lfs f0, 0x2094(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823226E4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823226E8: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 823226EC: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823226F0: 82410054  lwz r18, 0x54(r1)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823226F4: 82810050  lwz r20, 0x50(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823226F8: 7D72A214  add r11, r18, r20
	ctx.r[11].u64 = ctx.r[18].u64 + ctx.r[20].u64;
	// 823226FC: 1D6B0078  mulli r11, r11, 0x78
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 120 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82322700: 3BAB6320  addi r29, r11, 0x6320
	ctx.r[29].s64 = ctx.r[11].s64 + 25376;
	// 82322704: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82322708: 4BED2BE1  bl 0x821f52e8
	ctx.lr = 0x8232270C;
	sub_821F52E8(ctx, base);
	// 8232270C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82322710: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82322714: 4BF0ACD5  bl 0x8222d3e8
	ctx.lr = 0x82322718;
	sub_8222D3E8(ctx, base);
	// 82322718: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8232271C: 48212AB5  bl 0x825351d0
	ctx.lr = 0x82322720;
	sub_825351D0(ctx, base);
	// 82322720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82322724: 4BF0ACC5  bl 0x8222d3e8
	ctx.lr = 0x82322728;
	sub_8222D3E8(ctx, base);
	// 82322728: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8232272C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82322730: 907E00B0  stw r3, 0xb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 82322734: 392B8E40  addi r9, r11, -0x71c0
	ctx.r[9].s64 = ctx.r[11].s64 + -29120;
	// 82322738: 546B003E  slwi r11, r3, 0
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8232273C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82322740: 394300D8  addi r10, r3, 0xd8
	ctx.r[10].s64 = ctx.r[3].s64 + 216;
	// 82322744: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82322748: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8232274C: B30B0004  sth r24, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 82322750: B30B0006  sth r24, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[24].u16 ) };
	// 82322754: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322758: 930B0024  stw r24, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[24].u32 ) };
	// 8232275C: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322760: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82322764: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322768: 930B0018  stw r24, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[24].u32 ) };
	// 8232276C: 8170B514  lwz r11, -0x4aec(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-19180 as u32) ) } as u64;
	// 82322770: 80FE00B0  lwz r7, 0xb0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322774: 812B0090  lwz r9, 0x90(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82322778: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8232277C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82322780: 91670008  stw r11, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82322784: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322788: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8232278C: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 82322790: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322794: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82322798: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8232279C: 38AA03FF  addi r5, r10, 0x3ff
	ctx.r[5].s64 = ctx.r[10].s64 + 1023;
	// 823227A0: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 823227A4: C2A626B0  lfs f21, 0x26b0(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(9904 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 823227A8: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 823227AC: C3C91FF8  lfs f30, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823227B0: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 823227B4: D3CB001C  stfs f30, 0x1c(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823227B8: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 823227BC: D3CB0020  stfs f30, 0x20(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 823227C0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823227C4: C1A72398  lfs f13, 0x2398(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(9112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823227C8: 38E100D4  addi r7, r1, 0xd4
	ctx.r[7].s64 = ctx.r[1].s64 + 212;
	// 823227CC: C3E6BA38  lfs f31, -0x45c8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823227D0: 38C00009  li r6, 9
	ctx.r[6].s64 = 9;
	// 823227D4: C009D5B0  lfs f0, -0x2a50(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823227D8: 392100A4  addi r9, r1, 0xa4
	ctx.r[9].s64 = ctx.r[1].s64 + 164;
	// 823227DC: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 823227E0: C26BD564  lfs f19, -0x2a9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 823227E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823227E8: C0082068  lfs f0, 0x2068(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823227EC: 390100BC  addi r8, r1, 0xbc
	ctx.r[8].s64 = ctx.r[1].s64 + 188;
	// 823227F0: 90C100D8  stw r6, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[6].u32 ) };
	// 823227F4: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 823227F8: 90C100DC  stw r6, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[6].u32 ) };
	// 823227FC: 38C00018  li r6, 0x18
	ctx.r[6].s64 = 24;
	// 82322800: D1A10098  stfs f13, 0x98(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82322804: D2A1009C  stfs f21, 0x9c(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82322808: D3C100A0  stfs f30, 0xa0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8232280C: 93090000  stw r24, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82322810: C1AB2038  lfs f13, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322814: 90C100E0  stw r6, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[6].u32 ) };
	// 82322818: D26100A8  stfs f19, 0xa8(r1)
	tmp.f32 = (ctx.f[19].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8232281C: 80DE00B0  lwz r6, 0xb0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322820: D1A100AC  stfs f13, 0xac(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82322824: D26100B0  stfs f19, 0xb0(r1)
	tmp.f32 = (ctx.f[19].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82322828: 54AB0036  rlwinm r11, r5, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 8232282C: D3C100B8  stfs f30, 0xb8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82322830: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82322834: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82322838: 91460038  stw r10, 0x38(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 8232283C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82322840: 813E00B0  lwz r9, 0xb0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322844: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82322848: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8232284C: C18A228C  lfs f12, 0x228c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8844 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82322850: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82322854: D18100B4  stfs f12, 0xb4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82322858: 93080000  stw r24, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 8232285C: D00100C0  stfs f0, 0xc0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82322860: 9169003C  stw r11, 0x3c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82322864: D1A100C4  stfs f13, 0xc4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82322868: D2A100D0  stfs f21, 0xd0(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 8232286C: C00A26AC  lfs f0, 0x26ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9900 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322870: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82322874: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82322878: C00A26A8  lfs f0, 0x26a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9896 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232287C: 394B03FF  addi r10, r11, 0x3ff
	ctx.r[10].s64 = ctx.r[11].s64 + 1023;
	// 82322880: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82322884: 93070000  stw r24, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82322888: 554B0036  rlwinm r11, r10, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8232288C: 815E00B0  lwz r10, 0xb0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322890: 392B0A8F  addi r9, r11, 0xa8f
	ctx.r[9].s64 = ctx.r[11].s64 + 2703;
	// 82322894: 916A0040  stw r11, 0x40(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82322898: 552B0036  rlwinm r11, r9, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8232289C: 815E00B0  lwz r10, 0xb0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 823228A0: 392B10EF  addi r9, r11, 0x10ef
	ctx.r[9].s64 = ctx.r[11].s64 + 4335;
	// 823228A4: 916A0044  stw r11, 0x44(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 823228A8: 552B0036  rlwinm r11, r9, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 823228AC: 815E00B0  lwz r10, 0xb0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 823228B0: 392B10EF  addi r9, r11, 0x10ef
	ctx.r[9].s64 = ctx.r[11].s64 + 4335;
	// 823228B4: 916A0048  stw r11, 0x48(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 823228B8: 552B0036  rlwinm r11, r9, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 823228BC: 815E00B0  lwz r10, 0xb0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 823228C0: 392B2D0F  addi r9, r11, 0x2d0f
	ctx.r[9].s64 = ctx.r[11].s64 + 11535;
	// 823228C4: 916A004C  stw r11, 0x4c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 823228C8: 55310036  rlwinm r17, r9, 0, 0, 0x1b
	ctx.r[17].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 823228CC: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 823228D0: C32100B4  lfs f25, 0xb4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 823228D4: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 823228D8: C30100B0  lfs f24, 0xb0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 823228DC: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 823228E0: C2E100AC  lfs f23, 0xac(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 823228E4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823228E8: C2C100A8  lfs f22, 0xa8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 823228EC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823228F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823228F4: C346D6D0  lfs f26, -0x2930(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 823228F8: C3872144  lfs f28, 0x2144(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8516 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 823228FC: C28820C8  lfs f20, 0x20c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8392 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 82322900: C369BFFC  lfs f27, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82322904: C24A2198  lfs f18, 0x2198(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8600 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 82322908: C22B26A4  lfs f17, 0x26a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9892 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	pc = 0x8232290C; continue 'dispatch;
            }
            0x8232290C => {
    //   block [0x8232290C..0x82322968)
	// 8232290C: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82322910: 815E00B0  lwz r10, 0xb0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322914: 392100D8  addi r9, r1, 0xd8
	ctx.r[9].s64 = ctx.r[1].s64 + 216;
	// 82322918: 391C0014  addi r8, r28, 0x14
	ctx.r[8].s64 = ctx.r[28].s64 + 20;
	// 8232291C: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 82322920: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82322924: 38DC0011  addi r6, r28, 0x11
	ctx.r[6].s64 = ctx.r[28].s64 + 17;
	// 82322928: 7ECB482E  lwzx r22, r11, r9
	ctx.r[22].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8232292C: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82322930: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82322934: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82322938: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 8232293C: 55751838  slwi r21, r11, 3
	ctx.r[21].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[21].u64 = ctx.r[21].u32 as u64;
	// 82322940: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82322944: 7C153C2E  lfsx f0, r21, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322948: 7C08552E  stfsx f0, r8, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 8232294C: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322950: 7F29582E  lwzx r25, r9, r11
	ctx.r[25].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82322954: 419A0318  beq cr6, 0x82322c6c
	if ctx.cr[6].eq {
	pc = 0x82322C6C; continue 'dispatch;
	}
	// 82322958: 397C000E  addi r11, r28, 0xe
	ctx.r[11].s64 = ctx.r[28].s64 + 14;
	// 8232295C: 3AFE0090  addi r23, r30, 0x90
	ctx.r[23].s64 = ctx.r[30].s64 + 144;
	// 82322960: 5573103A  slwi r19, r11, 2
	ctx.r[19].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[19].u64 = ctx.r[19].u32 as u64;
	// 82322964: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	pc = 0x82322968; continue 'dispatch;
            }
            0x82322968 => {
    //   block [0x82322968..0x82322A14)
	// 82322968: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 8232296C: 7D6B982E  lwzx r11, r11, r19
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 82322970: 7FEBD214  add r31, r11, r26
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82322974: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 82322978: 933F0000  stw r25, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 8232297C: C0170000  lfs f0, 0(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322980: D01D0030  stfs f0, 0x30(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82322984: C0170004  lfs f0, 4(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322988: D01D0034  stfs f0, 0x34(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232298C: C0170008  lfs f0, 8(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322990: D01D0038  stfs f0, 0x38(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82322994: D3FD003C  stfs f31, 0x3c(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82322998: 48210879  bl 0x82533210
	ctx.lr = 0x8232299C;
	sub_82533210(ctx, base);
	// 8232299C: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 823229A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823229A4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 823229A8: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 823229AC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823229B0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823229B4: EC200772  fmuls f1, f0, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 823229B8: 48045601  bl 0x82367fb8
	ctx.lr = 0x823229BC;
	sub_82367FB8(ctx, base);
	// 823229BC: 2B1C0001  cmplwi cr6, r28, 1
	ctx.cr[6].compare_u32(ctx.r[28].u32, 1 as u32, &mut ctx.xer);
	// 823229C0: 409A0054  bne cr6, 0x82322a14
	if !ctx.cr[6].eq {
	pc = 0x82322A14; continue 'dispatch;
	}
	// 823229C4: 4821084D  bl 0x82533210
	ctx.lr = 0x823229C8;
	sub_82533210(ctx, base);
	// 823229C8: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 823229CC: C1BE00A0  lfs f13, 0xa0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823229D0: F96100F8  std r11, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u64 ) };
	// 823229D4: C80100F8  lfd f0, 0xf8(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 823229D8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823229DC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823229E0: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 823229E4: EC00BDBA  fmadds f0, f0, f22, f23
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[22].f64 + ctx.f[23].f64) as f32) as f64);
	// 823229E8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823229EC: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823229F0: 48210821  bl 0x82533210
	ctx.lr = 0x823229F4;
	sub_82533210(ctx, base);
	// 823229F4: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 823229F8: F96100F0  std r11, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u64 ) };
	// 823229FC: C80100F0  lfd f0, 0xf0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) };
	// 82322A00: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82322A04: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82322A08: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82322A0C: EC00CE3A  fmadds f0, f0, f24, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[24].f64 + ctx.f[25].f64) as f32) as f64);
	// 82322A10: 48000070  b 0x82322a80
	pc = 0x82322A80; continue 'dispatch;
            }
            0x82322A14 => {
    //   block [0x82322A14..0x82322A80)
	// 82322A14: 7ACB0020  clrldi r11, r22, 0x20
	ctx.r[11].u64 = ctx.r[22].u64 & 0x00000000FFFFFFFFu64;
	// 82322A18: C19E00A0  lfs f12, 0xa0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82322A1C: 7B6A0020  clrldi r10, r27, 0x20
	ctx.r[10].u64 = ctx.r[27].u64 & 0x00000000FFFFFFFFu64;
	// 82322A20: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 82322A24: 39010098  addi r8, r1, 0x98
	ctx.r[8].s64 = ctx.r[1].s64 + 152;
	// 82322A28: 38E10094  addi r7, r1, 0x94
	ctx.r[7].s64 = ctx.r[1].s64 + 148;
	// 82322A2C: F96100E8  std r11, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[11].u64 ) };
	// 82322A30: 3961009C  addi r11, r1, 0x9c
	ctx.r[11].s64 = ctx.r[1].s64 + 156;
	// 82322A34: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82322A38: 7D754C2E  lfsx f11, r21, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82322A3C: 7D55442E  lfsx f10, r21, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82322A40: 7D353C2E  lfsx f9, r21, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82322A44: 7D155C2E  lfsx f8, r21, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82322A48: C80100E8  lfd f0, 0xe8(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	// 82322A4C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82322A50: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82322A54: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82322A58: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82322A5C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82322A60: ECFF0024  fdivs f7, f31, f0
	ctx.f[7].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82322A64: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82322A68: ED6B01F2  fmuls f11, f11, f7
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[7].f64) as f32) as f64);
	// 82322A6C: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82322A70: ED6B4B7A  fmadds f11, f11, f13, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64);
	// 82322A74: EC00437A  fmadds f0, f0, f13, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[8].f64) as f32) as f64);
	// 82322A78: EDAB0332  fmuls f13, f11, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82322A7C: D1BF0050  stfs f13, 0x50(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x82322A80; continue 'dispatch;
            }
            0x82322A80 => {
    //   block [0x82322A80..0x82322AA8)
	// 82322A80: C1BE00A4  lfs f13, 0xa4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322A84: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82322A88: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82322A8C: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322A90: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82322A94: EDAD04B2  fmuls f13, f13, f18
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[18].f64) as f32) as f64);
	// 82322A98: D23F0060  stfs f17, 0x60(r31)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82322A9C: D1BF005C  stfs f13, 0x5c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82322AA0: EC0004B2  fmuls f0, f0, f18
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[18].f64) as f32) as f64);
	// 82322AA4: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	pc = 0x82322AA8; continue 'dispatch;
            }
            0x82322AA8 => {
    //   block [0x82322AA8..0x82322B4C)
	// 82322AA8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322AAC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82322AB0: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82322AB4: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82322AB8: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82322ABC: D3E9000C  stfs f31, 0xc(r9)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82322AC0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322AC4: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82322AC8: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 82322ACC: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82322AD0: F9490008  std r10, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82322AD4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322AD8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82322ADC: D36A0020  stfs f27, 0x20(r10)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82322AE0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322AE4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82322AE8: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 82322AEC: 2B0B01E0  cmplwi cr6, r11, 0x1e0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 480 as u32, &mut ctx.xer);
	// 82322AF0: D36A0024  stfs f27, 0x24(r10)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82322AF4: 4198FFB4  blt cr6, 0x82322aa8
	if ctx.cr[6].lt {
	pc = 0x82322AA8; continue 'dispatch;
	}
	// 82322AF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322AFC: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 82322B00: D34B0020  stfs f26, 0x20(r11)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82322B04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322B08: D3EB0024  stfs f31, 0x24(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82322B0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322B10: D34B01A0  stfs f26, 0x1a0(r11)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82322B14: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322B18: D3EB01A4  stfs f31, 0x1a4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 82322B1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322B20: D28B0080  stfs f20, 0x80(r11)
	tmp.f32 = (ctx.f[20].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82322B24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322B28: D3EB0084  stfs f31, 0x84(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82322B2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322B30: D34B00E0  stfs f26, 0xe0(r11)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82322B34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322B38: D3EB00E4  stfs f31, 0xe4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82322B3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322B40: D28B0140  stfs f20, 0x140(r11)
	tmp.f32 = (ctx.f[20].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 82322B44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322B48: D3EB0144  stfs f31, 0x144(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(324 as u32), tmp.u32 ) };
	pc = 0x82322B4C; continue 'dispatch;
            }
            0x82322B4C => {
    //   block [0x82322B4C..0x82322B5C)
	// 82322B4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322B50: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82322B54: 7D485A14  add r10, r8, r11
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82322B58: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82322B5C; continue 'dispatch;
            }
            0x82322B5C => {
    //   block [0x82322B5C..0x82322C6C)
	// 82322B5C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82322B60: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82322B64: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82322B68: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82322B6C: 4200FFF0  bdnz 0x82322b5c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82322B5C; continue 'dispatch;
	}
	// 82322B70: 39080060  addi r8, r8, 0x60
	ctx.r[8].s64 = ctx.r[8].s64 + 96;
	// 82322B74: 2B0801E0  cmplwi cr6, r8, 0x1e0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 480 as u32, &mut ctx.xer);
	// 82322B78: 4198FFD4  blt cr6, 0x82322b4c
	if ctx.cr[6].lt {
	pc = 0x82322B4C; continue 'dispatch;
	}
	// 82322B7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322B80: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322B84: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82322B88: 3B3901E0  addi r25, r25, 0x1e0
	ctx.r[25].s64 = ctx.r[25].s64 + 480;
	// 82322B8C: 3B5A0070  addi r26, r26, 0x70
	ctx.r[26].s64 = ctx.r[26].s64 + 112;
	// 82322B90: 7F1BB040  cmplw cr6, r27, r22
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82322B94: C1AB0030  lfs f13, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322B98: EC006F3A  fmadds f0, f0, f28, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64 + ctx.f[13].f64) as f32) as f64);
	// 82322B9C: D00B0030  stfs f0, 0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82322BA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322BA4: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322BA8: C1AB0098  lfs f13, 0x98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322BAC: EC006F3A  fmadds f0, f0, f28, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64 + ctx.f[13].f64) as f32) as f64);
	// 82322BB0: D00B0098  stfs f0, 0x98(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82322BB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322BB8: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322BBC: C1AB00F0  lfs f13, 0xf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322BC0: EC006F3C  fnmsubs f0, f0, f28, f13
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[28].f64 - ctx.f[13].f64) as f32) as f64);
	// 82322BC4: D00B00F0  stfs f0, 0xf0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82322BC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322BCC: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322BD0: C1AB0158  lfs f13, 0x158(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(344 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322BD4: EC006F3C  fnmsubs f0, f0, f28, f13
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[28].f64 - ctx.f[13].f64) as f32) as f64);
	// 82322BD8: D00B0158  stfs f0, 0x158(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 82322BDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322BE0: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322BE4: C1AB01B0  lfs f13, 0x1b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322BE8: EC006F3A  fmadds f0, f0, f28, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64 + ctx.f[13].f64) as f32) as f64);
	// 82322BEC: D00B01B0  stfs f0, 0x1b0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 82322BF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322BF4: D3CB0050  stfs f30, 0x50(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82322BF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322BFC: D3CB0054  stfs f30, 0x54(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82322C00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322C04: D3CB01D0  stfs f30, 0x1d0(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 82322C08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322C0C: D3CB01D4  stfs f30, 0x1d4(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 82322C10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322C14: D3EB00B0  stfs f31, 0xb0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82322C18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322C1C: D3CB00B4  stfs f30, 0xb4(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82322C20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322C24: D3CB0110  stfs f30, 0x110(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82322C28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322C2C: D3CB0114  stfs f30, 0x114(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82322C30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322C34: D3EB0170  stfs f31, 0x170(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 82322C38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322C3C: D3CB0174  stfs f30, 0x174(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 82322C40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322C44: D3EB001C  stfs f31, 0x1c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82322C48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322C4C: D3EB007C  stfs f31, 0x7c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82322C50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322C54: D3EB00DC  stfs f31, 0xdc(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82322C58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322C5C: D3EB013C  stfs f31, 0x13c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 82322C60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322C64: D3EB019C  stfs f31, 0x19c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82322C68: 4198FD00  blt cr6, 0x82322968
	if ctx.cr[6].lt {
	pc = 0x82322968; continue 'dispatch;
	}
	pc = 0x82322C6C; continue 'dispatch;
            }
            0x82322C6C => {
    //   block [0x82322C6C..0x82322CF4)
	// 82322C6C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82322C70: 2B1C0003  cmplwi cr6, r28, 3
	ctx.cr[6].compare_u32(ctx.r[28].u32, 3 as u32, &mut ctx.xer);
	// 82322C74: 4198FC98  blt cr6, 0x8232290c
	if ctx.cr[6].lt {
	pc = 0x8232290C; continue 'dispatch;
	}
	// 82322C78: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322C7C: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 82322C80: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82322C84: 930B0078  stw r24, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[24].u32 ) };
	// 82322C88: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322C8C: 914B0068  stw r10, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82322C90: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322C94: 930B007C  stw r24, 0x7c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), ctx.r[24].u32 ) };
	// 82322C98: 8170B514  lwz r11, -0x4aec(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-19180 as u32) ) } as u64;
	// 82322C9C: 811E00B0  lwz r8, 0xb0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322CA0: 814B0090  lwz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82322CA4: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82322CA8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82322CAC: 9168005C  stw r11, 0x5c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82322CB0: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322CB4: 912B0060  stw r9, 0x60(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82322CB8: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322CBC: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82322CC0: 554A072E  rlwinm r10, r10, 0, 0x1c, 0x17
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82322CC4: 914B006C  stw r10, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82322CC8: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322CCC: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82322CD0: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 82322CD4: 914B006C  stw r10, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82322CD8: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322CDC: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82322CE0: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82322CE4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82322CE8: 409A000C  bne cr6, 0x82322cf4
	if !ctx.cr[6].eq {
	pc = 0x82322CF4; continue 'dispatch;
	}
	// 82322CEC: D3EB0070  stfs f31, 0x70(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82322CF0: D3EB0074  stfs f31, 0x74(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), tmp.u32 ) };
	pc = 0x82322CF4; continue 'dispatch;
            }
            0x82322CF4 => {
    //   block [0x82322CF4..0x82322D14)
	// 82322CF4: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322CF8: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82322CFC: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82322D00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82322D04: 409A0010  bne cr6, 0x82322d14
	if !ctx.cr[6].eq {
	pc = 0x82322D14; continue 'dispatch;
	}
	// 82322D08: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 82322D0C: 394A3250  addi r10, r10, 0x3250
	ctx.r[10].s64 = ctx.r[10].s64 + 12880;
	// 82322D10: 914B0070  stw r10, 0x70(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	pc = 0x82322D14; continue 'dispatch;
            }
            0x82322D14 => {
    //   block [0x82322D14..0x82322DF0)
	// 82322D14: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322D18: 3951008F  addi r10, r17, 0x8f
	ctx.r[10].s64 = ctx.r[17].s64 + 143;
	// 82322D1C: C01E00A0  lfs f0, 0xa0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322D20: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82322D24: C1BE00A4  lfs f13, 0xa4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322D28: 3B210074  addi r25, r1, 0x74
	ctx.r[25].s64 = ctx.r[1].s64 + 116;
	// 82322D2C: D3C10078  stfs f30, 0x78(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82322D30: 3B400094  li r26, 0x94
	ctx.r[26].s64 = 148;
	// 82322D34: D2A10084  stfs f21, 0x84(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82322D38: 922B008C  stw r17, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[17].u32 ) };
	// 82322D3C: 554B0036  rlwinm r11, r10, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82322D40: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82322D44: 80FE00B0  lwz r7, 0xb0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322D48: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82322D4C: 3AEAFF6C  addi r23, r10, -0x94
	ctx.r[23].s64 = ctx.r[10].s64 + -148;
	// 82322D50: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82322D54: 91670090  stw r11, 0x90(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82322D58: 80FE00B0  lwz r7, 0xb0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322D5C: C18A9F78  lfs f12, -0x6088(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82322D60: 568A083C  slwi r10, r20, 1
	ctx.r[10].u32 = ctx.r[20].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82322D64: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82322D68: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82322D6C: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82322D70: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82322D74: C0092170  lfs f0, 0x2170(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322D78: 7D145214  add r8, r20, r10
	ctx.r[8].u64 = ctx.r[20].u64 + ctx.r[10].u64;
	// 82322D7C: 392B008F  addi r9, r11, 0x8f
	ctx.r[9].s64 = ctx.r[11].s64 + 143;
	// 82322D80: 80E7008C  lwz r7, 0x8c(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(140 as u32) ) } as u64;
	// 82322D84: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82322D88: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82322D8C: 552B0036  rlwinm r11, r9, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82322D90: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82322D94: 564A083C  slwi r10, r18, 1
	ctx.r[10].u32 = ctx.r[18].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82322D98: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82322D9C: 7D525214  add r10, r18, r10
	ctx.r[10].u64 = ctx.r[18].u64 + ctx.r[10].u64;
	// 82322DA0: 3908000F  addi r8, r8, 0xf
	ctx.r[8].s64 = ctx.r[8].s64 + 15;
	// 82322DA4: 9167006C  stw r11, 0x6c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82322DA8: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82322DAC: 550B0036  rlwinm r11, r8, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 82322DB0: 811E00B0  lwz r8, 0xb0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322DB4: 568A083C  slwi r10, r20, 1
	ctx.r[10].u32 = ctx.r[20].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82322DB8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82322DBC: 7D545214  add r10, r20, r10
	ctx.r[10].u64 = ctx.r[20].u64 + ctx.r[10].u64;
	// 82322DC0: 3929000F  addi r9, r9, 0xf
	ctx.r[9].s64 = ctx.r[9].s64 + 15;
	// 82322DC4: 81080090  lwz r8, 0x90(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(144 as u32) ) } as u64;
	// 82322DC8: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82322DCC: 9168006C  stw r11, 0x6c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82322DD0: 552B0036  rlwinm r11, r9, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82322DD4: 813E00B0  lwz r9, 0xb0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322DD8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82322DDC: 394A000F  addi r10, r10, 0xf
	ctx.r[10].s64 = ctx.r[10].s64 + 15;
	// 82322DE0: 91690094  stw r11, 0x94(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82322DE4: 554B0036  rlwinm r11, r10, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82322DE8: 815E00B0  lwz r10, 0xb0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322DEC: 916A0098  stw r11, 0x98(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	pc = 0x82322DF0; continue 'dispatch;
            }
            0x82322DF0 => {
    //   block [0x82322DF0..0x82322E50)
	// 82322DF0: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322DF4: C019FFFC  lfs f0, -4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322DF8: 7D57D02E  lwzx r10, r23, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82322DFC: C1B90000  lfs f13, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322E00: 7D2BD214  add r9, r11, r26
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82322E04: C1990004  lfs f12, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82322E08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82322E0C: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82322E10: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82322E14: 83E9FFF8  lwz r31, -8(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82322E18: 393F0050  addi r9, r31, 0x50
	ctx.r[9].s64 = ctx.r[31].s64 + 80;
	// 82322E1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82322E20: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82322E24: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82322E28: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82322E2C: D19F0068  stfs f12, 0x68(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82322E30: E95E0090  ld r10, 0x90(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) };
	// 82322E34: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82322E38: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82322E3C: E95E0098  ld r10, 0x98(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) };
	// 82322E40: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82322E44: 419A005C  beq cr6, 0x82322ea0
	if ctx.cr[6].eq {
	pc = 0x82322EA0; continue 'dispatch;
	}
	// 82322E48: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 82322E4C: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	pc = 0x82322E50; continue 'dispatch;
            }
            0x82322E50 => {
    //   block [0x82322E50..0x82322EA0)
	// 82322E50: 482103C1  bl 0x82533210
	ctx.lr = 0x82322E54;
	sub_82533210(ctx, base);
	// 82322E54: 546A047E  clrlwi r10, r3, 0x11
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82322E58: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82322E5C: C1BF0068  lfs f13, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322E60: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82322E64: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82322E68: 3B9C0018  addi r28, r28, 0x18
	ctx.r[28].s64 = ctx.r[28].s64 + 24;
	// 82322E6C: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82322E70: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82322E74: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82322E78: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82322E7C: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82322E80: EC006CFA  fmadds f0, f0, f19, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[19].f64 + ctx.f[13].f64) as f32) as f64);
	// 82322E84: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82322E88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82322E8C: 7F1B592E  stwx r24, r27, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32), ctx.r[24].u32) };
	// 82322E90: 3B7B0060  addi r27, r27, 0x60
	ctx.r[27].s64 = ctx.r[27].s64 + 96;
	// 82322E94: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82322E98: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82322E9C: 4198FFB4  blt cr6, 0x82322e50
	if ctx.cr[6].lt {
	pc = 0x82322E50; continue 'dispatch;
	}
	pc = 0x82322EA0; continue 'dispatch;
            }
            0x82322EA0 => {
    //   block [0x82322EA0..0x82322EB0)
	// 82322EA0: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82322EA4: 3B39000C  addi r25, r25, 0xc
	ctx.r[25].s64 = ctx.r[25].s64 + 12;
	// 82322EA8: 2B1A009C  cmplwi cr6, r26, 0x9c
	ctx.cr[6].compare_u32(ctx.r[26].u32, 156 as u32, &mut ctx.xer);
	// 82322EAC: 4198FF44  blt cr6, 0x82322df0
	if ctx.cr[6].lt {
	pc = 0x82322DF0; continue 'dispatch;
	}
	pc = 0x82322EB0; continue 'dispatch;
            }
            0x82322EB0 => {
    //   block [0x82322EB0..0x82322EC0)
	// 82322EB0: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82322EB4: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 82322EB8: 48213151  bl 0x82536008
	ctx.lr = 0x82322EBC;
	sub_82535FFC(ctx, base);
	// 82322EBC: 4821221C  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82322EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82322EC0 size=316
    let mut pc: u32 = 0x82322EC0;
    'dispatch: loop {
        match pc {
            0x82322EC0 => {
    //   block [0x82322EC0..0x82322F28)
	// 82322EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82322EC4: 482121F9  bl 0x825350bc
	ctx.lr = 0x82322EC8;
	sub_82535080(ctx, base);
	// 82322EC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82322ECC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82322ED0: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82322ED4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82322ED8: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82322EDC: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 82322EE0: C1BE00B4  lfs f13, 0xb4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322EE4: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322EE8: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82322EEC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82322EF0: D01E00B4  stfs f0, 0xb4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82322EF4: C1ABD5B0  lfs f13, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322EF8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82322EFC: 4099002C  ble cr6, 0x82322f28
	if !ctx.cr[6].gt {
	pc = 0x82322F28; continue 'dispatch;
	}
	// 82322F00: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82322F04: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82322F08: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82322F0C: 409A00E8  bne cr6, 0x82322ff4
	if !ctx.cr[6].eq {
	pc = 0x82322FF4; continue 'dispatch;
	}
	// 82322F10: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82322F14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82322F18: 997E0019  stb r11, 0x19(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82322F1C: 995E0025  stb r10, 0x25(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 82322F20: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82322F24: 482121E8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82322F28 => {
    //   block [0x82322F28..0x82322F5C)
	// 82322F28: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 82322F2C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82322F30: 38E00050  li r7, 0x50
	ctx.r[7].s64 = 80;
	// 82322F34: 38ABFFB0  addi r5, r11, -0x50
	ctx.r[5].s64 = ctx.r[11].s64 + -80;
	// 82322F38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82322F3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82322F40: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82322F44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82322F48: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 82322F4C: C04B1FF8  lfs f2, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82322F50: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82322F54: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 82322F58: 83EAB514  lwz r31, -0x4aec(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19180 as u32) ) } as u64;
	pc = 0x82322F5C; continue 'dispatch;
            }
            0x82322F5C => {
    //   block [0x82322F5C..0x82322FA0)
	// 82322F5C: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322F60: C01F009C  lfs f0, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322F64: 7DA75C2E  lfsx f13, r7, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82322F68: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82322F6C: 7C075D2E  stfsx f0, r7, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82322F70: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322F74: 7C075C2E  lfsx f0, r7, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82322F78: FF001000  fcmpu cr6, f0, f2
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[2].f64);
	// 82322F7C: 4199004C  bgt cr6, 0x82322fc8
	if ctx.cr[6].gt {
	pc = 0x82322FC8; continue 'dispatch;
	}
	// 82322F80: 7D275A14  add r9, r7, r11
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82322F84: 7D45382E  lwzx r10, r5, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82322F88: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82322F8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82322F90: 8089FFF4  lwz r4, -0xc(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82322F94: 806BFFE8  lwz r3, -0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 82322F98: 419A0030  beq cr6, 0x82322fc8
	if ctx.cr[6].eq {
	pc = 0x82322FC8; continue 'dispatch;
	}
	// 82322F9C: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	pc = 0x82322FA0; continue 'dispatch;
            }
            0x82322FA0 => {
    //   block [0x82322FA0..0x82322FB4)
	// 82322FA0: 93A30064  stw r29, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82322FA4: 8164004C  lwz r11, 0x4c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82322FA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82322FAC: 419A0008  beq cr6, 0x82322fb4
	if ctx.cr[6].eq {
	pc = 0x82322FB4; continue 'dispatch;
	}
	// 82322FB0: 48000141  bl 0x823230f0
	ctx.lr = 0x82322FB4;
	sub_823230F0(ctx, base);
	pc = 0x82322FB4; continue 'dispatch;
            }
            0x82322FB4 => {
    //   block [0x82322FB4..0x82322FC8)
	// 82322FB4: 38C6FFFF  addi r6, r6, -1
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	// 82322FB8: 38630070  addi r3, r3, 0x70
	ctx.r[3].s64 = ctx.r[3].s64 + 112;
	// 82322FBC: 388401E0  addi r4, r4, 0x1e0
	ctx.r[4].s64 = ctx.r[4].s64 + 480;
	// 82322FC0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82322FC4: 409AFFDC  bne cr6, 0x82322fa0
	if !ctx.cr[6].eq {
	pc = 0x82322FA0; continue 'dispatch;
	}
	pc = 0x82322FC8; continue 'dispatch;
            }
            0x82322FC8 => {
    //   block [0x82322FC8..0x82322FD8)
	// 82322FC8: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82322FCC: 2B07005C  cmplwi cr6, r7, 0x5c
	ctx.cr[6].compare_u32(ctx.r[7].u32, 92 as u32, &mut ctx.xer);
	// 82322FD0: 4198FF8C  blt cr6, 0x82322f5c
	if ctx.cr[6].lt {
	pc = 0x82322F5C; continue 'dispatch;
	}
	// 82322FD4: 3BE0008C  li r31, 0x8c
	ctx.r[31].s64 = 140;
	pc = 0x82322FD8; continue 'dispatch;
            }
            0x82322FD8 => {
    //   block [0x82322FD8..0x82322FF4)
	// 82322FD8: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82322FDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82322FE0: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82322FE4: 4800036D  bl 0x82323350
	ctx.lr = 0x82322FE8;
	sub_82323350(ctx, base);
	// 82322FE8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82322FEC: 2B1F0094  cmplwi cr6, r31, 0x94
	ctx.cr[6].compare_u32(ctx.r[31].u32, 148 as u32, &mut ctx.xer);
	// 82322FF0: 4198FFE8  blt cr6, 0x82322fd8
	if ctx.cr[6].lt {
	pc = 0x82322FD8; continue 'dispatch;
	}
	pc = 0x82322FF4; continue 'dispatch;
            }
            0x82322FF4 => {
    //   block [0x82322FF4..0x82322FFC)
	// 82322FF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82322FF8: 48212114  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82323000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82323000 size=200
    let mut pc: u32 = 0x82323000;
    'dispatch: loop {
        match pc {
            0x82323000 => {
    //   block [0x82323000..0x82323030)
	// 82323000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82323004: 482120B1  bl 0x825350b4
	ctx.lr = 0x82323008;
	sub_82535080(ctx, base);
	// 82323008: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232300C: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 82323010: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82323014: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82323018: 3BA00038  li r29, 0x38
	ctx.r[29].s64 = 56;
	// 8232301C: 3B6BFFC8  addi r27, r11, -0x38
	ctx.r[27].s64 = ctx.r[11].s64 + -56;
	// 82323020: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82323024: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82323028: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 8232302C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	pc = 0x82323030; continue 'dispatch;
            }
            0x82323030 => {
    //   block [0x82323030..0x82323044)
	// 82323030: 7D7BE82E  lwzx r11, r27, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82323034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82323038: 419A004C  beq cr6, 0x82323084
	if ctx.cr[6].eq {
	pc = 0x82323084; continue 'dispatch;
	}
	// 8232303C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82323040: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	pc = 0x82323044; continue 'dispatch;
            }
            0x82323044 => {
    //   block [0x82323044..0x82323074)
	// 82323044: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82323048: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232304C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82323050: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82323054: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82323058: 419A001C  beq cr6, 0x82323074
	if ctx.cr[6].eq {
	pc = 0x82323074; continue 'dispatch;
	}
	// 8232305C: 809E00B0  lwz r4, 0xb0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82323060: 38EB0010  addi r7, r11, 0x10
	ctx.r[7].s64 = ctx.r[11].s64 + 16;
	// 82323064: 3860000A  li r3, 0xa
	ctx.r[3].s64 = 10;
	// 82323068: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232306C: 38A40008  addi r5, r4, 8
	ctx.r[5].s64 = ctx.r[4].s64 + 8;
	// 82323070: 48049F09  bl 0x8236cf78
	ctx.lr = 0x82323074;
	sub_8236CF78(ctx, base);
	pc = 0x82323074; continue 'dispatch;
            }
            0x82323074 => {
    //   block [0x82323074..0x82323084)
	// 82323074: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 82323078: 3BFF0070  addi r31, r31, 0x70
	ctx.r[31].s64 = ctx.r[31].s64 + 112;
	// 8232307C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82323080: 409AFFC4  bne cr6, 0x82323044
	if !ctx.cr[6].eq {
	pc = 0x82323044; continue 'dispatch;
	}
	pc = 0x82323084; continue 'dispatch;
            }
            0x82323084 => {
    //   block [0x82323084..0x82323094)
	// 82323084: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82323088: 2B1D0044  cmplwi cr6, r29, 0x44
	ctx.cr[6].compare_u32(ctx.r[29].u32, 68 as u32, &mut ctx.xer);
	// 8232308C: 4198FFA4  blt cr6, 0x82323030
	if ctx.cr[6].lt {
	pc = 0x82323030; continue 'dispatch;
	}
	// 82323090: 3BE0008C  li r31, 0x8c
	ctx.r[31].s64 = 140;
	pc = 0x82323094; continue 'dispatch;
            }
            0x82323094 => {
    //   block [0x82323094..0x823230C8)
	// 82323094: 80BE00B0  lwz r5, 0xb0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 82323098: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8232309C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823230A0: 38C5005C  addi r6, r5, 0x5c
	ctx.r[6].s64 = ctx.r[5].s64 + 92;
	// 823230A4: 7D7F282E  lwzx r11, r31, r5
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 823230A8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823230AC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823230B0: 48049501  bl 0x8236c5b0
	ctx.lr = 0x823230B4;
	sub_8236C5B0(ctx, base);
	// 823230B4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823230B8: 2B1F0094  cmplwi cr6, r31, 0x94
	ctx.cr[6].compare_u32(ctx.r[31].u32, 148 as u32, &mut ctx.xer);
	// 823230BC: 4198FFD8  blt cr6, 0x82323094
	if ctx.cr[6].lt {
	pc = 0x82323094; continue 'dispatch;
	}
	// 823230C0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823230C4: 48212040  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823230C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823230C8 size=32
    let mut pc: u32 = 0x823230C8;
    'dispatch: loop {
        match pc {
            0x823230C8 => {
    //   block [0x823230C8..0x823230E8)
	// 823230C8: 39630080  addi r11, r3, 0x80
	ctx.r[11].s64 = ctx.r[3].s64 + 128;
	// 823230CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823230D0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823230D4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823230D8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823230DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823230E0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 823230E4: 4BDF9F74  b 0x8211d058
	sub_8211D058(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823230F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823230F0 size=604
    let mut pc: u32 = 0x823230F0;
    'dispatch: loop {
        match pc {
            0x823230F0 => {
    //   block [0x823230F0..0x82323118)
	// 823230F0: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 823230F4: C0030058  lfs f0, 0x58(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823230F8: C1830060  lfs f12, 0x60(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823230FC: 39240034  addi r9, r4, 0x34
	ctx.r[9].s64 = ctx.r[4].s64 + 52;
	// 82323100: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82323104: 816BB514  lwz r11, -0x4aec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19180 as u32) ) } as u64;
	// 82323108: C1AB009C  lfs f13, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232310C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82323110: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82323114: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	pc = 0x82323118; continue 'dispatch;
            }
            0x82323118 => {
    //   block [0x82323118..0x82323198)
	// 82323118: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232311C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82323120: C1830058  lfs f12, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82323124: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82323128: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8232312C: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 82323130: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82323134: 409AFFE4  bne cr6, 0x82323118
	if !ctx.cr[6].eq {
	pc = 0x82323118; continue 'dispatch;
	}
	// 82323138: C003005C  lfs f0, 0x5c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232313C: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82323140: C1840030  lfs f12, 0x30(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82323144: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82323148: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 8232314C: D0040030  stfs f0, 0x30(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82323150: C003005C  lfs f0, 0x5c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323154: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82323158: C1640098  lfs f11, 0x98(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(152 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232315C: EC005B7A  fmadds f0, f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82323160: D0040098  stfs f0, 0x98(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82323164: C003005C  lfs f0, 0x5c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323168: C14400F0  lfs f10, 0xf0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(240 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8232316C: EC00537C  fnmsubs f0, f0, f13, f10
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82323170: D00400F0  stfs f0, 0xf0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82323174: C003005C  lfs f0, 0x5c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323178: C1240158  lfs f9, 0x158(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(344 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8232317C: EC004B7C  fnmsubs f0, f0, f13, f9
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82323180: D0040158  stfs f0, 0x158(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 82323184: C10401B0  lfs f8, 0x1b0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(432 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82323188: C003005C  lfs f0, 0x5c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232318C: EC00437A  fmadds f0, f0, f13, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[8].f64) as f32) as f64);
	// 82323190: D00401B0  stfs f0, 0x1b0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 82323194: C008BFFC  lfs f0, -0x4004(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82323198; continue 'dispatch;
            }
            0x82323198 => {
    //   block [0x82323198..0x8232324C)
	// 82323198: C18BFFFC  lfs f12, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232319C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823231A0: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823231A4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823231A8: C14B0004  lfs f10, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823231AC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 823231B0: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 823231B4: D18BFFCC  stfs f12, -0x34(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-52 as u32), tmp.u32 ) };
	// 823231B8: D16BFFD0  stfs f11, -0x30(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 823231BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823231C0: D14BFFD4  stfs f10, -0x2c(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-44 as u32), tmp.u32 ) };
	// 823231C4: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 823231C8: 409AFFD0  bne cr6, 0x82323198
	if !ctx.cr[6].eq {
	pc = 0x82323198; continue 'dispatch;
	}
	// 823231CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823231D0: C1830050  lfs f12, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823231D4: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823231D8: C1440068  lfs f10, 0x68(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(104 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823231DC: C12400C0  lfs f9, 0xc0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(192 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823231E0: C1040128  lfs f8, 0x128(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(296 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823231E4: C00B20A0  lfs f0, 0x20a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823231E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823231EC: ED8C583A  fmadds f12, f12, f0, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 823231F0: D1840000  stfs f12, 0(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823231F4: C1830050  lfs f12, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823231F8: ED8C503A  fmadds f12, f12, f0, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 823231FC: D1840068  stfs f12, 0x68(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82323200: C1830050  lfs f12, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82323204: ED8C483C  fnmsubs f12, f12, f0, f9
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 82323208: D18400C0  stfs f12, 0xc0(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8232320C: C1830050  lfs f12, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82323210: ED8C403C  fnmsubs f12, f12, f0, f8
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 82323214: D1840128  stfs f12, 0x128(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82323218: C1830050  lfs f12, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232321C: C0E40180  lfs f7, 0x180(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(384 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82323220: EC0C383A  fmadds f0, f12, f0, f7
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 82323224: D0040180  stfs f0, 0x180(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82323228: C0030058  lfs f0, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232322C: C18B1FF8  lfs f12, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82323230: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82323234: 40980034  bge cr6, 0x82323268
	if !ctx.cr[6].lt {
	pc = 0x82323268; continue 'dispatch;
	}
	// 82323238: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232323C: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82323240: C00B209C  lfs f0, 0x209c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323244: 3964004C  addi r11, r4, 0x4c
	ctx.r[11].s64 = ctx.r[4].s64 + 76;
	// 82323248: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x8232324C; continue 'dispatch;
            }
            0x8232324C => {
    //   block [0x8232324C..0x82323268)
	// 8232324C: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82323250: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82323254: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82323258: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8232325C: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 82323260: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82323264: 409AFFE8  bne cr6, 0x8232324c
	if !ctx.cr[6].eq {
	pc = 0x8232324C; continue 'dispatch;
	}
	pc = 0x82323268; continue 'dispatch;
            }
            0x82323268 => {
    //   block [0x82323268..0x8232327C)
	// 82323268: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232326C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82323270: 409800A4  bge cr6, 0x82323314
	if !ctx.cr[6].lt {
	pc = 0x82323314; continue 'dispatch;
	}
	// 82323274: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82323278: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	pc = 0x8232327C; continue 'dispatch;
            }
            0x8232327C => {
    //   block [0x8232327C..0x82323314)
	// 8232327C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82323280: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82323284: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 82323288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232328C: 409AFFF0  bne cr6, 0x8232327c
	if !ctx.cr[6].eq {
	pc = 0x8232327C; continue 'dispatch;
	}
	// 82323290: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82323294: C164004C  lfs f11, 0x4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82323298: C144007C  lfs f10, 0x7c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(124 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8232329C: C12400AC  lfs f9, 0xac(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(172 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823232A0: C10400DC  lfs f8, 0xdc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(220 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823232A4: C0E4010C  lfs f7, 0x10c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(268 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823232A8: C00B2098  lfs f0, 0x2098(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823232AC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823232B0: C1A4001C  lfs f13, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823232B4: C0C4013C  lfs f6, 0x13c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(316 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 823232B8: C0A4016C  lfs f5, 0x16c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(364 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 823232BC: C084019C  lfs f4, 0x19c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(412 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823232C0: C06401CC  lfs f3, 0x1cc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(460 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823232C4: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823232C8: D1A4001C  stfs f13, 0x1c(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823232CC: EDAB0028  fsubs f13, f11, f0
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 823232D0: D1A4004C  stfs f13, 0x4c(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 823232D4: EDAA0028  fsubs f13, f10, f0
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 823232D8: D1A4007C  stfs f13, 0x7c(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 823232DC: EDA90028  fsubs f13, f9, f0
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 823232E0: D1A400AC  stfs f13, 0xac(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 823232E4: EDA80028  fsubs f13, f8, f0
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 823232E8: D1A400DC  stfs f13, 0xdc(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 823232EC: EDA70028  fsubs f13, f7, f0
	ctx.f[13].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 823232F0: D1A4010C  stfs f13, 0x10c(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 823232F4: EDA60028  fsubs f13, f6, f0
	ctx.f[13].f64 = (((ctx.f[6].f64 - ctx.f[0].f64) as f32) as f64);
	// 823232F8: D1A4013C  stfs f13, 0x13c(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 823232FC: EDA50028  fsubs f13, f5, f0
	ctx.f[13].f64 = (((ctx.f[5].f64 - ctx.f[0].f64) as f32) as f64);
	// 82323300: D1A4016C  stfs f13, 0x16c(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 82323304: EDA40028  fsubs f13, f4, f0
	ctx.f[13].f64 = (((ctx.f[4].f64 - ctx.f[0].f64) as f32) as f64);
	// 82323308: D1A4019C  stfs f13, 0x19c(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 8232330C: EC030028  fsubs f0, f3, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 - ctx.f[0].f64) as f32) as f64);
	// 82323310: D00401CC  stfs f0, 0x1cc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(460 as u32), tmp.u32 ) };
	pc = 0x82323314; continue 'dispatch;
            }
            0x82323314 => {
    //   block [0x82323314..0x82323330)
	// 82323314: C004004C  lfs f0, 0x4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323318: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8232331C: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82323320: 3964001C  addi r11, r4, 0x1c
	ctx.r[11].s64 = ctx.r[4].s64 + 28;
	// 82323324: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 82323328: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8232332C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82323330; continue 'dispatch;
            }
            0x82323330 => {
    //   block [0x82323330..0x8232334C)
	// 82323330: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82323334: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82323338: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8232333C: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 82323340: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82323344: 409AFFEC  bne cr6, 0x82323330
	if !ctx.cr[6].eq {
	pc = 0x82323330; continue 'dispatch;
	}
	// 82323348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82323350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82323350 size=1556
    let mut pc: u32 = 0x82323350;
    'dispatch: loop {
        match pc {
            0x82323350 => {
    //   block [0x82323350..0x8232348C)
	// 82323350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82323354: 48211D2D  bl 0x82535080
	ctx.lr = 0x82323358;
	sub_82535080(ctx, base);
	// 82323358: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 8232335C: 48212C55  bl 0x82535fb0
	ctx.lr = 0x82323360;
	sub_82535FB0(ctx, base);
	// 82323360: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82323364: 3DE082C0  lis r15, -0x7d40
	ctx.r[15].s64 = -2101346304;
	// 82323368: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8232336C: 816FB9B0  lwz r11, -0x4650(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-18000 as u32) ) } as u64;
	// 82323370: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82323374: C1AB0060  lfs f13, 0x60(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82323378: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232337C: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323380: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82323384: 4BE2FF35  bl 0x821532b8
	ctx.lr = 0x82323388;
	sub_821532B8(ctx, base);
	// 82323388: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 8232338C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82323390: 3A000000  li r16, 0
	ctx.r[16].s64 = 0;
	// 82323394: D021005C  stfs f1, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82323398: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232339C: 816BB514  lwz r11, -0x4aec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19180 as u32) ) } as u64;
	// 823233A0: 92010050  stw r16, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[16].u32 ) };
	// 823233A4: C1EB009C  lfs f15, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[15].f64 = (tmp.f32 as f64);
	// 823233A8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 823233AC: C3ABBA38  lfs f29, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 823233B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823233B4: D3A10080  stfs f29, 0x80(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 823233B8: D3A10084  stfs f29, 0x84(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 823233BC: D3A10088  stfs f29, 0x88(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 823233C0: C2EBBFFC  lfs f23, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 823233C4: D2E1008C  stfs f23, 0x8c(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 823233C8: 40990580  ble cr6, 0x82323948
	if !ctx.cr[6].gt {
	pc = 0x82323948; continue 'dispatch;
	}
	// 823233CC: 3EA0820D  lis r21, -0x7df3
	ctx.r[21].s64 = -2113077248;
	// 823233D0: 3E80820D  lis r20, -0x7df3
	ctx.r[20].s64 = -2113077248;
	// 823233D4: 3E40820C  lis r18, -0x7df4
	ctx.r[18].s64 = -2113142784;
	// 823233D8: 3E608286  lis r19, -0x7d7a
	ctx.r[19].s64 = -2105147392;
	// 823233DC: 3EE0820D  lis r23, -0x7df3
	ctx.r[23].s64 = -2113077248;
	// 823233E0: C01526A0  lfs f0, 0x26a0(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(9888 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823233E4: 3EC0820D  lis r22, -0x7df3
	ctx.r[22].s64 = -2113077248;
	// 823233E8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823233EC: 3F00820D  lis r24, -0x7df3
	ctx.r[24].s64 = -2113077248;
	// 823233F0: 3F20820D  lis r25, -0x7df3
	ctx.r[25].s64 = -2113077248;
	// 823233F4: C0142144  lfs f0, 0x2144(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823233F8: 3F408286  lis r26, -0x7d7a
	ctx.r[26].s64 = -2105147392;
	// 823233FC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82323400: 3F60820D  lis r27, -0x7df3
	ctx.r[27].s64 = -2113077248;
	// 82323404: C012D218  lfs f0, -0x2de8(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323408: 3F80820D  lis r28, -0x7df3
	ctx.r[28].s64 = -2113077248;
	// 8232340C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82323410: 3C60820D  lis r3, -0x7df3
	ctx.r[3].s64 = -2113077248;
	// 82323414: C357269C  lfs f26, 0x269c(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(9884 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82323418: 3C80820D  lis r4, -0x7df3
	ctx.r[4].s64 = -2113077248;
	// 8232341C: C013D468  lfs f0, -0x2b98(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323420: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 82323424: C25AD5B0  lfs f18, -0x2a50(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 82323428: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 8232342C: C31B2068  lfs f24, 0x2068(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8296 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82323430: 3CE08288  lis r7, -0x7d78
	ctx.r[7].s64 = -2105016320;
	// 82323434: C37C2198  lfs f27, 0x2198(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8600 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82323438: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8232343C: C263228C  lfs f19, 0x228c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8844 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 82323440: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82323444: C2842694  lfs f20, 0x2694(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(9876 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 82323448: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232344C: C2A52090  lfs f21, 0x2090(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8336 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 82323450: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 82323454: C2C621B8  lfs f22, 0x21b8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8632 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82323458: C387D4DC  lfs f28, -0x2b24(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8232345C: 7E1E8378  mr r30, r16
	ctx.r[30].u64 = ctx.r[16].u64;
	// 82323460: C328D6C8  lfs f25, -0x2938(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82323464: 7E1D8378  mr r29, r16
	ctx.r[29].u64 = ctx.r[16].u64;
	// 82323468: C3C9206C  lfs f30, 0x206c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8300 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8232346C: 39CB0C40  addi r14, r11, 0xc40
	ctx.r[14].s64 = ctx.r[11].s64 + 3136;
	// 82323470: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82323474: 3A200001  li r17, 1
	ctx.r[17].s64 = 1;
	// 82323478: C2392224  lfs f17, 0x2224(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8740 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 8232347C: C2182698  lfs f16, 0x2698(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(9880 as u32) ) };
	ctx.f[16].f64 = (tmp.f32 as f64);
	// 82323480: C1D62054  lfs f14, 0x2054(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8276 as u32) ) };
	ctx.f[14].f64 = (tmp.f32 as f64);
	// 82323484: D3410068  stfs f26, 0x68(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82323488: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	pc = 0x8232348C; continue 'dispatch;
            }
            0x8232348C => {
    //   block [0x8232348C..0x8232378C)
	// 8232348C: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82323490: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82323494: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323498: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8232349C: 409902F0  ble cr6, 0x8232378c
	if !ctx.cr[6].gt {
	pc = 0x8232378C; continue 'dispatch;
	}
	// 823234A0: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 823234A4: C00E06A4  lfs f0, 0x6a4(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(1700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823234A8: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823234AC: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 823234B0: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 823234B4: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 823234B8: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823234BC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 823234C0: 41990468  bgt cr6, 0x82323928
	if ctx.cr[6].gt {
	pc = 0x82323928; continue 'dispatch;
	}
	// 823234C4: 395F0050  addi r10, r31, 0x50
	ctx.r[10].s64 = ctx.r[31].s64 + 80;
	// 823234C8: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 823234CC: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 823234D0: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 823234D4: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 823234D8: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 823234DC: 4820FD35  bl 0x82533210
	ctx.lr = 0x823234E0;
	sub_82533210(ctx, base);
	// 823234E0: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 823234E4: C1A10070  lfs f13, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823234E8: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 823234EC: C80100C0  lfd f0, 0xc0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 823234F0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823234F4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823234F8: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 823234FC: EC00E678  fmsubs f0, f0, f25, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[25].f64 - ctx.f[28].f64) as f32) as f64);
	// 82323500: EF40682A  fadds f26, f0, f13
	ctx.f[26].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82323504: D3410070  stfs f26, 0x70(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82323508: 4820FD09  bl 0x82533210
	ctx.lr = 0x8232350C;
	sub_82533210(ctx, base);
	// 8232350C: 5469047E  clrlwi r9, r3, 0x11
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82323510: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82323514: C0010074  lfs f0, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323518: C1A1007C  lfs f13, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232351C: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82323520: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82323524: F9210090  std r9, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u64 ) };
	// 82323528: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8232352C: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82323530: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82323534: D1AB001C  stfs f13, 0x1c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82323538: C1A10078  lfs f13, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232353C: D34B0010  stfs f26, 0x10(r11)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82323540: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82323544: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82323548: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8232354C: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82323550: EC00E678  fmsubs f0, f0, f25, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[25].f64 - ctx.f[28].f64) as f32) as f64);
	// 82323554: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82323558: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8232355C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82323560: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82323564: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82323568: D38B0040  stfs f28, 0x40(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8232356C: D38B0044  stfs f28, 0x44(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82323570: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82323574: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82323578: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8232357C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82323580: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82323584: D3AB0048  stfs f29, 0x48(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82323588: D3AB004C  stfs f29, 0x4c(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 8232358C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82323590: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82323594: D3EB0008  stfs f31, 8(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82323598: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232359C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823235A0: 920B0050  stw r16, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[16].u32 ) };
	// 823235A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823235A8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823235AC: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 823235B0: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 823235B4: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 823235B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823235BC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823235C0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823235C4: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 823235C8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823235CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823235D0: 7E2BF12E  stwx r17, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[17].u32) };
	// 823235D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823235D8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823235DC: D3EB0020  stfs f31, 0x20(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 823235E0: D3EB0024  stfs f31, 0x24(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 823235E4: D3EB0028  stfs f31, 0x28(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 823235E8: D3AB002C  stfs f29, 0x2c(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 823235EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823235F0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823235F4: D3EB0008  stfs f31, 8(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823235F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823235FC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82323600: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82323604: 554A0102  rlwinm r10, r10, 0, 4, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82323608: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8232360C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82323610: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82323614: D3EB0050  stfs f31, 0x50(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82323618: D3EB0054  stfs f31, 0x54(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8232361C: 4820FBF5  bl 0x82533210
	ctx.lr = 0x82323620;
	sub_82533210(ctx, base);
	// 82323620: 546A047E  clrlwi r10, r3, 0x11
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82323624: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82323628: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 8232362C: F94100D0  std r10, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[10].u64 ) };
	// 82323630: C80100D0  lfd f0, 0xd0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 82323634: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82323638: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8232363C: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82323640: EC00ADBA  fmadds f0, f0, f22, f21
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[22].f64 + ctx.f[21].f64) as f32) as f64);
	// 82323644: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82323648: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 8232364C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82323650: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82323654: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82323658: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232365C: D00B0040  stfs f0, 0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82323660: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82323664: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82323668: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 8232366C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82323670: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323674: D00B0044  stfs f0, 0x44(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82323678: 4820FB99  bl 0x82533210
	ctx.lr = 0x8232367C;
	sub_82533210(ctx, base);
	// 8232367C: 546A047E  clrlwi r10, r3, 0x11
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82323680: C1BF0064  lfs f13, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82323684: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82323688: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 8232368C: F94100B8  std r10, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[10].u64 ) };
	// 82323690: C80100B8  lfd f0, 0xb8(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 82323694: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82323698: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8232369C: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 823236A0: EC009D3A  fmadds f0, f0, f20, f19
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[20].f64 + ctx.f[19].f64) as f32) as f64);
	// 823236A4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823236A8: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 823236AC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823236B0: 4820FB61  bl 0x82533210
	ctx.lr = 0x823236B4;
	sub_82533210(ctx, base);
	// 823236B4: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 823236B8: F96100A8  std r11, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 823236BC: C80100A8  lfd f0, 0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 823236C0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823236C4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823236C8: EF4007B2  fmuls f26, f0, f30
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 823236CC: 4820FB45  bl 0x82533210
	ctx.lr = 0x823236D0;
	sub_82533210(ctx, base);
	// 823236D0: 546A047E  clrlwi r10, r3, 0x11
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 823236D4: ED9AEE38  fmsubs f12, f26, f24, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[26].f64 * ctx.f[24].f64 - ctx.f[29].f64) as f32) as f64);
	// 823236D8: C1BF0060  lfs f13, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823236DC: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 823236E0: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 823236E4: F94100C8  std r10, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[10].u64 ) };
	// 823236E8: C80100C8  lfd f0, 0xc8(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 823236EC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823236F0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823236F4: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 823236F8: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 823236FC: EC0005F2  fmuls f0, f0, f23
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[23].f64) as f32) as f64);
	// 82323700: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82323704: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82323708: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 8232370C: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82323710: 4820FB01  bl 0x82533210
	ctx.lr = 0x82323714;
	sub_82533210(ctx, base);
	// 82323714: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82323718: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 8232371C: C8010098  lfd f0, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82323720: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82323724: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82323728: EF4007B2  fmuls f26, f0, f30
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8232372C: 4820FAE5  bl 0x82533210
	ctx.lr = 0x82323730;
	sub_82533210(ctx, base);
	// 82323730: 546A047E  clrlwi r10, r3, 0x11
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82323734: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82323738: C1BF0060  lfs f13, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232373C: ED9AEE38  fmsubs f12, f26, f24, f29
	ctx.f[12].f64 = (((ctx.f[26].f64 * ctx.f[24].f64 - ctx.f[29].f64) as f32) as f64);
	// 82323740: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82323744: F94100A0  std r10, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u64 ) };
	// 82323748: C80100A0  lfd f0, 0xa0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 8232374C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82323750: C3410068  lfs f26, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82323754: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82323758: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8232375C: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82323760: EC0005F2  fmuls f0, f0, f23
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[23].f64) as f32) as f64);
	// 82323764: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82323768: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232376C: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82323770: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82323774: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82323778: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 8232377C: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323780: EC008CBC  fnmsubs f0, f0, f18, f17
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[18].f64 - ctx.f[17].f64) as f32) as f64);
	// 82323784: EC000432  fmuls f0, f0, f16
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[16].f64) as f32) as f64);
	// 82323788: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x8232378C; continue 'dispatch;
            }
            0x8232378C => {
    //   block [0x8232378C..0x823237EC)
	// 8232378C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82323790: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82323794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82323798: 419A0190  beq cr6, 0x82323928
	if ctx.cr[6].eq {
	pc = 0x82323928; continue 'dispatch;
	}
	// 8232379C: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 823237A0: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 823237A4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823237A8: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823237AC: EC0F037A  fmadds f0, f15, f13, f0
	ctx.f[0].f64 = (((ctx.f[15].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 823237B0: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823237B4: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 823237B8: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 823237BC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823237C0: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823237C4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823237C8: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823237CC: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 823237D0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823237D4: 40980018  bge cr6, 0x823237ec
	if !ctx.cr[6].lt {
	pc = 0x823237EC; continue 'dispatch;
	}
	// 823237D8: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823237DC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823237E0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823237E4: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 823237E8: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x823237EC; continue 'dispatch;
            }
            0x823237EC => {
    //   block [0x823237EC..0x82323808)
	// 823237EC: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 823237F0: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 823237F4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823237F8: EDA005F2  fmuls f13, f0, f23
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[23].f64) as f32) as f64);
	// 823237FC: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 82323800: 40980008  bge cr6, 0x82323808
	if !ctx.cr[6].lt {
	pc = 0x82323808; continue 'dispatch;
	}
	// 82323804: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82323808; continue 'dispatch;
            }
            0x82323808 => {
    //   block [0x82323808..0x823238F8)
	// 82323808: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232380C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82323810: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82323814: C181005C  lfs f12, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82323818: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8232381C: EDAD03B2  fmuls f13, f13, f14
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[14].f64) as f32) as f64);
	// 82323820: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82323824: D00B0044  stfs f0, 0x44(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82323828: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232382C: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82323830: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82323834: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82323838: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 8232383C: C1AB0044  lfs f13, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82323840: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82323844: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323848: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232384C: EC006B38  fmsubs f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82323850: D00B0040  stfs f0, 0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82323854: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82323858: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 8232385C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82323860: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82323864: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82323868: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232386C: EC006BFA  fmadds f0, f0, f15, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[15].f64 + ctx.f[13].f64) as f32) as f64);
	// 82323870: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82323874: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82323878: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 8232387C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82323880: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82323884: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82323888: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232388C: EC006BFA  fmadds f0, f0, f15, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[15].f64 + ctx.f[13].f64) as f32) as f64);
	// 82323890: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82323894: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82323898: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232389C: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 823238A0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823238A4: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823238A8: 814FB9B0  lwz r10, -0x4650(r15)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-18000 as u32) ) } as u64;
	// 823238AC: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823238B0: EC006BFA  fmadds f0, f0, f15, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[15].f64 + ctx.f[13].f64) as f32) as f64);
	// 823238B4: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 823238B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823238BC: 814A0028  lwz r10, 0x28(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 823238C0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823238C4: C00A0068  lfs f0, 0x68(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823238C8: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823238CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823238D0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823238D4: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823238D8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 823238DC: 419A0024  beq cr6, 0x82323900
	if ctx.cr[6].eq {
	pc = 0x82323900; continue 'dispatch;
	}
	// 823238E0: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823238E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823238E8: 41980010  blt cr6, 0x823238f8
	if ctx.cr[6].lt {
	pc = 0x823238F8; continue 'dispatch;
	}
	// 823238EC: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823238F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823238F4: 4099000C  ble cr6, 0x82323900
	if !ctx.cr[6].gt {
	pc = 0x82323900; continue 'dispatch;
	}
	pc = 0x823238F8; continue 'dispatch;
            }
            0x823238F8 => {
    //   block [0x823238F8..0x82323900)
	// 823238F8: EC1D0028  fsubs f0, f29, f0
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 823238FC: 48000028  b 0x82323924
	pc = 0x82323924; continue 'dispatch;
            }
            0x82323900 => {
    //   block [0x82323900..0x82323924)
	// 82323900: 4820F911  bl 0x82533210
	ctx.lr = 0x82323904;
	sub_82533210(ctx, base);
	// 82323904: 546A047E  clrlwi r10, r3, 0x11
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82323908: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232390C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82323910: F94100B0  std r10, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[10].u64 ) };
	// 82323914: C80100B0  lfd f0, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82323918: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8232391C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82323920: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	pc = 0x82323924; continue 'dispatch;
            }
            0x82323924 => {
    //   block [0x82323924..0x82323928)
	// 82323924: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x82323928; continue 'dispatch;
            }
            0x82323928 => {
    //   block [0x82323928..0x82323948)
	// 82323928: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232392C: 3BBD0018  addi r29, r29, 0x18
	ctx.r[29].s64 = ctx.r[29].s64 + 24;
	// 82323930: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82323934: 3BDE0060  addi r30, r30, 0x60
	ctx.r[30].s64 = ctx.r[30].s64 + 96;
	// 82323938: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8232393C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82323940: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82323944: 4198FB48  blt cr6, 0x8232348c
	if ctx.cr[6].lt {
	pc = 0x8232348C; continue 'dispatch;
	}
	pc = 0x82323948; continue 'dispatch;
            }
            0x82323948 => {
    //   block [0x82323948..0x82323964)
	// 82323948: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232394C: EC00782A  fadds f0, f0, f15
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[15].f64) as f32) as f64;
	// 82323950: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82323954: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82323958: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 8232395C: 482126A1  bl 0x82535ffc
	ctx.lr = 0x82323960;
	sub_82535FFC(ctx, base);
	// 82323960: 48211770  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82323968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82323968 size=460
    let mut pc: u32 = 0x82323968;
    'dispatch: loop {
        match pc {
            0x82323968 => {
    //   block [0x82323968..0x82323998)
	// 82323968: 81030504  lwz r8, 0x504(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1284 as u32) ) } as u64;
	// 8232396C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82323970: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82323974: 3CC0830F  lis r6, -0x7cf1
	ctx.r[6].s64 = -2096168960;
	// 82323978: 81680054  lwz r11, 0x54(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232397C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82323980: 409A0018  bne cr6, 0x82323998
	if !ctx.cr[6].eq {
	pc = 0x82323998; continue 'dispatch;
	}
	// 82323984: 8146FAC0  lwz r10, -0x540(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82323988: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 8232398C: 409A000C  bne cr6, 0x82323998
	if !ctx.cr[6].eq {
	pc = 0x82323998; continue 'dispatch;
	}
	// 82323990: 98830019  stb r4, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[4].u8 ) };
	// 82323994: 98A30025  stb r5, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[5].u8 ) };
	pc = 0x82323998; continue 'dispatch;
            }
            0x82323998 => {
    //   block [0x82323998..0x82323A58)
	// 82323998: C00B0008  lfs f0, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232399C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823239A0: D00303E4  stfs f0, 0x3e4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(996 as u32), tmp.u32 ) };
	// 823239A4: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 823239A8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823239AC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823239B0: D00303E8  stfs f0, 0x3e8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1000 as u32), tmp.u32 ) };
	// 823239B4: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823239B8: D1A303EC  stfs f13, 0x3ec(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1004 as u32), tmp.u32 ) };
	// 823239BC: C18B0018  lfs f12, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823239C0: D18303F0  stfs f12, 0x3f0(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1008 as u32), tmp.u32 ) };
	// 823239C4: C18B001C  lfs f12, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823239C8: D18303F4  stfs f12, 0x3f4(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1012 as u32), tmp.u32 ) };
	// 823239CC: C18B0020  lfs f12, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823239D0: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823239D4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823239D8: D18303F8  stfs f12, 0x3f8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1016 as u32), tmp.u32 ) };
	// 823239DC: C18B0024  lfs f12, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823239E0: D18303FC  stfs f12, 0x3fc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1020 as u32), tmp.u32 ) };
	// 823239E4: C18B0028  lfs f12, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823239E8: D1830404  stfs f12, 0x404(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 823239EC: C18B002C  lfs f12, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823239F0: D0030408  stfs f0, 0x408(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 823239F4: D1830400  stfs f12, 0x400(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 823239F8: C18B0030  lfs f12, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823239FC: 912304C8  stw r9, 0x4c8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1224 as u32), ctx.r[9].u32 ) };
	// 82323A00: C1AA20CC  lfs f13, 0x20cc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8396 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82323A04: 912304C4  stw r9, 0x4c4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1220 as u32), ctx.r[9].u32 ) };
	// 82323A08: D1A30410  stfs f13, 0x410(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	// 82323A0C: 90E303C8  stw r7, 0x3c8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(968 as u32), ctx.r[7].u32 ) };
	// 82323A10: D0030414  stfs f0, 0x414(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1044 as u32), tmp.u32 ) };
	// 82323A14: 90E30450  stw r7, 0x450(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1104 as u32), ctx.r[7].u32 ) };
	// 82323A18: D0030418  stfs f0, 0x418(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1048 as u32), tmp.u32 ) };
	// 82323A1C: D003041C  stfs f0, 0x41c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1052 as u32), tmp.u32 ) };
	// 82323A20: D183040C  stfs f12, 0x40c(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1036 as u32), tmp.u32 ) };
	// 82323A24: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323A28: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 82323A2C: C1A300C8  lfs f13, 0xc8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82323A30: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82323A34: D00300C8  stfs f0, 0xc8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82323A38: 816BA0CC  lwz r11, -0x5f34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24372 as u32) ) } as u64;
	// 82323A3C: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 82323A40: 409A0108  bne cr6, 0x82323b48
	if !ctx.cr[6].eq {
		sub_82323B34(ctx, base);
		return;
	}
	// 82323A44: 89680007  lbz r11, 7(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(7 as u32) ) } as u64;
	// 82323A48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82323A4C: 409900E8  ble cr6, 0x82323b34
	if !ctx.cr[6].gt {
		sub_82323B34(ctx, base);
		return;
	}
	// 82323A50: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82323A54: 392304D4  addi r9, r3, 0x4d4
	ctx.r[9].s64 = ctx.r[3].s64 + 1236;
	pc = 0x82323A58; continue 'dispatch;
            }
            0x82323A58 => {
    //   block [0x82323A58..0x82323B34)
	// 82323A58: 81030504  lwz r8, 0x504(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1284 as u32) ) } as u64;
	// 82323A5C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82323A60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82323A64: 8108005C  lwz r8, 0x5c(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(92 as u32) ) } as u64;
	// 82323A68: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82323A6C: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 82323A70: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82323A74: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82323A78: 409AFFE0  bne cr6, 0x82323a58
	if !ctx.cr[6].eq {
	pc = 0x82323A58; continue 'dispatch;
	}
	// 82323A7C: 810304D4  lwz r8, 0x4d4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1236 as u32) ) } as u64;
	// 82323A80: 816304D8  lwz r11, 0x4d8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82323A84: 814304E0  lwz r10, 0x4e0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1248 as u32) ) } as u64;
	// 82323A88: 812304DC  lwz r9, 0x4dc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1244 as u32) ) } as u64;
	// 82323A8C: C1A80000  lfs f13, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82323A90: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323A94: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82323A98: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82323A9C: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82323AA0: ED6B6828  fsubs f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82323AA4: ED8C5824  fdivs f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 82323AA8: D18304E4  stfs f12, 0x4e4(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1252 as u32), tmp.u32 ) };
	// 82323AAC: EC0C037C  fnmsubs f0, f12, f13, f0
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82323AB0: D00304E8  stfs f0, 0x4e8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1256 as u32), tmp.u32 ) };
	// 82323AB4: C1A80000  lfs f13, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82323AB8: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323ABC: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82323AC0: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82323AC4: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82323AC8: ED6B6828  fsubs f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82323ACC: ED8C5824  fdivs f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 82323AD0: D18304EC  stfs f12, 0x4ec(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1260 as u32), tmp.u32 ) };
	// 82323AD4: EC0C037C  fnmsubs f0, f12, f13, f0
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82323AD8: D00304F0  stfs f0, 0x4f0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1264 as u32), tmp.u32 ) };
	// 82323ADC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82323AE0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323AE4: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82323AE8: C1690000  lfs f11, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82323AEC: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82323AF0: ED6B6828  fsubs f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82323AF4: ED8C5824  fdivs f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 82323AF8: D18304F4  stfs f12, 0x4f4(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1268 as u32), tmp.u32 ) };
	// 82323AFC: EC0C037C  fnmsubs f0, f12, f13, f0
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82323B00: D00304F8  stfs f0, 0x4f8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1272 as u32), tmp.u32 ) };
	// 82323B04: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82323B08: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82323B0C: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82323B10: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82323B14: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82323B18: ED6B6828  fsubs f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82323B1C: 98E304D0  stb r7, 0x4d0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(1232 as u32), ctx.r[7].u8 ) };
	// 82323B20: ED8C5824  fdivs f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 82323B24: D18304FC  stfs f12, 0x4fc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1276 as u32), tmp.u32 ) };
	// 82323B28: EC0C037C  fnmsubs f0, f12, f13, f0
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82323B2C: D0030500  stfs f0, 0x500(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1280 as u32), tmp.u32 ) };
	// 82323B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82323B34(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82323B34 size=28
    let mut pc: u32 = 0x82323B34;
    'dispatch: loop {
        match pc {
            0x82323B34 => {
    //   block [0x82323B34..0x82323B48)
	// 82323B34: 8166FAC0  lwz r11, -0x540(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82323B38: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82323B3C: 409A000C  bne cr6, 0x82323b48
	if !ctx.cr[6].eq {
	pc = 0x82323B48; continue 'dispatch;
	}
	// 82323B40: 98830019  stb r4, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[4].u8 ) };
	// 82323B44: 98A30025  stb r5, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[5].u8 ) };
	pc = 0x82323B48; continue 'dispatch;
            }
            0x82323B48 => {
    //   block [0x82323B48..0x82323B50)
	// 82323B48: 98E304D0  stb r7, 0x4d0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(1232 as u32), ctx.r[7].u8 ) };
	// 82323B4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82323B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82323B50 size=3764
    let mut pc: u32 = 0x82323B50;
    'dispatch: loop {
        match pc {
            0x82323B50 => {
    //   block [0x82323B50..0x82323B90)
	// 82323B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82323B54: 4821155D  bl 0x825350b0
	ctx.lr = 0x82323B58;
	sub_82535080(ctx, base);
	// 82323B58: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82323B5C: 48212485  bl 0x82535fe0
	ctx.lr = 0x82323B60;
	sub_82535FB0(ctx, base);
	// 82323B60: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 82323B64: 48215831  bl 0x82539394
	ctx.lr = 0x82323B68;
	sub_82539130(ctx, base);
	// 82323B68: 9421FD70  stwu r1, -0x290(r1)
	ea = ctx.r[1].u32.wrapping_add(-656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82323B6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82323B70: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 82323B74: 3B5F0330  addi r26, r31, 0x330
	ctx.r[26].s64 = ctx.r[31].s64 + 816;
	// 82323B78: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82323B7C: 817F0450  lwz r11, 0x450(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1104 as u32) ) } as u64;
	// 82323B80: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 82323B84: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82323B88: 911F0450  stw r8, 0x450(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1104 as u32), ctx.r[8].u32 ) };
	// 82323B8C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82323B90; continue 'dispatch;
            }
            0x82323B90 => {
    //   block [0x82323B90..0x82324A04)
	// 82323B90: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82323B94: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82323B98: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82323B9C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82323BA0: 4200FFF0  bdnz 0x82323b90
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82323B90; continue 'dispatch;
	}
	// 82323BA4: 3FC082C0  lis r30, -0x7d40
	ctx.r[30].s64 = -2101346304;
	// 82323BA8: 815F03C8  lwz r10, 0x3c8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(968 as u32) ) } as u64;
	// 82323BAC: 3D2082C0  lis r9, -0x7d40
	ctx.r[9].s64 = -2101346304;
	// 82323BB0: 3CE00003  lis r7, 3
	ctx.r[7].s64 = 196608;
	// 82323BB4: 3929BFF0  addi r9, r9, -0x4010
	ctx.r[9].s64 = ctx.r[9].s64 + -16400;
	// 82323BB8: 60E785E0  ori r7, r7, 0x85e0
	ctx.r[7].u64 = ctx.r[7].u64 | 34272;
	// 82323BBC: 807EB9B4  lwz r3, -0x464c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17996 as u32) ) } as u64;
	// 82323BC0: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 82323BC4: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 82323BC8: 39630210  addi r11, r3, 0x210
	ctx.r[11].s64 = ctx.r[3].s64 + 528;
	// 82323BCC: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 82323BD0: 7FA93C2E  lfsx f29, r9, r7
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82323BD4: 39210180  addi r9, r1, 0x180
	ctx.r[9].s64 = ctx.r[1].s64 + 384;
	// 82323BD8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82324A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82324A08 size=148
    let mut pc: u32 = 0x82324A08;
    'dispatch: loop {
        match pc {
            0x82324A08 => {
    //   block [0x82324A08..0x82324A48)
	// 82324A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82324A0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82324A10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82324A14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82324A18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82324A1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82324A20: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82324A24: 817F04C8  lwz r11, 0x4c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1224 as u32) ) } as u64;
	// 82324A28: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82324A2C: 4199001C  bgt cr6, 0x82324a48
	if ctx.cr[6].gt {
	pc = 0x82324A48; continue 'dispatch;
	}
	// 82324A30: 396B00EC  addi r11, r11, 0xec
	ctx.r[11].s64 = ctx.r[11].s64 + 236;
	// 82324A34: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82324A38: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82324A3C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82324A40: 419A0008  beq cr6, 0x82324a48
	if ctx.cr[6].eq {
	pc = 0x82324A48; continue 'dispatch;
	}
	// 82324A44: 7FCBF92E  stwx r30, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	pc = 0x82324A48; continue 'dispatch;
            }
            0x82324A48 => {
    //   block [0x82324A48..0x82324A6C)
	// 82324A48: 817F04C4  lwz r11, 0x4c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1220 as u32) ) } as u64;
	// 82324A4C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82324A50: 4199001C  bgt cr6, 0x82324a6c
	if ctx.cr[6].gt {
	pc = 0x82324A6C; continue 'dispatch;
	}
	// 82324A54: 396B00E8  addi r11, r11, 0xe8
	ctx.r[11].s64 = ctx.r[11].s64 + 232;
	// 82324A58: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82324A5C: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82324A60: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82324A64: 419A0008  beq cr6, 0x82324a6c
	if ctx.cr[6].eq {
	pc = 0x82324A6C; continue 'dispatch;
	}
	// 82324A68: 7FCBF92E  stwx r30, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	pc = 0x82324A6C; continue 'dispatch;
            }
            0x82324A6C => {
    //   block [0x82324A6C..0x82324A84)
	// 82324A6C: 897F04D0  lbz r11, 0x4d0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1232 as u32) ) } as u64;
	// 82324A70: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82324A74: 409A0010  bne cr6, 0x82324a84
	if !ctx.cr[6].eq {
	pc = 0x82324A84; continue 'dispatch;
	}
	// 82324A78: 807F03C4  lwz r3, 0x3c4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(964 as u32) ) } as u64;
	// 82324A7C: 480E0D15  bl 0x82405790
	ctx.lr = 0x82324A80;
	sub_82405790(ctx, base);
	// 82324A80: 9BDF04D0  stb r30, 0x4d0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1232 as u32), ctx.r[30].u8 ) };
	pc = 0x82324A84; continue 'dispatch;
            }
            0x82324A84 => {
    //   block [0x82324A84..0x82324A9C)
	// 82324A84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82324A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82324A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82324A90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82324A94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82324A98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82324AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82324AA0 size=288
    let mut pc: u32 = 0x82324AA0;
    'dispatch: loop {
        match pc {
            0x82324AA0 => {
    //   block [0x82324AA0..0x82324AF4)
	// 82324AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82324AA4: 48210615  bl 0x825350b8
	ctx.lr = 0x82324AA8;
	sub_82535080(ctx, base);
	// 82324AA8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82324AAC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82324AB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82324AB4: 83DF02C8  lwz r30, 0x2c8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82324AB8: 83BF02CC  lwz r29, 0x2cc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(716 as u32) ) } as u64;
	// 82324ABC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82324AC0: 4BEF9911  bl 0x8221e3d0
	ctx.lr = 0x82324AC4;
	sub_8221E3D0(ctx, base);
	// 82324AC4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82324AC8: 817F0294  lwz r11, 0x294(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 82324ACC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82324AD0: 815F02B8  lwz r10, 0x2b8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(696 as u32) ) } as u64;
	// 82324AD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82324AD8: C3E91FF8  lfs f31, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82324ADC: 419A0024  beq cr6, 0x82324b00
	if ctx.cr[6].eq {
	pc = 0x82324B00; continue 'dispatch;
	}
	// 82324AE0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82324AE4: 41980010  blt cr6, 0x82324af4
	if ctx.cr[6].lt {
	pc = 0x82324AF4; continue 'dispatch;
	}
	// 82324AE8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82324AEC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82324AF0: 41980014  blt cr6, 0x82324b04
	if ctx.cr[6].lt {
	pc = 0x82324B04; continue 'dispatch;
	}
	pc = 0x82324AF4; continue 'dispatch;
            }
            0x82324AF4 => {
    //   block [0x82324AF4..0x82324B00)
	// 82324AF4: D3FF029C  stfs f31, 0x29c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82324AF8: 939F0298  stw r28, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[28].u32 ) };
	// 82324AFC: 4800000C  b 0x82324b08
	pc = 0x82324B08; continue 'dispatch;
            }
            0x82324B00 => {
    //   block [0x82324B00..0x82324B04)
	// 82324B00: D3FF029C  stfs f31, 0x29c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), tmp.u32 ) };
	pc = 0x82324B04; continue 'dispatch;
            }
            0x82324B04 => {
    //   block [0x82324B04..0x82324B08)
	// 82324B04: 915F0298  stw r10, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[10].u32 ) };
	pc = 0x82324B08; continue 'dispatch;
            }
            0x82324B08 => {
    //   block [0x82324B08..0x82324B44)
	// 82324B08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82324B0C: C01F02BC  lfs f0, 0x2bc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82324B10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82324B14: D01F029C  stfs f0, 0x29c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82324B18: 4BEF98B9  bl 0x8221e3d0
	ctx.lr = 0x82324B1C;
	sub_8221E3D0(ctx, base);
	// 82324B1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82324B20: 815F02D4  lwz r10, 0x2d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(724 as u32) ) } as u64;
	// 82324B24: C1BF02B4  lfs f13, 0x2b4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82324B28: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82324B2C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82324B30: C00B212C  lfs f0, 0x212c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8492 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82324B34: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82324B38: 4099002C  ble cr6, 0x82324b64
	if !ctx.cr[6].gt {
	pc = 0x82324B64; continue 'dispatch;
	}
	// 82324B3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82324B40: 7D1EE850  subf r8, r30, r29
	ctx.r[8].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	pc = 0x82324B44; continue 'dispatch;
            }
            0x82324B44 => {
    //   block [0x82324B44..0x82324B64)
	// 82324B44: 7CA82214  add r5, r8, r4
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[4].u64;
	// 82324B48: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82324B4C: 480437AD  bl 0x823682f8
	ctx.lr = 0x82324B50;
	sub_823682F8(ctx, base);
	// 82324B50: 817F02D4  lwz r11, 0x2d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(724 as u32) ) } as u64;
	// 82324B54: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82324B58: 38840040  addi r4, r4, 0x40
	ctx.r[4].s64 = ctx.r[4].s64 + 64;
	// 82324B5C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82324B60: 4198FFE4  blt cr6, 0x82324b44
	if ctx.cr[6].lt {
	pc = 0x82324B44; continue 'dispatch;
	}
	pc = 0x82324B64; continue 'dispatch;
            }
            0x82324B64 => {
    //   block [0x82324B64..0x82324B88)
	// 82324B64: 815F0294  lwz r10, 0x294(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 82324B68: 817F02A0  lwz r11, 0x2a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(672 as u32) ) } as u64;
	// 82324B6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82324B70: 419A0034  beq cr6, 0x82324ba4
	if ctx.cr[6].eq {
	pc = 0x82324BA4; continue 'dispatch;
	}
	// 82324B74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82324B78: 41980010  blt cr6, 0x82324b88
	if ctx.cr[6].lt {
	pc = 0x82324B88; continue 'dispatch;
	}
	// 82324B7C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82324B80: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82324B84: 41980024  blt cr6, 0x82324ba8
	if ctx.cr[6].lt {
	pc = 0x82324BA8; continue 'dispatch;
	}
	pc = 0x82324B88; continue 'dispatch;
            }
            0x82324B88 => {
    //   block [0x82324B88..0x82324BA4)
	// 82324B88: D3FF029C  stfs f31, 0x29c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82324B8C: 939F0298  stw r28, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[28].u32 ) };
	// 82324B90: C01F02A4  lfs f0, 0x2a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82324B94: D01F029C  stfs f0, 0x29c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82324B98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82324B9C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82324BA0: 48210568  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x82324BA4 => {
    //   block [0x82324BA4..0x82324BA8)
	// 82324BA4: D3FF029C  stfs f31, 0x29c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), tmp.u32 ) };
	pc = 0x82324BA8; continue 'dispatch;
            }
            0x82324BA8 => {
    //   block [0x82324BA8..0x82324BC0)
	// 82324BA8: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 82324BAC: C01F02A4  lfs f0, 0x2a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82324BB0: D01F029C  stfs f0, 0x29c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82324BB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82324BB8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82324BBC: 4821054C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82324BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82324BC0 size=584
    let mut pc: u32 = 0x82324BC0;
    'dispatch: loop {
        match pc {
            0x82324BC0 => {
    //   block [0x82324BC0..0x82324E08)
	// 82324BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82324BC4: 482104E1  bl 0x825350a4
	ctx.lr = 0x82324BC8;
	sub_82535080(ctx, base);
	// 82324BC8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82324BCC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82324BD0: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82324BD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82324BD8: 396BD860  addi r11, r11, -0x27a0
	ctx.r[11].s64 = ctx.r[11].s64 + -10144;
	// 82324BDC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82324BE0: 3BDF00B0  addi r30, r31, 0xb0
	ctx.r[30].s64 = ctx.r[31].s64 + 176;
	// 82324BE4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82324BE8: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 82324BEC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82324BF0: 3D603F80  lis r11, 0x3f80
	ctx.r[11].s64 = 1065353216;
	// 82324BF4: C14A1FF8  lfs f10, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82324BF8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82324BFC: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82324C00: D15E029C  stfs f10, 0x29c(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82324C04: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82324C08: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 82324C0C: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	// 82324C10: 394A4634  addi r10, r10, 0x4634
	ctx.r[10].s64 = ctx.r[10].s64 + 17972;
	// 82324C14: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82324C18: 397E0250  addi r11, r30, 0x250
	ctx.r[11].s64 = ctx.r[30].s64 + 592;
	// 82324C1C: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82324C20: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82324C24: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82324C28: 915E0290  stw r10, 0x290(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(656 as u32), ctx.r[10].u32 ) };
	// 82324C2C: 939E0294  stw r28, 0x294(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(660 as u32), ctx.r[28].u32 ) };
	// 82324C30: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82324C34: 939E0298  stw r28, 0x298(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(664 as u32), ctx.r[28].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82324E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82324E08 size=96
    let mut pc: u32 = 0x82324E08;
    'dispatch: loop {
        match pc {
            0x82324E08 => {
    //   block [0x82324E08..0x82324E68)
	// 82324E08: 89030080  lbz r8, 0x80(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82324E0C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82324E10: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82324E14: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82324E18: 396BBC00  addi r11, r11, -0x4400
	ctx.r[11].s64 = ctx.r[11].s64 + -17408;
	// 82324E1C: 5508103E  rotlwi r8, r8, 2
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(2)) as u64;
	// 82324E20: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82324E24: 394A4634  addi r10, r10, 0x4634
	ctx.r[10].s64 = ctx.r[10].s64 + 17972;
	// 82324E28: 3929DED0  addi r9, r9, -0x2130
	ctx.r[9].s64 = ctx.r[9].s64 + -8496;
	// 82324E2C: 548607FE  clrlwi r6, r4, 0x1f
	ctx.r[6].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82324E30: 7CE8592E  stwx r7, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82324E34: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82324E38: 91430340  stw r10, 0x340(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(832 as u32), ctx.r[10].u32 ) };
	// 82324E3C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82324E40: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82324E44: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82324E48: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82324E4C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82324E50: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82324E54: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82324E58: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82324E5C: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82324E60: 99430025  stb r10, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 82324E64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82324E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82324E68 size=364
    let mut pc: u32 = 0x82324E68;
    'dispatch: loop {
        match pc {
            0x82324E68 => {
    //   block [0x82324E68..0x82324EC4)
	// 82324E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82324E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82324E70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82324E74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82324E78: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82324E7C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82324E80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82324E84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82324E88: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82324E8C: 397F00B0  addi r11, r31, 0xb0
	ctx.r[11].s64 = ctx.r[31].s64 + 176;
	// 82324E90: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82324E94: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82324E98: 991F001E  stb r8, 0x1e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(30 as u32), ctx.r[8].u8 ) };
	// 82324E9C: 93CB02A0  stw r30, 0x2a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(672 as u32), ctx.r[30].u32 ) };
	// 82324EA0: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 82324EA4: C3E91FF8  lfs f31, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82324EA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82324EAC: 419A0018  beq cr6, 0x82324ec4
	if ctx.cr[6].eq {
	pc = 0x82324EC4; continue 'dispatch;
	}
	// 82324EB0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82324EB4: 93CB0298  stw r30, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[30].u32 ) };
	// 82324EB8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82324EBC: 41990010  bgt cr6, 0x82324ecc
	if ctx.cr[6].gt {
	pc = 0x82324ECC; continue 'dispatch;
	}
	// 82324EC0: 48000008  b 0x82324ec8
	pc = 0x82324EC8; continue 'dispatch;
            }
            0x82324EC4 => {
    //   block [0x82324EC4..0x82324EC8)
	// 82324EC4: 93CB0298  stw r30, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[30].u32 ) };
	pc = 0x82324EC8; continue 'dispatch;
            }
            0x82324EC8 => {
    //   block [0x82324EC8..0x82324ECC)
	// 82324EC8: D3EB029C  stfs f31, 0x29c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), tmp.u32 ) };
	pc = 0x82324ECC; continue 'dispatch;
            }
            0x82324ECC => {
    //   block [0x82324ECC..0x82324F18)
	// 82324ECC: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 82324ED0: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82324ED4: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82324ED8: D3EB02A4  stfs f31, 0x2a4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(676 as u32), tmp.u32 ) };
	// 82324EDC: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82324EE0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82324EE4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82324EE8: C3CABA38  lfs f30, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82324EEC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82324EF0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82324EF4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82324EF8: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82324EFC: D00B02A8  stfs f0, 0x2a8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(680 as u32), tmp.u32 ) };
	// 82324F00: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82324F04: 4199001C  bgt cr6, 0x82324f20
	if ctx.cr[6].gt {
	pc = 0x82324F20; continue 'dispatch;
	}
	// 82324F08: 814B02B0  lwz r10, 0x2b0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(688 as u32) ) } as u64;
	// 82324F0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82324F10: 419A0008  beq cr6, 0x82324f18
	if ctx.cr[6].eq {
	pc = 0x82324F18; continue 'dispatch;
	}
	// 82324F14: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82324F18; continue 'dispatch;
            }
            0x82324F18 => {
    //   block [0x82324F18..0x82324F20)
	// 82324F18: D00B02A4  stfs f0, 0x2a4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(676 as u32), tmp.u32 ) };
	// 82324F1C: 48000008  b 0x82324f24
	pc = 0x82324F24; continue 'dispatch;
            }
            0x82324F20 => {
    //   block [0x82324F20..0x82324F24)
	// 82324F20: D3EB02A4  stfs f31, 0x2a4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(676 as u32), tmp.u32 ) };
	pc = 0x82324F24; continue 'dispatch;
            }
            0x82324F24 => {
    //   block [0x82324F24..0x82324FD4)
	// 82324F24: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82324F28: C1AB02A4  lfs f13, 0x2a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(676 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82324F2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82324F30: D1AB029C  stfs f13, 0x29c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82324F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82324F38: 93CB02B0  stw r30, 0x2b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(688 as u32), ctx.r[30].u32 ) };
	// 82324F3C: C00AD6C8  lfs f0, -0x2938(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82324F40: D00B02AC  stfs f0, 0x2ac(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(684 as u32), tmp.u32 ) };
	// 82324F44: 911F0360  stw r8, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[8].u32 ) };
	// 82324F48: 48001271  bl 0x823261b8
	ctx.lr = 0x82324F4C;
	sub_823261B8(ctx, base);
	// 82324F4C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82324F50: 815F0394  lwz r10, 0x394(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 82324F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82324F58: D3FF0430  stfs f31, 0x430(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	// 82324F5C: 93DF0434  stw r30, 0x434(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1076 as u32), ctx.r[30].u32 ) };
	// 82324F60: D3FF046C  stfs f31, 0x46c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1132 as u32), tmp.u32 ) };
	// 82324F64: 93DF0438  stw r30, 0x438(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), ctx.r[30].u32 ) };
	// 82324F68: 93DF0448  stw r30, 0x448(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1096 as u32), ctx.r[30].u32 ) };
	// 82324F6C: C00B2830  lfs f0, 0x2830(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82324F70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82324F74: D01F0460  stfs f0, 0x460(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1120 as u32), tmp.u32 ) };
	// 82324F78: 93DF0450  stw r30, 0x450(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1104 as u32), ctx.r[30].u32 ) };
	// 82324F7C: C1AB2570  lfs f13, 0x2570(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9584 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82324F80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82324F84: D1BF0464  stfs f13, 0x464(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1124 as u32), tmp.u32 ) };
	// 82324F88: C18B2238  lfs f12, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82324F8C: D19F0468  stfs f12, 0x468(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1128 as u32), tmp.u32 ) };
	// 82324F90: D3CA0000  stfs f30, 0(r10)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82324F94: 48000F7D  bl 0x82325f10
	ctx.lr = 0x82324F98;
	sub_82325F10(ctx, base);
	// 82324F98: 895F0080  lbz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82324F9C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82324FA0: 93DF0454  stw r30, 0x454(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1108 as u32), ctx.r[30].u32 ) };
	// 82324FA4: 396BBC00  addi r11, r11, -0x4400
	ctx.r[11].s64 = ctx.r[11].s64 + -17408;
	// 82324FA8: 93DF045C  stw r30, 0x45c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1116 as u32), ctx.r[30].u32 ) };
	// 82324FAC: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82324FB0: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82324FB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82324FB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82324FBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82324FC0: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82324FC4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82324FC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82324FCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82324FD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82324FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82324FD8 size=76
    let mut pc: u32 = 0x82324FD8;
    'dispatch: loop {
        match pc {
            0x82324FD8 => {
    //   block [0x82324FD8..0x82325024)
	// 82324FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82324FDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82324FE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82324FE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82324FE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82324FEC: 480000D5  bl 0x823250c0
	ctx.lr = 0x82324FF0;
	sub_823250C0(ctx, base);
	// 82324FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82324FF4: 48000325  bl 0x82325318
	ctx.lr = 0x82324FF8;
	sub_82325318(ctx, base);
	// 82324FF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82324FFC: 4800054D  bl 0x82325548
	ctx.lr = 0x82325000;
	sub_82325548(ctx, base);
	// 82325000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82325004: 48000675  bl 0x82325678
	ctx.lr = 0x82325008;
	sub_82325678(ctx, base);
	// 82325008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232500C: 48000D85  bl 0x82325d90
	ctx.lr = 0x82325010;
	sub_82325D90(ctx, base);
	// 82325010: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82325014: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82325018: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232501C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82325020: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82325028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82325028 size=152
    let mut pc: u32 = 0x82325028;
    'dispatch: loop {
        match pc {
            0x82325028 => {
    //   block [0x82325028..0x823250A4)
	// 82325028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232502C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82325030: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82325034: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82325038: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232503C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82325040: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82325044: 917F043C  stw r11, 0x43c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1084 as u32), ctx.r[11].u32 ) };
	// 82325048: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232504C: 816BB9B0  lwz r11, -0x4650(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18000 as u32) ) } as u64;
	// 82325050: 806B0028  lwz r3, 0x28(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82325054: 4BF356F5  bl 0x8225a748
	ctx.lr = 0x82325058;
	sub_8225A748(ctx, base);
	// 82325058: C1810054  lfs f12, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232505C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82325060: C01F0414  lfs f0, 0x414(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82325064: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82325068: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232506C: C1BF0418  lfs f13, 0x418(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1048 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82325070: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82325074: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82325078: C19F0410  lfs f12, 0x410(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232507C: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82325080: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82325084: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82325088: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 8232508C: EDA0002C  fsqrts f13, f0
	ctx.f[13].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82325090: C00BCFEC  lfs f0, -0x3014(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82325094: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82325098: 4098000C  bge cr6, 0x823250a4
	if !ctx.cr[6].lt {
	pc = 0x823250A4; continue 'dispatch;
	}
	// 8232509C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823250A0: 917F043C  stw r11, 0x43c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1084 as u32), ctx.r[11].u32 ) };
	pc = 0x823250A4; continue 'dispatch;
            }
            0x823250A4 => {
    //   block [0x823250A4..0x823250C0)
	// 823250A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823250A8: 480019A1  bl 0x82326a48
	ctx.lr = 0x823250AC;
	sub_82326A48(ctx, base);
	// 823250AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823250B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823250B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823250B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823250BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823250C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823250C0 size=596
    let mut pc: u32 = 0x823250C0;
    'dispatch: loop {
        match pc {
            0x823250C0 => {
    //   block [0x823250C0..0x82325148)
	// 823250C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823250C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823250C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823250CC: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 823250D0: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 823250D4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823250D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823250DC: 817F0400  lwz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 823250E0: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 823250E4: 419A0214  beq cr6, 0x823252f8
	if ctx.cr[6].eq {
	pc = 0x823252F8; continue 'dispatch;
	}
	// 823250E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823250EC: 419A01F0  beq cr6, 0x823252dc
	if ctx.cr[6].eq {
	pc = 0x823252DC; continue 'dispatch;
	}
	// 823250F0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823250F4: 419A01E8  beq cr6, 0x823252dc
	if ctx.cr[6].eq {
	pc = 0x823252DC; continue 'dispatch;
	}
	// 823250F8: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 823250FC: 409A004C  bne cr6, 0x82325148
	if !ctx.cr[6].eq {
	pc = 0x82325148; continue 'dispatch;
	}
	// 82325100: 39600410  li r11, 0x410
	ctx.r[11].s64 = 1040;
	// 82325104: 39400090  li r10, 0x90
	ctx.r[10].s64 = 144;
	pc = 0x82325148; continue 'dispatch;
            }
            0x82325148 => {
    //   block [0x82325148..0x823252DC)
	// 82325148: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8232514C: 409A00F0  bne cr6, 0x8232523c
	if !ctx.cr[6].eq {
	pc = 0x8232523C; continue 'dispatch;
	}
	// 82325150: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82325154: C01F0440  lfs f0, 0x440(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82325158: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232515C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82325160: 40990024  ble cr6, 0x82325184
	if !ctx.cr[6].gt {
	pc = 0x82325184; continue 'dispatch;
	}
	// 82325164: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82325168: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8232516C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82325170: 614A85D4  ori r10, r10, 0x85d4
	ctx.r[10].u64 = ctx.r[10].u64 | 34260;
	// 82325174: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82325178: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232517C: D01F0440  stfs f0, 0x440(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1088 as u32), tmp.u32 ) };
	// 82325180: 48000170  b 0x823252f0
	pc = 0x823252F0; continue 'dispatch;
	// 82325184: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82325188: C03F0424  lfs f1, 0x424(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232518C: C3CBBA38  lfs f30, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82325190: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82325194: 480429AD  bl 0x82367b40
	ctx.lr = 0x82325198;
	sub_82367B40(ctx, base);
	// 82325198: 39600410  li r11, 0x410
	ctx.r[11].s64 = 1040;
	// 8232519C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 823251A0: 39400090  li r10, 0x90
	ctx.r[10].s64 = 144;
            }
            0x823252DC => {
    //   block [0x823252DC..0x823252F8)
	// 823252DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823252E0: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823252E4: C05F0424  lfs f2, 0x424(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823252E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823252EC: 48000D9D  bl 0x82326088
	ctx.lr = 0x823252F0;
	sub_82326088(ctx, base);
	// 823252F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823252F4: 480015D5  bl 0x823268c8
	ctx.lr = 0x823252F8;
	sub_823268C8(ctx, base);
	pc = 0x823252F8; continue 'dispatch;
            }
            0x823252F8 => {
    //   block [0x823252F8..0x82325314)
	// 823252F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823252FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82325300: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82325304: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82325308: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232530C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82325310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82325318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82325318 size=556
    let mut pc: u32 = 0x82325318;
    'dispatch: loop {
        match pc {
            0x82325318 => {
    //   block [0x82325318..0x82325364)
	// 82325318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232531C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82325320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82325324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82325328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232532C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82325330: 815F0400  lwz r10, 0x400(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82325334: 2F0A0007  cmpwi cr6, r10, 7
	ctx.cr[6].compare_i32(ctx.r[10].s32, 7, &mut ctx.xer);
	// 82325338: 419A00C4  beq cr6, 0x823253fc
	if ctx.cr[6].eq {
	pc = 0x823253FC; continue 'dispatch;
	}
	// 8232533C: 2F0A0009  cmpwi cr6, r10, 9
	ctx.cr[6].compare_i32(ctx.r[10].s32, 9, &mut ctx.xer);
	// 82325340: 419A00B4  beq cr6, 0x823253f4
	if ctx.cr[6].eq {
	pc = 0x823253F4; continue 'dispatch;
	}
	// 82325344: 2F0A000A  cmpwi cr6, r10, 0xa
	ctx.cr[6].compare_i32(ctx.r[10].s32, 10, &mut ctx.xer);
	// 82325348: 419A00AC  beq cr6, 0x823253f4
	if ctx.cr[6].eq {
	pc = 0x823253F4; continue 'dispatch;
	}
	// 8232534C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82325350: C1BF0410  lfs f13, 0x410(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82325354: C00B2824  lfs f0, 0x2824(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82325358: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8232535C: 40980008  bge cr6, 0x82325364
	if !ctx.cr[6].lt {
	pc = 0x82325364; continue 'dispatch;
	}
	// 82325360: D01F0410  stfs f0, 0x410(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	pc = 0x82325364; continue 'dispatch;
            }
            0x82325364 => {
    //   block [0x82325364..0x8232537C)
	// 82325364: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82325368: C1BF0410  lfs f13, 0x410(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232536C: C00B281C  lfs f0, 0x281c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82325370: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82325374: 40990008  ble cr6, 0x8232537c
	if !ctx.cr[6].gt {
	pc = 0x8232537C; continue 'dispatch;
	}
	// 82325378: D01F0410  stfs f0, 0x410(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	pc = 0x8232537C; continue 'dispatch;
            }
            0x8232537C => {
    //   block [0x8232537C..0x82325394)
	// 8232537C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82325380: C1BF0418  lfs f13, 0x418(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1048 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82325384: C00B2828  lfs f0, 0x2828(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82325388: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8232538C: 40980008  bge cr6, 0x82325394
	if !ctx.cr[6].lt {
	pc = 0x82325394; continue 'dispatch;
	}
	// 82325390: D01F0418  stfs f0, 0x418(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1048 as u32), tmp.u32 ) };
	pc = 0x82325394; continue 'dispatch;
            }
            0x82325394 => {
    //   block [0x82325394..0x823253AC)
	// 82325394: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82325398: C1BF0418  lfs f13, 0x418(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1048 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232539C: C00B282C  lfs f0, 0x282c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10284 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823253A0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823253A4: 40990008  ble cr6, 0x823253ac
	if !ctx.cr[6].gt {
	pc = 0x823253AC; continue 'dispatch;
	}
	// 823253A8: D01F0418  stfs f0, 0x418(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1048 as u32), tmp.u32 ) };
	pc = 0x823253AC; continue 'dispatch;
            }
            0x823253AC => {
    //   block [0x823253AC..0x823253F4)
	// 823253AC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 823253B0: C1BF0404  lfs f13, 0x404(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823253B4: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 823253B8: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 823253BC: 612985D4  ori r9, r9, 0x85d4
	ctx.r[9].u64 = ctx.r[9].u64 | 34260;
	// 823253C0: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823253C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823253C8: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823253CC: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 823253D0: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823253D4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823253D8: 40980154  bge cr6, 0x8232552c
	if !ctx.cr[6].lt {
	pc = 0x8232552C; continue 'dispatch;
	}
	// 823253DC: 2F0A0008  cmpwi cr6, r10, 8
	ctx.cr[6].compare_i32(ctx.r[10].s32, 8, &mut ctx.xer);
	// 823253E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823253E4: 409A0144  bne cr6, 0x82325528
	if !ctx.cr[6].eq {
	pc = 0x82325528; continue 'dispatch;
	}
	// 823253E8: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 823253EC: 48000DCD  bl 0x823261b8
	ctx.lr = 0x823253F0;
	sub_823261B8(ctx, base);
	// 823253F0: 4800013C  b 0x8232552c
	pc = 0x8232552C; continue 'dispatch;
            }
            0x823253F4 => {
    //   block [0x823253F4..0x823253FC)
	// 823253F4: 2F0A0007  cmpwi cr6, r10, 7
	ctx.cr[6].compare_i32(ctx.r[10].s32, 7, &mut ctx.xer);
	// 823253F8: 409A00B4  bne cr6, 0x823254ac
	if !ctx.cr[6].eq {
	pc = 0x823254AC; continue 'dispatch;
	}
	pc = 0x823253FC; continue 'dispatch;
            }
            0x823253FC => {
    //   block [0x823253FC..0x8232544C)
	// 823253FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82325400: C01F0410  lfs f0, 0x410(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82325404: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82325408: C1AB2824  lfs f13, 0x2824(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232540C: 93DF0438  stw r30, 0x438(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), ctx.r[30].u32 ) };
	// 82325410: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82325414: 41980038  blt cr6, 0x8232544c
	if ctx.cr[6].lt {
	pc = 0x8232544C; continue 'dispatch;
	}
	// 82325418: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232541C: C1AB281C  lfs f13, 0x281c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82325420: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82325424: 41990028  bgt cr6, 0x8232544c
	if ctx.cr[6].gt {
	pc = 0x8232544C; continue 'dispatch;
	}
	// 82325428: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232542C: C01F0418  lfs f0, 0x418(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82325430: C1AB2828  lfs f13, 0x2828(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82325434: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82325438: 41980014  blt cr6, 0x8232544c
	if ctx.cr[6].lt {
	pc = 0x8232544C; continue 'dispatch;
	}
	// 8232543C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82325440: C1AB282C  lfs f13, 0x282c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10284 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82325444: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82325448: 4099000C  ble cr6, 0x82325454
	if !ctx.cr[6].gt {
	pc = 0x82325454; continue 'dispatch;
	}
	pc = 0x8232544C; continue 'dispatch;
            }
            0x8232544C => {
    //   block [0x8232544C..0x82325454)
	// 8232544C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82325450: 917F0438  stw r11, 0x438(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), ctx.r[11].u32 ) };
	pc = 0x82325454; continue 'dispatch;
            }
            0x82325454 => {
    //   block [0x82325454..0x823254AC)
	// 82325454: C1BF0414  lfs f13, 0x414(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1044 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82325458: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232545C: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82325460: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82325464: C19F0418  lfs f12, 0x418(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1048 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82325468: C1BF0098  lfs f13, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232546C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82325470: C17F0090  lfs f11, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82325474: C19F0410  lfs f12, 0x410(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82325478: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 8232547C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82325480: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82325484: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82325488: EDA0002C  fsqrts f13, f0
	ctx.f[13].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 8232548C: C00BD6C8  lfs f0, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82325490: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82325494: 40980098  bge cr6, 0x8232552c
	if !ctx.cr[6].lt {
	pc = 0x8232552C; continue 'dispatch;
	}
	// 82325498: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 8232549C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823254A0: 48000D19  bl 0x823261b8
	ctx.lr = 0x823254A4;
	sub_823261B8(ctx, base);
	// 823254A4: 93DF045C  stw r30, 0x45c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1116 as u32), ctx.r[30].u32 ) };
	// 823254A8: 48000084  b 0x8232552c
	pc = 0x8232552C; continue 'dispatch;
            }
            0x823254AC => {
    //   block [0x823254AC..0x82325500)
	// 823254AC: 2F0A0009  cmpwi cr6, r10, 9
	ctx.cr[6].compare_i32(ctx.r[10].s32, 9, &mut ctx.xer);
	// 823254B0: 409A0050  bne cr6, 0x82325500
	if !ctx.cr[6].eq {
	pc = 0x82325500; continue 'dispatch;
	}
	// 823254B4: 817F0458  lwz r11, 0x458(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1112 as u32) ) } as u64;
	// 823254B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823254BC: 409A0070  bne cr6, 0x8232552c
	if !ctx.cr[6].eq {
	pc = 0x8232552C; continue 'dispatch;
	}
	// 823254C0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 823254C4: C1BF0444  lfs f13, 0x444(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823254C8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 823254CC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 823254D0: 614A85D4  ori r10, r10, 0x85d4
	ctx.r[10].u64 = ctx.r[10].u64 | 34260;
	// 823254D4: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823254D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823254DC: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823254E0: D01F0444  stfs f0, 0x444(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1092 as u32), tmp.u32 ) };
	// 823254E4: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823254E8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823254EC: 40980040  bge cr6, 0x8232552c
	if !ctx.cr[6].lt {
	pc = 0x8232552C; continue 'dispatch;
	}
	// 823254F0: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 823254F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823254F8: 48000CC1  bl 0x823261b8
	ctx.lr = 0x823254FC;
	sub_823261B8(ctx, base);
	// 823254FC: 48000030  b 0x8232552c
	pc = 0x8232552C; continue 'dispatch;
            }
            0x82325500 => {
    //   block [0x82325500..0x82325528)
	// 82325500: 2F0A000A  cmpwi cr6, r10, 0xa
	ctx.cr[6].compare_i32(ctx.r[10].s32, 10, &mut ctx.xer);
	// 82325504: 409A0028  bne cr6, 0x8232552c
	if !ctx.cr[6].eq {
	pc = 0x8232552C; continue 'dispatch;
	}
	// 82325508: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232550C: C1BF0418  lfs f13, 0x418(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1048 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82325510: C00B2828  lfs f0, 0x2828(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82325514: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82325518: 40990014  ble cr6, 0x8232552c
	if !ctx.cr[6].gt {
	pc = 0x8232552C; continue 'dispatch;
	}
	// 8232551C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82325520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82325524: 917F0438  stw r11, 0x438(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), ctx.r[11].u32 ) };
	pc = 0x82325528; continue 'dispatch;
            }
            0x82325528 => {
    //   block [0x82325528..0x8232552C)
	// 82325528: 48000AA9  bl 0x82325fd0
	ctx.lr = 0x8232552C;
	sub_82325FD0(ctx, base);
	pc = 0x8232552C; continue 'dispatch;
            }
            0x8232552C => {
    //   block [0x8232552C..0x82325544)
	// 8232552C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82325530: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82325534: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82325538: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232553C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82325540: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82325548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82325548 size=300
    let mut pc: u32 = 0x82325548;
    'dispatch: loop {
        match pc {
            0x82325548 => {
    //   block [0x82325548..0x82325614)
	// 82325548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232554C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82325550: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82325554: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82325558: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232555C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82325560: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82325564: 616B9B80  ori r11, r11, 0x9b80
	ctx.r[11].u64 = ctx.r[11].u64 | 39808;
	// 82325568: 3BFE0410  addi r31, r30, 0x410
	ctx.r[31].s64 = ctx.r[30].s64 + 1040;
	// 8232556C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82325570: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82325574: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82325578: 394B76FC  addi r10, r11, 0x76fc
	ctx.r[10].s64 = ctx.r[11].s64 + 30460;
	// 8232557C: C11F0004  lfs f8, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82325580: C0FF0008  lfs f7, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82325584: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82325588: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232558C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82325590: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82325594: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82325598: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232559C: EC080028  fsubs f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 823255A0: C18A0004  lfs f12, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823255A4: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823255A8: ED886028  fsubs f12, f8, f12
	ctx.f[12].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 823255AC: EDA76828  fsubs f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 823255B0: C16A0008  lfs f11, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823255B4: C11F0000  lfs f8, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823255B8: ED675828  fsubs f11, f7, f11
	ctx.f[11].f64 = (((ctx.f[7].f64 - ctx.f[11].f64) as f32) as f64);
	// 823255BC: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823255C0: FCE04090  fmr f7, f8
	ctx.f[7].f64 = ctx.f[8].f64;
	// 823255C4: ED485028  fsubs f10, f8, f10
	ctx.f[10].f64 = (((ctx.f[8].f64 - ctx.f[10].f64) as f32) as f64);
	// 823255C8: C12A0000  lfs f9, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823255CC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 823255D0: 913E0434  stw r9, 0x434(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1076 as u32), ctx.r[9].u32 ) };
	// 823255D4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823255D8: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 823255DC: ED274828  fsubs f9, f7, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 - ctx.f[9].f64) as f32) as f64);
	// 823255E0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 823255E4: EDAB62FA  fmadds f13, f11, f11, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 823255E8: C18B9F78  lfs f12, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823255EC: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 823255F0: EDA96A7A  fmadds f13, f9, f9, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 823255F4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 823255F8: D01E0470  stfs f0, 0x470(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1136 as u32), tmp.u32 ) };
	// 823255FC: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82325600: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82325604: D1BE0474  stfs f13, 0x474(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1140 as u32), tmp.u32 ) };
	// 82325608: 4198000C  blt cr6, 0x82325614
	if ctx.cr[6].lt {
	pc = 0x82325614; continue 'dispatch;
	}
	// 8232560C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82325610: 4098004C  bge cr6, 0x8232565c
	if !ctx.cr[6].lt {
	pc = 0x8232565C; continue 'dispatch;
	}
	pc = 0x82325614; continue 'dispatch;
            }
            0x82325614 => {
    //   block [0x82325614..0x82325638)
	// 82325614: 817E0400  lwz r11, 0x400(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82325618: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 8232561C: 40980038  bge cr6, 0x82325654
	if !ctx.cr[6].lt {
	pc = 0x82325654; continue 'dispatch;
	}
	// 82325620: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82325624: C18B207C  lfs f12, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82325628: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8232562C: 4198000C  blt cr6, 0x82325638
	if ctx.cr[6].lt {
	pc = 0x82325638; continue 'dispatch;
	}
	// 82325630: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82325634: 40980020  bge cr6, 0x82325654
	if !ctx.cr[6].lt {
	pc = 0x82325654; continue 'dispatch;
	}
	pc = 0x82325638; continue 'dispatch;
            }
            0x82325638 => {
    //   block [0x82325638..0x82325654)
	// 82325638: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8232563C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82325640: 48000B79  bl 0x823261b8
	ctx.lr = 0x82325644;
	sub_823261B8(ctx, base);
	// 82325644: 38BE045C  addi r5, r30, 0x45c
	ctx.r[5].s64 = ctx.r[30].s64 + 1116;
	// 82325648: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8232564C: 3860000E  li r3, 0xe
	ctx.r[3].s64 = 14;
	// 82325650: 4803D031  bl 0x82362680
	ctx.lr = 0x82325654;
	sub_82362680(ctx, base);
	pc = 0x82325654; continue 'dispatch;
            }
            0x82325654 => {
    //   block [0x82325654..0x8232565C)
	// 82325654: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82325658: 917E0434  stw r11, 0x434(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1076 as u32), ctx.r[11].u32 ) };
	pc = 0x8232565C; continue 'dispatch;
            }
            0x8232565C => {
    //   block [0x8232565C..0x82325674)
	// 8232565C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82325660: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82325664: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82325668: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232566C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82325670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82325678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82325678 size=1812
    let mut pc: u32 = 0x82325678;
    'dispatch: loop {
        match pc {
            0x82325678 => {
    //   block [0x82325678..0x82325D7C)
	// 82325678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232567C: 4820FA25  bl 0x825350a0
	ctx.lr = 0x82325680;
	sub_82535080(ctx, base);
	// 82325680: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82325684: 4821092D  bl 0x82535fb0
	ctx.lr = 0x82325688;
	sub_82535FB0(ctx, base);
	// 82325688: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232568C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82325690: 817F0400  lwz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82325694: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82325698: 419906E4  bgt cr6, 0x82325d7c
	if ctx.cr[6].gt {
	pc = 0x82325D7C; continue 'dispatch;
	}
	// 8232569C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823256A0: C3FF0424  lfs f31, 0x424(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823256A4: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 823256A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823256AC: 7ED8B378  mr r24, r22
	ctx.r[24].u64 = ctx.r[22].u64;
	// 823256B0: C38B1FF8  lfs f28, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 823256B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823256B8: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 823256BC: C1EB2038  lfs f15, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[15].f64 = (tmp.f32 as f64);
	// 823256C0: EC3F7828  fsubs f1, f31, f15
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[15].f64) as f32) as f64);
	// 823256C4: 480421C5  bl 0x82367888
	ctx.lr = 0x823256C8;
	sub_82367888(ctx, base);
	// 823256C8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823256CC: C1A10058  lfs f13, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823256D0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 823256D4: 3B5F0410  addi r26, r31, 0x410
	ctx.r[26].s64 = ctx.r[31].s64 + 1040;
	// 823256D8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 823256DC: E90B0008  ld r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 823256E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	pc = 0x82325D7C; continue 'dispatch;
            }
            0x82325D7C => {
    //   block [0x82325D7C..0x82325D8C)
	// 82325D7C: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82325D80: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82325D84: 48210279  bl 0x82535ffc
	ctx.lr = 0x82325D88;
	sub_82535FFC(ctx, base);
	// 82325D88: 4820F368  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82325D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82325D90 size=384
    let mut pc: u32 = 0x82325D90;
    'dispatch: loop {
        match pc {
            0x82325D90 => {
    //   block [0x82325D90..0x82325EB0)
	// 82325D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82325D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82325D98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82325D9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82325DA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82325DA4: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 82325DA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82325DAC: 806B03D8  lwz r3, 0x3d8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(984 as u32) ) } as u64;
	// 82325DB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82325DB4: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82325DB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82325DBC: 4E800421  bctrl
	ctx.lr = 0x82325DC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82325DC0: 817F0454  lwz r11, 0x454(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82325DC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82325DC8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82325DCC: 419A012C  beq cr6, 0x82325ef8
	if ctx.cr[6].eq {
	pc = 0x82325EF8; continue 'dispatch;
	}
	// 82325DD0: 397EFFFF  addi r11, r30, -1
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	// 82325DD4: 2B0B002E  cmplwi cr6, r11, 0x2e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 46 as u32, &mut ctx.xer);
	// 82325DD8: 4199011C  bgt cr6, 0x82325ef4
	if ctx.cr[6].gt {
	pc = 0x82325EF4; continue 'dispatch;
	}
	// 82325DDC: 3D808232  lis r12, -0x7dce
	ctx.r[12].s64 = -2110652416;
	// 82325DE0: 398C5DF4  addi r12, r12, 0x5df4
	ctx.r[12].s64 = ctx.r[12].s64 + 24052;
	// 82325DE4: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82325DE8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82325DEC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82325DF0: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x82325EBC; continue 'dispatch;
		},
		1 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		2 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		3 => {
	pc = 0x82325EB0; continue 'dispatch;
		},
		4 => {
	pc = 0x82325EB0; continue 'dispatch;
		},
		5 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		6 => {
	pc = 0x82325EB0; continue 'dispatch;
		},
		7 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		8 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		9 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		10 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		11 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		12 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		13 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		14 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		15 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		16 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		17 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		18 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		19 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		20 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		21 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		22 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		23 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		24 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		25 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		26 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		27 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		28 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		29 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		30 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		31 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		32 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		33 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		34 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		35 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		36 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		37 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		38 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		39 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		40 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		41 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		42 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		43 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		44 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		45 => {
	pc = 0x82325EF4; continue 'dispatch;
		},
		46 => {
	pc = 0x82325EE0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82325DF4: 82325EBC  lwz r17, 0x5ebc(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24252 as u32) ) } as u64;
	// 82325DF8: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325DFC: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E00: 82325EB0  lwz r17, 0x5eb0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24240 as u32) ) } as u64;
	// 82325E04: 82325EB0  lwz r17, 0x5eb0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24240 as u32) ) } as u64;
	// 82325E08: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E0C: 82325EB0  lwz r17, 0x5eb0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24240 as u32) ) } as u64;
	// 82325E10: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E14: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E18: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E1C: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E20: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E24: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E28: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E2C: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E30: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E34: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E38: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E3C: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E40: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E44: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E48: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E4C: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E50: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E54: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E58: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E5C: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E60: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E64: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E68: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E6C: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E70: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E74: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E78: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E7C: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E80: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E84: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E88: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E8C: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E90: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E94: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E98: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325E9C: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325EA0: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325EA4: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325EA8: 82325EF4  lwz r17, 0x5ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24308 as u32) ) } as u64;
	// 82325EAC: 82325EE0  lwz r17, 0x5ee0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24288 as u32) ) } as u64;
            }
            0x82325EB0 => {
    //   block [0x82325EB0..0x82325EBC)
	// 82325EB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82325EB4: 917F0448  stw r11, 0x448(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1096 as u32), ctx.r[11].u32 ) };
	// 82325EB8: 4800003C  b 0x82325ef4
	pc = 0x82325EF4; continue 'dispatch;
            }
            0x82325EBC => {
    //   block [0x82325EBC..0x82325EE0)
	// 82325EBC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82325EC0: 813F0394  lwz r9, 0x394(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 82325EC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82325EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82325ECC: 915F0448  stw r10, 0x448(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1096 as u32), ctx.r[10].u32 ) };
	// 82325ED0: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82325ED4: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82325ED8: 48000039  bl 0x82325f10
	ctx.lr = 0x82325EDC;
	sub_82325F10(ctx, base);
	// 82325EDC: 48000018  b 0x82325ef4
	pc = 0x82325EF4; continue 'dispatch;
            }
            0x82325EE0 => {
    //   block [0x82325EE0..0x82325EF4)
	// 82325EE0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82325EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82325EE8: 480002D1  bl 0x823261b8
	ctx.lr = 0x82325EEC;
	sub_823261B8(ctx, base);
	// 82325EEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82325EF0: 917F0458  stw r11, 0x458(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1112 as u32), ctx.r[11].u32 ) };
	pc = 0x82325EF4; continue 'dispatch;
            }
            0x82325EF4 => {
    //   block [0x82325EF4..0x82325EF8)
	// 82325EF4: 93DF0454  stw r30, 0x454(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1108 as u32), ctx.r[30].u32 ) };
	pc = 0x82325EF8; continue 'dispatch;
            }
            0x82325EF8 => {
    //   block [0x82325EF8..0x82325F10)
	// 82325EF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82325EFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82325F00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82325F04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82325F08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82325F0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82325F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82325F10 size=192
    let mut pc: u32 = 0x82325F10;
    'dispatch: loop {
        match pc {
            0x82325F10 => {
    //   block [0x82325F10..0x82325FD0)
	// 82325F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82325F14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82325F18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82325F1C: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82325F20: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82325F24: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82325F28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82325F2C: 397F00A0  addi r11, r31, 0xa0
	ctx.r[11].s64 = ctx.r[31].s64 + 160;
	// 82325F30: 395F0410  addi r10, r31, 0x410
	ctx.r[10].s64 = ctx.r[31].s64 + 1040;
	// 82325F34: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82325F38: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82325F3C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82325F40: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82325F44: 4820D2CD  bl 0x82533210
	ctx.lr = 0x82325F48;
	sub_82533210(ctx, base);
	// 82325F48: 546A047E  clrlwi r10, r3, 0x11
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82325F4C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82325F50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82325F54: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82325F58: C00B206C  lfs f0, 0x206c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82325F5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82325F60: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82325F64: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82325F68: D3FF0420  stfs f31, 0x420(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1056 as u32), tmp.u32 ) };
	// 82325F6C: D3FF0428  stfs f31, 0x428(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1064 as u32), tmp.u32 ) };
	// 82325F70: C3CBBA38  lfs f30, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82325F74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82325F78: D3DF042C  stfs f30, 0x42c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1068 as u32), tmp.u32 ) };
	// 82325F7C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82325F80: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82325F84: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82325F88: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82325F8C: EC0C6838  fmsubs f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82325F90: D01F0424  stfs f0, 0x424(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1060 as u32), tmp.u32 ) };
	// 82325F94: 4800003D  bl 0x82325fd0
	ctx.lr = 0x82325F98;
	sub_82325FD0(ctx, base);
	// 82325F98: 815F0394  lwz r10, 0x394(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 82325F9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82325FA0: D3FF0430  stfs f31, 0x430(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	// 82325FA4: D3CA0000  stfs f30, 0(r10)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82325FA8: 917F0434  stw r11, 0x434(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1076 as u32), ctx.r[11].u32 ) };
	// 82325FAC: 917F0438  stw r11, 0x438(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), ctx.r[11].u32 ) };
	// 82325FB0: 917F0458  stw r11, 0x458(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1112 as u32), ctx.r[11].u32 ) };
	// 82325FB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82325FB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82325FBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82325FC0: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82325FC4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82325FC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82325FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82325FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82325FD0 size=180
    let mut pc: u32 = 0x82325FD0;
    'dispatch: loop {
        match pc {
            0x82325FD0 => {
    //   block [0x82325FD0..0x82326020)
	// 82325FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82325FD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82325FD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82325FDC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82325FE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82325FE4: 4820D22D  bl 0x82533210
	ctx.lr = 0x82325FE8;
	sub_82533210(ctx, base);
	// 82325FE8: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82325FEC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82325FF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82325FF4: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82325FF8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82325FFC: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82326000: C00B206C  lfs f0, 0x206c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326004: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326008: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232600C: C1AB20C8  lfs f13, 0x20c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326010: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82326014: 4099000C  ble cr6, 0x82326020
	if !ctx.cr[6].gt {
	pc = 0x82326020; continue 'dispatch;
	}
	// 82326018: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8232601C: 4800004C  b 0x82326068
	pc = 0x82326068; continue 'dispatch;
            }
            0x82326020 => {
    //   block [0x82326020..0x82326038)
	// 82326020: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82326024: C1ABD218  lfs f13, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326028: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232602C: 4099000C  ble cr6, 0x82326038
	if !ctx.cr[6].gt {
	pc = 0x82326038; continue 'dispatch;
	}
	// 82326030: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82326034: 48000034  b 0x82326068
	pc = 0x82326068; continue 'dispatch;
            }
            0x82326038 => {
    //   block [0x82326038..0x82326050)
	// 82326038: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232603C: C1ABD6C8  lfs f13, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326040: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82326044: 4099000C  ble cr6, 0x82326050
	if !ctx.cr[6].gt {
	pc = 0x82326050; continue 'dispatch;
	}
	// 82326048: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8232604C: 4800001C  b 0x82326068
	pc = 0x82326068; continue 'dispatch;
            }
            0x82326050 => {
    //   block [0x82326050..0x82326068)
	// 82326050: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82326054: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82326058: C1ABD4DC  lfs f13, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232605C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82326060: 41990008  bgt cr6, 0x82326068
	if ctx.cr[6].gt {
	pc = 0x82326068; continue 'dispatch;
	}
	// 82326064: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	pc = 0x82326068; continue 'dispatch;
            }
            0x82326068 => {
    //   block [0x82326068..0x82326084)
	// 82326068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232606C: 4800014D  bl 0x823261b8
	ctx.lr = 0x82326070;
	sub_823261B8(ctx, base);
	// 82326070: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82326074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82326078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232607C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82326080: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82326088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82326088 size=300
    let mut pc: u32 = 0x82326088;
    'dispatch: loop {
        match pc {
            0x82326088 => {
    //   block [0x82326088..0x823260D8)
	// 82326088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232608C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82326090: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82326094: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 82326098: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 8232609C: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 823260A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823260A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823260A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823260AC: C3AB1FF8  lfs f29, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 823260B0: FF01E800  fcmpu cr6, f1, f29
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 823260B4: 41990024  bgt cr6, 0x823260d8
	if ctx.cr[6].gt {
	pc = 0x823260D8; continue 'dispatch;
	}
	// 823260B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823260BC: C1BF0430  lfs f13, 0x430(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1072 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823260C0: C00B268C  lfs f0, 0x268c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9868 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823260C4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823260C8: D01F0430  stfs f0, 0x430(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	// 823260CC: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 823260D0: 40980008  bge cr6, 0x823260d8
	if !ctx.cr[6].lt {
	pc = 0x823260D8; continue 'dispatch;
	}
	// 823260D4: D3BF0430  stfs f29, 0x430(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	pc = 0x823260D8; continue 'dispatch;
            }
            0x823260D8 => {
    //   block [0x823260D8..0x82326100)
	// 823260D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823260DC: C01F0430  lfs f0, 0x430(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1072 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823260E0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823260E4: C1AB2688  lfs f13, 0x2688(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823260E8: 40990018  ble cr6, 0x82326100
	if !ctx.cr[6].gt {
	pc = 0x82326100; continue 'dispatch;
	}
	// 823260EC: EC01037A  fmadds f0, f1, f13, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 823260F0: D01F0430  stfs f0, 0x430(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	// 823260F4: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 823260F8: 41980008  blt cr6, 0x82326100
	if ctx.cr[6].lt {
	pc = 0x82326100; continue 'dispatch;
	}
	// 823260FC: D03F0430  stfs f1, 0x430(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	pc = 0x82326100; continue 'dispatch;
            }
            0x82326100 => {
    //   block [0x82326100..0x82326120)
	// 82326100: C01F0430  lfs f0, 0x430(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1072 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326104: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82326108: 40980018  bge cr6, 0x82326120
	if !ctx.cr[6].lt {
	pc = 0x82326120; continue 'dispatch;
	}
	// 8232610C: EC01037C  fnmsubs f0, f1, f13, f0
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82326110: D01F0430  stfs f0, 0x430(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	// 82326114: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82326118: 41990008  bgt cr6, 0x82326120
	if ctx.cr[6].gt {
	pc = 0x82326120; continue 'dispatch;
	}
	// 8232611C: D03F0430  stfs f1, 0x430(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	pc = 0x82326120; continue 'dispatch;
            }
            0x82326120 => {
    //   block [0x82326120..0x823261B4)
	// 82326120: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326124: C3DF0430  lfs f30, 0x430(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1072 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82326128: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232612C: EFE20032  fmuls f31, f2, f0
	ctx.f[31].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82326130: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82326134: 4BDF7395  bl 0x8211d4c8
	ctx.lr = 0x82326138;
	sub_8211D4C8(ctx, base);
	// 82326138: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8232613C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82326140: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82326144: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82326148: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8232614C: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82326150: 614A85D4  ori r10, r10, 0x85d4
	ctx.r[10].u64 = ctx.r[10].u64 | 34260;
	// 82326154: 7FEB542E  lfsx f31, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82326158: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8232615C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82326160: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82326164: 4BE2D155  bl 0x821532b8
	ctx.lr = 0x82326168;
	sub_821532B8(ctx, base);
	// 82326168: EC0107B2  fmuls f0, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8232616C: 397F0410  addi r11, r31, 0x410
	ctx.r[11].s64 = ctx.r[31].s64 + 1040;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823261B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823261B8 size=1808
    let mut pc: u32 = 0x823261B8;
    'dispatch: loop {
        match pc {
            0x823261B8 => {
    //   block [0x823261B8..0x82326220)
	// 823261B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823261BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823261C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823261C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823261C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823261CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823261D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823261D4: 2B1E000A  cmplwi cr6, r30, 0xa
	ctx.cr[6].compare_u32(ctx.r[30].u32, 10 as u32, &mut ctx.xer);
	// 823261D8: 419906C4  bgt cr6, 0x8232689c
	if ctx.cr[6].gt {
	pc = 0x8232689C; continue 'dispatch;
	}
	// 823261DC: 3D808232  lis r12, -0x7dce
	ctx.r[12].s64 = -2110652416;
	// 823261E0: 398C61F4  addi r12, r12, 0x61f4
	ctx.r[12].s64 = ctx.r[12].s64 + 25076;
	// 823261E4: 57C0103A  slwi r0, r30, 2
	ctx.r[0].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 823261E8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 823261EC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 823261F0: 4E800420  bctr
	match ctx.r[30].u64 {
		0 => {
	pc = 0x82326220; continue 'dispatch;
		},
		1 => {
	pc = 0x823262DC; continue 'dispatch;
		},
		2 => {
	pc = 0x823263A0; continue 'dispatch;
		},
		3 => {
	pc = 0x82326464; continue 'dispatch;
		},
		4 => {
	pc = 0x82326464; continue 'dispatch;
		},
		5 => {
	pc = 0x82326528; continue 'dispatch;
		},
		6 => {
	pc = 0x82326528; continue 'dispatch;
		},
		7 => {
	pc = 0x823265EC; continue 'dispatch;
		},
		8 => {
	pc = 0x823266A8; continue 'dispatch;
		},
		9 => {
	pc = 0x82326794; continue 'dispatch;
		},
		10 => {
	pc = 0x823267B0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 823261F4: 82326220  lwz r17, 0x6220(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(25120 as u32) ) } as u64;
	// 823261F8: 823262DC  lwz r17, 0x62dc(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(25308 as u32) ) } as u64;
	// 823261FC: 823263A0  lwz r17, 0x63a0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(25504 as u32) ) } as u64;
	// 82326200: 82326464  lwz r17, 0x6464(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(25700 as u32) ) } as u64;
	// 82326204: 82326464  lwz r17, 0x6464(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(25700 as u32) ) } as u64;
	// 82326208: 82326528  lwz r17, 0x6528(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(25896 as u32) ) } as u64;
	// 8232620C: 82326528  lwz r17, 0x6528(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(25896 as u32) ) } as u64;
	// 82326210: 823265EC  lwz r17, 0x65ec(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(26092 as u32) ) } as u64;
	// 82326214: 823266A8  lwz r17, 0x66a8(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(26280 as u32) ) } as u64;
	// 82326218: 82326794  lwz r17, 0x6794(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(26516 as u32) ) } as u64;
	// 8232621C: 823267B0  lwz r17, 0x67b0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(26544 as u32) ) } as u64;
            }
            0x82326220 => {
    //   block [0x82326220..0x82326288)
	// 82326220: 397F00B0  addi r11, r31, 0xb0
	ctx.r[11].s64 = ctx.r[31].s64 + 176;
	// 82326224: 814B02A0  lwz r10, 0x2a0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(672 as u32) ) } as u64;
	// 82326228: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8232622C: 419A009C  beq cr6, 0x823262c8
	if ctx.cr[6].eq {
	pc = 0x823262C8; continue 'dispatch;
	}
	// 82326230: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82326234: C1AB02A4  lfs f13, 0x2a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(676 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326238: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8232623C: C18B02A8  lfs f12, 0x2a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(680 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82326240: C16B02AC  lfs f11, 0x2ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(684 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82326244: 914B02B8  stw r10, 0x2b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(696 as u32), ctx.r[10].u32 ) };
	// 82326248: D1AB02BC  stfs f13, 0x2bc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(700 as u32), tmp.u32 ) };
	// 8232624C: D18B02C0  stfs f12, 0x2c0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(704 as u32), tmp.u32 ) };
	// 82326250: C009D6E8  lfs f0, -0x2918(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326254: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82326258: D00B02B4  stfs f0, 0x2b4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(692 as u32), tmp.u32 ) };
	// 8232625C: 910B02A0  stw r8, 0x2a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(672 as u32), ctx.r[8].u32 ) };
	// 82326260: D16B02C4  stfs f11, 0x2c4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(708 as u32), tmp.u32 ) };
	// 82326264: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 82326268: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232626C: C0091FF8  lfs f0, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326270: 419A0018  beq cr6, 0x82326288
	if ctx.cr[6].eq {
	pc = 0x82326288; continue 'dispatch;
	}
	// 82326274: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82326278: 910B0298  stw r8, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[8].u32 ) };
	// 8232627C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82326280: 41990010  bgt cr6, 0x82326290
	if ctx.cr[6].gt {
	pc = 0x82326290; continue 'dispatch;
	}
	// 82326284: 48000008  b 0x8232628c
	pc = 0x8232628C; continue 'dispatch;
            }
            0x82326288 => {
    //   block [0x82326288..0x8232628C)
	// 82326288: 910B0298  stw r8, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[8].u32 ) };
	pc = 0x8232628C; continue 'dispatch;
            }
            0x8232628C => {
    //   block [0x8232628C..0x82326290)
	// 8232628C: D00B029C  stfs f0, 0x29c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), tmp.u32 ) };
	pc = 0x82326290; continue 'dispatch;
            }
            0x82326290 => {
    //   block [0x82326290..0x823262C8)
	// 82326290: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 82326294: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82326298: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8232629C: D00B02A4  stfs f0, 0x2a4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(676 as u32), tmp.u32 ) };
	// 823262A0: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823262A4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 823262A8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 823262AC: 394ABA44  addi r10, r10, -0x45bc
	ctx.r[10].s64 = ctx.r[10].s64 + -17852;
	// 823262B0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823262B4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823262B8: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823262BC: C00AFFF4  lfs f0, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823262C0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823262C4: D00B02A8  stfs f0, 0x2a8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(680 as u32), tmp.u32 ) };
	pc = 0x823262C8; continue 'dispatch;
            }
            0x823262C8 => {
    //   block [0x823262C8..0x823262DC)
	// 823262C8: C01F03EC  lfs f0, 0x3ec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1004 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823262CC: C1BF0358  lfs f13, 0x358(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(856 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823262D0: D01F035C  stfs f0, 0x35c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(860 as u32), tmp.u32 ) };
	// 823262D4: D1BF0404  stfs f13, 0x404(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 823262D8: 480005C4  b 0x8232689c
	pc = 0x8232689C; continue 'dispatch;
            }
            0x823262DC => {
    //   block [0x823262DC..0x8232634C)
	// 823262DC: 397F00B0  addi r11, r31, 0xb0
	ctx.r[11].s64 = ctx.r[31].s64 + 176;
	// 823262E0: 814B02A0  lwz r10, 0x2a0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(672 as u32) ) } as u64;
	// 823262E4: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 823262E8: 419A00A4  beq cr6, 0x8232638c
	if ctx.cr[6].eq {
	pc = 0x8232638C; continue 'dispatch;
	}
	// 823262EC: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 823262F0: C1AB02A4  lfs f13, 0x2a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(676 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823262F4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823262F8: C18B02A8  lfs f12, 0x2a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(680 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823262FC: C16B02AC  lfs f11, 0x2ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(684 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82326300: 914B02B8  stw r10, 0x2b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(696 as u32), ctx.r[10].u32 ) };
	// 82326304: D1AB02BC  stfs f13, 0x2bc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(700 as u32), tmp.u32 ) };
	// 82326308: D18B02C0  stfs f12, 0x2c0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(704 as u32), tmp.u32 ) };
	// 8232630C: C009D6E8  lfs f0, -0x2918(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326310: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82326314: D00B02B4  stfs f0, 0x2b4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(692 as u32), tmp.u32 ) };
	// 82326318: 910B02A0  stw r8, 0x2a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(672 as u32), ctx.r[8].u32 ) };
	// 8232631C: D16B02C4  stfs f11, 0x2c4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(708 as u32), tmp.u32 ) };
	// 82326320: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 82326324: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82326328: C0091FF8  lfs f0, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232632C: 419A0020  beq cr6, 0x8232634c
	if ctx.cr[6].eq {
	pc = 0x8232634C; continue 'dispatch;
	}
	// 82326330: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82326334: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82326338: 41990018  bgt cr6, 0x82326350
	if ctx.cr[6].gt {
	pc = 0x82326350; continue 'dispatch;
	}
	// 8232633C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82326340: D00B029C  stfs f0, 0x29c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82326344: 914B0298  stw r10, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[10].u32 ) };
	// 82326348: 4800000C  b 0x82326354
	pc = 0x82326354; continue 'dispatch;
            }
            0x8232634C => {
    //   block [0x8232634C..0x82326350)
	// 8232634C: D00B029C  stfs f0, 0x29c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), tmp.u32 ) };
	pc = 0x82326350; continue 'dispatch;
            }
            0x82326350 => {
    //   block [0x82326350..0x82326354)
	// 82326350: 910B0298  stw r8, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[8].u32 ) };
	pc = 0x82326354; continue 'dispatch;
            }
            0x82326354 => {
    //   block [0x82326354..0x8232638C)
	// 82326354: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 82326358: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8232635C: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82326360: D00B02A4  stfs f0, 0x2a4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(676 as u32), tmp.u32 ) };
	// 82326364: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82326368: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 8232636C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82326370: 394ABA44  addi r10, r10, -0x45bc
	ctx.r[10].s64 = ctx.r[10].s64 + -17852;
	// 82326374: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82326378: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8232637C: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82326380: C00AFFF4  lfs f0, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326384: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82326388: D00B02A8  stfs f0, 0x2a8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(680 as u32), tmp.u32 ) };
	pc = 0x8232638C; continue 'dispatch;
            }
            0x8232638C => {
    //   block [0x8232638C..0x823263A0)
	// 8232638C: C01F03F0  lfs f0, 0x3f0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326390: C1BF0358  lfs f13, 0x358(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(856 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326394: D01F035C  stfs f0, 0x35c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(860 as u32), tmp.u32 ) };
	// 82326398: D1BF0404  stfs f13, 0x404(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 8232639C: 48000500  b 0x8232689c
	pc = 0x8232689C; continue 'dispatch;
            }
            0x823263A0 => {
    //   block [0x823263A0..0x82326404)
	// 823263A0: 397F00B0  addi r11, r31, 0xb0
	ctx.r[11].s64 = ctx.r[31].s64 + 176;
	// 823263A4: 812B02A0  lwz r9, 0x2a0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(672 as u32) ) } as u64;
	// 823263A8: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 823263AC: 419A0098  beq cr6, 0x82326444
	if ctx.cr[6].eq {
	pc = 0x82326444; continue 'dispatch;
	}
	// 823263B0: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 823263B4: C1AB02A4  lfs f13, 0x2a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(676 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823263B8: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 823263BC: C18B02A8  lfs f12, 0x2a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(680 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823263C0: C16B02AC  lfs f11, 0x2ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(684 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823263C4: 912B02B8  stw r9, 0x2b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(696 as u32), ctx.r[9].u32 ) };
	// 823263C8: D1AB02BC  stfs f13, 0x2bc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(700 as u32), tmp.u32 ) };
	// 823263CC: D18B02C0  stfs f12, 0x2c0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(704 as u32), tmp.u32 ) };
	// 823263D0: C008D6E8  lfs f0, -0x2918(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823263D4: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 823263D8: D00B02B4  stfs f0, 0x2b4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(692 as u32), tmp.u32 ) };
	// 823263DC: 914B02A0  stw r10, 0x2a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(672 as u32), ctx.r[10].u32 ) };
	// 823263E0: D16B02C4  stfs f11, 0x2c4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(708 as u32), tmp.u32 ) };
	// 823263E4: 812B0294  lwz r9, 0x294(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 823263E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823263EC: C0081FF8  lfs f0, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823263F0: 419A0014  beq cr6, 0x82326404
	if ctx.cr[6].eq {
	pc = 0x82326404; continue 'dispatch;
	}
	// 823263F4: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823263F8: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 823263FC: 4199000C  bgt cr6, 0x82326408
	if ctx.cr[6].gt {
	pc = 0x82326408; continue 'dispatch;
	}
	// 82326400: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82326404; continue 'dispatch;
            }
            0x82326404 => {
    //   block [0x82326404..0x82326408)
	// 82326404: D00B029C  stfs f0, 0x29c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), tmp.u32 ) };
	pc = 0x82326408; continue 'dispatch;
            }
            0x82326408 => {
    //   block [0x82326408..0x82326444)
	// 82326408: 914B0298  stw r10, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[10].u32 ) };
	// 8232640C: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 82326410: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82326414: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82326418: D00B02A4  stfs f0, 0x2a4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(676 as u32), tmp.u32 ) };
	// 8232641C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82326420: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82326424: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82326428: 394ABA44  addi r10, r10, -0x45bc
	ctx.r[10].s64 = ctx.r[10].s64 + -17852;
	// 8232642C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82326430: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82326434: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82326438: C00AFFF4  lfs f0, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232643C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82326440: D00B02A8  stfs f0, 0x2a8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(680 as u32), tmp.u32 ) };
	pc = 0x82326444; continue 'dispatch;
            }
            0x82326444 => {
    //   block [0x82326444..0x82326464)
	// 82326444: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326448: C1BF0358  lfs f13, 0x358(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(856 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232644C: C19F03F4  lfs f12, 0x3f4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82326450: D19F035C  stfs f12, 0x35c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(860 as u32), tmp.u32 ) };
	// 82326454: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326458: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232645C: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82326460: 4800043C  b 0x8232689c
	pc = 0x8232689C; continue 'dispatch;
            }
            0x82326464 => {
    //   block [0x82326464..0x823264C8)
	// 82326464: 397F00B0  addi r11, r31, 0xb0
	ctx.r[11].s64 = ctx.r[31].s64 + 176;
	// 82326468: 812B02A0  lwz r9, 0x2a0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(672 as u32) ) } as u64;
	// 8232646C: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 82326470: 419A0098  beq cr6, 0x82326508
	if ctx.cr[6].eq {
	pc = 0x82326508; continue 'dispatch;
	}
	// 82326474: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 82326478: C1AB02A4  lfs f13, 0x2a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(676 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232647C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82326480: C18B02A8  lfs f12, 0x2a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(680 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82326484: C16B02AC  lfs f11, 0x2ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(684 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82326488: 912B02B8  stw r9, 0x2b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(696 as u32), ctx.r[9].u32 ) };
	// 8232648C: D1AB02BC  stfs f13, 0x2bc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(700 as u32), tmp.u32 ) };
	// 82326490: D18B02C0  stfs f12, 0x2c0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(704 as u32), tmp.u32 ) };
	// 82326494: C008D6E8  lfs f0, -0x2918(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326498: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8232649C: D00B02B4  stfs f0, 0x2b4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(692 as u32), tmp.u32 ) };
	// 823264A0: 914B02A0  stw r10, 0x2a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(672 as u32), ctx.r[10].u32 ) };
	// 823264A4: D16B02C4  stfs f11, 0x2c4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(708 as u32), tmp.u32 ) };
	// 823264A8: 812B0294  lwz r9, 0x294(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 823264AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823264B0: C0081FF8  lfs f0, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823264B4: 419A0014  beq cr6, 0x823264c8
	if ctx.cr[6].eq {
	pc = 0x823264C8; continue 'dispatch;
	}
	// 823264B8: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823264BC: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 823264C0: 4199000C  bgt cr6, 0x823264cc
	if ctx.cr[6].gt {
	pc = 0x823264CC; continue 'dispatch;
	}
	// 823264C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x823264C8; continue 'dispatch;
            }
            0x823264C8 => {
    //   block [0x823264C8..0x823264CC)
	// 823264C8: D00B029C  stfs f0, 0x29c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), tmp.u32 ) };
	pc = 0x823264CC; continue 'dispatch;
            }
            0x823264CC => {
    //   block [0x823264CC..0x82326508)
	// 823264CC: 914B0298  stw r10, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[10].u32 ) };
	// 823264D0: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 823264D4: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 823264D8: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823264DC: D00B02A4  stfs f0, 0x2a4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(676 as u32), tmp.u32 ) };
	// 823264E0: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823264E4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 823264E8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 823264EC: 394ABA44  addi r10, r10, -0x45bc
	ctx.r[10].s64 = ctx.r[10].s64 + -17852;
	// 823264F0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823264F4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823264F8: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823264FC: C00AFFF4  lfs f0, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326500: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82326504: D00B02A8  stfs f0, 0x2a8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(680 as u32), tmp.u32 ) };
	pc = 0x82326508; continue 'dispatch;
            }
            0x82326508 => {
    //   block [0x82326508..0x82326528)
	// 82326508: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232650C: C1BF0358  lfs f13, 0x358(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(856 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326510: C19F03F4  lfs f12, 0x3f4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82326514: D19F035C  stfs f12, 0x35c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(860 as u32), tmp.u32 ) };
	// 82326518: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232651C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82326520: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82326524: 48000378  b 0x8232689c
	pc = 0x8232689C; continue 'dispatch;
            }
            0x82326528 => {
    //   block [0x82326528..0x8232658C)
	// 82326528: 397F00B0  addi r11, r31, 0xb0
	ctx.r[11].s64 = ctx.r[31].s64 + 176;
	// 8232652C: 812B02A0  lwz r9, 0x2a0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(672 as u32) ) } as u64;
	// 82326530: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 82326534: 419A0098  beq cr6, 0x823265cc
	if ctx.cr[6].eq {
	pc = 0x823265CC; continue 'dispatch;
	}
	// 82326538: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 8232653C: C1AB02A4  lfs f13, 0x2a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(676 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326540: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82326544: C18B02A8  lfs f12, 0x2a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(680 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82326548: C16B02AC  lfs f11, 0x2ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(684 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232654C: 912B02B8  stw r9, 0x2b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(696 as u32), ctx.r[9].u32 ) };
	// 82326550: D1AB02BC  stfs f13, 0x2bc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(700 as u32), tmp.u32 ) };
	// 82326554: D18B02C0  stfs f12, 0x2c0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(704 as u32), tmp.u32 ) };
	// 82326558: C008D6E8  lfs f0, -0x2918(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232655C: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82326560: D00B02B4  stfs f0, 0x2b4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(692 as u32), tmp.u32 ) };
	// 82326564: 914B02A0  stw r10, 0x2a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(672 as u32), ctx.r[10].u32 ) };
	// 82326568: D16B02C4  stfs f11, 0x2c4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(708 as u32), tmp.u32 ) };
	// 8232656C: 812B0294  lwz r9, 0x294(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 82326570: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82326574: C0081FF8  lfs f0, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326578: 419A0014  beq cr6, 0x8232658c
	if ctx.cr[6].eq {
	pc = 0x8232658C; continue 'dispatch;
	}
	// 8232657C: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82326580: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 82326584: 4199000C  bgt cr6, 0x82326590
	if ctx.cr[6].gt {
	pc = 0x82326590; continue 'dispatch;
	}
	// 82326588: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8232658C; continue 'dispatch;
            }
            0x8232658C => {
    //   block [0x8232658C..0x82326590)
	// 8232658C: D00B029C  stfs f0, 0x29c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), tmp.u32 ) };
	pc = 0x82326590; continue 'dispatch;
            }
            0x82326590 => {
    //   block [0x82326590..0x823265CC)
	// 82326590: 914B0298  stw r10, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[10].u32 ) };
	// 82326594: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 82326598: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232659C: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823265A0: D00B02A4  stfs f0, 0x2a4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(676 as u32), tmp.u32 ) };
	// 823265A4: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823265A8: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 823265AC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 823265B0: 394ABA44  addi r10, r10, -0x45bc
	ctx.r[10].s64 = ctx.r[10].s64 + -17852;
	// 823265B4: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823265B8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823265BC: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823265C0: C00AFFF4  lfs f0, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823265C4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823265C8: D00B02A8  stfs f0, 0x2a8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(680 as u32), tmp.u32 ) };
	pc = 0x823265CC; continue 'dispatch;
            }
            0x823265CC => {
    //   block [0x823265CC..0x823265EC)
	// 823265CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823265D0: C1BF03F4  lfs f13, 0x3f4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823265D4: C19F0424  lfs f12, 0x424(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1060 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823265D8: D1BF035C  stfs f13, 0x35c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(860 as u32), tmp.u32 ) };
	// 823265DC: D19F044C  stfs f12, 0x44c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1100 as u32), tmp.u32 ) };
	// 823265E0: C00B2818  lfs f0, 0x2818(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823265E4: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 823265E8: 480002B4  b 0x8232689c
	pc = 0x8232689C; continue 'dispatch;
            }
            0x823265EC => {
    //   block [0x823265EC..0x8232665C)
	// 823265EC: 397F00B0  addi r11, r31, 0xb0
	ctx.r[11].s64 = ctx.r[31].s64 + 176;
	// 823265F0: 814B02A0  lwz r10, 0x2a0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(672 as u32) ) } as u64;
	// 823265F4: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 823265F8: 419A00A4  beq cr6, 0x8232669c
	if ctx.cr[6].eq {
	pc = 0x8232669C; continue 'dispatch;
	}
	// 823265FC: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82326600: C1AB02A4  lfs f13, 0x2a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(676 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326604: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 82326608: C18B02A8  lfs f12, 0x2a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(680 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232660C: C16B02AC  lfs f11, 0x2ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(684 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82326610: 914B02B8  stw r10, 0x2b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(696 as u32), ctx.r[10].u32 ) };
	// 82326614: D1AB02BC  stfs f13, 0x2bc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(700 as u32), tmp.u32 ) };
	// 82326618: D18B02C0  stfs f12, 0x2c0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(704 as u32), tmp.u32 ) };
	// 8232661C: C009D6E8  lfs f0, -0x2918(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326620: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82326624: D00B02B4  stfs f0, 0x2b4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(692 as u32), tmp.u32 ) };
	// 82326628: 910B02A0  stw r8, 0x2a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(672 as u32), ctx.r[8].u32 ) };
	// 8232662C: D16B02C4  stfs f11, 0x2c4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(708 as u32), tmp.u32 ) };
	// 82326630: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 82326634: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82326638: C0091FF8  lfs f0, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232663C: 419A0020  beq cr6, 0x8232665c
	if ctx.cr[6].eq {
	pc = 0x8232665C; continue 'dispatch;
	}
	// 82326640: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82326644: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 82326648: 41990018  bgt cr6, 0x82326660
	if ctx.cr[6].gt {
	pc = 0x82326660; continue 'dispatch;
	}
	// 8232664C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82326650: D00B029C  stfs f0, 0x29c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82326654: 914B0298  stw r10, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[10].u32 ) };
	// 82326658: 4800000C  b 0x82326664
	pc = 0x82326664; continue 'dispatch;
            }
            0x8232665C => {
    //   block [0x8232665C..0x82326660)
	// 8232665C: D00B029C  stfs f0, 0x29c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), tmp.u32 ) };
	pc = 0x82326660; continue 'dispatch;
            }
            0x82326660 => {
    //   block [0x82326660..0x82326664)
	// 82326660: 910B0298  stw r8, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[8].u32 ) };
	pc = 0x82326664; continue 'dispatch;
            }
            0x82326664 => {
    //   block [0x82326664..0x8232669C)
	// 82326664: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 82326668: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8232666C: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82326670: D00B02A4  stfs f0, 0x2a4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(676 as u32), tmp.u32 ) };
	// 82326674: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82326678: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 8232667C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82326680: 394ABA44  addi r10, r10, -0x45bc
	ctx.r[10].s64 = ctx.r[10].s64 + -17852;
	// 82326684: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82326688: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8232668C: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82326690: C00AFFF4  lfs f0, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326694: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82326698: D00B02A8  stfs f0, 0x2a8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(680 as u32), tmp.u32 ) };
	pc = 0x8232669C; continue 'dispatch;
            }
            0x8232669C => {
    //   block [0x8232669C..0x823266A8)
	// 8232669C: C01F03F8  lfs f0, 0x3f8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1016 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823266A0: D01F035C  stfs f0, 0x35c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(860 as u32), tmp.u32 ) };
	// 823266A4: 480001F8  b 0x8232689c
	pc = 0x8232689C; continue 'dispatch;
            }
            0x823266A8 => {
    //   block [0x823266A8..0x82326720)
	// 823266A8: 397F00B0  addi r11, r31, 0xb0
	ctx.r[11].s64 = ctx.r[31].s64 + 176;
	// 823266AC: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 823266B0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 823266B4: 38E9BA44  addi r7, r9, -0x45bc
	ctx.r[7].s64 = ctx.r[9].s64 + -17852;
	// 823266B8: 814B02A0  lwz r10, 0x2a0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(672 as u32) ) } as u64;
	// 823266BC: C1A8D6E8  lfs f13, -0x2918(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823266C0: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 823266C4: 419A0094  beq cr6, 0x82326758
	if ctx.cr[6].eq {
	pc = 0x82326758; continue 'dispatch;
	}
	// 823266C8: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 823266CC: C00B02A4  lfs f0, 0x2a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(676 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823266D0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823266D4: C18B02A8  lfs f12, 0x2a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(680 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823266D8: C16B02AC  lfs f11, 0x2ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(684 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823266DC: 914B02B8  stw r10, 0x2b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(696 as u32), ctx.r[10].u32 ) };
	// 823266E0: D00B02BC  stfs f0, 0x2bc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(700 as u32), tmp.u32 ) };
	// 823266E4: D1AB02B4  stfs f13, 0x2b4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(692 as u32), tmp.u32 ) };
	// 823266E8: D18B02C0  stfs f12, 0x2c0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(704 as u32), tmp.u32 ) };
	// 823266EC: 910B02A0  stw r8, 0x2a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(672 as u32), ctx.r[8].u32 ) };
	// 823266F0: D16B02C4  stfs f11, 0x2c4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(708 as u32), tmp.u32 ) };
	// 823266F4: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 823266F8: C0091FF8  lfs f0, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823266FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82326700: 419A0020  beq cr6, 0x82326720
	if ctx.cr[6].eq {
	pc = 0x82326720; continue 'dispatch;
	}
	// 82326704: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82326708: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 8232670C: 41990018  bgt cr6, 0x82326724
	if ctx.cr[6].gt {
	pc = 0x82326724; continue 'dispatch;
	}
	// 82326710: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82326714: D00B029C  stfs f0, 0x29c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82326718: 914B0298  stw r10, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[10].u32 ) };
	// 8232671C: 4800000C  b 0x82326728
	pc = 0x82326728; continue 'dispatch;
            }
            0x82326720 => {
    //   block [0x82326720..0x82326724)
	// 82326720: D00B029C  stfs f0, 0x29c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), tmp.u32 ) };
	pc = 0x82326724; continue 'dispatch;
            }
            0x82326724 => {
    //   block [0x82326724..0x82326728)
	// 82326724: 910B0298  stw r8, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[8].u32 ) };
	pc = 0x82326728; continue 'dispatch;
            }
            0x82326728 => {
    //   block [0x82326728..0x82326758)
	// 82326728: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 8232672C: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82326730: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82326734: D00B02A4  stfs f0, 0x2a4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(676 as u32), tmp.u32 ) };
	// 82326738: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8232673C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82326740: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82326744: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82326748: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8232674C: C007FFF4  lfs f0, -0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326750: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82326754: D00B02A8  stfs f0, 0x2a8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(680 as u32), tmp.u32 ) };
	pc = 0x82326758; continue 'dispatch;
            }
            0x82326758 => {
    //   block [0x82326758..0x82326794)
	// 82326758: C19F0358  lfs f12, 0x358(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(856 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232675C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326760: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82326764: C1A70000  lfs f13, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326768: C01F03FC  lfs f0, 0x3fc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1020 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232676C: D01F035C  stfs f0, 0x35c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(860 as u32), tmp.u32 ) };
	// 82326770: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82326774: D1BF0404  stfs f13, 0x404(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82326778: C1AB2054  lfs f13, 0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232677C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326780: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82326784: C00B228C  lfs f0, 0x228c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8844 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326788: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8232678C: D01F0440  stfs f0, 0x440(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1088 as u32), tmp.u32 ) };
	// 82326790: 4800010C  b 0x8232689c
	pc = 0x8232689C; continue 'dispatch;
            }
            0x82326794 => {
    //   block [0x82326794..0x823267B0)
	// 82326794: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326798: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232679C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 823267A0: D01F0430  stfs f0, 0x430(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	// 823267A4: C00BF3E8  lfs f0, -0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823267A8: D01F0444  stfs f0, 0x444(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1092 as u32), tmp.u32 ) };
	// 823267AC: 480000F0  b 0x8232689c
	pc = 0x8232689C; continue 'dispatch;
            }
            0x823267B0 => {
    //   block [0x823267B0..0x82326814)
	// 823267B0: 397F00B0  addi r11, r31, 0xb0
	ctx.r[11].s64 = ctx.r[31].s64 + 176;
	// 823267B4: 812B02A0  lwz r9, 0x2a0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(672 as u32) ) } as u64;
	// 823267B8: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 823267BC: 419A0098  beq cr6, 0x82326854
	if ctx.cr[6].eq {
	pc = 0x82326854; continue 'dispatch;
	}
	// 823267C0: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 823267C4: C1AB02A4  lfs f13, 0x2a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(676 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823267C8: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 823267CC: C18B02A8  lfs f12, 0x2a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(680 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823267D0: C16B02AC  lfs f11, 0x2ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(684 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823267D4: 912B02B8  stw r9, 0x2b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(696 as u32), ctx.r[9].u32 ) };
	// 823267D8: D1AB02BC  stfs f13, 0x2bc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(700 as u32), tmp.u32 ) };
	// 823267DC: D18B02C0  stfs f12, 0x2c0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(704 as u32), tmp.u32 ) };
	// 823267E0: C008D6E8  lfs f0, -0x2918(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823267E4: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 823267E8: D00B02B4  stfs f0, 0x2b4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(692 as u32), tmp.u32 ) };
	// 823267EC: 914B02A0  stw r10, 0x2a0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(672 as u32), ctx.r[10].u32 ) };
	// 823267F0: D16B02C4  stfs f11, 0x2c4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(708 as u32), tmp.u32 ) };
	// 823267F4: 812B0294  lwz r9, 0x294(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 823267F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823267FC: C0081FF8  lfs f0, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326800: 419A0014  beq cr6, 0x82326814
	if ctx.cr[6].eq {
	pc = 0x82326814; continue 'dispatch;
	}
	// 82326804: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82326808: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 8232680C: 4199000C  bgt cr6, 0x82326818
	if ctx.cr[6].gt {
	pc = 0x82326818; continue 'dispatch;
	}
	// 82326810: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82326814; continue 'dispatch;
            }
            0x82326814 => {
    //   block [0x82326814..0x82326818)
	// 82326814: D00B029C  stfs f0, 0x29c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), tmp.u32 ) };
	pc = 0x82326818; continue 'dispatch;
            }
            0x82326818 => {
    //   block [0x82326818..0x82326854)
	// 82326818: 914B0298  stw r10, 0x298(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(664 as u32), ctx.r[10].u32 ) };
	// 8232681C: 814B0294  lwz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 82326820: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82326824: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82326828: D00B02A4  stfs f0, 0x2a4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(676 as u32), tmp.u32 ) };
	// 8232682C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82326830: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82326834: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82326838: 394ABA44  addi r10, r10, -0x45bc
	ctx.r[10].s64 = ctx.r[10].s64 + -17852;
	// 8232683C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82326840: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82326844: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82326848: C00AFFF4  lfs f0, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232684C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82326850: D00B02A8  stfs f0, 0x2a8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(680 as u32), tmp.u32 ) };
	pc = 0x82326854; continue 'dispatch;
            }
            0x82326854 => {
    //   block [0x82326854..0x8232689C)
	// 82326854: C01F03F4  lfs f0, 0x3f4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326858: D01F035C  stfs f0, 0x35c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(860 as u32), tmp.u32 ) };
	// 8232685C: 4820C9B5  bl 0x82533210
	ctx.lr = 0x82326860;
	sub_82533210(ctx, base);
	// 82326860: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326864: 546A047E  clrlwi r10, r3, 0x11
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82326868: C00B2144  lfs f0, 0x2144(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232686C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82326870: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82326874: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326878: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8232687C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82326880: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82326884: C1AB206C  lfs f13, 0x206c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8300 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326888: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232688C: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82326890: C1AB20A0  lfs f13, 0x20a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8352 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326894: EC0C6838  fmsubs f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82326898: D01F0424  stfs f0, 0x424(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1060 as u32), tmp.u32 ) };
	pc = 0x8232689C; continue 'dispatch;
            }
            0x8232689C => {
    //   block [0x8232689C..0x823268C8)
	// 8232689C: C01F0404  lfs f0, 0x404(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823268A0: 93DF0400  stw r30, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[30].u32 ) };
	// 823268A4: C1BF035C  lfs f13, 0x35c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(860 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823268A8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823268AC: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 823268B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823268B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823268B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823268BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823268C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823268C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823268C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823268C8 size=380
    let mut pc: u32 = 0x823268C8;
    'dispatch: loop {
        match pc {
            0x823268C8 => {
    //   block [0x823268C8..0x82326A44)
	// 823268C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823268CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823268D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823268D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823268D8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 823268DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823268E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823268E4: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 823268E8: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 823268EC: 3BFE03A0  addi r31, r30, 0x3a0
	ctx.r[31].s64 = ctx.r[30].s64 + 928;
	// 823268F0: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 823268F4: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 823268F8: 3D603F80  lis r11, 0x3f80
	ctx.r[11].s64 = 1065353216;
	// 823268FC: 38BE0410  addi r5, r30, 0x410
	ctx.r[5].s64 = ctx.r[30].s64 + 1040;
	// 82326900: 389E0420  addi r4, r30, 0x420
	ctx.r[4].s64 = ctx.r[30].s64 + 1056;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82326A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82326A48 size=328
    let mut pc: u32 = 0x82326A48;
    'dispatch: loop {
        match pc {
            0x82326A48 => {
    //   block [0x82326A48..0x82326A64)
	// 82326A48: 81430394  lwz r10, 0x394(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(916 as u32) ) } as u64;
	// 82326A4C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326A50: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326A54: C14B1FF8  lfs f10, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82326A58: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82326A5C: 40980008  bge cr6, 0x82326a64
	if !ctx.cr[6].lt {
	pc = 0x82326A64; continue 'dispatch;
	}
	// 82326A60: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82326A64; continue 'dispatch;
            }
            0x82326A64 => {
    //   block [0x82326A64..0x82326AD0)
	// 82326A64: 81630438  lwz r11, 0x438(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1080 as u32) ) } as u64;
	// 82326A68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82326A6C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82326A70: C12BBA38  lfs f9, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82326A74: 409A00CC  bne cr6, 0x82326b40
	if !ctx.cr[6].eq {
	pc = 0x82326B40; continue 'dispatch;
	}
	// 82326A78: 8163043C  lwz r11, 0x43c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1084 as u32) ) } as u64;
	// 82326A7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82326A80: 409A00C0  bne cr6, 0x82326b40
	if !ctx.cr[6].eq {
	pc = 0x82326B40; continue 'dispatch;
	}
	// 82326A84: 81630434  lwz r11, 0x434(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1076 as u32) ) } as u64;
	// 82326A88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82326A8C: 419A007C  beq cr6, 0x82326b08
	if ctx.cr[6].eq {
	pc = 0x82326B08; continue 'dispatch;
	}
	// 82326A90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326A94: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326A98: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82326A9C: 40990034  ble cr6, 0x82326ad0
	if !ctx.cr[6].gt {
	pc = 0x82326AD0; continue 'dispatch;
	}
	// 82326AA0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82326AA4: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 82326AA8: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82326AAC: 612985D4  ori r9, r9, 0x85d4
	ctx.r[9].u64 = ctx.r[9].u64 | 34260;
	// 82326AB0: 7D8B4C2E  lfsx f12, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82326AB4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326AB8: C16B212C  lfs f11, 0x212c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8492 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82326ABC: EC0C02FC  fnmsubs f0, f12, f11, f0
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82326AC0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82326AC4: 409800B0  bge cr6, 0x82326b74
	if !ctx.cr[6].lt {
	pc = 0x82326B74; continue 'dispatch;
	}
	// 82326AC8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82326ACC: 480000A8  b 0x82326b74
	pc = 0x82326B74; continue 'dispatch;
            }
            0x82326AD0 => {
    //   block [0x82326AD0..0x82326B08)
	// 82326AD0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82326AD4: 409800A0  bge cr6, 0x82326b74
	if !ctx.cr[6].lt {
	pc = 0x82326B74; continue 'dispatch;
	}
	// 82326AD8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82326ADC: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 82326AE0: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82326AE4: 612985D4  ori r9, r9, 0x85d4
	ctx.r[9].u64 = ctx.r[9].u64 | 34260;
	// 82326AE8: 7D8B4C2E  lfsx f12, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82326AEC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326AF0: C16B212C  lfs f11, 0x212c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8492 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82326AF4: EC0C02FA  fmadds f0, f12, f11, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82326AF8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82326AFC: 40990078  ble cr6, 0x82326b74
	if !ctx.cr[6].gt {
	pc = 0x82326B74; continue 'dispatch;
	}
	// 82326B00: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82326B04: 48000070  b 0x82326b74
	pc = 0x82326B74; continue 'dispatch;
            }
            0x82326B08 => {
    //   block [0x82326B08..0x82326B40)
	// 82326B08: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82326B0C: 40980068  bge cr6, 0x82326b74
	if !ctx.cr[6].lt {
	pc = 0x82326B74; continue 'dispatch;
	}
	// 82326B10: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82326B14: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 82326B18: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82326B1C: 612985D4  ori r9, r9, 0x85d4
	ctx.r[9].u64 = ctx.r[9].u64 | 34260;
	// 82326B20: 7DAB4C2E  lfsx f13, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326B24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326B28: C18B212C  lfs f12, 0x212c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8492 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82326B2C: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82326B30: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82326B34: 40990040  ble cr6, 0x82326b74
	if !ctx.cr[6].gt {
	pc = 0x82326B74; continue 'dispatch;
	}
	// 82326B38: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82326B3C: 48000038  b 0x82326b74
	pc = 0x82326B74; continue 'dispatch;
            }
            0x82326B40 => {
    //   block [0x82326B40..0x82326B74)
	// 82326B40: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82326B44: 40990030  ble cr6, 0x82326b74
	if !ctx.cr[6].gt {
	pc = 0x82326B74; continue 'dispatch;
	}
	// 82326B48: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82326B4C: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 82326B50: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82326B54: 612985D4  ori r9, r9, 0x85d4
	ctx.r[9].u64 = ctx.r[9].u64 | 34260;
	// 82326B58: 7DAB4C2E  lfsx f13, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82326B5C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82326B60: C18BD4DC  lfs f12, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82326B64: EC0D033C  fnmsubs f0, f13, f12, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82326B68: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82326B6C: 40980008  bge cr6, 0x82326b74
	if !ctx.cr[6].lt {
	pc = 0x82326B74; continue 'dispatch;
	}
	// 82326B70: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	pc = 0x82326B74; continue 'dispatch;
            }
            0x82326B74 => {
    //   block [0x82326B74..0x82326B90)
	// 82326B74: 81630448  lwz r11, 0x448(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1096 as u32) ) } as u64;
	// 82326B78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82326B7C: 419A0014  beq cr6, 0x82326b90
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82326B90);
		return;
	}
	// 82326B80: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	// 82326B84: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82326B88: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82326B8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82326BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82326BA8 size=296
    let mut pc: u32 = 0x82326BA8;
    'dispatch: loop {
        match pc {
            0x82326BA8 => {
    //   block [0x82326BA8..0x82326BEC)
	// 82326BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82326BAC: 4820E4F1  bl 0x8253509c
	ctx.lr = 0x82326BB0;
	sub_82535080(ctx, base);
	// 82326BB0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82326BB4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82326BB8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82326BBC: 3B2BBC00  addi r25, r11, -0x4400
	ctx.r[25].s64 = ctx.r[11].s64 + -17408;
	// 82326BC0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326BC4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82326BC8: 3B4BD840  addi r26, r11, -0x27c0
	ctx.r[26].s64 = ctx.r[11].s64 + -10176;
	// 82326BCC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326BD0: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82326BD4: 3BFC0084  addi r31, r28, 0x84
	ctx.r[31].s64 = ctx.r[28].s64 + 132;
	// 82326BD8: 3EE0830F  lis r23, -0x7cf1
	ctx.r[23].s64 = -2096168960;
	// 82326BDC: 3B0BD838  addi r24, r11, -0x27c8
	ctx.r[24].s64 = ctx.r[11].s64 + -10184;
	// 82326BE0: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 82326BE4: 3AA00005  li r21, 5
	ctx.r[21].s64 = 5;
	// 82326BE8: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	pc = 0x82326BEC; continue 'dispatch;
            }
            0x82326BEC => {
    //   block [0x82326BEC..0x82326C14)
	// 82326BEC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82326BF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82326BF4: 419A0090  beq cr6, 0x82326c84
	if ctx.cr[6].eq {
	pc = 0x82326C84; continue 'dispatch;
	}
	// 82326BF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82326BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82326C00: 419A0014  beq cr6, 0x82326c14
	if ctx.cr[6].eq {
	pc = 0x82326C14; continue 'dispatch;
	}
	// 82326C04: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82326C08: 815FFFFC  lwz r10, -4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82326C0C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82326C10: 419A0068  beq cr6, 0x82326c78
	if ctx.cr[6].eq {
	pc = 0x82326C78; continue 'dispatch;
	}
	pc = 0x82326C14; continue 'dispatch;
            }
            0x82326C14 => {
    //   block [0x82326C14..0x82326C3C)
	// 82326C14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82326C18: 8097FAC0  lwz r4, -0x540(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82326C1C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82326C20: 38A00300  li r5, 0x300
	ctx.r[5].s64 = 768;
	// 82326C24: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 82326C28: 48043869  bl 0x8236a490
	ctx.lr = 0x82326C2C;
	sub_8236A490(ctx, base);
	// 82326C2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82326C30: 419A000C  beq cr6, 0x82326c3c
	if ctx.cr[6].eq {
	pc = 0x82326C3C; continue 'dispatch;
	}
	// 82326C34: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82326C38: 48000008  b 0x82326c40
	pc = 0x82326C40; continue 'dispatch;
            }
            0x82326C3C => {
    //   block [0x82326C3C..0x82326C40)
	// 82326C3C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82326C40; continue 'dispatch;
            }
            0x82326C40 => {
    //   block [0x82326C40..0x82326C78)
	// 82326C40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82326C44: 917FFFFC  stw r11, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 82326C48: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82326C4C: 419A002C  beq cr6, 0x82326c78
	if ctx.cr[6].eq {
	pc = 0x82326C78; continue 'dispatch;
	}
	// 82326C50: 817C00AC  lwz r11, 0xac(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(172 as u32) ) } as u64;
	// 82326C54: 815C00A8  lwz r10, 0xa8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 82326C58: 93430000  stw r26, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82326C5C: 936300FC  stw r27, 0xfc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), ctx.r[27].u32 ) };
	// 82326C60: 93C30110  stw r30, 0x110(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), ctx.r[30].u32 ) };
	// 82326C64: B3C30114  sth r30, 0x114(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(276 as u32), ctx.r[30].u16 ) };
	// 82326C68: B3C30116  sth r30, 0x116(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(278 as u32), ctx.r[30].u16 ) };
	// 82326C6C: 9BA30088  stb r29, 0x88(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[29].u8 ) };
	// 82326C70: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82326C74: 91430080  stw r10, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	pc = 0x82326C78; continue 'dispatch;
            }
            0x82326C78 => {
    //   block [0x82326C78..0x82326C84)
	// 82326C78: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82326C7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82326C80: 409A0034  bne cr6, 0x82326cb4
	if !ctx.cr[6].eq {
	pc = 0x82326CB4; continue 'dispatch;
	}
	pc = 0x82326C84; continue 'dispatch;
            }
            0x82326C84 => {
    //   block [0x82326C84..0x82326CB4)
	// 82326C84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82326C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82326C8C: 419A0028  beq cr6, 0x82326cb4
	if ctx.cr[6].eq {
	pc = 0x82326CB4; continue 'dispatch;
	}
	// 82326C90: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82326C94: 813FFFFC  lwz r9, -4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82326C98: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82326C9C: 409A0018  bne cr6, 0x82326cb4
	if !ctx.cr[6].eq {
	pc = 0x82326CB4; continue 'dispatch;
	}
	// 82326CA0: A14B0014  lhz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82326CA4: 9AAB0019  stb r21, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[21].u8 ) };
	// 82326CA8: 614A8000  ori r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 32768;
	// 82326CAC: 9ACB0025  stb r22, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[22].u8 ) };
	// 82326CB0: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x82326CB4; continue 'dispatch;
            }
            0x82326CB4 => {
    //   block [0x82326CB4..0x82326CD0)
	// 82326CB4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82326CB8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82326CBC: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 82326CC0: 2B1D0005  cmplwi cr6, r29, 5
	ctx.cr[6].compare_u32(ctx.r[29].u32, 5 as u32, &mut ctx.xer);
	// 82326CC4: 4198FF28  blt cr6, 0x82326bec
	if ctx.cr[6].lt {
	pc = 0x82326BEC; continue 'dispatch;
	}
	// 82326CC8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82326CCC: 4820E420  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82326CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82326CD0 size=556
    let mut pc: u32 = 0x82326CD0;
    'dispatch: loop {
        match pc {
            0x82326CD0 => {
    //   block [0x82326CD0..0x82326EFC)
	// 82326CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82326CD4: 4820E3D1  bl 0x825350a4
	ctx.lr = 0x82326CD8;
	sub_82535080(ctx, base);
	// 82326CD8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82326CDC: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82326CE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82326CE4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82326CE8: 3CE04020  lis r7, 0x4020
	ctx.r[7].s64 = 1075838976;
	// 82326CEC: 38C00022  li r6, 0x22
	ctx.r[6].s64 = 34;
	// 82326CF0: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 82326CF4: 9943001E  stb r10, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[10].u8 ) };
	// 82326CF8: 38800120  li r4, 0x120
	ctx.r[4].s64 = 288;
	// 82326CFC: 9943001C  stb r10, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 82326D00: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82326D04: 912300EC  stw r9, 0xec(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(236 as u32), ctx.r[9].u32 ) };
	// 82326D08: 90E300F8  stw r7, 0xf8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), ctx.r[7].u32 ) };
	// 82326D0C: D0030108  stfs f0, 0x108(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82326D10: 90C300E4  stw r6, 0xe4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), ctx.r[6].u32 ) };
	// 82326D14: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 82326D18: 912300E8  stw r9, 0xe8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 82326D1C: 3BE00920  li r31, 0x920
	ctx.r[31].s64 = 2336;
	// 82326D20: 908300F4  stw r4, 0xf4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), ctx.r[4].u32 ) };
	// 82326D24: 390A8E38  addi r8, r10, -0x71c8
	ctx.r[8].s64 = ctx.r[10].s64 + -29128;
	// 82326D28: 90A300F0  stw r5, 0xf0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), ctx.r[5].u32 ) };
	// 82326D2C: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 82326D30: 80C30080  lwz r6, 0x80(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82326D34: 3D403F80  lis r10, 0x3f80
	ctx.r[10].s64 = 1065353216;
	// 82326D38: 80E30084  lwz r7, 0x84(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 82326D3C: 3BA0000D  li r29, 0xd
	ctx.r[29].s64 = 13;
	// 82326D40: 39630090  addi r11, r3, 0x90
	ctx.r[11].s64 = ctx.r[3].s64 + 144;
	// 82326D44: 93E300F4  stw r31, 0xf4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), ctx.r[31].u32 ) };
	// 82326D48: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 82326D4C: D001FFA0  stfs f0, -0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), tmp.u32 ) };
	// 82326D50: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 82326D54: 93C300E8  stw r30, 0xe8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 82326D58: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 82326D5C: D001FFA4  stfs f0, -0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-92 as u32), tmp.u32 ) };
	// 82326D60: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 82326D64: D001FFA8  stfs f0, -0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), tmp.u32 ) };
	// 82326D68: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 82326D6C: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 82326D70: 90E300E0  stw r7, 0xe0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), ctx.r[7].u32 ) };
	// 82326D74: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 82326D78: D0030100  stfs f0, 0x100(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82326D7C: D0030104  stfs f0, 0x104(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82326D80: 91030110  stw r8, 0x110(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), ctx.r[8].u32 ) };
	// 82326D84: B1230116  sth r9, 0x116(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(278 as u32), ctx.r[9].u16 ) };
	// 82326D88: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 82326D8C: B3A30114  sth r29, 0x114(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(276 as u32), ctx.r[29].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82326F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82326F00 size=220
    let mut pc: u32 = 0x82326F00;
    'dispatch: loop {
        match pc {
            0x82326F00 => {
    //   block [0x82326F00..0x82326FDC)
	// 82326F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82326F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82326F08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82326F0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82326F10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82326F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82326F18: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82326F1C: 3D603F80  lis r11, 0x3f80
	ctx.r[11].s64 = 1065353216;
	// 82326F20: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 82326F24: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82326F28: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82326F2C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82326F30: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82326F34: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82326FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82326FE0 size=172
    let mut pc: u32 = 0x82326FE0;
    'dispatch: loop {
        match pc {
            0x82326FE0 => {
    //   block [0x82326FE0..0x8232704C)
	// 82326FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82326FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82326FE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82326FEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82326FF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82326FF4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82326FF8: 396BBC00  addi r11, r11, -0x4400
	ctx.r[11].s64 = ctx.r[11].s64 + -17408;
	// 82326FFC: 895F0088  lbz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82327000: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82327004: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82327008: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 8232700C: 2F0A0009  cmpwi cr6, r10, 9
	ctx.cr[6].compare_i32(ctx.r[10].s32, 9, &mut ctx.xer);
	// 82327010: 419A003C  beq cr6, 0x8232704c
	if ctx.cr[6].eq {
	pc = 0x8232704C; continue 'dispatch;
	}
	// 82327014: 816B0448  lwz r11, 0x448(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1096 as u32) ) } as u64;
	// 82327018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232701C: 409A0030  bne cr6, 0x8232704c
	if !ctx.cr[6].eq {
	pc = 0x8232704C; continue 'dispatch;
	}
	// 82327020: 38FF0090  addi r7, r31, 0x90
	ctx.r[7].s64 = ctx.r[31].s64 + 144;
	// 82327024: C01F00D0  lfs f0, 0xd0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82327028: 38DF0120  addi r6, r31, 0x120
	ctx.r[6].s64 = ctx.r[31].s64 + 288;
	// 8232702C: D01F013C  stfs f0, 0x13c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 82327030: 38BF00E0  addi r5, r31, 0xe0
	ctx.r[5].s64 = ctx.r[31].s64 + 224;
	// 82327034: D01F016C  stfs f0, 0x16c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 82327038: 389F0110  addi r4, r31, 0x110
	ctx.r[4].s64 = ctx.r[31].s64 + 272;
	// 8232703C: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82327040: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82327044: D01F01CC  stfs f0, 0x1cc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), tmp.u32 ) };
	// 82327048: 480468C1  bl 0x8236d908
	ctx.lr = 0x8232704C;
	sub_8236D908(ctx, base);
	pc = 0x8232704C; continue 'dispatch;
            }
            0x8232704C => {
    //   block [0x8232704C..0x82327078)
	// 8232704C: A17F0028  lhz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82327050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82327054: 409A0024  bne cr6, 0x82327078
	if !ctx.cr[6].eq {
	pc = 0x82327078; continue 'dispatch;
	}
	// 82327058: A17F0114  lhz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8232705C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82327060: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 82327064: A0BF0116  lhz r5, 0x116(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(278 as u32) ) } as u64;
	// 82327068: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8232706C: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82327070: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82327074: 480449AD  bl 0x8236ba20
	ctx.lr = 0x82327078;
	sub_8236BA20(ctx, base);
	pc = 0x82327078; continue 'dispatch;
            }
            0x82327078 => {
    //   block [0x82327078..0x8232708C)
	// 82327078: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232707C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82327080: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82327084: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82327088: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82327090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82327090 size=12
    let mut pc: u32 = 0x82327090;
    'dispatch: loop {
        match pc {
            0x82327090 => {
    //   block [0x82327090..0x8232709C)
	// 82327090: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82327094: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82327098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823270A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823270A0 size=16
    let mut pc: u32 = 0x823270A0;
    'dispatch: loop {
        match pc {
            0x823270A0 => {
    //   block [0x823270A0..0x823270B0)
	// 823270A0: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 823270A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823270A8: 916ABC14  stw r11, -0x43ec(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17388 as u32), ctx.r[11].u32 ) };
	// 823270AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823270B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823270B0 size=420
    let mut pc: u32 = 0x823270B0;
    'dispatch: loop {
        match pc {
            0x823270B0 => {
    //   block [0x823270B0..0x82327188)
	// 823270B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823270B4: 4820E001  bl 0x825350b4
	ctx.lr = 0x823270B8;
	sub_82535080(ctx, base);
	// 823270B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823270BC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823270C0: 906100B4  stw r3, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 823270C4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 823270C8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823270CC: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 823270D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823270D4: C01C0030  lfs f0, 0x30(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823270D8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 823270DC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823270E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823270E4: C01C0034  lfs f0, 0x34(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823270E8: 83EBBC14  lwz r31, -0x43ec(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17388 as u32) ) } as u64;
	// 823270EC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 823270F0: C01C0038  lfs f0, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823270F4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 823270F8: 48041519  bl 0x82368610
	ctx.lr = 0x823270FC;
	sub_82368610(ctx, base);
	// 823270FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82327100: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82327104: 38EBD8A0  addi r7, r11, -0x2760
	ctx.r[7].s64 = ctx.r[11].s64 + -10080;
	// 82327108: 38A01300  li r5, 0x1300
	ctx.r[5].s64 = 4864;
	// 8232710C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82327110: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 82327114: 4804337D  bl 0x8236a490
	ctx.lr = 0x82327118;
	sub_8236A490(ctx, base);
	// 82327118: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8232711C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82327120: 419A0068  beq cr6, 0x82327188
	if ctx.cr[6].eq {
	pc = 0x82327188; continue 'dispatch;
	}
	// 82327124: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 82327128: 811F0084  lwz r8, 0x84(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 8232712C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82327130: 80FF0080  lwz r7, 0x80(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82327134: 38C6D8D8  addi r6, r6, -0x2728
	ctx.r[6].s64 = ctx.r[6].s64 + -10024;
	// 82327138: C01F0090  lfs f0, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232713C: C1BF008C  lfs f13, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82327140: 39430090  addi r10, r3, 0x90
	ctx.r[10].s64 = ctx.r[3].s64 + 144;
	// 82327144: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 82327148: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232714C: 90C30000  stw r6, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82327150: E8CB0000  ld r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82327154: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82327158: C18522C4  lfs f12, 0x22c4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8900 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232715C: 91230120  stw r9, 0x120(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), ctx.r[9].u32 ) };
	// 82327160: B1230124  sth r9, 0x124(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(292 as u32), ctx.r[9].u16 ) };
	// 82327164: B1230126  sth r9, 0x126(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(294 as u32), ctx.r[9].u16 ) };
	// 82327168: D1A30088  stfs f13, 0x88(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8232716C: F8CA0000  std r6, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 82327170: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82327174: D1830094  stfs f12, 0x94(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82327178: 91030084  stw r8, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 8232717C: D16300A0  stfs f11, 0xa0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82327180: 90E30080  stw r7, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[7].u32 ) };
	// 82327184: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	pc = 0x82327188; continue 'dispatch;
            }
            0x82327188 => {
    //   block [0x82327188..0x823271B0)
	// 82327188: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 8232718C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82327190: 394A76FC  addi r10, r10, 0x76fc
	ctx.r[10].s64 = ctx.r[10].s64 + 30460;
	// 82327194: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 82327198: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232719C: 7D0858AE  lbzx r8, r8, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823271A0: 7F08F040  cmplw cr6, r8, r30
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[30].u32, &mut ctx.xer);
	// 823271A4: 409A000C  bne cr6, 0x823271b0
	if !ctx.cr[6].eq {
	pc = 0x823271B0; continue 'dispatch;
	}
	// 823271A8: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 823271AC: 4800001C  b 0x823271c8
	pc = 0x823271C8; continue 'dispatch;
            }
            0x823271B0 => {
    //   block [0x823271B0..0x823271C8)
	// 823271B0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 823271B4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823271B8: 7D6B48AE  lbzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 823271BC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 823271C0: 409A008C  bne cr6, 0x8232724c
	if !ctx.cr[6].eq {
	pc = 0x8232724C; continue 'dispatch;
	}
	// 823271C4: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	pc = 0x823271C8; continue 'dispatch;
            }
            0x823271C8 => {
    //   block [0x823271C8..0x8232724C)
	// 823271C8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 823271CC: 577D103A  slwi r29, r27, 2
	ctx.r[29].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 823271D0: 3BCBBC18  addi r30, r11, -0x43e8
	ctx.r[30].s64 = ctx.r[11].s64 + -17384;
	// 823271D4: 7D7DF02E  lwzx r11, r29, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 823271D8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 823271DC: 40980070  bge cr6, 0x8232724c
	if !ctx.cr[6].lt {
	pc = 0x8232724C; continue 'dispatch;
	}
	// 823271E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823271E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823271E8: 38EBD8AC  addi r7, r11, -0x2754
	ctx.r[7].s64 = ctx.r[11].s64 + -10068;
	// 823271EC: 38A01300  li r5, 0x1300
	ctx.r[5].s64 = 4864;
	// 823271F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823271F4: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 823271F8: 48043299  bl 0x8236a490
	ctx.lr = 0x823271FC;
	sub_8236A490(ctx, base);
	// 823271FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82327200: 419A004C  beq cr6, 0x8232724c
	if ctx.cr[6].eq {
	pc = 0x8232724C; continue 'dispatch;
	}
	// 82327204: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82327208: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 8232720C: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82327210: C01F0090  lfs f0, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82327214: 3929D8F8  addi r9, r9, -0x2708
	ctx.r[9].s64 = ctx.r[9].s64 + -9992;
	// 82327218: C1BF008C  lfs f13, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232721C: C19F0088  lfs f12, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82327220: 938300C0  stw r28, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82327224: D0030090  stfs f0, 0x90(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82327228: 936300C4  stw r27, 0xc4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), ctx.r[27].u32 ) };
	// 8232722C: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82327230: D1A3008C  stfs f13, 0x8c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82327234: D1830088  stfs f12, 0x88(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82327238: 91430080  stw r10, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 8232723C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82327240: 7D7DF02E  lwzx r11, r29, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82327244: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82327248: 7D7DF12E  stwx r11, r29, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u32) };
	pc = 0x8232724C; continue 'dispatch;
            }
            0x8232724C => {
    //   block [0x8232724C..0x82327254)
	// 8232724C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82327250: 4820DEB4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82327258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82327258 size=316
    let mut pc: u32 = 0x82327258;
    'dispatch: loop {
        match pc {
            0x82327258 => {
    //   block [0x82327258..0x82327394)
	// 82327258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232725C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82327260: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82327264: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82327268: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232726C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82327270: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82327274: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 82327278: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8232727C: 392A8E40  addi r9, r10, -0x71c0
	ctx.r[9].s64 = ctx.r[10].s64 + -29120;
	// 82327280: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82327284: 811E0080  lwz r8, 0x80(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 82327288: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 8232728C: 817E0084  lwz r11, 0x84(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 82327290: 3BFE00B0  addi r31, r30, 0xb0
	ctx.r[31].s64 = ctx.r[30].s64 + 176;
	// 82327294: 98FE001E  stb r7, 0x1e(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(30 as u32), ctx.r[7].u8 ) };
	// 82327298: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 8232729C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 823272A0: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823272A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823272A8: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 823272AC: 90DE00F4  stw r6, 0xf4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(244 as u32), ctx.r[6].u32 ) };
	// 823272B0: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 823272B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823272B8: 917E00F0  stw r11, 0xf0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 823272BC: 3D603F80  lis r11, 0x3f80
	ctx.r[11].s64 = 1065353216;
	// 823272C0: 915E010C  stw r10, 0x10c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(268 as u32), ctx.r[10].u32 ) };
	// 823272C4: 915E0100  stw r10, 0x100(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), ctx.r[10].u32 ) };
	// 823272C8: 911E00FC  stw r8, 0xfc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(252 as u32), ctx.r[8].u32 ) };
	// 823272CC: D01E0104  stfs f0, 0x104(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 823272D0: D01E0108  stfs f0, 0x108(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 823272D4: 913E0120  stw r9, 0x120(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(288 as u32), ctx.r[9].u32 ) };
	// 823272D8: B15E0124  sth r10, 0x124(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(292 as u32), ctx.r[10].u16 ) };
	// 823272DC: B15E0126  sth r10, 0x126(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(294 as u32), ctx.r[10].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82327398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82327398 size=280
    let mut pc: u32 = 0x82327398;
    'dispatch: loop {
        match pc {
            0x82327398 => {
    //   block [0x82327398..0x823274B0)
	// 82327398: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8232739C: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 823273A0: 396300B0  addi r11, r3, 0xb0
	ctx.r[11].s64 = ctx.r[3].s64 + 176;
	// 823273A4: C1A30088  lfs f13, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823273A8: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 823273AC: C00300A4  lfs f0, 0xa4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823273B0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 823273B4: C183008C  lfs f12, 0x8c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823273B8: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 823273BC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823273C0: C16ABA38  lfs f11, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823273C4: 3D403F80  lis r10, 0x3f80
	ctx.r[10].s64 = 1065353216;
	// 823273C8: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823274B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823274B0 size=304
    let mut pc: u32 = 0x823274B0;
    'dispatch: loop {
        match pc {
            0x823274B0 => {
    //   block [0x823274B0..0x823275E0)
	// 823274B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823274B4: 4820DBF9  bl 0x825350ac
	ctx.lr = 0x823274B8;
	sub_82535080(ctx, base);
	// 823274B8: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823274BC: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 823274C0: C00300A8  lfs f0, 0xa8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823274C4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 823274C8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 823274CC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823274D0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823274D4: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 823274D8: C1A72048  lfs f13, 0x2048(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823274DC: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 823274E0: C009BA38  lfs f0, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823274E4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 823274E8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823274EC: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 823274F0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823274F4: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 823274F8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 823274FC: EB6B0000  ld r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82327500: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82327504: 3BC100A0  addi r30, r1, 0xa0
	ctx.r[30].s64 = ctx.r[1].s64 + 160;
	// 82327508: EB4A0000  ld r26, 0(r10)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8232750C: C1871FF8  lfs f12, 0x1ff8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82327510: C165BFFC  lfs f11, -0x4004(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82327514: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82327518: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8232751C: EB290000  ld r25, 0(r9)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 82327520: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82327524: 3BA100D0  addi r29, r1, 0xd0
	ctx.r[29].s64 = ctx.r[1].s64 + 208;
	// 82327528: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8232752C: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 82327530: D1A10090  stfs f13, 0x90(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82327534: 3B810100  addi r28, r1, 0x100
	ctx.r[28].s64 = ctx.r[1].s64 + 256;
	// 82327538: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8232753C: 38E300B0  addi r7, r3, 0xb0
	ctx.r[7].s64 = ctx.r[3].s64 + 176;
	// 82327540: D1A100C8  stfs f13, 0xc8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82327544: 38A300F0  addi r5, r3, 0xf0
	ctx.r[5].s64 = ctx.r[3].s64 + 240;
	// 82327548: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 8232754C: 38830120  addi r4, r3, 0x120
	ctx.r[4].s64 = ctx.r[3].s64 + 288;
	// 82327550: D00100FC  stfs f0, 0xfc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82327554: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82327558: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8232755C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82327560: D1810094  stfs f12, 0x94(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82327564: D1610098  stfs f11, 0x98(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82327568: D16100C0  stfs f11, 0xc0(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8232756C: D18100C4  stfs f12, 0xc4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82327570: D16100F0  stfs f11, 0xf0(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82327574: D18100F4  stfs f12, 0xf4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82327578: D16100F8  stfs f11, 0xf8(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 8232757C: FB680000  std r27, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 82327580: F9680008  std r11, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82327584: EB7F0000  ld r27, 0(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 82327588: E97F0008  ld r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 8232758C: FB5E0000  std r26, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	// 82327590: F95E0008  std r10, 8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82327594: FB3D0000  std r25, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[25].u64 ) };
	// 82327598: F93D0008  std r9, 8(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 8232759C: FB7C0000  std r27, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 823275A0: F97C0008  std r11, 8(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 823275A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823275A8: C00B209C  lfs f0, 0x209c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823275AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823275B0: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 823275B4: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 823275B8: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 823275BC: D00100E4  stfs f0, 0xe4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 823275C0: C1AB2420  lfs f13, 0x2420(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823275C4: D1A100B4  stfs f13, 0xb4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 823275C8: D1A100E0  stfs f13, 0xe0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 823275CC: D1A10110  stfs f13, 0x110(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 823275D0: D1A10114  stfs f13, 0x114(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 823275D4: 480459A5  bl 0x8236cf78
	ctx.lr = 0x823275D8;
	sub_8236CF78(ctx, base);
	// 823275D8: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 823275DC: 4820DB20  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823275E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823275E0 size=108
    let mut pc: u32 = 0x823275E0;
    'dispatch: loop {
        match pc {
            0x823275E0 => {
    //   block [0x823275E0..0x82327610)
	// 823275E0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823275E4: 812300C4  lwz r9, 0xc4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 823275E8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 823275EC: 394AD8F8  addi r10, r10, -0x2708
	ctx.r[10].s64 = ctx.r[10].s64 + -9992;
	// 823275F0: 396BBC18  addi r11, r11, -0x43e8
	ctx.r[11].s64 = ctx.r[11].s64 + -17384;
	// 823275F4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823275F8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823275FC: 7D49582E  lwzx r10, r9, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82327600: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82327604: 419A000C  beq cr6, 0x82327610
	if ctx.cr[6].eq {
	pc = 0x82327610; continue 'dispatch;
	}
	// 82327608: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8232760C: 7D49592E  stwx r10, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	pc = 0x82327610; continue 'dispatch;
            }
            0x82327610 => {
    //   block [0x82327610..0x8232764C)
	// 82327610: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82327614: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82327618: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 8232761C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82327620: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82327624: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82327628: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232762C: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82327630: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82327634: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82327638: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8232763C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82327640: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82327644: 99430025  stb r10, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 82327648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82327650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82327650 size=44
    let mut pc: u32 = 0x82327650;
    'dispatch: loop {
        match pc {
            0x82327650 => {
    //   block [0x82327650..0x8232767C)
	// 82327650: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82327654: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82327658: C1AB0030  lfs f13, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232765C: D1A300A0  stfs f13, 0xa0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82327660: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82327664: D1A300A4  stfs f13, 0xa4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82327668: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232766C: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82327670: D1A300A8  stfs f13, 0xa8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82327674: D00300C8  stfs f0, 0xc8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82327678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82327680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82327680 size=388
    let mut pc: u32 = 0x82327680;
    'dispatch: loop {
        match pc {
            0x82327680 => {
    //   block [0x82327680..0x82327714)
	// 82327680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82327684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82327688: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232768C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82327690: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82327694: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82327698: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232769C: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 823276A0: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823276A4: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 823276A8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823276AC: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 823276B0: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 823276B4: C1BF00B4  lfs f13, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823276B8: C01F00A4  lfs f0, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823276BC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823276C0: C19F00A8  lfs f12, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823276C4: C1BF00B8  lfs f13, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823276C8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 823276CC: C17F00B0  lfs f11, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823276D0: C19F00A0  lfs f12, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823276D4: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 823276D8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823276DC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 823276E0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 823276E4: EDA0002C  fsqrts f13, f0
	ctx.f[13].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 823276E8: C00BD5BC  lfs f0, -0x2a44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10820 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823276EC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823276F0: 40990024  ble cr6, 0x82327714
	if !ctx.cr[6].gt {
	pc = 0x82327714; continue 'dispatch;
	}
	// 823276F4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 823276F8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 823276FC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82327700: 409A0014  bne cr6, 0x82327714
	if !ctx.cr[6].eq {
	pc = 0x82327714; continue 'dispatch;
	}
	// 82327704: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82327708: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8232770C: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82327710: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x82327714; continue 'dispatch;
            }
            0x82327714 => {
    //   block [0x82327714..0x823277E4)
	// 82327714: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82327718: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8232771C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82327720: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82327724: 48040EED  bl 0x82368610
	ctx.lr = 0x82327728;
	sub_82368610(ctx, base);
	// 82327728: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232772C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82327730: C1BF00C8  lfs f13, 0xc8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82327734: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82327738: 614A85D4  ori r10, r10, 0x85d4
	ctx.r[10].u64 = ctx.r[10].u64 | 34260;
	// 8232773C: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82327740: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82327744: C1BF0088  lfs f13, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82327748: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8232774C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82327750: 419800A0  blt cr6, 0x823277f0
	if ctx.cr[6].lt {
	pc = 0x823277F0; continue 'dispatch;
	}
	// 82327754: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82327758: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8232775C: 38EBD8A0  addi r7, r11, -0x2760
	ctx.r[7].s64 = ctx.r[11].s64 + -10080;
	// 82327760: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82327764: 38A01300  li r5, 0x1300
	ctx.r[5].s64 = 4864;
	// 82327768: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 8232776C: 808BBC14  lwz r4, -0x43ec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17388 as u32) ) } as u64;
	// 82327770: 48042D21  bl 0x8236a490
	ctx.lr = 0x82327774;
	sub_8236A490(ctx, base);
	// 82327774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82327778: 419A006C  beq cr6, 0x823277e4
	if ctx.cr[6].eq {
	pc = 0x823277E4; continue 'dispatch;
	}
	// 8232777C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82327780: 813F0084  lwz r9, 0x84(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82327784: 39430090  addi r10, r3, 0x90
	ctx.r[10].s64 = ctx.r[3].s64 + 144;
	// 82327788: 811F0080  lwz r8, 0x80(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8232778C: C01F0090  lfs f0, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82327790: C1BF008C  lfs f13, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82327794: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82327798: C18B22C4  lfs f12, 0x22c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8900 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232779C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823277A0: 38EBD8D8  addi r7, r11, -0x2728
	ctx.r[7].s64 = ctx.r[11].s64 + -10024;
	// 823277A4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 823277A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823277AC: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823277B0: 91430120  stw r10, 0x120(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), ctx.r[10].u32 ) };
	// 823277B4: B1430124  sth r10, 0x124(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(292 as u32), ctx.r[10].u16 ) };
	// 823277B8: B1430126  sth r10, 0x126(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(294 as u32), ctx.r[10].u16 ) };
	// 823277BC: D1A30088  stfs f13, 0x88(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 823277C0: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 823277C4: 91230084  stw r9, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 823277C8: 91030080  stw r8, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 823277CC: E95F00A0  ld r10, 0xa0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	// 823277D0: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 823277D4: E95F00A8  ld r10, 0xa8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	// 823277D8: D1830094  stfs f12, 0x94(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 823277DC: D16300A0  stfs f11, 0xa0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 823277E0: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	pc = 0x823277E4; continue 'dispatch;
            }
            0x823277E4 => {
    //   block [0x823277E4..0x823277F0)
	// 823277E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823277E8: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823277EC: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	pc = 0x823277F0; continue 'dispatch;
            }
            0x823277F0 => {
    //   block [0x823277F0..0x82327804)
	// 823277F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823277F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823277F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823277FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82327800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82327808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82327808 size=216
    let mut pc: u32 = 0x82327808;
    'dispatch: loop {
        match pc {
            0x82327808 => {
    //   block [0x82327808..0x823278E0)
	// 82327808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232780C: 4820D8A9  bl 0x825350b4
	ctx.lr = 0x82327810;
	sub_82535080(ctx, base);
	// 82327810: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82327814: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82327818: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 8232781C: 394301C0  addi r10, r3, 0x1c0
	ctx.r[10].s64 = ctx.r[3].s64 + 448;
	// 82327820: 39094634  addi r8, r9, 0x4634
	ctx.r[8].s64 = ctx.r[9].s64 + 17972;
	// 82327824: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82327828: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232782C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82327830: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 82327834: 396BD944  addi r11, r11, -0x26bc
	ctx.r[11].s64 = ctx.r[11].s64 + -9916;
	// 82327838: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 8232783C: 3BE00010  li r31, 0x10
	ctx.r[31].s64 = 16;
	// 82327840: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82327844: 3D603F80  lis r11, 0x3f80
	ctx.r[11].s64 = 1065353216;
	// 82327848: D00A029C  stfs f0, 0x29c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 8232784C: 912A0294  stw r9, 0x294(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(660 as u32), ctx.r[9].u32 ) };
	// 82327850: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82327854: 912A0298  stw r9, 0x298(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(664 as u32), ctx.r[9].u32 ) };
	// 82327858: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8232785C: 910A0290  stw r8, 0x290(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(656 as u32), ctx.r[8].u32 ) };
	// 82327860: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82327864: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 82327868: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232786C: 906BBC20  stw r3, -0x43e0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17376 as u32), ctx.r[3].u32 ) };
	// 82327870: 396A0250  addi r11, r10, 0x250
	ctx.r[11].s64 = ctx.r[10].s64 + 592;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823278E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823278E0 size=152
    let mut pc: u32 = 0x823278E0;
    'dispatch: loop {
        match pc {
            0x823278E0 => {
    //   block [0x823278E0..0x82327918)
	// 823278E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823278E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823278E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823278EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823278F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823278F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823278F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823278FC: 396BD944  addi r11, r11, -0x26bc
	ctx.r[11].s64 = ctx.r[11].s64 + -9916;
	// 82327900: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82327904: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82327908: 807F1688  lwz r3, 0x1688(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5768 as u32) ) } as u64;
	// 8232790C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82327910: 419A0008  beq cr6, 0x82327918
	if ctx.cr[6].eq {
	pc = 0x82327918; continue 'dispatch;
	}
	// 82327914: 4BDF5745  bl 0x8211d058
	ctx.lr = 0x82327918;
	sub_8211D058(ctx, base);
	pc = 0x82327918; continue 'dispatch;
            }
            0x82327918 => {
    //   block [0x82327918..0x82327960)
	// 82327918: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232791C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82327920: 396B4634  addi r11, r11, 0x4634
	ctx.r[11].s64 = ctx.r[11].s64 + 17972;
	// 82327924: 394ADED0  addi r10, r10, -0x2130
	ctx.r[10].s64 = ctx.r[10].s64 + -8496;
	// 82327928: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8232792C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82327930: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82327934: 917F0450  stw r11, 0x450(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1104 as u32), ctx.r[11].u32 ) };
	// 82327938: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8232793C: 419A0024  beq cr6, 0x82327960
	if ctx.cr[6].eq {
	pc = 0x82327960; continue 'dispatch;
	}
	// 82327940: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82327944: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82327948: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8232794C: 409A0014  bne cr6, 0x82327960
	if !ctx.cr[6].eq {
	pc = 0x82327960; continue 'dispatch;
	}
	// 82327950: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82327954: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82327958: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8232795C: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x82327960; continue 'dispatch;
            }
            0x82327960 => {
    //   block [0x82327960..0x82327978)
	// 82327960: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82327964: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82327968: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232796C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82327970: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82327974: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82327978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82327978 size=812
    let mut pc: u32 = 0x82327978;
    'dispatch: loop {
        match pc {
            0x82327978 => {
    //   block [0x82327978..0x82327CA4)
	// 82327978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232797C: 4820D735  bl 0x825350b0
	ctx.lr = 0x82327980;
	sub_82535080(ctx, base);
	// 82327980: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82327984: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82327988: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82327CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82327CA8 size=224
    let mut pc: u32 = 0x82327CA8;
    'dispatch: loop {
        match pc {
            0x82327CA8 => {
    //   block [0x82327CA8..0x82327CE8)
	// 82327CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82327CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82327CB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82327CB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82327CB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82327CBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82327CC0: 817F1690  lwz r11, 0x1690(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5776 as u32) ) } as u64;
	// 82327CC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82327CC8: 409A0028  bne cr6, 0x82327cf0
	if !ctx.cr[6].eq {
	pc = 0x82327CF0; continue 'dispatch;
	}
	// 82327CCC: 817F16A8  lwz r11, 0x16a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5800 as u32) ) } as u64;
	// 82327CD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82327CD4: 409A0014  bne cr6, 0x82327ce8
	if !ctx.cr[6].eq {
	pc = 0x82327CE8; continue 'dispatch;
	}
	// 82327CD8: 480005F9  bl 0x823282d0
	ctx.lr = 0x82327CDC;
	sub_823282D0(ctx, base);
	// 82327CDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82327CE0: 48000AF1  bl 0x823287d0
	ctx.lr = 0x82327CE4;
	sub_823287D0(ctx, base);
	// 82327CE4: 48000010  b 0x82327cf4
	pc = 0x82327CF4; continue 'dispatch;
            }
            0x82327CE8 => {
    //   block [0x82327CE8..0x82327CF0)
	// 82327CE8: 48000F39  bl 0x82328c20
	ctx.lr = 0x82327CEC;
	sub_82328C20(ctx, base);
	// 82327CEC: 48000008  b 0x82327cf4
	pc = 0x82327CF4; continue 'dispatch;
            }
            0x82327CF0 => {
    //   block [0x82327CF0..0x82327CF4)
	// 82327CF0: 48000C11  bl 0x82328900
	ctx.lr = 0x82327CF4;
	sub_82328900(ctx, base);
	pc = 0x82327CF4; continue 'dispatch;
            }
            0x82327CF4 => {
    //   block [0x82327CF4..0x82327D34)
	// 82327CF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82327CF8: 48000141  bl 0x82327e38
	ctx.lr = 0x82327CFC;
	sub_82327E38(ctx, base);
	// 82327CFC: 3FC082C0  lis r30, -0x7d40
	ctx.r[30].s64 = -2101346304;
	// 82327D00: 817EBC34  lwz r11, -0x43cc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17356 as u32) ) } as u64;
	// 82327D04: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82327D08: 409A002C  bne cr6, 0x82327d34
	if !ctx.cr[6].eq {
	pc = 0x82327D34; continue 'dispatch;
	}
	// 82327D0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82327D10: 889F16B8  lbz r4, 0x16b8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5816 as u32) ) } as u64;
	// 82327D14: 4800035D  bl 0x82328070
	ctx.lr = 0x82327D18;
	sub_82328070(ctx, base);
	// 82327D18: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82327D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82327D20: 90FF16AC  stw r7, 0x16ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5804 as u32), ctx.r[7].u32 ) };
	// 82327D24: 90FF1690  stw r7, 0x1690(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5776 as u32), ctx.r[7].u32 ) };
	// 82327D28: 48000E51  bl 0x82328b78
	ctx.lr = 0x82327D2C;
	sub_82328B78(ctx, base);
	// 82327D2C: 90FEBC34  stw r7, -0x43cc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-17356 as u32), ctx.r[7].u32 ) };
	// 82327D30: 48000040  b 0x82327d70
	pc = 0x82327D70; continue 'dispatch;
            }
            0x82327D34 => {
    //   block [0x82327D34..0x82327D68)
	// 82327D34: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82327D38: 409A0030  bne cr6, 0x82327d68
	if !ctx.cr[6].eq {
	pc = 0x82327D68; continue 'dispatch;
	}
	// 82327D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82327D40: 889F16B8  lbz r4, 0x16b8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5816 as u32) ) } as u64;
	// 82327D44: 4800032D  bl 0x82328070
	ctx.lr = 0x82327D48;
	sub_82328070(ctx, base);
	// 82327D48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82327D4C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82327D50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82327D54: 917F16AC  stw r11, 0x16ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5804 as u32), ctx.r[11].u32 ) };
	// 82327D58: 90FF1690  stw r7, 0x1690(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5776 as u32), ctx.r[7].u32 ) };
	// 82327D5C: 48000E1D  bl 0x82328b78
	ctx.lr = 0x82327D60;
	sub_82328B78(ctx, base);
	// 82327D60: 90FEBC34  stw r7, -0x43cc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-17356 as u32), ctx.r[7].u32 ) };
	// 82327D64: 4800000C  b 0x82327d70
	pc = 0x82327D70; continue 'dispatch;
            }
            0x82327D68 => {
    //   block [0x82327D68..0x82327D70)
	// 82327D68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82327D6C: 917EBC34  stw r11, -0x43cc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-17356 as u32), ctx.r[11].u32 ) };
	pc = 0x82327D70; continue 'dispatch;
            }
            0x82327D70 => {
    //   block [0x82327D70..0x82327D88)
	// 82327D70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82327D74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82327D78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82327D7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82327D80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82327D84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82327D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82327D88 size=32
    let mut pc: u32 = 0x82327D88;
    'dispatch: loop {
        match pc {
            0x82327D88 => {
    //   block [0x82327D88..0x82327DA8)
	// 82327D88: 39631684  addi r11, r3, 0x1684
	ctx.r[11].s64 = ctx.r[3].s64 + 5764;
	// 82327D8C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82327D90: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82327D94: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82327D98: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82327D9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82327DA0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82327DA4: 4BDF52B4  b 0x8211d058
	sub_8211D058(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82327DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82327DB0 size=136
    let mut pc: u32 = 0x82327DB0;
    'dispatch: loop {
        match pc {
            0x82327DB0 => {
    //   block [0x82327DB0..0x82327E28)
	// 82327DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82327DB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82327DB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82327DBC: 3D4082B5  lis r10, -0x7d4b
	ctx.r[10].s64 = -2102067200;
	// 82327DC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82327DC4: 394A0C40  addi r10, r10, 0xc40
	ctx.r[10].s64 = ctx.r[10].s64 + 3136;
	// 82327DC8: 814A0384  lwz r10, 0x384(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(900 as u32) ) } as u64;
	// 82327DCC: 554A0672  rlwinm r10, r10, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82327DD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82327DD4: 419A0054  beq cr6, 0x82327e28
	if ctx.cr[6].eq {
	pc = 0x82327E28; continue 'dispatch;
	}
	// 82327DD8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82327DDC: C1AB04B4  lfs f13, 0x4b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1204 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82327DE0: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82327DE4: 38AB00C4  addi r5, r11, 0xc4
	ctx.r[5].s64 = ctx.r[11].s64 + 196;
	// 82327DE8: C00B04B0  lfs f0, 0x4b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82327DEC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82327DF0: C1AB04B8  lfs f13, 0x4b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82327DF4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82327DF8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82327DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82327E00: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82327E04: E96A0000  ld r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82327E08: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82327E0C: F9690000  std r11, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82327E10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82327E14: F9490008  std r10, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82327E18: C1AB2138  lfs f13, 0x2138(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82327E1C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82327E20: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82327E24: 4803AA85  bl 0x823628a8
	ctx.lr = 0x82327E28;
	sub_823628A8(ctx, base);
	pc = 0x82327E28; continue 'dispatch;
            }
            0x82327E28 => {
    //   block [0x82327E28..0x82327E38)
	// 82327E28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82327E2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82327E30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82327E34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82327E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82327E38 size=568
    let mut pc: u32 = 0x82327E38;
    'dispatch: loop {
        match pc {
            0x82327E38 => {
    //   block [0x82327E38..0x82327F58)
	// 82327E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82327E3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82327E40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82327E44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82327E48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82327E4C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 82327E50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82327E54: 806B03D8  lwz r3, 0x3d8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(984 as u32) ) } as u64;
	// 82327E58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82327E5C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82327E60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82327E64: 4E800421  bctrl
	ctx.lr = 0x82327E68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82327E68: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82327E6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82327E70: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82327E74: 419A01E4  beq cr6, 0x82328058
	if ctx.cr[6].eq {
	pc = 0x82328058; continue 'dispatch;
	}
	// 82327E78: 397EFFFF  addi r11, r30, -1
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	// 82327E7C: 2B0B002E  cmplwi cr6, r11, 0x2e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 46 as u32, &mut ctx.xer);
	// 82327E80: 419901D4  bgt cr6, 0x82328054
	if ctx.cr[6].gt {
	pc = 0x82328054; continue 'dispatch;
	}
	// 82327E84: 3D808232  lis r12, -0x7dce
	ctx.r[12].s64 = -2110652416;
	// 82327E88: 398C7E9C  addi r12, r12, 0x7e9c
	ctx.r[12].s64 = ctx.r[12].s64 + 32412;
	// 82327E8C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82327E90: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82327E94: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82327E98: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x82327F58; continue 'dispatch;
		},
		1 => {
	pc = 0x82327F7C; continue 'dispatch;
		},
		2 => {
	pc = 0x82328054; continue 'dispatch;
		},
		3 => {
	pc = 0x82327F88; continue 'dispatch;
		},
		4 => {
	pc = 0x82327F58; continue 'dispatch;
		},
		5 => {
	pc = 0x82327F58; continue 'dispatch;
		},
		6 => {
	pc = 0x82327F58; continue 'dispatch;
		},
		7 => {
	pc = 0x82328054; continue 'dispatch;
		},
		8 => {
	pc = 0x82328054; continue 'dispatch;
		},
		9 => {
	pc = 0x82328054; continue 'dispatch;
		},
		10 => {
	pc = 0x82328054; continue 'dispatch;
		},
		11 => {
	pc = 0x82328054; continue 'dispatch;
		},
		12 => {
	pc = 0x82328054; continue 'dispatch;
		},
		13 => {
	pc = 0x82328054; continue 'dispatch;
		},
		14 => {
	pc = 0x82328054; continue 'dispatch;
		},
		15 => {
	pc = 0x82328054; continue 'dispatch;
		},
		16 => {
	pc = 0x82328054; continue 'dispatch;
		},
		17 => {
	pc = 0x82328054; continue 'dispatch;
		},
		18 => {
	pc = 0x82328054; continue 'dispatch;
		},
		19 => {
	pc = 0x82328054; continue 'dispatch;
		},
		20 => {
	pc = 0x82328054; continue 'dispatch;
		},
		21 => {
	pc = 0x82328054; continue 'dispatch;
		},
		22 => {
	pc = 0x82328054; continue 'dispatch;
		},
		23 => {
	pc = 0x82328054; continue 'dispatch;
		},
		24 => {
	pc = 0x82328054; continue 'dispatch;
		},
		25 => {
	pc = 0x82328054; continue 'dispatch;
		},
		26 => {
	pc = 0x82328054; continue 'dispatch;
		},
		27 => {
	pc = 0x82328054; continue 'dispatch;
		},
		28 => {
	pc = 0x82328054; continue 'dispatch;
		},
		29 => {
	pc = 0x82328054; continue 'dispatch;
		},
		30 => {
	pc = 0x82327F88; continue 'dispatch;
		},
		31 => {
	pc = 0x82328054; continue 'dispatch;
		},
		32 => {
	pc = 0x82328054; continue 'dispatch;
		},
		33 => {
	pc = 0x82328054; continue 'dispatch;
		},
		34 => {
	pc = 0x82328054; continue 'dispatch;
		},
		35 => {
	pc = 0x82328054; continue 'dispatch;
		},
		36 => {
	pc = 0x82328054; continue 'dispatch;
		},
		37 => {
	pc = 0x82328054; continue 'dispatch;
		},
		38 => {
	pc = 0x82328054; continue 'dispatch;
		},
		39 => {
	pc = 0x82328054; continue 'dispatch;
		},
		40 => {
	pc = 0x82328054; continue 'dispatch;
		},
		41 => {
	pc = 0x82328054; continue 'dispatch;
		},
		42 => {
	pc = 0x82328054; continue 'dispatch;
		},
		43 => {
	pc = 0x82328054; continue 'dispatch;
		},
		44 => {
	pc = 0x82328054; continue 'dispatch;
		},
		45 => {
	pc = 0x82328054; continue 'dispatch;
		},
		46 => {
	pc = 0x8232803C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82327E9C: 82327F58  lwz r17, 0x7f58(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(32600 as u32) ) } as u64;
	// 82327EA0: 82327F7C  lwz r17, 0x7f7c(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(32636 as u32) ) } as u64;
	// 82327EA4: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EA8: 82327F88  lwz r17, 0x7f88(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(32648 as u32) ) } as u64;
	// 82327EAC: 82327F58  lwz r17, 0x7f58(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(32600 as u32) ) } as u64;
	// 82327EB0: 82327F58  lwz r17, 0x7f58(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(32600 as u32) ) } as u64;
	// 82327EB4: 82327F58  lwz r17, 0x7f58(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(32600 as u32) ) } as u64;
	// 82327EB8: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EBC: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EC0: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EC4: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EC8: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327ECC: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327ED0: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327ED4: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327ED8: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EDC: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EE0: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EE4: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EE8: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EEC: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EF0: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EF4: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EF8: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327EFC: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F00: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F04: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F08: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F0C: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F10: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F14: 82327F88  lwz r17, 0x7f88(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(32648 as u32) ) } as u64;
	// 82327F18: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F1C: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F20: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F24: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F28: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F2C: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F30: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F34: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F38: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F3C: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F40: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F44: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F48: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F4C: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F50: 82328054  lwz r17, -0x7fac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32684 as u32) ) } as u64;
	// 82327F54: 8232803C  lwz r17, -0x7fc4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32708 as u32) ) } as u64;
            }
            0x82327F58 => {
    //   block [0x82327F58..0x82327F7C)
	// 82327F58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82327F5C: 889F16B8  lbz r4, 0x16b8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5816 as u32) ) } as u64;
	// 82327F60: 48000111  bl 0x82328070
	ctx.lr = 0x82327F64;
	sub_82328070(ctx, base);
	// 82327F64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82327F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82327F6C: 917F16AC  stw r11, 0x16ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5804 as u32), ctx.r[11].u32 ) };
	// 82327F70: 917F1690  stw r11, 0x1690(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5776 as u32), ctx.r[11].u32 ) };
	// 82327F74: 48000C05  bl 0x82328b78
	ctx.lr = 0x82327F78;
	sub_82328B78(ctx, base);
	// 82327F78: 480000DC  b 0x82328054
	pc = 0x82328054; continue 'dispatch;
            }
            0x82327F7C => {
    //   block [0x82327F7C..0x82327F88)
	// 82327F7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82327F80: 917F16AC  stw r11, 0x16ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5804 as u32), ctx.r[11].u32 ) };
	// 82327F84: 480000D0  b 0x82328054
	pc = 0x82328054; continue 'dispatch;
            }
            0x82327F88 => {
    //   block [0x82327F88..0x82327FBC)
	// 82327F88: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82327F8C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82327F90: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 82327F94: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82327F98: 614A9460  ori r10, r10, 0x9460
	ctx.r[10].u64 = ctx.r[10].u64 | 37984;
	// 82327F9C: 6129945C  ori r9, r9, 0x945c
	ctx.r[9].u64 = ctx.r[9].u64 | 37980;
	// 82327FA0: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82327FA4: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82327FA8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82327FAC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82327FB0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82327FB4: 40990008  ble cr6, 0x82327fbc
	if !ctx.cr[6].gt {
	pc = 0x82327FBC; continue 'dispatch;
	}
	// 82327FB8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82327FBC; continue 'dispatch;
            }
            0x82327FBC => {
    //   block [0x82327FBC..0x8232800C)
	// 82327FBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82327FC0: 4198006C  blt cr6, 0x8232802c
	if ctx.cr[6].lt {
	pc = 0x8232802C; continue 'dispatch;
	}
	// 82327FC4: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 82327FC8: C01F1694  lfs f0, 0x1694(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5780 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82327FCC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82327FD0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82327FD4: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82327FD8: D1BF169C  stfs f13, 0x169c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5788 as u32), tmp.u32 ) };
	// 82327FDC: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82327FE0: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82327FE4: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82327FE8: D19F16A0  stfs f12, 0x16a0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5792 as u32), tmp.u32 ) };
	// 82327FEC: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82327FF0: D01F1694  stfs f0, 0x1694(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5780 as u32), tmp.u32 ) };
	// 82327FF4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82327FF8: 40980014  bge cr6, 0x8232800c
	if !ctx.cr[6].lt {
	pc = 0x8232800C; continue 'dispatch;
	}
	// 82327FFC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82328000: C1ABF3EC  lfs f13, -0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82328004: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82328008: D01F1694  stfs f0, 0x1694(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5780 as u32), tmp.u32 ) };
	pc = 0x8232800C; continue 'dispatch;
            }
            0x8232800C => {
    //   block [0x8232800C..0x8232802C)
	// 8232800C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82328010: C01F1694  lfs f0, 0x1694(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5780 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328014: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 82328018: D01F1698  stfs f0, 0x1698(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5784 as u32), tmp.u32 ) };
	// 8232801C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82328020: 913F1690  stw r9, 0x1690(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5776 as u32), ctx.r[9].u32 ) };
	// 82328024: 916ABC24  stw r11, -0x43dc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17372 as u32), ctx.r[11].u32 ) };
	// 82328028: 4800002C  b 0x82328054
	pc = 0x82328054; continue 'dispatch;
            }
            0x8232802C => {
    //   block [0x8232802C..0x8232803C)
	// 8232802C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82328030: 917F16AC  stw r11, 0x16ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5804 as u32), ctx.r[11].u32 ) };
	// 82328034: 917F1690  stw r11, 0x1690(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5776 as u32), ctx.r[11].u32 ) };
	// 82328038: 4800001C  b 0x82328054
	pc = 0x82328054; continue 'dispatch;
            }
            0x8232803C => {
    //   block [0x8232803C..0x82328054)
	// 8232803C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82328040: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82328044: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328048: D01F16A4  stfs f0, 0x16a4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5796 as u32), tmp.u32 ) };
	// 8232804C: 915F00C0  stw r10, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[10].u32 ) };
	// 82328050: 915F16A8  stw r10, 0x16a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5800 as u32), ctx.r[10].u32 ) };
	pc = 0x82328054; continue 'dispatch;
            }
            0x82328054 => {
    //   block [0x82328054..0x82328058)
	// 82328054: 93DF00B4  stw r30, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	pc = 0x82328058; continue 'dispatch;
            }
            0x82328058 => {
    //   block [0x82328058..0x82328070)
	// 82328058: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232805C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82328060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82328064: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82328068: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232806C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82328070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82328070 size=608
    let mut pc: u32 = 0x82328070;
    'dispatch: loop {
        match pc {
            0x82328070 => {
    //   block [0x82328070..0x823280C4)
	// 82328070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82328074: 4820D049  bl 0x825350bc
	ctx.lr = 0x82328078;
	sub_82535080(ctx, base);
	// 82328078: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232807C: 5489063E  clrlwi r9, r4, 0x18
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82328080: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82328084: 2B090006  cmplwi cr6, r9, 6
	ctx.cr[6].compare_u32(ctx.r[9].u32, 6 as u32, &mut ctx.xer);
	// 82328088: 41990124  bgt cr6, 0x823281ac
	if ctx.cr[6].gt {
	pc = 0x823281AC; continue 'dispatch;
	}
	// 8232808C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82328090: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 82328094: 398C80A8  addi r12, r12, -0x7f58
	ctx.r[12].s64 = ctx.r[12].s64 + -32600;
	// 82328098: 5520103A  slwi r0, r9, 2
	ctx.r[0].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8232809C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 823280A0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 823280A4: 4E800420  bctr
	match ctx.r[9].u64 {
		0 => {
	pc = 0x823280C4; continue 'dispatch;
		},
		1 => {
	pc = 0x823280E8; continue 'dispatch;
		},
		2 => {
	pc = 0x8232810C; continue 'dispatch;
		},
		3 => {
	pc = 0x82328130; continue 'dispatch;
		},
		4 => {
	pc = 0x82328154; continue 'dispatch;
		},
		5 => {
	pc = 0x8232816C; continue 'dispatch;
		},
		6 => {
	pc = 0x82328184; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 823280A8: 823280C4  lwz r17, -0x7f3c(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32572 as u32) ) } as u64;
	// 823280AC: 823280E8  lwz r17, -0x7f18(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32536 as u32) ) } as u64;
	// 823280B0: 8232810C  lwz r17, -0x7ef4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32500 as u32) ) } as u64;
	// 823280B4: 82328130  lwz r17, -0x7ed0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32464 as u32) ) } as u64;
	// 823280B8: 82328154  lwz r17, -0x7eac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32428 as u32) ) } as u64;
	// 823280BC: 8232816C  lwz r17, -0x7e94(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32404 as u32) ) } as u64;
	// 823280C0: 82328184  lwz r17, -0x7e7c(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-32380 as u32) ) } as u64;
            }
            0x823280C4 => {
    //   block [0x823280C4..0x823280E8)
	// 823280C4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823280C8: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 823280CC: 39200258  li r9, 0x258
	ctx.r[9].s64 = 600;
	// 823280D0: 390000DC  li r8, 0xdc
	ctx.r[8].s64 = 220;
	// 823280D4: C00A2A9C  lfs f0, 0x2a9c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823280D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823280DC: 91230080  stw r9, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 823280E0: 9103008C  stw r8, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[8].u32 ) };
	// 823280E4: 480000B8  b 0x8232819c
	pc = 0x8232819C; continue 'dispatch;
            }
            0x823280E8 => {
    //   block [0x823280E8..0x8232810C)
	// 823280E8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823280EC: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 823280F0: 392000B4  li r9, 0xb4
	ctx.r[9].s64 = 180;
	// 823280F4: 390000BE  li r8, 0xbe
	ctx.r[8].s64 = 190;
	// 823280F8: C00A2A9C  lfs f0, 0x2a9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823280FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82328100: 91230080  stw r9, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 82328104: 9103008C  stw r8, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[8].u32 ) };
	// 82328108: 48000094  b 0x8232819c
	pc = 0x8232819C; continue 'dispatch;
            }
            0x8232810C => {
    //   block [0x8232810C..0x82328130)
	// 8232810C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82328110: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82328114: 392000B4  li r9, 0xb4
	ctx.r[9].s64 = 180;
	// 82328118: 390000DC  li r8, 0xdc
	ctx.r[8].s64 = 220;
	// 8232811C: C00A2A9C  lfs f0, 0x2a9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328120: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82328124: 91230080  stw r9, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 82328128: 9103008C  stw r8, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[8].u32 ) };
	// 8232812C: 48000070  b 0x8232819c
	pc = 0x8232819C; continue 'dispatch;
            }
            0x82328130 => {
    //   block [0x82328130..0x82328154)
	// 82328130: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82328134: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82328138: 392000B4  li r9, 0xb4
	ctx.r[9].s64 = 180;
	// 8232813C: 390000FA  li r8, 0xfa
	ctx.r[8].s64 = 250;
	// 82328140: C00A2A9C  lfs f0, 0x2a9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328144: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82328148: 91230080  stw r9, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 8232814C: 9103008C  stw r8, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[8].u32 ) };
	// 82328150: 4800004C  b 0x8232819c
	pc = 0x8232819C; continue 'dispatch;
            }
            0x82328154 => {
    //   block [0x82328154..0x8232816C)
	// 82328154: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82328158: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 8232815C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82328160: C0092A9C  lfs f0, 0x2a9c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328164: 392000DC  li r9, 0xdc
	ctx.r[9].s64 = 220;
	// 82328168: 4800002C  b 0x82328194
	pc = 0x82328194; continue 'dispatch;
            }
            0x8232816C => {
    //   block [0x8232816C..0x82328184)
	// 8232816C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82328170: 91430080  stw r10, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82328174: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82328178: 91430088  stw r10, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 8232817C: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328180: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	pc = 0x82328184; continue 'dispatch;
            }
            0x82328184 => {
    //   block [0x82328184..0x82328194)
	// 82328184: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82328188: 91430088  stw r10, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 8232818C: C0092A9C  lfs f0, 0x2a9c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328190: 3920001E  li r9, 0x1e
	ctx.r[9].s64 = 30;
	pc = 0x82328194; continue 'dispatch;
            }
            0x82328194 => {
    //   block [0x82328194..0x8232819C)
	// 82328194: 9123008C  stw r9, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[9].u32 ) };
	// 82328198: 91430080  stw r10, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	pc = 0x8232819C; continue 'dispatch;
            }
            0x8232819C => {
    //   block [0x8232819C..0x823281AC)
	// 8232819C: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 823281A0: 91430094  stw r10, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 823281A4: 91430090  stw r10, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 823281A8: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	pc = 0x823281AC; continue 'dispatch;
            }
            0x823281AC => {
    //   block [0x823281AC..0x823282D0)
	// 823281AC: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 823281B0: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 823281B4: 916300A4  stw r11, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 823281B8: 39230410  addi r9, r3, 0x410
	ctx.r[9].s64 = ctx.r[3].s64 + 1040;
	// 823281BC: 916300AC  stw r11, 0xac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 823281C0: 916300C8  stw r11, 0xc8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 823281C4: 3D603F80  lis r11, 0x3f80
	ctx.r[11].s64 = 1065353216;
	// 823281C8: 988316B8  stb r4, 0x16b8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(5816 as u32), ctx.r[4].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823282D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823282D0 size=204
    let mut pc: u32 = 0x823282D0;
    'dispatch: loop {
        match pc {
            0x823282D0 => {
    //   block [0x823282D0..0x8232833C)
	// 823282D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823282D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823282D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823282DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823282E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823282E4: 817F16AC  lwz r11, 0x16ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5804 as u32) ) } as u64;
	// 823282E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823282EC: 419A0058  beq cr6, 0x82328344
	if ctx.cr[6].eq {
	pc = 0x82328344; continue 'dispatch;
	}
	// 823282F0: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 823282F4: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 823282F8: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 823282FC: 394B000B  addi r10, r11, 0xb
	ctx.r[10].s64 = ctx.r[11].s64 + 11;
	// 82328300: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82328304: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82328308: 913F00AC  stw r9, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[9].u32 ) };
	// 8232830C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82328310: 7D4AF82E  lwzx r10, r10, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82328314: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82328318: 409A0024  bne cr6, 0x8232833c
	if !ctx.cr[6].eq {
	pc = 0x8232833C; continue 'dispatch;
	}
	// 8232831C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82328320: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82328324: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82328328: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 8232832C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82328330: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82328334: 41980008  blt cr6, 0x8232833c
	if ctx.cr[6].lt {
	pc = 0x8232833C; continue 'dispatch;
	}
	// 82328338: 48000379  bl 0x823286b0
	ctx.lr = 0x8232833C;
	sub_823286B0(ctx, base);
	pc = 0x8232833C; continue 'dispatch;
            }
            0x8232833C => {
    //   block [0x8232833C..0x82328344)
	// 8232833C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82328340: 48000061  bl 0x823283a0
	ctx.lr = 0x82328344;
	sub_823283A0(ctx, base);
	pc = 0x82328344; continue 'dispatch;
            }
            0x82328344 => {
    //   block [0x82328344..0x8232839C)
	// 82328344: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82328348: C1BF0838  lfs f13, 0x838(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232834C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 82328350: 394BCF90  addi r10, r11, -0x3070
	ctx.r[10].s64 = ctx.r[11].s64 + -12400;
	// 82328354: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82328358: C0091FF8  lfs f0, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232835C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82328360: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82328364: 394A0800  addi r10, r10, 0x800
	ctx.r[10].s64 = ctx.r[10].s64 + 2048;
	// 82328368: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8232836C: C0092A98  lfs f0, 0x2a98(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10904 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328370: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82328374: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82328378: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8232837C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82328380: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82328384: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82328388: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232838C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82328390: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82328394: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82328398: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823283A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823283A0 size=784
    let mut pc: u32 = 0x823283A0;
    'dispatch: loop {
        match pc {
            0x823283A0 => {
    //   block [0x823283A0..0x82328468)
	// 823283A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823283A4: 4820CD01  bl 0x825350a4
	ctx.lr = 0x823283A8;
	sub_82535080(ctx, base);
	// 823283A8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 823283AC: 9421F8F0  stwu r1, -0x710(r1)
	ea = ctx.r[1].u32.wrapping_add(-1808 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823283B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823283B4: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 823283B8: 817E16B0  lwz r11, 0x16b0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(5808 as u32) ) } as u64;
	// 823283BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823283C0: 419A00A8  beq cr6, 0x82328468
	if ctx.cr[6].eq {
	pc = 0x82328468; continue 'dispatch;
	}
	// 823283C4: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 823283C8: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 823283CC: 393E0410  addi r9, r30, 0x410
	ctx.r[9].s64 = ctx.r[30].s64 + 1040;
	// 823283D0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 823283D4: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	pc = 0x82328468; continue 'dispatch;
            }
            0x82328468 => {
    //   block [0x82328468..0x823286B0)
	// 82328468: 817E16AC  lwz r11, 0x16ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(5804 as u32) ) } as u64;
	// 8232846C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82328470: 419A01DC  beq cr6, 0x8232864c
	if ctx.cr[6].eq {
	pc = 0x8232864C; continue 'dispatch;
	}
	// 82328474: 817E00A4  lwz r11, 0xa4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) } as u64;
	// 82328478: 396B000B  addi r11, r11, 0xb
	ctx.r[11].s64 = ctx.r[11].s64 + 11;
	// 8232847C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82328480: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82328484: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82328488: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8232848C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82328490: 419A01BC  beq cr6, 0x8232864c
	if ctx.cr[6].eq {
	pc = 0x8232864C; continue 'dispatch;
	}
	// 82328494: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82328498: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232849C: 3B5E0450  addi r26, r30, 0x450
	ctx.r[26].s64 = ctx.r[30].s64 + 1104;
	// 823284A0: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 823284A4: 3B3E0410  addi r25, r30, 0x410
	ctx.r[25].s64 = ctx.r[30].s64 + 1040;
	// 823284A8: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823284AC: 3B1E01C0  addi r24, r30, 0x1c0
	ctx.r[24].s64 = ctx.r[30].s64 + 448;
	// 823284B0: 3B6BBFF0  addi r27, r11, -0x4010
	ctx.r[27].s64 = ctx.r[11].s64 + -16400;
	// 823284B4: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823284B8: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 823284BC: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 823284C0: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 823284C4: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823284C8: 7FEBF214  add r31, r11, r30
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823284CC: 397F00E0  addi r11, r31, 0xe0
	ctx.r[11].s64 = ctx.r[31].s64 + 224;
	// 823284D0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 823284D4: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 823284D8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823284DC: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 823284E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 823284E4: 4200FFF0  bdnz 0x823284d4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823284D4; continue 'dispatch;
	}
	// 823284E8: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823284EC: C01F00D0  lfs f0, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823284F0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 823284F4: D01E045C  stfs f0, 0x45c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1116 as u32), tmp.u32 ) };
	// 823284F8: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 823284FC: 556B482C  slwi r11, r11, 9
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(9);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82328500: 7F8BF214  add r28, r11, r30
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82328504: 389C0480  addi r4, r28, 0x480
	ctx.r[4].s64 = ctx.r[28].s64 + 1152;
	// 82328508: 4BEF5EC9  bl 0x8221e3d0
	ctx.lr = 0x8232850C;
	sub_8221E3D0(ctx, base);
	// 8232850C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82328510: C1BF00D0  lfs f13, 0xd0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82328514: 616B85D4  ori r11, r11, 0x85d4
	ctx.r[11].u64 = ctx.r[11].u64 | 34260;
	// 82328518: C19F00D4  lfs f12, 0xd4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232851C: 7C1B5C2E  lfsx f0, r27, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328520: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82328524: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82328528: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232852C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82328530: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82328534: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82328538: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8232853C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82328540: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82328544: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82328548: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232854C: 41980030  blt cr6, 0x8232857c
	if ctx.cr[6].lt {
	pc = 0x8232857C; continue 'dispatch;
	}
	// 82328550: D3FF00D0  stfs f31, 0xd0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82328554: 92FF00D8  stw r23, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[23].u32 ) };
	// 82328558: D3FF00D4  stfs f31, 0xd4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8232855C: 2B1D0002  cmplwi cr6, r29, 2
	ctx.cr[6].compare_u32(ctx.r[29].u32, 2 as u32, &mut ctx.xer);
	// 82328560: C01E00BC  lfs f0, 0xbc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328564: C1BF0118  lfs f13, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82328568: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232856C: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82328570: 409A000C  bne cr6, 0x8232857c
	if !ctx.cr[6].eq {
	pc = 0x8232857C; continue 'dispatch;
	}
	// 82328574: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82328578: 48000139  bl 0x823286b0
	ctx.lr = 0x8232857C;
	sub_823286B0(ctx, base);
	// 8232857C: 397D0118  addi r11, r29, 0x118
	ctx.r[11].s64 = ctx.r[29].s64 + 280;
	// 82328580: C01C04F8  lfs f0, 0x4f8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328584: C1BF0118  lfs f13, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82328588: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 8232858C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82328590: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82328594: 2B1D0003  cmplwi cr6, r29, 3
	ctx.cr[6].compare_u32(ctx.r[29].u32, 3 as u32, &mut ctx.xer);
	// 82328598: 7C0BF52E  stfsx f0, r11, r30
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 8232859C: 4198FF18  blt cr6, 0x823284b4
	if ctx.cr[6].lt {
	pc = 0x823284B4; continue 'dispatch;
	}
	// 823285A0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823285A4: C01E00D0  lfs f0, 0xd0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823285A8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823285AC: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823285B0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823285B4: 2F0B003E  cmpwi cr6, r11, 0x3e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 62, &mut ctx.xer);
	// 823285B8: 419A0024  beq cr6, 0x823285dc
	if ctx.cr[6].eq {
	pc = 0x823285DC; continue 'dispatch;
	}
	// 823285BC: 2F0B0074  cmpwi cr6, r11, 0x74
	ctx.cr[6].compare_i32(ctx.r[11].s32, 116, &mut ctx.xer);
	// 823285C0: 419A001C  beq cr6, 0x823285dc
	if ctx.cr[6].eq {
	pc = 0x823285DC; continue 'dispatch;
	}
	// 823285C4: 2F0B00A3  cmpwi cr6, r11, 0xa3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 163, &mut ctx.xer);
	// 823285C8: 419A0014  beq cr6, 0x823285dc
	if ctx.cr[6].eq {
	pc = 0x823285DC; continue 'dispatch;
	}
	// 823285CC: 92FE00C8  stw r23, 0xc8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(200 as u32), ctx.r[23].u32 ) };
	// 823285D0: 38210710  addi r1, r1, 0x710
	ctx.r[1].s64 = ctx.r[1].s64 + 1808;
	// 823285D4: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 823285D8: 4820CB1C  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
	// 823285DC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823285E0: 813E00C8  lwz r9, 0xc8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 823285E4: C1BE04B4  lfs f13, 0x4b4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1204 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823285E8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 823285EC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823285F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823285F4: C01E04B0  lfs f0, 0x4b0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823285F8: C1BE04B8  lfs f13, 0x4b8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823285FC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82328600: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82328604: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82328608: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8232860C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82328610: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82328614: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82328618: C1AB2138  lfs f13, 0x2138(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232861C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82328620: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82328624: 409A0080  bne cr6, 0x823286a4
	if !ctx.cr[6].eq {
	pc = 0x823286A4; continue 'dispatch;
	}
	// 82328628: 38BE00C4  addi r5, r30, 0xc4
	ctx.r[5].s64 = ctx.r[30].s64 + 196;
	// 8232862C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82328630: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82328634: 4803A275  bl 0x823628a8
	ctx.lr = 0x82328638;
	sub_823628A8(ctx, base);
	// 82328638: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232863C: 917E00C8  stw r11, 0xc8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82328640: 38210710  addi r1, r1, 0x710
	ctx.r[1].s64 = ctx.r[1].s64 + 1808;
	// 82328644: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82328648: 4820CAAC  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
	// 8232864C: 397E00E0  addi r11, r30, 0xe0
	ctx.r[11].s64 = ctx.r[30].s64 + 224;
	// 82328650: 395E0410  addi r10, r30, 0x410
	ctx.r[10].s64 = ctx.r[30].s64 + 1040;
	// 82328654: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82328658: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8232865C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82328660: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82328664: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82328668: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8232866C: 4200FFF0  bdnz 0x8232865c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8232865C; continue 'dispatch;
	}
	// 82328670: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82328674: 3BBE01C0  addi r29, r30, 0x1c0
	ctx.r[29].s64 = ctx.r[30].s64 + 448;
	// 82328678: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 8232867C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328680: D01E045C  stfs f0, 0x45c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1116 as u32), tmp.u32 ) };
	// 82328684: 3BDE0480  addi r30, r30, 0x480
	ctx.r[30].s64 = ctx.r[30].s64 + 1152;
	// 82328688: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8232868C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82328690: 4BEF5D41  bl 0x8221e3d0
	ctx.lr = 0x82328694;
	sub_8221E3D0(ctx, base);
	// 82328694: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 82328698: 3BDE0600  addi r30, r30, 0x600
	ctx.r[30].s64 = ctx.r[30].s64 + 1536;
	// 8232869C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823286A0: 409AFFE8  bne cr6, 0x82328688
	if !ctx.cr[6].eq {
	pc = 0x82328688; continue 'dispatch;
	}
	// 823286A4: 38210710  addi r1, r1, 0x710
	ctx.r[1].s64 = ctx.r[1].s64 + 1808;
	// 823286A8: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 823286AC: 4820CA48  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823286B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823286B0 size=288
    let mut pc: u32 = 0x823286B0;
    'dispatch: loop {
        match pc {
            0x823286B0 => {
    //   block [0x823286B0..0x823286E0)
	// 823286B0: 816300A4  lwz r11, 0xa4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(164 as u32) ) } as u64;
	// 823286B4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823286B8: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823286BC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823286C0: 90A300AC  stw r5, 0xac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[5].u32 ) };
	// 823286C4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823286C8: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 823286CC: 814A0088  lwz r10, 0x88(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(136 as u32) ) } as u64;
	// 823286D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823286D4: 419A000C  beq cr6, 0x823286e0
	if ctx.cr[6].eq {
	pc = 0x823286E0; continue 'dispatch;
	}
	// 823286D8: 90A300A4  stw r5, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 823286DC: 4800000C  b 0x823286e8
	pc = 0x823286E8; continue 'dispatch;
            }
            0x823286E0 => {
    //   block [0x823286E0..0x823286E8)
	// 823286E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823286E4: 916300A4  stw r11, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	pc = 0x823286E8; continue 'dispatch;
            }
            0x823286E8 => {
    //   block [0x823286E8..0x82328790)
	// 823286E8: 816300A4  lwz r11, 0xa4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(164 as u32) ) } as u64;
	// 823286EC: 39230410  addi r9, r3, 0x410
	ctx.r[9].s64 = ctx.r[3].s64 + 1040;
	// 823286F0: 81430454  lwz r10, 0x454(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1108 as u32) ) } as u64;
	// 823286F4: 3901FFC0  addi r8, r1, -0x40
	ctx.r[8].s64 = ctx.r[1].s64 + -64;
	// 823286F8: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 823286FC: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 82328700: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 82328704: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82328708: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 8232870C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82328710: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82328714: F961FFB0  std r11, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.r[11].u64 ) };
	// 82328718: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232871C: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82328720: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82328724: F961FFB8  std r11, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.r[11].u64 ) };
	// 82328728: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232872C: C801FFB0  lfd f0, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82328730: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82328734: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82328738: C9A1FFB8  lfd f13, -0x48(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8232873C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82328740: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82328744: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82328748: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232874C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82328750: D00300D4  stfs f0, 0xd4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82328754: C18316B4  lfs f12, 0x16b4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(5812 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82328758: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232875C: D1A300D0  stfs f13, 0xd0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82328760: D0030124  stfs f0, 0x124(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82328764: C18316B4  lfs f12, 0x16b4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(5812 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82328768: C1AB2074  lfs f13, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232876C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82328770: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82328774: D0030174  stfs f0, 0x174(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 82328778: D1A30120  stfs f13, 0x120(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 8232877C: C1A316B4  lfs f13, 0x16b4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(5812 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82328780: C00B24DC  lfs f0, 0x24dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9436 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328784: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82328788: D0030170  stfs f0, 0x170(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 8232878C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82328790; continue 'dispatch;
            }
            0x82328790 => {
    //   block [0x82328790..0x823287D0)
	// 82328790: E9690000  ld r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 82328794: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82328798: F9680000  std r11, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8232879C: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 823287A0: 4200FFF0  bdnz 0x82328790
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82328790; continue 'dispatch;
	}
	// 823287A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823287A8: C1A1FFF8  lfs f13, -8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823287AC: C18300B0  lfs f12, 0xb0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823287B0: C00B24D8  lfs f0, 0x24d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823287B4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823287B8: C1A300BC  lfs f13, 0xbc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823287BC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823287C0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 823287C4: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 823287C8: 90A316AC  stw r5, 0x16ac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(5804 as u32), ctx.r[5].u32 ) };
	// 823287CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823287D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823287D0 size=304
    let mut pc: u32 = 0x823287D0;
    'dispatch: loop {
        match pc {
            0x823287D0 => {
    //   block [0x823287D0..0x8232882C)
	// 823287D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823287D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823287D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823287DC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 823287E0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 823287E4: 38EBBFF0  addi r7, r11, -0x4010
	ctx.r[7].s64 = ctx.r[11].s64 + -16400;
	// 823287E8: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 823287EC: 616B9450  ori r11, r11, 0x9450
	ctx.r[11].u64 = ctx.r[11].u64 | 37968;
	// 823287F0: 7D675A2E  lhzx r11, r7, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823287F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823287F8: 409A00F8  bne cr6, 0x823288f0
	if !ctx.cr[6].eq {
	pc = 0x823288F0; continue 'dispatch;
	}
	// 823287FC: 38681684  addi r3, r8, 0x1684
	ctx.r[3].s64 = ctx.r[8].s64 + 5764;
	// 82328800: 4BF04BE9  bl 0x8222d3e8
	ctx.lr = 0x82328804;
	sub_8222D3E8(ctx, base);
	// 82328804: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82328808: C0081694  lfs f0, 0x1694(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(5780 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232880C: 396800D0  addi r11, r8, 0xd0
	ctx.r[11].s64 = ctx.r[8].s64 + 208;
	// 82328810: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82328814: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 82328818: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 8232881C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82328820: 1D4A00F0  mulli r10, r10, 0xf0
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 240 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82328824: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82328828: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8232882C; continue 'dispatch;
            }
            0x8232882C => {
    //   block [0x8232882C..0x8232886C)
	// 8232882C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82328830: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82328834: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82328838: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8232883C: 4200FFF0  bdnz 0x8232882c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8232882C; continue 'dispatch;
	}
	// 82328840: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82328844: C0081694  lfs f0, 0x1694(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(5780 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328848: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232884C: 39680120  addi r11, r8, 0x120
	ctx.r[11].s64 = ctx.r[8].s64 + 288;
	// 82328850: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 82328854: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82328858: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232885C: 1D4A00F0  mulli r10, r10, 0xf0
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 240 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82328860: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82328864: 394A0050  addi r10, r10, 0x50
	ctx.r[10].s64 = ctx.r[10].s64 + 80;
	// 82328868: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8232886C; continue 'dispatch;
            }
            0x8232886C => {
    //   block [0x8232886C..0x823288AC)
	// 8232886C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82328870: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82328874: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82328878: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8232887C: 4200FFF0  bdnz 0x8232886c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8232886C; continue 'dispatch;
	}
	// 82328880: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82328884: C0081694  lfs f0, 0x1694(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(5780 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328888: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232888C: 39680170  addi r11, r8, 0x170
	ctx.r[11].s64 = ctx.r[8].s64 + 368;
	// 82328890: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 82328894: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82328898: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232889C: 1D4A00F0  mulli r10, r10, 0xf0
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 240 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823288A0: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 823288A4: 394A00A0  addi r10, r10, 0xa0
	ctx.r[10].s64 = ctx.r[10].s64 + 160;
	// 823288A8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x823288AC; continue 'dispatch;
            }
            0x823288AC => {
    //   block [0x823288AC..0x823288F0)
	// 823288AC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 823288B0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823288B4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 823288B8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 823288BC: 4200FFF0  bdnz 0x823288ac
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823288AC; continue 'dispatch;
	}
	// 823288C0: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 823288C4: C1A81694  lfs f13, 0x1694(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(5780 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823288C8: 616B85D4  ori r11, r11, 0x85d4
	ctx.r[11].u64 = ctx.r[11].u64 | 34260;
	// 823288CC: 7C075C2E  lfsx f0, r7, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823288D0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 823288D4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823288D8: D0081694  stfs f0, 0x1694(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(5780 as u32), tmp.u32 ) };
	// 823288DC: C1ABF3EC  lfs f13, -0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823288E0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823288E4: 4198000C  blt cr6, 0x823288f0
	if ctx.cr[6].lt {
	pc = 0x823288F0; continue 'dispatch;
	}
	// 823288E8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823288EC: D0081694  stfs f0, 0x1694(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(5780 as u32), tmp.u32 ) };
	pc = 0x823288F0; continue 'dispatch;
            }
            0x823288F0 => {
    //   block [0x823288F0..0x82328900)
	// 823288F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823288F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823288F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823288FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82328900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82328900 size=628
    let mut pc: u32 = 0x82328900;
    'dispatch: loop {
        match pc {
            0x82328900 => {
    //   block [0x82328900..0x82328930)
	// 82328900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82328904: 4820C7A5  bl 0x825350a8
	ctx.lr = 0x82328908;
	sub_82535080(ctx, base);
	// 82328908: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 8232890C: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 82328910: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82328914: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82328918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232891C: 815F1684  lwz r10, 0x1684(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5764 as u32) ) } as u64;
	// 82328920: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82328924: 409A000C  bne cr6, 0x82328930
	if !ctx.cr[6].eq {
	pc = 0x82328930; continue 'dispatch;
	}
	// 82328928: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232892C: 4800002C  b 0x82328958
	pc = 0x82328958; continue 'dispatch;
            }
            0x82328930 => {
    //   block [0x82328930..0x82328948)
	// 82328930: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82328934: 813F168C  lwz r9, 0x168c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5772 as u32) ) } as u64;
	// 82328938: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232893C: 419A000C  beq cr6, 0x82328948
	if ctx.cr[6].eq {
	pc = 0x82328948; continue 'dispatch;
	}
	// 82328940: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82328944: 48000014  b 0x82328958
	pc = 0x82328958; continue 'dispatch;
            }
            0x82328948 => {
    //   block [0x82328948..0x82328958)
	// 82328948: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232894C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82328950: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82328954: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x82328958; continue 'dispatch;
            }
            0x82328958 => {
    //   block [0x82328958..0x8232896C)
	// 82328958: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8232895C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82328960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82328964: 419A0008  beq cr6, 0x8232896c
	if ctx.cr[6].eq {
	pc = 0x8232896C; continue 'dispatch;
	}
	// 82328968: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8232896C; continue 'dispatch;
            }
            0x8232896C => {
    //   block [0x8232896C..0x823289C4)
	// 8232896C: C01F1694  lfs f0, 0x1694(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5780 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328970: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82328974: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82328978: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232897C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82328980: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82328984: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82328988: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8232898C: FDA06E5E  fctidz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 82328990: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82328994: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82328998: FDA0665E  fctidz f13, f12
	ctx.f[13].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 8232899C: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823289A0: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 823289A4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823289A8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823289AC: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823289B0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823289B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823289B8: 2B0B0384  cmplwi cr6, r11, 0x384
	ctx.cr[6].compare_u32(ctx.r[11].u32, 900 as u32, &mut ctx.xer);
	// 823289BC: 41980008  blt cr6, 0x823289c4
	if ctx.cr[6].lt {
	pc = 0x823289C4; continue 'dispatch;
	}
	// 823289C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x823289C4; continue 'dispatch;
            }
            0x823289C4 => {
    //   block [0x823289C4..0x823289FC)
	// 823289C4: 1D4B00F0  mulli r10, r11, 0xf0
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 240 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823289C8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823289CC: 1D6B00F0  mulli r11, r11, 0xf0
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 240 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823289D0: 7F8A4A14  add r28, r10, r9
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823289D4: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 823289D8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 823289DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823289E0: 3B1F0410  addi r24, r31, 0x410
	ctx.r[24].s64 = ctx.r[31].s64 + 1040;
	// 823289E4: 3B3F01C0  addi r25, r31, 0x1c0
	ctx.r[25].s64 = ctx.r[31].s64 + 448;
	// 823289E8: 3B5F0460  addi r26, r31, 0x460
	ctx.r[26].s64 = ctx.r[31].s64 + 1120;
	// 823289EC: 3BDF04F8  addi r30, r31, 0x4f8
	ctx.r[30].s64 = ctx.r[31].s64 + 1272;
	// 823289F0: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823289F4: 3B600003  li r27, 3
	ctx.r[27].s64 = 3;
	// 823289F8: C3AABA38  lfs f29, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	pc = 0x823289FC; continue 'dispatch;
            }
            0x823289FC => {
    //   block [0x823289FC..0x82328A0C)
	// 823289FC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82328A00: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82328A04: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 82328A08: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82328A0C; continue 'dispatch;
            }
            0x82328A0C => {
    //   block [0x82328A0C..0x82328A30)
	// 82328A0C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82328A10: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82328A14: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82328A18: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82328A1C: 4200FFF0  bdnz 0x82328a0c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82328A0C; continue 'dispatch;
	}
	// 82328A20: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 82328A24: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82328A28: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 82328A2C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82328A30; continue 'dispatch;
            }
            0x82328A30 => {
    //   block [0x82328A30..0x82328A64)
	// 82328A30: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82328A34: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82328A38: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82328A3C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82328A40: 4200FFF0  bdnz 0x82328a30
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82328A30; continue 'dispatch;
	}
	// 82328A44: C00100C0  lfs f0, 0xc0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328A48: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82328A4C: 40990018  ble cr6, 0x82328a64
	if !ctx.cr[6].gt {
	pc = 0x82328A64; continue 'dispatch;
	}
	// 82328A50: EDBDF828  fsubs f13, f29, f31
	ctx.f[13].f64 = (((ctx.f[29].f64 - ctx.f[31].f64) as f32) as f64);
	// 82328A54: C1810070  lfs f12, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82328A58: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82328A5C: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82328A60: 48000008  b 0x82328a68
	pc = 0x82328A68; continue 'dispatch;
            }
            0x82328A64 => {
    //   block [0x82328A64..0x82328A68)
	// 82328A64: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82328A68; continue 'dispatch;
            }
            0x82328A68 => {
    //   block [0x82328A68..0x82328A78)
	// 82328A68: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82328A6C: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82328A70: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82328A74: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82328A78; continue 'dispatch;
            }
            0x82328A78 => {
    //   block [0x82328A78..0x82328B40)
	// 82328A78: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82328A7C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82328A80: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82328A84: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82328A88: 4200FFF0  bdnz 0x82328a78
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82328A78; continue 'dispatch;
	}
	// 82328A8C: 389EFF88  addi r4, r30, -0x78
	ctx.r[4].s64 = ctx.r[30].s64 + -120;
	// 82328A90: D01F045C  stfs f0, 0x45c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1116 as u32), tmp.u32 ) };
	// 82328A94: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82328A98: 4BEF5939  bl 0x8221e3d0
	ctx.lr = 0x82328A9C;
	sub_8221E3D0(ctx, base);
	// 82328A9C: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328AA0: C1A100B8  lfs f13, 0xb8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82328AA4: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 82328AA8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82328AAC: D01A0000  stfs f0, 0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82328AB0: 3BBD0050  addi r29, r29, 0x50
	ctx.r[29].s64 = ctx.r[29].s64 + 80;
	// 82328AB4: 3B9C0050  addi r28, r28, 0x50
	ctx.r[28].s64 = ctx.r[28].s64 + 80;
	// 82328AB8: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82328ABC: 3BDE0600  addi r30, r30, 0x600
	ctx.r[30].s64 = ctx.r[30].s64 + 1536;
	// 82328AC0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82328AC4: 409AFF38  bne cr6, 0x823289fc
	if !ctx.cr[6].eq {
	pc = 0x823289FC; continue 'dispatch;
	}
	// 82328AC8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 82328ACC: C01F0838  lfs f0, 0x838(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328AD0: D3C10060  stfs f30, 0x60(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82328AD4: 394BCF90  addi r10, r11, -0x3070
	ctx.r[10].s64 = ctx.r[11].s64 + -12400;
	// 82328AD8: D3C10064  stfs f30, 0x64(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82328ADC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82328AE0: 392A0800  addi r9, r10, 0x800
	ctx.r[9].s64 = ctx.r[10].s64 + 2048;
	// 82328AE4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82328AE8: C1AA2A98  lfs f13, 0x2a98(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10904 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82328AEC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82328AF0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82328AF4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82328AF8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82328AFC: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82328B00: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82328B04: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82328B08: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82328B0C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82328B10: C1BF1694  lfs f13, 0x1694(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5780 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82328B14: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82328B18: 614A9478  ori r10, r10, 0x9478
	ctx.r[10].u64 = ctx.r[10].u64 | 38008;
	// 82328B1C: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328B20: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82328B24: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82328B28: D01F1694  stfs f0, 0x1694(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5780 as u32), tmp.u32 ) };
	// 82328B2C: C1ABF3EC  lfs f13, -0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82328B30: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82328B34: 4198000C  blt cr6, 0x82328b40
	if ctx.cr[6].lt {
	pc = 0x82328B40; continue 'dispatch;
	}
	// 82328B38: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82328B3C: D01F1694  stfs f0, 0x1694(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5780 as u32), tmp.u32 ) };
	pc = 0x82328B40; continue 'dispatch;
            }
            0x82328B40 => {
    //   block [0x82328B40..0x82328B60)
	// 82328B40: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 82328B44: 816ABC24  lwz r11, -0x43dc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17372 as u32) ) } as u64;
	// 82328B48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82328B4C: 419A0014  beq cr6, 0x82328b60
	if ctx.cr[6].eq {
	pc = 0x82328B60; continue 'dispatch;
	}
	// 82328B50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82328B54: C01F1698  lfs f0, 0x1698(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5784 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328B58: D01F1694  stfs f0, 0x1694(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5780 as u32), tmp.u32 ) };
	// 82328B5C: 916ABC24  stw r11, -0x43dc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17372 as u32), ctx.r[11].u32 ) };
	pc = 0x82328B60; continue 'dispatch;
            }
            0x82328B60 => {
    //   block [0x82328B60..0x82328B74)
	// 82328B60: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82328B64: CBA1FFA0  lfd f29, -0x60(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82328B68: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82328B6C: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82328B70: 4820C588  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82328B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82328B78 size=164
    let mut pc: u32 = 0x82328B78;
    'dispatch: loop {
        match pc {
            0x82328B78 => {
    //   block [0x82328B78..0x82328B90)
	// 82328B78: 81431684  lwz r10, 0x1684(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(5764 as u32) ) } as u64;
	// 82328B7C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82328B80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82328B84: 409A000C  bne cr6, 0x82328b90
	if !ctx.cr[6].eq {
	pc = 0x82328B90; continue 'dispatch;
	}
	// 82328B88: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82328B8C: 4800002C  b 0x82328bb8
	pc = 0x82328BB8; continue 'dispatch;
            }
            0x82328B90 => {
    //   block [0x82328B90..0x82328BA8)
	// 82328B90: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82328B94: 8103168C  lwz r8, 0x168c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(5772 as u32) ) } as u64;
	// 82328B98: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82328B9C: 419A000C  beq cr6, 0x82328ba8
	if ctx.cr[6].eq {
	pc = 0x82328BA8; continue 'dispatch;
	}
	// 82328BA0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82328BA4: 48000014  b 0x82328bb8
	pc = 0x82328BB8; continue 'dispatch;
            }
            0x82328BA8 => {
    //   block [0x82328BA8..0x82328BB8)
	// 82328BA8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82328BAC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82328BB0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82328BB4: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x82328BB8; continue 'dispatch;
            }
            0x82328BB8 => {
    //   block [0x82328BB8..0x82328BCC)
	// 82328BB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82328BBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82328BC0: 409A000C  bne cr6, 0x82328bcc
	if !ctx.cr[6].eq {
	pc = 0x82328BCC; continue 'dispatch;
	}
	// 82328BC4: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82328BC8: 48000008  b 0x82328bd0
	pc = 0x82328BD0; continue 'dispatch;
            }
            0x82328BCC => {
    //   block [0x82328BCC..0x82328BD0)
	// 82328BCC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82328BD0; continue 'dispatch;
            }
            0x82328BD0 => {
    //   block [0x82328BD0..0x82328BE4)
	// 82328BD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82328BD4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328BD8: 396A0058  addi r11, r10, 0x58
	ctx.r[11].s64 = ctx.r[10].s64 + 88;
	// 82328BDC: D0031694  stfs f0, 0x1694(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(5780 as u32), tmp.u32 ) };
	// 82328BE0: 39400384  li r10, 0x384
	ctx.r[10].s64 = 900;
	pc = 0x82328BE4; continue 'dispatch;
            }
            0x82328BE4 => {
    //   block [0x82328BE4..0x82328C1C)
	// 82328BE4: D00BFFA8  stfs f0, -0x58(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-88 as u32), tmp.u32 ) };
	// 82328BE8: 912BFFB0  stw r9, -0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-80 as u32), ctx.r[9].u32 ) };
	// 82328BEC: D00BFFAC  stfs f0, -0x54(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-84 as u32), tmp.u32 ) };
	// 82328BF0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82328BF4: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82328BF8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82328BFC: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82328C00: 912B0050  stw r9, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82328C04: D00B0048  stfs f0, 0x48(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82328C08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82328C0C: D00B004C  stfs f0, 0x4c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82328C10: 396B00F0  addi r11, r11, 0xf0
	ctx.r[11].s64 = ctx.r[11].s64 + 240;
	// 82328C14: 409AFFD0  bne cr6, 0x82328be4
	if !ctx.cr[6].eq {
	pc = 0x82328BE4; continue 'dispatch;
	}
	// 82328C18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82328C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82328C20 size=248
    let mut pc: u32 = 0x82328C20;
    'dispatch: loop {
        match pc {
            0x82328C20 => {
    //   block [0x82328C20..0x82328C94)
	// 82328C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82328C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82328C28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82328C2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82328C30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82328C34: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82328C38: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82328C3C: 419A0084  beq cr6, 0x82328cc0
	if ctx.cr[6].eq {
	pc = 0x82328CC0; continue 'dispatch;
	}
	// 82328C40: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 82328C44: 419A0050  beq cr6, 0x82328c94
	if ctx.cr[6].eq {
	pc = 0x82328C94; continue 'dispatch;
	}
	// 82328C48: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 82328C4C: 409A00B8  bne cr6, 0x82328d04
	if !ctx.cr[6].eq {
	pc = 0x82328D04; continue 'dispatch;
	}
	// 82328C50: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82328C54: C19F16A4  lfs f12, 0x16a4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5796 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82328C58: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82328C5C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82328C60: 614A85D4  ori r10, r10, 0x85d4
	ctx.r[10].u64 = ctx.r[10].u64 | 34260;
	// 82328C64: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328C68: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82328C6C: C1AB2164  lfs f13, 0x2164(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8548 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82328C70: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82328C74: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82328C78: D01F16A4  stfs f0, 0x16a4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5796 as u32), tmp.u32 ) };
	// 82328C7C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82328C80: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82328C84: 41980080  blt cr6, 0x82328d04
	if ctx.cr[6].lt {
	pc = 0x82328D04; continue 'dispatch;
	}
	// 82328C88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82328C8C: 917F16A8  stw r11, 0x16a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5800 as u32), ctx.r[11].u32 ) };
	// 82328C90: 4800006C  b 0x82328cfc
	pc = 0x82328CFC; continue 'dispatch;
            }
            0x82328C94 => {
    //   block [0x82328C94..0x82328CC0)
	// 82328C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82328C98: 889F16B8  lbz r4, 0x16b8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5816 as u32) ) } as u64;
	// 82328C9C: 4BFFF3D5  bl 0x82328070
	ctx.lr = 0x82328CA0;
	sub_82328070(ctx, base);
	// 82328CA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82328CA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82328CA8: 917F16AC  stw r11, 0x16ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5804 as u32), ctx.r[11].u32 ) };
	// 82328CAC: 917F1690  stw r11, 0x1690(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5776 as u32), ctx.r[11].u32 ) };
	// 82328CB0: 4BFFFEC9  bl 0x82328b78
	ctx.lr = 0x82328CB4;
	sub_82328B78(ctx, base);
	// 82328CB4: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82328CB8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82328CBC: 48000044  b 0x82328d00
	pc = 0x82328D00; continue 'dispatch;
            }
            0x82328CC0 => {
    //   block [0x82328CC0..0x82328CFC)
	// 82328CC0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82328CC4: C19F16A4  lfs f12, 0x16a4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5796 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82328CC8: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 82328CCC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82328CD0: 612985D4  ori r9, r9, 0x85d4
	ctx.r[9].u64 = ctx.r[9].u64 | 34260;
	// 82328CD4: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82328CD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82328CDC: C1AB2164  lfs f13, 0x2164(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8548 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82328CE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82328CE4: EC00637C  fnmsubs f0, f0, f13, f12
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82328CE8: D01F16A4  stfs f0, 0x16a4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5796 as u32), tmp.u32 ) };
	// 82328CEC: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82328CF0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82328CF4: 41990010  bgt cr6, 0x82328d04
	if ctx.cr[6].gt {
	pc = 0x82328D04; continue 'dispatch;
	}
	// 82328CF8: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	pc = 0x82328CFC; continue 'dispatch;
            }
            0x82328CFC => {
    //   block [0x82328CFC..0x82328D00)
	// 82328CFC: D1BF16A4  stfs f13, 0x16a4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5796 as u32), tmp.u32 ) };
	pc = 0x82328D00; continue 'dispatch;
            }
            0x82328D00 => {
    //   block [0x82328D00..0x82328D04)
	// 82328D00: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	pc = 0x82328D04; continue 'dispatch;
            }
            0x82328D04 => {
    //   block [0x82328D04..0x82328D18)
	// 82328D04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82328D08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82328D0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82328D10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82328D14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82328D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82328D18 size=552
    let mut pc: u32 = 0x82328D18;
    'dispatch: loop {
        match pc {
            0x82328D18 => {
    //   block [0x82328D18..0x82328F40)
	// 82328D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82328D1C: 4820C391  bl 0x825350ac
	ctx.lr = 0x82328D20;
	sub_82535080(ctx, base);
	// 82328D20: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82328D24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82328D28: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82328D2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82328D30: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82328D34: 387F0260  addi r3, r31, 0x260
	ctx.r[3].s64 = ctx.r[31].s64 + 608;
	// 82328D38: 392A4634  addi r9, r10, 0x4634
	ctx.r[9].s64 = ctx.r[10].s64 + 17972;
	// 82328D3C: C18B1FF8  lfs f12, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82328D40: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82328D44: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82328D48: 396BD964  addi r11, r11, -0x269c
	ctx.r[11].s64 = ctx.r[11].s64 + -9884;
	// 82328D4C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82328D50: 3B200030  li r25, 0x30
	ctx.r[25].s64 = 48;
	// 82328D54: 3B400020  li r26, 0x20
	ctx.r[26].s64 = 32;
	// 82328D58: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 82328D5C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82328D60: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82328D64: 915F00BC  stw r10, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 82328D68: 3FA03F80  lis r29, 0x3f80
	ctx.r[29].s64 = 1065353216;
	// 82328D6C: 93DF00D0  stw r30, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[30].u32 ) };
	// 82328D70: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82328D74: B3DF00D4  sth r30, 0xd4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[30].u16 ) };
	// 82328D78: B3DF00D6  sth r30, 0xd6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(214 as u32), ctx.r[30].u16 ) };
	// 82328D7C: D183029C  stfs f12, 0x29c(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82328D80: 814BBC20  lwz r10, -0x43e0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17376 as u32) ) } as u64;
	// 82328D84: 39630250  addi r11, r3, 0x250
	ctx.r[11].s64 = ctx.r[3].s64 + 592;
	// 82328D88: 93C30294  stw r30, 0x294(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(660 as u32), ctx.r[30].u32 ) };
	// 82328D8C: 93C30298  stw r30, 0x298(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(664 as u32), ctx.r[30].u32 ) };
	// 82328D90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82328D94: 91230290  stw r9, 0x290(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(656 as u32), ctx.r[9].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82328F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82328F40 size=188
    let mut pc: u32 = 0x82328F40;
    'dispatch: loop {
        match pc {
            0x82328F40 => {
    //   block [0x82328F40..0x82328F9C)
	// 82328F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82328F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82328F48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82328F4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82328F50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82328F54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82328F58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82328F5C: 3D4082D0  lis r10, -0x7d30
	ctx.r[10].s64 = -2100297728;
	// 82328F60: 396BD964  addi r11, r11, -0x269c
	ctx.r[11].s64 = ctx.r[11].s64 + -9884;
	// 82328F64: 394A4998  addi r10, r10, 0x4998
	ctx.r[10].s64 = ctx.r[10].s64 + 18840;
	// 82328F68: 813F055C  lwz r9, 0x55c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1372 as u32) ) } as u64;
	// 82328F6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82328F70: 3D00829F  lis r8, -0x7d61
	ctx.r[8].s64 = -2103508992;
	// 82328F74: 5527103A  slwi r7, r9, 2
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82328F78: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 82328F7C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82328F80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82328F84: 7CC7512E  stwx r6, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 82328F88: 807F0550  lwz r3, 0x550(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1360 as u32) ) } as u64;
	// 82328F8C: 9128B518  stw r9, -0x4ae8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(-19176 as u32), ctx.r[9].u32 ) };
	// 82328F90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82328F94: 419A0008  beq cr6, 0x82328f9c
	if ctx.cr[6].eq {
	pc = 0x82328F9C; continue 'dispatch;
	}
	// 82328F98: 4BDF40C1  bl 0x8211d058
	ctx.lr = 0x82328F9C;
	sub_8211D058(ctx, base);
	pc = 0x82328F9C; continue 'dispatch;
            }
            0x82328F9C => {
    //   block [0x82328F9C..0x82328FE4)
	// 82328F9C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82328FA0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82328FA4: 396B4634  addi r11, r11, 0x4634
	ctx.r[11].s64 = ctx.r[11].s64 + 17972;
	// 82328FA8: 394ADED0  addi r10, r10, -0x2130
	ctx.r[10].s64 = ctx.r[10].s64 + -8496;
	// 82328FAC: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82328FB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82328FB4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82328FB8: 917F04F0  stw r11, 0x4f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1264 as u32), ctx.r[11].u32 ) };
	// 82328FBC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82328FC0: 419A0024  beq cr6, 0x82328fe4
	if ctx.cr[6].eq {
	pc = 0x82328FE4; continue 'dispatch;
	}
	// 82328FC4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82328FC8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82328FCC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82328FD0: 409A0014  bne cr6, 0x82328fe4
	if !ctx.cr[6].eq {
	pc = 0x82328FE4; continue 'dispatch;
	}
	// 82328FD4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82328FD8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82328FDC: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82328FE0: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x82328FE4; continue 'dispatch;
            }
            0x82328FE4 => {
    //   block [0x82328FE4..0x82328FFC)
	// 82328FE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82328FE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82328FEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82328FF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82328FF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82328FF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82329000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82329000 size=736
    let mut pc: u32 = 0x82329000;
    'dispatch: loop {
        match pc {
            0x82329000 => {
    //   block [0x82329000..0x823292BC)
	// 82329000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82329004: 4820C09D  bl 0x825350a0
	ctx.lr = 0x82329008;
	sub_82535080(ctx, base);
	// 82329008: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232900C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82329010: 3D605555  lis r11, 0x5555
	ctx.r[11].s64 = 1431633920;
	// 82329014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82329018: 61655556  ori r5, r11, 0x5556
	ctx.r[5].u64 = ctx.r[11].u64 | 21846;
	// 8232901C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82329020: C1A9BA38  lfs f13, -0x45c8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329024: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82329028: 391F00F0  addi r8, r31, 0xf0
	ctx.r[8].s64 = ctx.r[31].s64 + 240;
	// 8232902C: 815F055C  lwz r10, 0x55c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1372 as u32) ) } as u64;
	// 82329030: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82329034: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82329038: D1BF0568  stfs f13, 0x568(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1384 as u32), tmp.u32 ) };
	// 8232903C: C00B203C  lfs f0, 0x203c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82329040: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82329044: C189D6E8  lfs f12, -0x2918(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82329048: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 8232904C: 396B8C60  addi r11, r11, -0x73a0
	ctx.r[11].s64 = ctx.r[11].s64 + -29600;
	// 82329050: D01F0564  stfs f0, 0x564(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1380 as u32), tmp.u32 ) };
	// 82329054: 3C804020  lis r4, 0x4020
	ctx.r[4].s64 = 1075838976;
	// 82329058: D19F056C  stfs f12, 0x56c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1388 as u32), tmp.u32 ) };
	// 8232905C: 38EB0100  addi r7, r11, 0x100
	ctx.r[7].s64 = ctx.r[11].s64 + 256;
	// 82329060: 9B9F001E  stb r28, 0x1e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(30 as u32), ctx.r[28].u8 ) };
	// 82329064: 38600022  li r3, 0x22
	ctx.r[3].s64 = 34;
	// 82329068: 9B9F001C  stb r28, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[28].u8 ) };
	// 8232906C: C169D5BC  lfs f11, -0x2a44(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10820 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82329070: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82329074: 3BA00120  li r29, 0x120
	ctx.r[29].s64 = 288;
	// 82329078: D17F0578  stfs f11, 0x578(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1400 as u32), tmp.u32 ) };
	// 8232907C: 3B600030  li r27, 0x30
	ctx.r[27].s64 = 48;
	// 82329080: 93DF0540  stw r30, 0x540(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1344 as u32), ctx.r[30].u32 ) };
	// 82329084: 3B400920  li r26, 0x920
	ctx.r[26].s64 = 2336;
	// 82329088: 3B200004  li r25, 4
	ctx.r[25].s64 = 4;
	// 8232908C: C1492684  lfs f10, 0x2684(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9860 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82329090: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82329094: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82329098: D15F057C  stfs f10, 0x57c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1404 as u32), tmp.u32 ) };
	// 8232909C: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 823290A0: 3B00000D  li r24, 0xd
	ctx.r[24].s64 = 13;
	// 823290A4: 3AFF0120  addi r23, r31, 0x120
	ctx.r[23].s64 = ctx.r[31].s64 + 288;
	// 823290A8: 3ACB0100  addi r22, r11, 0x100
	ctx.r[22].s64 = ctx.r[11].s64 + 256;
	// 823290AC: C0071FF8  lfs f0, 0x1ff8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823290B0: 3CE08288  lis r7, -0x7d78
	ctx.r[7].s64 = -2105016320;
	// 823290B4: 38C78E38  addi r6, r7, -0x71c8
	ctx.r[6].s64 = ctx.r[7].s64 + -29128;
	// 823290B8: 7CEA2896  mulhw r7, r10, r5
	ctx.r[7].s64 = ((ctx.r[10].s32 as i64 * ctx.r[5].s32 as i64) >> 32);
	// 823290BC: 54E50FFE  srwi r5, r7, 0x1f
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shr(31);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823290C0: 7CE72A14  add r7, r7, r5
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 823290C4: 54E5083C  slwi r5, r7, 1
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823290C8: 7CE72A14  add r7, r7, r5
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 823290CC: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 823290D0: 995F0574  stb r10, 0x574(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1396 as u32), ctx.r[10].u8 ) };
	// 823290D4: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 823290D8: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 823290DC: 909F00B8  stw r4, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[4].u32 ) };
	// 823290E0: 907F00A4  stw r3, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 823290E4: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 823290E8: 93BF00B4  stw r29, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[29].u32 ) };
	// 823290EC: 814ABC20  lwz r10, -0x43e0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17376 as u32) ) } as u64;
	// 823290F0: 93DF00A8  stw r30, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 823290F4: 937F00B0  stw r27, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[27].u32 ) };
	// 823290F8: 935F00B4  stw r26, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[26].u32 ) };
	// 823290FC: 80EA0470  lwz r7, 0x470(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1136 as u32) ) } as u64;
	// 82329100: 814A046C  lwz r10, 0x46c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82329104: 933F00A8  stw r25, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[25].u32 ) };
	// 82329108: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 8232910C: 38FF0150  addi r7, r31, 0x150
	ctx.r[7].s64 = ctx.r[31].s64 + 336;
	// 82329110: 915F00A0  stw r10, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 82329114: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82329118: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8232911C: 90DF00D0  stw r6, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[6].u32 ) };
	// 82329120: B31F00D4  sth r24, 0xd4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[24].u16 ) };
	// 82329124: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 82329128: B3DF00D6  sth r30, 0xd6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(214 as u32), ctx.r[30].u16 ) };
	// 8232912C: E9480000  ld r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 82329130: F9490000  std r10, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82329134: E9480008  ld r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 82329138: 390B0100  addi r8, r11, 0x100
	ctx.r[8].s64 = ctx.r[11].s64 + 256;
	// 8232913C: F9490008  std r10, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82329140: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82329144: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 82329148: C189267C  lfs f12, 0x267c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9852 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232914C: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82329150: 3BBF01E0  addi r29, r31, 0x1e0
	ctx.r[29].s64 = ctx.r[31].s64 + 480;
	// 82329154: C1662680  lfs f11, 0x2680(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(9856 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82329158: 3B6B0100  addi r27, r11, 0x100
	ctx.r[27].s64 = ctx.r[11].s64 + 256;
	// 8232915C: 38CB0100  addi r6, r11, 0x100
	ctx.r[6].s64 = ctx.r[11].s64 + 256;
	// 82329160: 388B0100  addi r4, r11, 0x100
	ctx.r[4].s64 = ctx.r[11].s64 + 256;
	// 82329164: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82329168: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 8232916C: EB6A0000  ld r27, 0(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82329170: 38BF0180  addi r5, r31, 0x180
	ctx.r[5].s64 = ctx.r[31].s64 + 384;
	// 82329174: 387F01B0  addi r3, r31, 0x1b0
	ctx.r[3].s64 = ctx.r[31].s64 + 432;
	// 82329178: FB690000  std r27, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 8232917C: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82329180: F9490008  std r10, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82329184: E9480000  ld r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 82329188: F9470000  std r10, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 8232918C: E9480008  ld r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 82329190: F9470008  std r10, 8(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82329194: E9460000  ld r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 82329198: F9450000  std r10, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 8232919C: E9460008  ld r10, 8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	// 823291A0: F9450008  std r10, 8(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 823291A4: E9440000  ld r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 823291A8: F9430000  std r10, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 823291AC: E9440008  ld r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	// 823291B0: F9430008  std r10, 8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 823291B4: E95D0000  ld r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 823291B8: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 823291BC: E95D0008  ld r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 823291C0: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 823291C4: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 823291C8: D19F00E0  stfs f12, 0xe0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 823291CC: 3BAB63D0  addi r29, r11, 0x63d0
	ctx.r[29].s64 = ctx.r[11].s64 + 25552;
	// 823291D0: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 823291D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823291D8: D19F00E8  stfs f12, 0xe8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 823291DC: D1BF00EC  stfs f13, 0xec(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 823291E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823291E4: D19F0140  stfs f12, 0x140(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 823291E8: D01F0144  stfs f0, 0x144(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 823291EC: D01F0148  stfs f0, 0x148(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 823291F0: C14B2678  lfs f10, 0x2678(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9848 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823291F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823291F8: D1BF014C  stfs f13, 0x14c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 823291FC: D17F0110  stfs f11, 0x110(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82329200: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82329204: D19F0118  stfs f12, 0x118(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82329208: D1BF011C  stfs f13, 0x11c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 8232920C: D17F0170  stfs f11, 0x170(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 82329210: D01F0174  stfs f0, 0x174(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 82329214: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 82329218: D1BF017C  stfs f13, 0x17c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 8232921C: D19F01A0  stfs f12, 0x1a0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82329220: D01F01A4  stfs f0, 0x1a4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 82329224: D15F01A8  stfs f10, 0x1a8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82329228: D1BF01AC  stfs f13, 0x1ac(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 8232922C: D17F01D0  stfs f11, 0x1d0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 82329230: D01F01D4  stfs f0, 0x1d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 82329234: D15F01D8  stfs f10, 0x1d8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 82329238: D1BF01DC  stfs f13, 0x1dc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), tmp.u32 ) };
	// 8232923C: C12BBFFC  lfs f9, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82329240: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82329244: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82329248: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 8232924C: D13F0164  stfs f9, 0x164(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82329250: D1BF0130  stfs f13, 0x130(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82329254: D01F0134  stfs f0, 0x134(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 82329258: D1BF0190  stfs f13, 0x190(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 8232925C: D13F0194  stfs f9, 0x194(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 82329260: D01F01C0  stfs f0, 0x1c0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82329264: D1BF01C4  stfs f13, 0x1c4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82329268: D1BF01F0  stfs f13, 0x1f0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), tmp.u32 ) };
	// 8232926C: D1BF01F4  stfs f13, 0x1f4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), tmp.u32 ) };
	// 82329270: 483E3FED  bl 0x8270d25c
	ctx.lr = 0x82329274;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82329274: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82329278: 3CA00003  lis r5, 3
	ctx.r[5].s64 = 196608;
	// 8232927C: 389F054C  addi r4, r31, 0x54c
	ctx.r[4].s64 = ctx.r[31].s64 + 1356;
	// 82329280: 60A54BC0  ori r5, r5, 0x4bc0
	ctx.r[5].u64 = ctx.r[5].u64 | 19392;
	// 82329284: 806BB9F8  lwz r3, -0x4608(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17928 as u32) ) } as u64;
	// 82329288: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232928C: 38CBD930  addi r6, r11, -0x26d0
	ctx.r[6].s64 = ctx.r[11].s64 + -9936;
	// 82329290: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82329294: 816A0040  lwz r11, 0x40(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 82329298: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8232929C: 4E800421  bctrl
	ctx.lr = 0x823292A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823292A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823292A4: 483E3FC9  bl 0x8270d26c
	ctx.lr = 0x823292A8;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823292A8: 897F008C  lbz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 823292AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823292B0: 419A000C  beq cr6, 0x823292bc
	if ctx.cr[6].eq {
	pc = 0x823292BC; continue 'dispatch;
	}
	// 823292B4: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 823292B8: 409A001C  bne cr6, 0x823292d4
	if !ctx.cr[6].eq {
	pc = 0x823292D4; continue 'dispatch;
	}
            }
            0x823292BC => {
    //   block [0x823292BC..0x823292D4)
	// 823292BC: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 823292C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823292C4: 409A0010  bne cr6, 0x823292d4
	if !ctx.cr[6].eq {
	pc = 0x823292D4; continue 'dispatch;
	}
	// 823292C8: 939F0200  stw r28, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[28].u32 ) };
	// 823292CC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823292D0: 4820BE20  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x823292D4 => {
    //   block [0x823292D4..0x823292E0)
	// 823292D4: 93DF0200  stw r30, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[30].u32 ) };
	// 823292D8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823292DC: 4820BE14  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823292E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823292E0 size=232
    let mut pc: u32 = 0x823292E0;
    'dispatch: loop {
        match pc {
            0x823292E0 => {
    //   block [0x823292E0..0x8232938C)
	// 823292E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823292E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823292E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823292EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823292F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823292F4: 3FC082C0  lis r30, -0x7d40
	ctx.r[30].s64 = -2101346304;
	// 823292F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823292FC: 817EBC20  lwz r11, -0x43e0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17376 as u32) ) } as u64;
	// 82329300: 816B1690  lwz r11, 0x1690(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5776 as u32) ) } as u64;
	// 82329304: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82329308: 409A009C  bne cr6, 0x823293a4
	if !ctx.cr[6].eq {
	pc = 0x823293A4; continue 'dispatch;
	}
	// 8232930C: 4800033D  bl 0x82329648
	ctx.lr = 0x82329310;
	sub_82329648(ctx, base);
	// 82329310: 480009D9  bl 0x82329ce8
	ctx.lr = 0x82329314;
	sub_82329CE8(ctx, base);
	// 82329314: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82329318: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8232931C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82329320: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 82329324: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82329328: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8232932C: 409A007C  bne cr6, 0x823293a8
	if !ctx.cr[6].eq {
	pc = 0x823293A8; continue 'dispatch;
	}
	// 82329330: 387F054C  addi r3, r31, 0x54c
	ctx.r[3].s64 = ctx.r[31].s64 + 1356;
	// 82329334: 4BF040B5  bl 0x8222d3e8
	ctx.lr = 0x82329338;
	sub_8222D3E8(ctx, base);
	// 82329338: 817EBC20  lwz r11, -0x43e0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17376 as u32) ) } as u64;
	// 8232933C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82329340: 813F0540  lwz r9, 0x540(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1344 as u32) ) } as u64;
	// 82329344: C00B1694  lfs f0, 0x1694(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5780 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82329348: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232934C: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82329350: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82329354: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82329358: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8232935C: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82329360: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82329364: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82329368: 815F0540  lwz r10, 0x540(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1344 as u32) ) } as u64;
	// 8232936C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82329370: 419A0038  beq cr6, 0x823293a8
	if ctx.cr[6].eq {
	pc = 0x823293A8; continue 'dispatch;
	}
	// 82329374: 395F0210  addi r10, r31, 0x210
	ctx.r[10].s64 = ctx.r[31].s64 + 528;
	// 82329378: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 8232937C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82329380: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82329384: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 82329388: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8232938C; continue 'dispatch;
            }
            0x8232938C => {
    //   block [0x8232938C..0x823293A4)
	// 8232938C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82329390: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82329394: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82329398: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8232939C: 4200FFF0  bdnz 0x8232938c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8232938C; continue 'dispatch;
	}
	// 823293A0: 48000008  b 0x823293a8
	pc = 0x823293A8; continue 'dispatch;
            }
            0x823293A4 => {
    //   block [0x823293A4..0x823293A8)
	// 823293A4: 48000E45  bl 0x8232a1e8
	ctx.lr = 0x823293A8;
	sub_8232A1E8(ctx, base);
	pc = 0x823293A8; continue 'dispatch;
            }
            0x823293A8 => {
    //   block [0x823293A8..0x823293C8)
	// 823293A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823293AC: 48000AED  bl 0x82329e98
	ctx.lr = 0x823293B0;
	sub_82329E98(ctx, base);
	// 823293B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823293B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823293B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823293BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823293C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823293C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823293C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823293C8 size=96
    let mut pc: u32 = 0x823293C8;
    'dispatch: loop {
        match pc {
            0x823293C8 => {
    //   block [0x823293C8..0x82329400)
	// 823293C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823293CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823293D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823293D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823293D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823293DC: 4800019D  bl 0x82329578
	ctx.lr = 0x823293E0;
	sub_82329578(ctx, base);
	// 823293E0: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 823293E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823293E8: 419A0018  beq cr6, 0x82329400
	if ctx.cr[6].eq {
	pc = 0x82329400; continue 'dispatch;
	}
	// 823293EC: 815F0548  lwz r10, 0x548(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1352 as u32) ) } as u64;
	// 823293F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823293F4: 409A0018  bne cr6, 0x8232940c
	if !ctx.cr[6].eq {
	pc = 0x8232940C; continue 'dispatch;
	}
	// 823293F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823293FC: 409A0018  bne cr6, 0x82329414
	if !ctx.cr[6].eq {
	pc = 0x82329414; continue 'dispatch;
	}
	pc = 0x82329400; continue 'dispatch;
            }
            0x82329400 => {
    //   block [0x82329400..0x8232940C)
	// 82329400: 817F0548  lwz r11, 0x548(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1352 as u32) ) } as u64;
	// 82329404: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82329408: 409A000C  bne cr6, 0x82329414
	if !ctx.cr[6].eq {
	pc = 0x82329414; continue 'dispatch;
	}
	pc = 0x8232940C; continue 'dispatch;
            }
            0x8232940C => {
    //   block [0x8232940C..0x82329414)
	// 8232940C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82329410: 48000CB1  bl 0x8232a0c0
	ctx.lr = 0x82329414;
	sub_8232A0C0(ctx, base);
	pc = 0x82329414; continue 'dispatch;
            }
            0x82329414 => {
    //   block [0x82329414..0x82329428)
	// 82329414: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82329418: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232941C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82329420: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82329424: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82329428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82329428 size=32
    let mut pc: u32 = 0x82329428;
    'dispatch: loop {
        match pc {
            0x82329428 => {
    //   block [0x82329428..0x82329448)
	// 82329428: 3963054C  addi r11, r3, 0x54c
	ctx.r[11].s64 = ctx.r[3].s64 + 1356;
	// 8232942C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82329430: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82329434: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82329438: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8232943C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82329440: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82329444: 4BDF3C14  b 0x8211d058
	sub_8211D058(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82329450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82329450 size=296
    let mut pc: u32 = 0x82329450;
    'dispatch: loop {
        match pc {
            0x82329450 => {
    //   block [0x82329450..0x82329548)
	// 82329450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82329454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82329458: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232945C: 81630540  lwz r11, 0x540(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1344 as u32) ) } as u64;
	// 82329460: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82329464: 409A00E4  bne cr6, 0x82329548
	if !ctx.cr[6].eq {
	pc = 0x82329548; continue 'dispatch;
	}
	// 82329468: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8232946C: 81230080  lwz r9, 0x80(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82329470: C1830564  lfs f12, 0x564(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1380 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82329474: 616B9B80  ori r11, r11, 0x9b80
	ctx.r[11].u64 = ctx.r[11].u64 | 39808;
	// 82329478: C1A90078  lfs f13, 0x78(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232947C: C0090070  lfs f0, 0x70(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82329548; continue 'dispatch;
            }
            0x82329548 => {
    //   block [0x82329548..0x82329578)
	// 82329548: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232954C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82329550: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82329554: 4E800020  blr
	return;
	// 82329558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232955C: 419AFFB0  beq cr6, 0x8232950c
	if ctx.cr[6].eq {
	pc = 0x8232950C; continue 'dispatch;
	}
	// 82329560: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82329564: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82329568: 4099FFA4  ble cr6, 0x8232950c
	if !ctx.cr[6].gt {
	pc = 0x8232950C; continue 'dispatch;
	}
	// 8232956C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82329570: 916304F8  stw r11, 0x4f8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1272 as u32), ctx.r[11].u32 ) };
	// 82329574: 4BFFFFAC  b 0x82329520
	pc = 0x82329520; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82329578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82329578 size=208
    let mut pc: u32 = 0x82329578;
    'dispatch: loop {
        match pc {
            0x82329578 => {
    //   block [0x82329578..0x823295EC)
	// 82329578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232957C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82329580: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82329584: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82329588: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232958C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82329590: 816BBC20  lwz r11, -0x43e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17376 as u32) ) } as u64;
	// 82329594: 816B16A8  lwz r11, 0x16a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5800 as u32) ) } as u64;
	// 82329598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232959C: 409A0098  bne cr6, 0x82329634
	if !ctx.cr[6].eq {
	pc = 0x82329634; continue 'dispatch;
	}
	// 823295A0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 823295A4: 816BB9B0  lwz r11, -0x4650(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18000 as u32) ) } as u64;
	// 823295A8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823295AC: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 823295B0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823295B4: 816B0058  lwz r11, 0x58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 823295B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823295BC: 4E800421  bctrl
	ctx.lr = 0x823295C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823295C0: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 823295C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823295C8: C00B0038  lfs f0, 0x38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823295CC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 823295D0: 915F0548  stw r10, 0x548(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1352 as u32), ctx.r[10].u32 ) };
	// 823295D4: C1ABD28C  lfs f13, -0x2d74(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11636 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823295D8: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823295DC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823295E0: 4098000C  bge cr6, 0x823295ec
	if !ctx.cr[6].lt {
	pc = 0x823295EC; continue 'dispatch;
	}
	// 823295E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823295E8: 917F0548  stw r11, 0x548(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1352 as u32), ctx.r[11].u32 ) };
            }
            0x823295EC => {
    //   block [0x823295EC..0x82329614)
	// 823295EC: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 823295F0: 815F0094  lwz r10, 0x94(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 823295F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823295F8: 817F0548  lwz r11, 0x548(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1352 as u32) ) } as u64;
	// 823295FC: 419A0024  beq cr6, 0x82329620
	if ctx.cr[6].eq {
	pc = 0x82329620; continue 'dispatch;
	}
	// 82329600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82329604: 419A0010  beq cr6, 0x82329614
	if ctx.cr[6].eq {
	pc = 0x82329614; continue 'dispatch;
	}
	// 82329608: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8232960C: C00BD428  lfs f0, -0x2bd8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82329610: 48000020  b 0x82329630
	pc = 0x82329630; continue 'dispatch;
            }
            0x82329614 => {
    //   block [0x82329614..0x82329620)
	// 82329614: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82329618: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232961C: 48000014  b 0x82329630
	pc = 0x82329630; continue 'dispatch;
            }
            0x82329620 => {
    //   block [0x82329620..0x82329630)
	// 82329620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82329624: 409AFFF0  bne cr6, 0x82329614
	if !ctx.cr[6].eq {
	pc = 0x82329614; continue 'dispatch;
	}
	// 82329628: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8232962C: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82329630; continue 'dispatch;
            }
            0x82329630 => {
    //   block [0x82329630..0x82329634)
	// 82329630: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82329634; continue 'dispatch;
            }
            0x82329634 => {
    //   block [0x82329634..0x82329648)
	// 82329634: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82329638: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232963C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82329640: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82329644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82329648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82329648 size=1692
    let mut pc: u32 = 0x82329648;
    'dispatch: loop {
        match pc {
            0x82329648 => {
    //   block [0x82329648..0x82329CE4)
	// 82329648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232964C: 4820BA71  bl 0x825350bc
	ctx.lr = 0x82329650;
	sub_82535080(ctx, base);
	// 82329650: 88E30574  lbz r7, 0x574(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1396 as u32) ) } as u64;
	// 82329654: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82329658: 81030080  lwz r8, 0x80(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 8232965C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82329660: 54E5083E  rotlwi r5, r7, 1
	ctx.r[5].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 82329664: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 82329668: 7CE72A14  add r7, r7, r5
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 8232966C: 38C80040  addi r6, r8, 0x40
	ctx.r[6].s64 = ctx.r[8].s64 + 64;
	// 82329670: 54E5482C  slwi r5, r7, 9
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(9);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82329674: 3CE082C0  lis r7, -0x7d40
	ctx.r[7].s64 = -2101346304;
	// 82329678: 80E7BC20  lwz r7, -0x43e0(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-17376 as u32) ) } as u64;
	// 8232967C: 7CA53A14  add r5, r5, r7
	ctx.r[5].u64 = ctx.r[5].u64 + ctx.r[7].u64;
	// 82329680: 38A50480  addi r5, r5, 0x480
	ctx.r[5].s64 = ctx.r[5].s64 + 1152;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82329CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82329CE8 size=428
    let mut pc: u32 = 0x82329CE8;
    'dispatch: loop {
        match pc {
            0x82329CE8 => {
    //   block [0x82329CE8..0x82329DB4)
	// 82329CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82329CEC: 4820B3C9  bl 0x825350b4
	ctx.lr = 0x82329CF0;
	sub_82535080(ctx, base);
	// 82329CF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82329CF4: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 82329CF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82329CFC: 806B03D8  lwz r3, 0x3d8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(984 as u32) ) } as u64;
	// 82329D00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82329D04: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82329D08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82329D0C: 4E800421  bctrl
	ctx.lr = 0x82329D10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82329D10: 817F0540  lwz r11, 0x540(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1344 as u32) ) } as u64;
	// 82329D14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82329D18: 419A0174  beq cr6, 0x82329e8c
	if ctx.cr[6].eq {
	pc = 0x82329E8C; continue 'dispatch;
	}
	// 82329D1C: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82329D20: 409A016C  bne cr6, 0x82329e8c
	if !ctx.cr[6].eq {
	pc = 0x82329E8C; continue 'dispatch;
	}
	// 82329D24: 83DF0084  lwz r30, 0x84(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82329D28: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82329D2C: 387F0260  addi r3, r31, 0x260
	ctx.r[3].s64 = ctx.r[31].s64 + 608;
	// 82329D30: 83BF0080  lwz r29, 0x80(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82329D34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82329D38: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 82329D3C: 4BEF4695  bl 0x8221e3d0
	ctx.lr = 0x82329D40;
	sub_8221E3D0(ctx, base);
	// 82329D40: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82329D44: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82329D48: C1BF056C  lfs f13, 0x56c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329D4C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82329D50: C19F0210  lfs f12, 0x210(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82329D54: 614A85D4  ori r10, r10, 0x85d4
	ctx.r[10].u64 = ctx.r[10].u64 | 34260;
	// 82329D58: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82329D5C: 817F04F4  lwz r11, 0x4f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1268 as u32) ) } as u64;
	// 82329D60: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82329D64: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82329D68: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82329D6C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82329D70: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82329D74: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82329D78: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82329D7C: EDAB6824  fdivs f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 / ctx.f[13].f64) as f32) as f64;
	// 82329D80: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82329D84: D01F0210  stfs f0, 0x210(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), tmp.u32 ) };
	// 82329D88: 817F04F4  lwz r11, 0x4f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1268 as u32) ) } as u64;
	// 82329D8C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82329D90: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82329D94: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82329D98: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82329D9C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82329DA0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82329DA4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82329DA8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82329DAC: 41980008  blt cr6, 0x82329db4
	if ctx.cr[6].lt {
	pc = 0x82329DB4; continue 'dispatch;
	}
	// 82329DB0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
            }
            0x82329DB4 => {
    //   block [0x82329DB4..0x82329E00)
	// 82329DB4: D01F04FC  stfs f0, 0x4fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1276 as u32), tmp.u32 ) };
	// 82329DB8: 9B9F0560  stb r28, 0x560(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1376 as u32), ctx.r[28].u8 ) };
	// 82329DBC: 817F04F4  lwz r11, 0x4f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1268 as u32) ) } as u64;
	// 82329DC0: C1BF0210  lfs f13, 0x210(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329DC4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82329DC8: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82329DCC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82329DD0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82329DD4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82329DD8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82329DDC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82329DE0: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82329DE4: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82329DE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82329DEC: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82329DF0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82329DF4: 4098000C  bge cr6, 0x82329e00
	if !ctx.cr[6].lt {
	pc = 0x82329E00; continue 'dispatch;
	}
	// 82329DF8: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82329DFC: 48000014  b 0x82329e10
	pc = 0x82329E10; continue 'dispatch;
            }
            0x82329E00 => {
    //   block [0x82329E00..0x82329E10)
	// 82329E00: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82329E04: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329E08: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82329E0C: EC0C683C  fnmsubs f0, f12, f0, f13
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82329E10; continue 'dispatch;
            }
            0x82329E10 => {
    //   block [0x82329E10..0x82329E2C)
	// 82329E10: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82329E14: C1BF0568  lfs f13, 0x568(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329E18: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82329E1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82329E20: 393E0038  addi r9, r30, 0x38
	ctx.r[9].s64 = ctx.r[30].s64 + 56;
	// 82329E24: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82329E28: 80EBBC20  lwz r7, -0x43e0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17376 as u32) ) } as u64;
	pc = 0x82329E2C; continue 'dispatch;
            }
            0x82329E2C => {
    //   block [0x82329E2C..0x82329E8C)
	// 82329E2C: 897F0574  lbz r11, 0x574(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1396 as u32) ) } as u64;
	// 82329E30: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82329E34: 38A9FFC8  addi r5, r9, -0x38
	ctx.r[5].s64 = ctx.r[9].s64 + -56;
	// 82329E38: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82329E3C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82329E40: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82329E44: 7DAB3C2E  lfsx f13, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329E48: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82329E4C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82329E50: 4803E4A9  bl 0x823682f8
	ctx.lr = 0x82329E54;
	sub_823682F8(ctx, base);
	// 82329E54: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82329E58: 38840040  addi r4, r4, 0x40
	ctx.r[4].s64 = ctx.r[4].s64 + 64;
	// 82329E5C: 39290040  addi r9, r9, 0x40
	ctx.r[9].s64 = ctx.r[9].s64 + 64;
	// 82329E60: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82329E64: 409AFFC8  bne cr6, 0x82329e2c
	if !ctx.cr[6].eq {
	pc = 0x82329E2C; continue 'dispatch;
	}
	// 82329E68: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82329E6C: 419A0020  beq cr6, 0x82329e8c
	if ctx.cr[6].eq {
	pc = 0x82329E8C; continue 'dispatch;
	}
	// 82329E70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82329E74: 939F0540  stw r28, 0x540(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1344 as u32), ctx.r[28].u32 ) };
	// 82329E78: 939F0218  stw r28, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[28].u32 ) };
	// 82329E7C: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82329E80: D01F0210  stfs f0, 0x210(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), tmp.u32 ) };
	// 82329E84: D01F0214  stfs f0, 0x214(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), tmp.u32 ) };
	// 82329E88: D01F04FC  stfs f0, 0x4fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1276 as u32), tmp.u32 ) };
	pc = 0x82329E8C; continue 'dispatch;
            }
            0x82329E8C => {
    //   block [0x82329E8C..0x82329E94)
	// 82329E8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82329E90: 4820B274  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82329E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82329E98 size=552
    let mut pc: u32 = 0x82329E98;
    'dispatch: loop {
        match pc {
            0x82329E98 => {
    //   block [0x82329E98..0x82329EAC)
	// 82329E98: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82329E9C: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82329EA0: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82329EA4: 396B0074  addi r11, r11, 0x74
	ctx.r[11].s64 = ctx.r[11].s64 + 116;
	// 82329EA8: C00922C0  lfs f0, 0x22c0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8896 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82329EAC; continue 'dispatch;
            }
            0x82329EAC => {
    //   block [0x82329EAC..0x8232A0C0)
	// 82329EAC: 8123055C  lwz r9, 0x55c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1372 as u32) ) } as u64;
	// 82329EB0: C1A3057C  lfs f13, 0x57c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1404 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329EB4: C16BFFC0  lfs f11, -0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-64 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82329EB8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82329EBC: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82329EC0: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82329EC4: D1ABFFC0  stfs f13, -0x40(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-64 as u32), tmp.u32 ) };
	// 82329EC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82329ECC: C18BFFBC  lfs f12, -0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82329ED0: C14BFFC4  lfs f10, -0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82329ED4: D14BFFC4  stfs f10, -0x3c(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-60 as u32), tmp.u32 ) };
	// 82329ED8: F921FFC0  std r9, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[9].u64 ) };
	// 82329EDC: C9A1FFC0  lfd f13, -0x40(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82329EE0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82329EE4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82329EE8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82329EEC: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82329EF0: D1ABFFBC  stfs f13, -0x44(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-68 as u32), tmp.u32 ) };
	// 82329EF4: 8123055C  lwz r9, 0x55c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1372 as u32) ) } as u64;
	// 82329EF8: C16BFFFC  lfs f11, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82329EFC: C1A3057C  lfs f13, 0x57c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1404 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329F00: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82329F04: F921FFC8  std r9, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[9].u64 ) };
	// 82329F08: C981FFC8  lfd f12, -0x38(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82329F0C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82329F10: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82329F14: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82329F18: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 82329F1C: D18BFFFC  stfs f12, -4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82329F20: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82329F24: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82329F28: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82329F2C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329F30: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82329F34: 8123055C  lwz r9, 0x55c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1372 as u32) ) } as u64;
	// 82329F38: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82329F3C: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82329F40: C1A3057C  lfs f13, 0x57c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1404 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329F44: F921FFD0  std r9, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[9].u64 ) };
	// 82329F48: C981FFD0  lfd f12, -0x30(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82329F4C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82329F50: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82329F54: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82329F58: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82329F5C: D18B003C  stfs f12, 0x3c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82329F60: C18B0040  lfs f12, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82329F64: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82329F68: D1AB0040  stfs f13, 0x40(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82329F6C: C1AB0044  lfs f13, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329F70: D1AB0044  stfs f13, 0x44(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82329F74: 8123055C  lwz r9, 0x55c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1372 as u32) ) } as u64;
	// 82329F78: C16B007C  lfs f11, 0x7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82329F7C: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82329F80: C1A3057C  lfs f13, 0x57c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1404 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329F84: F921FFD8  std r9, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[9].u64 ) };
	// 82329F88: C981FFD8  lfd f12, -0x28(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82329F8C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82329F90: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82329F94: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82329F98: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82329F9C: D18B007C  stfs f12, 0x7c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82329FA0: C18B0080  lfs f12, 0x80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82329FA4: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82329FA8: D1AB0080  stfs f13, 0x80(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82329FAC: C1AB0084  lfs f13, 0x84(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329FB0: D1AB0084  stfs f13, 0x84(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82329FB4: 8123055C  lwz r9, 0x55c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1372 as u32) ) } as u64;
	// 82329FB8: C16B00BC  lfs f11, 0xbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82329FBC: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82329FC0: C183057C  lfs f12, 0x57c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1404 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82329FC4: F921FFE0  std r9, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[9].u64 ) };
	// 82329FC8: C9A1FFE0  lfd f13, -0x20(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82329FCC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82329FD0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82329FD4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82329FD8: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82329FDC: D1AB00BC  stfs f13, 0xbc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82329FE0: C1AB00C0  lfs f13, 0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329FE4: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82329FE8: D1AB00C0  stfs f13, 0xc0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82329FEC: C1AB00C4  lfs f13, 0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82329FF0: D1AB00C4  stfs f13, 0xc4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82329FF4: 8123055C  lwz r9, 0x55c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1372 as u32) ) } as u64;
	// 82329FF8: C16B00FC  lfs f11, 0xfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82329FFC: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8232A000: C1A3057C  lfs f13, 0x57c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1404 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232A004: F921FFE8  std r9, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[9].u64 ) };
	// 8232A008: C981FFE8  lfd f12, -0x18(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232A00C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8232A010: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8232A014: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232A018: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 8232A01C: D18B00FC  stfs f12, 0xfc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 8232A020: C18B0100  lfs f12, 0x100(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232A024: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 8232A028: D1AB0100  stfs f13, 0x100(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 8232A02C: C1AB0104  lfs f13, 0x104(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232A030: D1AB0104  stfs f13, 0x104(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 8232A034: 8123055C  lwz r9, 0x55c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1372 as u32) ) } as u64;
	// 8232A038: C16B013C  lfs f11, 0x13c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(316 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232A03C: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8232A040: C1A3057C  lfs f13, 0x57c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1404 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232A044: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 8232A048: C981FFF0  lfd f12, -0x10(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232A04C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8232A050: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8232A054: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232A058: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 8232A05C: D18B013C  stfs f12, 0x13c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 8232A060: C18B0140  lfs f12, 0x140(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232A064: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232A068: D1AB0140  stfs f13, 0x140(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 8232A06C: C1AB0144  lfs f13, 0x144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(324 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232A070: D1AB0144  stfs f13, 0x144(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 8232A074: 8123055C  lwz r9, 0x55c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1372 as u32) ) } as u64;
	// 8232A078: C16B017C  lfs f11, 0x17c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(380 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232A07C: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8232A080: C1A3057C  lfs f13, 0x57c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1404 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232A084: F921FFF8  std r9, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[9].u64 ) };
	// 8232A088: C981FFF8  lfd f12, -8(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 8232A08C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8232A090: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8232A094: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232A098: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 8232A09C: D18B017C  stfs f12, 0x17c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 8232A0A0: C18B0180  lfs f12, 0x180(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(384 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232A0A4: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232A0A8: D1AB0180  stfs f13, 0x180(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 8232A0AC: C1AB0184  lfs f13, 0x184(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232A0B0: D1AB0184  stfs f13, 0x184(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 8232A0B4: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 8232A0B8: 409AFDF4  bne cr6, 0x82329eac
	if !ctx.cr[6].eq {
	pc = 0x82329EAC; continue 'dispatch;
	}
	// 8232A0BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232A0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232A0C0 size=296
    let mut pc: u32 = 0x8232A0C0;
    'dispatch: loop {
        match pc {
            0x8232A0C0 => {
    //   block [0x8232A0C0..0x8232A0E8)
	// 8232A0C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232A0C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232A0C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232A0CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232A0D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232A0D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232A0D8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8232A0DC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 8232A0E0: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8232A0E4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8232A0E8; continue 'dispatch;
            }
            0x8232A0E8 => {
    //   block [0x8232A0E8..0x8232A15C)
	// 8232A0E8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8232A0EC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8232A0F0: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8232A0F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8232A0F8: 4200FFF0  bdnz 0x8232a0e8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8232A0E8; continue 'dispatch;
	}
	// 8232A0FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232A100: C1A10084  lfs f13, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232A104: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8232A108: C00B21DC  lfs f0, 0x21dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8668 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232A10C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232A110: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232A114: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8232A118: C02BBFFC  lfs f1, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232A11C: 4803DE9D  bl 0x82367fb8
	ctx.lr = 0x8232A120;
	sub_82367FB8(ctx, base);
	// 8232A120: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232A124: 816BBC20  lwz r11, -0x43e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17376 as u32) ) } as u64;
	// 8232A128: 814B16A8  lwz r10, 0x16a8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5800 as u32) ) } as u64;
	// 8232A12C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232A130: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232A134: C00B2278  lfs f0, 0x2278(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232A138: 419A0024  beq cr6, 0x8232a15c
	if ctx.cr[6].eq {
	pc = 0x8232A15C; continue 'dispatch;
	}
	// 8232A13C: 815F0094  lwz r10, 0x94(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 8232A140: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232A144: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232A148: FD806A10  fabs f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 8232A14C: C00BD28C  lfs f0, -0x2d74(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232A150: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232A154: C1AB2068  lfs f13, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232A158: EC0C683C  fnmsubs f0, f12, f0, f13
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x8232A15C; continue 'dispatch;
            }
            0x8232A15C => {
    //   block [0x8232A15C..0x8232A1D0)
	// 8232A15C: 3BDF00D0  addi r30, r31, 0xd0
	ctx.r[30].s64 = ctx.r[31].s64 + 208;
	// 8232A160: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 8232A164: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8232A168: D01F012C  stfs f0, 0x12c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 8232A16C: 38DF00E0  addi r6, r31, 0xe0
	ctx.r[6].s64 = ctx.r[31].s64 + 224;
	// 8232A170: D01F015C  stfs f0, 0x15c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 8232A174: 38BF00A0  addi r5, r31, 0xa0
	ctx.r[5].s64 = ctx.r[31].s64 + 160;
	// 8232A178: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 8232A17C: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 8232A180: D01F01BC  stfs f0, 0x1bc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 8232A184: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8232A188: D01F01EC  stfs f0, 0x1ec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), tmp.u32 ) };
	// 8232A18C: 4804377D  bl 0x8236d908
	ctx.lr = 0x8232A190;
	sub_8236D908(ctx, base);
	// 8232A190: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 8232A194: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 8232A198: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 8232A19C: 812AB518  lwz r9, -0x4ae8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19176 as u32) ) } as u64;
	// 8232A1A0: 816B0688  lwz r11, 0x688(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8232A1A4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8232A1A8: 419A0028  beq cr6, 0x8232a1d0
	if ctx.cr[6].eq {
	pc = 0x8232A1D0; continue 'dispatch;
	}
	// 8232A1AC: A13F00D4  lhz r9, 0xd4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 8232A1B0: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 8232A1B4: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 8232A1B8: A0BF00D6  lhz r5, 0xd6(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(214 as u32) ) } as u64;
	// 8232A1BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8232A1C0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232A1C4: 38890001  addi r4, r9, 1
	ctx.r[4].s64 = ctx.r[9].s64 + 1;
	// 8232A1C8: 916AB518  stw r11, -0x4ae8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-19176 as u32), ctx.r[11].u32 ) };
	// 8232A1CC: 48041855  bl 0x8236ba20
	ctx.lr = 0x8232A1D0;
	sub_8236BA20(ctx, base);
	pc = 0x8232A1D0; continue 'dispatch;
            }
            0x8232A1D0 => {
    //   block [0x8232A1D0..0x8232A1E8)
	// 8232A1D0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8232A1D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232A1D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232A1DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232A1E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232A1E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232A1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232A1E8 size=1952
    let mut pc: u32 = 0x8232A1E8;
    'dispatch: loop {
        match pc {
            0x8232A1E8 => {
    //   block [0x8232A1E8..0x8232A210)
	// 8232A1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232A1EC: 4820AEC5  bl 0x825350b0
	ctx.lr = 0x8232A1F0;
	sub_82535080(ctx, base);
	// 8232A1F0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8232A1F4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232A1F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8232A1FC: 815D054C  lwz r10, 0x54c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1356 as u32) ) } as u64;
	// 8232A200: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232A204: 409A000C  bne cr6, 0x8232a210
	if !ctx.cr[6].eq {
	pc = 0x8232A210; continue 'dispatch;
	}
	// 8232A208: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232A20C: 4800002C  b 0x8232a238
	pc = 0x8232A238; continue 'dispatch;
            }
            0x8232A210 => {
    //   block [0x8232A210..0x8232A228)
	// 8232A210: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232A214: 813D0554  lwz r9, 0x554(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1364 as u32) ) } as u64;
	// 8232A218: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232A21C: 419A000C  beq cr6, 0x8232a228
	if ctx.cr[6].eq {
	pc = 0x8232A228; continue 'dispatch;
	}
	// 8232A220: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232A224: 48000014  b 0x8232a238
	pc = 0x8232A238; continue 'dispatch;
            }
            0x8232A228 => {
    //   block [0x8232A228..0x8232A238)
	// 8232A228: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232A22C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8232A230: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8232A234: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x8232A238; continue 'dispatch;
            }
            0x8232A238 => {
    //   block [0x8232A238..0x8232A24C)
	// 8232A238: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8232A23C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8232A240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232A244: 419A0008  beq cr6, 0x8232a24c
	if ctx.cr[6].eq {
	pc = 0x8232A24C; continue 'dispatch;
	}
	// 8232A248: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8232A24C; continue 'dispatch;
            }
            0x8232A24C => {
    //   block [0x8232A24C..0x8232A2B4)
	// 8232A24C: 3F4082C0  lis r26, -0x7d40
	ctx.r[26].s64 = -2101346304;
	// 8232A250: 83DD0080  lwz r30, 0x80(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 8232A254: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 8232A258: 837D0084  lwz r27, 0x84(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 8232A25C: 813ABC20  lwz r9, -0x43e0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-17376 as u32) ) } as u64;
	// 8232A260: C0091694  lfs f0, 0x1694(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(5780 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232A264: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232A268: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232A26C: FD60065E  fctidz f11, f0
	ctx.f[11].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232A270: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8232A274: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8232A278: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8232A27C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8232A280: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8232A284: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8232A288: FDA06E5E  fctidz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 8232A28C: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 8232A290: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8232A294: FD80665E  fctidz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 8232A298: EDA05828  fsubs f13, f0, f11
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 8232A29C: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 8232A2A0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232A2A4: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 8232A2A8: 2B030384  cmplwi cr6, r3, 0x384
	ctx.cr[6].compare_u32(ctx.r[3].u32, 900 as u32, &mut ctx.xer);
	// 8232A2AC: 41980008  blt cr6, 0x8232a2b4
	if ctx.cr[6].lt {
	pc = 0x8232A2B4; continue 'dispatch;
	}
	// 8232A2B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8232A2B4; continue 'dispatch;
            }
            0x8232A2B4 => {
    //   block [0x8232A2B4..0x8232A988)
	// 8232A2B4: 88FD0574  lbz r7, 0x574(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(1396 as u32) ) } as u64;
	// 8232A2B8: 3BE00010  li r31, 0x10
	ctx.r[31].s64 = 16;
	// 8232A2BC: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8232A2C0: 54E6083E  rotlwi r6, r7, 1
	ctx.r[6].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 8232A2C4: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 8232A2C8: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8232A2CC: 391E0040  addi r8, r30, 0x40
	ctx.r[8].s64 = ctx.r[30].s64 + 64;
	// 8232A2D0: 54E7482C  slwi r7, r7, 9
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(9);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8232A2D4: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 8232A2D8: 38E70480  addi r7, r7, 0x480
	ctx.r[7].s64 = ctx.r[7].s64 + 1152;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232A988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232A988 size=152
    let mut pc: u32 = 0x8232A988;
    'dispatch: loop {
        match pc {
            0x8232A988 => {
    //   block [0x8232A988..0x8232A9CC)
	// 8232A988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232A98C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232A990: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232A994: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232A998: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232A99C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232A9A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232A9A4: 396BD99C  addi r11, r11, -0x2664
	ctx.r[11].s64 = ctx.r[11].s64 + -9828;
	// 8232A9A8: 3D4082D0  lis r10, -0x7d30
	ctx.r[10].s64 = -2100297728;
	// 8232A9AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8232A9B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232A9B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232A9B8: 916A49BC  stw r11, 0x49bc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(18876 as u32), ctx.r[11].u32 ) };
	// 8232A9BC: 807F057C  lwz r3, 0x57c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1404 as u32) ) } as u64;
	// 8232A9C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232A9C4: 419A0008  beq cr6, 0x8232a9cc
	if ctx.cr[6].eq {
	pc = 0x8232A9CC; continue 'dispatch;
	}
	// 8232A9C8: 4BDF2691  bl 0x8211d058
	ctx.lr = 0x8232A9CC;
	sub_8211D058(ctx, base);
	pc = 0x8232A9CC; continue 'dispatch;
            }
            0x8232A9CC => {
    //   block [0x8232A9CC..0x8232AA08)
	// 8232A9CC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232A9D0: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8232A9D4: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 8232A9D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232A9DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232A9E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232A9E4: 419A0024  beq cr6, 0x8232aa08
	if ctx.cr[6].eq {
	pc = 0x8232AA08; continue 'dispatch;
	}
	// 8232A9E8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232A9EC: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8232A9F0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8232A9F4: 409A0014  bne cr6, 0x8232aa08
	if !ctx.cr[6].eq {
	pc = 0x8232AA08; continue 'dispatch;
	}
	// 8232A9F8: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8232A9FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8232AA00: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8232AA04: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x8232AA08; continue 'dispatch;
            }
            0x8232AA08 => {
    //   block [0x8232AA08..0x8232AA20)
	// 8232AA08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232AA0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232AA10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232AA14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232AA18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232AA1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232AA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8232AA20 size=596
    let mut pc: u32 = 0x8232AA20;
    'dispatch: loop {
        match pc {
            0x8232AA20 => {
    //   block [0x8232AA20..0x8232AA58)
	// 8232AA20: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 8232AA24: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8232AA28: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232AA2C: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 8232AA30: 38CBD99C  addi r6, r11, -0x2664
	ctx.r[6].s64 = ctx.r[11].s64 + -9828;
	// 8232AA34: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8232AA38: 39230510  addi r9, r3, 0x510
	ctx.r[9].s64 = ctx.r[3].s64 + 1296;
	// 8232AA3C: 39600012  li r11, 0x12
	ctx.r[11].s64 = 18;
	// 8232AA40: 90C30000  stw r6, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 8232AA44: 91430578  stw r10, 0x578(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1400 as u32), ctx.r[10].u32 ) };
	// 8232AA48: 9143057C  stw r10, 0x57c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1404 as u32), ctx.r[10].u32 ) };
	// 8232AA4C: A0C40008  lhz r6, 8(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232AA50: 83E40060  lwz r31, 0x60(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) } as u64;
	// 8232AA54: 90C30080  stw r6, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[6].u32 ) };
	pc = 0x8232AA58; continue 'dispatch;
            }
            0x8232AA58 => {
    //   block [0x8232AA58..0x8232AB34)
	// 8232AA58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8232AA5C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8232AA60: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 8232AA64: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 8232AA68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232AA6C: 409AFFEC  bne cr6, 0x8232aa58
	if !ctx.cr[6].eq {
	pc = 0x8232AA58; continue 'dispatch;
	}
	// 8232AA70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232AA74: 90E30560  stw r7, 0x560(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1376 as u32), ctx.r[7].u32 ) };
	// 8232AA78: C0A1FFE8  lfs f5, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8232AA7C: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8232AA80: C0C1FFE4  lfs f6, -0x1c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8232AA84: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 8232AA88: C0E1FFE0  lfs f7, -0x20(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8232AA8C: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 8232AA90: C101FFE8  lfs f8, -0x18(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8232AA94: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8232AA98: C16B1FF8  lfs f11, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232AA9C: 3D203F80  lis r9, 0x3f80
	ctx.r[9].s64 = 1065353216;
	// 8232AAA0: C121FFE4  lfs f9, -0x1c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8232AAA4: C141FFE0  lfs f10, -0x20(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8232AAA8: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8232AAAC: 3961FFE0  addi r11, r1, -0x20
	ctx.r[11].s64 = ctx.r[1].s64 + -32;
	// 8232AAB0: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8232AAB4: 2B0A000D  cmplwi cr6, r10, 0xd
	ctx.cr[6].compare_u32(ctx.r[10].u32, 13 as u32, &mut ctx.xer);
	// 8232AAB8: 55082036  slwi r8, r8, 4
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8232AABC: 7D08FA14  add r8, r8, r31
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	// 8232AAC0: 39080010  addi r8, r8, 0x10
	ctx.r[8].s64 = ctx.r[8].s64 + 16;
	// 8232AAC4: EBC80000  ld r30, 0(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 8232AAC8: E9080008  ld r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 8232AACC: FBCB0000  std r30, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 8232AAD0: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 8232AAD4: C1A1FFE0  lfs f13, -0x20(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232AAD8: C181FFE4  lfs f12, -0x1c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232AADC: C001FFE8  lfs f0, -0x18(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232AAE0: 41990098  bgt cr6, 0x8232ab78
	if ctx.cr[6].gt {
	pc = 0x8232AB78; continue 'dispatch;
	}
	// 8232AAE4: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 8232AAE8: 398CAAFC  addi r12, r12, -0x5504
	ctx.r[12].s64 = ctx.r[12].s64 + -21764;
	// 8232AAEC: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8232AAF0: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8232AAF4: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8232AAF8: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x8232AB48; continue 'dispatch;
		},
		1 => {
	pc = 0x8232AB34; continue 'dispatch;
		},
		2 => {
	pc = 0x8232AB40; continue 'dispatch;
		},
		3 => {
	pc = 0x8232AB40; continue 'dispatch;
		},
		4 => {
	pc = 0x8232AB40; continue 'dispatch;
		},
		5 => {
	pc = 0x8232AB40; continue 'dispatch;
		},
		6 => {
	pc = 0x8232AB40; continue 'dispatch;
		},
		7 => {
	pc = 0x8232AB40; continue 'dispatch;
		},
		8 => {
	pc = 0x8232AB6C; continue 'dispatch;
		},
		9 => {
	pc = 0x8232AB78; continue 'dispatch;
		},
		10 => {
	pc = 0x8232AB78; continue 'dispatch;
		},
		11 => {
	pc = 0x8232AB78; continue 'dispatch;
		},
		12 => {
	pc = 0x8232AB78; continue 'dispatch;
		},
		13 => {
	pc = 0x8232AB5C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8232AAFC: 8232AB48  lwz r17, -0x54b8(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21688 as u32) ) } as u64;
	// 8232AB00: 8232AB34  lwz r17, -0x54cc(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21708 as u32) ) } as u64;
	// 8232AB04: 8232AB40  lwz r17, -0x54c0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21696 as u32) ) } as u64;
	// 8232AB08: 8232AB40  lwz r17, -0x54c0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21696 as u32) ) } as u64;
	// 8232AB0C: 8232AB40  lwz r17, -0x54c0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21696 as u32) ) } as u64;
	// 8232AB10: 8232AB40  lwz r17, -0x54c0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21696 as u32) ) } as u64;
	// 8232AB14: 8232AB40  lwz r17, -0x54c0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21696 as u32) ) } as u64;
	// 8232AB18: 8232AB40  lwz r17, -0x54c0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21696 as u32) ) } as u64;
	// 8232AB1C: 8232AB6C  lwz r17, -0x5494(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21652 as u32) ) } as u64;
	// 8232AB20: 8232AB78  lwz r17, -0x5488(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21640 as u32) ) } as u64;
	// 8232AB24: 8232AB78  lwz r17, -0x5488(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21640 as u32) ) } as u64;
	// 8232AB28: 8232AB78  lwz r17, -0x5488(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21640 as u32) ) } as u64;
	// 8232AB2C: 8232AB78  lwz r17, -0x5488(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21640 as u32) ) } as u64;
	// 8232AB30: 8232AB5C  lwz r17, -0x54a4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-21668 as u32) ) } as u64;
            }
            0x8232AB34 => {
    //   block [0x8232AB34..0x8232AB40)
	// 8232AB34: FCE06890  fmr f7, f13
	ctx.f[7].f64 = ctx.f[13].f64;
	// 8232AB38: FCC06090  fmr f6, f12
	ctx.f[6].f64 = ctx.f[12].f64;
	// 8232AB3C: FCA05890  fmr f5, f11
	ctx.f[5].f64 = ctx.f[11].f64;
	pc = 0x8232AB40; continue 'dispatch;
            }
            0x8232AB40 => {
    //   block [0x8232AB40..0x8232AB48)
	// 8232AB40: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	// 8232AB44: 48000034  b 0x8232ab78
	pc = 0x8232AB78; continue 'dispatch;
            }
            0x8232AB48 => {
    //   block [0x8232AB48..0x8232AB5C)
	// 8232AB48: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 8232AB4C: FD206090  fmr f9, f12
	ctx.f[9].f64 = ctx.f[12].f64;
	// 8232AB50: FD005890  fmr f8, f11
	ctx.f[8].f64 = ctx.f[11].f64;
	// 8232AB54: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	// 8232AB58: 48000020  b 0x8232ab78
	pc = 0x8232AB78; continue 'dispatch;
            }
            0x8232AB5C => {
    //   block [0x8232AB5C..0x8232AB6C)
	// 8232AB5C: EDA7682A  fadds f13, f7, f13
	ctx.f[13].f64 = ((ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232AB60: ED86602A  fadds f12, f6, f12
	ctx.f[12].f64 = ((ctx.f[6].f64 + ctx.f[12].f64) as f32) as f64;
	// 8232AB64: EC05002A  fadds f0, f5, f0
	ctx.f[0].f64 = ((ctx.f[5].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232AB68: 48000010  b 0x8232ab78
	pc = 0x8232AB78; continue 'dispatch;
            }
            0x8232AB6C => {
    //   block [0x8232AB6C..0x8232AB78)
	// 8232AB6C: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232AB70: ED89602A  fadds f12, f9, f12
	ctx.f[12].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 8232AB74: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x8232AB78; continue 'dispatch;
            }
            0x8232AB78 => {
    //   block [0x8232AB78..0x8232AB90)
	// 8232AB78: 396AFFF7  addi r11, r10, -9
	ctx.r[11].s64 = ctx.r[10].s64 + -9;
	// 8232AB7C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8232AB80: 41990010  bgt cr6, 0x8232ab90
	if ctx.cr[6].gt {
	pc = 0x8232AB90; continue 'dispatch;
	}
	// 8232AB84: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232AB88: ED89602A  fadds f12, f9, f12
	ctx.f[12].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 8232AB8C: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x8232AB90; continue 'dispatch;
            }
            0x8232AB90 => {
    //   block [0x8232AB90..0x8232ABA8)
	// 8232AB90: 396AFFF2  addi r11, r10, -0xe
	ctx.r[11].s64 = ctx.r[10].s64 + -14;
	// 8232AB94: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8232AB98: 41990010  bgt cr6, 0x8232aba8
	if ctx.cr[6].gt {
	pc = 0x8232ABA8; continue 'dispatch;
	}
	// 8232AB9C: EDA7682A  fadds f13, f7, f13
	ctx.f[13].f64 = ((ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232ABA0: ED86602A  fadds f12, f6, f12
	ctx.f[12].f64 = ((ctx.f[6].f64 + ctx.f[12].f64) as f32) as f64;
	// 8232ABA4: EC05002A  fadds f0, f5, f0
	ctx.f[0].f64 = ((ctx.f[5].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x8232ABA8; continue 'dispatch;
            }
            0x8232ABA8 => {
    //   block [0x8232ABA8..0x8232AC74)
	// 8232ABA8: 554B3032  slwi r11, r10, 6
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8232ABAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8232ABB0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 8232ABB4: 2B0A0012  cmplwi cr6, r10, 0x12
	ctx.cr[6].compare_u32(ctx.r[10].u32, 18 as u32, &mut ctx.xer);
	// 8232ABB8: 396B0090  addi r11, r11, 0x90
	ctx.r[11].s64 = ctx.r[11].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232AC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232AC78 size=244
    let mut pc: u32 = 0x8232AC78;
    'dispatch: loop {
        match pc {
            0x8232AC78 => {
    //   block [0x8232AC78..0x8232AD54)
	// 8232AC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232AC7C: 4820A441  bl 0x825350bc
	ctx.lr = 0x8232AC80;
	sub_82535080(ctx, base);
	// 8232AC80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232AC84: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232AC88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232AC8C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8232AC90: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8232AC94: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8232AC98: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232AC9C: D01F05E8  stfs f0, 0x5e8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1512 as u32), tmp.u32 ) };
	// 8232ACA0: D01F05D8  stfs f0, 0x5d8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1496 as u32), tmp.u32 ) };
	// 8232ACA4: 93DF05EC  stw r30, 0x5ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1516 as u32), ctx.r[30].u32 ) };
	// 8232ACA8: D01F05DC  stfs f0, 0x5dc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1500 as u32), tmp.u32 ) };
	// 8232ACAC: 9BBF001E  stb r29, 0x1e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(30 as u32), ctx.r[29].u8 ) };
	// 8232ACB0: D01F0564  stfs f0, 0x564(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1380 as u32), tmp.u32 ) };
	// 8232ACB4: 9BBF001C  stb r29, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 8232ACB8: D01F0568  stfs f0, 0x568(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1384 as u32), tmp.u32 ) };
	// 8232ACBC: 93DF056C  stw r30, 0x56c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1388 as u32), ctx.r[30].u32 ) };
	// 8232ACC0: 93DF0570  stw r30, 0x570(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1392 as u32), ctx.r[30].u32 ) };
	// 8232ACC4: 9BDF05F0  stb r30, 0x5f0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1520 as u32), ctx.r[30].u8 ) };
	// 8232ACC8: 48000271  bl 0x8232af38
	ctx.lr = 0x8232ACCC;
	sub_8232AF38(ctx, base);
	// 8232ACCC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232ACD0: 93DF05EC  stw r30, 0x5ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1516 as u32), ctx.r[30].u32 ) };
	// 8232ACD4: 38A03840  li r5, 0x3840
	ctx.r[5].s64 = 14400;
	// 8232ACD8: 389F0578  addi r4, r31, 0x578
	ctx.r[4].s64 = ctx.r[31].s64 + 1400;
	// 8232ACDC: C00B24D0  lfs f0, 0x24d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9424 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232ACE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232ACE4: D01F05F4  stfs f0, 0x5f4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1524 as u32), tmp.u32 ) };
	// 8232ACE8: 38CBD984  addi r6, r11, -0x267c
	ctx.r[6].s64 = ctx.r[11].s64 + -9852;
	// 8232ACEC: D01F0604  stfs f0, 0x604(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1540 as u32), tmp.u32 ) };
	// 8232ACF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232ACF4: C1AB21DC  lfs f13, 0x21dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8668 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232ACF8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8232ACFC: D1BF05F8  stfs f13, 0x5f8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1528 as u32), tmp.u32 ) };
	// 8232AD00: 386BDBE0  addi r3, r11, -0x2420
	ctx.r[3].s64 = ctx.r[11].s64 + -9248;
	// 8232AD04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232AD08: C18B20CC  lfs f12, 0x20cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8396 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232AD0C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232AD10: D19F05FC  stfs f12, 0x5fc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 8232AD14: C16B223C  lfs f11, 0x223c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8764 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232AD18: D17F0600  stfs f11, 0x600(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1536 as u32), tmp.u32 ) };
	// 8232AD1C: 4BECA5CD  bl 0x821f52e8
	ctx.lr = 0x8232AD20;
	sub_821F52E8(ctx, base);
	// 8232AD20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232AD24: 480013BD  bl 0x8232c0e0
	ctx.lr = 0x8232AD28;
	sub_8232C0E0(ctx, base);
	// 8232AD28: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232AD2C: 93DF0584  stw r30, 0x584(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1412 as u32), ctx.r[30].u32 ) };
	// 8232AD30: 93DF0598  stw r30, 0x598(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1432 as u32), ctx.r[30].u32 ) };
	// 8232AD34: 816BBC38  lwz r11, -0x43c8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17352 as u32) ) } as u64;
	// 8232AD38: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8232AD3C: 409A0018  bne cr6, 0x8232ad54
	if !ctx.cr[6].eq {
	pc = 0x8232AD54; continue 'dispatch;
	}
	// 8232AD40: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232AD44: 93BF05B4  stw r29, 0x5b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1460 as u32), ctx.r[29].u32 ) };
	// 8232AD48: 93CBBC34  stw r30, -0x43cc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17356 as u32), ctx.r[30].u32 ) };
	// 8232AD4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232AD50: 4820A3BC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x8232AD54 => {
    //   block [0x8232AD54..0x8232AD6C)
	// 8232AD54: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 8232AD58: 93DF05B4  stw r30, 0x5b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1460 as u32), ctx.r[30].u32 ) };
	// 8232AD5C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8232AD60: 916ABC34  stw r11, -0x43cc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17356 as u32), ctx.r[11].u32 ) };
	// 8232AD64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232AD68: 4820A3A4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232AD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232AD70 size=224
    let mut pc: u32 = 0x8232AD70;
    'dispatch: loop {
        match pc {
            0x8232AD70 => {
    //   block [0x8232AD70..0x8232ADD8)
	// 8232AD70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232AD74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232AD78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232AD7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232AD80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232AD84: 817F05B4  lwz r11, 0x5b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1460 as u32) ) } as u64;
	// 8232AD88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232AD8C: 409A00B0  bne cr6, 0x8232ae3c
	if !ctx.cr[6].eq {
	pc = 0x8232AE3C; continue 'dispatch;
	}
	// 8232AD90: 817F0584  lwz r11, 0x584(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1412 as u32) ) } as u64;
	// 8232AD94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232AD98: 409A008C  bne cr6, 0x8232ae24
	if !ctx.cr[6].eq {
	pc = 0x8232AE24; continue 'dispatch;
	}
	// 8232AD9C: 817F0598  lwz r11, 0x598(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1432 as u32) ) } as u64;
	// 8232ADA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232ADA4: 409A0054  bne cr6, 0x8232adf8
	if !ctx.cr[6].eq {
	pc = 0x8232ADF8; continue 'dispatch;
	}
	// 8232ADA8: 817F05EC  lwz r11, 0x5ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1516 as u32) ) } as u64;
	// 8232ADAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232ADB0: 419A0028  beq cr6, 0x8232add8
	if ctx.cr[6].eq {
	pc = 0x8232ADD8; continue 'dispatch;
	}
	// 8232ADB4: C03F05D4  lfs f1, 0x5d4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1492 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232ADB8: 48000A21  bl 0x8232b7d8
	ctx.lr = 0x8232ADBC;
	sub_8232B7D8(ctx, base);
	// 8232ADBC: 817F05E0  lwz r11, 0x5e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1504 as u32) ) } as u64;
	// 8232ADC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8232ADC4: 917F05E0  stw r11, 0x5e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1504 as u32), ctx.r[11].u32 ) };
	// 8232ADC8: 480002C1  bl 0x8232b088
	ctx.lr = 0x8232ADCC;
	sub_8232B088(ctx, base);
	// 8232ADCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232ADD0: 48000F49  bl 0x8232bd18
	ctx.lr = 0x8232ADD4;
	sub_8232BD18(ctx, base);
	// 8232ADD4: 48000058  b 0x8232ae2c
	pc = 0x8232AE2C; continue 'dispatch;
            }
            0x8232ADD8 => {
    //   block [0x8232ADD8..0x8232ADF8)
	// 8232ADD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232ADDC: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232ADE0: 480009F9  bl 0x8232b7d8
	ctx.lr = 0x8232ADE4;
	sub_8232B7D8(ctx, base);
	// 8232ADE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232ADE8: 480002A1  bl 0x8232b088
	ctx.lr = 0x8232ADEC;
	sub_8232B088(ctx, base);
	// 8232ADEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232ADF0: 48000F29  bl 0x8232bd18
	ctx.lr = 0x8232ADF4;
	sub_8232BD18(ctx, base);
	// 8232ADF4: 48000038  b 0x8232ae2c
	pc = 0x8232AE2C; continue 'dispatch;
            }
            0x8232ADF8 => {
    //   block [0x8232ADF8..0x8232AE24)
	// 8232ADF8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232ADFC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8232AE00: 814BBC3C  lwz r10, -0x43c4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17348 as u32) ) } as u64;
	// 8232AE04: 912BBC3C  stw r9, -0x43c4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17348 as u32), ctx.r[9].u32 ) };
	// 8232AE08: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 8232AE0C: 409A0020  bne cr6, 0x8232ae2c
	if !ctx.cr[6].eq {
	pc = 0x8232AE2C; continue 'dispatch;
	}
	// 8232AE10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232AE14: 913F0598  stw r9, 0x598(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1432 as u32), ctx.r[9].u32 ) };
	// 8232AE18: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232AE1C: D01F05E8  stfs f0, 0x5e8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1512 as u32), tmp.u32 ) };
	// 8232AE20: 4800000C  b 0x8232ae2c
	pc = 0x8232AE2C; continue 'dispatch;
            }
            0x8232AE24 => {
    //   block [0x8232AE24..0x8232AE2C)
	// 8232AE24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232AE28: 48000FF1  bl 0x8232be18
	ctx.lr = 0x8232AE2C;
	sub_8232BE18(ctx, base);
	pc = 0x8232AE2C; continue 'dispatch;
            }
            0x8232AE2C => {
    //   block [0x8232AE2C..0x8232AE3C)
	// 8232AE2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232AE30: 48000499  bl 0x8232b2c8
	ctx.lr = 0x8232AE34;
	sub_8232B2C8(ctx, base);
	// 8232AE34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232AE38: 48001341  bl 0x8232c178
	ctx.lr = 0x8232AE3C;
	sub_8232C178(ctx, base);
	pc = 0x8232AE3C; continue 'dispatch;
            }
            0x8232AE3C => {
    //   block [0x8232AE3C..0x8232AE50)
	// 8232AE3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232AE40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232AE44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232AE48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232AE4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232AE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232AE50 size=64
    let mut pc: u32 = 0x8232AE50;
    'dispatch: loop {
        match pc {
            0x8232AE50 => {
    //   block [0x8232AE50..0x8232AE7C)
	// 8232AE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232AE54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232AE58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232AE5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232AE60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232AE64: 48000A7D  bl 0x8232b8e0
	ctx.lr = 0x8232AE68;
	sub_8232B8E0(ctx, base);
	// 8232AE68: 817F05B4  lwz r11, 0x5b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1460 as u32) ) } as u64;
	// 8232AE6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232AE70: 409A000C  bne cr6, 0x8232ae7c
	if !ctx.cr[6].eq {
	pc = 0x8232AE7C; continue 'dispatch;
	}
	// 8232AE74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232AE78: 48000329  bl 0x8232b1a0
	ctx.lr = 0x8232AE7C;
	sub_8232B1A0(ctx, base);
	pc = 0x8232AE7C; continue 'dispatch;
            }
            0x8232AE7C => {
    //   block [0x8232AE7C..0x8232AE90)
	// 8232AE7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232AE80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232AE84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232AE88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232AE8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232AE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232AE90 size=168
    let mut pc: u32 = 0x8232AE90;
    'dispatch: loop {
        match pc {
            0x8232AE90 => {
    //   block [0x8232AE90..0x8232AEC4)
	// 8232AE90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232AE94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232AE98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232AE9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232AEA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232AEA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8232AEA8: 397F0578  addi r11, r31, 0x578
	ctx.r[11].s64 = ctx.r[31].s64 + 1400;
	// 8232AEAC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8232AEB0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232AEB4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8232AEB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232AEBC: 419A0008  beq cr6, 0x8232aec4
	if ctx.cr[6].eq {
	pc = 0x8232AEC4; continue 'dispatch;
	}
	// 8232AEC0: 4BDF2199  bl 0x8211d058
	ctx.lr = 0x8232AEC4;
	sub_8211D058(ctx, base);
	pc = 0x8232AEC4; continue 'dispatch;
            }
            0x8232AEC4 => {
    //   block [0x8232AEC4..0x8232AED4)
	// 8232AEC4: 807F059C  lwz r3, 0x59c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1436 as u32) ) } as u64;
	// 8232AEC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232AECC: 419A0008  beq cr6, 0x8232aed4
	if ctx.cr[6].eq {
	pc = 0x8232AED4; continue 'dispatch;
	}
	// 8232AED0: 480DB119  bl 0x82405fe8
	ctx.lr = 0x8232AED4;
	sub_82405FE8(ctx, base);
	pc = 0x8232AED4; continue 'dispatch;
            }
            0x8232AED4 => {
    //   block [0x8232AED4..0x8232AEE4)
	// 8232AED4: 807F05A0  lwz r3, 0x5a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1440 as u32) ) } as u64;
	// 8232AED8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232AEDC: 419A0008  beq cr6, 0x8232aee4
	if ctx.cr[6].eq {
	pc = 0x8232AEE4; continue 'dispatch;
	}
	// 8232AEE0: 480DB109  bl 0x82405fe8
	ctx.lr = 0x8232AEE4;
	sub_82405FE8(ctx, base);
	pc = 0x8232AEE4; continue 'dispatch;
            }
            0x8232AEE4 => {
    //   block [0x8232AEE4..0x8232AEF4)
	// 8232AEE4: 807F05A4  lwz r3, 0x5a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1444 as u32) ) } as u64;
	// 8232AEE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232AEEC: 419A0008  beq cr6, 0x8232aef4
	if ctx.cr[6].eq {
	pc = 0x8232AEF4; continue 'dispatch;
	}
	// 8232AEF0: 480DB0F9  bl 0x82405fe8
	ctx.lr = 0x8232AEF4;
	sub_82405FE8(ctx, base);
	pc = 0x8232AEF4; continue 'dispatch;
            }
            0x8232AEF4 => {
    //   block [0x8232AEF4..0x8232AF04)
	// 8232AEF4: 807F05A8  lwz r3, 0x5a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1448 as u32) ) } as u64;
	// 8232AEF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232AEFC: 419A0008  beq cr6, 0x8232af04
	if ctx.cr[6].eq {
	pc = 0x8232AF04; continue 'dispatch;
	}
	// 8232AF00: 480DB0E9  bl 0x82405fe8
	ctx.lr = 0x8232AF04;
	sub_82405FE8(ctx, base);
	pc = 0x8232AF04; continue 'dispatch;
            }
            0x8232AF04 => {
    //   block [0x8232AF04..0x8232AF14)
	// 8232AF04: 807F05AC  lwz r3, 0x5ac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1452 as u32) ) } as u64;
	// 8232AF08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232AF0C: 419A0008  beq cr6, 0x8232af14
	if ctx.cr[6].eq {
	pc = 0x8232AF14; continue 'dispatch;
	}
	// 8232AF10: 480DB0D9  bl 0x82405fe8
	ctx.lr = 0x8232AF14;
	sub_82405FE8(ctx, base);
	pc = 0x8232AF14; continue 'dispatch;
            }
            0x8232AF14 => {
    //   block [0x8232AF14..0x8232AF24)
	// 8232AF14: 807F05B0  lwz r3, 0x5b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1456 as u32) ) } as u64;
	// 8232AF18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232AF1C: 419A0008  beq cr6, 0x8232af24
	if ctx.cr[6].eq {
	pc = 0x8232AF24; continue 'dispatch;
	}
	// 8232AF20: 480DB0C9  bl 0x82405fe8
	ctx.lr = 0x8232AF24;
	sub_82405FE8(ctx, base);
	pc = 0x8232AF24; continue 'dispatch;
            }
            0x8232AF24 => {
    //   block [0x8232AF24..0x8232AF38)
	// 8232AF24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232AF28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232AF2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232AF30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232AF34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232AF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232AF38 size=336
    let mut pc: u32 = 0x8232AF38;
    'dispatch: loop {
        match pc {
            0x8232AF38 => {
    //   block [0x8232AF38..0x8232AF90)
	// 8232AF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232AF3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232AF40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232AF44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232AF48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232AF4C: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 8232AF50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232AF54: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8232AF58: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 8232AF5C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8232AF60: 41980084  blt cr6, 0x8232afe4
	if ctx.cr[6].lt {
	pc = 0x8232AFE4; continue 'dispatch;
	}
	// 8232AF64: 419A002C  beq cr6, 0x8232af90
	if ctx.cr[6].eq {
	pc = 0x8232AF90; continue 'dispatch;
	}
	// 8232AF68: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8232AF6C: 409800B0  bge cr6, 0x8232b01c
	if !ctx.cr[6].lt {
	pc = 0x8232B01C; continue 'dispatch;
	}
	// 8232AF70: 4803C3E9  bl 0x82367358
	ctx.lr = 0x8232AF74;
	sub_82367358(ctx, base);
	// 8232AF74: 546B07FE  clrlwi r11, r3, 0x1f
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	// 8232AF78: C01F05C4  lfs f0, 0x5c4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1476 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232AF7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232AF80: 409A0054  bne cr6, 0x8232afd4
	if !ctx.cr[6].eq {
	pc = 0x8232AFD4; continue 'dispatch;
	}
	// 8232AF84: D01F05D4  stfs f0, 0x5d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1492 as u32), tmp.u32 ) };
	// 8232AF88: 98BF05E4  stb r5, 0x5e4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1508 as u32), ctx.r[5].u8 ) };
	// 8232AF8C: 48000090  b 0x8232b01c
	pc = 0x8232B01C; continue 'dispatch;
            }
            0x8232AF90 => {
    //   block [0x8232AF90..0x8232AFD4)
	// 8232AF90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8232AF94: 9BDF05B8  stb r30, 0x5b8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1464 as u32), ctx.r[30].u8 ) };
	// 8232AF98: 39400078  li r10, 0x78
	ctx.r[10].s64 = 120;
	// 8232AF9C: C00B2938  lfs f0, 0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232AFA0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232AFA4: D01F05BC  stfs f0, 0x5bc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1468 as u32), tmp.u32 ) };
	// 8232AFA8: 915F05C0  stw r10, 0x5c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1472 as u32), ctx.r[10].u32 ) };
	// 8232AFAC: C1AB212C  lfs f13, 0x212c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8492 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232AFB0: D1BF05C4  stfs f13, 0x5c4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1476 as u32), tmp.u32 ) };
	// 8232AFB4: 4803C3A5  bl 0x82367358
	ctx.lr = 0x8232AFB8;
	sub_82367358(ctx, base);
	// 8232AFB8: 546B07FE  clrlwi r11, r3, 0x1f
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	// 8232AFBC: C01F05C4  lfs f0, 0x5c4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1476 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232AFC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232AFC4: 409A0010  bne cr6, 0x8232afd4
	if !ctx.cr[6].eq {
	pc = 0x8232AFD4; continue 'dispatch;
	}
	// 8232AFC8: D01F05D4  stfs f0, 0x5d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1492 as u32), tmp.u32 ) };
	// 8232AFCC: 98BF05E4  stb r5, 0x5e4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1508 as u32), ctx.r[5].u8 ) };
	// 8232AFD0: 4800004C  b 0x8232b01c
	pc = 0x8232B01C; continue 'dispatch;
            }
            0x8232AFD4 => {
    //   block [0x8232AFD4..0x8232AFE4)
	// 8232AFD4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232AFD8: 9BDF05E4  stb r30, 0x5e4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1508 as u32), ctx.r[30].u8 ) };
	// 8232AFDC: D01F05D4  stfs f0, 0x5d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1492 as u32), tmp.u32 ) };
	// 8232AFE0: 4800003C  b 0x8232b01c
	pc = 0x8232B01C; continue 'dispatch;
            }
            0x8232AFE4 => {
    //   block [0x8232AFE4..0x8232B01C)
	// 8232AFE4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8232AFE8: 98BF05B8  stb r5, 0x5b8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1464 as u32), ctx.r[5].u8 ) };
	// 8232AFEC: 394001E0  li r10, 0x1e0
	ctx.r[10].s64 = 480;
	// 8232AFF0: 392001A4  li r9, 0x1a4
	ctx.r[9].s64 = 420;
	// 8232AFF4: C00B9DC4  lfs f0, -0x623c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232AFF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232AFFC: D01F05BC  stfs f0, 0x5bc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1468 as u32), tmp.u32 ) };
	// 8232B000: 915F05C0  stw r10, 0x5c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1472 as u32), ctx.r[10].u32 ) };
	// 8232B004: 913F05C8  stw r9, 0x5c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1480 as u32), ctx.r[9].u32 ) };
	// 8232B008: C1AB22BC  lfs f13, 0x22bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8892 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232B00C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232B010: D1BF05C4  stfs f13, 0x5c4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1476 as u32), tmp.u32 ) };
	// 8232B014: C18B22B8  lfs f12, 0x22b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8888 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232B018: D19F05CC  stfs f12, 0x5cc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1484 as u32), tmp.u32 ) };
	pc = 0x8232B01C; continue 'dispatch;
            }
            0x8232B01C => {
    //   block [0x8232B01C..0x8232B030)
	// 8232B01C: 897F05B8  lbz r11, 0x5b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1464 as u32) ) } as u64;
	// 8232B020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232B024: 409A000C  bne cr6, 0x8232b030
	if !ctx.cr[6].eq {
	pc = 0x8232B030; continue 'dispatch;
	}
	// 8232B028: 93DF05D0  stw r30, 0x5d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1488 as u32), ctx.r[30].u32 ) };
	// 8232B02C: 48000008  b 0x8232b034
	pc = 0x8232B034; continue 'dispatch;
            }
            0x8232B030 => {
    //   block [0x8232B030..0x8232B034)
	// 8232B030: 90BF05D0  stw r5, 0x5d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1488 as u32), ctx.r[5].u32 ) };
	pc = 0x8232B034; continue 'dispatch;
            }
            0x8232B034 => {
    //   block [0x8232B034..0x8232B088)
	// 8232B034: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232B038: C03F05BC  lfs f1, 0x5bc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1468 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232B03C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232B040: 90BF05E0  stw r5, 0x5e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1504 as u32), ctx.r[5].u32 ) };
	// 8232B044: 90BF056C  stw r5, 0x56c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1388 as u32), ctx.r[5].u32 ) };
	// 8232B048: 90BF0570  stw r5, 0x570(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1392 as u32), ctx.r[5].u32 ) };
	// 8232B04C: 989F05F0  stb r4, 0x5f0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1520 as u32), ctx.r[4].u8 ) };
	// 8232B050: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B054: D01F05E8  stfs f0, 0x5e8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1512 as u32), tmp.u32 ) };
	// 8232B058: D01F05D8  stfs f0, 0x5d8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1496 as u32), tmp.u32 ) };
	// 8232B05C: D01F05DC  stfs f0, 0x5dc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1500 as u32), tmp.u32 ) };
	// 8232B060: D01F0564  stfs f0, 0x564(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1380 as u32), tmp.u32 ) };
	// 8232B064: D01F0568  stfs f0, 0x568(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1384 as u32), tmp.u32 ) };
	// 8232B068: 48000629  bl 0x8232b690
	ctx.lr = 0x8232B06C;
	sub_8232B690(ctx, base);
	// 8232B06C: 93DF05EC  stw r30, 0x5ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1516 as u32), ctx.r[30].u32 ) };
	// 8232B070: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232B074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232B078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232B07C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232B080: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232B084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232B088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232B088 size=280
    let mut pc: u32 = 0x8232B088;
    'dispatch: loop {
        match pc {
            0x8232B088 => {
    //   block [0x8232B088..0x8232B124)
	// 8232B088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232B08C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232B090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232B094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232B098: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232B09C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232B0A0: 895F05B8  lbz r10, 0x5b8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1464 as u32) ) } as u64;
	// 8232B0A4: 817F05C0  lwz r11, 0x5c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1472 as u32) ) } as u64;
	// 8232B0A8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 8232B0AC: 41980084  blt cr6, 0x8232b130
	if ctx.cr[6].lt {
	pc = 0x8232B130; continue 'dispatch;
	}
	// 8232B0B0: 409A00D8  bne cr6, 0x8232b188
	if !ctx.cr[6].eq {
	pc = 0x8232B188; continue 'dispatch;
	}
	// 8232B0B4: 815F05E0  lwz r10, 0x5e0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1504 as u32) ) } as u64;
	// 8232B0B8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8232B0BC: 419800CC  blt cr6, 0x8232b188
	if ctx.cr[6].lt {
	pc = 0x8232B188; continue 'dispatch;
	}
	// 8232B0C0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8232B0C4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8232B0C8: 616B9B88  ori r11, r11, 0x9b88
	ctx.r[11].u64 = ctx.r[11].u64 | 39816;
	// 8232B0CC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 8232B0D0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 8232B0D4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8232B0D8: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 8232B0DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232B0E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232B0E4: 7C0A4C2E  lfsx f0, r10, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B0E8: 7DAB442E  lfsx f13, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232B0EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232B0F0: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232B0F4: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B0F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232B0FC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232B100: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B104: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8232B108: C01F05C4  lfs f0, 0x5c4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1476 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B10C: 41980018  blt cr6, 0x8232b124
	if ctx.cr[6].lt {
	pc = 0x8232B124; continue 'dispatch;
	}
	// 8232B110: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232B114: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232B118: D01F05D4  stfs f0, 0x5d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1492 as u32), tmp.u32 ) };
	// 8232B11C: 997F05E4  stb r11, 0x5e4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1508 as u32), ctx.r[11].u8 ) };
	// 8232B120: 48000064  b 0x8232b184
	pc = 0x8232B184; continue 'dispatch;
            }
            0x8232B124 => {
    //   block [0x8232B124..0x8232B130)
	// 8232B124: D01F05D4  stfs f0, 0x5d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1492 as u32), tmp.u32 ) };
	// 8232B128: 9BDF05E4  stb r30, 0x5e4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1508 as u32), ctx.r[30].u8 ) };
	// 8232B12C: 48000058  b 0x8232b184
	pc = 0x8232B184; continue 'dispatch;
            }
            0x8232B130 => {
    //   block [0x8232B130..0x8232B140)
	// 8232B130: 815F05D0  lwz r10, 0x5d0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1488 as u32) ) } as u64;
	// 8232B134: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232B138: 419A0008  beq cr6, 0x8232b140
	if ctx.cr[6].eq {
	pc = 0x8232B140; continue 'dispatch;
	}
	// 8232B13C: 817F05C8  lwz r11, 0x5c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1480 as u32) ) } as u64;
	pc = 0x8232B140; continue 'dispatch;
            }
            0x8232B140 => {
    //   block [0x8232B140..0x8232B174)
	// 8232B140: 815F05E0  lwz r10, 0x5e0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1504 as u32) ) } as u64;
	// 8232B144: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8232B148: 41980040  blt cr6, 0x8232b188
	if ctx.cr[6].lt {
	pc = 0x8232B188; continue 'dispatch;
	}
	// 8232B14C: 897F05E4  lbz r11, 0x5e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1508 as u32) ) } as u64;
	// 8232B150: C01F05C4  lfs f0, 0x5c4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1476 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B154: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8232B158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232B15C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232B160: 409A0014  bne cr6, 0x8232b174
	if !ctx.cr[6].eq {
	pc = 0x8232B174; continue 'dispatch;
	}
	// 8232B164: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232B168: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232B16C: 997F05E4  stb r11, 0x5e4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1508 as u32), ctx.r[11].u8 ) };
	// 8232B170: 48000008  b 0x8232b178
	pc = 0x8232B178; continue 'dispatch;
            }
            0x8232B174 => {
    //   block [0x8232B174..0x8232B178)
	// 8232B174: 9BDF05E4  stb r30, 0x5e4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1508 as u32), ctx.r[30].u8 ) };
	pc = 0x8232B178; continue 'dispatch;
            }
            0x8232B178 => {
    //   block [0x8232B178..0x8232B184)
	// 8232B178: D01F05D4  stfs f0, 0x5d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1492 as u32), tmp.u32 ) };
	// 8232B17C: 48000975  bl 0x8232baf0
	ctx.lr = 0x8232B180;
	sub_8232BAF0(ctx, base);
	// 8232B180: 93DF05D0  stw r30, 0x5d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1488 as u32), ctx.r[30].u32 ) };
	pc = 0x8232B184; continue 'dispatch;
            }
            0x8232B184 => {
    //   block [0x8232B184..0x8232B188)
	// 8232B184: 93DF05E0  stw r30, 0x5e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1504 as u32), ctx.r[30].u32 ) };
	pc = 0x8232B188; continue 'dispatch;
            }
            0x8232B188 => {
    //   block [0x8232B188..0x8232B1A0)
	// 8232B188: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232B18C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232B190: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232B194: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232B198: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232B19C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232B1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232B1A0 size=292
    let mut pc: u32 = 0x8232B1A0;
    'dispatch: loop {
        match pc {
            0x8232B1A0 => {
    //   block [0x8232B1A0..0x8232B210)
	// 8232B1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232B1A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232B1A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232B1AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232B1B0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232B1B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232B1B8: 816BB9B0  lwz r11, -0x4650(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18000 as u32) ) } as u64;
	// 8232B1BC: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8232B1C0: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 8232B1C4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232B1C8: 816B0058  lwz r11, 0x58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8232B1CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8232B1D0: 4E800421  bctrl
	ctx.lr = 0x8232B1D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8232B1D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232B1D8: C19F05BC  lfs f12, 0x5bc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1468 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232B1DC: C01F05E8  lfs f0, 0x5e8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B1E0: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232B1E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232B1E8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232B1EC: C18B20C8  lfs f12, 0x20c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232B1F0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232B1F4: 394BB901  addi r10, r11, -0x46ff
	ctx.r[10].s64 = ctx.r[11].s64 + -18175;
	// 8232B1F8: ED60682A  fadds f11, f0, f13
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232B1FC: ED6B6028  fsubs f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 8232B200: FF015800  fcmpu cr6, f1, f11
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[11].f64);
	// 8232B204: 4099000C  ble cr6, 0x8232b210
	if !ctx.cr[6].gt {
	pc = 0x8232B210; continue 'dispatch;
	}
	// 8232B208: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232B20C: 4800001C  b 0x8232b228
	pc = 0x8232B228; continue 'dispatch;
            }
            0x8232B210 => {
    //   block [0x8232B210..0x8232B228)
	// 8232B210: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232B214: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8232B218: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 8232B21C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8232B220: 41980008  blt cr6, 0x8232b228
	if ctx.cr[6].lt {
	pc = 0x8232B228; continue 'dispatch;
	}
	// 8232B224: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8232B228; continue 'dispatch;
            }
            0x8232B228 => {
    //   block [0x8232B228..0x8232B278)
	// 8232B228: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 8232B22C: 5569063E  clrlwi r9, r11, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8232B230: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8232B234: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232B238: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 8232B23C: C1AABA38  lfs f13, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232B240: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B244: 409A0034  bne cr6, 0x8232b278
	if !ctx.cr[6].eq {
	pc = 0x8232B278; continue 'dispatch;
	}
	// 8232B248: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232B24C: 817F0514  lwz r11, 0x514(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1300 as u32) ) } as u64;
	// 8232B250: C18A2208  lfs f12, 0x2208(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8712 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232B254: D00B0030  stfs f0, 0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232B258: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232B25C: D18B0038  stfs f12, 0x38(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8232B260: D1AB003C  stfs f13, 0x3c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8232B264: 817F052C  lwz r11, 0x52c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1324 as u32) ) } as u64;
	// 8232B268: D00B0030  stfs f0, 0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232B26C: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232B270: D18B0038  stfs f12, 0x38(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8232B274: D1AB003C  stfs f13, 0x3c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x8232B278; continue 'dispatch;
            }
            0x8232B278 => {
    //   block [0x8232B278..0x8232B2B0)
	// 8232B278: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 8232B27C: 409A0034  bne cr6, 0x8232b2b0
	if !ctx.cr[6].eq {
	pc = 0x8232B2B0; continue 'dispatch;
	}
	// 8232B280: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232B284: 817F0510  lwz r11, 0x510(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1296 as u32) ) } as u64;
	// 8232B288: C18A2294  lfs f12, 0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8852 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232B28C: D00B0030  stfs f0, 0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232B290: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232B294: D18B0038  stfs f12, 0x38(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8232B298: D1AB003C  stfs f13, 0x3c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8232B29C: 817F0524  lwz r11, 0x524(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1316 as u32) ) } as u64;
	// 8232B2A0: D00B0030  stfs f0, 0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232B2A4: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232B2A8: D18B0038  stfs f12, 0x38(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8232B2AC: D1AB003C  stfs f13, 0x3c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x8232B2B0; continue 'dispatch;
            }
            0x8232B2B0 => {
    //   block [0x8232B2B0..0x8232B2C4)
	// 8232B2B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232B2B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232B2B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232B2BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232B2C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232B2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232B2C8 size=968
    let mut pc: u32 = 0x8232B2C8;
    'dispatch: loop {
        match pc {
            0x8232B2C8 => {
    //   block [0x8232B2C8..0x8232B3E8)
	// 8232B2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232B2CC: 48209DE1  bl 0x825350ac
	ctx.lr = 0x8232B2D0;
	sub_82535080(ctx, base);
	// 8232B2D0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232B2D4: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8232B2D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232B2DC: 806B03D8  lwz r3, 0x3d8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(984 as u32) ) } as u64;
	// 8232B2E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232B2E4: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8232B2E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8232B2EC: 4E800421  bctrl
	ctx.lr = 0x8232B2F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8232B2F0: 817F0574  lwz r11, 0x574(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1396 as u32) ) } as u64;
	// 8232B2F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8232B2F8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8232B2FC: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8232B300: 3F2082C0  lis r25, -0x7d40
	ctx.r[25].s64 = -2101346304;
	// 8232B304: 419A0288  beq cr6, 0x8232b58c
	if ctx.cr[6].eq {
	pc = 0x8232B58C; continue 'dispatch;
	}
	// 8232B308: 397EFFFF  addi r11, r30, -1
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	// 8232B30C: 2B0B002E  cmplwi cr6, r11, 0x2e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 46 as u32, &mut ctx.xer);
	// 8232B310: 41990278  bgt cr6, 0x8232b588
	if ctx.cr[6].gt {
	pc = 0x8232B588; continue 'dispatch;
	}
	// 8232B314: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 8232B318: 398CB32C  addi r12, r12, -0x4cd4
	ctx.r[12].s64 = ctx.r[12].s64 + -19668;
	// 8232B31C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8232B320: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8232B324: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8232B328: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8232B3E8; continue 'dispatch;
		},
		1 => {
	pc = 0x8232B410; continue 'dispatch;
		},
		2 => {
	pc = 0x8232B44C; continue 'dispatch;
		},
		3 => {
	pc = 0x8232B454; continue 'dispatch;
		},
		4 => {
	pc = 0x8232B3E8; continue 'dispatch;
		},
		5 => {
	pc = 0x8232B3E8; continue 'dispatch;
		},
		6 => {
	pc = 0x8232B3E8; continue 'dispatch;
		},
		7 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		8 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		9 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		10 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		11 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		12 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		13 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		14 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		15 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		16 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		17 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		18 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		19 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		20 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		21 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		22 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		23 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		24 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		25 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		26 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		27 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		28 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		29 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		30 => {
	pc = 0x8232B454; continue 'dispatch;
		},
		31 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		32 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		33 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		34 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		35 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		36 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		37 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		38 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		39 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		40 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		41 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		42 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		43 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		44 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		45 => {
	pc = 0x8232B588; continue 'dispatch;
		},
		46 => {
	pc = 0x8232B510; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8232B32C: 8232B3E8  lwz r17, -0x4c18(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19480 as u32) ) } as u64;
	// 8232B330: 8232B410  lwz r17, -0x4bf0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19440 as u32) ) } as u64;
	// 8232B334: 8232B44C  lwz r17, -0x4bb4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19380 as u32) ) } as u64;
	// 8232B338: 8232B454  lwz r17, -0x4bac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19372 as u32) ) } as u64;
	// 8232B33C: 8232B3E8  lwz r17, -0x4c18(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19480 as u32) ) } as u64;
	// 8232B340: 8232B3E8  lwz r17, -0x4c18(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19480 as u32) ) } as u64;
	// 8232B344: 8232B3E8  lwz r17, -0x4c18(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19480 as u32) ) } as u64;
	// 8232B348: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B34C: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B350: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B354: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B358: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B35C: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B360: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B364: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B368: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B36C: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B370: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B374: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B378: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B37C: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B380: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B384: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B388: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B38C: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B390: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B394: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B398: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B39C: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3A0: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3A4: 8232B454  lwz r17, -0x4bac(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19372 as u32) ) } as u64;
	// 8232B3A8: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3AC: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3B0: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3B4: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3B8: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3BC: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3C0: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3C4: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3C8: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3CC: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3D0: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3D4: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3D8: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3DC: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3E0: 8232B588  lwz r17, -0x4a78(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19064 as u32) ) } as u64;
	// 8232B3E4: 8232B510  lwz r17, -0x4af0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-19184 as u32) ) } as u64;
            }
            0x8232B3E8 => {
    //   block [0x8232B3E8..0x8232B410)
	// 8232B3E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232B3EC: 889F05F0  lbz r4, 0x5f0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1520 as u32) ) } as u64;
	// 8232B3F0: 4BFFFB49  bl 0x8232af38
	ctx.lr = 0x8232B3F4;
	sub_8232AF38(ctx, base);
	// 8232B3F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232B3F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232B3FC: 935F05EC  stw r26, 0x5ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1516 as u32), ctx.r[26].u32 ) };
	// 8232B400: 935F0584  stw r26, 0x584(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1412 as u32), ctx.r[26].u32 ) };
	// 8232B404: 9179BC30  stw r11, -0x43d0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(-17360 as u32), ctx.r[11].u32 ) };
	// 8232B408: 48000CD9  bl 0x8232c0e0
	ctx.lr = 0x8232B40C;
	sub_8232C0E0(ctx, base);
	// 8232B40C: 4800017C  b 0x8232b588
	pc = 0x8232B588; continue 'dispatch;
            }
            0x8232B410 => {
    //   block [0x8232B410..0x8232B438)
	// 8232B410: 4803BFA9  bl 0x823673b8
	ctx.lr = 0x8232B414;
	sub_823673B8(ctx, base);
	// 8232B414: 546A07FE  clrlwi r10, r3, 0x1f
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	// 8232B418: C01F05CC  lfs f0, 0x5cc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1484 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B41C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232B420: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232B424: 409A0014  bne cr6, 0x8232b438
	if !ctx.cr[6].eq {
	pc = 0x8232B438; continue 'dispatch;
	}
	// 8232B428: D01F05D4  stfs f0, 0x5d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1492 as u32), tmp.u32 ) };
	// 8232B42C: 9B5F05E4  stb r26, 0x5e4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1508 as u32), ctx.r[26].u8 ) };
	// 8232B430: 917F05EC  stw r11, 0x5ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1516 as u32), ctx.r[11].u32 ) };
	// 8232B434: 48000154  b 0x8232b588
	pc = 0x8232B588; continue 'dispatch;
            }
            0x8232B438 => {
    //   block [0x8232B438..0x8232B44C)
	// 8232B438: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232B43C: 997F05E4  stb r11, 0x5e4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1508 as u32), ctx.r[11].u8 ) };
	// 8232B440: D01F05D4  stfs f0, 0x5d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1492 as u32), tmp.u32 ) };
	// 8232B444: 917F05EC  stw r11, 0x5ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1516 as u32), ctx.r[11].u32 ) };
	// 8232B448: 48000140  b 0x8232b588
	pc = 0x8232B588; continue 'dispatch;
            }
            0x8232B44C => {
    //   block [0x8232B44C..0x8232B454)
	// 8232B44C: 935F05EC  stw r26, 0x5ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1516 as u32), ctx.r[26].u32 ) };
	// 8232B450: 48000138  b 0x8232b588
	pc = 0x8232B588; continue 'dispatch;
            }
            0x8232B454 => {
    //   block [0x8232B454..0x8232B488)
	// 8232B454: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232B458: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8232B45C: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8232B460: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8232B464: 614A9460  ori r10, r10, 0x9460
	ctx.r[10].u64 = ctx.r[10].u64 | 37984;
	// 8232B468: 6129945C  ori r9, r9, 0x945c
	ctx.r[9].u64 = ctx.r[9].u64 | 37980;
	// 8232B46C: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8232B470: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8232B474: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8232B478: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8232B47C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8232B480: 40990008  ble cr6, 0x8232b488
	if !ctx.cr[6].gt {
	pc = 0x8232B488; continue 'dispatch;
	}
	// 8232B484: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x8232B488; continue 'dispatch;
            }
            0x8232B488 => {
    //   block [0x8232B488..0x8232B4E4)
	// 8232B488: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232B48C: 41980078  blt cr6, 0x8232b504
	if ctx.cr[6].lt {
	pc = 0x8232B504; continue 'dispatch;
	}
	// 8232B490: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 8232B494: C01F0588  lfs f0, 0x588(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B498: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232B49C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 8232B4A0: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232B4A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232B4A8: D1BF0590  stfs f13, 0x590(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1424 as u32), tmp.u32 ) };
	// 8232B4AC: C16B2068  lfs f11, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232B4B0: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8232B4B4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8232B4B8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8232B4BC: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8232B4C0: D01F0588  stfs f0, 0x588(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1416 as u32), tmp.u32 ) };
	// 8232B4C4: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 8232B4C8: D19F0594  stfs f12, 0x594(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1428 as u32), tmp.u32 ) };
	// 8232B4CC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232B4D0: 40980014  bge cr6, 0x8232b4e4
	if !ctx.cr[6].lt {
	pc = 0x8232B4E4; continue 'dispatch;
	}
	// 8232B4D4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232B4D8: C1ABF3EC  lfs f13, -0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232B4DC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232B4E0: D01F0588  stfs f0, 0x588(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1416 as u32), tmp.u32 ) };
	pc = 0x8232B4E4; continue 'dispatch;
            }
            0x8232B4E4 => {
    //   block [0x8232B4E4..0x8232B504)
	// 8232B4E4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8232B4E8: C01F0588  lfs f0, 0x588(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B4EC: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 8232B4F0: D01F058C  stfs f0, 0x58c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1420 as u32), tmp.u32 ) };
	// 8232B4F4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 8232B4F8: 913F0584  stw r9, 0x584(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1412 as u32), ctx.r[9].u32 ) };
	// 8232B4FC: 916ABC24  stw r11, -0x43dc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17372 as u32), ctx.r[11].u32 ) };
	// 8232B500: 48000088  b 0x8232b588
	pc = 0x8232B588; continue 'dispatch;
            }
            0x8232B504 => {
    //   block [0x8232B504..0x8232B510)
	// 8232B504: 935F05EC  stw r26, 0x5ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1516 as u32), ctx.r[26].u32 ) };
	// 8232B508: 935F0584  stw r26, 0x584(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1412 as u32), ctx.r[26].u32 ) };
	// 8232B50C: 4800007C  b 0x8232b588
	pc = 0x8232B588; continue 'dispatch;
            }
            0x8232B510 => {
    //   block [0x8232B510..0x8232B538)
	// 8232B510: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232B514: 935F05EC  stw r26, 0x5ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1516 as u32), ctx.r[26].u32 ) };
	// 8232B518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232B51C: 935F0584  stw r26, 0x584(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1412 as u32), ctx.r[26].u32 ) };
	// 8232B520: 917F0598  stw r11, 0x598(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1432 as u32), ctx.r[11].u32 ) };
	// 8232B524: 48000BBD  bl 0x8232c0e0
	ctx.lr = 0x8232B528;
	sub_8232C0E0(ctx, base);
	// 8232B528: 807F059C  lwz r3, 0x59c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1436 as u32) ) } as u64;
	// 8232B52C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232B530: 419A0008  beq cr6, 0x8232b538
	if ctx.cr[6].eq {
	pc = 0x8232B538; continue 'dispatch;
	}
	// 8232B534: 480DAAB5  bl 0x82405fe8
	ctx.lr = 0x8232B538;
	sub_82405FE8(ctx, base);
	pc = 0x8232B538; continue 'dispatch;
            }
            0x8232B538 => {
    //   block [0x8232B538..0x8232B548)
	// 8232B538: 807F05A0  lwz r3, 0x5a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1440 as u32) ) } as u64;
	// 8232B53C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232B540: 419A0008  beq cr6, 0x8232b548
	if ctx.cr[6].eq {
	pc = 0x8232B548; continue 'dispatch;
	}
	// 8232B544: 480DAAA5  bl 0x82405fe8
	ctx.lr = 0x8232B548;
	sub_82405FE8(ctx, base);
	pc = 0x8232B548; continue 'dispatch;
            }
            0x8232B548 => {
    //   block [0x8232B548..0x8232B558)
	// 8232B548: 807F05A4  lwz r3, 0x5a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1444 as u32) ) } as u64;
	// 8232B54C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232B550: 419A0008  beq cr6, 0x8232b558
	if ctx.cr[6].eq {
	pc = 0x8232B558; continue 'dispatch;
	}
	// 8232B554: 480DAA95  bl 0x82405fe8
	ctx.lr = 0x8232B558;
	sub_82405FE8(ctx, base);
	pc = 0x8232B558; continue 'dispatch;
            }
            0x8232B558 => {
    //   block [0x8232B558..0x8232B568)
	// 8232B558: 807F05A8  lwz r3, 0x5a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1448 as u32) ) } as u64;
	// 8232B55C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232B560: 419A0008  beq cr6, 0x8232b568
	if ctx.cr[6].eq {
	pc = 0x8232B568; continue 'dispatch;
	}
	// 8232B564: 480DAA85  bl 0x82405fe8
	ctx.lr = 0x8232B568;
	sub_82405FE8(ctx, base);
	pc = 0x8232B568; continue 'dispatch;
            }
            0x8232B568 => {
    //   block [0x8232B568..0x8232B578)
	// 8232B568: 807F05AC  lwz r3, 0x5ac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1452 as u32) ) } as u64;
	// 8232B56C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232B570: 419A0008  beq cr6, 0x8232b578
	if ctx.cr[6].eq {
	pc = 0x8232B578; continue 'dispatch;
	}
	// 8232B574: 480DAA75  bl 0x82405fe8
	ctx.lr = 0x8232B578;
	sub_82405FE8(ctx, base);
	pc = 0x8232B578; continue 'dispatch;
            }
            0x8232B578 => {
    //   block [0x8232B578..0x8232B588)
	// 8232B578: 807F05B0  lwz r3, 0x5b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1456 as u32) ) } as u64;
	// 8232B57C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232B580: 419A0008  beq cr6, 0x8232b588
	if ctx.cr[6].eq {
	pc = 0x8232B588; continue 'dispatch;
	}
	// 8232B584: 480DAA65  bl 0x82405fe8
	ctx.lr = 0x8232B588;
	sub_82405FE8(ctx, base);
	pc = 0x8232B588; continue 'dispatch;
            }
            0x8232B588 => {
    //   block [0x8232B588..0x8232B58C)
	// 8232B588: 93DF0574  stw r30, 0x574(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1396 as u32), ctx.r[30].u32 ) };
	pc = 0x8232B58C; continue 'dispatch;
            }
            0x8232B58C => {
    //   block [0x8232B58C..0x8232B5AC)
	// 8232B58C: 8179BC30  lwz r11, -0x43d0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-17360 as u32) ) } as u64;
	// 8232B590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232B594: 419A00F4  beq cr6, 0x8232b688
	if ctx.cr[6].eq {
	pc = 0x8232B688; continue 'dispatch;
	}
	// 8232B598: 807F059C  lwz r3, 0x59c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1436 as u32) ) } as u64;
	// 8232B59C: 3B7F059C  addi r27, r31, 0x59c
	ctx.r[27].s64 = ctx.r[31].s64 + 1436;
	// 8232B5A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232B5A4: 419A0008  beq cr6, 0x8232b5ac
	if ctx.cr[6].eq {
	pc = 0x8232B5AC; continue 'dispatch;
	}
	// 8232B5A8: 480DAA41  bl 0x82405fe8
	ctx.lr = 0x8232B5AC;
	sub_82405FE8(ctx, base);
	pc = 0x8232B5AC; continue 'dispatch;
            }
            0x8232B5AC => {
    //   block [0x8232B5AC..0x8232B5C0)
	// 8232B5AC: 807F05A0  lwz r3, 0x5a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1440 as u32) ) } as u64;
	// 8232B5B0: 3B9F05A0  addi r28, r31, 0x5a0
	ctx.r[28].s64 = ctx.r[31].s64 + 1440;
	// 8232B5B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232B5B8: 419A0008  beq cr6, 0x8232b5c0
	if ctx.cr[6].eq {
	pc = 0x8232B5C0; continue 'dispatch;
	}
	// 8232B5BC: 480DAA2D  bl 0x82405fe8
	ctx.lr = 0x8232B5C0;
	sub_82405FE8(ctx, base);
	pc = 0x8232B5C0; continue 'dispatch;
            }
            0x8232B5C0 => {
    //   block [0x8232B5C0..0x8232B5D4)
	// 8232B5C0: 807F05A4  lwz r3, 0x5a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1444 as u32) ) } as u64;
	// 8232B5C4: 3BBF05A4  addi r29, r31, 0x5a4
	ctx.r[29].s64 = ctx.r[31].s64 + 1444;
	// 8232B5C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232B5CC: 419A0008  beq cr6, 0x8232b5d4
	if ctx.cr[6].eq {
	pc = 0x8232B5D4; continue 'dispatch;
	}
	// 8232B5D0: 480DAA19  bl 0x82405fe8
	ctx.lr = 0x8232B5D4;
	sub_82405FE8(ctx, base);
	pc = 0x8232B5D4; continue 'dispatch;
            }
            0x8232B5D4 => {
    //   block [0x8232B5D4..0x8232B5E8)
	// 8232B5D4: 807F05A8  lwz r3, 0x5a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1448 as u32) ) } as u64;
	// 8232B5D8: 3BDF05A8  addi r30, r31, 0x5a8
	ctx.r[30].s64 = ctx.r[31].s64 + 1448;
	// 8232B5DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232B5E0: 419A0008  beq cr6, 0x8232b5e8
	if ctx.cr[6].eq {
	pc = 0x8232B5E8; continue 'dispatch;
	}
	// 8232B5E4: 480DAA05  bl 0x82405fe8
	ctx.lr = 0x8232B5E8;
	sub_82405FE8(ctx, base);
	pc = 0x8232B5E8; continue 'dispatch;
            }
            0x8232B5E8 => {
    //   block [0x8232B5E8..0x8232B5F8)
	// 8232B5E8: 807F05AC  lwz r3, 0x5ac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1452 as u32) ) } as u64;
	// 8232B5EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232B5F0: 419A0008  beq cr6, 0x8232b5f8
	if ctx.cr[6].eq {
	pc = 0x8232B5F8; continue 'dispatch;
	}
	// 8232B5F4: 480DA9F5  bl 0x82405fe8
	ctx.lr = 0x8232B5F8;
	sub_82405FE8(ctx, base);
	pc = 0x8232B5F8; continue 'dispatch;
            }
            0x8232B5F8 => {
    //   block [0x8232B5F8..0x8232B608)
	// 8232B5F8: 807F05B0  lwz r3, 0x5b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1456 as u32) ) } as u64;
	// 8232B5FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232B600: 419A0008  beq cr6, 0x8232b608
	if ctx.cr[6].eq {
	pc = 0x8232B608; continue 'dispatch;
	}
	// 8232B604: 480DA9E5  bl 0x82405fe8
	ctx.lr = 0x8232B608;
	sub_82405FE8(ctx, base);
	pc = 0x8232B608; continue 'dispatch;
            }
            0x8232B608 => {
    //   block [0x8232B608..0x8232B688)
	// 8232B608: 817F0514  lwz r11, 0x514(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1300 as u32) ) } as u64;
	// 8232B60C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 8232B610: 815F0510  lwz r10, 0x510(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1296 as u32) ) } as u64;
	// 8232B614: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8232B618: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8232B61C: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B620: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8232B624: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B628: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8232B62C: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B630: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8232B634: C00A0030  lfs f0, 0x30(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B638: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8232B63C: C00A0034  lfs f0, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B640: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8232B644: C00A0038  lfs f0, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B648: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8232B64C: 48037035  bl 0x82362680
	ctx.lr = 0x8232B650;
	sub_82362680(ctx, base);
	// 8232B650: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8232B654: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8232B658: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8232B65C: 48037025  bl 0x82362680
	ctx.lr = 0x8232B660;
	sub_82362680(ctx, base);
	// 8232B660: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8232B664: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8232B668: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8232B66C: 48037015  bl 0x82362680
	ctx.lr = 0x8232B670;
	sub_82362680(ctx, base);
	// 8232B670: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8232B674: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8232B678: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8232B67C: 48037005  bl 0x82362680
	ctx.lr = 0x8232B680;
	sub_82362680(ctx, base);
	// 8232B680: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 8232B684: 9179BC30  stw r11, -0x43d0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(-17360 as u32), ctx.r[11].u32 ) };
	pc = 0x8232B688; continue 'dispatch;
            }
            0x8232B688 => {
    //   block [0x8232B688..0x8232B690)
	// 8232B688: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8232B68C: 48209A70  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232B690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8232B690 size=328
    //   switch @ 0x8232B714: r9 with 14 label(s)
    //       case  0  0x8232B758
    //       case  1  0x8232B750
    //       case  2  0x8232B758
    //       case  3  0x8232B750
    //       case  4  0x8232B758
    //       case  5  0x8232B758
    //       case  6  0x8232B750
    //       case  7  0x8232B750
    //       case  8  0x8232B758
    //       case  9  0x8232B764
    //       case 10  0x8232B764
    //       case 11  0x8232B764
    //       case 12  0x8232B764
    //       case 13  0x8232B750
    let mut pc: u32 = 0x8232B690;
    'dispatch: loop {
        match pc {
            0x8232B690 => {
    //   block [0x8232B690..0x8232B750)
	// 8232B690: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8232B694: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232B698: C161FFE8  lfs f11, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232B69C: 39030510  addi r8, r3, 0x510
	ctx.r[8].s64 = ctx.r[3].s64 + 1296;
	// 8232B6A0: C181FFE4  lfs f12, -0x1c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232B6A4: 394300B0  addi r10, r3, 0xb0
	ctx.r[10].s64 = ctx.r[3].s64 + 176;
	// 8232B6A8: C1A1FFE0  lfs f13, -0x20(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232B6AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8232B6B0: 3860FFE0  li r3, -0x20
	ctx.r[3].s64 = -32;
	// 8232B6B4: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B6B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232B6BC: ED410032  fmuls f10, f1, f0
	ctx.f[10].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232B6C0: 3880FFF0  li r4, -0x10
	ctx.r[4].s64 = -16;
	// 8232B6C4: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8232B6C8: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 8232B6CC: 38C00030  li r6, 0x30
	ctx.r[6].s64 = 48;
	// 8232B6D0: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B6D4: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8232B750; continue 'dispatch;
            }
            0x8232B750 => {
    //   block [0x8232B750..0x8232B758)
	// 8232B750: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 8232B754: 48000008  b 0x8232b75c
	pc = 0x8232B75C; continue 'dispatch;
            }
            0x8232B758 => {
    //   block [0x8232B758..0x8232B764)
	// 8232B758: FD605050  fneg f11, f10
	ctx.f[11].u64 = ctx.f[10].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232B75C: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 8232B760: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x8232B764; continue 'dispatch;
            }
            0x8232B764 => {
    //   block [0x8232B764..0x8232B7D8)
	// 8232B764: 3969FFF2  addi r11, r9, -0xe
	ctx.r[11].s64 = ctx.r[9].s64 + -14;
	// 8232B768: 3BEB0005  addi r31, r11, 5
	ctx.r[31].s64 = ctx.r[11].s64 + 5;
	// 8232B76C: 2B1F0003  cmplwi cr6, r31, 3
	ctx.cr[6].compare_u32(ctx.r[31].u32, 3 as u32, &mut ctx.xer);
	// 8232B770: 41990010  bgt cr6, 0x8232b780
	if ctx.cr[6].gt {
	pc = 0x8232B780; continue 'dispatch;
	}
	// 8232B774: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8232B778: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 8232B77C: FD605050  fneg f11, f10
	ctx.f[11].u64 = ctx.f[10].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232B780: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8232B784: 41990010  bgt cr6, 0x8232b794
	if ctx.cr[6].gt {
	pc = 0x8232B794; continue 'dispatch;
	}
	// 8232B788: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8232B78C: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 8232B790: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 8232B794: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232B798: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8232B79C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 8232B7A0: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 8232B7A4: 2B090012  cmplwi cr6, r9, 0x12
	ctx.cr[6].compare_u32(ctx.r[9].u32, 18 as u32, &mut ctx.xer);
	// 8232B7A8: C12B0030  lfs f9, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8232B7AC: C10B0034  lfs f8, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8232B7B0: ED29682A  fadds f9, f9, f13
	ctx.f[9].f64 = ((ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232B7B4: C0EB0038  lfs f7, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8232B7B8: ED08602A  fadds f8, f8, f12
	ctx.f[8].f64 = ((ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64;
	// 8232B7BC: ECE7582A  fadds f7, f7, f11
	ctx.f[7].f64 = ((ctx.f[7].f64 + ctx.f[11].f64) as f32) as f64;
	// 8232B7C0: D12B0030  stfs f9, 0x30(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232B7C4: D10B0034  stfs f8, 0x34(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232B7C8: D0EB0038  stfs f7, 0x38(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8232B7CC: 4198FF08  blt cr6, 0x8232b6d4
	if ctx.cr[6].lt {
	pc = 0x8232B6D4; continue 'dispatch;
	}
	// 8232B7D0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 8232B7D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232B7D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8232B7D8 size=264
    let mut pc: u32 = 0x8232B7D8;
    'dispatch: loop {
        match pc {
            0x8232B7D8 => {
    //   block [0x8232B7D8..0x8232B804)
	// 8232B7D8: 896305E4  lbz r11, 0x5e4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1508 as u32) ) } as u64;
	// 8232B7DC: C1A30564  lfs f13, 0x564(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1380 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232B7E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232B7E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232B7E8: C00B20AC  lfs f0, 0x20ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B7EC: 409A0018  bne cr6, 0x8232b804
	if !ctx.cr[6].eq {
	pc = 0x8232B804; continue 'dispatch;
	}
	// 8232B7F0: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232B7F4: D0030564  stfs f0, 0x564(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1380 as u32), tmp.u32 ) };
	// 8232B7F8: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 8232B7FC: 4099001C  ble cr6, 0x8232b818
	if !ctx.cr[6].gt {
	pc = 0x8232B818; continue 'dispatch;
	}
	// 8232B800: 48000014  b 0x8232b814
	pc = 0x8232B814; continue 'dispatch;
            }
            0x8232B804 => {
    //   block [0x8232B804..0x8232B814)
	// 8232B804: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8232B808: D0030564  stfs f0, 0x564(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1380 as u32), tmp.u32 ) };
	// 8232B80C: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 8232B810: 40980008  bge cr6, 0x8232b818
	if !ctx.cr[6].lt {
	pc = 0x8232B818; continue 'dispatch;
	}
	pc = 0x8232B814; continue 'dispatch;
            }
            0x8232B814 => {
    //   block [0x8232B814..0x8232B818)
	// 8232B814: D0230564  stfs f1, 0x564(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1380 as u32), tmp.u32 ) };
	pc = 0x8232B818; continue 'dispatch;
            }
            0x8232B818 => {
    //   block [0x8232B818..0x8232B838)
	// 8232B818: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232B81C: 8163056C  lwz r11, 0x56c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1388 as u32) ) } as u64;
	// 8232B820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232B824: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B828: 419A0010  beq cr6, 0x8232b838
	if ctx.cr[6].eq {
	pc = 0x8232B838; continue 'dispatch;
	}
	// 8232B82C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8232B830: D0030564  stfs f0, 0x564(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1380 as u32), tmp.u32 ) };
	// 8232B834: 9163056C  stw r11, 0x56c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1388 as u32), ctx.r[11].u32 ) };
	pc = 0x8232B838; continue 'dispatch;
            }
            0x8232B838 => {
    //   block [0x8232B838..0x8232B8E0)
	// 8232B838: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232B83C: C16305E8  lfs f11, 0x5e8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1512 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232B840: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8232B844: C1430564  lfs f10, 0x564(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1380 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8232B848: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8232B84C: D001FFE0  stfs f0, -0x20(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 8232B850: 614A85D4  ori r10, r10, 0x85d4
	ctx.r[10].u64 = ctx.r[10].u64 | 34260;
	// 8232B854: D001FFE4  stfs f0, -0x1c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 8232B858: D001FFEC  stfs f0, -0x14(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	// 8232B85C: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 8232B860: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8232B864: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8232B868: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 8232B86C: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232B870: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232B874: EC0A5B7A  fmadds f0, f10, f13, f11
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 8232B878: C12305BC  lfs f9, 0x5bc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1468 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8232B87C: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 8232B880: D00305E8  stfs f0, 0x5e8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1512 as u32), tmp.u32 ) };
	// 8232B884: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232B888: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8232B88C: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 8232B890: 390B0800  addi r8, r11, 0x800
	ctx.r[8].s64 = ctx.r[11].s64 + 2048;
	// 8232B894: 38EB0810  addi r7, r11, 0x810
	ctx.r[7].s64 = ctx.r[11].s64 + 2064;
	// 8232B898: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 8232B89C: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8232B8A0: C1A824D4  lfs f13, 0x24d4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(9428 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232B8A4: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 8232B8A8: EDA96B3C  fnmsubs f13, f9, f12, f13
	ctx.f[13].f64 = -(((ctx.f[9].f64 * ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232B8AC: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232B8B0: D181FFE8  stfs f12, -0x18(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 8232B8B4: E8EA0000  ld r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8232B8B8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232B8BC: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8232B8C0: D001FFF8  stfs f0, -8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 8232B8C4: E8C90000  ld r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 8232B8C8: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 8232B8CC: F8EB0000  std r7, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 8232B8D0: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 8232B8D4: F8C80000  std r6, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 8232B8D8: F9280008  std r9, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 8232B8DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232B8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232B8E0 size=528
    let mut pc: u32 = 0x8232B8E0;
    'dispatch: loop {
        match pc {
            0x8232B8E0 => {
    //   block [0x8232B8E0..0x8232B91C)
	// 8232B8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232B8E4: 482097D9  bl 0x825350bc
	ctx.lr = 0x8232B8E8;
	sub_82535080(ctx, base);
	// 8232B8E8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8232B8EC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232B8F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232B8F4: C03F05BC  lfs f1, 0x5bc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1468 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232B8F8: 4BFFFD99  bl 0x8232b690
	ctx.lr = 0x8232B8FC;
	sub_8232B690(ctx, base);
	// 8232B8FC: 817F05B4  lwz r11, 0x5b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1460 as u32) ) } as u64;
	// 8232B900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232B904: 409A0120  bne cr6, 0x8232ba24
	if !ctx.cr[6].eq {
	pc = 0x8232BA24; continue 'dispatch;
	}
	// 8232B908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232B90C: C3FF05E8  lfs f31, 0x5e8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1512 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8232B910: 48000281  bl 0x8232bb90
	ctx.lr = 0x8232B914;
	sub_8232BB90(ctx, base);
	// 8232B914: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8232B918: 3BBF0510  addi r29, r31, 0x510
	ctx.r[29].s64 = ctx.r[31].s64 + 1296;
	pc = 0x8232B91C; continue 'dispatch;
            }
            0x8232B91C => {
    //   block [0x8232B91C..0x8232B954)
	// 8232B91C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232B920: 2B1E0003  cmplwi cr6, r30, 3
	ctx.cr[6].compare_u32(ctx.r[30].u32, 3 as u32, &mut ctx.xer);
	// 8232B924: C0030038  lfs f0, 0x38(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B928: C1A30030  lfs f13, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232B92C: EC1F002A  fadds f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232B930: C1830034  lfs f12, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232B934: D1A30030  stfs f13, 0x30(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232B938: D1830034  stfs f12, 0x34(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232B93C: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8232B940: 40990014  ble cr6, 0x8232b954
	if !ctx.cr[6].gt {
	pc = 0x8232B954; continue 'dispatch;
	}
	// 8232B944: 2B1E0005  cmplwi cr6, r30, 5
	ctx.cr[6].compare_u32(ctx.r[30].u32, 5 as u32, &mut ctx.xer);
	// 8232B948: 419A000C  beq cr6, 0x8232b954
	if ctx.cr[6].eq {
	pc = 0x8232B954; continue 'dispatch;
	}
	// 8232B94C: 2B1E0007  cmplwi cr6, r30, 7
	ctx.cr[6].compare_u32(ctx.r[30].u32, 7 as u32, &mut ctx.xer);
	// 8232B950: 409A000C  bne cr6, 0x8232b95c
	if !ctx.cr[6].eq {
	pc = 0x8232B95C; continue 'dispatch;
	}
	pc = 0x8232B954; continue 'dispatch;
            }
            0x8232B954 => {
    //   block [0x8232B954..0x8232B95C)
	// 8232B954: C03F0568  lfs f1, 0x568(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1384 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232B958: 4803C539  bl 0x82367e90
	ctx.lr = 0x8232B95C;
	sub_82367E90(ctx, base);
	pc = 0x8232B95C; continue 'dispatch;
            }
            0x8232B95C => {
    //   block [0x8232B95C..0x8232B9D8)
	// 8232B95C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8232B960: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8232B964: 2B1E0012  cmplwi cr6, r30, 0x12
	ctx.cr[6].compare_u32(ctx.r[30].u32, 18 as u32, &mut ctx.xer);
	// 8232B968: 4198FFB4  blt cr6, 0x8232b91c
	if ctx.cr[6].lt {
	pc = 0x8232B91C; continue 'dispatch;
	}
	// 8232B96C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232B970: C01F0564  lfs f0, 0x564(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1380 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B974: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8232B978: C19F055C  lfs f12, 0x55c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1372 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232B97C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8232B980: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232B984: 614A85D4  ori r10, r10, 0x85d4
	ctx.r[10].u64 = ctx.r[10].u64 | 34260;
	// 8232B988: C15F0558  lfs f10, 0x558(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1368 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8232B98C: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232B990: C17F05D8  lfs f11, 0x5d8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1496 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232B994: C13F05DC  lfs f9, 0x5dc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1500 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8232B998: 807F0544  lwz r3, 0x544(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1348 as u32) ) } as u64;
	// 8232B99C: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232B9A0: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8232B9A4: 614A85D4  ori r10, r10, 0x85d4
	ctx.r[10].u64 = ctx.r[10].u64 | 34260;
	// 8232B9A8: EC0C5B7A  fmadds f0, f12, f13, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 8232B9AC: D01F05D8  stfs f0, 0x5d8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1496 as u32), tmp.u32 ) };
	// 8232B9B0: C03F05D8  lfs f1, 0x5d8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1496 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232B9B4: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232B9B8: EC0A483A  fmadds f0, f10, f0, f9
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 8232B9BC: D01F05DC  stfs f0, 0x5dc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1500 as u32), tmp.u32 ) };
	// 8232B9C0: 4803C4D1  bl 0x82367e90
	ctx.lr = 0x8232B9C4;
	sub_82367E90(ctx, base);
	// 8232B9C4: C03F05D8  lfs f1, 0x5d8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1496 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232B9C8: 807F0530  lwz r3, 0x530(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1328 as u32) ) } as u64;
	// 8232B9CC: 4803C4C5  bl 0x82367e90
	ctx.lr = 0x8232B9D0;
	sub_82367E90(ctx, base);
	// 8232B9D0: 3BBF0534  addi r29, r31, 0x534
	ctx.r[29].s64 = ctx.r[31].s64 + 1332;
	// 8232B9D4: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	pc = 0x8232B9D8; continue 'dispatch;
            }
            0x8232B9D8 => {
    //   block [0x8232B9D8..0x8232B9FC)
	// 8232B9D8: C03F05DC  lfs f1, 0x5dc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1500 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232B9DC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232B9E0: 4803C5D9  bl 0x82367fb8
	ctx.lr = 0x8232B9E4;
	sub_82367FB8(ctx, base);
	// 8232B9E4: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8232B9E8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8232B9EC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232B9F0: 409AFFE8  bne cr6, 0x8232b9d8
	if !ctx.cr[6].eq {
	pc = 0x8232B9D8; continue 'dispatch;
	}
	// 8232B9F4: 3BBF0548  addi r29, r31, 0x548
	ctx.r[29].s64 = ctx.r[31].s64 + 1352;
	// 8232B9F8: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	pc = 0x8232B9FC; continue 'dispatch;
            }
            0x8232B9FC => {
    //   block [0x8232B9FC..0x8232BA24)
	// 8232B9FC: C03F05DC  lfs f1, 0x5dc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1500 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232BA00: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232BA04: 4803C5B5  bl 0x82367fb8
	ctx.lr = 0x8232BA08;
	sub_82367FB8(ctx, base);
	// 8232BA08: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8232BA0C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8232BA10: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232BA14: 409AFFE8  bne cr6, 0x8232b9fc
	if !ctx.cr[6].eq {
	pc = 0x8232B9FC; continue 'dispatch;
	}
	// 8232BA18: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232BA1C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8232BA20: 482096EC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x8232BA24 => {
    //   block [0x8232BA24..0x8232BA34)
	// 8232BA24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232BA28: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8232BA2C: 395F0510  addi r10, r31, 0x510
	ctx.r[10].s64 = ctx.r[31].s64 + 1296;
	// 8232BA30: C1AB2208  lfs f13, 0x2208(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8712 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x8232BA34; continue 'dispatch;
            }
            0x8232BA34 => {
    //   block [0x8232BA34..0x8232BA8C)
	// 8232BA34: 2B09000D  cmplwi cr6, r9, 0xd
	ctx.cr[6].compare_u32(ctx.r[9].u32, 13 as u32, &mut ctx.xer);
	// 8232BA38: 4199009C  bgt cr6, 0x8232bad4
	if ctx.cr[6].gt {
	pc = 0x8232BAD4; continue 'dispatch;
	}
	// 8232BA3C: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 8232BA40: 398CBA54  addi r12, r12, -0x45ac
	ctx.r[12].s64 = ctx.r[12].s64 + -17836;
	// 8232BA44: 5520103A  slwi r0, r9, 2
	ctx.r[0].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8232BA48: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8232BA4C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8232BA50: 4E800420  bctr
	match ctx.r[9].u64 {
		0 => {
	pc = 0x8232BAAC; continue 'dispatch;
		},
		1 => {
	pc = 0x8232BA8C; continue 'dispatch;
		},
		2 => {
	pc = 0x8232BAAC; continue 'dispatch;
		},
		3 => {
	pc = 0x8232BA8C; continue 'dispatch;
		},
		4 => {
	pc = 0x8232BAAC; continue 'dispatch;
		},
		5 => {
	pc = 0x8232BAAC; continue 'dispatch;
		},
		6 => {
	pc = 0x8232BA8C; continue 'dispatch;
		},
		7 => {
	pc = 0x8232BA8C; continue 'dispatch;
		},
		8 => {
	pc = 0x8232BAAC; continue 'dispatch;
		},
		9 => {
	pc = 0x8232BAD4; continue 'dispatch;
		},
		10 => {
	pc = 0x8232BAD4; continue 'dispatch;
		},
		11 => {
	pc = 0x8232BAD4; continue 'dispatch;
		},
		12 => {
	pc = 0x8232BAD4; continue 'dispatch;
		},
		13 => {
	pc = 0x8232BA8C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8232BA54: 8232BAAC  lwz r17, -0x4554(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17748 as u32) ) } as u64;
	// 8232BA58: 8232BA8C  lwz r17, -0x4574(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17780 as u32) ) } as u64;
	// 8232BA5C: 8232BAAC  lwz r17, -0x4554(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17748 as u32) ) } as u64;
	// 8232BA60: 8232BA8C  lwz r17, -0x4574(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17780 as u32) ) } as u64;
	// 8232BA64: 8232BAAC  lwz r17, -0x4554(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17748 as u32) ) } as u64;
	// 8232BA68: 8232BAAC  lwz r17, -0x4554(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17748 as u32) ) } as u64;
	// 8232BA6C: 8232BA8C  lwz r17, -0x4574(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17780 as u32) ) } as u64;
	// 8232BA70: 8232BA8C  lwz r17, -0x4574(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17780 as u32) ) } as u64;
	// 8232BA74: 8232BAAC  lwz r17, -0x4554(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17748 as u32) ) } as u64;
	// 8232BA78: 8232BAD4  lwz r17, -0x452c(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17708 as u32) ) } as u64;
	// 8232BA7C: 8232BAD4  lwz r17, -0x452c(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17708 as u32) ) } as u64;
	// 8232BA80: 8232BAD4  lwz r17, -0x452c(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17708 as u32) ) } as u64;
	// 8232BA84: 8232BAD4  lwz r17, -0x452c(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17708 as u32) ) } as u64;
	// 8232BA88: 8232BA8C  lwz r17, -0x4574(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-17780 as u32) ) } as u64;
            }
            0x8232BA8C => {
    //   block [0x8232BA8C..0x8232BAAC)
	// 8232BA8C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232BA90: C01F05E8  lfs f0, 0x5e8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BA94: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232BA98: C16B0030  lfs f11, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232BA9C: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232BAA0: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232BAA4: D16B0030  stfs f11, 0x30(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232BAA8: 48000024  b 0x8232bacc
	pc = 0x8232BACC; continue 'dispatch;
            }
            0x8232BAAC => {
    //   block [0x8232BAAC..0x8232BACC)
	// 8232BAAC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232BAB0: C01F05E8  lfs f0, 0x5e8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BAB4: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232BAB8: C16B0038  lfs f11, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232BABC: ED8C682A  fadds f12, f12, f13
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232BAC0: C14B0030  lfs f10, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8232BAC4: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232BAC8: D14B0030  stfs f10, 0x30(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	pc = 0x8232BACC; continue 'dispatch;
            }
            0x8232BACC => {
    //   block [0x8232BACC..0x8232BAD4)
	// 8232BACC: D00B0038  stfs f0, 0x38(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8232BAD0: D18B0034  stfs f12, 0x34(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x8232BAD4; continue 'dispatch;
            }
            0x8232BAD4 => {
    //   block [0x8232BAD4..0x8232BAF0)
	// 8232BAD4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8232BAD8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8232BADC: 2B090012  cmplwi cr6, r9, 0x12
	ctx.cr[6].compare_u32(ctx.r[9].u32, 18 as u32, &mut ctx.xer);
	// 8232BAE0: 4198FF54  blt cr6, 0x8232ba34
	if ctx.cr[6].lt {
	pc = 0x8232BA34; continue 'dispatch;
	}
	// 8232BAE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232BAE8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8232BAEC: 48209620  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232BAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232BAF0 size=156
    let mut pc: u32 = 0x8232BAF0;
    'dispatch: loop {
        match pc {
            0x8232BAF0 => {
    //   block [0x8232BAF0..0x8232BB8C)
	// 8232BAF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232BAF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232BAF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232BAFC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232BB00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232BB04: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8232BB08: 3900001E  li r8, 0x1e
	ctx.r[8].s64 = 30;
	// 8232BB0C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8232BB10: 38BF05AC  addi r5, r31, 0x5ac
	ctx.r[5].s64 = ctx.r[31].s64 + 1452;
	// 8232BB14: 817F0514  lwz r11, 0x514(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1300 as u32) ) } as u64;
	// 8232BB18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8232BB1C: C0091FF8  lfs f0, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BB20: 815F0510  lwz r10, 0x510(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1296 as u32) ) } as u64;
	// 8232BB24: D01F0564  stfs f0, 0x564(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1380 as u32), tmp.u32 ) };
	// 8232BB28: 911F056C  stw r8, 0x56c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1388 as u32), ctx.r[8].u32 ) };
	// 8232BB2C: 90FF0570  stw r7, 0x570(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1392 as u32), ctx.r[7].u32 ) };
	// 8232BB30: 3860001A  li r3, 0x1a
	ctx.r[3].s64 = 26;
	// 8232BB34: C00B0030  lfs f0, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BB38: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8232BB3C: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BB40: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8232BB44: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BB48: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8232BB4C: C00A0030  lfs f0, 0x30(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BB50: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8232BB54: C00A0034  lfs f0, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BB58: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8232BB5C: C00A0038  lfs f0, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BB60: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8232BB64: 48036B1D  bl 0x82362680
	ctx.lr = 0x8232BB68;
	sub_82362680(ctx, base);
	// 8232BB68: 38BF05B0  addi r5, r31, 0x5b0
	ctx.r[5].s64 = ctx.r[31].s64 + 1456;
	// 8232BB6C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8232BB70: 3860001A  li r3, 0x1a
	ctx.r[3].s64 = 26;
	// 8232BB74: 48036B0D  bl 0x82362680
	ctx.lr = 0x8232BB78;
	sub_82362680(ctx, base);
	// 8232BB78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232BB7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232BB80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232BB84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232BB88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232BB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8232BB90 size=188
    let mut pc: u32 = 0x8232BB90;
    'dispatch: loop {
        match pc {
            0x8232BB90 => {
    //   block [0x8232BB90..0x8232BC1C)
	// 8232BB90: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 8232BB94: C16305FC  lfs f11, 0x5fc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1532 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232BB98: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8232BB9C: C1430600  lfs f10, 0x600(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1536 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8232BBA0: 394ABFF0  addi r10, r10, -0x4010
	ctx.r[10].s64 = ctx.r[10].s64 + -16400;
	// 8232BBA4: C1A305F4  lfs f13, 0x5f4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1524 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232BBA8: 612985D4  ori r9, r9, 0x85d4
	ctx.r[9].u64 = ctx.r[9].u64 | 34260;
	// 8232BBAC: C18305F8  lfs f12, 0x5f8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232BBB0: C1230604  lfs f9, 0x604(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1540 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8232BBB4: 81630570  lwz r11, 0x570(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1392 as u32) ) } as u64;
	// 8232BBB8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8232BBBC: 7C0A4C2E  lfsx f0, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BBC0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232BBC4: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232BBC8: ED0A0032  fmuls f8, f10, f0
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232BBCC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232BBD0: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232BBD4: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232BBD8: C00A20B0  lfs f0, 0x20b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BBDC: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232BBE0: ED680032  fmuls f11, f8, f0
	ctx.f[11].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232BBE4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232BBE8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232BBEC: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232BBF0: 409A005C  bne cr6, 0x8232bc4c
	if !ctx.cr[6].eq {
		sub_8232BC4C(ctx, base);
		return;
	}
	// 8232BBF4: 896305E4  lbz r11, 0x5e4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1508 as u32) ) } as u64;
	// 8232BBF8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8232BBFC: 409A0020  bne cr6, 0x8232bc1c
	if !ctx.cr[6].eq {
	pc = 0x8232BC1C; continue 'dispatch;
	}
	// 8232BC00: C0030568  lfs f0, 0x568(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BC04: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232BC08: D0030568  stfs f0, 0x568(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1384 as u32), tmp.u32 ) };
	// 8232BC0C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 8232BC10: 4099000C  ble cr6, 0x8232bc1c
	if !ctx.cr[6].gt {
	pc = 0x8232BC1C; continue 'dispatch;
	}
	// 8232BC14: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 8232BC18: 91430570  stw r10, 0x570(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1392 as u32), ctx.r[10].u32 ) };
	pc = 0x8232BC1C; continue 'dispatch;
            }
            0x8232BC1C => {
    //   block [0x8232BC1C..0x8232BC4C)
	// 8232BC1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232BC20: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8232BC24: C0030568  lfs f0, 0x568(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BC28: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232BC2C: D0030568  stfs f0, 0x568(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1384 as u32), tmp.u32 ) };
	// 8232BC30: FDA05850  fneg f13, f11
	ctx.f[13].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232BC34: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232BC38: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 8232BC3C: 81630570  lwz r11, 0x570(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1392 as u32) ) } as u64;
	// 8232BC40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8232BC44: 91630570  stw r11, 0x570(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1392 as u32), ctx.r[11].u32 ) };
	// 8232BC48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232BC4C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8232BC4C size=96
    let mut pc: u32 = 0x8232BC4C;
    'dispatch: loop {
        match pc {
            0x8232BC4C => {
    //   block [0x8232BC4C..0x8232BC80)
	// 8232BC4C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8232BC50: 409A005C  bne cr6, 0x8232bcac
	if !ctx.cr[6].eq {
		sub_8232BCAC(ctx, base);
		return;
	}
	// 8232BC54: 896305E4  lbz r11, 0x5e4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1508 as u32) ) } as u64;
	// 8232BC58: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8232BC5C: 409A0024  bne cr6, 0x8232bc80
	if !ctx.cr[6].eq {
	pc = 0x8232BC80; continue 'dispatch;
	}
	// 8232BC60: C1A30568  lfs f13, 0x568(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232BC64: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232BC68: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8232BC6C: D1A30568  stfs f13, 0x568(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1384 as u32), tmp.u32 ) };
	// 8232BC70: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 8232BC74: 4098000C  bge cr6, 0x8232bc80
	if !ctx.cr[6].lt {
	pc = 0x8232BC80; continue 'dispatch;
	}
	// 8232BC78: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 8232BC7C: 91430570  stw r10, 0x570(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1392 as u32), ctx.r[10].u32 ) };
	pc = 0x8232BC80; continue 'dispatch;
            }
            0x8232BC80 => {
    //   block [0x8232BC80..0x8232BCAC)
	// 8232BC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232BC84: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8232BC88: C1A30568  lfs f13, 0x568(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232BC8C: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 8232BC90: D1A30568  stfs f13, 0x568(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1384 as u32), tmp.u32 ) };
	// 8232BC94: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8232BC98: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 8232BC9C: 81630570  lwz r11, 0x570(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1392 as u32) ) } as u64;
	// 8232BCA0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8232BCA4: 91630570  stw r11, 0x570(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1392 as u32), ctx.r[11].u32 ) };
	// 8232BCA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232BCAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8232BCAC size=108
    let mut pc: u32 = 0x8232BCAC;
    'dispatch: loop {
        match pc {
            0x8232BCAC => {
    //   block [0x8232BCAC..0x8232BCE8)
	// 8232BCAC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8232BCB0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8232BCB4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232BCB8: 894305E4  lbz r10, 0x5e4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1508 as u32) ) } as u64;
	// 8232BCBC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 8232BCC0: C1AB1FF8  lfs f13, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232BCC4: 409A0024  bne cr6, 0x8232bce8
	if !ctx.cr[6].eq {
	pc = 0x8232BCE8; continue 'dispatch;
	}
	// 8232BCC8: C0030568  lfs f0, 0x568(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BCCC: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 8232BCD0: D0030568  stfs f0, 0x568(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1384 as u32), tmp.u32 ) };
	// 8232BCD4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232BCD8: 40990010  ble cr6, 0x8232bce8
	if !ctx.cr[6].gt {
	pc = 0x8232BCE8; continue 'dispatch;
	}
	// 8232BCDC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8232BCE0: D1A30568  stfs f13, 0x568(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1384 as u32), tmp.u32 ) };
	// 8232BCE4: 91630570  stw r11, 0x570(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1392 as u32), ctx.r[11].u32 ) };
	pc = 0x8232BCE8; continue 'dispatch;
            }
            0x8232BCE8 => {
    //   block [0x8232BCE8..0x8232BD18)
	// 8232BCE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232BCEC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8232BCF0: C0030568  lfs f0, 0x568(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BCF4: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 8232BCF8: D0030568  stfs f0, 0x568(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1384 as u32), tmp.u32 ) };
	// 8232BCFC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232BD00: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 8232BD04: 81630570  lwz r11, 0x570(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1392 as u32) ) } as u64;
	// 8232BD08: D1A30568  stfs f13, 0x568(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1384 as u32), tmp.u32 ) };
	// 8232BD0C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8232BD10: 91630570  stw r11, 0x570(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1392 as u32), ctx.r[11].u32 ) };
	// 8232BD14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232BD18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232BD18 size=256
    let mut pc: u32 = 0x8232BD18;
    'dispatch: loop {
        match pc {
            0x8232BD18 => {
    //   block [0x8232BD18..0x8232BE08)
	// 8232BD18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232BD1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232BD20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232BD24: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232BD28: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8232BD2C: 38EBBFF0  addi r7, r11, -0x4010
	ctx.r[7].s64 = ctx.r[11].s64 + -16400;
	// 8232BD30: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8232BD34: 616B9450  ori r11, r11, 0x9450
	ctx.r[11].u64 = ctx.r[11].u64 | 37968;
	// 8232BD38: 7D675A2E  lhzx r11, r7, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232BD3C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8232BD40: 409A00C8  bne cr6, 0x8232be08
	if !ctx.cr[6].eq {
	pc = 0x8232BE08; continue 'dispatch;
	}
	// 8232BD44: 38680578  addi r3, r8, 0x578
	ctx.r[3].s64 = ctx.r[8].s64 + 1400;
	// 8232BD48: 4BF016A1  bl 0x8222d3e8
	ctx.lr = 0x8232BD4C;
	sub_8222D3E8(ctx, base);
	// 8232BD4C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8232BD50: C0080588  lfs f0, 0x588(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BD54: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232BD58: C1A805E8  lfs f13, 0x5e8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1512 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232BD5C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 8232BD60: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232BD64: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8232BD68: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8232BD6C: 7DAB1D2E  stfsx f13, r11, r3
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 8232BD70: C0080588  lfs f0, 0x588(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BD74: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232BD78: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 8232BD7C: C00805D8  lfs f0, 0x5d8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1496 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BD80: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232BD84: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8232BD88: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8232BD8C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 8232BD90: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8232BD94: C0080588  lfs f0, 0x588(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BD98: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232BD9C: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 8232BDA0: C00805DC  lfs f0, 0x5dc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1500 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BDA4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232BDA8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8232BDAC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8232BDB0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 8232BDB4: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8232BDB8: C0080588  lfs f0, 0x588(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BDBC: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232BDC0: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 8232BDC4: C0080568  lfs f0, 0x568(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BDC8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232BDCC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8232BDD0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 8232BDD4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8232BDD8: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8232BDDC: C1A80588  lfs f13, 0x588(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232BDE0: 616B85D4  ori r11, r11, 0x85d4
	ctx.r[11].u64 = ctx.r[11].u64 | 34260;
	// 8232BDE4: 7C075C2E  lfsx f0, r7, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BDE8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232BDEC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232BDF0: D0080588  stfs f0, 0x588(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(1416 as u32), tmp.u32 ) };
	// 8232BDF4: C1ABF3EC  lfs f13, -0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232BDF8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232BDFC: 4198000C  blt cr6, 0x8232be08
	if ctx.cr[6].lt {
	pc = 0x8232BE08; continue 'dispatch;
	}
	// 8232BE00: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232BE04: D0080588  stfs f0, 0x588(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(1416 as u32), tmp.u32 ) };
	pc = 0x8232BE08; continue 'dispatch;
            }
            0x8232BE08 => {
    //   block [0x8232BE08..0x8232BE18)
	// 8232BE08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232BE0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232BE10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232BE14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232BE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232BE18 size=712
    let mut pc: u32 = 0x8232BE18;
    'dispatch: loop {
        match pc {
            0x8232BE18 => {
    //   block [0x8232BE18..0x8232BE40)
	// 8232BE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232BE1C: 482092A1  bl 0x825350bc
	ctx.lr = 0x8232BE20;
	sub_82535080(ctx, base);
	// 8232BE20: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8232BE24: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232BE28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232BE2C: 815F0578  lwz r10, 0x578(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1400 as u32) ) } as u64;
	// 8232BE30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232BE34: 409A000C  bne cr6, 0x8232be40
	if !ctx.cr[6].eq {
	pc = 0x8232BE40; continue 'dispatch;
	}
	// 8232BE38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232BE3C: 4800002C  b 0x8232be68
	pc = 0x8232BE68; continue 'dispatch;
            }
            0x8232BE40 => {
    //   block [0x8232BE40..0x8232BE58)
	// 8232BE40: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232BE44: 813F0580  lwz r9, 0x580(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1408 as u32) ) } as u64;
	// 8232BE48: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232BE4C: 419A000C  beq cr6, 0x8232be58
	if ctx.cr[6].eq {
	pc = 0x8232BE58; continue 'dispatch;
	}
	// 8232BE50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232BE54: 48000014  b 0x8232be68
	pc = 0x8232BE68; continue 'dispatch;
            }
            0x8232BE58 => {
    //   block [0x8232BE58..0x8232BE68)
	// 8232BE58: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232BE5C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8232BE60: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8232BE64: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x8232BE68; continue 'dispatch;
            }
            0x8232BE68 => {
    //   block [0x8232BE68..0x8232BE7C)
	// 8232BE68: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8232BE6C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8232BE70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232BE74: 419A0008  beq cr6, 0x8232be7c
	if ctx.cr[6].eq {
	pc = 0x8232BE7C; continue 'dispatch;
	}
	// 8232BE78: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8232BE7C; continue 'dispatch;
            }
            0x8232BE7C => {
    //   block [0x8232BE7C..0x8232BED4)
	// 8232BE7C: C01F0588  lfs f0, 0x588(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BE80: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 8232BE84: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232BE88: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232BE8C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8232BE90: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8232BE94: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8232BE98: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8232BE9C: FDA06E5E  fctidz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 8232BEA0: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 8232BEA4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8232BEA8: FDA0665E  fctidz f13, f12
	ctx.f[13].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 8232BEAC: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 8232BEB0: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232BEB4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8232BEB8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8232BEBC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232BEC0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232BEC4: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 8232BEC8: 2B080384  cmplwi cr6, r8, 0x384
	ctx.cr[6].compare_u32(ctx.r[8].u32, 900 as u32, &mut ctx.xer);
	// 8232BECC: 41980008  blt cr6, 0x8232bed4
	if ctx.cr[6].lt {
	pc = 0x8232BED4; continue 'dispatch;
	}
	// 8232BED0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x8232BED4; continue 'dispatch;
            }
            0x8232BED4 => {
    //   block [0x8232BED4..0x8232BFBC)
	// 8232BED4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8232BED8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232BEDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232BEE0: C03F05BC  lfs f1, 0x5bc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1468 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232BEE4: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8232BEE8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8232BEEC: C1AABA38  lfs f13, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232BEF0: 550A2036  slwi r10, r8, 4
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8232BEF4: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8232BEF8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8232BEFC: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232BF00: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232BF04: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232BF08: ED8B603A  fmadds f12, f11, f0, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8232BF0C: D19F05E8  stfs f12, 0x5e8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1512 as u32), tmp.u32 ) };
	// 8232BF10: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232BF14: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232BF18: C16A0004  lfs f11, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232BF1C: ED8B603A  fmadds f12, f11, f0, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8232BF20: D19F05D8  stfs f12, 0x5d8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1496 as u32), tmp.u32 ) };
	// 8232BF24: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232BF28: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232BF2C: C16A0008  lfs f11, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232BF30: ED8B603A  fmadds f12, f11, f0, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8232BF34: D19F05DC  stfs f12, 0x5dc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1500 as u32), tmp.u32 ) };
	// 8232BF38: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232BF3C: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232BF40: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232BF44: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8232BF48: D01F0568  stfs f0, 0x568(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1384 as u32), tmp.u32 ) };
	// 8232BF4C: 4BFFF745  bl 0x8232b690
	ctx.lr = 0x8232BF50;
	sub_8232B690(ctx, base);
	// 8232BF50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232BF54: C19F05BC  lfs f12, 0x5bc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1468 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232BF58: 807F0544  lwz r3, 0x544(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1348 as u32) ) } as u64;
	// 8232BF5C: C3FF05E8  lfs f31, 0x5e8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1512 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8232BF60: C03F05D8  lfs f1, 0x5d8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1496 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232BF64: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232BF68: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232BF6C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BF70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232BF74: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8232BF78: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8232BF7C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8232BF80: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8232BF84: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8232BF88: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8232BF8C: C00B24D4  lfs f0, 0x24d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232BF90: EC0C037C  fnmsubs f0, f12, f13, f0
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8232BF94: EDA0F82A  fadds f13, f0, f31
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 8232BF98: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8232BF9C: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8232BFA0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8232BFA4: 4803BEED  bl 0x82367e90
	ctx.lr = 0x8232BFA8;
	sub_82367E90(ctx, base);
	// 8232BFA8: C03F05D8  lfs f1, 0x5d8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1496 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232BFAC: 807F0530  lwz r3, 0x530(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1328 as u32) ) } as u64;
	// 8232BFB0: 4803BEE1  bl 0x82367e90
	ctx.lr = 0x8232BFB4;
	sub_82367E90(ctx, base);
	// 8232BFB4: 3BBF0534  addi r29, r31, 0x534
	ctx.r[29].s64 = ctx.r[31].s64 + 1332;
	// 8232BFB8: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	pc = 0x8232BFBC; continue 'dispatch;
            }
            0x8232BFBC => {
    //   block [0x8232BFBC..0x8232BFE0)
	// 8232BFBC: C03F05DC  lfs f1, 0x5dc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1500 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232BFC0: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232BFC4: 4803BFF5  bl 0x82367fb8
	ctx.lr = 0x8232BFC8;
	sub_82367FB8(ctx, base);
	// 8232BFC8: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8232BFCC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8232BFD0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232BFD4: 409AFFE8  bne cr6, 0x8232bfbc
	if !ctx.cr[6].eq {
	pc = 0x8232BFBC; continue 'dispatch;
	}
	// 8232BFD8: 3BBF0548  addi r29, r31, 0x548
	ctx.r[29].s64 = ctx.r[31].s64 + 1352;
	// 8232BFDC: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	pc = 0x8232BFE0; continue 'dispatch;
            }
            0x8232BFE0 => {
    //   block [0x8232BFE0..0x8232C004)
	// 8232BFE0: C03F05DC  lfs f1, 0x5dc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1500 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232BFE4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232BFE8: 4803BFD1  bl 0x82367fb8
	ctx.lr = 0x8232BFEC;
	sub_82367FB8(ctx, base);
	// 8232BFEC: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8232BFF0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8232BFF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232BFF8: 409AFFE8  bne cr6, 0x8232bfe0
	if !ctx.cr[6].eq {
	pc = 0x8232BFE0; continue 'dispatch;
	}
	// 8232BFFC: 3BBF0510  addi r29, r31, 0x510
	ctx.r[29].s64 = ctx.r[31].s64 + 1296;
	// 8232C000: 3BC00012  li r30, 0x12
	ctx.r[30].s64 = 18;
	pc = 0x8232C004; continue 'dispatch;
            }
            0x8232C004 => {
    //   block [0x8232C004..0x8232C0B4)
	// 8232C004: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232C008: C0030038  lfs f0, 0x38(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232C00C: C1A30030  lfs f13, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232C010: EC1F002A  fadds f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232C014: C1830034  lfs f12, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232C018: D1A30030  stfs f13, 0x30(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232C01C: D1830034  stfs f12, 0x34(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232C020: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8232C024: C03F0568  lfs f1, 0x568(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1384 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232C028: 4803BE69  bl 0x82367e90
	ctx.lr = 0x8232C02C;
	sub_82367E90(ctx, base);
	// 8232C02C: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8232C030: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8232C034: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232C038: 409AFFCC  bne cr6, 0x8232c004
	if !ctx.cr[6].eq {
	pc = 0x8232C004; continue 'dispatch;
	}
	// 8232C03C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8232C040: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8232C044: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 8232C048: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 8232C04C: 390B0800  addi r8, r11, 0x800
	ctx.r[8].s64 = ctx.r[11].s64 + 2048;
	// 8232C050: 38EB0810  addi r7, r11, 0x810
	ctx.r[7].s64 = ctx.r[11].s64 + 2064;
	// 8232C054: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 8232C058: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 8232C05C: E8EA0000  ld r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8232C060: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8232C064: E8C90000  ld r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 8232C068: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 8232C06C: F8EB0000  std r7, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 8232C070: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 8232C074: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232C078: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8232C07C: F8C80000  std r6, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 8232C080: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8232C084: F9280008  std r9, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 8232C088: 614A9478  ori r10, r10, 0x9478
	ctx.r[10].u64 = ctx.r[10].u64 | 38008;
	// 8232C08C: C1BF0588  lfs f13, 0x588(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232C090: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232C094: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232C098: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232C09C: D01F0588  stfs f0, 0x588(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1416 as u32), tmp.u32 ) };
	// 8232C0A0: C1ABF3EC  lfs f13, -0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232C0A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232C0A8: 4198000C  blt cr6, 0x8232c0b4
	if ctx.cr[6].lt {
	pc = 0x8232C0B4; continue 'dispatch;
	}
	// 8232C0AC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232C0B0: D01F0588  stfs f0, 0x588(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1416 as u32), tmp.u32 ) };
	pc = 0x8232C0B4; continue 'dispatch;
            }
            0x8232C0B4 => {
    //   block [0x8232C0B4..0x8232C0D4)
	// 8232C0B4: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 8232C0B8: 816ABC24  lwz r11, -0x43dc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17372 as u32) ) } as u64;
	// 8232C0BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232C0C0: 419A0014  beq cr6, 0x8232c0d4
	if ctx.cr[6].eq {
	pc = 0x8232C0D4; continue 'dispatch;
	}
	// 8232C0C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232C0C8: C01F058C  lfs f0, 0x58c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1420 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232C0CC: D01F0588  stfs f0, 0x588(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1416 as u32), tmp.u32 ) };
	// 8232C0D0: 916ABC24  stw r11, -0x43dc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17372 as u32), ctx.r[11].u32 ) };
	pc = 0x8232C0D4; continue 'dispatch;
            }
            0x8232C0D4 => {
    //   block [0x8232C0D4..0x8232C0E0)
	// 8232C0D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8232C0D8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8232C0DC: 48209030  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8232C0E0 size=148
    let mut pc: u32 = 0x8232C0E0;
    'dispatch: loop {
        match pc {
            0x8232C0E0 => {
    //   block [0x8232C0E0..0x8232C0F4)
	// 8232C0E0: 81430578  lwz r10, 0x578(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1400 as u32) ) } as u64;
	// 8232C0E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232C0E8: 409A000C  bne cr6, 0x8232c0f4
	if !ctx.cr[6].eq {
	pc = 0x8232C0F4; continue 'dispatch;
	}
	// 8232C0EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232C0F0: 4800002C  b 0x8232c11c
	pc = 0x8232C11C; continue 'dispatch;
            }
            0x8232C0F4 => {
    //   block [0x8232C0F4..0x8232C10C)
	// 8232C0F4: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232C0F8: 81230580  lwz r9, 0x580(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1408 as u32) ) } as u64;
	// 8232C0FC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232C100: 419A000C  beq cr6, 0x8232c10c
	if ctx.cr[6].eq {
	pc = 0x8232C10C; continue 'dispatch;
	}
	// 8232C104: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232C108: 48000014  b 0x8232c11c
	pc = 0x8232C11C; continue 'dispatch;
            }
            0x8232C10C => {
    //   block [0x8232C10C..0x8232C11C)
	// 8232C10C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232C110: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8232C114: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8232C118: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x8232C11C; continue 'dispatch;
            }
            0x8232C11C => {
    //   block [0x8232C11C..0x8232C130)
	// 8232C11C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8232C120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232C124: 409A000C  bne cr6, 0x8232c130
	if !ctx.cr[6].eq {
	pc = 0x8232C130; continue 'dispatch;
	}
	// 8232C128: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8232C12C: 48000008  b 0x8232c134
	pc = 0x8232C134; continue 'dispatch;
            }
            0x8232C130 => {
    //   block [0x8232C130..0x8232C134)
	// 8232C130: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8232C134; continue 'dispatch;
            }
            0x8232C134 => {
    //   block [0x8232C134..0x8232C150)
	// 8232C134: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232C138: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8232C13C: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232C140: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	// 8232C144: C1A921EC  lfs f13, 0x21ec(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232C148: 39400384  li r10, 0x384
	ctx.r[10].s64 = 900;
	// 8232C14C: D0030588  stfs f0, 0x588(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1416 as u32), tmp.u32 ) };
	pc = 0x8232C150; continue 'dispatch;
            }
            0x8232C150 => {
    //   block [0x8232C150..0x8232C174)
	// 8232C150: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8232C154: D1ABFFF8  stfs f13, -8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 8232C158: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 8232C15C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8232C160: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232C164: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8232C168: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 8232C16C: 409AFFE4  bne cr6, 0x8232c150
	if !ctx.cr[6].eq {
	pc = 0x8232C150; continue 'dispatch;
	}
	// 8232C170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232C178 size=224
    let mut pc: u32 = 0x8232C178;
    'dispatch: loop {
        match pc {
            0x8232C178 => {
    //   block [0x8232C178..0x8232C1CC)
	// 8232C178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232C17C: 48208F3D  bl 0x825350b8
	ctx.lr = 0x8232C180;
	sub_82535080(ctx, base);
	// 8232C180: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232C184: 3FA082C0  lis r29, -0x7d40
	ctx.r[29].s64 = -2101346304;
	// 8232C188: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232C18C: 817DBC34  lwz r11, -0x43cc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17356 as u32) ) } as u64;
	// 8232C190: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8232C194: 409A0038  bne cr6, 0x8232c1cc
	if !ctx.cr[6].eq {
	pc = 0x8232C1CC; continue 'dispatch;
	}
	// 8232C198: 889F05F0  lbz r4, 0x5f0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1520 as u32) ) } as u64;
	// 8232C19C: 4BFFED9D  bl 0x8232af38
	ctx.lr = 0x8232C1A0;
	sub_8232AF38(ctx, base);
	// 8232C1A0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8232C1A4: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 8232C1A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232C1AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232C1B0: 93DF05EC  stw r30, 0x5ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1516 as u32), ctx.r[30].u32 ) };
	// 8232C1B4: 93DF0584  stw r30, 0x584(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1412 as u32), ctx.r[30].u32 ) };
	// 8232C1B8: 916ABC30  stw r11, -0x43d0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17360 as u32), ctx.r[11].u32 ) };
	// 8232C1BC: 4BFFFF25  bl 0x8232c0e0
	ctx.lr = 0x8232C1C0;
	sub_8232C0E0(ctx, base);
	// 8232C1C0: 93DDBC34  stw r30, -0x43cc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-17356 as u32), ctx.r[30].u32 ) };
	// 8232C1C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232C1C8: 48208F40  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8232C1CC => {
    //   block [0x8232C1CC..0x8232C22C)
	// 8232C1CC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8232C1D0: 409A0078  bne cr6, 0x8232c248
	if !ctx.cr[6].eq {
	pc = 0x8232C248; continue 'dispatch;
	}
	// 8232C1D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232C1D8: 889F05F0  lbz r4, 0x5f0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1520 as u32) ) } as u64;
	// 8232C1DC: 4BFFED5D  bl 0x8232af38
	ctx.lr = 0x8232C1E0;
	sub_8232AF38(ctx, base);
	// 8232C1E0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8232C1E4: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 8232C1E8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 8232C1EC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8232C1F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232C1F4: 916ABC30  stw r11, -0x43d0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17360 as u32), ctx.r[11].u32 ) };
	// 8232C1F8: 93DF0584  stw r30, 0x584(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1412 as u32), ctx.r[30].u32 ) };
	// 8232C1FC: 4BFFFEE5  bl 0x8232c0e0
	ctx.lr = 0x8232C200;
	sub_8232C0E0(ctx, base);
	// 8232C200: 4803B1B9  bl 0x823673b8
	ctx.lr = 0x8232C204;
	sub_823673B8(ctx, base);
	// 8232C204: 546B07FE  clrlwi r11, r3, 0x1f
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	// 8232C208: C01F05CC  lfs f0, 0x5cc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1484 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232C20C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232C210: 409A001C  bne cr6, 0x8232c22c
	if !ctx.cr[6].eq {
	pc = 0x8232C22C; continue 'dispatch;
	}
	// 8232C214: D01F05D4  stfs f0, 0x5d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1492 as u32), tmp.u32 ) };
	// 8232C218: 9BDF05E4  stb r30, 0x5e4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1508 as u32), ctx.r[30].u8 ) };
	// 8232C21C: 93DDBC34  stw r30, -0x43cc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-17356 as u32), ctx.r[30].u32 ) };
	// 8232C220: 939F05EC  stw r28, 0x5ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1516 as u32), ctx.r[28].u32 ) };
	// 8232C224: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232C228: 48208EE0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8232C22C => {
    //   block [0x8232C22C..0x8232C248)
	// 8232C22C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232C230: 9B9F05E4  stb r28, 0x5e4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1508 as u32), ctx.r[28].u8 ) };
	// 8232C234: D01F05D4  stfs f0, 0x5d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1492 as u32), tmp.u32 ) };
	// 8232C238: 93DDBC34  stw r30, -0x43cc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-17356 as u32), ctx.r[30].u32 ) };
	// 8232C23C: 939F05EC  stw r28, 0x5ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1516 as u32), ctx.r[28].u32 ) };
	// 8232C240: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232C244: 48208EC4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8232C248 => {
    //   block [0x8232C248..0x8232C258)
	// 8232C248: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232C24C: 917DBC34  stw r11, -0x43cc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-17356 as u32), ctx.r[11].u32 ) };
	// 8232C250: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232C254: 48208EB4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232C258 size=12
    let mut pc: u32 = 0x8232C258;
    'dispatch: loop {
        match pc {
            0x8232C258 => {
    //   block [0x8232C258..0x8232C264)
	// 8232C258: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232C25C: 9963001E  stb r11, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[11].u8 ) };
	// 8232C260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232C268 size=200
    let mut pc: u32 = 0x8232C268;
    'dispatch: loop {
        match pc {
            0x8232C268 => {
    //   block [0x8232C268..0x8232C330)
	// 8232C268: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 8232C26C: 81630088  lwz r11, 0x88(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 8232C270: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8232C274: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8232C278: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8232C27C: 3CC082C0  lis r6, -0x7d40
	ctx.r[6].s64 = -2101346304;
	// 8232C280: 814ABC28  lwz r10, -0x43d8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17368 as u32) ) } as u64;
	// 8232C284: 88C6B901  lbz r6, -0x46ff(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(-18175 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232C330 size=4
    let mut pc: u32 = 0x8232C330;
    'dispatch: loop {
        match pc {
            0x8232C330 => {
    //   block [0x8232C330..0x8232C334)
	// 8232C330: 4BFFFF38  b 0x8232c268
	sub_8232C268(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232C338 size=8
    let mut pc: u32 = 0x8232C338;
    'dispatch: loop {
        match pc {
            0x8232C338 => {
    //   block [0x8232C338..0x8232C340)
	// 8232C338: 5483F7FE  rlwinm r3, r4, 0x1e, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0x00000003u64;
	// 8232C33C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232C340 size=140
    let mut pc: u32 = 0x8232C340;
    'dispatch: loop {
        match pc {
            0x8232C340 => {
    //   block [0x8232C340..0x8232C398)
	// 8232C340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232C344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232C348: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232C34C: A1650008  lhz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232C350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232C354: 419A0064  beq cr6, 0x8232c3b8
	if ctx.cr[6].eq {
	pc = 0x8232C3B8; continue 'dispatch;
	}
	// 8232C358: 81650068  lwz r11, 0x68(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(104 as u32) ) } as u64;
	// 8232C35C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232C360: 419A0058  beq cr6, 0x8232c3b8
	if ctx.cr[6].eq {
	pc = 0x8232C3B8; continue 'dispatch;
	}
	// 8232C364: 89650005  lbz r11, 5(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(5 as u32) ) } as u64;
	// 8232C368: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8232C36C: 4198004C  blt cr6, 0x8232c3b8
	if ctx.cr[6].lt {
	pc = 0x8232C3B8; continue 'dispatch;
	}
	// 8232C370: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232C374: 419A0024  beq cr6, 0x8232c398
	if ctx.cr[6].eq {
	pc = 0x8232C398; continue 'dispatch;
	}
	// 8232C378: 48000091  bl 0x8232c408
	ctx.lr = 0x8232C37C;
	sub_8232C408(ctx, base);
	// 8232C37C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232C380: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 8232C384: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8232C388: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232C38C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232C390: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232C394: 4E800020  blr
	return;
            }
            0x8232C398 => {
    //   block [0x8232C398..0x8232C3B8)
	// 8232C398: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232C39C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8232C3A0: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 8232C3A4: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8232C3A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232C3AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232C3B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232C3B4: 4E800020  blr
	return;
            }
            0x8232C3B8 => {
    //   block [0x8232C3B8..0x8232C3CC)
	// 8232C3B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8232C3BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232C3C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232C3C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232C3C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232C3D0 size=48
    let mut pc: u32 = 0x8232C3D0;
    'dispatch: loop {
        match pc {
            0x8232C3D0 => {
    //   block [0x8232C3D0..0x8232C400)
	// 8232C3D0: A1630008  lhz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232C3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232C3D8: 419A0028  beq cr6, 0x8232c400
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8232C400);
		return;
	}
	// 8232C3DC: 81430068  lwz r10, 0x68(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 8232C3E0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8232C3E4: 419A001C  beq cr6, 0x8232c400
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8232C400);
		return;
	}
	// 8232C3E8: 89430005  lbz r10, 5(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(5 as u32) ) } as u64;
	// 8232C3EC: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 8232C3F0: 41980010  blt cr6, 0x8232c400
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x8232C400);
		return;
	}
	// 8232C3F4: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8232C3F8: 386B0310  addi r3, r11, 0x310
	ctx.r[3].s64 = ctx.r[11].s64 + 784;
	// 8232C3FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232C408 size=448
    let mut pc: u32 = 0x8232C408;
    'dispatch: loop {
        match pc {
            0x8232C408 => {
    //   block [0x8232C408..0x8232C5C8)
	// 8232C408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232C40C: 48208CA1  bl 0x825350ac
	ctx.lr = 0x8232C410;
	sub_82535080(ctx, base);
	// 8232C410: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8232C414: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232C418: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232C41C: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8232C420: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232C424: 396BD9DC  addi r11, r11, -0x2624
	ctx.r[11].s64 = ctx.r[11].s64 + -9764;
	// 8232C428: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232C42C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8232C430: 3BDF0070  addi r30, r31, 0x70
	ctx.r[30].s64 = ctx.r[31].s64 + 112;
	// 8232C434: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8232C438: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 8232C43C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232C440: 3D603F80  lis r11, 0x3f80
	ctx.r[11].s64 = 1065353216;
	// 8232C444: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8232C448: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8232C44C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 8232C450: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 8232C454: D3FE029C  stfs f31, 0x29c(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 8232C458: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 8232C45C: 939E0294  stw r28, 0x294(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(660 as u32), ctx.r[28].u32 ) };
	// 8232C460: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 8232C464: 939E0298  stw r28, 0x298(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(664 as u32), ctx.r[28].u32 ) };
	// 8232C468: 397F031F  addi r11, r31, 0x31f
	ctx.r[11].s64 = ctx.r[31].s64 + 799;
	// 8232C46C: 394A4634  addi r10, r10, 0x4634
	ctx.r[10].s64 = ctx.r[10].s64 + 17972;
	// 8232C470: 55790036  rlwinm r25, r11, 0, 0, 0x1b
	ctx.r[25].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8232C474: 397E0250  addi r11, r30, 0x250
	ctx.r[11].s64 = ctx.r[30].s64 + 592;
	// 8232C478: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8232C47C: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8232C480: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8232C484: 915E0290  stw r10, 0x290(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(656 as u32), ctx.r[10].u32 ) };
	// 8232C488: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232C5C8 size=124
    let mut pc: u32 = 0x8232C5C8;
    'dispatch: loop {
        match pc {
            0x8232C5C8 => {
    //   block [0x8232C5C8..0x8232C600)
	// 8232C5C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232C5CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232C5D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232C5D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232C5D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232C5DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232C5E0: 394BD9DC  addi r10, r11, -0x2624
	ctx.r[10].s64 = ctx.r[11].s64 + -9764;
	// 8232C5E4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232C5E8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8232C5EC: 812BBC40  lwz r9, -0x43c0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17344 as u32) ) } as u64;
	// 8232C5F0: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8232C5F4: 409A000C  bne cr6, 0x8232c600
	if !ctx.cr[6].eq {
	pc = 0x8232C600; continue 'dispatch;
	}
	// 8232C5F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8232C5FC: 914BBC40  stw r10, -0x43c0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17344 as u32), ctx.r[10].u32 ) };
	pc = 0x8232C600; continue 'dispatch;
            }
            0x8232C600 => {
    //   block [0x8232C600..0x8232C630)
	// 8232C600: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232C604: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8232C608: 396B4634  addi r11, r11, 0x4634
	ctx.r[11].s64 = ctx.r[11].s64 + 17972;
	// 8232C60C: 394A3BF8  addi r10, r10, 0x3bf8
	ctx.r[10].s64 = ctx.r[10].s64 + 15352;
	// 8232C610: 548907FE  clrlwi r9, r4, 0x1f
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 8232C614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232C618: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8232C61C: 917F0300  stw r11, 0x300(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(768 as u32), ctx.r[11].u32 ) };
	// 8232C620: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8232C624: 419A000C  beq cr6, 0x8232c630
	if ctx.cr[6].eq {
	pc = 0x8232C630; continue 'dispatch;
	}
	// 8232C628: 48206591  bl 0x82532bb8
	ctx.lr = 0x8232C62C;
	sub_82532BB8(ctx, base);
	// 8232C62C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8232C630; continue 'dispatch;
            }
            0x8232C630 => {
    //   block [0x8232C630..0x8232C644)
	// 8232C630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232C634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232C638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232C63C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232C640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232C648 size=16
    let mut pc: u32 = 0x8232C648;
    'dispatch: loop {
        match pc {
            0x8232C648 => {
    //   block [0x8232C648..0x8232C658)
	// 8232C648: A163000A  lhz r11, 0xa(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(10 as u32) ) } as u64;
	// 8232C64C: 556B303E  rotlwi r11, r11, 6
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(6)) as u64;
	// 8232C650: 386B0310  addi r3, r11, 0x310
	ctx.r[3].s64 = ctx.r[11].s64 + 784;
	// 8232C654: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8232C658 size=60
    let mut pc: u32 = 0x8232C658;
    'dispatch: loop {
        match pc {
            0x8232C658 => {
    //   block [0x8232C658..0x8232C68C)
	// 8232C658: C1A30018  lfs f13, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232C65C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232C660: C0030020  lfs f0, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232C664: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232C668: C1A30014  lfs f13, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232C66C: EC00687A  fmadds f0, f0, f1, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64 + ctx.f[13].f64) as f32) as f64);
	// 8232C670: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232C674: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8232C678: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232C67C: 41980010  blt cr6, 0x8232c68c
	if ctx.cr[6].lt {
	pc = 0x8232C68C; continue 'dispatch;
	}
	// 8232C680: C1A3001C  lfs f13, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232C684: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232C688: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x8232C68C; continue 'dispatch;
            }
            0x8232C68C => {
    //   block [0x8232C68C..0x8232C694)
	// 8232C68C: D1A30014  stfs f13, 0x14(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8232C690: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232C698 size=100
    let mut pc: u32 = 0x8232C698;
    'dispatch: loop {
        match pc {
            0x8232C698 => {
    //   block [0x8232C698..0x8232C6FC)
	// 8232C698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232C69C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232C6A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232C6A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232C6A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232C6AC: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 8232C6B0: 387F02C0  addi r3, r31, 0x2c0
	ctx.r[3].s64 = ctx.r[31].s64 + 704;
	// 8232C6B4: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232C6B8: 4803B679  bl 0x82367d30
	ctx.lr = 0x8232C6BC;
	sub_82367D30(ctx, base);
	// 8232C6BC: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 8232C6C0: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232C6C4: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8232C6C8: D01F030C  stfs f0, 0x30c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(780 as u32), tmp.u32 ) };
	// 8232C6CC: 4BEF1D05  bl 0x8221e3d0
	ctx.lr = 0x8232C6D0;
	sub_8221E3D0(ctx, base);
	// 8232C6D0: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232C6D4: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 8232C6D8: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8232C6DC: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 8232C6E0: 396BB670  addi r11, r11, -0x4990
	ctx.r[11].s64 = ctx.r[11].s64 + -18832;
	// 8232C6E4: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 8232C6E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232C6EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232C6F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232C6F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232C6F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232C700 size=208
    let mut pc: u32 = 0x8232C700;
    'dispatch: loop {
        match pc {
            0x8232C700 => {
    //   block [0x8232C700..0x8232C758)
	// 8232C700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232C704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232C708: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232C70C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232C710: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232C714: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8232C718: 896B0005  lbz r11, 5(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 8232C71C: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 8232C720: 40980038  bge cr6, 0x8232c758
	if !ctx.cr[6].lt {
	pc = 0x8232C758; continue 'dispatch;
	}
	// 8232C724: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232C728: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8232C72C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8232C730: 409A008C  bne cr6, 0x8232c7bc
	if !ctx.cr[6].eq {
	pc = 0x8232C7BC; continue 'dispatch;
	}
	// 8232C734: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8232C738: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8232C73C: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8232C740: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8232C744: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232C748: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232C74C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232C750: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232C754: 4E800020  blr
	return;
            }
            0x8232C758 => {
    //   block [0x8232C758..0x8232C7B4)
	// 8232C758: 4BFA3BE9  bl 0x822d0340
	ctx.lr = 0x8232C75C;
	sub_822D0340(ctx, base);
	// 8232C75C: 813F0080  lwz r9, 0x80(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8232C760: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 8232C764: 394BDCC0  addi r10, r11, -0x2340
	ctx.r[10].s64 = ctx.r[11].s64 + -9024;
	// 8232C768: 81690054  lwz r11, 0x54(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232C76C: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232C770: C14B0024  lfs f10, 0x24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8232C774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232C778: C12B0020  lfs f9, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8232C77C: C10B001C  lfs f8, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8232C780: C0EB0018  lfs f7, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8232C784: C0CB0014  lfs f6, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8232C788: C0AB0010  lfs f5, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8232C78C: C08B000C  lfs f4, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8232C790: C06B0008  lfs f3, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8232C794: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8232C798: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8232C79C: 419A0018  beq cr6, 0x8232c7b4
	if ctx.cr[6].eq {
	pc = 0x8232C7B4; continue 'dispatch;
	}
	// 8232C7A0: 81230030  lwz r9, 0x30(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232C7A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232C7A8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8232C7AC: 409A0008  bne cr6, 0x8232c7b4
	if !ctx.cr[6].eq {
	pc = 0x8232C7B4; continue 'dispatch;
	}
	// 8232C7B0: 4BFA4481  bl 0x822d0c30
	ctx.lr = 0x8232C7B4;
	sub_822D0C30(ctx, base);
	pc = 0x8232C7B4; continue 'dispatch;
            }
            0x8232C7B4 => {
    //   block [0x8232C7B4..0x8232C7BC)
	// 8232C7B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232C7B8: 997F001C  stb r11, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	pc = 0x8232C7BC; continue 'dispatch;
            }
            0x8232C7BC => {
    //   block [0x8232C7BC..0x8232C7D0)
	// 8232C7BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232C7C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232C7C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232C7C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232C7CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232C7D0 size=56
    let mut pc: u32 = 0x8232C7D0;
    'dispatch: loop {
        match pc {
            0x8232C7D0 => {
    //   block [0x8232C7D0..0x8232C808)
	// 8232C7D0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232C7D4: 894BBFF0  lbz r10, -0x4010(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-16400 as u32) ) } as u64;
	// 8232C7D8: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 8232C7DC: 396BDCC0  addi r11, r11, -0x2340
	ctx.r[11].s64 = ctx.r[11].s64 + -9024;
	// 8232C7E0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232C7E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232C7E8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8232C7EC: 81230030  lwz r9, 0x30(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232C7F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232C7F4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8232C7F8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8232C7FC: 7D4B0034  cntlzw r11, r10
	ctx.r[11].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8232C800: 5564DFFE  rlwinm r4, r11, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8232C804: 4BFA3E3C  b 0x822d0640
	sub_822D0640(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232C808 size=4
    let mut pc: u32 = 0x8232C808;
    'dispatch: loop {
        match pc {
            0x8232C808 => {
    //   block [0x8232C808..0x8232C80C)
	// 8232C808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232C810 size=4
    let mut pc: u32 = 0x8232C810;
    'dispatch: loop {
        match pc {
            0x8232C810 => {
    //   block [0x8232C810..0x8232C814)
	// 8232C810: 4BFA3CB0  b 0x822d04c0
	sub_822D04C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232C818 size=212
    let mut pc: u32 = 0x8232C818;
    'dispatch: loop {
        match pc {
            0x8232C818 => {
    //   block [0x8232C818..0x8232C86C)
	// 8232C818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232C81C: 48208895  bl 0x825350b0
	ctx.lr = 0x8232C820;
	sub_82535080(ctx, base);
	// 8232C820: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8232C824: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232C828: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 8232C82C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8232C830: 3BEBF500  addi r31, r11, -0xb00
	ctx.r[31].s64 = ctx.r[11].s64 + -2816;
	// 8232C834: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8232C838: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8232C83C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8232C840: 483E0A1D  bl 0x8270d25c
	ctx.lr = 0x8232C844;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 8232C844: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8232C848: 83BF0038  lwz r29, 0x38(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8232C84C: 483E0A21  bl 0x8270d26c
	ctx.lr = 0x8232C850;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 8232C850: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8232C854: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8232C858: 419A0088  beq cr6, 0x8232c8e0
	if ctx.cr[6].eq {
	pc = 0x8232C8E0; continue 'dispatch;
	}
	// 8232C85C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232C860: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8232C864: 3BCB9180  addi r30, r11, -0x6e80
	ctx.r[30].s64 = ctx.r[11].s64 + -28288;
	// 8232C868: C3EA1FF8  lfs f31, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x8232C86C; continue 'dispatch;
            }
            0x8232C86C => {
    //   block [0x8232C86C..0x8232C8D4)
	// 8232C86C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8232C870: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8232C874: 4806E62D  bl 0x8239aea0
	ctx.lr = 0x8232C878;
	sub_8239AEA0(ctx, base);
	// 8232C878: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8232C87C: 387E0080  addi r3, r30, 0x80
	ctx.r[3].s64 = ctx.r[30].s64 + 128;
	// 8232C880: 4807CB31  bl 0x823a93b0
	ctx.lr = 0x8232C884;
	sub_823A93B0(ctx, base);
	// 8232C884: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232C888: 419A004C  beq cr6, 0x8232c8d4
	if ctx.cr[6].eq {
	pc = 0x8232C8D4; continue 'dispatch;
	}
	// 8232C88C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232C890: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8232C894: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8232C898: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8232C89C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8232C8A0: 4E800421  bctrl
	ctx.lr = 0x8232C8A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8232C8A4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8232C8A8: 409A002C  bne cr6, 0x8232c8d4
	if !ctx.cr[6].eq {
	pc = 0x8232C8D4; continue 'dispatch;
	}
	// 8232C8AC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232C8B0: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 8232C8B4: 419A0020  beq cr6, 0x8232c8d4
	if ctx.cr[6].eq {
	pc = 0x8232C8D4; continue 'dispatch;
	}
	// 8232C8B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232C8BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8232C8C0: 7B650020  clrldi r5, r27, 0x20
	ctx.r[5].u64 = ctx.r[27].u64 & 0x00000000FFFFFFFFu64;
	// 8232C8C4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8232C8C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232C8CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8232C8D0: 4E800421  bctrl
	ctx.lr = 0x8232C8D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8232C8D4 => {
    //   block [0x8232C8D4..0x8232C8E0)
	// 8232C8D4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8232C8D8: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8232C8DC: 4198FF90  blt cr6, 0x8232c86c
	if ctx.cr[6].lt {
	pc = 0x8232C86C; continue 'dispatch;
	}
	pc = 0x8232C8E0; continue 'dispatch;
            }
            0x8232C8E0 => {
    //   block [0x8232C8E0..0x8232C8EC)
	// 8232C8E0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8232C8E4: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8232C8E8: 48208818  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232C8F0 size=188
    let mut pc: u32 = 0x8232C8F0;
    'dispatch: loop {
        match pc {
            0x8232C8F0 => {
    //   block [0x8232C8F0..0x8232C998)
	// 8232C8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232C8F4: 482087C9  bl 0x825350bc
	ctx.lr = 0x8232C8F8;
	sub_82535080(ctx, base);
	// 8232C8F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232C8FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8232C900: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232C904: 3FA082C0  lis r29, -0x7d40
	ctx.r[29].s64 = -2101346304;
	// 8232C908: 396BDA38  addi r11, r11, -0x25c8
	ctx.r[11].s64 = ctx.r[11].s64 + -9672;
	// 8232C90C: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232C910: 815DBC44  lwz r10, -0x43bc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17340 as u32) ) } as u64;
	// 8232C914: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232C918: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232C91C: 409A007C  bne cr6, 0x8232c998
	if !ctx.cr[6].eq {
	pc = 0x8232C998; continue 'dispatch;
	}
	// 8232C920: 3D2082C0  lis r9, -0x7d40
	ctx.r[9].s64 = -2101346304;
	// 8232C924: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232C928: 8149BC48  lwz r10, -0x43b8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17336 as u32) ) } as u64;
	// 8232C92C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8232C930: 41980068  blt cr6, 0x8232c998
	if ctx.cr[6].lt {
	pc = 0x8232C998; continue 'dispatch;
	}
	// 8232C934: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8232C938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232C93C: 9169BC48  stw r11, -0x43b8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-17336 as u32), ctx.r[11].u32 ) };
	// 8232C940: 409A0058  bne cr6, 0x8232c998
	if !ctx.cr[6].eq {
	pc = 0x8232C998; continue 'dispatch;
	}
	// 8232C944: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232C948: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8232C94C: 386BDA28  addi r3, r11, -0x25d8
	ctx.r[3].s64 = ctx.r[11].s64 + -9688;
	// 8232C950: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8232C954: 3C801000  lis r4, 0x1000
	ctx.r[4].s64 = 268435456;
	// 8232C958: 4BFFFEC1  bl 0x8232c818
	ctx.lr = 0x8232C95C;
	sub_8232C818(ctx, base);
	// 8232C95C: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 8232C960: 3CA00606  lis r5, 0x606
	ctx.r[5].s64 = 101056512;
	// 8232C964: 3BEBF080  addi r31, r11, -0xf80
	ctx.r[31].s64 = ctx.r[11].s64 + -3968;
	// 8232C968: 60A58110  ori r5, r5, 0x8110
	ctx.r[5].u64 = ctx.r[5].u64 | 33040;
	// 8232C96C: 3C802000  lis r4, 0x2000
	ctx.r[4].s64 = 536870912;
	// 8232C970: 387F1600  addi r3, r31, 0x1600
	ctx.r[3].s64 = ctx.r[31].s64 + 5632;
	// 8232C974: 4807C325  bl 0x823a8c98
	ctx.lr = 0x8232C978;
	sub_823A8C98(ctx, base);
	// 8232C978: 3CA00606  lis r5, 0x606
	ctx.r[5].s64 = 101056512;
	// 8232C97C: 3C802000  lis r4, 0x2000
	ctx.r[4].s64 = 536870912;
	// 8232C980: 60A58111  ori r5, r5, 0x8111
	ctx.r[5].u64 = ctx.r[5].u64 | 33041;
	// 8232C984: 60840001  ori r4, r4, 1
	ctx.r[4].u64 = ctx.r[4].u64 | 1;
	// 8232C988: 387F1600  addi r3, r31, 0x1600
	ctx.r[3].s64 = ctx.r[31].s64 + 5632;
	// 8232C98C: 4807C30D  bl 0x823a8c98
	ctx.lr = 0x8232C990;
	sub_823A8C98(ctx, base);
	// 8232C990: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232C994: 917DBC44  stw r11, -0x43bc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-17340 as u32), ctx.r[11].u32 ) };
	pc = 0x8232C998; continue 'dispatch;
            }
            0x8232C998 => {
    //   block [0x8232C998..0x8232C9AC)
	// 8232C998: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232C99C: 396B3BF8  addi r11, r11, 0x3bf8
	ctx.r[11].s64 = ctx.r[11].s64 + 15352;
	// 8232C9A0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232C9A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232C9A8: 48208764  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232C9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232C9B0 size=524
    let mut pc: u32 = 0x8232C9B0;
    'dispatch: loop {
        match pc {
            0x8232C9B0 => {
    //   block [0x8232C9B0..0x8232C9D8)
	// 8232C9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232C9B4: 48208709  bl 0x825350bc
	ctx.lr = 0x8232C9B8;
	sub_82535080(ctx, base);
	// 8232C9B8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232C9BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232C9C0: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 8232C9C4: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 8232C9C8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232C9CC: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 8232C9D0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 8232C9D4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8232C9D8; continue 'dispatch;
            }
            0x8232C9D8 => {
    //   block [0x8232C9D8..0x8232CBBC)
	// 8232C9D8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8232C9DC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8232C9E0: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8232C9E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8232C9E8: 4200FFF0  bdnz 0x8232c9d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8232C9D8; continue 'dispatch;
	}
	// 8232C9EC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8232C9F0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8232C9F4: 4803C19D  bl 0x82368b90
	ctx.lr = 0x8232C9F8;
	sub_82368B90(ctx, base);
	// 8232C9F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232C9FC: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8232CA00: C1A100D0  lfs f13, 0xd0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232CA04: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 8232CA08: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8232CA0C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8232CA10: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232CA14: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 8232CA18: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232CA1C: C1A100D4  lfs f13, 0xd4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232CA20: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232CA24: D18100D0  stfs f12, 0xd0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 8232CA28: D16100D4  stfs f11, 0xd4(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232CBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232CBC0 size=364
    let mut pc: u32 = 0x8232CBC0;
    'dispatch: loop {
        match pc {
            0x8232CBC0 => {
    //   block [0x8232CBC0..0x8232CC34)
	// 8232CBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232CBC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232CBC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232CBCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232CBD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232CBD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232CBD8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232CBDC: 896A0006  lbz r11, 6(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 8232CBE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232CBE4: 419A0130  beq cr6, 0x8232cd14
	if ctx.cr[6].eq {
	pc = 0x8232CD14; continue 'dispatch;
	}
	// 8232CBE8: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232CBEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8232CBF0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8232CBF4: 4198009C  blt cr6, 0x8232cc90
	if ctx.cr[6].lt {
	pc = 0x8232CC90; continue 'dispatch;
	}
	// 8232CBF8: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232CBFC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232CC00: 552B073E  clrlwi r11, r9, 0x1c
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000000Fu64;
	// 8232CC04: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8232CC08: 41990040  bgt cr6, 0x8232cc48
	if ctx.cr[6].gt {
	pc = 0x8232CC48; continue 'dispatch;
	}
	// 8232CC0C: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 8232CC10: 398CCC24  addi r12, r12, -0x33dc
	ctx.r[12].s64 = ctx.r[12].s64 + -13276;
	// 8232CC14: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8232CC18: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8232CC1C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8232CC20: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8232CC48; continue 'dispatch;
		},
		1 => {
	pc = 0x8232CC34; continue 'dispatch;
		},
		2 => {
	pc = 0x8232CC3C; continue 'dispatch;
		},
		3 => {
	pc = 0x8232CC44; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8232CC24: 8232CC48  lwz r17, -0x33b8(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-13240 as u32) ) } as u64;
	// 8232CC28: 8232CC34  lwz r17, -0x33cc(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-13260 as u32) ) } as u64;
	// 8232CC2C: 8232CC3C  lwz r17, -0x33c4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-13252 as u32) ) } as u64;
	// 8232CC30: 8232CC44  lwz r17, -0x33bc(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-13244 as u32) ) } as u64;
            }
            0x8232CC34 => {
    //   block [0x8232CC34..0x8232CC3C)
	// 8232CC34: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 8232CC38: 48000010  b 0x8232cc48
	pc = 0x8232CC48; continue 'dispatch;
            }
            0x8232CC3C => {
    //   block [0x8232CC3C..0x8232CC44)
	// 8232CC3C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 8232CC40: 48000008  b 0x8232cc48
	pc = 0x8232CC48; continue 'dispatch;
            }
            0x8232CC44 => {
    //   block [0x8232CC44..0x8232CC48)
	// 8232CC44: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	pc = 0x8232CC48; continue 'dispatch;
            }
            0x8232CC48 => {
    //   block [0x8232CC48..0x8232CC7C)
	// 8232CC48: 7D2B2670  srawi r11, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 8232CC4C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8232CC50: 41990040  bgt cr6, 0x8232cc90
	if ctx.cr[6].gt {
	pc = 0x8232CC90; continue 'dispatch;
	}
	// 8232CC54: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 8232CC58: 398CCC6C  addi r12, r12, -0x3394
	ctx.r[12].s64 = ctx.r[12].s64 + -13204;
	// 8232CC5C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8232CC60: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8232CC64: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8232CC68: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8232CC90; continue 'dispatch;
		},
		1 => {
	pc = 0x8232CC7C; continue 'dispatch;
		},
		2 => {
	pc = 0x8232CC84; continue 'dispatch;
		},
		3 => {
	pc = 0x8232CC8C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8232CC6C: 8232CC90  lwz r17, -0x3370(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-13168 as u32) ) } as u64;
	// 8232CC70: 8232CC7C  lwz r17, -0x3384(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-13188 as u32) ) } as u64;
	// 8232CC74: 8232CC84  lwz r17, -0x337c(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-13180 as u32) ) } as u64;
	// 8232CC78: 8232CC8C  lwz r17, -0x3374(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-13172 as u32) ) } as u64;
            }
            0x8232CC7C => {
    //   block [0x8232CC7C..0x8232CC84)
	// 8232CC7C: 60C60020  ori r6, r6, 0x20
	ctx.r[6].u64 = ctx.r[6].u64 | 32;
	// 8232CC80: 48000010  b 0x8232cc90
	pc = 0x8232CC90; continue 'dispatch;
            }
            0x8232CC84 => {
    //   block [0x8232CC84..0x8232CC8C)
	// 8232CC84: 60C60040  ori r6, r6, 0x40
	ctx.r[6].u64 = ctx.r[6].u64 | 64;
	// 8232CC88: 48000008  b 0x8232cc90
	pc = 0x8232CC90; continue 'dispatch;
            }
            0x8232CC8C => {
    //   block [0x8232CC8C..0x8232CC90)
	// 8232CC8C: 60C60060  ori r6, r6, 0x60
	ctx.r[6].u64 = ctx.r[6].u64 | 96;
	pc = 0x8232CC90; continue 'dispatch;
            }
            0x8232CC90 => {
    //   block [0x8232CC90..0x8232CD14)
	// 8232CC90: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8232CC94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232CC98: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8232CC9C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8232CCA0: 386BDA28  addi r3, r11, -0x25d8
	ctx.r[3].s64 = ctx.r[11].s64 + -9688;
	// 8232CCA4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232CCA8: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8232CCAC: 4BFFFB6D  bl 0x8232c818
	ctx.lr = 0x8232CCB0;
	sub_8232C818(ctx, base);
	// 8232CCB0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232CCB4: 894B0006  lbz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 8232CCB8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 8232CCBC: 40990058  ble cr6, 0x8232cd14
	if !ctx.cr[6].gt {
	pc = 0x8232CD14; continue 'dispatch;
	}
	// 8232CCC0: 812B0058  lwz r9, 0x58(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8232CCC4: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 8232CCC8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8232CCCC: 3C802000  lis r4, 0x2000
	ctx.r[4].s64 = 536870912;
	// 8232CCD0: 3BCBF080  addi r30, r11, -0xf80
	ctx.r[30].s64 = ctx.r[11].s64 + -3968;
	// 8232CCD4: 387E1600  addi r3, r30, 0x1600
	ctx.r[3].s64 = ctx.r[30].s64 + 5632;
	// 8232CCD8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232CCDC: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8232CCE0: 4807BFB9  bl 0x823a8c98
	ctx.lr = 0x8232CCE4;
	sub_823A8C98(ctx, base);
	// 8232CCE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232CCE8: 894B0006  lbz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 8232CCEC: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 8232CCF0: 40990024  ble cr6, 0x8232cd14
	if !ctx.cr[6].gt {
	pc = 0x8232CD14; continue 'dispatch;
	}
	// 8232CCF4: 816B0058  lwz r11, 0x58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8232CCF8: 3C802000  lis r4, 0x2000
	ctx.r[4].s64 = 536870912;
	// 8232CCFC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8232CD00: 387E1600  addi r3, r30, 0x1600
	ctx.r[3].s64 = ctx.r[30].s64 + 5632;
	// 8232CD04: 60840001  ori r4, r4, 1
	ctx.r[4].u64 = ctx.r[4].u64 | 1;
	// 8232CD08: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232CD0C: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8232CD10: 4807BF89  bl 0x823a8c98
	ctx.lr = 0x8232CD14;
	sub_823A8C98(ctx, base);
	pc = 0x8232CD14; continue 'dispatch;
            }
            0x8232CD14 => {
    //   block [0x8232CD14..0x8232CD2C)
	// 8232CD14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232CD18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232CD1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232CD20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232CD24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232CD28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232CD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232CD30 size=80
    let mut pc: u32 = 0x8232CD30;
    'dispatch: loop {
        match pc {
            0x8232CD30 => {
    //   block [0x8232CD30..0x8232CD68)
	// 8232CD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232CD34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232CD38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232CD3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232CD40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232CD44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232CD48: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8232CD4C: 4BFFFBA5  bl 0x8232c8f0
	ctx.lr = 0x8232CD50;
	sub_8232C8F0(ctx, base);
	// 8232CD50: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8232CD54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232CD58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232CD5C: 419A000C  beq cr6, 0x8232cd68
	if ctx.cr[6].eq {
	pc = 0x8232CD68; continue 'dispatch;
	}
	// 8232CD60: 48205E59  bl 0x82532bb8
	ctx.lr = 0x8232CD64;
	sub_82532BB8(ctx, base);
	// 8232CD64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8232CD68; continue 'dispatch;
            }
            0x8232CD68 => {
    //   block [0x8232CD68..0x8232CD80)
	// 8232CD68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232CD6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232CD70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232CD74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232CD78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232CD7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232CD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232CD80 size=592
    let mut pc: u32 = 0x8232CD80;
    'dispatch: loop {
        match pc {
            0x8232CD80 => {
    //   block [0x8232CD80..0x8232CDA8)
	// 8232CD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232CD84: 48208339  bl 0x825350bc
	ctx.lr = 0x8232CD88;
	sub_82535080(ctx, base);
	// 8232CD88: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232CD8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232CD90: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 8232CD94: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 8232CD98: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232CD9C: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 8232CDA0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 8232CDA4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8232CDA8; continue 'dispatch;
            }
            0x8232CDA8 => {
    //   block [0x8232CDA8..0x8232CFD0)
	// 8232CDA8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8232CDAC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8232CDB0: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8232CDB4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8232CDB8: 4200FFF0  bdnz 0x8232cda8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8232CDA8; continue 'dispatch;
	}
	// 8232CDBC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8232CDC0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8232CDC4: 4803BDCD  bl 0x82368b90
	ctx.lr = 0x8232CDC8;
	sub_82368B90(ctx, base);
	// 8232CDC8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232CDCC: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8232CDD0: C1A100D0  lfs f13, 0xd0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232CDD4: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 8232CDD8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8232CDDC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8232CDE0: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232CDE4: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 8232CDE8: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232CDEC: C1A100D4  lfs f13, 0xd4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232CDF0: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232CDF4: D18100D0  stfs f12, 0xd0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 8232CDF8: D16100D4  stfs f11, 0xd4(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232CFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232CFD0 size=212
    let mut pc: u32 = 0x8232CFD0;
    'dispatch: loop {
        match pc {
            0x8232CFD0 => {
    //   block [0x8232CFD0..0x8232D0A4)
	// 8232CFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232CFD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232CFD8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232CFDC: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8232CFE0: 3D4082B5  lis r10, -0x7d4b
	ctx.r[10].s64 = -2102067200;
	// 8232CFE4: 39680020  addi r11, r8, 0x20
	ctx.r[11].s64 = ctx.r[8].s64 + 32;
	// 8232CFE8: 388A5C40  addi r4, r10, 0x5c40
	ctx.r[4].s64 = ctx.r[10].s64 + 23616;
	// 8232CFEC: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8232CFF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232D0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232D0A8 size=8
    let mut pc: u32 = 0x8232D0A8;
    'dispatch: loop {
        match pc {
            0x8232D0A8 => {
    //   block [0x8232D0A8..0x8232D0B0)
	// 8232D0A8: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 8232D0AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232D0B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232D0B0 size=24
    let mut pc: u32 = 0x8232D0B0;
    'dispatch: loop {
        match pc {
            0x8232D0B0 => {
    //   block [0x8232D0B0..0x8232D0C8)
	// 8232D0B0: 548B077A  rlwinm r11, r4, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 8232D0B4: 386300D0  addi r3, r3, 0xd0
	ctx.r[3].s64 = ctx.r[3].s64 + 208;
	// 8232D0B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232D0BC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8232D0C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8232D0C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232D0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232D0C8 size=96
    let mut pc: u32 = 0x8232D0C8;
    'dispatch: loop {
        match pc {
            0x8232D0C8 => {
    //   block [0x8232D0C8..0x8232D114)
	// 8232D0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232D0CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232D0D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232D0D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232D0D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232D0DC: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8232D0E0: 480D86B1  bl 0x82405790
	ctx.lr = 0x8232D0E4;
	sub_82405790(ctx, base);
	// 8232D0E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232D0E8: 419A002C  beq cr6, 0x8232d114
	if ctx.cr[6].eq {
	pc = 0x8232D114; continue 'dispatch;
	}
	// 8232D0EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232D0F0: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8232D0F4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232D0F8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8232D0FC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8232D100: 409A0014  bne cr6, 0x8232d114
	if !ctx.cr[6].eq {
	pc = 0x8232D114; continue 'dispatch;
	}
	// 8232D104: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8232D108: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8232D10C: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8232D110: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x8232D114; continue 'dispatch;
            }
            0x8232D114 => {
    //   block [0x8232D114..0x8232D128)
	// 8232D114: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232D118: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232D11C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232D120: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232D124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232D128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232D128 size=140
    let mut pc: u32 = 0x8232D128;
    'dispatch: loop {
        match pc {
            0x8232D128 => {
    //   block [0x8232D128..0x8232D160)
	// 8232D128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232D12C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232D130: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232D134: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232D138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232D13C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232D140: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232D144: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8232D148: 396BDAC4  addi r11, r11, -0x253c
	ctx.r[11].s64 = ctx.r[11].s64 + -9532;
	// 8232D14C: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8232D150: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232D154: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232D158: 419A0008  beq cr6, 0x8232d160
	if ctx.cr[6].eq {
	pc = 0x8232D160; continue 'dispatch;
	}
	// 8232D15C: 480D8E8D  bl 0x82405fe8
	ctx.lr = 0x8232D160;
	sub_82405FE8(ctx, base);
	pc = 0x8232D160; continue 'dispatch;
            }
            0x8232D160 => {
    //   block [0x8232D160..0x8232D19C)
	// 8232D160: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232D164: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8232D168: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 8232D16C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232D170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232D174: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232D178: 419A0024  beq cr6, 0x8232d19c
	if ctx.cr[6].eq {
	pc = 0x8232D19C; continue 'dispatch;
	}
	// 8232D17C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232D180: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8232D184: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8232D188: 409A0014  bne cr6, 0x8232d19c
	if !ctx.cr[6].eq {
	pc = 0x8232D19C; continue 'dispatch;
	}
	// 8232D18C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8232D190: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8232D194: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8232D198: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x8232D19C; continue 'dispatch;
            }
            0x8232D19C => {
    //   block [0x8232D19C..0x8232D1B4)
	// 8232D19C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232D1A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232D1A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232D1A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232D1AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232D1B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232D1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232D1B8 size=196
    let mut pc: u32 = 0x8232D1B8;
    'dispatch: loop {
        match pc {
            0x8232D1B8 => {
    //   block [0x8232D1B8..0x8232D22C)
	// 8232D1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232D1BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232D1C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232D1C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232D1C8: 89650007  lbz r11, 7(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(7 as u32) ) } as u64;
	// 8232D1CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232D1D0: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8232D1D4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8232D1D8: 4198008C  blt cr6, 0x8232d264
	if ctx.cr[6].lt {
	pc = 0x8232D264; continue 'dispatch;
	}
	// 8232D1DC: 89650005  lbz r11, 5(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(5 as u32) ) } as u64;
	// 8232D1E0: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 8232D1E4: 41980080  blt cr6, 0x8232d264
	if ctx.cr[6].lt {
	pc = 0x8232D264; continue 'dispatch;
	}
	// 8232D1E8: 89650004  lbz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232D1EC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8232D1F0: 41980074  blt cr6, 0x8232d264
	if ctx.cr[6].lt {
	pc = 0x8232D264; continue 'dispatch;
	}
	// 8232D1F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8232D1F8: 419A0054  beq cr6, 0x8232d24c
	if ctx.cr[6].eq {
	pc = 0x8232D24C; continue 'dispatch;
	}
	// 8232D1FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232D200: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8232D204: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8232D208: 90BF0118  stw r5, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[5].u32 ) };
	// 8232D20C: 396BDA98  addi r11, r11, -0x2568
	ctx.r[11].s64 = ctx.r[11].s64 + -9576;
	// 8232D210: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232D214: 4805C28D  bl 0x823894a0
	ctx.lr = 0x8232D218;
	sub_823894A0(ctx, base);
	// 8232D218: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232D21C: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 8232D220: 409A000C  bne cr6, 0x8232d22c
	if !ctx.cr[6].eq {
	pc = 0x8232D22C; continue 'dispatch;
	}
	// 8232D224: 4805C2F5  bl 0x82389518
	ctx.lr = 0x8232D228;
	sub_82389518(ctx, base);
	// 8232D228: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	pc = 0x8232D22C; continue 'dispatch;
            }
            0x8232D22C => {
    //   block [0x8232D22C..0x8232D24C)
	// 8232D22C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232D230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232D234: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8232D238: 48000079  bl 0x8232d2b0
	ctx.lr = 0x8232D23C;
	sub_8232D2B0(ctx, base);
	// 8232D23C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232D240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232D244: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8232D248: 48000008  b 0x8232d250
	pc = 0x8232D250; continue 'dispatch;
            }
            0x8232D24C => {
    //   block [0x8232D24C..0x8232D250)
	// 8232D24C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8232D250; continue 'dispatch;
            }
            0x8232D250 => {
    //   block [0x8232D250..0x8232D264)
	// 8232D250: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232D254: C1A3000C  lfs f13, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232D258: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D25C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8232D260: 40980008  bge cr6, 0x8232d268
	if !ctx.cr[6].lt {
	pc = 0x8232D268; continue 'dispatch;
	}
	pc = 0x8232D264; continue 'dispatch;
            }
            0x8232D264 => {
    //   block [0x8232D264..0x8232D268)
	// 8232D264: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8232D268; continue 'dispatch;
            }
            0x8232D268 => {
    //   block [0x8232D268..0x8232D27C)
	// 8232D268: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232D26C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232D270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232D274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232D278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232D280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232D280 size=48
    let mut pc: u32 = 0x8232D280;
    'dispatch: loop {
        match pc {
            0x8232D280 => {
    //   block [0x8232D280..0x8232D2A8)
	// 8232D280: 89630007  lbz r11, 7(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(7 as u32) ) } as u64;
	// 8232D284: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8232D288: 41980020  blt cr6, 0x8232d2a8
	if ctx.cr[6].lt {
	pc = 0x8232D2A8; continue 'dispatch;
	}
	// 8232D28C: 89630005  lbz r11, 5(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(5 as u32) ) } as u64;
	// 8232D290: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 8232D294: 41980014  blt cr6, 0x8232d2a8
	if ctx.cr[6].lt {
	pc = 0x8232D2A8; continue 'dispatch;
	}
	// 8232D298: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232D29C: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 8232D2A0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8232D2A4: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	pc = 0x8232D2A8; continue 'dispatch;
            }
            0x8232D2A8 => {
    //   block [0x8232D2A8..0x8232D2B0)
	// 8232D2A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8232D2AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232D2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232D2B0 size=1180
    let mut pc: u32 = 0x8232D2B0;
    'dispatch: loop {
        match pc {
            0x8232D2B0 => {
    //   block [0x8232D2B0..0x8232D3B4)
	// 8232D2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232D2B4: 48207E09  bl 0x825350bc
	ctx.lr = 0x8232D2B8;
	sub_82535080(ctx, base);
	// 8232D2B8: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 8232D2BC: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8232D2C0: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8232D2C4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232D2C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232D2CC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232D2D0: 83DF0118  lwz r30, 0x118(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 8232D2D4: C0CABFFC  lfs f6, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8232D2D8: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232D2DC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D2E0: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8232D2E4: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232D2E8: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232D2EC: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D2F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232D2F4: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8232D2F8: C9AB2008  lfd f13, 0x2008(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 8232D2FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232D300: FC00682E  fsel f0, f0, f0, f13
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8232D304: C9AB2000  lfd f13, 0x2000(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 8232D308: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 8232D30C: FC0C036E  fsel f0, f12, f13, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 8232D310: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8232D314: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8232D318: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232D31C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D320: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232D324: C1AB2150  lfs f13, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232D328: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232D32C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232D330: C3AB1FF8  lfs f29, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8232D334: 40990080  ble cr6, 0x8232d3b4
	if !ctx.cr[6].gt {
	pc = 0x8232D3B4; continue 'dispatch;
	}
	// 8232D338: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232D33C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D340: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232D344: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8232D348: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8232D34C: 396BBA38  addi r11, r11, -0x45c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17864;
	// 8232D350: C3CB0000  lfs f30, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8232D354: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 8232D358: EC00302A  fadds f0, f0, f6
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64;
	// 8232D35C: EC1E0024  fdivs f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 8232D360: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8232D364: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232D368: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232D36C: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232D370: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 8232D374: EC00F1BC  fnmsubs f0, f0, f6, f30
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[6].f64 - ctx.f[30].f64) as f32) as f64);
	// 8232D378: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 8232D37C: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8232D380: EC1E0024  fdivs f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 8232D384: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8232D388: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232D38C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D390: EC060024  fdivs f0, f6, f0
	ctx.f[0].f64 = ((ctx.f[6].f64 / ctx.f[0].f64) as f32) as f64;
	// 8232D394: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8232D398: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232D39C: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232D3A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232D3A4: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D3A8: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232D3AC: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8232D3B0: 48000038  b 0x8232d3e8
	pc = 0x8232D3E8; continue 'dispatch;
            }
            0x8232D3B4 => {
    //   block [0x8232D3B4..0x8232D3E8)
	// 8232D3B4: D3BF0018  stfs f29, 0x18(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8232D3B8: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232D3BC: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D3C0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8232D3C4: 396BBA38  addi r11, r11, -0x45c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17864;
	// 8232D3C8: C3CB0000  lfs f30, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8232D3CC: EC1E0024  fdivs f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 8232D3D0: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8232D3D4: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232D3D8: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D3DC: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8232D3E0: D3BF0024  stfs f29, 0x24(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8232D3E4: D3BF0028  stfs f29, 0x28(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	pc = 0x8232D3E8; continue 'dispatch;
            }
            0x8232D3E8 => {
    //   block [0x8232D3E8..0x8232D74C)
	// 8232D3E8: 815E005C  lwz r10, 0x5c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 8232D3EC: 38FF00B0  addi r7, r31, 0xb0
	ctx.r[7].s64 = ctx.r[31].s64 + 176;
	// 8232D3F0: 397F00C0  addi r11, r31, 0xc0
	ctx.r[11].s64 = ctx.r[31].s64 + 192;
	// 8232D3F4: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8232D3F8: F9270000  std r9, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8232D3FC: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8232D400: F9470008  std r10, 8(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232D750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232D750 size=1072
    let mut pc: u32 = 0x8232D750;
    'dispatch: loop {
        match pc {
            0x8232D750 => {
    //   block [0x8232D750..0x8232D830)
	// 8232D750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232D754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232D758: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232D75C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232D760: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8232D764: 4820887D  bl 0x82535fe0
	ctx.lr = 0x8232D768;
	sub_82535FB0(ctx, base);
	// 8232D768: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232D76C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232D770: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 8232D774: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 8232D778: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8232D77C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8232D780: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232D784: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232D788: C3A7BA38  lfs f29, -0x45c8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8232D78C: C3C81FF8  lfs f30, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8232D790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232D794: C349BFFC  lfs f26, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8232D798: C36A2490  lfs f27, 0x2490(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9360 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 8232D79C: 409A0108  bne cr6, 0x8232d8a4
	if !ctx.cr[6].eq {
	pc = 0x8232D8A4; continue 'dispatch;
	}
	// 8232D7A0: C01F0030  lfs f0, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D7A4: EC1C002A  fadds f0, f28, f0
	ctx.f[0].f64 = ((ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232D7A8: C1BF002C  lfs f13, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232D7AC: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232D7B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232D7B4: 409902E0  ble cr6, 0x8232da94
	if !ctx.cr[6].gt {
	pc = 0x8232DA94; continue 'dispatch;
	}
	// 8232D7B8: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232D7BC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8232D7C0: 396B9A6C  addi r11, r11, -0x6594
	ctx.r[11].s64 = ctx.r[11].s64 + -26004;
	// 8232D7C4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8232D7C8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232D7CC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8232D7D0: 40990060  ble cr6, 0x8232d830
	if !ctx.cr[6].gt {
	pc = 0x8232D830; continue 'dispatch;
	}
	// 8232D7D4: 3BDF005C  addi r30, r31, 0x5c
	ctx.r[30].s64 = ctx.r[31].s64 + 92;
	// 8232D7D8: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8232D7DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8232D7E0: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8232D7E4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8232D7E8: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8232D7EC: D3A1005C  stfs f29, 0x5c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8232D7F0: 48034E91  bl 0x82362680
	ctx.lr = 0x8232D7F4;
	sub_82362680(ctx, base);
	// 8232D7F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232D7F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8232D7FC: 38EBDA90  addi r7, r11, -0x2570
	ctx.r[7].s64 = ctx.r[11].s64 + -9584;
	// 8232D800: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232D804: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8232D808: 38600088  li r3, 0x88
	ctx.r[3].s64 = 136;
	// 8232D80C: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8232D810: 4803CC81  bl 0x8236a490
	ctx.lr = 0x8232D814;
	sub_8236A490(ctx, base);
	// 8232D814: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232D818: 419A0018  beq cr6, 0x8232d830
	if ctx.cr[6].eq {
	pc = 0x8232D830; continue 'dispatch;
	}
	// 8232D81C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232D820: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232D824: 394ADAC4  addi r10, r10, -0x253c
	ctx.r[10].s64 = ctx.r[10].s64 + -9532;
	// 8232D828: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8232D82C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8232D830; continue 'dispatch;
            }
            0x8232D830 => {
    //   block [0x8232D830..0x8232D884)
	// 8232D830: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8232D834: C1BF0038  lfs f13, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232D838: C19F001C  lfs f12, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232D83C: 556AF87E  srwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8232D840: C17F0040  lfs f11, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232D844: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232D848: D3DF0044  stfs f30, 0x44(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8232D84C: D17F003C  stfs f11, 0x3c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8232D850: FF0CF000  fcmpu cr6, f12, f30
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[30].f64);
	// 8232D854: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 8232D858: C00B2038  lfs f0, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D85C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232D860: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232D864: C01F0030  lfs f0, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D868: C1BF002C  lfs f13, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232D86C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232D870: 409A0014  bne cr6, 0x8232d884
	if !ctx.cr[6].eq {
	pc = 0x8232D884; continue 'dispatch;
	}
	// 8232D874: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232D878: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232D87C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8232D880: 4800020C  b 0x8232da8c
	pc = 0x8232DA8C; continue 'dispatch;
            }
            0x8232D884 => {
    //   block [0x8232D884..0x8232D8A4)
	// 8232D884: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232D888: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232D88C: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8232D890: EC3F06F2  fmuls f1, f31, f27
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[27].f64) as f32) as f64);
	// 8232D894: 4BDEFC35  bl 0x8211d4c8
	ctx.lr = 0x8232D898;
	sub_8211D4C8(ctx, base);
	// 8232D898: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 8232D89C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8232D8A0: 480001DC  b 0x8232da7c
	pc = 0x8232DA7C; continue 'dispatch;
            }
            0x8232D8A4 => {
    //   block [0x8232D8A4..0x8232D8F4)
	// 8232D8A4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8232D8A8: 409A00D4  bne cr6, 0x8232d97c
	if !ctx.cr[6].eq {
	pc = 0x8232D97C; continue 'dispatch;
	}
	// 8232D8AC: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D8B0: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232D8B4: EC0D073A  fmadds f0, f13, f28, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64);
	// 8232D8B8: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8232D8BC: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 8232D8C0: 409901D4  ble cr6, 0x8232da94
	if !ctx.cr[6].gt {
	pc = 0x8232DA94; continue 'dispatch;
	}
	// 8232D8C4: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 8232D8C8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8232D8CC: 396B9A6C  addi r11, r11, -0x6594
	ctx.r[11].s64 = ctx.r[11].s64 + -26004;
	// 8232D8D0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8232D8D4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232D8D8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8232D8DC: 40990018  ble cr6, 0x8232d8f4
	if !ctx.cr[6].gt {
	pc = 0x8232D8F4; continue 'dispatch;
	}
	// 8232D8E0: 480345E1  bl 0x82361ec0
	ctx.lr = 0x8232D8E4;
	sub_82361EC0(ctx, base);
	// 8232D8E4: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 8232D8E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232D8EC: 419A0008  beq cr6, 0x8232d8f4
	if ctx.cr[6].eq {
	pc = 0x8232D8F4; continue 'dispatch;
	}
	// 8232D8F0: 480D86F9  bl 0x82405fe8
	ctx.lr = 0x8232D8F4;
	sub_82405FE8(ctx, base);
	pc = 0x8232D8F4; continue 'dispatch;
            }
            0x8232D8F4 => {
    //   block [0x8232D8F4..0x8232D97C)
	// 8232D8F4: 813F0114  lwz r9, 0x114(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8232D8F8: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 8232D8FC: 811F004C  lwz r8, 0x4c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8232D900: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D904: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8232D908: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 8232D90C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8232D910: E8DF00C8  ld r6, 0xc8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	// 8232D914: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8232D918: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232D91C: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232D920: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232D924: 911F0048  stw r8, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[8].u32 ) };
	// 8232D928: C17F0038  lfs f11, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232D92C: 913F0114  stw r9, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[9].u32 ) };
	// 8232D930: D3DF0044  stfs f30, 0x44(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8232D934: E93F00B0  ld r9, 0xb0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	// 8232D938: D17F0034  stfs f11, 0x34(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232D93C: E91F00B8  ld r8, 0xb8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	// 8232D940: D1BF003C  stfs f13, 0x3c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8232D944: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 8232D948: D3DF000C  stfs f30, 0xc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8232D94C: E8FF00C0  ld r7, 0xc0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	// 8232D950: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 8232D954: F8DF00B8  std r6, 0xb8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 8232D958: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8232D95C: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232D960: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 8232D964: E96A0000  ld r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8232D968: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8232D96C: F8FF00B0  std r7, 0xb0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[7].u64 ) };
	// 8232D970: F97F00C0  std r11, 0xc0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 8232D974: F95F00C8  std r10, 0xc8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[10].u64 ) };
	// 8232D978: 4800011C  b 0x8232da94
	pc = 0x8232DA94; continue 'dispatch;
            }
            0x8232D97C => {
    //   block [0x8232D97C..0x8232D9C8)
	// 8232D97C: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D980: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232D984: EFED073A  fmadds f31, f13, f28, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64);
	// 8232D988: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8232D98C: FF1FD000  fcmpu cr6, f31, f26
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[26].f64);
	// 8232D990: 409900E4  ble cr6, 0x8232da74
	if !ctx.cr[6].gt {
	pc = 0x8232DA74; continue 'dispatch;
	}
	// 8232D994: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232D998: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 8232D99C: 4098002C  bge cr6, 0x8232d9c8
	if !ctx.cr[6].lt {
	pc = 0x8232D9C8; continue 'dispatch;
	}
	// 8232D9A0: EC1FD028  fsubs f0, f31, f26
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[26].f64) as f32) as f64);
	// 8232D9A4: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232D9A8: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232D9AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232D9B0: ED8C06B2  fmuls f12, f12, f26
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[26].f64) as f32) as f64);
	// 8232D9B4: C17F0010  lfs f11, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232D9B8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8232D9BC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232D9C0: EC0062FA  fmadds f0, f0, f11, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 8232D9C4: 480000CC  b 0x8232da90
	pc = 0x8232DA90; continue 'dispatch;
            }
            0x8232D9C8 => {
    //   block [0x8232D9C8..0x8232D9F8)
	// 8232D9C8: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 8232D9CC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8232D9D0: 396B9A6C  addi r11, r11, -0x6594
	ctx.r[11].s64 = ctx.r[11].s64 + -26004;
	// 8232D9D4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8232D9D8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232D9DC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8232D9E0: 40990018  ble cr6, 0x8232d9f8
	if !ctx.cr[6].gt {
	pc = 0x8232D9F8; continue 'dispatch;
	}
	// 8232D9E4: 480344DD  bl 0x82361ec0
	ctx.lr = 0x8232D9E8;
	sub_82361EC0(ctx, base);
	// 8232D9E8: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 8232D9EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232D9F0: 419A0008  beq cr6, 0x8232d9f8
	if ctx.cr[6].eq {
	pc = 0x8232D9F8; continue 'dispatch;
	}
	// 8232D9F4: 480D85F5  bl 0x82405fe8
	ctx.lr = 0x8232D9F8;
	sub_82405FE8(ctx, base);
	pc = 0x8232D9F8; continue 'dispatch;
            }
            0x8232D9F8 => {
    //   block [0x8232D9F8..0x8232DA74)
	// 8232D9F8: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8232D9FC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8232DA00: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 8232DA04: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232DA08: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8232DA0C: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 8232DA10: E8FF00C0  ld r7, 0xc0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	// 8232DA14: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232DA18: E8DF00C8  ld r6, 0xc8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	// 8232DA1C: C19F0028  lfs f12, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232DA20: 913F0048  stw r9, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[9].u32 ) };
	// 8232DA24: C17F0038  lfs f11, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232DA28: E93F00B0  ld r9, 0xb0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	// 8232DA2C: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232DA30: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 8232DA34: D3DF0044  stfs f30, 0x44(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8232DA38: E91F00B8  ld r8, 0xb8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	// 8232DA3C: D17F0034  stfs f11, 0x34(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232DA40: D1BF003C  stfs f13, 0x3c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8232DA44: F8FF00B0  std r7, 0xb0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[7].u64 ) };
	// 8232DA48: D3DF000C  stfs f30, 0xc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8232DA4C: F8DF00B8  std r6, 0xb8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 8232DA50: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8232DA54: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 8232DA58: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232DA5C: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 8232DA60: E96A0000  ld r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8232DA64: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8232DA68: F97F00C0  std r11, 0xc0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 8232DA6C: F95F00C8  std r10, 0xc8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[10].u64 ) };
	// 8232DA70: 48000024  b 0x8232da94
	pc = 0x8232DA94; continue 'dispatch;
            }
            0x8232DA74 => {
    //   block [0x8232DA74..0x8232DA7C)
	// 8232DA74: EC3F06F2  fmuls f1, f31, f27
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[27].f64) as f32) as f64);
	// 8232DA78: 4BDEFA51  bl 0x8211d4c8
	ctx.lr = 0x8232DA7C;
	sub_8211D4C8(ctx, base);
	pc = 0x8232DA7C; continue 'dispatch;
            }
            0x8232DA7C => {
    //   block [0x8232DA7C..0x8232DA8C)
	// 8232DA7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232DA80: C1BF0018  lfs f13, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232DA84: C00B2200  lfs f0, 0x2200(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232DA88: EC01F83C  fnmsubs f0, f1, f0, f31
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	pc = 0x8232DA8C; continue 'dispatch;
            }
            0x8232DA8C => {
    //   block [0x8232DA8C..0x8232DA90)
	// 8232DA8C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x8232DA90; continue 'dispatch;
            }
            0x8232DA90 => {
    //   block [0x8232DA90..0x8232DA94)
	// 8232DA90: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x8232DA94; continue 'dispatch;
            }
            0x8232DA94 => {
    //   block [0x8232DA94..0x8232DB04)
	// 8232DA94: 83DF0048  lwz r30, 0x48(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8232DA98: FD80F090  fmr f12, f30
	ctx.f[12].f64 = ctx.f[30].f64;
	// 8232DA9C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232DAA0: 419A0064  beq cr6, 0x8232db04
	if ctx.cr[6].eq {
	pc = 0x8232DB04; continue 'dispatch;
	}
	// 8232DAA4: C3FF0044  lfs f31, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8232DAA8: C3DF0034  lfs f30, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8232DAAC: EC3F06F2  fmuls f1, f31, f27
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[27].f64) as f32) as f64);
	// 8232DAB0: 4BDEFA19  bl 0x8211d4c8
	ctx.lr = 0x8232DAB4;
	sub_8211D4C8(ctx, base);
	// 8232DAB4: C1BF003C  lfs f13, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232DAB8: EC0DFF3A  fmadds f0, f13, f28, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[28].f64 + ctx.f[31].f64) as f32) as f64);
	// 8232DABC: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8232DAC0: ED8107B2  fmuls f12, f1, f30
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8232DAC4: FD600210  fabs f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 8232DAC8: FF0BE800  fcmpu cr6, f11, f29
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[29].f64);
	// 8232DACC: 40990038  ble cr6, 0x8232db04
	if !ctx.cr[6].gt {
	pc = 0x8232DB04; continue 'dispatch;
	}
	// 8232DAD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232DAD4: ED5E06B2  fmuls f10, f30, f26
	ctx.f[10].f64 = (((ctx.f[30].f64 * ctx.f[26].f64) as f32) as f64);
	// 8232DAD8: 395EFFFF  addi r10, r30, -1
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	// 8232DADC: D15F0034  stfs f10, 0x34(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232DAE0: C16B22E8  lfs f11, 0x22e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8936 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232DAE4: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 8232DAE8: D1BF003C  stfs f13, 0x3c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8232DAEC: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232DAF0: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 8232DAF4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8232DAF8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8232DAFC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232DB00: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	pc = 0x8232DB04; continue 'dispatch;
            }
            0x8232DB04 => {
    //   block [0x8232DB04..0x8232DB80)
	// 8232DB04: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232DB08: 38BF0070  addi r5, r31, 0x70
	ctx.r[5].s64 = ctx.r[31].s64 + 112;
	// 8232DB0C: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 8232DB10: C19F00B0  lfs f12, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232DB14: C17F00B4  lfs f11, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232DB18: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 8232DB1C: C15F00B8  lfs f10, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8232DB20: C13F00C0  lfs f9, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8232DB24: C11F00C4  lfs f8, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8232DB28: C0FF00C8  lfs f7, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8232DB2C: D3A5003C  stfs f29, 0x3c(r5)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8232DB30: EDBD0028  fsubs f13, f29, f0
	ctx.f[13].f64 = (((ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 8232DB34: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232DB38: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232DB3C: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232DB40: EDA9603A  fmadds f13, f9, f0, f12
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8232DB44: D1A50030  stfs f13, 0x30(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232DB48: ED88583A  fmadds f12, f8, f0, f11
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 8232DB4C: D1850034  stfs f12, 0x34(r5)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232DB50: EC07503A  fmadds f0, f7, f0, f10
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 8232DB54: D0050038  stfs f0, 0x38(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8232DB58: 809F0110  lwz r4, 0x110(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 8232DB5C: 4803A1D5  bl 0x82367d30
	ctx.lr = 0x8232DB60;
	sub_82367D30(ctx, base);
	// 8232DB60: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8232DB64: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8232DB68: 482084C5  bl 0x8253602c
	ctx.lr = 0x8232DB6C;
	sub_82535FFC(ctx, base);
	// 8232DB6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232DB70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232DB74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232DB78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232DB7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232DB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232DB80 size=12
    let mut pc: u32 = 0x8232DB80;
    'dispatch: loop {
        match pc {
            0x8232DB80 => {
    //   block [0x8232DB80..0x8232DB8C)
	// 8232DB80: 81630118  lwz r11, 0x118(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) } as u64;
	// 8232DB84: A06B0000  lhz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232DB88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232DB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232DB90 size=276
    let mut pc: u32 = 0x8232DB90;
    'dispatch: loop {
        match pc {
            0x8232DB90 => {
    //   block [0x8232DB90..0x8232DC1C)
	// 8232DB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232DB94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232DB98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232DB9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232DBA0: 89650004  lbz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232DBA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232DBA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232DBAC: 419A00BC  beq cr6, 0x8232dc68
	if ctx.cr[6].eq {
	pc = 0x8232DC68; continue 'dispatch;
	}
	// 8232DBB0: 81650050  lwz r11, 0x50(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232DBB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232DBB8: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8232DBBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232DBC0: 419A00A8  beq cr6, 0x8232dc68
	if ctx.cr[6].eq {
	pc = 0x8232DC68; continue 'dispatch;
	}
	// 8232DBC4: 89650007  lbz r11, 7(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(7 as u32) ) } as u64;
	// 8232DBC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232DBCC: 419A009C  beq cr6, 0x8232dc68
	if ctx.cr[6].eq {
	pc = 0x8232DC68; continue 'dispatch;
	}
	// 8232DBD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8232DBD4: 419A00B8  beq cr6, 0x8232dc8c
	if ctx.cr[6].eq {
	pc = 0x8232DC8C; continue 'dispatch;
	}
	// 8232DBD8: 48000151  bl 0x8232dd28
	ctx.lr = 0x8232DBDC;
	sub_8232DD28(ctx, base);
	// 8232DBDC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232DBE0: 393F003F  addi r9, r31, 0x3f
	ctx.r[9].s64 = ctx.r[31].s64 + 63;
	// 8232DBE4: 394BDB10  addi r10, r11, -0x24f0
	ctx.r[10].s64 = ctx.r[11].s64 + -9456;
	// 8232DBE8: 552B0036  rlwinm r11, r9, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8232DBEC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8232DBF0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8232DBF4: 89450004  lbz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232DBF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232DBFC: 419A0020  beq cr6, 0x8232dc1c
	if ctx.cr[6].eq {
	pc = 0x8232DC1C; continue 'dispatch;
	}
	// 8232DC00: 81450050  lwz r10, 0x50(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232DC04: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232DC08: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8232DC0C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8232DC10: 419A000C  beq cr6, 0x8232dc1c
	if ctx.cr[6].eq {
	pc = 0x8232DC1C; continue 'dispatch;
	}
	// 8232DC14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232DC18: 48000010  b 0x8232dc28
	pc = 0x8232DC28; continue 'dispatch;
            }
            0x8232DC1C => {
    //   block [0x8232DC1C..0x8232DC28)
	// 8232DC1C: A1450008  lhz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232DC20: 554A303E  rotlwi r10, r10, 6
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(6)) as u64;
	// 8232DC24: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x8232DC28; continue 'dispatch;
            }
            0x8232DC28 => {
    //   block [0x8232DC28..0x8232DC50)
	// 8232DC28: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8232DC2C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 8232DC30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232DC34: 4805B86D  bl 0x823894a0
	ctx.lr = 0x8232DC38;
	sub_823894A0(ctx, base);
	// 8232DC38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232DC3C: 907F0028  stw r3, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 8232DC40: 409A0010  bne cr6, 0x8232dc50
	if !ctx.cr[6].eq {
	pc = 0x8232DC50; continue 'dispatch;
	}
	// 8232DC44: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 8232DC48: 816BC8BC  lwz r11, -0x3744(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14148 as u32) ) } as u64;
	// 8232DC4C: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	pc = 0x8232DC50; continue 'dispatch;
            }
            0x8232DC50 => {
    //   block [0x8232DC50..0x8232DC68)
	// 8232DC50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232DC54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232DC58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232DC5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232DC60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232DC64: 4E800020  blr
	return;
            }
            0x8232DC68 => {
    //   block [0x8232DC68..0x8232DC8C)
	// 8232DC68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8232DC6C: 419A0020  beq cr6, 0x8232dc8c
	if ctx.cr[6].eq {
	pc = 0x8232DC8C; continue 'dispatch;
	}
	// 8232DC70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232DC74: 480000B5  bl 0x8232dd28
	ctx.lr = 0x8232DC78;
	sub_8232DD28(ctx, base);
	// 8232DC78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232DC7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232DC80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232DC84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232DC88: 4E800020  blr
	return;
            }
            0x8232DC8C => {
    //   block [0x8232DC8C..0x8232DCA4)
	// 8232DC8C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8232DC90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232DC94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232DC98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232DC9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232DCA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232DCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232DCA8 size=104
    let mut pc: u32 = 0x8232DCA8;
    'dispatch: loop {
        match pc {
            0x8232DCA8 => {
    //   block [0x8232DCA8..0x8232DCD8)
	// 8232DCA8: 89430004  lbz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232DCAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232DCB0: 419A0028  beq cr6, 0x8232dcd8
	if ctx.cr[6].eq {
	pc = 0x8232DCD8; continue 'dispatch;
	}
	// 8232DCB4: 81630050  lwz r11, 0x50(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232DCB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232DCBC: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8232DCC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232DCC4: 419A0014  beq cr6, 0x8232dcd8
	if ctx.cr[6].eq {
	pc = 0x8232DCD8; continue 'dispatch;
	}
	// 8232DCC8: 89630007  lbz r11, 7(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(7 as u32) ) } as u64;
	// 8232DCCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232DCD0: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 8232DCD4: 409A0008  bne cr6, 0x8232dcdc
	if !ctx.cr[6].eq {
	pc = 0x8232DCDC; continue 'dispatch;
	}
	pc = 0x8232DCD8; continue 'dispatch;
            }
            0x8232DCD8 => {
    //   block [0x8232DCD8..0x8232DCDC)
	// 8232DCD8: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	pc = 0x8232DCDC; continue 'dispatch;
            }
            0x8232DCDC => {
    //   block [0x8232DCDC..0x8232DD10)
	// 8232DCDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232DCE0: 419A0030  beq cr6, 0x8232dd10
	if ctx.cr[6].eq {
		sub_8232DD10(ctx, base);
		return;
	}
	// 8232DCE4: 81430050  lwz r10, 0x50(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232DCE8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232DCEC: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8232DCF0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8232DCF4: 419A001C  beq cr6, 0x8232dd10
	if ctx.cr[6].eq {
		sub_8232DD10(ctx, base);
		return;
	}
	// 8232DCF8: A1430008  lhz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232DCFC: 392B000F  addi r9, r11, 0xf
	ctx.r[9].s64 = ctx.r[11].s64 + 15;
	// 8232DD00: 554B303E  rotlwi r11, r10, 6
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(6)) as u64;
	// 8232DD04: 552A0036  rlwinm r10, r9, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8232DD08: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8232DD0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232DD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232DD10 size=24
    let mut pc: u32 = 0x8232DD10;
    'dispatch: loop {
        match pc {
            0x8232DD10 => {
    //   block [0x8232DD10..0x8232DD28)
	// 8232DD10: A1430008  lhz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232DD14: 392B000F  addi r9, r11, 0xf
	ctx.r[9].s64 = ctx.r[11].s64 + 15;
	// 8232DD18: 554B383E  rotlwi r11, r10, 7
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(7)) as u64;
	// 8232DD1C: 552A0036  rlwinm r10, r9, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8232DD20: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8232DD24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232DD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232DD28 size=100
    let mut pc: u32 = 0x8232DD28;
    'dispatch: loop {
        match pc {
            0x8232DD28 => {
    //   block [0x8232DD28..0x8232DD8C)
	// 8232DD28: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232DD2C: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 8232DD30: 3923002F  addi r9, r3, 0x2f
	ctx.r[9].s64 = ctx.r[3].s64 + 47;
	// 8232DD34: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 8232DD38: 394BDAE4  addi r10, r11, -0x251c
	ctx.r[10].s64 = ctx.r[11].s64 + -9500;
	// 8232DD3C: 552B0036  rlwinm r11, r9, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8232DD40: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8232DD44: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8232DD48: F9230018  std r9, 0x18(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[9].u64 ) };
	// 8232DD4C: A145000A  lhz r10, 0xa(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(10 as u32) ) } as u64;
	// 8232DD50: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 8232DD54: B143000C  sth r10, 0xc(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u16 ) };
	// 8232DD58: A1450008  lhz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232DD5C: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8232DD60: B143000E  sth r10, 0xe(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(14 as u32), ctx.r[10].u16 ) };
	// 8232DD64: 89450004  lbz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232DD68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232DD6C: 419A0020  beq cr6, 0x8232dd8c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8232DD8C);
		return;
	}
	// 8232DD70: 81450050  lwz r10, 0x50(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232DD74: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232DD78: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8232DD7C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8232DD80: 419A000C  beq cr6, 0x8232dd8c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8232DD8C);
		return;
	}
	// 8232DD84: 91230014  stw r9, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8232DD88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232DDA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232DDA8 size=112
    let mut pc: u32 = 0x8232DDA8;
    'dispatch: loop {
        match pc {
            0x8232DDA8 => {
    //   block [0x8232DDA8..0x8232DE08)
	// 8232DDA8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232DDAC: 396BDAE4  addi r11, r11, -0x251c
	ctx.r[11].s64 = ctx.r[11].s64 + -9500;
	// 8232DDB0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232DDB4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 8232DDB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232DDBC: 419A004C  beq cr6, 0x8232de08
	if ctx.cr[6].eq {
	pc = 0x8232DE08; continue 'dispatch;
	}
	// 8232DDC0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232DDC4: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8232DDC8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8232DDCC: 409A003C  bne cr6, 0x8232de08
	if !ctx.cr[6].eq {
	pc = 0x8232DE08; continue 'dispatch;
	}
	// 8232DDD0: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 8232DDD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232DDD8: 419A0030  beq cr6, 0x8232de08
	if ctx.cr[6].eq {
	pc = 0x8232DE08; continue 'dispatch;
	}
	// 8232DDDC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232DDE0: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8232DDE4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232DDE8: 409A0020  bne cr6, 0x8232de08
	if !ctx.cr[6].eq {
	pc = 0x8232DE08; continue 'dispatch;
	}
	// 8232DDEC: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 8232DDF0: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8232DDF4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8232DDF8: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 8232DDFC: 610A8000  ori r10, r8, 0x8000
	ctx.r[10].u64 = ctx.r[8].u64 | 32768;
	// 8232DE00: 992B0025  stb r9, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[9].u8 ) };
	// 8232DE04: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x8232DE08; continue 'dispatch;
            }
            0x8232DE08 => {
    //   block [0x8232DE08..0x8232DE18)
	// 8232DE08: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232DE0C: 396B3BF8  addi r11, r11, 0x3bf8
	ctx.r[11].s64 = ctx.r[11].s64 + 15352;
	// 8232DE10: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232DE14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232DE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232DE18 size=16
    let mut pc: u32 = 0x8232DE18;
    'dispatch: loop {
        match pc {
            0x8232DE18 => {
    //   block [0x8232DE18..0x8232DE28)
	// 8232DE18: A163000E  lhz r11, 0xe(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(14 as u32) ) } as u64;
	// 8232DE1C: 556B303E  rotlwi r11, r11, 6
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(6)) as u64;
	// 8232DE20: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 8232DE24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232DE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232DE28 size=48
    let mut pc: u32 = 0x8232DE28;
    'dispatch: loop {
        match pc {
            0x8232DE28 => {
    //   block [0x8232DE28..0x8232DE58)
	// 8232DE28: A143000C  lhz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8232DE2C: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 8232DE30: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232DE34: 396BB670  addi r11, r11, -0x4990
	ctx.r[11].s64 = ctx.r[11].s64 + -18832;
	// 8232DE38: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 8232DE3C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 8232DE40: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 8232DE44: A163000C  lhz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8232DE48: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8232DE4C: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 8232DE50: 7D4B412E  stwx r10, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 8232DE54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232DE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232DE58 size=680
    let mut pc: u32 = 0x8232DE58;
    'dispatch: loop {
        match pc {
            0x8232DE58 => {
    //   block [0x8232DE58..0x8232DEBC)
	// 8232DE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232DE5C: 4820725D  bl 0x825350b8
	ctx.lr = 0x8232DE60;
	sub_82535080(ctx, base);
	// 8232DE60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232DE64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232DE68: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8232DE6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232DE70: 419A004C  beq cr6, 0x8232debc
	if ctx.cr[6].eq {
	pc = 0x8232DEBC; continue 'dispatch;
	}
	// 8232DE74: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232DE78: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8232DE7C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8232DE80: 409A003C  bne cr6, 0x8232debc
	if !ctx.cr[6].eq {
	pc = 0x8232DEBC; continue 'dispatch;
	}
	// 8232DE84: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8232DE88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232DE8C: 419A0030  beq cr6, 0x8232debc
	if ctx.cr[6].eq {
	pc = 0x8232DEBC; continue 'dispatch;
	}
	// 8232DE90: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232DE94: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8232DE98: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232DE9C: 409A0020  bne cr6, 0x8232debc
	if !ctx.cr[6].eq {
	pc = 0x8232DEBC; continue 'dispatch;
	}
	// 8232DEA0: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 8232DEA4: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8232DEA8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8232DEAC: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 8232DEB0: 610A8000  ori r10, r8, 0x8000
	ctx.r[10].u64 = ctx.r[8].u64 | 32768;
	// 8232DEB4: 992B0025  stb r9, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[9].u8 ) };
	// 8232DEB8: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x8232DEBC; continue 'dispatch;
            }
            0x8232DEBC => {
    //   block [0x8232DEBC..0x8232DF20)
	// 8232DEBC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232DEC0: 892B0004  lbz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232DEC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8232DEC8: 419A01A0  beq cr6, 0x8232e068
	if ctx.cr[6].eq {
	pc = 0x8232E068; continue 'dispatch;
	}
	// 8232DECC: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232DED0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232DED4: 5548077A  rlwinm r8, r10, 0, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8232DED8: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8232DEDC: 419A0100  beq cr6, 0x8232dfdc
	if ctx.cr[6].eq {
	pc = 0x8232DFDC; continue 'dispatch;
	}
	// 8232DEE0: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8232DEE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8232DEE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232DEEC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232DEF0: 38A00300  li r5, 0x300
	ctx.r[5].s64 = 768;
	// 8232DEF4: 38EB1160  addi r7, r11, 0x1160
	ctx.r[7].s64 = ctx.r[11].s64 + 4448;
	// 8232DEF8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232DEFC: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8232DF00: 419A005C  beq cr6, 0x8232df5c
	if ctx.cr[6].eq {
	pc = 0x8232DF5C; continue 'dispatch;
	}
	// 8232DF04: 386003B0  li r3, 0x3b0
	ctx.r[3].s64 = 944;
	// 8232DF08: 4803C589  bl 0x8236a490
	ctx.lr = 0x8232DF0C;
	sub_8236A490(ctx, base);
	// 8232DF0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8232DF10: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232DF14: 419A000C  beq cr6, 0x8232df20
	if ctx.cr[6].eq {
	pc = 0x8232DF20; continue 'dispatch;
	}
	// 8232DF18: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232DF1C: 48000008  b 0x8232df24
	pc = 0x8232DF24; continue 'dispatch;
            }
            0x8232DF20 => {
    //   block [0x8232DF20..0x8232DF24)
	// 8232DF20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8232DF24; continue 'dispatch;
            }
            0x8232DF24 => {
    //   block [0x8232DF24..0x8232DF5C)
	// 8232DF24: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232DF28: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8232DF2C: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 8232DF30: 419A01C8  beq cr6, 0x8232e0f8
	if ctx.cr[6].eq {
	pc = 0x8232E0F8; continue 'dispatch;
	}
	// 8232DF34: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8232DF38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232DF3C: 4805B565  bl 0x823894a0
	ctx.lr = 0x8232DF40;
	sub_823894A0(ctx, base);
	// 8232DF40: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8232DF44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8232DF48: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232DF4C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232DF50: 48000C39  bl 0x8232eb88
	ctx.lr = 0x8232DF54;
	sub_8232EB88(ctx, base);
	// 8232DF54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232DF58: 482071B0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8232DF5C => {
    //   block [0x8232DF5C..0x8232DF78)
	// 8232DF5C: 386003C0  li r3, 0x3c0
	ctx.r[3].s64 = 960;
	// 8232DF60: 4803C531  bl 0x8236a490
	ctx.lr = 0x8232DF64;
	sub_8236A490(ctx, base);
	// 8232DF64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8232DF68: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232DF6C: 419A000C  beq cr6, 0x8232df78
	if ctx.cr[6].eq {
	pc = 0x8232DF78; continue 'dispatch;
	}
	// 8232DF70: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232DF74: 48000008  b 0x8232df7c
	pc = 0x8232DF7C; continue 'dispatch;
            }
            0x8232DF78 => {
    //   block [0x8232DF78..0x8232DF7C)
	// 8232DF78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8232DF7C; continue 'dispatch;
            }
            0x8232DF7C => {
    //   block [0x8232DF7C..0x8232DFDC)
	// 8232DF7C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232DF80: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8232DF84: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 8232DF88: 419A0170  beq cr6, 0x8232e0f8
	if ctx.cr[6].eq {
	pc = 0x8232E0F8; continue 'dispatch;
	}
	// 8232DF8C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8232DF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232DF94: 4805B50D  bl 0x823894a0
	ctx.lr = 0x8232DF98;
	sub_823894A0(ctx, base);
	// 8232DF98: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232DF9C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8232DFA0: 839F0014  lwz r28, 0x14(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8232DFA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8232DFA8: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232DFAC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8232DFB0: 48000BD9  bl 0x8232eb88
	ctx.lr = 0x8232DFB4;
	sub_8232EB88(ctx, base);
	// 8232DFB4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232DFB8: 939E03B4  stw r28, 0x3b4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(948 as u32), ctx.r[28].u32 ) };
	// 8232DFBC: 396BDBBC  addi r11, r11, -0x2444
	ctx.r[11].s64 = ctx.r[11].s64 + -9284;
	// 8232DFC0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232DFC4: A17D0008  lhz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232DFC8: 917E03B0  stw r11, 0x3b0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(944 as u32), ctx.r[11].u32 ) };
	// 8232DFCC: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 8232DFD0: 917E03B8  stw r11, 0x3b8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(952 as u32), ctx.r[11].u32 ) };
	// 8232DFD4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232DFD8: 48207130  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8232DFDC => {
    //   block [0x8232DFDC..0x8232E02C)
	// 8232DFDC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8232DFE0: 419A0088  beq cr6, 0x8232e068
	if ctx.cr[6].eq {
	pc = 0x8232E068; continue 'dispatch;
	}
	// 8232DFE4: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232DFE8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232DFEC: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8232DFF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232DFF4: 419A0074  beq cr6, 0x8232e068
	if ctx.cr[6].eq {
	pc = 0x8232E068; continue 'dispatch;
	}
	// 8232DFF8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232DFFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8232E000: 38EB1160  addi r7, r11, 0x1160
	ctx.r[7].s64 = ctx.r[11].s64 + 4448;
	// 8232E004: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232E008: 38A00300  li r5, 0x300
	ctx.r[5].s64 = 768;
	// 8232E00C: 38600390  li r3, 0x390
	ctx.r[3].s64 = 912;
	// 8232E010: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8232E014: 4803C47D  bl 0x8236a490
	ctx.lr = 0x8232E018;
	sub_8236A490(ctx, base);
	// 8232E018: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8232E01C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232E020: 419A000C  beq cr6, 0x8232e02c
	if ctx.cr[6].eq {
	pc = 0x8232E02C; continue 'dispatch;
	}
	// 8232E024: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232E028: 48000008  b 0x8232e030
	pc = 0x8232E030; continue 'dispatch;
            }
            0x8232E02C => {
    //   block [0x8232E02C..0x8232E030)
	// 8232E02C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8232E030; continue 'dispatch;
            }
            0x8232E030 => {
    //   block [0x8232E030..0x8232E068)
	// 8232E030: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232E034: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8232E038: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 8232E03C: 419A00BC  beq cr6, 0x8232e0f8
	if ctx.cr[6].eq {
	pc = 0x8232E0F8; continue 'dispatch;
	}
	// 8232E040: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8232E044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232E048: 4805B459  bl 0x823894a0
	ctx.lr = 0x8232E04C;
	sub_823894A0(ctx, base);
	// 8232E04C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8232E050: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8232E054: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232E058: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232E05C: 480004D5  bl 0x8232e530
	ctx.lr = 0x8232E060;
	sub_8232E530(ctx, base);
	// 8232E060: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232E064: 482070A4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8232E068 => {
    //   block [0x8232E068..0x8232E09C)
	// 8232E068: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232E06C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8232E070: 38EB1160  addi r7, r11, 0x1160
	ctx.r[7].s64 = ctx.r[11].s64 + 4448;
	// 8232E074: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232E078: 38A00300  li r5, 0x300
	ctx.r[5].s64 = 768;
	// 8232E07C: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 8232E080: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8232E084: 4803C40D  bl 0x8236a490
	ctx.lr = 0x8232E088;
	sub_8236A490(ctx, base);
	// 8232E088: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8232E08C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232E090: 419A000C  beq cr6, 0x8232e09c
	if ctx.cr[6].eq {
	pc = 0x8232E09C; continue 'dispatch;
	}
	// 8232E094: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232E098: 48000008  b 0x8232e0a0
	pc = 0x8232E0A0; continue 'dispatch;
            }
            0x8232E09C => {
    //   block [0x8232E09C..0x8232E0A0)
	// 8232E09C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8232E0A0; continue 'dispatch;
            }
            0x8232E0A0 => {
    //   block [0x8232E0A0..0x8232E0F8)
	// 8232E0A0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232E0A4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8232E0A8: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 8232E0AC: 419A004C  beq cr6, 0x8232e0f8
	if ctx.cr[6].eq {
	pc = 0x8232E0F8; continue 'dispatch;
	}
	// 8232E0B0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8232E0B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232E0B8: 4805B3E9  bl 0x823894a0
	ctx.lr = 0x8232E0BC;
	sub_823894A0(ctx, base);
	// 8232E0BC: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232E0C0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8232E0C4: 839F0014  lwz r28, 0x14(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8232E0C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8232E0CC: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232E0D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8232E0D4: 4800045D  bl 0x8232e530
	ctx.lr = 0x8232E0D8;
	sub_8232E530(ctx, base);
	// 8232E0D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232E0DC: 939E0394  stw r28, 0x394(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(916 as u32), ctx.r[28].u32 ) };
	// 8232E0E0: 396BDBDC  addi r11, r11, -0x2424
	ctx.r[11].s64 = ctx.r[11].s64 + -9252;
	// 8232E0E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232E0E8: A17D0008  lhz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232E0EC: 917E0390  stw r11, 0x390(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 8232E0F0: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 8232E0F4: 917E0398  stw r11, 0x398(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	pc = 0x8232E0F8; continue 'dispatch;
            }
            0x8232E0F8 => {
    //   block [0x8232E0F8..0x8232E100)
	// 8232E0F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232E0FC: 4820700C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232E100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232E100 size=64
    let mut pc: u32 = 0x8232E100;
    'dispatch: loop {
        match pc {
            0x8232E100 => {
    //   block [0x8232E100..0x8232E12C)
	// 8232E100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232E104: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232E108: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232E10C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232E110: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232E114: 4BFFFC95  bl 0x8232dda8
	ctx.lr = 0x8232E118;
	sub_8232DDA8(ctx, base);
	// 8232E118: 548B07FE  clrlwi r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 8232E11C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232E120: 419A000C  beq cr6, 0x8232e12c
	if ctx.cr[6].eq {
	pc = 0x8232E12C; continue 'dispatch;
	}
	// 8232E124: 48204A95  bl 0x82532bb8
	ctx.lr = 0x8232E128;
	sub_82532BB8(ctx, base);
	// 8232E128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8232E12C; continue 'dispatch;
            }
            0x8232E12C => {
    //   block [0x8232E12C..0x8232E140)
	// 8232E12C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232E130: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232E134: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232E138: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232E13C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232E140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232E140 size=16
    let mut pc: u32 = 0x8232E140;
    'dispatch: loop {
        match pc {
            0x8232E140 => {
    //   block [0x8232E140..0x8232E150)
	// 8232E140: A163000E  lhz r11, 0xe(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(14 as u32) ) } as u64;
	// 8232E144: 556B303E  rotlwi r11, r11, 6
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(6)) as u64;
	// 8232E148: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 8232E14C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232E150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8232E150 size=68
    let mut pc: u32 = 0x8232E150;
    'dispatch: loop {
        match pc {
            0x8232E150 => {
    //   block [0x8232E150..0x8232E194)
	// 8232E150: A143000C  lhz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8232E154: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 8232E158: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232E15C: 396BB670  addi r11, r11, -0x4990
	ctx.r[11].s64 = ctx.r[11].s64 + -18832;
	// 8232E160: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 8232E164: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 8232E168: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 8232E16C: A163000C  lhz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8232E170: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8232E174: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 8232E178: 7D4B412E  stwx r10, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 8232E17C: C0030020  lfs f0, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232E180: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 8232E184: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232E188: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232E18C: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8232E190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232E198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232E198 size=920
    let mut pc: u32 = 0x8232E198;
    'dispatch: loop {
        match pc {
            0x8232E198 => {
    //   block [0x8232E198..0x8232E1FC)
	// 8232E198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232E19C: 48206F1D  bl 0x825350b8
	ctx.lr = 0x8232E1A0;
	sub_82535080(ctx, base);
	// 8232E1A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232E1A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232E1A8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8232E1AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232E1B0: 419A004C  beq cr6, 0x8232e1fc
	if ctx.cr[6].eq {
	pc = 0x8232E1FC; continue 'dispatch;
	}
	// 8232E1B4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232E1B8: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8232E1BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8232E1C0: 409A003C  bne cr6, 0x8232e1fc
	if !ctx.cr[6].eq {
	pc = 0x8232E1FC; continue 'dispatch;
	}
	// 8232E1C4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8232E1C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232E1CC: 419A0030  beq cr6, 0x8232e1fc
	if ctx.cr[6].eq {
	pc = 0x8232E1FC; continue 'dispatch;
	}
	// 8232E1D0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232E1D4: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8232E1D8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232E1DC: 409A0020  bne cr6, 0x8232e1fc
	if !ctx.cr[6].eq {
	pc = 0x8232E1FC; continue 'dispatch;
	}
	// 8232E1E0: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 8232E1E4: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8232E1E8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8232E1EC: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 8232E1F0: 610A8000  ori r10, r8, 0x8000
	ctx.r[10].u64 = ctx.r[8].u64 | 32768;
	// 8232E1F4: 992B0025  stb r9, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[9].u8 ) };
	// 8232E1F8: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x8232E1FC; continue 'dispatch;
            }
            0x8232E1FC => {
    //   block [0x8232E1FC..0x8232E260)
	// 8232E1FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232E200: 892B0004  lbz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232E204: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8232E208: 419A0254  beq cr6, 0x8232e45c
	if ctx.cr[6].eq {
	pc = 0x8232E45C; continue 'dispatch;
	}
	// 8232E20C: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232E210: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232E214: 5548077A  rlwinm r8, r10, 0, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8232E218: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8232E21C: 419A0178  beq cr6, 0x8232e394
	if ctx.cr[6].eq {
	pc = 0x8232E394; continue 'dispatch;
	}
	// 8232E220: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8232E224: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8232E228: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232E22C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232E230: 38A00300  li r5, 0x300
	ctx.r[5].s64 = 768;
	// 8232E234: 38EB1160  addi r7, r11, 0x1160
	ctx.r[7].s64 = ctx.r[11].s64 + 4448;
	// 8232E238: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232E23C: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8232E240: 419A0098  beq cr6, 0x8232e2d8
	if ctx.cr[6].eq {
	pc = 0x8232E2D8; continue 'dispatch;
	}
	// 8232E244: 386003D0  li r3, 0x3d0
	ctx.r[3].s64 = 976;
	// 8232E248: 4803C249  bl 0x8236a490
	ctx.lr = 0x8232E24C;
	sub_8236A490(ctx, base);
	// 8232E24C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8232E250: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232E254: 419A000C  beq cr6, 0x8232e260
	if ctx.cr[6].eq {
	pc = 0x8232E260; continue 'dispatch;
	}
	// 8232E258: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232E25C: 48000008  b 0x8232e264
	pc = 0x8232E264; continue 'dispatch;
            }
            0x8232E260 => {
    //   block [0x8232E260..0x8232E264)
	// 8232E260: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8232E264; continue 'dispatch;
            }
            0x8232E264 => {
    //   block [0x8232E264..0x8232E2D8)
	// 8232E264: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232E268: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8232E26C: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 8232E270: 419A02B8  beq cr6, 0x8232e528
	if ctx.cr[6].eq {
	pc = 0x8232E528; continue 'dispatch;
	}
	// 8232E274: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8232E278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232E27C: 4805B225  bl 0x823894a0
	ctx.lr = 0x8232E280;
	sub_823894A0(ctx, base);
	// 8232E280: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232E284: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8232E288: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232E28C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8232E290: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8232E294: 480008F5  bl 0x8232eb88
	ctx.lr = 0x8232E298;
	sub_8232EB88(ctx, base);
	// 8232E298: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232E29C: 393F0020  addi r9, r31, 0x20
	ctx.r[9].s64 = ctx.r[31].s64 + 32;
	// 8232E2A0: 394BDB9C  addi r10, r11, -0x2464
	ctx.r[10].s64 = ctx.r[11].s64 + -9316;
	// 8232E2A4: 397E03C0  addi r11, r30, 0x3c0
	ctx.r[11].s64 = ctx.r[30].s64 + 960;
	// 8232E2A8: 913E03B0  stw r9, 0x3b0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(944 as u32), ctx.r[9].u32 ) };
	// 8232E2AC: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8232E2B0: 815D005C  lwz r10, 0x5c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 8232E2B4: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8232E2B8: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8232E2BC: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8232E2C0: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 8232E2C4: 817D005C  lwz r11, 0x5c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 8232E2C8: C00B0020  lfs f0, 0x20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232E2CC: D01E03CC  stfs f0, 0x3cc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(972 as u32), tmp.u32 ) };
	// 8232E2D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232E2D4: 48206E34  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8232E2D8 => {
    //   block [0x8232E2D8..0x8232E2F4)
	// 8232E2D8: 386003E0  li r3, 0x3e0
	ctx.r[3].s64 = 992;
	// 8232E2DC: 4803C1B5  bl 0x8236a490
	ctx.lr = 0x8232E2E0;
	sub_8236A490(ctx, base);
	// 8232E2E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8232E2E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232E2E8: 419A000C  beq cr6, 0x8232e2f4
	if ctx.cr[6].eq {
	pc = 0x8232E2F4; continue 'dispatch;
	}
	// 8232E2EC: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232E2F0: 48000008  b 0x8232e2f8
	pc = 0x8232E2F8; continue 'dispatch;
            }
            0x8232E2F4 => {
    //   block [0x8232E2F4..0x8232E2F8)
	// 8232E2F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8232E2F8; continue 'dispatch;
            }
            0x8232E2F8 => {
    //   block [0x8232E2F8..0x8232E394)
	// 8232E2F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232E2FC: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8232E300: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 8232E304: 419A0224  beq cr6, 0x8232e528
	if ctx.cr[6].eq {
	pc = 0x8232E528; continue 'dispatch;
	}
	// 8232E308: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8232E30C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232E310: 4805B191  bl 0x823894a0
	ctx.lr = 0x8232E314;
	sub_823894A0(ctx, base);
	// 8232E314: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232E318: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8232E31C: 839F0014  lwz r28, 0x14(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8232E320: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8232E324: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232E328: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8232E32C: 4800085D  bl 0x8232eb88
	ctx.lr = 0x8232E330;
	sub_8232EB88(ctx, base);
	// 8232E330: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232E334: 391F0020  addi r8, r31, 0x20
	ctx.r[8].s64 = ctx.r[31].s64 + 32;
	// 8232E338: 394BDB9C  addi r10, r11, -0x2464
	ctx.r[10].s64 = ctx.r[11].s64 + -9316;
	// 8232E33C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232E340: 38FE03C0  addi r7, r30, 0x3c0
	ctx.r[7].s64 = ctx.r[30].s64 + 960;
	// 8232E344: 392BDBFC  addi r9, r11, -0x2404
	ctx.r[9].s64 = ctx.r[11].s64 + -9220;
	// 8232E348: 911E03B0  stw r8, 0x3b0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(944 as u32), ctx.r[8].u32 ) };
	// 8232E34C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 8232E350: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8232E354: 815D005C  lwz r10, 0x5c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 8232E358: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8232E35C: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 8232E360: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8232E364: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 8232E368: 817D005C  lwz r11, 0x5c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 8232E36C: C00B0020  lfs f0, 0x20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232E370: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8232E374: D01E03CC  stfs f0, 0x3cc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(972 as u32), tmp.u32 ) };
	// 8232E378: 939E03D4  stw r28, 0x3d4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(980 as u32), ctx.r[28].u32 ) };
	// 8232E37C: A17D0008  lhz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232E380: 917E03D0  stw r11, 0x3d0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(976 as u32), ctx.r[11].u32 ) };
	// 8232E384: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 8232E388: 917E03D8  stw r11, 0x3d8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(984 as u32), ctx.r[11].u32 ) };
	// 8232E38C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232E390: 48206D78  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8232E394 => {
    //   block [0x8232E394..0x8232E3E4)
	// 8232E394: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8232E398: 419A00C4  beq cr6, 0x8232e45c
	if ctx.cr[6].eq {
	pc = 0x8232E45C; continue 'dispatch;
	}
	// 8232E39C: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232E3A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232E3A4: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8232E3A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232E3AC: 419A00B0  beq cr6, 0x8232e45c
	if ctx.cr[6].eq {
	pc = 0x8232E45C; continue 'dispatch;
	}
	// 8232E3B0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232E3B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8232E3B8: 38EB1160  addi r7, r11, 0x1160
	ctx.r[7].s64 = ctx.r[11].s64 + 4448;
	// 8232E3BC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232E3C0: 38A00300  li r5, 0x300
	ctx.r[5].s64 = 768;
	// 8232E3C4: 386003B0  li r3, 0x3b0
	ctx.r[3].s64 = 944;
	// 8232E3C8: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8232E3CC: 4803C0C5  bl 0x8236a490
	ctx.lr = 0x8232E3D0;
	sub_8236A490(ctx, base);
	// 8232E3D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8232E3D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232E3D8: 419A000C  beq cr6, 0x8232e3e4
	if ctx.cr[6].eq {
	pc = 0x8232E3E4; continue 'dispatch;
	}
	// 8232E3DC: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232E3E0: 48000008  b 0x8232e3e8
	pc = 0x8232E3E8; continue 'dispatch;
            }
            0x8232E3E4 => {
    //   block [0x8232E3E4..0x8232E3E8)
	// 8232E3E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8232E3E8; continue 'dispatch;
            }
            0x8232E3E8 => {
    //   block [0x8232E3E8..0x8232E45C)
	// 8232E3E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232E3EC: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8232E3F0: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 8232E3F4: 419A0134  beq cr6, 0x8232e528
	if ctx.cr[6].eq {
	pc = 0x8232E528; continue 'dispatch;
	}
	// 8232E3F8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8232E3FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232E400: 4805B0A1  bl 0x823894a0
	ctx.lr = 0x8232E404;
	sub_823894A0(ctx, base);
	// 8232E404: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232E408: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8232E40C: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232E410: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8232E414: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8232E418: 48000119  bl 0x8232e530
	ctx.lr = 0x8232E41C;
	sub_8232E530(ctx, base);
	// 8232E41C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232E420: 393F0020  addi r9, r31, 0x20
	ctx.r[9].s64 = ctx.r[31].s64 + 32;
	// 8232E424: 394BDB5C  addi r10, r11, -0x24a4
	ctx.r[10].s64 = ctx.r[11].s64 + -9380;
	// 8232E428: 397E03A0  addi r11, r30, 0x3a0
	ctx.r[11].s64 = ctx.r[30].s64 + 928;
	// 8232E42C: 913E0390  stw r9, 0x390(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(912 as u32), ctx.r[9].u32 ) };
	// 8232E430: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8232E434: 815D005C  lwz r10, 0x5c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 8232E438: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8232E43C: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8232E440: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8232E444: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 8232E448: 817D005C  lwz r11, 0x5c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 8232E44C: C00B0020  lfs f0, 0x20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232E450: D01E03AC  stfs f0, 0x3ac(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(940 as u32), tmp.u32 ) };
	// 8232E454: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232E458: 48206CB0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8232E45C => {
    //   block [0x8232E45C..0x8232E490)
	// 8232E45C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232E460: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8232E464: 38EB1160  addi r7, r11, 0x1160
	ctx.r[7].s64 = ctx.r[11].s64 + 4448;
	// 8232E468: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232E46C: 38A00300  li r5, 0x300
	ctx.r[5].s64 = 768;
	// 8232E470: 386003C0  li r3, 0x3c0
	ctx.r[3].s64 = 960;
	// 8232E474: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8232E478: 4803C019  bl 0x8236a490
	ctx.lr = 0x8232E47C;
	sub_8236A490(ctx, base);
	// 8232E47C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8232E480: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232E484: 419A000C  beq cr6, 0x8232e490
	if ctx.cr[6].eq {
	pc = 0x8232E490; continue 'dispatch;
	}
	// 8232E488: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8232E48C: 48000008  b 0x8232e494
	pc = 0x8232E494; continue 'dispatch;
            }
            0x8232E490 => {
    //   block [0x8232E490..0x8232E494)
	// 8232E490: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8232E494; continue 'dispatch;
            }
            0x8232E494 => {
    //   block [0x8232E494..0x8232E528)
	// 8232E494: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232E498: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8232E49C: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 8232E4A0: 419A0088  beq cr6, 0x8232e528
	if ctx.cr[6].eq {
	pc = 0x8232E528; continue 'dispatch;
	}
	// 8232E4A4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8232E4A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232E4AC: 4805AFF5  bl 0x823894a0
	ctx.lr = 0x8232E4B0;
	sub_823894A0(ctx, base);
	// 8232E4B0: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232E4B4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8232E4B8: 839F0014  lwz r28, 0x14(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8232E4BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8232E4C0: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8232E4C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8232E4C8: 48000069  bl 0x8232e530
	ctx.lr = 0x8232E4CC;
	sub_8232E530(ctx, base);
	// 8232E4CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232E4D0: 391F0020  addi r8, r31, 0x20
	ctx.r[8].s64 = ctx.r[31].s64 + 32;
	// 8232E4D4: 394BDB5C  addi r10, r11, -0x24a4
	ctx.r[10].s64 = ctx.r[11].s64 + -9380;
	// 8232E4D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232E4DC: 38FE03A0  addi r7, r30, 0x3a0
	ctx.r[7].s64 = ctx.r[30].s64 + 928;
	// 8232E4E0: 392BDC1C  addi r9, r11, -0x23e4
	ctx.r[9].s64 = ctx.r[11].s64 + -9188;
	// 8232E4E4: 911E0390  stw r8, 0x390(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(912 as u32), ctx.r[8].u32 ) };
	// 8232E4E8: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 8232E4EC: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8232E4F0: 815D005C  lwz r10, 0x5c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 8232E4F4: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8232E4F8: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 8232E4FC: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8232E500: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 8232E504: 817D005C  lwz r11, 0x5c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 8232E508: C00B0020  lfs f0, 0x20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232E50C: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8232E510: D01E03AC  stfs f0, 0x3ac(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(940 as u32), tmp.u32 ) };
	// 8232E514: 939E03B4  stw r28, 0x3b4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(948 as u32), ctx.r[28].u32 ) };
	// 8232E518: A17D0008  lhz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232E51C: 917E03B0  stw r11, 0x3b0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(944 as u32), ctx.r[11].u32 ) };
	// 8232E520: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 8232E524: 917E03B8  stw r11, 0x3b8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(952 as u32), ctx.r[11].u32 ) };
	pc = 0x8232E528; continue 'dispatch;
            }
            0x8232E528 => {
    //   block [0x8232E528..0x8232E530)
	// 8232E528: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232E52C: 48206BDC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232E530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232E530 size=504
    let mut pc: u32 = 0x8232E530;
    'dispatch: loop {
        match pc {
            0x8232E530 => {
    //   block [0x8232E530..0x8232E728)
	// 8232E530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232E534: 48206B85  bl 0x825350b8
	ctx.lr = 0x8232E538;
	sub_82535080(ctx, base);
	// 8232E538: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8232E53C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232E540: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232E544: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8232E548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232E54C: 396BDB3C  addi r11, r11, -0x24c4
	ctx.r[11].s64 = ctx.r[11].s64 + -9412;
	// 8232E550: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232E554: 3BDF00E0  addi r30, r31, 0xe0
	ctx.r[30].s64 = ctx.r[31].s64 + 224;
	// 8232E558: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8232E55C: 90BF00D0  stw r5, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[5].u32 ) };
	// 8232E560: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8232E564: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232E568: 3D603F80  lis r11, 0x3f80
	ctx.r[11].s64 = 1065353216;
	// 8232E56C: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8232E570: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8232E574: 90DF00D4  stw r6, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[6].u32 ) };
	// 8232E578: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 8232E57C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 8232E580: D3FE029C  stfs f31, 0x29c(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 8232E584: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8232E588: 939E0294  stw r28, 0x294(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(660 as u32), ctx.r[28].u32 ) };
	// 8232E58C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8232E590: 939E0298  stw r28, 0x298(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(664 as u32), ctx.r[28].u32 ) };
	// 8232E594: 394A4634  addi r10, r10, 0x4634
	ctx.r[10].s64 = ctx.r[10].s64 + 17972;
	// 8232E598: 397E0250  addi r11, r30, 0x250
	ctx.r[11].s64 = ctx.r[30].s64 + 592;
	// 8232E59C: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8232E5A0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8232E5A4: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8232E5A8: 915E0290  stw r10, 0x290(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(656 as u32), ctx.r[10].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232E728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232E728 size=332
    let mut pc: u32 = 0x8232E728;
    'dispatch: loop {
        match pc {
            0x8232E728 => {
    //   block [0x8232E728..0x8232E754)
	// 8232E728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232E72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232E730: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232E734: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232E738: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232E73C: 809F00D4  lwz r4, 0xd4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 8232E740: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8232E744: 419A0010  beq cr6, 0x8232e754
	if ctx.cr[6].eq {
	pc = 0x8232E754; continue 'dispatch;
	}
	// 8232E748: 38BF0080  addi r5, r31, 0x80
	ctx.r[5].s64 = ctx.r[31].s64 + 128;
	// 8232E74C: 387F0330  addi r3, r31, 0x330
	ctx.r[3].s64 = ctx.r[31].s64 + 816;
	// 8232E750: 480395E1  bl 0x82367d30
	ctx.lr = 0x8232E754;
	sub_82367D30(ctx, base);
	pc = 0x8232E754; continue 'dispatch;
            }
            0x8232E754 => {
    //   block [0x8232E754..0x8232E778)
	// 8232E754: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 8232E758: C01F00C4  lfs f0, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232E75C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8232E760: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8232E764: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8232E768: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8232E76C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8232E770: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232E774: 419800AC  blt cr6, 0x8232e820
	if ctx.cr[6].lt {
	pc = 0x8232E820; continue 'dispatch;
	}
	pc = 0x8232E778; continue 'dispatch;
            }
            0x8232E778 => {
    //   block [0x8232E778..0x8232E7AC)
	// 8232E778: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232E77C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232E780: 4098FFF8  bge cr6, 0x8232e778
	if !ctx.cr[6].lt {
	pc = 0x8232E778; continue 'dispatch;
	}
	// 8232E784: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8232E788: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8232E78C: 815F0374  lwz r10, 0x374(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 8232E790: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8232E794: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8232E798: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 8232E79C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232E7A0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8232E7A4: 41980008  blt cr6, 0x8232e7ac
	if ctx.cr[6].lt {
	pc = 0x8232E7AC; continue 'dispatch;
	}
	// 8232E7A8: 913F00C0  stw r9, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	pc = 0x8232E7AC; continue 'dispatch;
            }
            0x8232E7AC => {
    //   block [0x8232E7AC..0x8232E7D0)
	// 8232E7AC: 815F0374  lwz r10, 0x374(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 8232E7B0: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8232E7B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232E7B8: 419A002C  beq cr6, 0x8232e7e4
	if ctx.cr[6].eq {
	pc = 0x8232E7E4; continue 'dispatch;
	}
	// 8232E7BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232E7C0: 41980010  blt cr6, 0x8232e7d0
	if ctx.cr[6].lt {
	pc = 0x8232E7D0; continue 'dispatch;
	}
	// 8232E7C4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232E7C8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8232E7CC: 41980024  blt cr6, 0x8232e7f0
	if ctx.cr[6].lt {
	pc = 0x8232E7F0; continue 'dispatch;
	}
	pc = 0x8232E7D0; continue 'dispatch;
            }
            0x8232E7D0 => {
    //   block [0x8232E7D0..0x8232E7E4)
	// 8232E7D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232E7D4: 913F0378  stw r9, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[9].u32 ) };
	// 8232E7D8: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232E7DC: D01F037C  stfs f0, 0x37c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	// 8232E7E0: 48000014  b 0x8232e7f4
	pc = 0x8232E7F4; continue 'dispatch;
            }
            0x8232E7E4 => {
    //   block [0x8232E7E4..0x8232E7F0)
	// 8232E7E4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232E7E8: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232E7EC: D01F037C  stfs f0, 0x37c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	pc = 0x8232E7F0; continue 'dispatch;
            }
            0x8232E7F0 => {
    //   block [0x8232E7F0..0x8232E7F4)
	// 8232E7F0: 917F0378  stw r11, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[11].u32 ) };
	pc = 0x8232E7F4; continue 'dispatch;
            }
            0x8232E7F4 => {
    //   block [0x8232E7F4..0x8232E804)
	// 8232E7F4: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8232E7F8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8232E7FC: 40980008  bge cr6, 0x8232e804
	if !ctx.cr[6].lt {
	pc = 0x8232E804; continue 'dispatch;
	}
	// 8232E800: 815F0378  lwz r10, 0x378(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(888 as u32) ) } as u64;
	pc = 0x8232E804; continue 'dispatch;
            }
            0x8232E804 => {
    //   block [0x8232E804..0x8232E820)
	// 8232E804: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 8232E808: 817F0374  lwz r11, 0x374(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 8232E80C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8232E810: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232E814: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232E818: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8232E81C: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	pc = 0x8232E820; continue 'dispatch;
            }
            0x8232E820 => {
    //   block [0x8232E820..0x8232E874)
	// 8232E820: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 8232E824: C01F00C4  lfs f0, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232E828: 809F00D0  lwz r4, 0xd0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8232E82C: D01F037C  stfs f0, 0x37c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	// 8232E830: 4BEEFBA1  bl 0x8221e3d0
	ctx.lr = 0x8232E834;
	sub_8221E3D0(ctx, base);
	// 8232E834: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232E838: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8232E83C: C1BF00C4  lfs f13, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232E840: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8232E844: C19F00C8  lfs f12, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232E848: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 8232E84C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232E850: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232E854: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8232E858: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8232E85C: 4800001D  bl 0x8232e878
	ctx.lr = 0x8232E860;
	sub_8232E878(ctx, base);
	// 8232E860: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232E864: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232E868: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232E86C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232E870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232E878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232E878 size=328
    let mut pc: u32 = 0x8232E878;
    'dispatch: loop {
        match pc {
            0x8232E878 => {
    //   block [0x8232E878..0x8232E92C)
	// 8232E878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232E87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232E880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232E884: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232E888: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 8232E88C: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8232E890: 394ABFF0  addi r10, r10, -0x4010
	ctx.r[10].s64 = ctx.r[10].s64 + -16400;
	// 8232E894: 612985E0  ori r9, r9, 0x85e0
	ctx.r[9].u64 = ctx.r[9].u64 | 34272;
	// 8232E898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232E89C: 7DAA4C2E  lfsx f13, r10, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232E8A0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232E8A4: 817F0380  lwz r11, 0x380(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(896 as u32) ) } as u64;
	// 8232E8A8: C01F00C4  lfs f0, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232E8AC: C17F00C8  lfs f11, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232E8B0: EDAB037C  fnmsubs f13, f11, f13, f0
	ctx.f[13].f64 = -(((ctx.f[11].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8232E8B4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8232E8B8: C18A1FF8  lfs f12, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232E8BC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8232E8C0: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8232E8C4: C18ABA38  lfs f12, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232E8C8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232E8CC: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8232E8D0: C18A24E4  lfs f12, 0x24e4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9444 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232E8D4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8232E8D8: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8232E8DC: C18AD760  lfs f12, -0x28a0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10400 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232E8E0: D181006C  stfs f12, 0x6c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8232E8E4: 419A007C  beq cr6, 0x8232e960
	if ctx.cr[6].eq {
	pc = 0x8232E960; continue 'dispatch;
	}
	// 8232E8E8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8232E8EC: 419A0040  beq cr6, 0x8232e92c
	if ctx.cr[6].eq {
	pc = 0x8232E92C; continue 'dispatch;
	}
	// 8232E8F0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8232E8F4: 409A00B8  bne cr6, 0x8232e9ac
	if !ctx.cr[6].eq {
	pc = 0x8232E9AC; continue 'dispatch;
	}
	// 8232E8F8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8232E8FC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8232E900: 7D8B542E  lfsx f12, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232E904: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 8232E908: 409900A4  ble cr6, 0x8232e9ac
	if !ctx.cr[6].gt {
	pc = 0x8232E9AC; continue 'dispatch;
	}
	// 8232E90C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 8232E910: 4199009C  bgt cr6, 0x8232e9ac
	if ctx.cr[6].gt {
	pc = 0x8232E9AC; continue 'dispatch;
	}
	// 8232E914: C1BF0384  lfs f13, 0x384(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(900 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232E918: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8232E91C: 419A0090  beq cr6, 0x8232e9ac
	if ctx.cr[6].eq {
	pc = 0x8232E9AC; continue 'dispatch;
	}
	// 8232E920: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8232E924: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 8232E928: 48000074  b 0x8232e99c
	pc = 0x8232E99C; continue 'dispatch;
            }
            0x8232E92C => {
    //   block [0x8232E92C..0x8232E960)
	// 8232E92C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8232E930: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8232E934: 7D8B542E  lfsx f12, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232E938: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 8232E93C: 40990070  ble cr6, 0x8232e9ac
	if !ctx.cr[6].gt {
	pc = 0x8232E9AC; continue 'dispatch;
	}
	// 8232E940: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 8232E944: 41990068  bgt cr6, 0x8232e9ac
	if ctx.cr[6].gt {
	pc = 0x8232E9AC; continue 'dispatch;
	}
	// 8232E948: C1BF0384  lfs f13, 0x384(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(900 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232E94C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8232E950: 419A005C  beq cr6, 0x8232e9ac
	if ctx.cr[6].eq {
	pc = 0x8232E9AC; continue 'dispatch;
	}
	// 8232E954: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8232E958: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8232E95C: 48000040  b 0x8232e99c
	pc = 0x8232E99C; continue 'dispatch;
            }
            0x8232E960 => {
    //   block [0x8232E960..0x8232E99C)
	// 8232E960: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8232E964: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8232E968: 7D8B542E  lfsx f12, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232E96C: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 8232E970: 4099003C  ble cr6, 0x8232e9ac
	if !ctx.cr[6].gt {
	pc = 0x8232E9AC; continue 'dispatch;
	}
	// 8232E974: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 8232E978: 41990034  bgt cr6, 0x8232e9ac
	if ctx.cr[6].gt {
	pc = 0x8232E9AC; continue 'dispatch;
	}
	// 8232E97C: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8232E980: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232E984: 409A0028  bne cr6, 0x8232e9ac
	if !ctx.cr[6].eq {
	pc = 0x8232E9AC; continue 'dispatch;
	}
	// 8232E988: C1BF0384  lfs f13, 0x384(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(900 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232E98C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8232E990: 419A001C  beq cr6, 0x8232e9ac
	if ctx.cr[6].eq {
	pc = 0x8232E9AC; continue 'dispatch;
	}
	// 8232E994: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8232E998: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	pc = 0x8232E99C; continue 'dispatch;
            }
            0x8232E99C => {
    //   block [0x8232E99C..0x8232E9AC)
	// 8232E99C: 389F0360  addi r4, r31, 0x360
	ctx.r[4].s64 = ctx.r[31].s64 + 864;
	// 8232E9A0: 48033CE1  bl 0x82362680
	ctx.lr = 0x8232E9A4;
	sub_82362680(ctx, base);
	// 8232E9A4: C01F00C4  lfs f0, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232E9A8: D01F0384  stfs f0, 0x384(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(900 as u32), tmp.u32 ) };
	pc = 0x8232E9AC; continue 'dispatch;
            }
            0x8232E9AC => {
    //   block [0x8232E9AC..0x8232E9C0)
	// 8232E9AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8232E9B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232E9B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232E9B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232E9BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232E9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232E9C0 size=456
    let mut pc: u32 = 0x8232E9C0;
    'dispatch: loop {
        match pc {
            0x8232E9C0 => {
    //   block [0x8232E9C0..0x8232E9EC)
	// 8232E9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232E9C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232E9C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232E9CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232E9D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232E9D4: 809F00D4  lwz r4, 0xd4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 8232E9D8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8232E9DC: 419A0010  beq cr6, 0x8232e9ec
	if ctx.cr[6].eq {
	pc = 0x8232E9EC; continue 'dispatch;
	}
	// 8232E9E0: 38BF0080  addi r5, r31, 0x80
	ctx.r[5].s64 = ctx.r[31].s64 + 128;
	// 8232E9E4: 387F0330  addi r3, r31, 0x330
	ctx.r[3].s64 = ctx.r[31].s64 + 816;
	// 8232E9E8: 48039349  bl 0x82367d30
	ctx.lr = 0x8232E9EC;
	sub_82367D30(ctx, base);
	pc = 0x8232E9EC; continue 'dispatch;
            }
            0x8232E9EC => {
    //   block [0x8232E9EC..0x8232EA18)
	// 8232E9EC: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 8232E9F0: C01F00C4  lfs f0, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232E9F4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8232E9F8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8232E9FC: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8232EA00: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8232EA04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232EA08: C0CB1FF8  lfs f6, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8232EA0C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8232EA10: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232EA14: 4198009C  blt cr6, 0x8232eab0
	if ctx.cr[6].lt {
	pc = 0x8232EAB0; continue 'dispatch;
	}
	pc = 0x8232EA18; continue 'dispatch;
            }
            0x8232EA18 => {
    //   block [0x8232EA18..0x8232EA4C)
	// 8232EA18: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232EA1C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232EA20: 4098FFF8  bge cr6, 0x8232ea18
	if !ctx.cr[6].lt {
	pc = 0x8232EA18; continue 'dispatch;
	}
	// 8232EA24: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8232EA28: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8232EA2C: 815F0374  lwz r10, 0x374(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 8232EA30: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8232EA34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8232EA38: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 8232EA3C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232EA40: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8232EA44: 41980008  blt cr6, 0x8232ea4c
	if ctx.cr[6].lt {
	pc = 0x8232EA4C; continue 'dispatch;
	}
	// 8232EA48: 913F00C0  stw r9, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	pc = 0x8232EA4C; continue 'dispatch;
            }
            0x8232EA4C => {
    //   block [0x8232EA4C..0x8232EA70)
	// 8232EA4C: 815F0374  lwz r10, 0x374(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 8232EA50: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8232EA54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232EA58: 419A0024  beq cr6, 0x8232ea7c
	if ctx.cr[6].eq {
	pc = 0x8232EA7C; continue 'dispatch;
	}
	// 8232EA5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232EA60: 41980010  blt cr6, 0x8232ea70
	if ctx.cr[6].lt {
	pc = 0x8232EA70; continue 'dispatch;
	}
	// 8232EA64: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232EA68: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8232EA6C: 41980014  blt cr6, 0x8232ea80
	if ctx.cr[6].lt {
	pc = 0x8232EA80; continue 'dispatch;
	}
	pc = 0x8232EA70; continue 'dispatch;
            }
            0x8232EA70 => {
    //   block [0x8232EA70..0x8232EA7C)
	// 8232EA70: D0DF037C  stfs f6, 0x37c(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	// 8232EA74: 913F0378  stw r9, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[9].u32 ) };
	// 8232EA78: 4800000C  b 0x8232ea84
	pc = 0x8232EA84; continue 'dispatch;
            }
            0x8232EA7C => {
    //   block [0x8232EA7C..0x8232EA80)
	// 8232EA7C: D0DF037C  stfs f6, 0x37c(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	pc = 0x8232EA80; continue 'dispatch;
            }
            0x8232EA80 => {
    //   block [0x8232EA80..0x8232EA84)
	// 8232EA80: 917F0378  stw r11, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[11].u32 ) };
	pc = 0x8232EA84; continue 'dispatch;
            }
            0x8232EA84 => {
    //   block [0x8232EA84..0x8232EA94)
	// 8232EA84: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8232EA88: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8232EA8C: 40980008  bge cr6, 0x8232ea94
	if !ctx.cr[6].lt {
	pc = 0x8232EA94; continue 'dispatch;
	}
	// 8232EA90: 815F0378  lwz r10, 0x378(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(888 as u32) ) } as u64;
	pc = 0x8232EA94; continue 'dispatch;
            }
            0x8232EA94 => {
    //   block [0x8232EA94..0x8232EAB0)
	// 8232EA94: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 8232EA98: 817F0374  lwz r11, 0x374(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 8232EA9C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8232EAA0: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232EAA4: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232EAA8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8232EAAC: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	pc = 0x8232EAB0; continue 'dispatch;
            }
            0x8232EAB0 => {
    //   block [0x8232EAB0..0x8232EB88)
	// 8232EAB0: 394003A0  li r10, 0x3a0
	ctx.r[10].s64 = 928;
	// 8232EAB4: C01F03AC  lfs f0, 0x3ac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(940 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232EAB8: 397F0330  addi r11, r31, 0x330
	ctx.r[11].s64 = ctx.r[31].s64 + 816;
	// 8232EABC: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8232EAC0: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 8232EAC4: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232EB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232EB88 size=276
    let mut pc: u32 = 0x8232EB88;
    'dispatch: loop {
        match pc {
            0x8232EB88 => {
    //   block [0x8232EB88..0x8232EBE8)
	// 8232EB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232EB8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232EB90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232EB94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232EB98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232EB9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232EBA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8232EBA4: 4BFFF98D  bl 0x8232e530
	ctx.lr = 0x8232EBA8;
	sub_8232E530(ctx, base);
	// 8232EBA8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232EBAC: 817F0374  lwz r11, 0x374(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 8232EBB0: 394ADB7C  addi r10, r10, -0x2484
	ctx.r[10].s64 = ctx.r[10].s64 + -9348;
	// 8232EBB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232EBB8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8232EBBC: 419A00C4  beq cr6, 0x8232ec80
	if ctx.cr[6].eq {
	pc = 0x8232EC80; continue 'dispatch;
	}
	// 8232EBC0: 895E0005  lbz r10, 5(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(5 as u32) ) } as u64;
	// 8232EBC4: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 8232EBC8: 419800B8  blt cr6, 0x8232ec80
	if ctx.cr[6].lt {
	pc = 0x8232EC80; continue 'dispatch;
	}
	// 8232EBCC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232EBD0: 917F0390  stw r11, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 8232EBD4: 895E0005  lbz r10, 5(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(5 as u32) ) } as u64;
	// 8232EBD8: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 8232EBDC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8232EBE0: 40980008  bge cr6, 0x8232ebe8
	if !ctx.cr[6].lt {
	pc = 0x8232EBE8; continue 'dispatch;
	}
	// 8232EBE4: 915F0390  stw r10, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[10].u32 ) };
	pc = 0x8232EBE8; continue 'dispatch;
            }
            0x8232EBE8 => {
    //   block [0x8232EBE8..0x8232EBFC)
	// 8232EBE8: 817F0390  lwz r11, 0x390(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 8232EBEC: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 8232EBF0: 4099000C  ble cr6, 0x8232ebfc
	if !ctx.cr[6].gt {
	pc = 0x8232EBFC; continue 'dispatch;
	}
	// 8232EBF4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8232EBF8: 917F0390  stw r11, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	pc = 0x8232EBFC; continue 'dispatch;
            }
            0x8232EBFC => {
    //   block [0x8232EBFC..0x8232EC28)
	// 8232EBFC: 817F0390  lwz r11, 0x390(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 8232EC00: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8232EC04: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8232EC08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232EC0C: 40990060  ble cr6, 0x8232ec6c
	if !ctx.cr[6].gt {
	pc = 0x8232EC6C; continue 'dispatch;
	}
	// 8232EC10: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 8232EC14: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 8232EC18: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 8232EC1C: 395F0394  addi r10, r31, 0x394
	ctx.r[10].s64 = ctx.r[31].s64 + 916;
	// 8232EC20: C1A6BFFC  lfs f13, -0x4004(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232EC24: C0072808  lfs f0, 0x2808(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(10248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8232EC28; continue 'dispatch;
            }
            0x8232EC28 => {
    //   block [0x8232EC28..0x8232EC6C)
	// 8232EC28: 80FE0054  lwz r7, 0x54(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232EC2C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8232EC30: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 8232EC34: 7D875C2E  lfsx f12, r7, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232EC38: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8232EC3C: ED8C683A  fmadds f12, f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8232EC40: FD80665E  fctidz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 8232EC44: 7D8037AE  stfiwx f12, 0, r6
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32, tmp.u32) };
	// 8232EC48: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232EC4C: 7D274A14  add r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 8232EC50: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8232EC54: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8232EC58: 80FF0390  lwz r7, 0x390(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 8232EC5C: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 8232EC60: 4198FFC8  blt cr6, 0x8232ec28
	if ctx.cr[6].lt {
	pc = 0x8232EC28; continue 'dispatch;
	}
	// 8232EC64: 2B097FFF  cmplwi cr6, r9, 0x7fff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 32767 as u32, &mut ctx.xer);
	// 8232EC68: 40980018  bge cr6, 0x8232ec80
	if !ctx.cr[6].lt {
	pc = 0x8232EC80; continue 'dispatch;
	}
	pc = 0x8232EC6C; continue 'dispatch;
            }
            0x8232EC6C => {
    //   block [0x8232EC6C..0x8232EC80)
	// 8232EC6C: 817F0390  lwz r11, 0x390(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 8232EC70: 39407FFF  li r10, 0x7fff
	ctx.r[10].s64 = 32767;
	// 8232EC74: 396B00E4  addi r11, r11, 0xe4
	ctx.r[11].s64 = ctx.r[11].s64 + 228;
	// 8232EC78: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8232EC7C: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	pc = 0x8232EC80; continue 'dispatch;
            }
            0x8232EC80 => {
    //   block [0x8232EC80..0x8232EC9C)
	// 8232EC80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232EC84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232EC88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232EC8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232EC90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232EC94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232EC98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232ECA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232ECA0 size=356
    let mut pc: u32 = 0x8232ECA0;
    'dispatch: loop {
        match pc {
            0x8232ECA0 => {
    //   block [0x8232ECA0..0x8232ECCC)
	// 8232ECA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232ECA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232ECA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232ECAC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232ECB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232ECB4: 809F00D4  lwz r4, 0xd4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 8232ECB8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8232ECBC: 419A0010  beq cr6, 0x8232eccc
	if ctx.cr[6].eq {
	pc = 0x8232ECCC; continue 'dispatch;
	}
	// 8232ECC0: 38BF0080  addi r5, r31, 0x80
	ctx.r[5].s64 = ctx.r[31].s64 + 128;
	// 8232ECC4: 387F0330  addi r3, r31, 0x330
	ctx.r[3].s64 = ctx.r[31].s64 + 816;
	// 8232ECC8: 48039069  bl 0x82367d30
	ctx.lr = 0x8232ECCC;
	sub_82367D30(ctx, base);
	pc = 0x8232ECCC; continue 'dispatch;
            }
            0x8232ECCC => {
    //   block [0x8232ECCC..0x8232ECF0)
	// 8232ECCC: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 8232ECD0: C01F00C4  lfs f0, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232ECD4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8232ECD8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8232ECDC: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8232ECE0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8232ECE4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8232ECE8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232ECEC: 419800C4  blt cr6, 0x8232edb0
	if ctx.cr[6].lt {
	pc = 0x8232EDB0; continue 'dispatch;
	}
	pc = 0x8232ECF0; continue 'dispatch;
            }
            0x8232ECF0 => {
    //   block [0x8232ECF0..0x8232ED18)
	// 8232ECF0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232ECF4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232ECF8: 4098FFF8  bge cr6, 0x8232ecf0
	if !ctx.cr[6].lt {
	pc = 0x8232ECF0; continue 'dispatch;
	}
	// 8232ECFC: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8232ED00: 48204511  bl 0x82533210
	ctx.lr = 0x8232ED04;
	sub_82533210(ctx, base);
	// 8232ED04: 815F0390  lwz r10, 0x390(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 8232ED08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232ED0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232ED10: 40990030  ble cr6, 0x8232ed40
	if !ctx.cr[6].gt {
	pc = 0x8232ED40; continue 'dispatch;
	}
	// 8232ED14: 395F0394  addi r10, r31, 0x394
	ctx.r[10].s64 = ctx.r[31].s64 + 916;
	pc = 0x8232ED18; continue 'dispatch;
            }
            0x8232ED18 => {
    //   block [0x8232ED18..0x8232ED3C)
	// 8232ED18: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232ED1C: 7F034840  cmplw cr6, r3, r9
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232ED20: 4099001C  ble cr6, 0x8232ed3c
	if !ctx.cr[6].gt {
	pc = 0x8232ED3C; continue 'dispatch;
	}
	// 8232ED24: 813F0390  lwz r9, 0x390(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 8232ED28: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8232ED2C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8232ED30: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232ED34: 4198FFE4  blt cr6, 0x8232ed18
	if ctx.cr[6].lt {
	pc = 0x8232ED18; continue 'dispatch;
	}
	// 8232ED38: 48000008  b 0x8232ed40
	pc = 0x8232ED40; continue 'dispatch;
            }
            0x8232ED3C => {
    //   block [0x8232ED3C..0x8232ED40)
	// 8232ED3C: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	pc = 0x8232ED40; continue 'dispatch;
            }
            0x8232ED40 => {
    //   block [0x8232ED40..0x8232ED64)
	// 8232ED40: 815F0374  lwz r10, 0x374(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 8232ED44: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8232ED48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232ED4C: 419A0028  beq cr6, 0x8232ed74
	if ctx.cr[6].eq {
	pc = 0x8232ED74; continue 'dispatch;
	}
	// 8232ED50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232ED54: 41980010  blt cr6, 0x8232ed64
	if ctx.cr[6].lt {
	pc = 0x8232ED64; continue 'dispatch;
	}
	// 8232ED58: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232ED5C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8232ED60: 41980020  blt cr6, 0x8232ed80
	if ctx.cr[6].lt {
	pc = 0x8232ED80; continue 'dispatch;
	}
	pc = 0x8232ED64; continue 'dispatch;
            }
            0x8232ED64 => {
    //   block [0x8232ED64..0x8232ED74)
	// 8232ED64: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232ED68: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232ED6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232ED70: 4800000C  b 0x8232ed7c
	pc = 0x8232ED7C; continue 'dispatch;
            }
            0x8232ED74 => {
    //   block [0x8232ED74..0x8232ED7C)
	// 8232ED74: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232ED78: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8232ED7C; continue 'dispatch;
            }
            0x8232ED7C => {
    //   block [0x8232ED7C..0x8232ED80)
	// 8232ED7C: D01F037C  stfs f0, 0x37c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	pc = 0x8232ED80; continue 'dispatch;
            }
            0x8232ED80 => {
    //   block [0x8232ED80..0x8232ED94)
	// 8232ED80: 917F0378  stw r11, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[11].u32 ) };
	// 8232ED84: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8232ED88: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8232ED8C: 40980008  bge cr6, 0x8232ed94
	if !ctx.cr[6].lt {
	pc = 0x8232ED94; continue 'dispatch;
	}
	// 8232ED90: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x8232ED94; continue 'dispatch;
            }
            0x8232ED94 => {
    //   block [0x8232ED94..0x8232EDB0)
	// 8232ED94: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 8232ED98: 817F0374  lwz r11, 0x374(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 8232ED9C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8232EDA0: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232EDA4: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232EDA8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8232EDAC: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	pc = 0x8232EDB0; continue 'dispatch;
            }
            0x8232EDB0 => {
    //   block [0x8232EDB0..0x8232EE04)
	// 8232EDB0: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 8232EDB4: C01F00C4  lfs f0, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232EDB8: 809F00D0  lwz r4, 0xd0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8232EDBC: D01F037C  stfs f0, 0x37c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	// 8232EDC0: 4BEEF611  bl 0x8221e3d0
	ctx.lr = 0x8232EDC4;
	sub_8221E3D0(ctx, base);
	// 8232EDC4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8232EDC8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8232EDCC: C1BF00C4  lfs f13, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232EDD0: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8232EDD4: C19F00C8  lfs f12, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232EDD8: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 8232EDDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232EDE0: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232EDE4: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8232EDE8: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8232EDEC: 4BFFFA8D  bl 0x8232e878
	ctx.lr = 0x8232EDF0;
	sub_8232E878(ctx, base);
	// 8232EDF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232EDF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232EDF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232EDFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232EE00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232EE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232EE08 size=72
    let mut pc: u32 = 0x8232EE08;
    'dispatch: loop {
        match pc {
            0x8232EE08 => {
    //   block [0x8232EE08..0x8232EE50)
	// 8232EE08: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232EE0C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8232EE10: 396B4634  addi r11, r11, 0x4634
	ctx.r[11].s64 = ctx.r[11].s64 + 17972;
	// 8232EE14: 394ADED0  addi r10, r10, -0x2130
	ctx.r[10].s64 = ctx.r[10].s64 + -8496;
	// 8232EE18: 548907FE  clrlwi r9, r4, 0x1f
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 8232EE1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8232EE20: 91630370  stw r11, 0x370(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(880 as u32), ctx.r[11].u32 ) };
	// 8232EE24: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8232EE28: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8232EE2C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232EE30: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8232EE34: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 8232EE38: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8232EE3C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8232EE40: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8232EE44: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8232EE48: 99430025  stb r10, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8232EE4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232EE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232EE50 size=484
    let mut pc: u32 = 0x8232EE50;
    'dispatch: loop {
        match pc {
            0x8232EE50 => {
    //   block [0x8232EE50..0x8232EE80)
	// 8232EE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232EE54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232EE58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232EE5C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8232EE60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232EE64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232EE68: 809F00D4  lwz r4, 0xd4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 8232EE6C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8232EE70: 419A0010  beq cr6, 0x8232ee80
	if ctx.cr[6].eq {
	pc = 0x8232EE80; continue 'dispatch;
	}
	// 8232EE74: 38BF0080  addi r5, r31, 0x80
	ctx.r[5].s64 = ctx.r[31].s64 + 128;
	// 8232EE78: 387F0330  addi r3, r31, 0x330
	ctx.r[3].s64 = ctx.r[31].s64 + 816;
	// 8232EE7C: 48038EB5  bl 0x82367d30
	ctx.lr = 0x8232EE80;
	sub_82367D30(ctx, base);
	pc = 0x8232EE80; continue 'dispatch;
            }
            0x8232EE80 => {
    //   block [0x8232EE80..0x8232EEAC)
	// 8232EE80: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 8232EE84: C01F00C4  lfs f0, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232EE88: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8232EE8C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8232EE90: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8232EE94: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8232EE98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232EE9C: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8232EEA0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8232EEA4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232EEA8: 419800B0  blt cr6, 0x8232ef58
	if ctx.cr[6].lt {
	pc = 0x8232EF58; continue 'dispatch;
	}
	pc = 0x8232EEAC; continue 'dispatch;
            }
            0x8232EEAC => {
    //   block [0x8232EEAC..0x8232EED4)
	// 8232EEAC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232EEB0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232EEB4: 4098FFF8  bge cr6, 0x8232eeac
	if !ctx.cr[6].lt {
	pc = 0x8232EEAC; continue 'dispatch;
	}
	// 8232EEB8: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8232EEBC: 48204355  bl 0x82533210
	ctx.lr = 0x8232EEC0;
	sub_82533210(ctx, base);
	// 8232EEC0: 815F0390  lwz r10, 0x390(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 8232EEC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232EEC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232EECC: 40990030  ble cr6, 0x8232eefc
	if !ctx.cr[6].gt {
	pc = 0x8232EEFC; continue 'dispatch;
	}
	// 8232EED0: 395F0394  addi r10, r31, 0x394
	ctx.r[10].s64 = ctx.r[31].s64 + 916;
	pc = 0x8232EED4; continue 'dispatch;
            }
            0x8232EED4 => {
    //   block [0x8232EED4..0x8232EEF8)
	// 8232EED4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232EED8: 7F034840  cmplw cr6, r3, r9
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232EEDC: 4099001C  ble cr6, 0x8232eef8
	if !ctx.cr[6].gt {
	pc = 0x8232EEF8; continue 'dispatch;
	}
	// 8232EEE0: 813F0390  lwz r9, 0x390(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 8232EEE4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8232EEE8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8232EEEC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232EEF0: 4198FFE4  blt cr6, 0x8232eed4
	if ctx.cr[6].lt {
	pc = 0x8232EED4; continue 'dispatch;
	}
	// 8232EEF4: 48000008  b 0x8232eefc
	pc = 0x8232EEFC; continue 'dispatch;
            }
            0x8232EEF8 => {
    //   block [0x8232EEF8..0x8232EEFC)
	// 8232EEF8: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	pc = 0x8232EEFC; continue 'dispatch;
            }
            0x8232EEFC => {
    //   block [0x8232EEFC..0x8232EF20)
	// 8232EEFC: 815F0374  lwz r10, 0x374(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 8232EF00: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8232EF04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232EF08: 419A001C  beq cr6, 0x8232ef24
	if ctx.cr[6].eq {
	pc = 0x8232EF24; continue 'dispatch;
	}
	// 8232EF0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232EF10: 41980010  blt cr6, 0x8232ef20
	if ctx.cr[6].lt {
	pc = 0x8232EF20; continue 'dispatch;
	}
	// 8232EF14: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232EF18: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8232EF1C: 4198000C  blt cr6, 0x8232ef28
	if ctx.cr[6].lt {
	pc = 0x8232EF28; continue 'dispatch;
	}
	pc = 0x8232EF20; continue 'dispatch;
            }
            0x8232EF20 => {
    //   block [0x8232EF20..0x8232EF24)
	// 8232EF20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8232EF24; continue 'dispatch;
            }
            0x8232EF24 => {
    //   block [0x8232EF24..0x8232EF28)
	// 8232EF24: D3FF037C  stfs f31, 0x37c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	pc = 0x8232EF28; continue 'dispatch;
            }
            0x8232EF28 => {
    //   block [0x8232EF28..0x8232EF3C)
	// 8232EF28: 917F0378  stw r11, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[11].u32 ) };
	// 8232EF2C: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8232EF30: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8232EF34: 40980008  bge cr6, 0x8232ef3c
	if !ctx.cr[6].lt {
	pc = 0x8232EF3C; continue 'dispatch;
	}
	// 8232EF38: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x8232EF3C; continue 'dispatch;
            }
            0x8232EF3C => {
    //   block [0x8232EF3C..0x8232EF58)
	// 8232EF3C: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 8232EF40: 817F0374  lwz r11, 0x374(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 8232EF44: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8232EF48: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232EF4C: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232EF50: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8232EF54: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	pc = 0x8232EF58; continue 'dispatch;
            }
            0x8232EF58 => {
    //   block [0x8232EF58..0x8232F034)
	// 8232EF58: 394003C0  li r10, 0x3c0
	ctx.r[10].s64 = 960;
	// 8232EF5C: C01F03CC  lfs f0, 0x3cc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232EF60: 397F0330  addi r11, r31, 0x330
	ctx.r[11].s64 = ctx.r[31].s64 + 816;
	// 8232EF64: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8232EF68: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 8232EF6C: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232F038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232F038 size=120
    let mut pc: u32 = 0x8232F038;
    'dispatch: loop {
        match pc {
            0x8232F038 => {
    //   block [0x8232F038..0x8232F06C)
	// 8232F038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232F03C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232F040: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232F044: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232F048: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232F04C: 4BFFFC55  bl 0x8232eca0
	ctx.lr = 0x8232F050;
	sub_8232ECA0(ctx, base);
	// 8232F050: 817F03B8  lwz r11, 0x3b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 8232F054: 7C005A2C  dcbt 0, r11
	// 8232F058: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8232F05C: 817F03B0  lwz r11, 0x3b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(944 as u32) ) } as u64;
	// 8232F060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232F064: 40990038  ble cr6, 0x8232f09c
	if !ctx.cr[6].gt {
	pc = 0x8232F09C; continue 'dispatch;
	}
	// 8232F068: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x8232F06C; continue 'dispatch;
            }
            0x8232F06C => {
    //   block [0x8232F06C..0x8232F09C)
	// 8232F06C: 813F03B8  lwz r9, 0x3b8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 8232F070: 815F00D0  lwz r10, 0xd0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8232F074: 817F03B4  lwz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 8232F078: 7CA84A14  add r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 8232F07C: 7C8A4214  add r4, r10, r8
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8232F080: 7C6B4214  add r3, r11, r8
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 8232F084: 48038CAD  bl 0x82367d30
	ctx.lr = 0x8232F088;
	sub_82367D30(ctx, base);
	// 8232F088: 817F03B0  lwz r11, 0x3b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(944 as u32) ) } as u64;
	// 8232F08C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 8232F090: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 8232F094: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8232F098: 4198FFD4  blt cr6, 0x8232f06c
	if ctx.cr[6].lt {
	pc = 0x8232F06C; continue 'dispatch;
	}
	pc = 0x8232F09C; continue 'dispatch;
            }
            0x8232F09C => {
    //   block [0x8232F09C..0x8232F0B0)
	// 8232F09C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232F0A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232F0A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232F0A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232F0AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232F0B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232F0B0 size=120
    let mut pc: u32 = 0x8232F0B0;
    'dispatch: loop {
        match pc {
            0x8232F0B0 => {
    //   block [0x8232F0B0..0x8232F0E4)
	// 8232F0B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232F0B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232F0B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232F0BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232F0C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232F0C4: 4BFFF665  bl 0x8232e728
	ctx.lr = 0x8232F0C8;
	sub_8232E728(ctx, base);
	// 8232F0C8: 817F0398  lwz r11, 0x398(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 8232F0CC: 7C005A2C  dcbt 0, r11
	// 8232F0D0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8232F0D4: 817F0390  lwz r11, 0x390(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 8232F0D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232F0DC: 40990038  ble cr6, 0x8232f114
	if !ctx.cr[6].gt {
	pc = 0x8232F114; continue 'dispatch;
	}
	// 8232F0E0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x8232F0E4; continue 'dispatch;
            }
            0x8232F0E4 => {
    //   block [0x8232F0E4..0x8232F114)
	// 8232F0E4: 813F0398  lwz r9, 0x398(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 8232F0E8: 815F00D0  lwz r10, 0xd0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8232F0EC: 817F0394  lwz r11, 0x394(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 8232F0F0: 7CA84A14  add r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 8232F0F4: 7C8A4214  add r4, r10, r8
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8232F0F8: 7C6B4214  add r3, r11, r8
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 8232F0FC: 48038C35  bl 0x82367d30
	ctx.lr = 0x8232F100;
	sub_82367D30(ctx, base);
	// 8232F100: 817F0390  lwz r11, 0x390(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 8232F104: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 8232F108: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 8232F10C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8232F110: 4198FFD4  blt cr6, 0x8232f0e4
	if ctx.cr[6].lt {
	pc = 0x8232F0E4; continue 'dispatch;
	}
	pc = 0x8232F114; continue 'dispatch;
            }
            0x8232F114 => {
    //   block [0x8232F114..0x8232F128)
	// 8232F114: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232F118: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232F11C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232F120: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232F124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232F128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232F128 size=144
    let mut pc: u32 = 0x8232F128;
    'dispatch: loop {
        match pc {
            0x8232F128 => {
    //   block [0x8232F128..0x8232F174)
	// 8232F128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232F12C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232F130: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232F134: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232F138: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232F13C: 4BFFFD15  bl 0x8232ee50
	ctx.lr = 0x8232F140;
	sub_8232EE50(ctx, base);
	// 8232F140: 817F03B0  lwz r11, 0x3b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(944 as u32) ) } as u64;
	// 8232F144: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F148: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F14C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F150: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8232F154: 419A0050  beq cr6, 0x8232f1a4
	if ctx.cr[6].eq {
	pc = 0x8232F1A4; continue 'dispatch;
	}
	// 8232F158: 817F03D8  lwz r11, 0x3d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(984 as u32) ) } as u64;
	// 8232F15C: 7C005A2C  dcbt 0, r11
	// 8232F160: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8232F164: 817F03D0  lwz r11, 0x3d0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 8232F168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232F16C: 40990038  ble cr6, 0x8232f1a4
	if !ctx.cr[6].gt {
	pc = 0x8232F1A4; continue 'dispatch;
	}
	// 8232F170: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x8232F174; continue 'dispatch;
            }
            0x8232F174 => {
    //   block [0x8232F174..0x8232F1A4)
	// 8232F174: 813F03D8  lwz r9, 0x3d8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(984 as u32) ) } as u64;
	// 8232F178: 815F00D0  lwz r10, 0xd0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8232F17C: 817F03D4  lwz r11, 0x3d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 8232F180: 7CA94214  add r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 8232F184: 7C8A4214  add r4, r10, r8
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8232F188: 7C6B4214  add r3, r11, r8
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 8232F18C: 48038BA5  bl 0x82367d30
	ctx.lr = 0x8232F190;
	sub_82367D30(ctx, base);
	// 8232F190: 817F03D0  lwz r11, 0x3d0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 8232F194: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 8232F198: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 8232F19C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8232F1A0: 4198FFD4  blt cr6, 0x8232f174
	if ctx.cr[6].lt {
	pc = 0x8232F174; continue 'dispatch;
	}
	pc = 0x8232F1A4; continue 'dispatch;
            }
            0x8232F1A4 => {
    //   block [0x8232F1A4..0x8232F1B8)
	// 8232F1A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232F1A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232F1AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232F1B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232F1B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232F1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232F1B8 size=144
    let mut pc: u32 = 0x8232F1B8;
    'dispatch: loop {
        match pc {
            0x8232F1B8 => {
    //   block [0x8232F1B8..0x8232F204)
	// 8232F1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232F1BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232F1C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232F1C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232F1C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232F1CC: 4BFFF7F5  bl 0x8232e9c0
	ctx.lr = 0x8232F1D0;
	sub_8232E9C0(ctx, base);
	// 8232F1D0: 817F0390  lwz r11, 0x390(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 8232F1D4: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F1D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F1DC: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F1E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8232F1E4: 419A0050  beq cr6, 0x8232f234
	if ctx.cr[6].eq {
	pc = 0x8232F234; continue 'dispatch;
	}
	// 8232F1E8: 817F03B8  lwz r11, 0x3b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 8232F1EC: 7C005A2C  dcbt 0, r11
	// 8232F1F0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8232F1F4: 817F03B0  lwz r11, 0x3b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(944 as u32) ) } as u64;
	// 8232F1F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232F1FC: 40990038  ble cr6, 0x8232f234
	if !ctx.cr[6].gt {
	pc = 0x8232F234; continue 'dispatch;
	}
	// 8232F200: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x8232F204; continue 'dispatch;
            }
            0x8232F204 => {
    //   block [0x8232F204..0x8232F234)
	// 8232F204: 813F03B8  lwz r9, 0x3b8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 8232F208: 815F00D0  lwz r10, 0xd0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8232F20C: 817F03B4  lwz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 8232F210: 7CA94214  add r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 8232F214: 7C8A4214  add r4, r10, r8
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8232F218: 7C6B4214  add r3, r11, r8
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 8232F21C: 48038B15  bl 0x82367d30
	ctx.lr = 0x8232F220;
	sub_82367D30(ctx, base);
	// 8232F220: 817F03B0  lwz r11, 0x3b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(944 as u32) ) } as u64;
	// 8232F224: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 8232F228: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 8232F22C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8232F230: 4198FFD4  blt cr6, 0x8232f204
	if ctx.cr[6].lt {
	pc = 0x8232F204; continue 'dispatch;
	}
	pc = 0x8232F234; continue 'dispatch;
            }
            0x8232F234 => {
    //   block [0x8232F234..0x8232F248)
	// 8232F234: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232F238: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232F23C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232F240: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232F244: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232F248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232F248 size=8
    let mut pc: u32 = 0x8232F248;
    'dispatch: loop {
        match pc {
            0x8232F248 => {
    //   block [0x8232F248..0x8232F250)
	// 8232F248: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 8232F24C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232F250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232F250 size=24
    let mut pc: u32 = 0x8232F250;
    'dispatch: loop {
        match pc {
            0x8232F250 => {
    //   block [0x8232F250..0x8232F268)
	// 8232F250: 548B077A  rlwinm r11, r4, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 8232F254: 386300B0  addi r3, r3, 0xb0
	ctx.r[3].s64 = ctx.r[3].s64 + 176;
	// 8232F258: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232F25C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8232F260: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8232F264: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232F268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232F268 size=168
    let mut pc: u32 = 0x8232F268;
    'dispatch: loop {
        match pc {
            0x8232F268 => {
    //   block [0x8232F268..0x8232F2D0)
	// 8232F268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232F26C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232F270: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232F274: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232F278: 89650005  lbz r11, 5(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(5 as u32) ) } as u64;
	// 8232F27C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232F280: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8232F284: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8232F288: 41980070  blt cr6, 0x8232f2f8
	if ctx.cr[6].lt {
	pc = 0x8232F2F8; continue 'dispatch;
	}
	// 8232F28C: 89650004  lbz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232F290: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8232F294: 41980064  blt cr6, 0x8232f2f8
	if ctx.cr[6].lt {
	pc = 0x8232F2F8; continue 'dispatch;
	}
	// 8232F298: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8232F29C: 419A0044  beq cr6, 0x8232f2e0
	if ctx.cr[6].eq {
	pc = 0x8232F2E0; continue 'dispatch;
	}
	// 8232F2A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F2A4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8232F2A8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8232F2AC: 90BF00F4  stw r5, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[5].u32 ) };
	// 8232F2B0: 396BDC3C  addi r11, r11, -0x23c4
	ctx.r[11].s64 = ctx.r[11].s64 + -9156;
	// 8232F2B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232F2B8: 4805A1E9  bl 0x823894a0
	ctx.lr = 0x8232F2BC;
	sub_823894A0(ctx, base);
	// 8232F2BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232F2C0: 907F00F0  stw r3, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[3].u32 ) };
	// 8232F2C4: 409A000C  bne cr6, 0x8232f2d0
	if !ctx.cr[6].eq {
	pc = 0x8232F2D0; continue 'dispatch;
	}
	// 8232F2C8: 4805A251  bl 0x82389518
	ctx.lr = 0x8232F2CC;
	sub_82389518(ctx, base);
	// 8232F2CC: 907F00F0  stw r3, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[3].u32 ) };
	pc = 0x8232F2D0; continue 'dispatch;
            }
            0x8232F2D0 => {
    //   block [0x8232F2D0..0x8232F2E0)
	// 8232F2D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232F2D4: 48000065  bl 0x8232f338
	ctx.lr = 0x8232F2D8;
	sub_8232F338(ctx, base);
	// 8232F2D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232F2DC: 48000008  b 0x8232f2e4
	pc = 0x8232F2E4; continue 'dispatch;
            }
            0x8232F2E0 => {
    //   block [0x8232F2E0..0x8232F2E4)
	// 8232F2E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8232F2E4; continue 'dispatch;
            }
            0x8232F2E4 => {
    //   block [0x8232F2E4..0x8232F2F8)
	// 8232F2E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F2E8: C1A3000C  lfs f13, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F2EC: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F2F0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8232F2F4: 40980008  bge cr6, 0x8232f2fc
	if !ctx.cr[6].lt {
	pc = 0x8232F2FC; continue 'dispatch;
	}
	pc = 0x8232F2F8; continue 'dispatch;
            }
            0x8232F2F8 => {
    //   block [0x8232F2F8..0x8232F2FC)
	// 8232F2F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8232F2FC; continue 'dispatch;
            }
            0x8232F2FC => {
    //   block [0x8232F2FC..0x8232F310)
	// 8232F2FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8232F300: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232F304: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232F308: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232F30C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232F310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232F310 size=36
    let mut pc: u32 = 0x8232F310;
    'dispatch: loop {
        match pc {
            0x8232F310 => {
    //   block [0x8232F310..0x8232F32C)
	// 8232F310: 89630005  lbz r11, 5(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(5 as u32) ) } as u64;
	// 8232F314: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8232F318: 41980014  blt cr6, 0x8232f32c
	if ctx.cr[6].lt {
	pc = 0x8232F32C; continue 'dispatch;
	}
	// 8232F31C: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232F320: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 8232F324: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8232F328: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	pc = 0x8232F32C; continue 'dispatch;
            }
            0x8232F32C => {
    //   block [0x8232F32C..0x8232F334)
	// 8232F32C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8232F330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232F338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232F338 size=900
    let mut pc: u32 = 0x8232F338;
    'dispatch: loop {
        match pc {
            0x8232F338 => {
    //   block [0x8232F338..0x8232F440)
	// 8232F338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232F33C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232F340: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232F344: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232F348: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8232F34C: 48206C95  bl 0x82535fe0
	ctx.lr = 0x8232F350;
	sub_82535FB0(ctx, base);
	// 8232F350: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232F354: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232F358: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232F35C: 83DF00F4  lwz r30, 0xf4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 8232F360: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F364: C00B0014  lfs f0, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F368: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8232F36C: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F370: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F374: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F378: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F37C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8232F380: C9AB2008  lfd f13, 0x2008(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 8232F384: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F388: FC00682E  fsel f0, f0, f0, f13
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8232F38C: C9AB2000  lfd f13, 0x2000(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 8232F390: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 8232F394: FC0C036E  fsel f0, f12, f13, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 8232F398: C1AABFFC  lfs f13, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F39C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8232F3A0: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8232F3A4: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F3A8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F3AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F3B0: C34B2150  lfs f26, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8232F3B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F3B8: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 8232F3BC: C36B1FF8  lfs f27, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 8232F3C0: 40990080  ble cr6, 0x8232f440
	if !ctx.cr[6].gt {
	pc = 0x8232F440; continue 'dispatch;
	}
	// 8232F3C4: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F3C8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F3CC: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232F3D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8232F3D4: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8232F3D8: 396BBA38  addi r11, r11, -0x45c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17864;
	// 8232F3DC: C3EB0000  lfs f31, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8232F3E0: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 8232F3E4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8232F3E8: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 8232F3EC: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8232F3F0: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F3F4: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232F3F8: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232F3FC: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 8232F400: EC00FB7C  fnmsubs f0, f0, f13, f31
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 8232F404: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 8232F408: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8232F40C: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 8232F410: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8232F414: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F418: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F41C: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 8232F420: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8232F424: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F428: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232F42C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F430: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F434: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232F438: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8232F43C: 48000038  b 0x8232f474
	pc = 0x8232F474; continue 'dispatch;
            }
            0x8232F440 => {
    //   block [0x8232F440..0x8232F474)
	// 8232F440: D37F0018  stfs f27, 0x18(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8232F444: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F448: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F44C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8232F450: 396BBA38  addi r11, r11, -0x45c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17864;
	// 8232F454: C3EB0000  lfs f31, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8232F458: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 8232F45C: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8232F460: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F464: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F468: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8232F46C: D37F0024  stfs f27, 0x24(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8232F470: D37F0028  stfs f27, 0x28(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	pc = 0x8232F474; continue 'dispatch;
            }
            0x8232F474 => {
    //   block [0x8232F474..0x8232F52C)
	// 8232F474: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F478: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F47C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F480: C3AB22A4  lfs f29, 0x22a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8868 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8232F484: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8232F488: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232F48C: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F490: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232F494: ED6C0772  fmuls f11, f12, f29
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[29].f64) as f32) as f64);
	// 8232F498: D17F0038  stfs f11, 0x38(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8232F49C: ED8B0028  fsubs f12, f11, f0
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 8232F4A0: FD606210  fabs f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 8232F4A4: FF0BD000  fcmpu cr6, f11, f26
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[26].f64);
	// 8232F4A8: 419801E8  blt cr6, 0x8232f690
	if ctx.cr[6].lt {
	pc = 0x8232F690; continue 'dispatch;
	}
	// 8232F4AC: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F4B0: EF9F6024  fdivs f28, f31, f12
	ctx.f[28].f64 = ((ctx.f[31].f64 / ctx.f[12].f64) as f32) as f64;
	// 8232F4B4: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232F4B8: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232F4BC: C16B0010  lfs f11, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232F4C0: EC0B0778  fmsubs f0, f11, f29, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 8232F4C4: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 8232F4C8: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8232F4CC: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232F4D0: FC0B06EE  fsel f0, f11, f27, f0
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[27].f64 } else { ctx.f[0].f64 };
	// 8232F4D4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8232F4D8: ED7F0028  fsubs f11, f31, f0
	ctx.f[11].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8232F4DC: FC0BF82E  fsel f0, f11, f0, f31
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[31].f64 };
	// 8232F4E0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8232F4E4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8232F4E8: 40980044  bge cr6, 0x8232f52c
	if !ctx.cr[6].lt {
	pc = 0x8232F52C; continue 'dispatch;
	}
	// 8232F4EC: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 8232F4F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F4F4: EFC00372  fmuls f30, f0, f13
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232F4F8: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F4FC: D3DF0020  stfs f30, 0x20(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8232F500: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232F504: 4BDEDFC5  bl 0x8211d4c8
	ctx.lr = 0x8232F508;
	sub_8211D4C8(ctx, base);
	// 8232F508: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F50C: C1BF0018  lfs f13, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F510: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 8232F514: C00B2200  lfs f0, 0x2200(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F518: EC01F03C  fnmsubs f0, f1, f0, f30
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 8232F51C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8232F520: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232F524: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8232F528: 4800000C  b 0x8232f534
	pc = 0x8232F534; continue 'dispatch;
            }
            0x8232F52C => {
    //   block [0x8232F52C..0x8232F534)
	// 8232F52C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232F530: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x8232F534; continue 'dispatch;
            }
            0x8232F534 => {
    //   block [0x8232F534..0x8232F548)
	// 8232F534: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232F538: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232F53C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8232F540: 41990008  bgt cr6, 0x8232f548
	if ctx.cr[6].gt {
	pc = 0x8232F548; continue 'dispatch;
	}
	// 8232F544: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8232F548; continue 'dispatch;
            }
            0x8232F548 => {
    //   block [0x8232F548..0x8232F5AC)
	// 8232F548: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8232F54C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232F550: 815E0054  lwz r10, 0x54(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F554: C00A001C  lfs f0, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F558: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 8232F55C: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8232F560: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 8232F564: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8232F568: 419A0044  beq cr6, 0x8232f5ac
	if ctx.cr[6].eq {
	pc = 0x8232F5AC; continue 'dispatch;
	}
	// 8232F56C: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 8232F570: 4099003C  ble cr6, 0x8232f5ac
	if !ctx.cr[6].gt {
	pc = 0x8232F5AC; continue 'dispatch;
	}
	// 8232F574: 815E0054  lwz r10, 0x54(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F578: C00A0018  lfs f0, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F57C: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 8232F580: 4099002C  ble cr6, 0x8232f5ac
	if !ctx.cr[6].gt {
	pc = 0x8232F5AC; continue 'dispatch;
	}
	// 8232F584: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 8232F588: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 8232F58C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8232F590: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 8232F594: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8232F598: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8232F59C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8232F5A0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232F5A4: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8232F5A8: 48000010  b 0x8232f5b8
	pc = 0x8232F5B8; continue 'dispatch;
            }
            0x8232F5AC => {
    //   block [0x8232F5AC..0x8232F5B8)
	// 8232F5AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232F5B0: D37F0048  stfs f27, 0x48(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8232F5B4: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x8232F5B8; continue 'dispatch;
            }
            0x8232F5B8 => {
    //   block [0x8232F5B8..0x8232F5CC)
	// 8232F5B8: 389F0070  addi r4, r31, 0x70
	ctx.r[4].s64 = ctx.r[31].s64 + 112;
	// 8232F5BC: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 8232F5C0: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 8232F5C4: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8232F5C8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8232F5CC; continue 'dispatch;
            }
            0x8232F5CC => {
    //   block [0x8232F5CC..0x8232F61C)
	// 8232F5CC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8232F5D0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8232F5D4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8232F5D8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8232F5DC: 4200FFF0  bdnz 0x8232f5cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8232F5CC; continue 'dispatch;
	}
	// 8232F5E0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8232F5E4: 480393E5  bl 0x823689c8
	ctx.lr = 0x8232F5E8;
	sub_823689C8(ctx, base);
	// 8232F5E8: 811E0050  lwz r8, 0x50(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232F5EC: 81480008  lwz r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232F5F0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8232F5F4: 4099009C  ble cr6, 0x8232f690
	if !ctx.cr[6].gt {
	pc = 0x8232F690; continue 'dispatch;
	}
	// 8232F5F8: 897E0004  lbz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232F5FC: 392A0003  addi r9, r10, 3
	ctx.r[9].s64 = ctx.r[10].s64 + 3;
	// 8232F600: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232F604: 4198008C  blt cr6, 0x8232f690
	if ctx.cr[6].lt {
	pc = 0x8232F690; continue 'dispatch;
	}
	// 8232F608: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8232F60C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232F610: 419A0040  beq cr6, 0x8232f650
	if ctx.cr[6].eq {
	pc = 0x8232F650; continue 'dispatch;
	}
	// 8232F614: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 8232F618: 393F0058  addi r9, r31, 0x58
	ctx.r[9].s64 = ctx.r[31].s64 + 88;
	pc = 0x8232F61C; continue 'dispatch;
            }
            0x8232F61C => {
    //   block [0x8232F61C..0x8232F650)
	// 8232F61C: 88FE0004  lbz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232F620: 38CB0003  addi r6, r11, 3
	ctx.r[6].s64 = ctx.r[11].s64 + 3;
	// 8232F624: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 8232F628: 40980028  bge cr6, 0x8232f650
	if !ctx.cr[6].lt {
	pc = 0x8232F650; continue 'dispatch;
	}
	// 8232F62C: 7D0A402E  lwzx r8, r10, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8232F630: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8232F634: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8232F638: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8232F63C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 8232F640: 811E0050  lwz r8, 0x50(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232F644: 80E80008  lwz r7, 8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232F648: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 8232F64C: 4198FFD0  blt cr6, 0x8232f61c
	if ctx.cr[6].lt {
	pc = 0x8232F61C; continue 'dispatch;
	}
	pc = 0x8232F650; continue 'dispatch;
            }
            0x8232F650 => {
    //   block [0x8232F650..0x8232F680)
	// 8232F650: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232F654: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232F658: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8232F65C: 40980040  bge cr6, 0x8232f69c
	if !ctx.cr[6].lt {
	pc = 0x8232F69C; continue 'dispatch;
	}
	// 8232F660: 392B0016  addi r9, r11, 0x16
	ctx.r[9].s64 = ctx.r[11].s64 + 22;
	// 8232F664: 214B0003  subfic r10, r11, 3
	ctx.xer.ca = ctx.r[11].u32 <= 3 as u32;
	ctx.r[10].s64 = (3 as i64) - ctx.r[11].s64;
	// 8232F668: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8232F66C: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 8232F670: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 8232F674: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232F678: 419A0024  beq cr6, 0x8232f69c
	if ctx.cr[6].eq {
	pc = 0x8232F69C; continue 'dispatch;
	}
	// 8232F67C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x8232F680; continue 'dispatch;
            }
            0x8232F680 => {
    //   block [0x8232F680..0x8232F690)
	// 8232F680: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8232F684: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8232F688: 4200FFF8  bdnz 0x8232f680
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8232F680; continue 'dispatch;
	}
	// 8232F68C: 48000010  b 0x8232f69c
	pc = 0x8232F69C; continue 'dispatch;
            }
            0x8232F690 => {
    //   block [0x8232F690..0x8232F69C)
	// 8232F690: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F694: C00B2074  lfs f0, 0x2074(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F698: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x8232F69C; continue 'dispatch;
            }
            0x8232F69C => {
    //   block [0x8232F69C..0x8232F6BC)
	// 8232F69C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8232F6A0: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8232F6A4: 48206989  bl 0x8253602c
	ctx.lr = 0x8232F6A8;
	sub_82535FFC(ctx, base);
	// 8232F6A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232F6AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232F6B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232F6B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232F6B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232F6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232F6C0 size=832
    let mut pc: u32 = 0x8232F6C0;
    'dispatch: loop {
        match pc {
            0x8232F6C0 => {
    //   block [0x8232F6C0..0x8232F748)
	// 8232F6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232F6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232F6C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232F6CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232F6D0: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8232F6D4: 4820690D  bl 0x82535fe0
	ctx.lr = 0x8232F6D8;
	sub_82535FB0(ctx, base);
	// 8232F6D8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232F6DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232F6E0: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 8232F6E4: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 8232F6E8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 8232F6EC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8232F6F0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232F6F4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232F6F8: C3C71FF8  lfs f30, 0x1ff8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8232F6FC: C388BA38  lfs f28, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8232F700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232F704: C349BFFC  lfs f26, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8232F708: C36A2490  lfs f27, 0x2490(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9360 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 8232F70C: 409A00B0  bne cr6, 0x8232f7bc
	if !ctx.cr[6].eq {
	pc = 0x8232F7BC; continue 'dispatch;
	}
	// 8232F710: C01F0030  lfs f0, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F714: EC1D002A  fadds f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64;
	// 8232F718: C1BF002C  lfs f13, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F71C: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232F720: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8232F724: 4099020C  ble cr6, 0x8232f930
	if !ctx.cr[6].gt {
	pc = 0x8232F930; continue 'dispatch;
	}
	// 8232F728: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 8232F72C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8232F730: 396B9B00  addi r11, r11, -0x6500
	ctx.r[11].s64 = ctx.r[11].s64 + -25856;
	// 8232F734: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8232F738: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232F73C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8232F740: 40990008  ble cr6, 0x8232f748
	if !ctx.cr[6].gt {
	pc = 0x8232F748; continue 'dispatch;
	}
	// 8232F744: 4803277D  bl 0x82361ec0
	ctx.lr = 0x8232F748;
	sub_82361EC0(ctx, base);
	pc = 0x8232F748; continue 'dispatch;
            }
            0x8232F748 => {
    //   block [0x8232F748..0x8232F79C)
	// 8232F748: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F74C: C1BF0040  lfs f13, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F750: C19F001C  lfs f12, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232F754: 556AF87E  srwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8232F758: C17F0048  lfs f11, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232F75C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F760: D3DF004C  stfs f30, 0x4c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 8232F764: D17F0044  stfs f11, 0x44(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8232F768: FF0CF000  fcmpu cr6, f12, f30
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[30].f64);
	// 8232F76C: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8232F770: C00B2038  lfs f0, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F774: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8232F778: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8232F77C: C01F0030  lfs f0, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F780: C1BF002C  lfs f13, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F784: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232F788: 409A0014  bne cr6, 0x8232f79c
	if !ctx.cr[6].eq {
	pc = 0x8232F79C; continue 'dispatch;
	}
	// 8232F78C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232F790: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F794: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8232F798: 48000190  b 0x8232f928
	pc = 0x8232F928; continue 'dispatch;
            }
            0x8232F79C => {
    //   block [0x8232F79C..0x8232F7BC)
	// 8232F79C: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F7A0: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232F7A4: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8232F7A8: EC3F06F2  fmuls f1, f31, f27
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[27].f64) as f32) as f64);
	// 8232F7AC: 4BDEDD1D  bl 0x8211d4c8
	ctx.lr = 0x8232F7B0;
	sub_8211D4C8(ctx, base);
	// 8232F7B0: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 8232F7B4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8232F7B8: 48000160  b 0x8232f918
	pc = 0x8232F918; continue 'dispatch;
            }
            0x8232F7BC => {
    //   block [0x8232F7BC..0x8232F7FC)
	// 8232F7BC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8232F7C0: 409A0090  bne cr6, 0x8232f850
	if !ctx.cr[6].eq {
	pc = 0x8232F850; continue 'dispatch;
	}
	// 8232F7C4: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F7C8: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F7CC: EC0D077A  fmadds f0, f13, f29, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64);
	// 8232F7D0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8232F7D4: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 8232F7D8: 40990158  ble cr6, 0x8232f930
	if !ctx.cr[6].gt {
	pc = 0x8232F930; continue 'dispatch;
	}
	// 8232F7DC: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8232F7E0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8232F7E4: 396B9B00  addi r11, r11, -0x6500
	ctx.r[11].s64 = ctx.r[11].s64 + -25856;
	// 8232F7E8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8232F7EC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232F7F0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8232F7F4: 40990008  ble cr6, 0x8232f7fc
	if !ctx.cr[6].gt {
	pc = 0x8232F7FC; continue 'dispatch;
	}
	// 8232F7F8: 480326C9  bl 0x82361ec0
	ctx.lr = 0x8232F7FC;
	sub_82361EC0(ctx, base);
	pc = 0x8232F7FC; continue 'dispatch;
            }
            0x8232F7FC => {
    //   block [0x8232F7FC..0x8232F850)
	// 8232F7FC: C1BF000C  lfs f13, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F800: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F804: EDADE028  fsubs f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[28].f64) as f32) as f64);
	// 8232F808: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8232F80C: C19F0048  lfs f12, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232F810: C17F0014  lfs f11, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232F814: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232F818: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F81C: C15F0038  lfs f10, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8232F820: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8232F824: C13F0040  lfs f9, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8232F828: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8232F82C: D3DF004C  stfs f30, 0x4c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 8232F830: D13F003C  stfs f9, 0x3c(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8232F834: D19F0044  stfs f12, 0x44(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8232F838: D3DF000C  stfs f30, 0xc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8232F83C: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 8232F840: D15F0034  stfs f10, 0x34(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232F844: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232F848: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8232F84C: 480000E4  b 0x8232f930
	pc = 0x8232F930; continue 'dispatch;
            }
            0x8232F850 => {
    //   block [0x8232F850..0x8232F89C)
	// 8232F850: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F854: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F858: EFED077A  fmadds f31, f13, f29, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64);
	// 8232F85C: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8232F860: FF1FD000  fcmpu cr6, f31, f26
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[26].f64);
	// 8232F864: 409900AC  ble cr6, 0x8232f910
	if !ctx.cr[6].gt {
	pc = 0x8232F910; continue 'dispatch;
	}
	// 8232F868: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F86C: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 8232F870: 4098002C  bge cr6, 0x8232f89c
	if !ctx.cr[6].lt {
	pc = 0x8232F89C; continue 'dispatch;
	}
	// 8232F874: EC1FD028  fsubs f0, f31, f26
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[26].f64) as f32) as f64);
	// 8232F878: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F87C: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232F880: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8232F884: ED8C06B2  fmuls f12, f12, f26
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[26].f64) as f32) as f64);
	// 8232F888: C17F0010  lfs f11, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232F88C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8232F890: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8232F894: EC0062FA  fmadds f0, f0, f11, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 8232F898: 48000094  b 0x8232f92c
	pc = 0x8232F92C; continue 'dispatch;
            }
            0x8232F89C => {
    //   block [0x8232F89C..0x8232F8BC)
	// 8232F89C: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8232F8A0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8232F8A4: 396B9B00  addi r11, r11, -0x6500
	ctx.r[11].s64 = ctx.r[11].s64 + -25856;
	// 8232F8A8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8232F8AC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8232F8B0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8232F8B4: 40990008  ble cr6, 0x8232f8bc
	if !ctx.cr[6].gt {
	pc = 0x8232F8BC; continue 'dispatch;
	}
	// 8232F8B8: 48032609  bl 0x82361ec0
	ctx.lr = 0x8232F8BC;
	sub_82361EC0(ctx, base);
	pc = 0x8232F8BC; continue 'dispatch;
            }
            0x8232F8BC => {
    //   block [0x8232F8BC..0x8232F910)
	// 8232F8BC: C1BF0020  lfs f13, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F8C0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232F8C4: EDADD028  fsubs f13, f13, f26
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[26].f64) as f32) as f64);
	// 8232F8C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8232F8CC: C19F0048  lfs f12, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232F8D0: C17F0028  lfs f11, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8232F8D4: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8232F8D8: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F8DC: C15F0038  lfs f10, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8232F8E0: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8232F8E4: C13F0040  lfs f9, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8232F8E8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8232F8EC: D3DF004C  stfs f30, 0x4c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 8232F8F0: D13F003C  stfs f9, 0x3c(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8232F8F4: D19F0044  stfs f12, 0x44(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8232F8F8: D3DF000C  stfs f30, 0xc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8232F8FC: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 8232F900: D15F0034  stfs f10, 0x34(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232F904: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232F908: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8232F90C: 48000024  b 0x8232f930
	pc = 0x8232F930; continue 'dispatch;
            }
            0x8232F910 => {
    //   block [0x8232F910..0x8232F918)
	// 8232F910: EC3F06F2  fmuls f1, f31, f27
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[27].f64) as f32) as f64);
	// 8232F914: 4BDEDBB5  bl 0x8211d4c8
	ctx.lr = 0x8232F918;
	sub_8211D4C8(ctx, base);
	pc = 0x8232F918; continue 'dispatch;
            }
            0x8232F918 => {
    //   block [0x8232F918..0x8232F928)
	// 8232F918: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F91C: C1BF0018  lfs f13, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F920: C00B2200  lfs f0, 0x2200(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F924: EC01F83C  fnmsubs f0, f1, f0, f31
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	pc = 0x8232F928; continue 'dispatch;
            }
            0x8232F928 => {
    //   block [0x8232F928..0x8232F92C)
	// 8232F928: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x8232F92C; continue 'dispatch;
            }
            0x8232F92C => {
    //   block [0x8232F92C..0x8232F930)
	// 8232F92C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x8232F930; continue 'dispatch;
            }
            0x8232F930 => {
    //   block [0x8232F930..0x8232F9A0)
	// 8232F930: 83DF0050  lwz r30, 0x50(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232F934: FD60F090  fmr f11, f30
	ctx.f[11].f64 = ctx.f[30].f64;
	// 8232F938: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8232F93C: 419A0064  beq cr6, 0x8232f9a0
	if ctx.cr[6].eq {
	pc = 0x8232F9A0; continue 'dispatch;
	}
	// 8232F940: C3FF004C  lfs f31, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8232F944: C3DF003C  lfs f30, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8232F948: EC3F06F2  fmuls f1, f31, f27
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[27].f64) as f32) as f64);
	// 8232F94C: 4BDEDB7D  bl 0x8211d4c8
	ctx.lr = 0x8232F950;
	sub_8211D4C8(ctx, base);
	// 8232F950: C1BF0044  lfs f13, 0x44(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F954: EC0DFF7A  fmadds f0, f13, f29, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 + ctx.f[31].f64) as f32) as f64);
	// 8232F958: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 8232F95C: ED6107B2  fmuls f11, f1, f30
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8232F960: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 8232F964: FF0CE000  fcmpu cr6, f12, f28
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[28].f64);
	// 8232F968: 40990038  ble cr6, 0x8232f9a0
	if !ctx.cr[6].gt {
	pc = 0x8232F9A0; continue 'dispatch;
	}
	// 8232F96C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232F970: ED5E06B2  fmuls f10, f30, f26
	ctx.f[10].f64 = (((ctx.f[30].f64 * ctx.f[26].f64) as f32) as f64);
	// 8232F974: 395EFFFF  addi r10, r30, -1
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	// 8232F978: D15F003C  stfs f10, 0x3c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8232F97C: C18B22E8  lfs f12, 0x22e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8936 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232F980: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 8232F984: D1BF0044  stfs f13, 0x44(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8232F988: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8232F98C: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8232F990: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8232F994: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8232F998: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8232F99C: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	pc = 0x8232F9A0; continue 'dispatch;
            }
            0x8232F9A0 => {
    //   block [0x8232F9A0..0x8232FA00)
	// 8232F9A0: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232F9A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8232F9A8: C1BF0038  lfs f13, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232F9AC: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8232F9B0: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8232F9B4: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 8232F9B8: EC2D033A  fmadds f1, f13, f12, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 8232F9BC: 480385FD  bl 0x82367fb8
	ctx.lr = 0x8232F9C0;
	sub_82367FB8(ctx, base);
	// 8232F9C0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8232F9C4: 389F0070  addi r4, r31, 0x70
	ctx.r[4].s64 = ctx.r[31].s64 + 112;
	// 8232F9C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8232F9CC: 48038425  bl 0x82367df0
	ctx.lr = 0x8232F9D0;
	sub_82367DF0(ctx, base);
	// 8232F9D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8232F9D4: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 8232F9D8: 809F00F0  lwz r4, 0xf0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 8232F9DC: 48038355  bl 0x82367d30
	ctx.lr = 0x8232F9E0;
	sub_82367D30(ctx, base);
	// 8232F9E0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8232F9E4: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8232F9E8: 48206645  bl 0x8253602c
	ctx.lr = 0x8232F9EC;
	sub_82535FFC(ctx, base);
	// 8232F9EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232F9F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232F9F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232F9F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232F9FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232FA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232FA00 size=208
    let mut pc: u32 = 0x8232FA00;
    'dispatch: loop {
        match pc {
            0x8232FA00 => {
    //   block [0x8232FA00..0x8232FAB4)
	// 8232FA00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232FA04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232FA08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232FA0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232FA10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232FA14: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8232FA18: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8232FA1C: 3C800410  lis r4, 0x410
	ctx.r[4].s64 = 68157440;
	// 8232FA20: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232FA24: 3CE00000  lis r7, 0
	ctx.r[7].s64 = 0;
	// 8232FA28: C1A91FF8  lfs f13, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8232FA2C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8232FA30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232FA34: 609E0010  ori r30, r4, 0x10
	ctx.r[30].u64 = ctx.r[4].u64 | 16;
	// 8232FA38: 394ADC68  addi r10, r10, -0x2398
	ctx.r[10].s64 = ctx.r[10].s64 + -9112;
	// 8232FA3C: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 8232FA40: C009BA38  lfs f0, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232FA44: 60E7C80D  ori r7, r7, 0xc80d
	ctx.r[7].u64 = ctx.r[7].u64 | 51213;
	// 8232FA48: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8232FA4C: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8232FA50: 3CC01000  lis r6, 0x1000
	ctx.r[6].s64 = 268435456;
	// 8232FA54: D1BF0014  stfs f13, 0x14(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8232FA58: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8232FA5C: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8232FA60: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8232FA64: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8232FA68: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8232FA6C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8232FA70: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8232FA74: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 8232FA78: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8232FA7C: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 8232FA80: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8232FA84: 911F003C  stw r8, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 8232FA88: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8232FA8C: 90FF0050  stw r7, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 8232FA90: 90DF0054  stw r6, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 8232FA94: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8232FA98: 48059A09  bl 0x823894a0
	ctx.lr = 0x8232FA9C;
	sub_823894A0(ctx, base);
	// 8232FA9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232FAA0: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 8232FAA4: 409A0010  bne cr6, 0x8232fab4
	if !ctx.cr[6].eq {
	pc = 0x8232FAB4; continue 'dispatch;
	}
	// 8232FAA8: 48059A71  bl 0x82389518
	ctx.lr = 0x8232FAAC;
	sub_82389518(ctx, base);
	// 8232FAAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8232FAB0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x8232FAB4; continue 'dispatch;
            }
            0x8232FAB4 => {
    //   block [0x8232FAB4..0x8232FAD0)
	// 8232FAB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232FAB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232FABC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232FAC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232FAC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232FAC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232FACC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232FAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232FAD0 size=268
    let mut pc: u32 = 0x8232FAD0;
    'dispatch: loop {
        match pc {
            0x8232FAD0 => {
    //   block [0x8232FAD0..0x8232FB44)
	// 8232FAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232FAD4: 482055E5  bl 0x825350b8
	ctx.lr = 0x8232FAD8;
	sub_82535080(ctx, base);
	// 8232FAD8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232FADC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8232FAE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8232FAE4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232FAE8: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8232FAEC: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 8232FAF0: 48038241  bl 0x82367d30
	ctx.lr = 0x8232FAF4;
	sub_82367D30(ctx, base);
	// 8232FAF4: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 8232FAF8: 3BEBD180  addi r31, r11, -0x2e80
	ctx.r[31].s64 = ctx.r[11].s64 + -11904;
	// 8232FAFC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8232FB00: 7C005FEC  dcbz 0, r11
	ea.u32 = ctx.r[11].u32;
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FB04: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8232FB08: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8232FB0C: 394B0080  addi r10, r11, 0x80
	ctx.r[10].s64 = ctx.r[11].s64 + 128;
	// 8232FB10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232FB14: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 8232FB18: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8232FB1C: 3B8A063C  addi r28, r10, 0x63c
	ctx.r[28].s64 = ctx.r[10].s64 + 1596;
	// 8232FB20: 419A0024  beq cr6, 0x8232fb44
	if ctx.cr[6].eq {
	pc = 0x8232FB44; continue 'dispatch;
	}
	// 8232FB24: 3D408239  lis r10, -0x7dc7
	ctx.r[10].s64 = -2110193664;
	// 8232FB28: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8232FB2C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8232FB30: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8232FB34: 394A8E60  addi r10, r10, -0x71a0
	ctx.r[10].s64 = ctx.r[10].s64 + -29088;
	// 8232FB38: 93AB000C  stw r29, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 8232FB3C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8232FB40: 48000008  b 0x8232fb48
	pc = 0x8232FB48; continue 'dispatch;
            }
            0x8232FB44 => {
    //   block [0x8232FB44..0x8232FB48)
	// 8232FB44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x8232FB48; continue 'dispatch;
            }
            0x8232FB48 => {
    //   block [0x8232FB48..0x8232FBDC)
	// 8232FB48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232FB4C: 480704E5  bl 0x823a0030
	ctx.lr = 0x8232FB50;
	sub_823A0030(ctx, base);
	// 8232FB50: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8232FB54: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232FBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232FBE0 size=16
    let mut pc: u32 = 0x8232FBE0;
    'dispatch: loop {
        match pc {
            0x8232FBE0 => {
    //   block [0x8232FBE0..0x8232FBF0)
	// 8232FBE0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232FBE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8232FBE8: 914B0170  stw r10, 0x170(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(368 as u32), ctx.r[10].u32 ) };
	// 8232FBEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232FBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8232FBF0 size=16
    let mut pc: u32 = 0x8232FBF0;
    'dispatch: loop {
        match pc {
            0x8232FBF0 => {
    //   block [0x8232FBF0..0x8232FC00)
	// 8232FBF0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8232FBF4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8232FBF8: 914B0170  stw r10, 0x170(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(368 as u32), ctx.r[10].u32 ) };
	// 8232FBFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232FC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8232FC00 size=148
    let mut pc: u32 = 0x8232FC00;
    'dispatch: loop {
        match pc {
            0x8232FC00 => {
    //   block [0x8232FC00..0x8232FC40)
	// 8232FC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232FC04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8232FC08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8232FC0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8232FC10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232FC14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232FC18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232FC1C: 396BDCA0  addi r11, r11, -0x2360
	ctx.r[11].s64 = ctx.r[11].s64 + -9056;
	// 8232FC20: 387F0168  addi r3, r31, 0x168
	ctx.r[3].s64 = ctx.r[31].s64 + 360;
	// 8232FC24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8232FC28: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232FC2C: 48005975  bl 0x823355a0
	ctx.lr = 0x8232FC30;
	sub_823355A0(ctx, base);
	// 8232FC30: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 8232FC34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8232FC38: 419A0008  beq cr6, 0x8232fc40
	if ctx.cr[6].eq {
	pc = 0x8232FC40; continue 'dispatch;
	}
	// 8232FC3C: 4BDED41D  bl 0x8211d058
	ctx.lr = 0x8232FC40;
	sub_8211D058(ctx, base);
	pc = 0x8232FC40; continue 'dispatch;
            }
            0x8232FC40 => {
    //   block [0x8232FC40..0x8232FC7C)
	// 8232FC40: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8232FC44: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8232FC48: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 8232FC4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232FC50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8232FC54: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8232FC58: 419A0024  beq cr6, 0x8232fc7c
	if ctx.cr[6].eq {
	pc = 0x8232FC7C; continue 'dispatch;
	}
	// 8232FC5C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8232FC60: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8232FC64: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8232FC68: 409A0014  bne cr6, 0x8232fc7c
	if !ctx.cr[6].eq {
	pc = 0x8232FC7C; continue 'dispatch;
	}
	// 8232FC6C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8232FC70: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8232FC74: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8232FC78: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x8232FC7C; continue 'dispatch;
            }
            0x8232FC7C => {
    //   block [0x8232FC7C..0x8232FC94)
	// 8232FC7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8232FC80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8232FC84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8232FC88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8232FC8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8232FC90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8232FC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8232FC98 size=1016
    let mut pc: u32 = 0x8232FC98;
    'dispatch: loop {
        match pc {
            0x8232FC98 => {
    //   block [0x8232FC98..0x8232FCF0)
	// 8232FC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8232FC9C: 48205419  bl 0x825350b4
	ctx.lr = 0x8232FCA0;
	sub_82535080(ctx, base);
	// 8232FCA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8232FCA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8232FCA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8232FCAC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8232FCB0: 38CBDC94  addi r6, r11, -0x236c
	ctx.r[6].s64 = ctx.r[11].s64 + -9068;
	// 8232FCB4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8232FCB8: 3B9F0080  addi r28, r31, 0x80
	ctx.r[28].s64 = ctx.r[31].s64 + 128;
	// 8232FCBC: 3CA00004  lis r5, 4
	ctx.r[5].s64 = 262144;
	// 8232FCC0: 386BDBE0  addi r3, r11, -0x2420
	ctx.r[3].s64 = ctx.r[11].s64 + -9248;
	// 8232FCC4: 9BBF001E  stb r29, 0x1e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(30 as u32), ctx.r[29].u8 ) };
	// 8232FCC8: 60A54000  ori r5, r5, 0x4000
	ctx.r[5].u64 = ctx.r[5].u64 | 16384;
	// 8232FCCC: 9BBF001C  stb r29, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 8232FCD0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8232FCD4: 4BEC5615  bl 0x821f52e8
	ctx.lr = 0x8232FCD8;
	sub_821F52E8(ctx, base);
	// 8232FCD8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232FCDC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8232FCE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232FCE4: 409A000C  bne cr6, 0x8232fcf0
	if !ctx.cr[6].eq {
	pc = 0x8232FCF0; continue 'dispatch;
	}
	// 8232FCE8: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 8232FCEC: 4800002C  b 0x8232fd18
	pc = 0x8232FD18; continue 'dispatch;
            }
            0x8232FCF0 => {
    //   block [0x8232FCF0..0x8232FD08)
	// 8232FCF0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232FCF4: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232FCF8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232FCFC: 419A000C  beq cr6, 0x8232fd08
	if ctx.cr[6].eq {
	pc = 0x8232FD08; continue 'dispatch;
	}
	// 8232FD00: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 8232FD04: 48000014  b 0x8232fd18
	pc = 0x8232FD18; continue 'dispatch;
            }
            0x8232FD08 => {
    //   block [0x8232FD08..0x8232FD18)
	// 8232FD08: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232FD0C: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8232FD10: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 8232FD14: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	pc = 0x8232FD18; continue 'dispatch;
            }
            0x8232FD18 => {
    //   block [0x8232FD18..0x8232FD2C)
	// 8232FD18: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8232FD1C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 8232FD20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232FD24: 419A0008  beq cr6, 0x8232fd2c
	if ctx.cr[6].eq {
	pc = 0x8232FD2C; continue 'dispatch;
	}
	// 8232FD28: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8232FD2C; continue 'dispatch;
            }
            0x8232FD2C => {
    //   block [0x8232FD2C..0x8232FD50)
	// 8232FD2C: 3969007F  addi r11, r9, 0x7f
	ctx.r[11].s64 = ctx.r[9].s64 + 127;
	// 8232FD30: 3D490004  addis r10, r9, 4
	ctx.r[10].s64 = ctx.r[9].s64 + 262144;
	// 8232FD34: 55680030  rlwinm r8, r11, 0, 0, 0x18
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8232FD38: 554B0030  rlwinm r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8232FD3C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232FD40: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 8232FD44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8232FD48: 419A0008  beq cr6, 0x8232fd50
	if ctx.cr[6].eq {
	pc = 0x8232FD50; continue 'dispatch;
	}
	// 8232FD4C: 7C004A2C  dcbt 0, r9
	pc = 0x8232FD50; continue 'dispatch;
            }
            0x8232FD50 => {
    //   block [0x8232FD50..0x8232FD5C)
	// 8232FD50: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8232FD54: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 8232FD58: 41980080  blt cr6, 0x8232fdd8
	if ctx.cr[6].lt {
	pc = 0x8232FDD8; continue 'dispatch;
	}
	pc = 0x8232FD5C; continue 'dispatch;
            }
            0x8232FD5C => {
    //   block [0x8232FD5C..0x8232FDD8)
	// 8232FD5C: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 8232FD60: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FD64: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232FD68: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 8232FD6C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FD70: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 8232FD74: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232FD78: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FD7C: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 8232FD80: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232FD84: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FD88: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 8232FD8C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232FD90: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FD94: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 8232FD98: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232FD9C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FDA0: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 8232FDA4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232FDA8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FDAC: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 8232FDB0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232FDB4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FDB8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8232FDBC: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 8232FDC0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8232FDC4: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 8232FDC8: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 8232FDCC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8232FDD0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8232FDD4: 4098FF88  bge cr6, 0x8232fd5c
	if !ctx.cr[6].lt {
	pc = 0x8232FD5C; continue 'dispatch;
	}
	pc = 0x8232FDD8; continue 'dispatch;
            }
            0x8232FDD8 => {
    //   block [0x8232FDD8..0x8232FE1C)
	// 8232FDD8: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 8232FDDC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8232FDE0: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 8232FDE4: 41990088  bgt cr6, 0x8232fe6c
	if ctx.cr[6].gt {
	pc = 0x8232FE6C; continue 'dispatch;
	}
	// 8232FDE8: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 8232FDEC: 398CFE00  addi r12, r12, -0x200
	ctx.r[12].s64 = ctx.r[12].s64 + -512;
	// 8232FDF0: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8232FDF4: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8232FDF8: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8232FDFC: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x8232FE64; continue 'dispatch;
		},
		1 => {
	pc = 0x8232FE58; continue 'dispatch;
		},
		2 => {
	pc = 0x8232FE4C; continue 'dispatch;
		},
		3 => {
	pc = 0x8232FE40; continue 'dispatch;
		},
		4 => {
	pc = 0x8232FE34; continue 'dispatch;
		},
		5 => {
	pc = 0x8232FE28; continue 'dispatch;
		},
		6 => {
	pc = 0x8232FE1C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8232FE00: 8232FE64  lwz r17, -0x19c(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-412 as u32) ) } as u64;
	// 8232FE04: 8232FE58  lwz r17, -0x1a8(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-424 as u32) ) } as u64;
	// 8232FE08: 8232FE4C  lwz r17, -0x1b4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-436 as u32) ) } as u64;
	// 8232FE0C: 8232FE40  lwz r17, -0x1c0(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-448 as u32) ) } as u64;
	// 8232FE10: 8232FE34  lwz r17, -0x1cc(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-460 as u32) ) } as u64;
	// 8232FE14: 8232FE28  lwz r17, -0x1d8(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-472 as u32) ) } as u64;
	// 8232FE18: 8232FE1C  lwz r17, -0x1e4(r18)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-484 as u32) ) } as u64;
            }
            0x8232FE1C => {
    //   block [0x8232FE1C..0x8232FE28)
	// 8232FE1C: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 8232FE20: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FE24: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8232FE28; continue 'dispatch;
            }
            0x8232FE28 => {
    //   block [0x8232FE28..0x8232FE34)
	// 8232FE28: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 8232FE2C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FE30: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8232FE34; continue 'dispatch;
            }
            0x8232FE34 => {
    //   block [0x8232FE34..0x8232FE40)
	// 8232FE34: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 8232FE38: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FE3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8232FE40; continue 'dispatch;
            }
            0x8232FE40 => {
    //   block [0x8232FE40..0x8232FE4C)
	// 8232FE40: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 8232FE44: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FE48: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8232FE4C; continue 'dispatch;
            }
            0x8232FE4C => {
    //   block [0x8232FE4C..0x8232FE58)
	// 8232FE4C: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 8232FE50: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FE54: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8232FE58; continue 'dispatch;
            }
            0x8232FE58 => {
    //   block [0x8232FE58..0x8232FE64)
	// 8232FE58: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 8232FE5C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8232FE60: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8232FE64; continue 'dispatch;
            }
            0x8232FE64 => {
    //   block [0x8232FE64..0x8232FE6C)
	// 8232FE64: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 8232FE68: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	pc = 0x8232FE6C; continue 'dispatch;
            }
            0x8232FE6C => {
    //   block [0x8232FE6C..0x8232FE80)
	// 8232FE6C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232FE70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8232FE74: 409A000C  bne cr6, 0x8232fe80
	if !ctx.cr[6].eq {
	pc = 0x8232FE80; continue 'dispatch;
	}
	// 8232FE78: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8232FE7C: 4800002C  b 0x8232fea8
	pc = 0x8232FEA8; continue 'dispatch;
            }
            0x8232FE80 => {
    //   block [0x8232FE80..0x8232FE98)
	// 8232FE80: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232FE84: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8232FE88: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8232FE8C: 419A000C  beq cr6, 0x8232fe98
	if ctx.cr[6].eq {
	pc = 0x8232FE98; continue 'dispatch;
	}
	// 8232FE90: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8232FE94: 48000014  b 0x8232fea8
	pc = 0x8232FEA8; continue 'dispatch;
            }
            0x8232FE98 => {
    //   block [0x8232FE98..0x8232FEA8)
	// 8232FE98: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8232FE9C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8232FEA0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8232FEA4: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x8232FEA8; continue 'dispatch;
            }
            0x8232FEA8 => {
    //   block [0x8232FEA8..0x8232FEBC)
	// 8232FEA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8232FEAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8232FEB0: 409A000C  bne cr6, 0x8232febc
	if !ctx.cr[6].eq {
	pc = 0x8232FEBC; continue 'dispatch;
	}
	// 8232FEB4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 8232FEB8: 48000008  b 0x8232fec0
	pc = 0x8232FEC0; continue 'dispatch;
            }
            0x8232FEBC => {
    //   block [0x8232FEBC..0x8232FEC0)
	// 8232FEBC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8232FEC0; continue 'dispatch;
            }
            0x8232FEC0 => {
    //   block [0x8232FEC0..0x82330090)
	// 8232FEC0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8232FEC4: 915F0114  stw r10, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[10].u32 ) };
	// 8232FEC8: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8232FECC: 397F00D0  addi r11, r31, 0xd0
	ctx.r[11].s64 = ctx.r[31].s64 + 208;
	// 8232FED0: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 8232FED4: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 8232FED8: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 8232FEDC: C0091FF8  lfs f0, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8232FEE0: 3D2A0002  addis r9, r10, 2
	ctx.r[9].s64 = ctx.r[10].s64 + 131072;
	// 8232FEE4: 3D403F80  lis r10, 0x3f80
	ctx.r[10].s64 = 1065353216;
	// 8232FEE8: 39294000  addi r9, r9, 0x4000
	ctx.r[9].s64 = ctx.r[9].s64 + 16384;
	// 8232FEEC: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 8232FEF0: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 8232FEF4: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 8232FEF8: 3F600001  lis r27, 1
	ctx.r[27].s64 = 65536;
	// 8232FEFC: 913F0118  stw r9, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[9].u32 ) };
	// 8232FF00: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82330090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82330090 size=2424
    let mut pc: u32 = 0x82330090;
    'dispatch: loop {
        match pc {
            0x82330090 => {
    //   block [0x82330090..0x82330188)
	// 82330090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82330094: 48205009  bl 0x8253509c
	ctx.lr = 0x82330098;
	sub_82535080(ctx, base);
	// 82330098: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 8233009C: 48205F2D  bl 0x82535fc8
	ctx.lr = 0x823300A0;
	sub_82535FB0(ctx, base);
	// 823300A0: 3981FF40  addi r12, r1, -0xc0
	ctx.r[12].s64 = ctx.r[1].s64 + -192;
	// 823300A4: 482092E9  bl 0x8253938c
	ctx.lr = 0x823300A8;
	sub_82539130(ctx, base);
	// 823300A8: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823300AC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 823300B0: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 823300B4: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 823300B8: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 823300BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823300C0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 823300C4: 7FEB542E  lfsx f31, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823300C8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823300CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823300D0: 837E0110  lwz r27, 0x110(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) } as u64;
	// 823300D4: C31E011C  lfs f24, 0x11c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(284 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 823300D8: C01E0138  lfs f0, 0x138(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823300DC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823300E0: C2FE013C  lfs f23, 0x13c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(316 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 823300E4: C2C9BA38  lfs f22, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 823300E8: C3AB1FF8  lfs f29, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 823300EC: C2AABFFC  lfs f21, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 823300F0: 419A0474  beq cr6, 0x82330564
	if ctx.cr[6].eq {
	pc = 0x82330564; continue 'dispatch;
	}
	// 823300F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823300F8: D2C10120  stfs f22, 0x120(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 823300FC: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82330100: D3A10124  stfs f29, 0x124(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82330104: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82330108: D3A10128  stfs f29, 0x128(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 8233010C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82330110: D2C1012C  stfs f22, 0x12c(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82330114: FF200050  fneg f25, f0
	ctx.f[25].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82330118: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8233011C: C1AB2584  lfs f13, 0x2584(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9604 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82330120: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82330124: C288264C  lfs f20, 0x264c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(9804 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 82330128: EF800372  fmuls f28, f0, f13
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8233012C: C3692038  lfs f27, 0x2038(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8248 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82330130: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82330134: C34A2074  lfs f26, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82330138: 7F78DB78  mr r24, r27
	ctx.r[24].u64 = ctx.r[27].u64;
	// 8233013C: 3B2B1E40  addi r25, r11, 0x1e40
	ctx.r[25].s64 = ctx.r[11].s64 + 7744;
	// 82330140: 3AE00004  li r23, 4
	ctx.r[23].s64 = 4;
	// 82330144: 3AA00002  li r21, 2
	ctx.r[21].s64 = 2;
	// 82330148: 3AC00003  li r22, 3
	ctx.r[22].s64 = 3;
	// 8233014C: 817E0118  lwz r11, 0x118(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 82330150: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82330154: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82330158: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8233015C: 41990078  bgt cr6, 0x823301d4
	if ctx.cr[6].gt {
	pc = 0x823301D4; continue 'dispatch;
	}
	// 82330160: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 82330164: 398C0178  addi r12, r12, 0x178
	ctx.r[12].s64 = ctx.r[12].s64 + 376;
	// 82330168: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8233016C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82330170: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82330174: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x823301D0; continue 'dispatch;
		},
		1 => {
	pc = 0x82330188; continue 'dispatch;
		},
		2 => {
	pc = 0x823301A8; continue 'dispatch;
		},
		3 => {
	pc = 0x823301BC; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82330178: 823301D0  lwz r17, 0x1d0(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(464 as u32) ) } as u64;
	// 8233017C: 82330188  lwz r17, 0x188(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(392 as u32) ) } as u64;
	// 82330180: 823301A8  lwz r17, 0x1a8(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(424 as u32) ) } as u64;
	// 82330184: 823301BC  lwz r17, 0x1bc(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(444 as u32) ) } as u64;
            }
            0x82330188 => {
    //   block [0x82330188..0x823301A8)
	// 82330188: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233018C: EC1F057A  fmadds f0, f31, f21, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[21].f64 + ctx.f[0].f64) as f32) as f64);
	// 82330190: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82330194: FF00B000  fcmpu cr6, f0, f22
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[22].f64);
	// 82330198: 4099003C  ble cr6, 0x823301d4
	if !ctx.cr[6].gt {
	pc = 0x823301D4; continue 'dispatch;
	}
	// 8233019C: D2DF0058  stfs f22, 0x58(r31)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 823301A0: 92BF0054  stw r21, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[21].u32 ) };
	// 823301A4: 48000030  b 0x823301d4
	pc = 0x823301D4; continue 'dispatch;
            }
            0x823301A8 => {
    //   block [0x823301A8..0x823301BC)
	// 823301A8: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823301AC: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 823301B0: 40980024  bge cr6, 0x823301d4
	if !ctx.cr[6].lt {
	pc = 0x823301D4; continue 'dispatch;
	}
	// 823301B4: 92DF0054  stw r22, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	// 823301B8: 4800001C  b 0x823301d4
	pc = 0x823301D4; continue 'dispatch;
            }
            0x823301BC => {
    //   block [0x823301BC..0x823301D0)
	// 823301BC: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823301C0: EC1F057C  fnmsubs f0, f31, f21, f0
	ctx.f[0].f64 = -(((ctx.f[31].f64 * ctx.f[21].f64 - ctx.f[0].f64) as f32) as f64);
	// 823301C4: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 823301C8: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 823301CC: 40980008  bge cr6, 0x823301d4
	if !ctx.cr[6].lt {
	pc = 0x823301D4; continue 'dispatch;
	}
	pc = 0x823301D0; continue 'dispatch;
            }
            0x823301D0 => {
    //   block [0x823301D0..0x823301D4)
	// 823301D0: 92FF0054  stw r23, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	pc = 0x823301D4; continue 'dispatch;
            }
            0x823301D4 => {
    //   block [0x823301D4..0x823301FC)
	// 823301D4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 823301D8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 823301DC: 409A0020  bne cr6, 0x823301fc
	if !ctx.cr[6].eq {
	pc = 0x823301FC; continue 'dispatch;
	}
	// 823301E0: 815E0118  lwz r10, 0x118(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 823301E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823301E8: 817E0114  lwz r11, 0x114(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) } as u64;
	// 823301EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823301F0: 7CAAE214  add r5, r10, r28
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 823301F4: 7C8BD214  add r4, r11, r26
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 823301F8: 48000849  bl 0x82330a40
	ctx.lr = 0x823301FC;
	sub_82330A40(ctx, base);
	pc = 0x823301FC; continue 'dispatch;
            }
            0x823301FC => {
    //   block [0x823301FC..0x82330564)
	// 823301FC: E93F0000  ld r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 82330200: 39610140  addi r11, r1, 0x140
	ctx.r[11].s64 = ctx.r[1].s64 + 320;
	// 82330204: E91F0008  ld r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 82330208: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 8233020C: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 82330210: C01F0040  lfs f0, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82330214: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 82330218: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82330564; continue 'dispatch;
            }
            0x82330564 => {
    //   block [0x82330564..0x82330A08)
	// 82330564: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82330568: D3A100A4  stfs f29, 0xa4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8233056C: D2C100AC  stfs f22, 0xac(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82330570: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82330574: D3A100B4  stfs f29, 0xb4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82330578: D2A100B8  stfs f21, 0xb8(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8233057C: D2C100BC  stfs f22, 0xbc(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82330580: C00B2048  lfs f0, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82330584: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82330588: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8233058C: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82330590: D2A100C0  stfs f21, 0xc0(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82330594: D3A100C4  stfs f29, 0xc4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82330598: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8233059C: D2C100CC  stfs f22, 0xcc(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 823305A0: D2A100D0  stfs f21, 0xd0(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 823305A4: D3A100D4  stfs f29, 0xd4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 823305A8: D2A100D8  stfs f21, 0xd8(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 823305AC: D2C100DC  stfs f22, 0xdc(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 823305B0: D00100E0  stfs f0, 0xe0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 823305B4: D3A100E4  stfs f29, 0xe4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 823305B8: D00100E8  stfs f0, 0xe8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 823305BC: D2C100EC  stfs f22, 0xec(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 823305C0: D00100F0  stfs f0, 0xf0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 823305C4: D3A100F4  stfs f29, 0xf4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 823305C8: D2A100F8  stfs f21, 0xf8(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 823305CC: D2C100FC  stfs f22, 0xfc(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 823305D0: 419A0420  beq cr6, 0x823309f0
	if ctx.cr[6].eq {
	pc = 0x823309F0; continue 'dispatch;
	}
	// 823305D4: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82330A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82330A40 size=1444
    let mut pc: u32 = 0x82330A40;
    'dispatch: loop {
        match pc {
            0x82330A40 => {
    //   block [0x82330A40..0x82330A7C)
	// 82330A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82330A44: 4820466D  bl 0x825350b0
	ctx.lr = 0x82330A48;
	sub_82535080(ctx, base);
	// 82330A48: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82330A4C: 48205591  bl 0x82535fdc
	ctx.lr = 0x82330A50;
	sub_82535FB0(ctx, base);
	// 82330A50: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 82330A54: 48208951  bl 0x825393a4
	ctx.lr = 0x82330A58;
	sub_82539130(ctx, base);
	// 82330A58: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82330A5C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82330A60: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82330A64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82330A68: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82330A6C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82330A70: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82330A74: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82330A78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82330A7C; continue 'dispatch;
            }
            0x82330A7C => {
    //   block [0x82330A7C..0x82330AA4)
	// 82330A7C: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82330A80: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82330A84: 4200FFF8  bdnz 0x82330a7c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82330A7C; continue 'dispatch;
	}
	// 82330A88: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82330A8C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82330A90: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82330A94: 935F0054  stw r26, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82330A98: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82330A9C: 419A0008  beq cr6, 0x82330aa4
	if ctx.cr[6].eq {
	pc = 0x82330AA4; continue 'dispatch;
	}
	// 82330AA0: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	pc = 0x82330AA4; continue 'dispatch;
            }
            0x82330AA4 => {
    //   block [0x82330AA4..0x82330FE4)
	// 82330AA4: 4820276D  bl 0x82533210
	ctx.lr = 0x82330AA8;
	sub_82533210(ctx, base);
	// 82330AA8: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82330AAC: C1BD0134  lfs f13, 0x134(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82330AB0: C19D012C  lfs f12, 0x12c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(300 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82330AB4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82330AB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82330ABC: C3CB206C  lfs f30, 0x206c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8300 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82330AC0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82330AC4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82330AC8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82330ACC: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82330AD0: EC0DF83A  fmadds f0, f13, f0, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64);
	// 82330AD4: EF800332  fmuls f28, f0, f12
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82330AD8: 48202739  bl 0x82533210
	ctx.lr = 0x82330ADC;
	sub_82533210(ctx, base);
	// 82330ADC: 546A047E  clrlwi r10, r3, 0x11
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82330AE0: C1BD0134  lfs f13, 0x134(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82330AE4: C19D0130  lfs f12, 0x130(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(304 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82330AE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82330AEC: D3FF003C  stfs f31, 0x3c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82330AF0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82330AF4: C3AB1FF8  lfs f29, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82330AF8: D3BF0034  stfs f29, 0x34(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82330AFC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82330B00: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82330B04: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82330B08: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82330B0C: EC0DF83A  fmadds f0, f13, f0, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64);
	// 82330B10: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82330B14: EDBC0028  fsubs f13, f28, f0
	ctx.f[13].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 82330B18: FD8D072E  fsel f12, f13, f28, f0
	ctx.f[12].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[28].f64 } else { ctx.f[0].f64 };
	// 82330B1C: D19F0030  stfs f12, 0x30(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82330B20: FC0DE02E  fsel f0, f13, f0, f28
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[28].f64 };
	// 82330B24: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82330B28: 482026E9  bl 0x82533210
	ctx.lr = 0x82330B2C;
	sub_82533210(ctx, base);
	// 82330B2C: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82330B30: C1BD0144  lfs f13, 0x144(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(324 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82330B34: C19D0140  lfs f12, 0x140(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(320 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82330B38: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82330B3C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82330B40: 3B8B1E40  addi r28, r11, 0x1e40
	ctx.r[28].s64 = ctx.r[11].s64 + 7744;
	// 82330B44: 39600180  li r11, 0x180
	ctx.r[11].s64 = 384;
	// 82330B48: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82330B4C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82330B50: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82330B54: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82330B58: EC0DF83A  fmadds f0, f13, f0, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64);
	// 82330B5C: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82330B60: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82330B64: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82330FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82330FE8 size=552
    let mut pc: u32 = 0x82330FE8;
    'dispatch: loop {
        match pc {
            0x82330FE8 => {
    //   block [0x82330FE8..0x82331060)
	// 82330FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82330FEC: 482040CD  bl 0x825350b8
	ctx.lr = 0x82330FF0;
	sub_82535080(ctx, base);
	// 82330FF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82330FF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82330FF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82330FFC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82331000: 396BDD0C  addi r11, r11, -0x22f4
	ctx.r[11].s64 = ctx.r[11].s64 + -8948;
	// 82331004: 3BFD0080  addi r31, r29, 0x80
	ctx.r[31].s64 = ctx.r[29].s64 + 128;
	// 82331008: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8233100C: 38CADCE0  addi r6, r10, -0x2320
	ctx.r[6].s64 = ctx.r[10].s64 + -8992;
	// 82331010: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 82331014: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82331018: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233101C: 386ADBE0  addi r3, r10, -0x2420
	ctx.r[3].s64 = ctx.r[10].s64 + -9248;
	// 82331020: 38A00480  li r5, 0x480
	ctx.r[5].s64 = 1152;
	// 82331024: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82331028: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233102C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82331030: 4BEC42B9  bl 0x821f52e8
	ctx.lr = 0x82331034;
	sub_821F52E8(ctx, base);
	// 82331034: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233103C: 419A0024  beq cr6, 0x82331060
	if ctx.cr[6].eq {
	pc = 0x82331060; continue 'dispatch;
	}
	// 82331040: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331044: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331048: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8233104C: 409A0014  bne cr6, 0x82331060
	if !ctx.cr[6].eq {
	pc = 0x82331060; continue 'dispatch;
	}
	// 82331050: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331054: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82331058: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8233105C: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x82331060; continue 'dispatch;
            }
            0x82331060 => {
    //   block [0x82331060..0x823310A0)
	// 82331060: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82331064: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82331068: 419A019C  beq cr6, 0x82331204
	if ctx.cr[6].eq {
	pc = 0x82331204; continue 'dispatch;
	}
	// 8233106C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82331070: 4BEFC379  bl 0x8222d3e8
	ctx.lr = 0x82331074;
	sub_8222D3E8(ctx, base);
	// 82331074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82331078: 397F007F  addi r11, r31, 0x7f
	ctx.r[11].s64 = ctx.r[31].s64 + 127;
	// 8233107C: 395F0480  addi r10, r31, 0x480
	ctx.r[10].s64 = ctx.r[31].s64 + 1152;
	// 82331080: 55690030  rlwinm r9, r11, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82331084: 554B0030  rlwinm r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82331088: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8233108C: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82331090: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82331094: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82331098: 419A0008  beq cr6, 0x823310a0
	if ctx.cr[6].eq {
	pc = 0x823310A0; continue 'dispatch;
	}
	// 8233109C: 7C00FA2C  dcbt 0, r31
	pc = 0x823310A0; continue 'dispatch;
            }
            0x823310A0 => {
    //   block [0x823310A0..0x823310AC)
	// 823310A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823310A4: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 823310A8: 41980084  blt cr6, 0x8233112c
	if ctx.cr[6].lt {
	pc = 0x8233112C; continue 'dispatch;
	}
	pc = 0x823310AC; continue 'dispatch;
            }
            0x823310AC => {
    //   block [0x823310AC..0x8233112C)
	// 823310AC: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 823310B0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823310B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823310B8: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 823310BC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823310C0: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 823310C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823310C8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823310CC: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 823310D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823310D4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823310D8: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 823310DC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823310E0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823310E4: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 823310E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823310EC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823310F0: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 823310F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823310F8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823310FC: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 82331100: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82331104: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82331108: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8233110C: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 82331110: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82331114: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 82331118: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 8233111C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82331120: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82331124: 4098FF88  bge cr6, 0x823310ac
	if !ctx.cr[6].lt {
	pc = 0x823310AC; continue 'dispatch;
	}
	// 82331128: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x8233112C; continue 'dispatch;
            }
            0x8233112C => {
    //   block [0x8233112C..0x82331170)
	// 8233112C: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 82331130: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82331134: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 82331138: 4199008C  bgt cr6, 0x823311c4
	if ctx.cr[6].gt {
	pc = 0x823311C4; continue 'dispatch;
	}
	// 8233113C: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 82331140: 398C1154  addi r12, r12, 0x1154
	ctx.r[12].s64 = ctx.r[12].s64 + 4436;
	// 82331144: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82331148: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8233114C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82331150: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x823311B8; continue 'dispatch;
		},
		1 => {
	pc = 0x823311AC; continue 'dispatch;
		},
		2 => {
	pc = 0x823311A0; continue 'dispatch;
		},
		3 => {
	pc = 0x82331194; continue 'dispatch;
		},
		4 => {
	pc = 0x82331188; continue 'dispatch;
		},
		5 => {
	pc = 0x8233117C; continue 'dispatch;
		},
		6 => {
	pc = 0x82331170; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82331154: 823311B8  lwz r17, 0x11b8(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4536 as u32) ) } as u64;
	// 82331158: 823311AC  lwz r17, 0x11ac(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4524 as u32) ) } as u64;
	// 8233115C: 823311A0  lwz r17, 0x11a0(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4512 as u32) ) } as u64;
	// 82331160: 82331194  lwz r17, 0x1194(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4500 as u32) ) } as u64;
	// 82331164: 82331188  lwz r17, 0x1188(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4488 as u32) ) } as u64;
	// 82331168: 8233117C  lwz r17, 0x117c(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4476 as u32) ) } as u64;
	// 8233116C: 82331170  lwz r17, 0x1170(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4464 as u32) ) } as u64;
            }
            0x82331170 => {
    //   block [0x82331170..0x8233117C)
	// 82331170: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 82331174: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82331178: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8233117C; continue 'dispatch;
            }
            0x8233117C => {
    //   block [0x8233117C..0x82331188)
	// 8233117C: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 82331180: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82331184: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82331188; continue 'dispatch;
            }
            0x82331188 => {
    //   block [0x82331188..0x82331194)
	// 82331188: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 8233118C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82331190: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82331194; continue 'dispatch;
            }
            0x82331194 => {
    //   block [0x82331194..0x823311A0)
	// 82331194: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 82331198: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8233119C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823311A0; continue 'dispatch;
            }
            0x823311A0 => {
    //   block [0x823311A0..0x823311AC)
	// 823311A0: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 823311A4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823311A8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823311AC; continue 'dispatch;
            }
            0x823311AC => {
    //   block [0x823311AC..0x823311B8)
	// 823311AC: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 823311B0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823311B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823311B8; continue 'dispatch;
            }
            0x823311B8 => {
    //   block [0x823311B8..0x823311C4)
	// 823311B8: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 823311BC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823311C0: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x823311C4; continue 'dispatch;
            }
            0x823311C4 => {
    //   block [0x823311C4..0x82331204)
	// 823311C4: 38A00090  li r5, 0x90
	ctx.r[5].s64 = 144;
	// 823311C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823311CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823311D0: 48203981  bl 0x82534b50
	ctx.lr = 0x823311D4;
	sub_82534B50(ctx, base);
	// 823311D4: 817C006C  lwz r11, 0x6c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(108 as u32) ) } as u64;
	// 823311D8: 917F03F4  stw r11, 0x3f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1012 as u32), ctx.r[11].u32 ) };
	// 823311DC: 817C0070  lwz r11, 0x70(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(112 as u32) ) } as u64;
	// 823311E0: 917F03F8  stw r11, 0x3f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[11].u32 ) };
	// 823311E4: 817C0074  lwz r11, 0x74(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(116 as u32) ) } as u64;
	// 823311E8: 917F03FC  stw r11, 0x3fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1020 as u32), ctx.r[11].u32 ) };
	// 823311EC: 817C0078  lwz r11, 0x78(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(120 as u32) ) } as u64;
	// 823311F0: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 823311F4: 817C007C  lwz r11, 0x7c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(124 as u32) ) } as u64;
	// 823311F8: 917F0404  stw r11, 0x404(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), ctx.r[11].u32 ) };
	// 823311FC: 817C0080  lwz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 82331200: 917F0408  stw r11, 0x408(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), ctx.r[11].u32 ) };
	pc = 0x82331204; continue 'dispatch;
            }
            0x82331204 => {
    //   block [0x82331204..0x82331210)
	// 82331204: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82331208: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8233120C: 48203EFC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82331210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82331210 size=244
    let mut pc: u32 = 0x82331210;
    'dispatch: loop {
        match pc {
            0x82331210 => {
    //   block [0x82331210..0x82331254)
	// 82331210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82331214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82331218: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233121C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82331220: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82331224: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82331228: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233122C: 394ADD0C  addi r10, r10, -0x22f4
	ctx.r[10].s64 = ctx.r[10].s64 + -8948;
	// 82331230: 397F0080  addi r11, r31, 0x80
	ctx.r[11].s64 = ctx.r[31].s64 + 128;
	// 82331234: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82331238: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8233123C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82331240: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331244: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82331248: 409A000C  bne cr6, 0x82331254
	if !ctx.cr[6].eq {
	pc = 0x82331254; continue 'dispatch;
	}
	// 8233124C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82331250: 4800002C  b 0x8233127c
	pc = 0x8233127C; continue 'dispatch;
            }
            0x82331254 => {
    //   block [0x82331254..0x8233126C)
	// 82331254: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331258: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233125C: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82331260: 419A000C  beq cr6, 0x8233126c
	if ctx.cr[6].eq {
	pc = 0x8233126C; continue 'dispatch;
	}
	// 82331264: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82331268: 48000014  b 0x8233127c
	pc = 0x8233127C; continue 'dispatch;
            }
            0x8233126C => {
    //   block [0x8233126C..0x8233127C)
	// 8233126C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331270: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82331274: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82331278: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	pc = 0x8233127C; continue 'dispatch;
            }
            0x8233127C => {
    //   block [0x8233127C..0x823312A0)
	// 8233127C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82331280: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82331284: 419A001C  beq cr6, 0x823312a0
	if ctx.cr[6].eq {
	pc = 0x823312A0; continue 'dispatch;
	}
	// 82331288: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8233128C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82331290: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82331294: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82331298: 419A0008  beq cr6, 0x823312a0
	if ctx.cr[6].eq {
	pc = 0x823312A0; continue 'dispatch;
	}
	// 8233129C: 4BDEBDBD  bl 0x8211d058
	ctx.lr = 0x823312A0;
	sub_8211D058(ctx, base);
	pc = 0x823312A0; continue 'dispatch;
            }
            0x823312A0 => {
    //   block [0x823312A0..0x823312B0)
	// 823312A0: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 823312A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823312A8: 419A0008  beq cr6, 0x823312b0
	if ctx.cr[6].eq {
	pc = 0x823312B0; continue 'dispatch;
	}
	// 823312AC: 4BDEBDAD  bl 0x8211d058
	ctx.lr = 0x823312B0;
	sub_8211D058(ctx, base);
	pc = 0x823312B0; continue 'dispatch;
            }
            0x823312B0 => {
    //   block [0x823312B0..0x823312EC)
	// 823312B0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 823312B4: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 823312B8: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 823312BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823312C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823312C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823312C8: 419A0024  beq cr6, 0x823312ec
	if ctx.cr[6].eq {
	pc = 0x823312EC; continue 'dispatch;
	}
	// 823312CC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 823312D0: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 823312D4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 823312D8: 409A0014  bne cr6, 0x823312ec
	if !ctx.cr[6].eq {
	pc = 0x823312EC; continue 'dispatch;
	}
	// 823312DC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 823312E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823312E4: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 823312E8: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x823312EC; continue 'dispatch;
            }
            0x823312EC => {
    //   block [0x823312EC..0x82331304)
	// 823312EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823312F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823312F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823312F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823312FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82331300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82331308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82331308 size=900
    let mut pc: u32 = 0x82331308;
    'dispatch: loop {
        match pc {
            0x82331308 => {
    //   block [0x82331308..0x82331334)
	// 82331308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233130C: 48203D95  bl 0x825350a0
	ctx.lr = 0x82331310;
	sub_82535080(ctx, base);
	// 82331310: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82331314: 9421FAC0  stwu r1, -0x540(r1)
	ea = ctx.r[1].u32.wrapping_add(-1344 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82331318: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8233131C: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82331320: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82331324: 80DC0120  lwz r6, 0x120(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(288 as u32) ) } as u64;
	// 82331328: 39060010  addi r8, r6, 0x10
	ctx.r[8].s64 = ctx.r[6].s64 + 16;
	// 8233132C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82331330: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82331334; continue 'dispatch;
            }
            0x82331334 => {
    //   block [0x82331334..0x8233168C)
	// 82331334: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82331338: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8233133C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82331340: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82331344: 4200FFF0  bdnz 0x82331334
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82331334; continue 'dispatch;
	}
	// 82331348: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8233134C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82331350: 48037841  bl 0x82368b90
	ctx.lr = 0x82331354;
	sub_82368B90(ctx, base);
	// 82331354: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82331358: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8233135C: C1A100D0  lfs f13, 0xd0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82331360: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82331364: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82331368: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8233136C: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82331370: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 82331374: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82331378: C1A100D4  lfs f13, 0xd4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233137C: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82331380: D18100D0  stfs f12, 0xd0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82331384: D16100D4  stfs f11, 0xd4(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82331690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82331690 size=432
    let mut pc: u32 = 0x82331690;
    'dispatch: loop {
        match pc {
            0x82331690 => {
    //   block [0x82331690..0x823316C0)
	// 82331690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82331694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82331698: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233169C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823316A0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823316A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823316A8: 817F06F0  lwz r11, 0x6f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1776 as u32) ) } as u64;
	// 823316AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823316B0: 419A0010  beq cr6, 0x823316c0
	if ctx.cr[6].eq {
	pc = 0x823316C0; continue 'dispatch;
	}
	// 823316B4: 817F06F4  lwz r11, 0x6f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1780 as u32) ) } as u64;
	// 823316B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823316BC: 409A0014  bne cr6, 0x823316d0
	if !ctx.cr[6].eq {
	pc = 0x823316D0; continue 'dispatch;
	}
	pc = 0x823316C0; continue 'dispatch;
            }
            0x823316C0 => {
    //   block [0x823316C0..0x823316D0)
	// 823316C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823316C4: 480001A5  bl 0x82331868
	ctx.lr = 0x823316C8;
	sub_82331868(ctx, base);
	// 823316C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823316CC: 419A015C  beq cr6, 0x82331828
	if ctx.cr[6].eq {
	pc = 0x82331828; continue 'dispatch;
	}
	pc = 0x823316D0; continue 'dispatch;
            }
            0x823316D0 => {
    //   block [0x823316D0..0x823316F4)
	// 823316D0: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 823316D4: 3BCB49C0  addi r30, r11, 0x49c0
	ctx.r[30].s64 = ctx.r[11].s64 + 18880;
	// 823316D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823316DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823316E0: 419A0014  beq cr6, 0x823316f4
	if ctx.cr[6].eq {
	pc = 0x823316F4; continue 'dispatch;
	}
	// 823316E4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 823316E8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823316EC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823316F0: 419A0138  beq cr6, 0x82331828
	if ctx.cr[6].eq {
	pc = 0x82331828; continue 'dispatch;
	}
	pc = 0x823316F4; continue 'dispatch;
            }
            0x823316F4 => {
    //   block [0x823316F4..0x82331720)
	// 823316F4: C1BF0750  lfs f13, 0x750(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1872 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823316F8: C01F074C  lfs f0, 0x74c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1868 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823316FC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82331700: 41990020  bgt cr6, 0x82331720
	if ctx.cr[6].gt {
	pc = 0x82331720; continue 'dispatch;
	}
	// 82331704: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82331708: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8233170C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82331710: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 82331714: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82331718: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8233171C: 48000108  b 0x82331824
	pc = 0x82331824; continue 'dispatch;
            }
            0x82331720 => {
    //   block [0x82331720..0x8233175C)
	// 82331720: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82331724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82331728: 48000249  bl 0x82331970
	ctx.lr = 0x8233172C;
	sub_82331970(ctx, base);
	// 8233172C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82331730: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82331734: 38EBC610  addi r7, r11, -0x39f0
	ctx.r[7].s64 = ctx.r[11].s64 + -14832;
	// 82331738: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8233173C: 38A00300  li r5, 0x300
	ctx.r[5].s64 = 768;
	// 82331740: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 82331744: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82331748: 48038D49  bl 0x8236a490
	ctx.lr = 0x8233174C;
	sub_8236A490(ctx, base);
	// 8233174C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82331750: 419A000C  beq cr6, 0x8233175c
	if ctx.cr[6].eq {
	pc = 0x8233175C; continue 'dispatch;
	}
	// 82331754: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82331758: 48000008  b 0x82331760
	pc = 0x82331760; continue 'dispatch;
            }
            0x8233175C => {
    //   block [0x8233175C..0x82331760)
	// 8233175C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82331760; continue 'dispatch;
            }
            0x82331760 => {
    //   block [0x82331760..0x82331778)
	// 82331760: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82331764: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82331768: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8233176C: 419A000C  beq cr6, 0x82331778
	if ctx.cr[6].eq {
	pc = 0x82331778; continue 'dispatch;
	}
	// 82331770: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82331774: 4BFFF875  bl 0x82330fe8
	ctx.lr = 0x82331778;
	sub_82330FE8(ctx, base);
	pc = 0x82331778; continue 'dispatch;
            }
            0x82331778 => {
    //   block [0x82331778..0x82331798)
	// 82331778: 817F0120  lwz r11, 0x120(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 8233177C: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82331780: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331784: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82331788: 41980010  blt cr6, 0x82331798
	if ctx.cr[6].lt {
	pc = 0x82331798; continue 'dispatch;
	}
	// 8233178C: 409A0014  bne cr6, 0x823317a0
	if !ctx.cr[6].eq {
	pc = 0x823317A0; continue 'dispatch;
	}
	// 82331790: 3860000E  li r3, 0xe
	ctx.r[3].s64 = 14;
	// 82331794: 48000008  b 0x8233179c
	pc = 0x8233179C; continue 'dispatch;
            }
            0x82331798 => {
    //   block [0x82331798..0x8233179C)
	// 82331798: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	pc = 0x8233179C; continue 'dispatch;
            }
            0x8233179C => {
    //   block [0x8233179C..0x823317A0)
	// 8233179C: 48030725  bl 0x82361ec0
	ctx.lr = 0x823317A0;
	sub_82361EC0(ctx, base);
	pc = 0x823317A0; continue 'dispatch;
            }
            0x823317A0 => {
    //   block [0x823317A0..0x82331824)
	// 823317A0: 48201A71  bl 0x82533210
	ctx.lr = 0x823317A4;
	sub_82533210(ctx, base);
	// 823317A4: 3D6051EB  lis r11, 0x51eb
	ctx.r[11].s64 = 1374355456;
	// 823317A8: C01F074C  lfs f0, 0x74c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1868 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823317AC: 616B851F  ori r11, r11, 0x851f
	ctx.r[11].u64 = ctx.r[11].u64 | 34079;
	// 823317B0: 7D635896  mulhw r11, r3, r11
	ctx.r[11].s64 = ((ctx.r[3].s32 as i64 * ctx.r[11].s32 as i64) >> 32);
	// 823317B4: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 823317B8: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823317BC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823317C0: 1D6B0064  mulli r11, r11, 0x64
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823317C4: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 823317C8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823317CC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823317D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823317D4: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823317D8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823317DC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823317E0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823317E4: C00B2238  lfs f0, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823317E8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823317EC: D01F0750  stfs f0, 0x750(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1872 as u32), tmp.u32 ) };
	// 823317F0: 48201A21  bl 0x82533210
	ctx.lr = 0x823317F4;
	sub_82533210(ctx, base);
	// 823317F4: 546B07FE  clrlwi r11, r3, 0x1f
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	// 823317F8: C01F0750  lfs f0, 0x750(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1872 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823317FC: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 82331800: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82331804: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82331808: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8233180C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82331810: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82331814: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82331818: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8233181C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82331820: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82331824; continue 'dispatch;
            }
            0x82331824 => {
    //   block [0x82331824..0x82331828)
	// 82331824: D01F0750  stfs f0, 0x750(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1872 as u32), tmp.u32 ) };
	pc = 0x82331828; continue 'dispatch;
            }
            0x82331828 => {
    //   block [0x82331828..0x82331840)
	// 82331828: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8233182C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82331830: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82331834: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82331838: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233183C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82331840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82331840 size=36
    let mut pc: u32 = 0x82331840;
    'dispatch: loop {
        match pc {
            0x82331840 => {
    //   block [0x82331840..0x82331864)
	// 82331840: 81430120  lwz r10, 0x120(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(288 as u32) ) } as u64;
	// 82331844: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82331848: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8233184C: 396BBC50  addi r11, r11, -0x43b0
	ctx.r[11].s64 = ctx.r[11].s64 + -17328;
	// 82331850: 814A0050  lwz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82331854: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331858: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8233185C: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 82331860: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82331868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82331868 size=260
    let mut pc: u32 = 0x82331868;
    'dispatch: loop {
        match pc {
            0x82331868 => {
    //   block [0x82331868..0x82331890)
	// 82331868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233186C: 48203839  bl 0x825350a4
	ctx.lr = 0x82331870;
	sub_82535080(ctx, base);
	// 82331870: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82331874: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82331878: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8233187C: 396B4A00  addi r11, r11, 0x4a00
	ctx.r[11].s64 = ctx.r[11].s64 + 18944;
	// 82331880: 3B1A0710  addi r24, r26, 0x710
	ctx.r[24].s64 = ctx.r[26].s64 + 1808;
	// 82331884: 3AFA06F8  addi r23, r26, 0x6f8
	ctx.r[23].s64 = ctx.r[26].s64 + 1784;
	// 82331888: 3B6B00B0  addi r27, r11, 0xb0
	ctx.r[27].s64 = ctx.r[11].s64 + 176;
	// 8233188C: 3B200003  li r25, 3
	ctx.r[25].s64 = 3;
	pc = 0x82331890; continue 'dispatch;
            }
            0x82331890 => {
    //   block [0x82331890..0x823318A0)
	// 82331890: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82331898: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8233189C: 419A0074  beq cr6, 0x82331910
	if ctx.cr[6].eq {
	pc = 0x82331910; continue 'dispatch;
	}
	pc = 0x823318A0; continue 'dispatch;
            }
            0x823318A0 => {
    //   block [0x823318A0..0x823318C4)
	// 823318A0: 838B0028  lwz r28, 0x28(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823318A4: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 823318A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823318AC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823318B0: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 823318B4: 409A0048  bne cr6, 0x823318fc
	if !ctx.cr[6].eq {
	pc = 0x823318FC; continue 'dispatch;
	}
	// 823318B8: 3BFA0130  addi r31, r26, 0x130
	ctx.r[31].s64 = ctx.r[26].s64 + 304;
	// 823318BC: 3BDA06F0  addi r30, r26, 0x6f0
	ctx.r[30].s64 = ctx.r[26].s64 + 1776;
	// 823318C0: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	pc = 0x823318C4; continue 'dispatch;
            }
            0x823318C4 => {
    //   block [0x823318C4..0x823318E8)
	// 823318C4: 817F02F8  lwz r11, 0x2f8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(760 as u32) ) } as u64;
	// 823318C8: 815C0018  lwz r10, 0x18(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 823318CC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823318D0: 409A0018  bne cr6, 0x823318e8
	if !ctx.cr[6].eq {
	pc = 0x823318E8; continue 'dispatch;
	}
	// 823318D4: 38A00170  li r5, 0x170
	ctx.r[5].s64 = 368;
	// 823318D8: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823318DC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823318E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823318E4: 4820326D  bl 0x82534b50
	ctx.lr = 0x823318E8;
	sub_82534B50(ctx, base);
	pc = 0x823318E8; continue 'dispatch;
            }
            0x823318E8 => {
    //   block [0x823318E8..0x823318FC)
	// 823318E8: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 823318EC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823318F0: 3BFF0170  addi r31, r31, 0x170
	ctx.r[31].s64 = ctx.r[31].s64 + 368;
	// 823318F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823318F8: 409AFFCC  bne cr6, 0x823318c4
	if !ctx.cr[6].eq {
	pc = 0x823318C4; continue 'dispatch;
	}
	pc = 0x823318FC; continue 'dispatch;
            }
            0x823318FC => {
    //   block [0x823318FC..0x82331910)
	// 823318FC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331900: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82331904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82331908: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8233190C: 409AFF94  bne cr6, 0x823318a0
	if !ctx.cr[6].eq {
	pc = 0x823318A0; continue 'dispatch;
	}
	pc = 0x82331910; continue 'dispatch;
            }
            0x82331910 => {
    //   block [0x82331910..0x82331960)
	// 82331910: 397B0050  addi r11, r27, 0x50
	ctx.r[11].s64 = ctx.r[27].s64 + 80;
	// 82331914: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82331918: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 8233191C: 3B180010  addi r24, r24, 0x10
	ctx.r[24].s64 = ctx.r[24].s64 + 16;
	// 82331920: 3B7B03C0  addi r27, r27, 0x3c0
	ctx.r[27].s64 = ctx.r[27].s64 + 960;
	// 82331924: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82331928: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8233192C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82331930: 3AF70004  addi r23, r23, 4
	ctx.r[23].s64 = ctx.r[23].s64 + 4;
	// 82331934: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82331938: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8233193C: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82331940: 409AFF50  bne cr6, 0x82331890
	if !ctx.cr[6].eq {
	pc = 0x82331890; continue 'dispatch;
	}
	// 82331944: 817A06F0  lwz r11, 0x6f0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(1776 as u32) ) } as u64;
	// 82331948: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233194C: 419A0014  beq cr6, 0x82331960
	if ctx.cr[6].eq {
	pc = 0x82331960; continue 'dispatch;
	}
	// 82331950: 817A06F4  lwz r11, 0x6f4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(1780 as u32) ) } as u64;
	// 82331954: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82331958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233195C: 409A0008  bne cr6, 0x82331964
	if !ctx.cr[6].eq {
	pc = 0x82331964; continue 'dispatch;
	}
	pc = 0x82331960; continue 'dispatch;
            }
            0x82331960 => {
    //   block [0x82331960..0x82331964)
	// 82331960: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82331964; continue 'dispatch;
            }
            0x82331964 => {
    //   block [0x82331964..0x8233196C)
	// 82331964: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82331968: 4820378C  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82331970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82331970 size=360
    let mut pc: u32 = 0x82331970;
    'dispatch: loop {
        match pc {
            0x82331970 => {
    //   block [0x82331970..0x82331A1C)
	// 82331970: 81630120  lwz r11, 0x120(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(288 as u32) ) } as u64;
	// 82331974: 39430080  addi r10, r3, 0x80
	ctx.r[10].s64 = ctx.r[3].s64 + 128;
	// 82331978: 392300C0  addi r9, r3, 0xc0
	ctx.r[9].s64 = ctx.r[3].s64 + 192;
	// 8233197C: 390300D0  addi r8, r3, 0xd0
	ctx.r[8].s64 = ctx.r[3].s64 + 208;
	// 82331980: 38E30110  addi r7, r3, 0x110
	ctx.r[7].s64 = ctx.r[3].s64 + 272;
	// 82331984: 38C30130  addi r6, r3, 0x130
	ctx.r[6].s64 = ctx.r[3].s64 + 304;
	// 82331988: 38A30410  addi r5, r3, 0x410
	ctx.r[5].s64 = ctx.r[3].s64 + 1040;
	// 8233198C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82331990: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82331994: 396302A0  addi r11, r3, 0x2a0
	ctx.r[11].s64 = ctx.r[3].s64 + 672;
	// 82331998: 91240008  stw r9, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8233199C: 39430580  addi r10, r3, 0x580
	ctx.r[10].s64 = ctx.r[3].s64 + 1408;
	// 823319A0: 9104000C  stw r8, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823319A4: 90E40010  stw r7, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 823319A8: 90C40014  stw r6, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 823319AC: 90A4001C  stw r5, 0x1c(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), ctx.r[5].u32 ) };
	// 823319B0: 812306F0  lwz r9, 0x6f0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1776 as u32) ) } as u64;
	// 823319B4: 91640018  stw r11, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 823319B8: 91440020  stw r10, 0x20(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 823319BC: 9124006C  stw r9, 0x6c(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 823319C0: 816306F4  lwz r11, 0x6f4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1780 as u32) ) } as u64;
	// 823319C4: 91640070  stw r11, 0x70(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 823319C8: 81630120  lwz r11, 0x120(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(288 as u32) ) } as u64;
	// 823319CC: 896B0005  lbz r11, 5(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 823319D0: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 823319D4: 409A0048  bne cr6, 0x82331a1c
	if !ctx.cr[6].eq {
	pc = 0x82331A1C; continue 'dispatch;
	}
	// 823319D8: 81630120  lwz r11, 0x120(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(288 as u32) ) } as u64;
	// 823319DC: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 823319E0: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823319E4: D0040084  stfs f0, 0x84(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 823319E8: 81630120  lwz r11, 0x120(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(288 as u32) ) } as u64;
	// 823319EC: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 823319F0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823319F4: D0040088  stfs f0, 0x88(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 823319F8: 81630120  lwz r11, 0x120(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(288 as u32) ) } as u64;
	// 823319FC: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82331A00: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82331A04: D004008C  stfs f0, 0x8c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82331A08: 81630120  lwz r11, 0x120(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(288 as u32) ) } as u64;
	// 82331A0C: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82331A10: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82331A14: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82331A18: 48000024  b 0x82331a3c
	pc = 0x82331A3C; continue 'dispatch;
            }
            0x82331A1C => {
    //   block [0x82331A1C..0x82331A3C)
	// 82331A1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82331A20: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82331A24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82331A28: D0040088  stfs f0, 0x88(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82331A2C: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82331A30: D1A40084  stfs f13, 0x84(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82331A34: D1A4008C  stfs f13, 0x8c(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82331A38: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82331A3C; continue 'dispatch;
            }
            0x82331A3C => {
    //   block [0x82331A3C..0x82331A40)
	// 82331A3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82331A40; continue 'dispatch;
            }
            0x82331A40 => {
    //   block [0x82331A40..0x82331A98)
	// 82331A40: 394B0071  addi r10, r11, 0x71
	ctx.r[10].s64 = ctx.r[11].s64 + 113;
	// 82331A44: 390B0003  addi r8, r11, 3
	ctx.r[8].s64 = ctx.r[11].s64 + 3;
	// 82331A48: 55492036  slwi r9, r10, 4
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82331A4C: 550A2036  slwi r10, r8, 4
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82331A50: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 82331A54: 7D0A2214  add r8, r10, r4
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 82331A58: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82331A5C: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82331A60: 390B01BE  addi r8, r11, 0x1be
	ctx.r[8].s64 = ctx.r[11].s64 + 446;
	// 82331A64: 38EB001D  addi r7, r11, 0x1d
	ctx.r[7].s64 = ctx.r[11].s64 + 29;
	// 82331A68: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82331A6C: E8CA0000  ld r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82331A70: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82331A74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82331A78: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 82331A7C: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82331A80: F9490008  std r10, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82331A84: 7D48182E  lwzx r10, r8, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82331A88: 7D47212E  stwx r10, r7, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[4].u32), ctx.r[10].u32) };
	// 82331A8C: 409A000C  bne cr6, 0x82331a98
	if !ctx.cr[6].eq {
	pc = 0x82331A98; continue 'dispatch;
	}
	// 82331A90: D1A40060  stfs f13, 0x60(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82331A94: 48000010  b 0x82331aa4
	pc = 0x82331AA4; continue 'dispatch;
            }
            0x82331A98 => {
    //   block [0x82331A98..0x82331AA4)
	// 82331A98: 394B0018  addi r10, r11, 0x18
	ctx.r[10].s64 = ctx.r[11].s64 + 24;
	// 82331A9C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82331AA0: 7C0A252E  stfsx f0, r10, r4
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32), tmp.u32) };
	pc = 0x82331AA4; continue 'dispatch;
            }
            0x82331AA4 => {
    //   block [0x82331AA4..0x82331AD8)
	// 82331AA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82331AA8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82331AAC: 4198FF94  blt cr6, 0x82331a40
	if ctx.cr[6].lt {
	pc = 0x82331A40; continue 'dispatch;
	}
	// 82331AB0: 81430120  lwz r10, 0x120(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(288 as u32) ) } as u64;
	// 82331AB4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82331AB8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82331ABC: 396BBC50  addi r11, r11, -0x43b0
	ctx.r[11].s64 = ctx.r[11].s64 + -17328;
	// 82331AC0: 814A0050  lwz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82331AC4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331AC8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82331ACC: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82331AD0: 91640080  stw r11, 0x80(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82331AD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82331AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82331AD8 size=1472
    let mut pc: u32 = 0x82331AD8;
    'dispatch: loop {
        match pc {
            0x82331AD8 => {
    //   block [0x82331AD8..0x82331B1C)
	// 82331AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82331ADC: 482035D9  bl 0x825350b4
	ctx.lr = 0x82331AE0;
	sub_82535080(ctx, base);
	// 82331AE0: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 82331AE4: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82331AE8: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82331AEC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82331AF0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82331AF4: 387B0080  addi r3, r27, 0x80
	ctx.r[3].s64 = ctx.r[27].s64 + 128;
	// 82331AF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82331B00: 419A002C  beq cr6, 0x82331b2c
	if ctx.cr[6].eq {
	pc = 0x82331B2C; continue 'dispatch;
	}
	// 82331B04: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331B08: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331B0C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82331B10: 419A000C  beq cr6, 0x82331b1c
	if ctx.cr[6].eq {
	pc = 0x82331B1C; continue 'dispatch;
	}
	// 82331B14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82331B18: 48000014  b 0x82331b2c
	pc = 0x82331B2C; continue 'dispatch;
            }
            0x82331B1C => {
    //   block [0x82331B1C..0x82331B2C)
	// 82331B1C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331B20: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82331B24: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82331B28: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x82331B2C; continue 'dispatch;
            }
            0x82331B2C => {
    //   block [0x82331B2C..0x82331B5C)
	// 82331B2C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82331B30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82331B34: 419A0550  beq cr6, 0x82332084
	if ctx.cr[6].eq {
	pc = 0x82332084; continue 'dispatch;
	}
	// 82331B38: 4BEFB8B1  bl 0x8222d3e8
	ctx.lr = 0x82331B3C;
	sub_8222D3E8(ctx, base);
	// 82331B3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82331B40: C1BF0410  lfs f13, 0x410(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82331B44: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82331B48: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82331B4C: 419800A4  blt cr6, 0x82331bf0
	if ctx.cr[6].lt {
	pc = 0x82331BF0; continue 'dispatch;
	}
	// 82331B50: 3B9F00E0  addi r28, r31, 0xe0
	ctx.r[28].s64 = ctx.r[31].s64 + 224;
	// 82331B54: 3BBF0014  addi r29, r31, 0x14
	ctx.r[29].s64 = ctx.r[31].s64 + 20;
	// 82331B58: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	pc = 0x82331B5C; continue 'dispatch;
            }
            0x82331B5C => {
    //   block [0x82331B5C..0x82331BF0)
	// 82331B5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82331B60: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331B64: 4BFC753D  bl 0x822f90a0
	ctx.lr = 0x82331B68;
	sub_822F90A0(ctx, base);
	// 82331B68: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 82331B6C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82331B70: 3B9C0170  addi r28, r28, 0x170
	ctx.r[28].s64 = ctx.r[28].s64 + 368;
	// 82331B74: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82331B78: 409AFFE4  bne cr6, 0x82331b5c
	if !ctx.cr[6].eq {
	pc = 0x82331B5C; continue 'dispatch;
	}
	// 82331B7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82331B80: 395F0040  addi r10, r31, 0x40
	ctx.r[10].s64 = ctx.r[31].s64 + 64;
	// 82331B84: 393F0050  addi r9, r31, 0x50
	ctx.r[9].s64 = ctx.r[31].s64 + 80;
	// 82331B88: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82331B8C: 397F0030  addi r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
	// 82331B90: E8EA0000  ld r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82331B94: E8C90000  ld r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 82331B98: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82331B9C: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 82331BA0: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82331BA4: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82331BA8: F8FF03D0  std r7, 0x3d0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(976 as u32), ctx.r[7].u64 ) };
	// 82331BAC: F95F03D8  std r10, 0x3d8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(984 as u32), ctx.r[10].u64 ) };
	// 82331BB0: F8DF03E0  std r6, 0x3e0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(992 as u32), ctx.r[6].u64 ) };
	// 82331BB4: F91F03C0  std r8, 0x3c0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(960 as u32), ctx.r[8].u64 ) };
	// 82331BB8: F97F03C8  std r11, 0x3c8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(968 as u32), ctx.r[11].u64 ) };
	// 82331BBC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82331BC0: F93F03E8  std r9, 0x3e8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(1000 as u32), ctx.r[9].u64 ) };
	// 82331BC4: D01F03F0  stfs f0, 0x3f0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), tmp.u32 ) };
	// 82331BC8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331BCC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82331BD0: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82331BD4: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82331BD8: 409A02E0  bne cr6, 0x82331eb8
	if !ctx.cr[6].eq {
	pc = 0x82331EB8; continue 'dispatch;
	}
	// 82331BDC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82331BE0: 997B0019  stb r11, 0x19(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82331BE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82331BE8: 997B0025  stb r11, 0x25(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 82331BEC: 480002CC  b 0x82331eb8
	pc = 0x82331EB8; continue 'dispatch;
            }
            0x82331BF0 => {
    //   block [0x82331BF0..0x82331C30)
	// 82331BF0: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82331BF4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82331BF8: C3BF0088  lfs f29, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82331BFC: C3CBBA38  lfs f30, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82331C00: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82331C04: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82331C08: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82331C0C: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82331C10: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82331C14: 419A001C  beq cr6, 0x82331c30
	if ctx.cr[6].eq {
	pc = 0x82331C30; continue 'dispatch;
	}
	// 82331C18: FC200210  fabs f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82331C1C: 482013BD  bl 0x82532fd8
	ctx.lr = 0x82331C20;
	sub_82532FD8(ctx, base);
	// 82331C20: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82331C24: EC200772  fmuls f1, f0, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82331C28: 48201871  bl 0x82533498
	ctx.lr = 0x82331C2C;
	sub_82533498(ctx, base);
	// 82331C2C: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	pc = 0x82331C30; continue 'dispatch;
            }
            0x82331C30 => {
    //   block [0x82331C30..0x82331C50)
	// 82331C30: 3B9F0090  addi r28, r31, 0x90
	ctx.r[28].s64 = ctx.r[31].s64 + 144;
	// 82331C34: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82331C38: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82331C3C: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82331C40: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82331C44: 4098003C  bge cr6, 0x82331c80
	if !ctx.cr[6].lt {
	pc = 0x82331C80; continue 'dispatch;
	}
	// 82331C48: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82331C4C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82331C50; continue 'dispatch;
            }
            0x82331C50 => {
    //   block [0x82331C50..0x82331C80)
	// 82331C50: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82331C54: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82331C58: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82331C5C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82331C60: 4200FFF0  bdnz 0x82331c50
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82331C50; continue 'dispatch;
	}
	// 82331C64: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82331C68: 3BBF00D0  addi r29, r31, 0xd0
	ctx.r[29].s64 = ctx.r[31].s64 + 208;
	// 82331C6C: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82331C70: F95D0000  std r10, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82331C74: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82331C78: D3DF03F0  stfs f30, 0x3f0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), tmp.u32 ) };
	// 82331C7C: 48000044  b 0x82331cc0
	pc = 0x82331CC0; continue 'dispatch;
            }
            0x82331C80 => {
    //   block [0x82331C80..0x82331C88)
	// 82331C80: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82331C84: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82331C88; continue 'dispatch;
            }
            0x82331C88 => {
    //   block [0x82331C88..0x82331CC0)
	// 82331C88: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82331C8C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82331C90: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82331C94: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82331C98: 4200FFF0  bdnz 0x82331c88
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82331C88; continue 'dispatch;
	}
	// 82331C9C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331CA0: EDBEF828  fsubs f13, f30, f31
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 82331CA4: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82331CA8: 3BBF00D0  addi r29, r31, 0xd0
	ctx.r[29].s64 = ctx.r[31].s64 + 208;
	// 82331CAC: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82331CB0: F95D0000  std r10, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82331CB4: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82331CB8: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82331CBC: D01F03F0  stfs f0, 0x3f0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), tmp.u32 ) };
	pc = 0x82331CC0; continue 'dispatch;
            }
            0x82331CC0 => {
    //   block [0x82331CC0..0x82331D24)
	// 82331CC0: F97D0008  std r11, 8(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82331CC4: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82331CC8: C1BF0410  lfs f13, 0x410(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82331CCC: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82331CD0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82331CD4: 409800AC  bge cr6, 0x82331d80
	if !ctx.cr[6].lt {
	pc = 0x82331D80; continue 'dispatch;
	}
	// 82331CD8: 48201539  bl 0x82533210
	ctx.lr = 0x82331CDC;
	sub_82533210(ctx, base);
	// 82331CDC: 3D6051EB  lis r11, 0x51eb
	ctx.r[11].s64 = 1374355456;
	// 82331CE0: 617E851F  ori r30, r11, 0x851f
	ctx.r[30].u64 = ctx.r[11].u64 | 34079;
	// 82331CE4: 7D63F096  mulhw r11, r3, r30
	ctx.r[11].s64 = ((ctx.r[3].s32 as i64 * ctx.r[30].s32 as i64) >> 32);
	// 82331CE8: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 82331CEC: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82331CF0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82331CF4: 1D6B0064  mulli r11, r11, 0x64
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82331CF8: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82331CFC: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 82331D00: 40980080  bge cr6, 0x82331d80
	if !ctx.cr[6].lt {
	pc = 0x82331D80; continue 'dispatch;
	}
	// 82331D04: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82331D08: C1BF0410  lfs f13, 0x410(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82331D0C: C00BD560  lfs f0, -0x2aa0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82331D10: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82331D14: 40990010  ble cr6, 0x82331d24
	if !ctx.cr[6].gt {
	pc = 0x82331D24; continue 'dispatch;
	}
	// 82331D18: 817F040C  lwz r11, 0x40c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1036 as u32) ) } as u64;
	// 82331D1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82331D20: 40990060  ble cr6, 0x82331d80
	if !ctx.cr[6].gt {
	pc = 0x82331D80; continue 'dispatch;
	}
	pc = 0x82331D24; continue 'dispatch;
            }
            0x82331D24 => {
    //   block [0x82331D24..0x82331D80)
	// 82331D24: 482014ED  bl 0x82533210
	ctx.lr = 0x82331D28;
	sub_82533210(ctx, base);
	// 82331D28: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82331D2C: ED9EF828  fsubs f12, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 82331D30: C00B2810  lfs f0, 0x2810(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82331D34: 817F040C  lwz r11, 0x40c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1036 as u32) ) } as u64;
	// 82331D38: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82331D3C: 917F040C  stw r11, 0x40c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), ctx.r[11].u32 ) };
	// 82331D40: 7D63F096  mulhw r11, r3, r30
	ctx.r[11].s64 = ((ctx.r[3].s32 as i64 * ctx.r[30].s32 as i64) >> 32);
	// 82331D44: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 82331D48: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82331D4C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82331D50: 1D6B0064  mulli r11, r11, 0x64
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82331D54: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82331D58: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82331D5C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82331D60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82331D64: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82331D68: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82331D6C: FD606818  frsp f11, f13
	ctx.f[11].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82331D70: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82331D74: EC0B683A  fmadds f0, f11, f0, f13
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82331D78: EFE00332  fmuls f31, f0, f12
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82331D7C: D3FF03F0  stfs f31, 0x3f0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), tmp.u32 ) };
	pc = 0x82331D80; continue 'dispatch;
            }
            0x82331D80 => {
    //   block [0x82331D80..0x82331D8C)
	// 82331D80: 395F001C  addi r10, r31, 0x1c
	ctx.r[10].s64 = ctx.r[31].s64 + 28;
	// 82331D84: 393F0220  addi r9, r31, 0x220
	ctx.r[9].s64 = ctx.r[31].s64 + 544;
	// 82331D88: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	pc = 0x82331D8C; continue 'dispatch;
            }
            0x82331D8C => {
    //   block [0x82331D8C..0x82331EB8)
	// 82331D8C: 80EAFFF8  lwz r7, -8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82331D90: 3869FFF0  addi r3, r9, -0x10
	ctx.r[3].s64 = ctx.r[9].s64 + -16;
	// 82331D94: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331D98: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82331D9C: 38A70130  addi r5, r7, 0x130
	ctx.r[5].s64 = ctx.r[7].s64 + 304;
	// 82331DA0: 388B0130  addi r4, r11, 0x130
	ctx.r[4].s64 = ctx.r[11].s64 + 304;
	// 82331DA4: 48050C05  bl 0x823829a8
	ctx.lr = 0x82331DA8;
	sub_823829A8(ctx, base);
	// 82331DA8: 80EAFFF8  lwz r7, -8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82331DAC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331DB0: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82331DB4: 38A70140  addi r5, r7, 0x140
	ctx.r[5].s64 = ctx.r[7].s64 + 320;
	// 82331DB8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82331DBC: 388B0140  addi r4, r11, 0x140
	ctx.r[4].s64 = ctx.r[11].s64 + 320;
	// 82331DC0: 48050BE9  bl 0x823829a8
	ctx.lr = 0x82331DC4;
	sub_823829A8(ctx, base);
	// 82331DC4: 80EAFFF8  lwz r7, -8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82331DC8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331DCC: 38690010  addi r3, r9, 0x10
	ctx.r[3].s64 = ctx.r[9].s64 + 16;
	// 82331DD0: 38A70150  addi r5, r7, 0x150
	ctx.r[5].s64 = ctx.r[7].s64 + 336;
	// 82331DD4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82331DD8: 388B0150  addi r4, r11, 0x150
	ctx.r[4].s64 = ctx.r[11].s64 + 336;
	// 82331DDC: 48050BCD  bl 0x823829a8
	ctx.lr = 0x82331DE0;
	sub_823829A8(ctx, base);
	// 82331DE0: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82331DE4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82331DE8: 39290170  addi r9, r9, 0x170
	ctx.r[9].s64 = ctx.r[9].s64 + 368;
	// 82331DEC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82331DF0: 409AFF9C  bne cr6, 0x82331d8c
	if !ctx.cr[6].eq {
	pc = 0x82331D8C; continue 'dispatch;
	}
	// 82331DF4: EDBEF828  fsubs f13, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 82331DF8: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82331DFC: C19F0034  lfs f12, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82331E00: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82331E04: C17F0038  lfs f11, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82331E08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82331E0C: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82331E10: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82331E14: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82331E18: ED8C07FA  fmadds f12, f12, f31, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82331E1C: ED6B07FA  fmadds f11, f11, f31, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82331E20: ED4A07FA  fmadds f10, f10, f31, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82331E24: C00B22EC  lfs f0, 0x22ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8940 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82331E28: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82331E2C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82331E30: D19F03C4  stfs f12, 0x3c4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(964 as u32), tmp.u32 ) };
	// 82331E34: C18B2278  lfs f12, 0x2278(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8824 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82331E38: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82331E3C: D17F03C8  stfs f11, 0x3c8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(968 as u32), tmp.u32 ) };
	// 82331E40: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82331E44: D15F03C0  stfs f10, 0x3c0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(960 as u32), tmp.u32 ) };
	// 82331E48: C17F0064  lfs f11, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82331E4C: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82331E50: C15F0044  lfs f10, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82331E54: C13F0048  lfs f9, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82331E58: C11F0040  lfs f8, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82331E5C: ED4A5FFA  fmadds f10, f10, f31, f11
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 82331E60: ED295FFA  fmadds f9, f9, f31, f11
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 82331E64: ED685FFA  fmadds f11, f8, f31, f11
	ctx.f[11].f64 = (((ctx.f[8].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 82331E68: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82331E6C: D17F03D0  stfs f11, 0x3d0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(976 as u32), tmp.u32 ) };
	// 82331E70: ED6A0032  fmuls f11, f10, f0
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82331E74: D17F03D4  stfs f11, 0x3d4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(980 as u32), tmp.u32 ) };
	// 82331E78: ED690332  fmuls f11, f9, f12
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82331E7C: D17F03D8  stfs f11, 0x3d8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(984 as u32), tmp.u32 ) };
	// 82331E80: C17F0068  lfs f11, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82331E84: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82331E88: C15F0058  lfs f10, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82331E8C: C17F0054  lfs f11, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82331E90: C13F0050  lfs f9, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82331E94: ED6B6FFA  fmadds f11, f11, f31, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82331E98: ED4A6FFA  fmadds f10, f10, f31, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82331E9C: EDA96FFA  fmadds f13, f9, f31, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82331EA0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82331EA4: D1BF03E0  stfs f13, 0x3e0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(992 as u32), tmp.u32 ) };
	// 82331EA8: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82331EAC: D01F03E4  stfs f0, 0x3e4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(996 as u32), tmp.u32 ) };
	// 82331EB0: EC0A0332  fmuls f0, f10, f12
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82331EB4: D01F03E8  stfs f0, 0x3e8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1000 as u32), tmp.u32 ) };
	pc = 0x82331EB8; continue 'dispatch;
            }
            0x82331EB8 => {
    //   block [0x82331EB8..0x82332018)
	// 82331EB8: 815F03F4  lwz r10, 0x3f4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) } as u64;
	// 82331EBC: 397F0210  addi r11, r31, 0x210
	ctx.r[11].s64 = ctx.r[31].s64 + 528;
	// 82331EC0: 393F0220  addi r9, r31, 0x220
	ctx.r[9].s64 = ctx.r[31].s64 + 544;
	// 82331EC4: 390A0130  addi r8, r10, 0x130
	ctx.r[8].s64 = ctx.r[10].s64 + 304;
	// 82331EC8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82331ECC: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82331ED0: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331ED4: 391F0230  addi r8, r31, 0x230
	ctx.r[8].s64 = ctx.r[31].s64 + 560;
	// 82331ED8: 38FF0380  addi r7, r31, 0x380
	ctx.r[7].s64 = ctx.r[31].s64 + 896;
	// 82331EDC: 38DF0390  addi r6, r31, 0x390
	ctx.r[6].s64 = ctx.r[31].s64 + 912;
	// 82331EE0: 38BF03A0  addi r5, r31, 0x3a0
	ctx.r[5].s64 = ctx.r[31].s64 + 928;
	// 82331EE4: 93C90000  stw r30, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82331EE8: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82331EEC: 93C90004  stw r30, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82331EF0: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331EF4: 93C90008  stw r30, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82331EF8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82331EFC: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82331F00: 817F03F4  lwz r11, 0x3f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) } as u64;
	// 82331F04: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331F08: 396B0140  addi r11, r11, 0x140
	ctx.r[11].s64 = ctx.r[11].s64 + 320;
	// 82331F0C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82331F10: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82331F14: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82331F18: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331F1C: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82331F20: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82331F24: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82331F28: 817F03F4  lwz r11, 0x3f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) } as u64;
	// 82331F2C: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331F30: 396B0150  addi r11, r11, 0x150
	ctx.r[11].s64 = ctx.r[11].s64 + 336;
	// 82331F34: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82331F38: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82331F3C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82331F40: 81480008  lwz r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331F44: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82331F48: 8148000C  lwz r10, 0xc(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 82331F4C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82331F50: 817F03F8  lwz r11, 0x3f8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1016 as u32) ) } as u64;
	// 82331F54: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331F58: 396B0130  addi r11, r11, 0x130
	ctx.r[11].s64 = ctx.r[11].s64 + 304;
	// 82331F5C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82331F60: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82331F64: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82331F68: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331F6C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82331F70: 8147000C  lwz r10, 0xc(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 82331F74: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82331F78: 817F03F8  lwz r11, 0x3f8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1016 as u32) ) } as u64;
	// 82331F7C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331F80: 396B0140  addi r11, r11, 0x140
	ctx.r[11].s64 = ctx.r[11].s64 + 320;
	// 82331F84: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82331F88: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82331F8C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82331F90: 81460008  lwz r10, 8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331F94: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82331F98: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82331F9C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82331FA0: 817F03F8  lwz r11, 0x3f8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1016 as u32) ) } as u64;
	// 82331FA4: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82331FA8: 396B0150  addi r11, r11, 0x150
	ctx.r[11].s64 = ctx.r[11].s64 + 336;
	// 82331FAC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82331FB0: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82331FB4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82331FB8: 81450008  lwz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82331FBC: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82331FC0: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82331FC4: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82331FC8: 817F03FC  lwz r11, 0x3fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1020 as u32) ) } as u64;
	// 82331FCC: E95F03C0  ld r10, 0x3c0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) };
	// 82331FD0: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82331FD4: E95F03C8  ld r10, 0x3c8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(968 as u32) ) };
	// 82331FD8: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82331FDC: 817F0400  lwz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82331FE0: E95F03D0  ld r10, 0x3d0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) };
	// 82331FE4: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82331FE8: E95F03D8  ld r10, 0x3d8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(984 as u32) ) };
	// 82331FEC: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82331FF0: 817F0404  lwz r11, 0x404(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82331FF4: E95F03E0  ld r10, 0x3e0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(992 as u32) ) };
	// 82331FF8: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82331FFC: E95F03E8  ld r10, 0x3e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) };
	// 82332000: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82332004: 817F0408  lwz r11, 0x408(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82332008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233200C: 419A000C  beq cr6, 0x82332018
	if ctx.cr[6].eq {
	pc = 0x82332018; continue 'dispatch;
	}
	// 82332010: C01F03F0  lfs f0, 0x3f0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82332014: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82332018; continue 'dispatch;
            }
            0x82332018 => {
    //   block [0x82332018..0x8233202C)
	// 82332018: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 8233201C: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82332020: 394BB5C0  addi r10, r11, -0x4a40
	ctx.r[10].s64 = ctx.r[11].s64 + -19008;
	// 82332024: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82332028: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8233202C; continue 'dispatch;
            }
            0x8233202C => {
    //   block [0x8233202C..0x82332084)
	// 8233202C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82332030: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82332034: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82332038: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8233203C: 4200FFF0  bdnz 0x8233202c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8233202C; continue 'dispatch;
	}
	// 82332040: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82332044: 3D2082B6  lis r9, -0x7d4a
	ctx.r[9].s64 = -2102001664;
	// 82332048: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 8233204C: 396BB610  addi r11, r11, -0x49f0
	ctx.r[11].s64 = ctx.r[11].s64 + -18928;
	// 82332050: 9149B600  stw r10, -0x4a00(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-18944 as u32), ctx.r[10].u32 ) };
	// 82332054: E9440000  ld r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 82332058: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 8233205C: E9440008  ld r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	// 82332060: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82332064: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82332068: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8233206C: C1BF0410  lfs f13, 0x410(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82332070: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82332074: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 82332078: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233207C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82332080: D01F0410  stfs f0, 0x410(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	pc = 0x82332084; continue 'dispatch;
            }
            0x82332084 => {
    //   block [0x82332084..0x82332098)
	// 82332084: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82332088: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8233208C: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82332090: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82332094: 48203070  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82332098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82332098 size=160
    let mut pc: u32 = 0x82332098;
    'dispatch: loop {
        match pc {
            0x82332098 => {
    //   block [0x82332098..0x823320F4)
	// 82332098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233209C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823320A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823320A4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823320A8: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823320AC: 817F0398  lwz r11, 0x398(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 823320B0: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823320B4: 409A0070  bne cr6, 0x82332124
	if !ctx.cr[6].eq {
	pc = 0x82332124; continue 'dispatch;
	}
	// 823320B8: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 823320BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823320C0: 409A0064  bne cr6, 0x82332124
	if !ctx.cr[6].eq {
	pc = 0x82332124; continue 'dispatch;
	}
	// 823320C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823320C8: 419A002C  beq cr6, 0x823320f4
	if ctx.cr[6].eq {
	pc = 0x823320F4; continue 'dispatch;
	}
	// 823320CC: C01F00B0  lfs f0, 0xb0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823320D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823320D4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823320D8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823320DC: C01F00B4  lfs f0, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823320E0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 823320E4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 823320E8: C01F00B8  lfs f0, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823320EC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 823320F0: 48030591  bl 0x82362680
	ctx.lr = 0x823320F4;
	sub_82362680(ctx, base);
	pc = 0x823320F4; continue 'dispatch;
            }
            0x823320F4 => {
    //   block [0x823320F4..0x82332118)
	// 823320F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823320F8: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 823320FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82332100: 917F039C  stw r11, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[11].u32 ) };
	// 82332104: 419A0014  beq cr6, 0x82332118
	if ctx.cr[6].eq {
	pc = 0x82332118; continue 'dispatch;
	}
	// 82332108: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8233210C: 814BBC4C  lwz r10, -0x43b4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17332 as u32) ) } as u64;
	// 82332110: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82332114: 914BBC4C  stw r10, -0x43b4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17332 as u32), ctx.r[10].u32 ) };
	pc = 0x82332118; continue 'dispatch;
            }
            0x82332118 => {
    //   block [0x82332118..0x82332124)
	// 82332118: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 8233211C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82332120: 48000E09  bl 0x82332f28
	ctx.lr = 0x82332124;
	sub_82332F28(ctx, base);
	pc = 0x82332124; continue 'dispatch;
            }
            0x82332124 => {
    //   block [0x82332124..0x82332138)
	// 82332124: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82332128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233212C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82332130: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82332134: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82332138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82332138 size=40
    let mut pc: u32 = 0x82332138;
    'dispatch: loop {
        match pc {
            0x82332138 => {
    //   block [0x82332138..0x82332150)
	// 82332138: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233213C: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 82332140: 419A0010  beq cr6, 0x82332150
	if ctx.cr[6].eq {
	pc = 0x82332150; continue 'dispatch;
	}
	// 82332144: 81630398  lwz r11, 0x398(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(920 as u32) ) } as u64;
	// 82332148: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8233214C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x82332150; continue 'dispatch;
            }
            0x82332150 => {
    //   block [0x82332150..0x82332160)
	// 82332150: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82332154: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82332158: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233215C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82332168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82332168 size=100
    let mut pc: u32 = 0x82332168;
    'dispatch: loop {
        match pc {
            0x82332168 => {
    //   block [0x82332168..0x823321B8)
	// 82332168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233216C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82332170: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82332174: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82332178: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233217C: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82332180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82332184: 419A0034  beq cr6, 0x823321b8
	if ctx.cr[6].eq {
	pc = 0x823321B8; continue 'dispatch;
	}
	// 82332188: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233218C: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 82332190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82332194: 917F039C  stw r11, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[11].u32 ) };
	// 82332198: 48000D91  bl 0x82332f28
	ctx.lr = 0x8233219C;
	sub_82332F28(ctx, base);
	// 8233219C: 3D60822B  lis r11, -0x7dd5
	ctx.r[11].s64 = -2111111168;
	// 823321A0: 813F03E4  lwz r9, 0x3e4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(996 as u32) ) } as u64;
	// 823321A4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823321A8: 396B2F80  addi r11, r11, 0x2f80
	ctx.r[11].s64 = ctx.r[11].s64 + 12160;
	// 823321AC: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823321B0: 917F03F8  stw r11, 0x3f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[11].u32 ) };
	// 823321B4: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823321B8; continue 'dispatch;
            }
            0x823321B8 => {
    //   block [0x823321B8..0x823321CC)
	// 823321B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823321BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823321C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823321C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823321C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823321D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823321D0 size=160
    let mut pc: u32 = 0x823321D0;
    'dispatch: loop {
        match pc {
            0x823321D0 => {
    //   block [0x823321D0..0x82332210)
	// 823321D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823321D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823321D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823321DC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 823321E0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823321E4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 823321E8: 392ADD38  addi r9, r10, -0x22c8
	ctx.r[9].s64 = ctx.r[10].s64 + -8904;
	// 823321EC: 396BBCD0  addi r11, r11, -0x4330
	ctx.r[11].s64 = ctx.r[11].s64 + -17200;
	// 823321F0: 81070398  lwz r8, 0x398(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(920 as u32) ) } as u64;
	// 823321F4: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823321F8: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823321FC: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82332200: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82332204: 419A000C  beq cr6, 0x82332210
	if ctx.cr[6].eq {
	pc = 0x82332210; continue 'dispatch;
	}
	// 82332208: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8233220C: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	pc = 0x82332210; continue 'dispatch;
            }
            0x82332210 => {
    //   block [0x82332210..0x82332260)
	// 82332210: 38670390  addi r3, r7, 0x390
	ctx.r[3].s64 = ctx.r[7].s64 + 912;
	// 82332214: 4800338D  bl 0x823355a0
	ctx.lr = 0x82332218;
	sub_823355A0(ctx, base);
	// 82332218: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8233221C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82332220: 396B4634  addi r11, r11, 0x4634
	ctx.r[11].s64 = ctx.r[11].s64 + 17972;
	// 82332224: 394ADED0  addi r10, r10, -0x2130
	ctx.r[10].s64 = ctx.r[10].s64 + -8496;
	// 82332228: 548907FE  clrlwi r9, r4, 0x1f
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 8233222C: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82332230: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82332234: 91670370  stw r11, 0x370(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(880 as u32), ctx.r[11].u32 ) };
	// 82332238: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8233223C: 419A0024  beq cr6, 0x82332260
	if ctx.cr[6].eq {
	pc = 0x82332260; continue 'dispatch;
	}
	// 82332240: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82332244: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82332248: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 8233224C: 409A0014  bne cr6, 0x82332260
	if !ctx.cr[6].eq {
	pc = 0x82332260; continue 'dispatch;
	}
	// 82332250: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82332254: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82332258: 99670019  stb r11, 0x19(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8233225C: 99470025  stb r10, 0x25(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x82332260; continue 'dispatch;
            }
            0x82332260 => {
    //   block [0x82332260..0x82332270)
	// 82332260: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82332264: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82332268: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233226C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82332270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82332270 size=764
    let mut pc: u32 = 0x82332270;
    'dispatch: loop {
        match pc {
            0x82332270 => {
    //   block [0x82332270..0x823322A4)
	// 82332270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82332274: 48202E35  bl 0x825350a8
	ctx.lr = 0x82332278;
	sub_82535080(ctx, base);
	// 82332278: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8233227C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82332280: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 82332284: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82332288: 3BCB49C8  addi r30, r11, 0x49c8
	ctx.r[30].s64 = ctx.r[11].s64 + 18888;
	// 8233228C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82332290: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82332294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82332298: 409A000C  bne cr6, 0x823322a4
	if !ctx.cr[6].eq {
	pc = 0x823322A4; continue 'dispatch;
	}
	// 8233229C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 823322A0: 4800002C  b 0x823322cc
	pc = 0x823322CC; continue 'dispatch;
            }
            0x823322A4 => {
    //   block [0x823322A4..0x823322BC)
	// 823322A4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823322A8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823322AC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823322B0: 419A000C  beq cr6, 0x823322bc
	if ctx.cr[6].eq {
	pc = 0x823322BC; continue 'dispatch;
	}
	// 823322B4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 823322B8: 48000014  b 0x823322cc
	pc = 0x823322CC; continue 'dispatch;
            }
            0x823322BC => {
    //   block [0x823322BC..0x823322CC)
	// 823322BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823322C0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823322C4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823322C8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x823322CC; continue 'dispatch;
            }
            0x823322CC => {
    //   block [0x823322CC..0x82332420)
	// 823322CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823322D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823322D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823322D8: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823322DC: 409A0144  bne cr6, 0x82332420
	if !ctx.cr[6].eq {
	pc = 0x82332420; continue 'dispatch;
	}
	// 823322E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823322E4: 815F03E0  lwz r10, 0x3e0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(992 as u32) ) } as u64;
	// 823322E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823322EC: 38CBDD2C  addi r6, r11, -0x22d4
	ctx.r[6].s64 = ctx.r[11].s64 + -8916;
	// 823322F0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 823322F4: A36A0008  lhz r27, 8(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823322F8: 386BDBE0  addi r3, r11, -0x2420
	ctx.r[3].s64 = ctx.r[11].s64 + -9248;
	// 823322FC: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 82332300: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82332304: 916ABC4C  stw r11, -0x43b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17332 as u32), ctx.r[11].u32 ) };
	// 82332308: 817F0374  lwz r11, 0x374(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 8233230C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82332310: 7F8A5A2E  lhzx r28, r10, r11
	ctx.r[28].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82332314: 7D7CD9D6  mullw r11, r28, r27
	ctx.r[11].s32 = ((ctx.r[28].s32 as i64 * ctx.r[27].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82332318: 55653032  slwi r5, r11, 6
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8233231C: 4BEC2FCD  bl 0x821f52e8
	ctx.lr = 0x82332320;
	sub_821F52E8(ctx, base);
	// 82332320: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82332324: 4BEFB0C5  bl 0x8222d3e8
	ctx.lr = 0x82332328;
	sub_8222D3E8(ctx, base);
	// 82332328: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8233232C: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 82332330: 3B3F0330  addi r25, r31, 0x330
	ctx.r[25].s64 = ctx.r[31].s64 + 816;
	// 82332334: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82332338: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	pc = 0x82332420; continue 'dispatch;
            }
            0x82332420 => {
    //   block [0x82332420..0x8233256C)
	// 82332420: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82332424: 815F03E4  lwz r10, 0x3e4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(996 as u32) ) } as u64;
	// 82332428: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233242C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82332430: 931F00C0  stw r24, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[24].u32 ) };
	// 82332434: 817F0374  lwz r11, 0x374(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 82332438: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233243C: 7FCA5A2E  lhzx r30, r10, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82332440: 48200DD1  bl 0x82533210
	ctx.lr = 0x82332444;
	sub_82533210(ctx, base);
	// 82332444: 546A047E  clrlwi r10, r3, 0x11
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82332448: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8233244C: 7FC907B4  extsw r9, r30
	ctx.r[9].s64 = ctx.r[30].s32 as i64;
	// 82332450: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82332454: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82332458: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8233245C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82332460: C9A10058  lfd f13, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82332464: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82332468: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8233246C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82332470: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82332474: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82332478: C00A206C  lfs f0, 0x206c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233247C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82332480: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82332484: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82332488: 40980008  bge cr6, 0x82332490
	if !ctx.cr[6].lt {
	pc = 0x82332490; continue 'dispatch;
	}
	// 8233248C: 817F0378  lwz r11, 0x378(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(888 as u32) ) } as u64;
	// 82332490: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82332494: 815F0374  lwz r10, 0x374(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 82332498: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8233249C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823324A0: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823324A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823324A8: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 823324AC: 817F0374  lwz r11, 0x374(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 823324B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823324B4: 419A0018  beq cr6, 0x823324cc
	if ctx.cr[6].eq {
	pc = 0x823324CC; continue 'dispatch;
	}
	// 823324B8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823324BC: 931F0378  stw r24, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[24].u32 ) };
	// 823324C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823324C4: 41990010  bgt cr6, 0x823324d4
	if ctx.cr[6].gt {
	pc = 0x823324D4; continue 'dispatch;
	}
	// 823324C8: 48000008  b 0x823324d0
	pc = 0x823324D0; continue 'dispatch;
	// 823324CC: 931F0378  stw r24, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[24].u32 ) };
	// 823324D0: D3FF037C  stfs f31, 0x37c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	// 823324D4: 815F03E8  lwz r10, 0x3e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) } as u64;
	// 823324D8: C03F00C4  lfs f1, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823324DC: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 823324E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823324E4: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823324E8: 419A0054  beq cr6, 0x8233253c
	if ctx.cr[6].eq {
	pc = 0x8233253C; continue 'dispatch;
	}
	// 823324EC: 815F0374  lwz r10, 0x374(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 823324F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823324F4: 419A0030  beq cr6, 0x82332524
	if ctx.cr[6].eq {
	pc = 0x82332524; continue 'dispatch;
	}
	// 823324F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823324FC: 41980010  blt cr6, 0x8233250c
	if ctx.cr[6].lt {
	pc = 0x8233250C; continue 'dispatch;
	}
	// 82332500: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82332504: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82332508: 41980020  blt cr6, 0x82332528
	if ctx.cr[6].lt {
	pc = 0x82332528; continue 'dispatch;
	}
	// 8233250C: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 82332510: D3FF037C  stfs f31, 0x37c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	// 82332514: 931F0378  stw r24, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[24].u32 ) };
	// 82332518: D03F037C  stfs f1, 0x37c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	// 8233251C: 4BEEBEB5  bl 0x8221e3d0
	ctx.lr = 0x82332520;
	sub_8221E3D0(ctx, base);
	// 82332520: 48000024  b 0x82332544
	pc = 0x82332544; continue 'dispatch;
	// 82332524: D3FF037C  stfs f31, 0x37c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	// 82332528: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 8233252C: 917F0378  stw r11, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[11].u32 ) };
	// 82332530: D03F037C  stfs f1, 0x37c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	// 82332534: 4BEEBE9D  bl 0x8221e3d0
	ctx.lr = 0x82332538;
	sub_8221E3D0(ctx, base);
	// 82332538: 4800000C  b 0x82332544
	pc = 0x82332544; continue 'dispatch;
	// 8233253C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82332540: 48000C31  bl 0x82333170
	ctx.lr = 0x82332544;
	sub_82333170(ctx, base);
	// 82332544: 3D608233  lis r11, -0x7dcd
	ctx.r[11].s64 = -2110586880;
	// 82332548: 931F03F0  stw r24, 0x3f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), ctx.r[24].u32 ) };
	// 8233254C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82332550: 931F039C  stw r24, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[24].u32 ) };
	// 82332554: 396B2628  addi r11, r11, 0x2628
	ctx.r[11].s64 = ctx.r[11].s64 + 9768;
	// 82332558: 995F001C  stb r10, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 8233255C: 917F03F8  stw r11, 0x3f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[11].u32 ) };
	// 82332560: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82332564: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82332568: 48202B90  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82332570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82332570 size=180
    let mut pc: u32 = 0x82332570;
    'dispatch: loop {
        match pc {
            0x82332570 => {
    //   block [0x82332570..0x823325EC)
	// 82332570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82332574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82332578: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233257C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82332580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82332584: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82332588: 817E03F8  lwz r11, 0x3f8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1016 as u32) ) } as u64;
	// 8233258C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82332590: 419A007C  beq cr6, 0x8233260c
	if ctx.cr[6].eq {
	pc = 0x8233260C; continue 'dispatch;
	}
	// 82332594: 817E0398  lwz r11, 0x398(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(920 as u32) ) } as u64;
	// 82332598: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8233259C: 40980058  bge cr6, 0x823325f4
	if !ctx.cr[6].lt {
	pc = 0x823325F4; continue 'dispatch;
	}
	// 823325A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823325A4: 41980050  blt cr6, 0x823325f4
	if ctx.cr[6].lt {
	pc = 0x823325F4; continue 'dispatch;
	}
	// 823325A8: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 823325AC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823325B0: 3BEABCF0  addi r31, r10, -0x4310
	ctx.r[31].s64 = ctx.r[10].s64 + -17168;
	// 823325B4: 815E03E8  lwz r10, 0x3e8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1000 as u32) ) } as u64;
	// 823325B8: 7C8BF82E  lwzx r4, r11, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823325BC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823325C0: 419A002C  beq cr6, 0x823325ec
	if ctx.cr[6].eq {
	pc = 0x823325EC; continue 'dispatch;
	}
	// 823325C4: 817E03E0  lwz r11, 0x3e0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(992 as u32) ) } as u64;
	// 823325C8: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823325CC: A16B0008  lhz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823325D0: 5565303E  rotlwi r5, r11, 6
	ctx.r[5].u64 = ((ctx.r[11].u32).rotate_left(6)) as u64;
	// 823325D4: 4820257D  bl 0x82534b50
	ctx.lr = 0x823325D8;
	sub_82534B50(ctx, base);
	// 823325D8: 817E0398  lwz r11, 0x398(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(920 as u32) ) } as u64;
	// 823325DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823325E0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823325E4: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 823325E8: 48000024  b 0x8233260c
	pc = 0x8233260C; continue 'dispatch;
            }
            0x823325EC => {
    //   block [0x823325EC..0x823325F4)
	// 823325EC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823325F0: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	pc = 0x823325F4; continue 'dispatch;
            }
            0x823325F4 => {
    //   block [0x823325F4..0x8233260C)
	// 823325F4: 817E03F8  lwz r11, 0x3f8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1016 as u32) ) } as u64;
	// 823325F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823325FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82332600: 4E800421  bctrl
	ctx.lr = 0x82332604;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82332604: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82332608: 48000C79  bl 0x82333280
	ctx.lr = 0x8233260C;
	sub_82333280(ctx, base);
            }
            0x8233260C => {
    //   block [0x8233260C..0x82332624)
	// 8233260C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82332610: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82332614: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82332618: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233261C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82332620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82332628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82332628 size=768
    let mut pc: u32 = 0x82332628;
    'dispatch: loop {
        match pc {
            0x82332628 => {
    //   block [0x82332628..0x82332694)
	// 82332628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233262C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82332630: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82332634: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82332638: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8233263C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82332640: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82332644: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82332648: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8233264C: 409A0048  bne cr6, 0x82332694
	if !ctx.cr[6].eq {
	pc = 0x82332694; continue 'dispatch;
	}
	// 82332650: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82332654: C01F00C4  lfs f0, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82332658: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8233265C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82332660: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82332664: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82332668: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8233266C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82332670: 41980024  blt cr6, 0x82332694
	if ctx.cr[6].lt {
	pc = 0x82332694; continue 'dispatch;
	}
	// 82332674: 3D60822B  lis r11, -0x7dd5
	ctx.r[11].s64 = -2111111168;
	// 82332678: 813F03E4  lwz r9, 0x3e4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(996 as u32) ) } as u64;
	// 8233267C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82332680: 396B2F80  addi r11, r11, 0x2f80
	ctx.r[11].s64 = ctx.r[11].s64 + 12160;
	// 82332684: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82332688: 917F03F8  stw r11, 0x3f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[11].u32 ) };
	// 8233268C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82332690: 4800027C  b 0x8233290c
	pc = 0x8233290C; continue 'dispatch;
            }
            0x82332694 => {
    //   block [0x82332694..0x82332720)
	// 82332694: 817F03F0  lwz r11, 0x3f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 82332698: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8233269C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823326A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823326A4: C3CABA38  lfs f30, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823326A8: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823326AC: 409A008C  bne cr6, 0x82332738
	if !ctx.cr[6].eq {
	pc = 0x82332738; continue 'dispatch;
	}
	// 823326B0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823326B4: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823326B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823326BC: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 823326C0: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 823326C4: D3C1006C  stfs f30, 0x6c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 823326C8: 48000789  bl 0x82332e50
	ctx.lr = 0x823326CC;
	sub_82332E50(ctx, base);
	// 823326CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823326D0: 419A0068  beq cr6, 0x82332738
	if ctx.cr[6].eq {
	pc = 0x82332738; continue 'dispatch;
	}
	// 823326D4: 48200B3D  bl 0x82533210
	ctx.lr = 0x823326D8;
	sub_82533210(ctx, base);
	// 823326D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823326DC: 546A047E  clrlwi r10, r3, 0x11
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 823326E0: C00BD6C8  lfs f0, -0x2938(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823326E4: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 823326E8: 806BB514  lwz r3, -0x4aec(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19180 as u32) ) } as u64;
	// 823326EC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 823326F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823326F4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823326F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823326FC: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82332700: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82332704: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82332708: C1AB206C  lfs f13, 0x206c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8300 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233270C: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82332710: EC2DF03A  fmadds f1, f13, f0, f30
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64);
	// 82332714: 419A000C  beq cr6, 0x82332720
	if ctx.cr[6].eq {
	pc = 0x82332720; continue 'dispatch;
	}
	// 82332718: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8233271C: 4BFEE83D  bl 0x82320f58
	ctx.lr = 0x82332720;
	sub_82320F58(ctx, base);
	pc = 0x82332720; continue 'dispatch;
            }
            0x82332720 => {
    //   block [0x82332720..0x82332738)
	// 82332720: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82332724: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82332728: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 8233272C: 4802FF55  bl 0x82362680
	ctx.lr = 0x82332730;
	sub_82362680(ctx, base);
	// 82332730: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82332734: 917F03F0  stw r11, 0x3f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), ctx.r[11].u32 ) };
	pc = 0x82332738; continue 'dispatch;
            }
            0x82332738 => {
    //   block [0x82332738..0x8233290C)
	// 82332738: 815F00CC  lwz r10, 0xcc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 8233273C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82332740: D3E10070  stfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82332744: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82332748: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 8233274C: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82332750: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82332754: C19F00C4  lfs f12, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82332758: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 8233275C: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82332760: 397F0330  addi r11, r31, 0x330
	ctx.r[11].s64 = ctx.r[31].s64 + 816;
	// 82332764: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82332768: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 8233276C: C00A9F78  lfs f0, -0x6088(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82332770: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82332774: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	pc = 0x8233290C; continue 'dispatch;
            }
            0x8233290C => {
    //   block [0x8233290C..0x82332928)
	// 8233290C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82332910: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82332914: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82332918: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8233291C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82332920: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82332924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82332928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82332928 size=684
    let mut pc: u32 = 0x82332928;
    'dispatch: loop {
        match pc {
            0x82332928 => {
    //   block [0x82332928..0x82332974)
	// 82332928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233292C: 48202791  bl 0x825350bc
	ctx.lr = 0x82332930;
	sub_82535080(ctx, base);
	// 82332930: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82332934: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82332938: 9421F770  stwu r1, -0x890(r1)
	ea = ctx.r[1].u32.wrapping_add(-2192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233293C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82332940: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82332944: C1BD03B8  lfs f13, 0x3b8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(952 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82332948: C00BD560  lfs f0, -0x2aa0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233294C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82332950: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82332954: D01D03B8  stfs f0, 0x3b8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(952 as u32), tmp.u32 ) };
	// 82332958: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233295C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82332960: 41980014  blt cr6, 0x82332974
	if ctx.cr[6].lt {
	pc = 0x82332974; continue 'dispatch;
	}
	// 82332964: 3D608233  lis r11, -0x7dcd
	ctx.r[11].s64 = -2110586880;
	// 82332968: D1BD03B8  stfs f13, 0x3b8(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(952 as u32), tmp.u32 ) };
	// 8233296C: 396B2628  addi r11, r11, 0x2628
	ctx.r[11].s64 = ctx.r[11].s64 + 9768;
	// 82332970: 917D03F8  stw r11, 0x3f8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(1016 as u32), ctx.r[11].u32 ) };
	pc = 0x82332974; continue 'dispatch;
            }
            0x82332974 => {
    //   block [0x82332974..0x82332998)
	// 82332974: 817D00CC  lwz r11, 0xcc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(204 as u32) ) } as u64;
	// 82332978: C1BD00C4  lfs f13, 0xc4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233297C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82332980: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82332984: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82332988: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8233298C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82332990: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82332994: 40990030  ble cr6, 0x823329c4
	if !ctx.cr[6].gt {
	pc = 0x823329C4; continue 'dispatch;
	}
	pc = 0x82332998; continue 'dispatch;
            }
            0x82332998 => {
    //   block [0x82332998..0x823329C4)
	// 82332998: C1BD00C4  lfs f13, 0xc4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233299C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823329A0: D1BD00C4  stfs f13, 0xc4(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 823329A4: 817D00CC  lwz r11, 0xcc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(204 as u32) ) } as u64;
	// 823329A8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823329AC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823329B0: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823329B4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 823329B8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 823329BC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 823329C0: 4199FFD8  bgt cr6, 0x82332998
	if ctx.cr[6].gt {
	pc = 0x82332998; continue 'dispatch;
	}
	pc = 0x823329C4; continue 'dispatch;
            }
            0x823329C4 => {
    //   block [0x823329C4..0x823329F0)
	// 823329C4: 396100DF  addi r11, r1, 0xdf
	ctx.r[11].s64 = ctx.r[1].s64 + 223;
	// 823329C8: 39410860  addi r10, r1, 0x860
	ctx.r[10].s64 = ctx.r[1].s64 + 2144;
	// 823329CC: 55690030  rlwinm r9, r11, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823329D0: 554B0030  rlwinm r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823329D4: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 823329D8: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 823329DC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823329E0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 823329E4: 419A000C  beq cr6, 0x823329f0
	if ctx.cr[6].eq {
	pc = 0x823329F0; continue 'dispatch;
	}
	// 823329E8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 823329EC: 7C004A2C  dcbt 0, r9
	pc = 0x823329F0; continue 'dispatch;
            }
            0x823329F0 => {
    //   block [0x823329F0..0x823329FC)
	// 823329F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823329F4: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 823329F8: 41980080  blt cr6, 0x82332a78
	if ctx.cr[6].lt {
	pc = 0x82332A78; continue 'dispatch;
	}
	pc = 0x823329FC; continue 'dispatch;
            }
            0x823329FC => {
    //   block [0x823329FC..0x82332A78)
	// 823329FC: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 82332A00: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332A04: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82332A08: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 82332A0C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332A10: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 82332A14: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82332A18: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332A1C: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 82332A20: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82332A24: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332A28: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 82332A2C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82332A30: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332A34: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 82332A38: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82332A3C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332A40: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 82332A44: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82332A48: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332A4C: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 82332A50: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82332A54: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332A58: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82332A5C: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 82332A60: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82332A64: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 82332A68: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 82332A6C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82332A70: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82332A74: 4098FF88  bge cr6, 0x823329fc
	if !ctx.cr[6].lt {
	pc = 0x823329FC; continue 'dispatch;
	}
	pc = 0x82332A78; continue 'dispatch;
            }
            0x82332A78 => {
    //   block [0x82332A78..0x82332ABC)
	// 82332A78: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 82332A7C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82332A80: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 82332A84: 41990088  bgt cr6, 0x82332b0c
	if ctx.cr[6].gt {
	pc = 0x82332B0C; continue 'dispatch;
	}
	// 82332A88: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 82332A8C: 398C2AA0  addi r12, r12, 0x2aa0
	ctx.r[12].s64 = ctx.r[12].s64 + 10912;
	// 82332A90: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82332A94: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82332A98: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82332A9C: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x82332B04; continue 'dispatch;
		},
		1 => {
	pc = 0x82332AF8; continue 'dispatch;
		},
		2 => {
	pc = 0x82332AEC; continue 'dispatch;
		},
		3 => {
	pc = 0x82332AE0; continue 'dispatch;
		},
		4 => {
	pc = 0x82332AD4; continue 'dispatch;
		},
		5 => {
	pc = 0x82332AC8; continue 'dispatch;
		},
		6 => {
	pc = 0x82332ABC; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82332AA0: 82332B04  lwz r17, 0x2b04(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(11012 as u32) ) } as u64;
	// 82332AA4: 82332AF8  lwz r17, 0x2af8(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(11000 as u32) ) } as u64;
	// 82332AA8: 82332AEC  lwz r17, 0x2aec(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(10988 as u32) ) } as u64;
	// 82332AAC: 82332AE0  lwz r17, 0x2ae0(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(10976 as u32) ) } as u64;
	// 82332AB0: 82332AD4  lwz r17, 0x2ad4(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(10964 as u32) ) } as u64;
	// 82332AB4: 82332AC8  lwz r17, 0x2ac8(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(10952 as u32) ) } as u64;
	// 82332AB8: 82332ABC  lwz r17, 0x2abc(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(10940 as u32) ) } as u64;
            }
            0x82332ABC => {
    //   block [0x82332ABC..0x82332AC8)
	// 82332ABC: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 82332AC0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332AC4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82332AC8; continue 'dispatch;
            }
            0x82332AC8 => {
    //   block [0x82332AC8..0x82332AD4)
	// 82332AC8: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 82332ACC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332AD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82332AD4; continue 'dispatch;
            }
            0x82332AD4 => {
    //   block [0x82332AD4..0x82332AE0)
	// 82332AD4: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 82332AD8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332ADC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82332AE0; continue 'dispatch;
            }
            0x82332AE0 => {
    //   block [0x82332AE0..0x82332AEC)
	// 82332AE0: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 82332AE4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332AE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82332AEC; continue 'dispatch;
            }
            0x82332AEC => {
    //   block [0x82332AEC..0x82332AF8)
	// 82332AEC: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 82332AF0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332AF4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82332AF8; continue 'dispatch;
            }
            0x82332AF8 => {
    //   block [0x82332AF8..0x82332B04)
	// 82332AF8: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 82332AFC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332B00: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82332B04; continue 'dispatch;
            }
            0x82332B04 => {
    //   block [0x82332B04..0x82332B0C)
	// 82332B04: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 82332B08: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	pc = 0x82332B0C; continue 'dispatch;
            }
            0x82332B0C => {
    //   block [0x82332B0C..0x82332B44)
	// 82332B0C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82332B10: C03D00C4  lfs f1, 0xc4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82332B14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82332B18: 809D00C0  lwz r4, 0xc0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 82332B1C: 4800039D  bl 0x82332eb8
	ctx.lr = 0x82332B20;
	sub_82332EB8(ctx, base);
	// 82332B20: 817D03E0  lwz r11, 0x3e0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(992 as u32) ) } as u64;
	// 82332B24: A3CB0008  lhz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82332B28: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82332B2C: 419A0074  beq cr6, 0x82332ba0
	if ctx.cr[6].eq {
	pc = 0x82332BA0; continue 'dispatch;
	}
	// 82332B30: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82332B34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82332B38: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82332B3C: C3CA2068  lfs f30, 0x2068(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8296 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82332B40: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82332B44; continue 'dispatch;
            }
            0x82332B44 => {
    //   block [0x82332B44..0x82332B58)
	// 82332B44: C01D03B8  lfs f0, 0x3b8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(952 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82332B48: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82332B4C: 409A000C  bne cr6, 0x82332b58
	if !ctx.cr[6].eq {
	pc = 0x82332B58; continue 'dispatch;
	}
	// 82332B50: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82332B54: 4800001C  b 0x82332b70
	pc = 0x82332B70; continue 'dispatch;
            }
            0x82332B58 => {
    //   block [0x82332B58..0x82332B70)
	// 82332B58: FC200210  fabs f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82332B5C: 4820047D  bl 0x82532fd8
	ctx.lr = 0x82332B60;
	sub_82532FD8(ctx, base);
	// 82332B60: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82332B64: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82332B68: 48200931  bl 0x82533498
	ctx.lr = 0x82332B6C;
	sub_82533498(ctx, base);
	// 82332B6C: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	pc = 0x82332B70; continue 'dispatch;
            }
            0x82332B70 => {
    //   block [0x82332B70..0x82332BA0)
	// 82332B70: 817D03E8  lwz r11, 0x3e8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82332B74: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82332B78: 7CBF5214  add r5, r31, r10
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 82332B7C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82332B80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82332B84: 7C8AFA14  add r4, r10, r31
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82332B88: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82332B8C: 4803576D  bl 0x823682f8
	ctx.lr = 0x82332B90;
	sub_823682F8(ctx, base);
	// 82332B90: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 82332B94: 3BFF0040  addi r31, r31, 0x40
	ctx.r[31].s64 = ctx.r[31].s64 + 64;
	// 82332B98: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82332B9C: 409AFFA8  bne cr6, 0x82332b44
	if !ctx.cr[6].eq {
	pc = 0x82332B44; continue 'dispatch;
	}
	pc = 0x82332BA0; continue 'dispatch;
            }
            0x82332BA0 => {
    //   block [0x82332BA0..0x82332BD4)
	// 82332BA0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82332BA4: C1BD00C4  lfs f13, 0xc4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82332BA8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82332BAC: C19D00C8  lfs f12, 0xc8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(200 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82332BB0: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82332BB4: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 82332BB8: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82332BBC: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82332BC0: D01D00C4  stfs f0, 0xc4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82332BC4: 38210890  addi r1, r1, 0x890
	ctx.r[1].s64 = ctx.r[1].s64 + 2192;
	// 82332BC8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82332BCC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82332BD0: 4820253C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82332BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82332BD8 size=628
    //   switch @ 0x82332D08: r11 with 8 label(s)
    //       case  0  0x82332D2C
    //       case  1  0x82332D78
    //       case  2  0x82332D78
    //       case  3  0x82332D8C
    //       case  4  0x82332D9C
    //       case  5  0x82332D78
    //       case  6  0x82332D78
    //       case  7  0x82332C10
    let mut pc: u32 = 0x82332BD8;
    'dispatch: loop {
        match pc {
            0x82332BD8 => {
    //   block [0x82332BD8..0x82332C10)
	// 82332BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82332BDC: 482024CD  bl 0x825350a8
	ctx.lr = 0x82332BE0;
	sub_82535080(ctx, base);
	// 82332BE0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82332BE4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82332BE8: 3B00FFFF  li r24, -1
	ctx.r[24].s64 = -1;
	// 82332BEC: 817B00CC  lwz r11, 0xcc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(204 as u32) ) } as u64;
	// 82332BF0: C01B00C4  lfs f0, 0xc4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82332BF4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82332BF8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82332BFC: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82332C00: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82332C04: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82332C08: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82332C0C: 41990010  bgt cr6, 0x82332c1c
	if ctx.cr[6].gt {
	pc = 0x82332C1C; continue 'dispatch;
	}
	pc = 0x82332C10; continue 'dispatch;
            }
            0x82332C10 => {
    //   block [0x82332C10..0x82332C1C)
	// 82332C10: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82332C14: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82332C18: 482024E0  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x82332C1C => {
    //   block [0x82332C1C..0x82332D2C)
	// 82332C1C: 482005F5  bl 0x82533210
	ctx.lr = 0x82332C20;
	sub_82533210(ctx, base);
	// 82332C20: 815B03E4  lwz r10, 0x3e4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(996 as u32) ) } as u64;
	// 82332C24: 3D6051EB  lis r11, 0x51eb
	ctx.r[11].s64 = 1374355456;
	// 82332C28: 3BBB0080  addi r29, r27, 0x80
	ctx.r[29].s64 = ctx.r[27].s64 + 128;
	// 82332C2C: 616B851F  ori r11, r11, 0x851f
	ctx.r[11].u64 = ctx.r[11].u64 | 34079;
	// 82332C30: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 82332C34: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82332C38: 7D635896  mulhw r11, r3, r11
	ctx.r[11].s64 = ((ctx.r[3].s32 as i64 * ctx.r[11].s32 as i64) >> 32);
	// 82332C3C: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82332C40: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 82332C44: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82332C48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82332C4C: 695A0001  xori r26, r10, 1
	ctx.r[26].u64 = ctx.r[10].u64 ^ 1;
	// 82332C50: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82332C54: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82332C58: 1D6B0064  mulli r11, r11, 0x64
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82332C5C: 7F2B1850  subf r25, r11, r3
	ctx.r[25].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82332C60: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82332C64: 3B8B76FC  addi r28, r11, 0x76fc
	ctx.r[28].s64 = ctx.r[11].s64 + 30460;
	// 82332C68: 7D7EE02E  lwzx r11, r30, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82332C6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82332C70: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 82332C74: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82332C78: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82332C7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82332C80: 4E800421  bctrl
	ctx.lr = 0x82332C84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82332C84: 397FFFF8  addi r11, r31, -8
	ctx.r[11].s64 = ctx.r[31].s64 + -8;
	// 82332C88: 395F0018  addi r10, r31, 0x18
	ctx.r[10].s64 = ctx.r[31].s64 + 24;
	// 82332C8C: C1630030  lfs f11, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82332C90: C1430034  lfs f10, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82332C94: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82332C98: C1230038  lfs f9, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82332C9C: D17FFFF8  stfs f11, -8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82332CA0: D15FFFFC  stfs f10, -4(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82332CA4: D13F0000  stfs f9, 0(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82332CA8: C01D0030  lfs f0, 0x30(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82332CAC: 7C7E492E  stwx r3, r30, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32), ctx.r[3].u32) };
	// 82332CB0: C1BD0034  lfs f13, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82332CB4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82332CB8: C19D0038  lfs f12, 0x38(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82332CBC: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82332CC0: 2B1E0008  cmplwi cr6, r30, 8
	ctx.cr[6].compare_u32(ctx.r[30].u32, 8 as u32, &mut ctx.xer);
	// 82332CC4: D1BF001C  stfs f13, 0x1c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82332CC8: D19F0020  stfs f12, 0x20(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82332CCC: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
            }
            0x82332D2C => {
    //   block [0x82332D2C..0x82332D78)
	// 82332D2C: 817B03BC  lwz r11, 0x3bc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(956 as u32) ) } as u64;
	// 82332D30: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82332D34: 409900C8  ble cr6, 0x82332dfc
	if !ctx.cr[6].gt {
	pc = 0x82332DFC; continue 'dispatch;
	}
	// 82332D38: 2F190050  cmpwi cr6, r25, 0x50
	ctx.cr[6].compare_i32(ctx.r[25].s32, 80, &mut ctx.xer);
	// 82332D3C: 4099001C  ble cr6, 0x82332d58
	if !ctx.cr[6].gt {
	pc = 0x82332D58; continue 'dispatch;
	}
	// 82332D40: 482004D1  bl 0x82533210
	ctx.lr = 0x82332D44;
	sub_82533210(ctx, base);
	// 82332D44: 546B07FE  clrlwi r11, r3, 0x1f
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	// 82332D48: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82332D4C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82332D50: 3B0B0003  addi r24, r11, 3
	ctx.r[24].s64 = ctx.r[11].s64 + 3;
	// 82332D54: 48000054  b 0x82332da8
	pc = 0x82332DA8; continue 'dispatch;
	// 82332D58: 2F19003C  cmpwi cr6, r25, 0x3c
	ctx.cr[6].compare_i32(ctx.r[25].s32, 60, &mut ctx.xer);
	// 82332D5C: 409900A0  ble cr6, 0x82332dfc
	if !ctx.cr[6].gt {
	pc = 0x82332DFC; continue 'dispatch;
	}
	// 82332D60: 482004B1  bl 0x82533210
	ctx.lr = 0x82332D64;
	sub_82533210(ctx, base);
	// 82332D64: 546B07FE  clrlwi r11, r3, 0x1f
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	// 82332D68: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82332D6C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82332D70: 3B0B0001  addi r24, r11, 1
	ctx.r[24].s64 = ctx.r[11].s64 + 1;
	// 82332D74: 48000034  b 0x82332da8
	pc = 0x82332DA8; continue 'dispatch;
            }
            0x82332D78 => {
    //   block [0x82332D78..0x82332D8C)
	// 82332D78: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82332D7C: 817FBC4C  lwz r11, -0x43b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17332 as u32) ) } as u64;
	// 82332D80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82332D84: 917FBC4C  stw r11, -0x43b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-17332 as u32), ctx.r[11].u32 ) };
	// 82332D88: 48000038  b 0x82332dc0
	pc = 0x82332DC0; continue 'dispatch;
            }
            0x82332D8C => {
    //   block [0x82332D8C..0x82332D9C)
	// 82332D8C: 217A0000  subfic r11, r26, 0
	ctx.xer.ca = ctx.r[26].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[26].s64;
	// 82332D90: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82332D94: 5578077A  rlwinm r24, r11, 0, 0x1d, 0x1d
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82332D98: 48000010  b 0x82332da8
	pc = 0x82332DA8; continue 'dispatch;
            }
            0x82332D9C => {
    //   block [0x82332D9C..0x82332E4C)
	// 82332D9C: 217A0000  subfic r11, r26, 0
	ctx.xer.ca = ctx.r[26].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[26].s64;
	// 82332DA0: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82332DA4: 557807BE  clrlwi r24, r11, 0x1e
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82332DA8: 2F180003  cmpwi cr6, r24, 3
	ctx.cr[6].compare_i32(ctx.r[24].s32, 3, &mut ctx.xer);
	// 82332DAC: 409A0030  bne cr6, 0x82332ddc
	if !ctx.cr[6].eq {
	pc = 0x82332DDC; continue 'dispatch;
	}
	// 82332DB0: 817B00C0  lwz r11, 0xc0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 82332DB4: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82332DB8: 409A0044  bne cr6, 0x82332dfc
	if !ctx.cr[6].eq {
	pc = 0x82332DFC; continue 'dispatch;
	}
	// 82332DBC: 817FBC4C  lwz r11, -0x43b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17332 as u32) ) } as u64;
	// 82332DC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82332DC4: 4098006C  bge cr6, 0x82332e30
	if !ctx.cr[6].lt {
	pc = 0x82332E30; continue 'dispatch;
	}
	// 82332DC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82332DCC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82332DD0: 917FBC4C  stw r11, -0x43b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-17332 as u32), ctx.r[11].u32 ) };
	// 82332DD4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82332DD8: 48202320  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
	// 82332DDC: 2F180004  cmpwi cr6, r24, 4
	ctx.cr[6].compare_i32(ctx.r[24].s32, 4, &mut ctx.xer);
	// 82332DE0: 409A0014  bne cr6, 0x82332df4
	if !ctx.cr[6].eq {
	pc = 0x82332DF4; continue 'dispatch;
	}
	// 82332DE4: 817B00C0  lwz r11, 0xc0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 82332DE8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82332DEC: 409A0010  bne cr6, 0x82332dfc
	if !ctx.cr[6].eq {
	pc = 0x82332DFC; continue 'dispatch;
	}
	// 82332DF0: 4BFFFFCC  b 0x82332dbc
	pc = 0x82332DBC; continue 'dispatch;
	// 82332DF4: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82332DF8: 419AFF84  beq cr6, 0x82332d7c
	if ctx.cr[6].eq {
	pc = 0x82332D7C; continue 'dispatch;
	}
	// 82332DFC: 817FBC4C  lwz r11, -0x43b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17332 as u32) ) } as u64;
	// 82332E00: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82332E04: 4198000C  blt cr6, 0x82332e10
	if ctx.cr[6].lt {
	pc = 0x82332E10; continue 'dispatch;
	}
	// 82332E08: 3B00FFFF  li r24, -1
	ctx.r[24].s64 = -1;
	// 82332E0C: 4BFFFFB4  b 0x82332dc0
	pc = 0x82332DC0; continue 'dispatch;
	// 82332E10: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82332E14: 4099FFAC  ble cr6, 0x82332dc0
	if !ctx.cr[6].gt {
	pc = 0x82332DC0; continue 'dispatch;
	}
	// 82332E18: 815B00C0  lwz r10, 0xc0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 82332E1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82332E20: 409AFFA0  bne cr6, 0x82332dc0
	if !ctx.cr[6].eq {
	pc = 0x82332DC0; continue 'dispatch;
	}
	// 82332E24: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82332E28: 917FBC4C  stw r11, -0x43b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-17332 as u32), ctx.r[11].u32 ) };
	// 82332E2C: 4BFFFF94  b 0x82332dc0
	pc = 0x82332DC0; continue 'dispatch;
	// 82332E30: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82332E34: 4099000C  ble cr6, 0x82332e40
	if !ctx.cr[6].gt {
	pc = 0x82332E40; continue 'dispatch;
	}
	// 82332E38: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82332E3C: 917FBC4C  stw r11, -0x43b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-17332 as u32), ctx.r[11].u32 ) };
	// 82332E40: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82332E44: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82332E48: 482022B0  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82332E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82332E50 size=100
    let mut pc: u32 = 0x82332E50;
    'dispatch: loop {
        match pc {
            0x82332E50 => {
    //   block [0x82332E50..0x82332EA0)
	// 82332E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82332E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82332E58: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82332E5C: 4BE84AAD  bl 0x821b7908
	ctx.lr = 0x82332E60;
	sub_821B7908(ctx, base);
	// 82332E60: 816303E8  lwz r11, 0x3e8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82332E64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82332E68: C00B03F0  lfs f0, 0x3f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1008 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82332E6C: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82332E70: C00B03F4  lfs f0, 0x3f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1012 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82332E74: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82332E78: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82332E7C: C1AB03F8  lfs f13, 0x3f8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1016 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82332E80: D1A40008  stfs f13, 8(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82332E84: 4098001C  bge cr6, 0x82332ea0
	if !ctx.cr[6].lt {
	pc = 0x82332EA0; continue 'dispatch;
	}
	// 82332E88: D0240004  stfs f1, 4(r4)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82332E8C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82332E90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82332E94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82332E98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82332E9C: 4E800020  blr
	return;
            }
            0x82332EA0 => {
    //   block [0x82332EA0..0x82332EB4)
	// 82332EA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82332EA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82332EA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82332EAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82332EB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82332EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82332EB8 size=104
    let mut pc: u32 = 0x82332EB8;
    'dispatch: loop {
        match pc {
            0x82332EB8 => {
    //   block [0x82332EB8..0x82332EEC)
	// 82332EB8: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82332EBC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82332EC0: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82332EC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82332EC8: 419A0058  beq cr6, 0x82332f20
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82332F20);
		return;
	}
	// 82332ECC: 812B0374  lwz r9, 0x374(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(884 as u32) ) } as u64;
	// 82332ED0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82332ED4: 419A0030  beq cr6, 0x82332f04
	if ctx.cr[6].eq {
	pc = 0x82332F04; continue 'dispatch;
	}
	// 82332ED8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82332EDC: 41980010  blt cr6, 0x82332eec
	if ctx.cr[6].lt {
	pc = 0x82332EEC; continue 'dispatch;
	}
	// 82332EE0: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82332EE4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82332EE8: 41980028  blt cr6, 0x82332f10
	if ctx.cr[6].lt {
	pc = 0x82332F10; continue 'dispatch;
	}
	pc = 0x82332EEC; continue 'dispatch;
            }
            0x82332EEC => {
    //   block [0x82332EEC..0x82332F04)
	// 82332EEC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82332EF0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82332EF4: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82332EF8: D00B037C  stfs f0, 0x37c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(892 as u32), tmp.u32 ) };
	// 82332EFC: 912B0378  stw r9, 0x378(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(888 as u32), ctx.r[9].u32 ) };
	// 82332F00: 48000014  b 0x82332f14
	pc = 0x82332F14; continue 'dispatch;
            }
            0x82332F04 => {
    //   block [0x82332F04..0x82332F10)
	// 82332F04: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82332F08: C0091FF8  lfs f0, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82332F0C: D00B037C  stfs f0, 0x37c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(892 as u32), tmp.u32 ) };
	pc = 0x82332F10; continue 'dispatch;
            }
            0x82332F10 => {
    //   block [0x82332F10..0x82332F14)
	// 82332F10: 914B0378  stw r10, 0x378(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(888 as u32), ctx.r[10].u32 ) };
	pc = 0x82332F14; continue 'dispatch;
            }
            0x82332F14 => {
    //   block [0x82332F14..0x82332F20)
	// 82332F14: D02B037C  stfs f1, 0x37c(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(892 as u32), tmp.u32 ) };
	// 82332F18: 386B00E0  addi r3, r11, 0xe0
	ctx.r[3].s64 = ctx.r[11].s64 + 224;
	// 82332F1C: 4BEEB4B4  b 0x8221e3d0
	sub_8221E3D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82332F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82332F28 size=584
    let mut pc: u32 = 0x82332F28;
    'dispatch: loop {
        match pc {
            0x82332F28 => {
    //   block [0x82332F28..0x82332F78)
	// 82332F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82332F2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82332F30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82332F34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82332F38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82332F3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82332F40: 3D608233  lis r11, -0x7dcd
	ctx.r[11].s64 = -2110586880;
	// 82332F44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82332F48: 396B2928  addi r11, r11, 0x2928
	ctx.r[11].s64 = ctx.r[11].s64 + 10536;
	// 82332F4C: 815F03E0  lwz r10, 0x3e0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(992 as u32) ) } as u64;
	// 82332F50: 813F03E8  lwz r9, 0x3e8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82332F54: 917F03F8  stw r11, 0x3f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[11].u32 ) };
	// 82332F58: A16A0008  lhz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82332F5C: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82332F60: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82332F64: 556B303E  rotlwi r11, r11, 6
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(6)) as u64;
	// 82332F68: 2B0B0100  cmplwi cr6, r11, 0x100
	ctx.cr[6].compare_u32(ctx.r[11].u32, 256 as u32, &mut ctx.xer);
	// 82332F6C: 4098000C  bge cr6, 0x82332f78
	if !ctx.cr[6].lt {
	pc = 0x82332F78; continue 'dispatch;
	}
	// 82332F70: 7C004A2C  dcbt 0, r9
	// 82332F74: 48000154  b 0x823330c8
	pc = 0x823330C8; continue 'dispatch;
            }
            0x82332F78 => {
    //   block [0x82332F78..0x82332F88)
	// 82332F78: 3D400004  lis r10, 4
	ctx.r[10].s64 = 262144;
	// 82332F7C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82332F80: 41980008  blt cr6, 0x82332f88
	if ctx.cr[6].lt {
	pc = 0x82332F88; continue 'dispatch;
	}
	// 82332F84: 3D600004  lis r11, 4
	ctx.r[11].s64 = 262144;
	pc = 0x82332F88; continue 'dispatch;
            }
            0x82332F88 => {
    //   block [0x82332F88..0x82332FAC)
	// 82332F88: 3949007F  addi r10, r9, 0x7f
	ctx.r[10].s64 = ctx.r[9].s64 + 127;
	// 82332F8C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82332F90: 55480030  rlwinm r8, r10, 0, 0, 0x18
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82332F94: 556B0030  rlwinm r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82332F98: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82332F9C: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82332FA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82332FA4: 419A0008  beq cr6, 0x82332fac
	if ctx.cr[6].eq {
	pc = 0x82332FAC; continue 'dispatch;
	}
	// 82332FA8: 7C004A2C  dcbt 0, r9
	pc = 0x82332FAC; continue 'dispatch;
            }
            0x82332FAC => {
    //   block [0x82332FAC..0x82332FB8)
	// 82332FAC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82332FB0: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 82332FB4: 41980080  blt cr6, 0x82333034
	if ctx.cr[6].lt {
	pc = 0x82333034; continue 'dispatch;
	}
	pc = 0x82332FB8; continue 'dispatch;
            }
            0x82332FB8 => {
    //   block [0x82332FB8..0x82333034)
	// 82332FB8: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 82332FBC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332FC0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82332FC4: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 82332FC8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332FCC: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 82332FD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82332FD4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332FD8: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 82332FDC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82332FE0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332FE4: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 82332FE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82332FEC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332FF0: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 82332FF4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82332FF8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82332FFC: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 82333000: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82333004: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333008: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 8233300C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82333010: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333014: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333018: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 8233301C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82333020: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 82333024: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 82333028: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8233302C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82333030: 4098FF88  bge cr6, 0x82332fb8
	if !ctx.cr[6].lt {
	pc = 0x82332FB8; continue 'dispatch;
	}
	pc = 0x82333034; continue 'dispatch;
            }
            0x82333034 => {
    //   block [0x82333034..0x82333078)
	// 82333034: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 82333038: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8233303C: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 82333040: 41990088  bgt cr6, 0x823330c8
	if ctx.cr[6].gt {
	pc = 0x823330C8; continue 'dispatch;
	}
	// 82333044: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 82333048: 398C305C  addi r12, r12, 0x305c
	ctx.r[12].s64 = ctx.r[12].s64 + 12380;
	// 8233304C: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82333050: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82333054: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82333058: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x823330C0; continue 'dispatch;
		},
		1 => {
	pc = 0x823330B4; continue 'dispatch;
		},
		2 => {
	pc = 0x823330A8; continue 'dispatch;
		},
		3 => {
	pc = 0x8233309C; continue 'dispatch;
		},
		4 => {
	pc = 0x82333090; continue 'dispatch;
		},
		5 => {
	pc = 0x82333084; continue 'dispatch;
		},
		6 => {
	pc = 0x82333078; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8233305C: 823330C0  lwz r17, 0x30c0(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(12480 as u32) ) } as u64;
	// 82333060: 823330B4  lwz r17, 0x30b4(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(12468 as u32) ) } as u64;
	// 82333064: 823330A8  lwz r17, 0x30a8(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(12456 as u32) ) } as u64;
	// 82333068: 8233309C  lwz r17, 0x309c(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(12444 as u32) ) } as u64;
	// 8233306C: 82333090  lwz r17, 0x3090(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(12432 as u32) ) } as u64;
	// 82333070: 82333084  lwz r17, 0x3084(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(12420 as u32) ) } as u64;
	// 82333074: 82333078  lwz r17, 0x3078(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(12408 as u32) ) } as u64;
            }
            0x82333078 => {
    //   block [0x82333078..0x82333084)
	// 82333078: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 8233307C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333080: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82333084; continue 'dispatch;
            }
            0x82333084 => {
    //   block [0x82333084..0x82333090)
	// 82333084: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 82333088: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8233308C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82333090; continue 'dispatch;
            }
            0x82333090 => {
    //   block [0x82333090..0x8233309C)
	// 82333090: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 82333094: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333098: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8233309C; continue 'dispatch;
            }
            0x8233309C => {
    //   block [0x8233309C..0x823330A8)
	// 8233309C: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 823330A0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823330A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823330A8; continue 'dispatch;
            }
            0x823330A8 => {
    //   block [0x823330A8..0x823330B4)
	// 823330A8: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 823330AC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823330B0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823330B4; continue 'dispatch;
            }
            0x823330B4 => {
    //   block [0x823330B4..0x823330C0)
	// 823330B4: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 823330B8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823330BC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823330C0; continue 'dispatch;
            }
            0x823330C0 => {
    //   block [0x823330C0..0x823330C8)
	// 823330C0: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 823330C4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	pc = 0x823330C8; continue 'dispatch;
            }
            0x823330C8 => {
    //   block [0x823330C8..0x82333110)
	// 823330C8: 817F03E8  lwz r11, 0x3e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) } as u64;
	// 823330CC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823330D0: 55453032  slwi r5, r10, 6
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823330D4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823330D8: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823330DC: 48201A75  bl 0x82534b50
	ctx.lr = 0x823330E0;
	sub_82534B50(ctx, base);
	// 823330E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823330E4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823330E8: D01F03B8  stfs f0, 0x3b8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(952 as u32), tmp.u32 ) };
	// 823330EC: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 823330F0: 817F0374  lwz r11, 0x374(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 823330F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823330F8: 419A0028  beq cr6, 0x82333120
	if ctx.cr[6].eq {
	pc = 0x82333120; continue 'dispatch;
	}
	// 823330FC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82333100: 41980010  blt cr6, 0x82333110
	if ctx.cr[6].lt {
	pc = 0x82333110; continue 'dispatch;
	}
	// 82333104: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82333108: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8233310C: 41980018  blt cr6, 0x82333124
	if ctx.cr[6].lt {
	pc = 0x82333124; continue 'dispatch;
	}
	pc = 0x82333110; continue 'dispatch;
            }
            0x82333110 => {
    //   block [0x82333110..0x82333120)
	// 82333110: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82333114: D01F037C  stfs f0, 0x37c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	// 82333118: 917F0378  stw r11, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[11].u32 ) };
	// 8233311C: 4800000C  b 0x82333128
	pc = 0x82333128; continue 'dispatch;
            }
            0x82333120 => {
    //   block [0x82333120..0x82333124)
	// 82333120: D01F037C  stfs f0, 0x37c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	pc = 0x82333124; continue 'dispatch;
            }
            0x82333124 => {
    //   block [0x82333124..0x82333128)
	// 82333124: 93DF0378  stw r30, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[30].u32 ) };
	pc = 0x82333128; continue 'dispatch;
            }
            0x82333128 => {
    //   block [0x82333128..0x8233313C)
	// 82333128: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 8233312C: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 82333130: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82333134: 40980008  bge cr6, 0x8233313c
	if !ctx.cr[6].lt {
	pc = 0x8233313C; continue 'dispatch;
	}
	// 82333138: 815F0378  lwz r10, 0x378(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(888 as u32) ) } as u64;
	pc = 0x8233313C; continue 'dispatch;
            }
            0x8233313C => {
    //   block [0x8233313C..0x82333170)
	// 8233313C: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82333140: 817F0374  lwz r11, 0x374(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 82333144: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82333148: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8233314C: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82333150: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82333154: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82333158: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8233315C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82333160: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82333164: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82333168: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233316C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82333170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82333170 size=268
    let mut pc: u32 = 0x82333170;
    'dispatch: loop {
        match pc {
            0x82333170 => {
    //   block [0x82333170..0x823331C8)
	// 82333170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82333174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82333178: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233317C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82333180: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82333184: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82333188: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 8233318C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82333190: 396B49C8  addi r11, r11, 0x49c8
	ctx.r[11].s64 = ctx.r[11].s64 + 18888;
	// 82333194: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 82333198: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8233319C: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 823331A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823331A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823331A8: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 823331AC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823331B0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823331B4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823331B8: EC210028  fsubs f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 823331BC: 409A000C  bne cr6, 0x823331c8
	if !ctx.cr[6].eq {
	pc = 0x823331C8; continue 'dispatch;
	}
	// 823331C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823331C4: 4800002C  b 0x823331f0
	pc = 0x823331F0; continue 'dispatch;
            }
            0x823331C8 => {
    //   block [0x823331C8..0x823331E0)
	// 823331C8: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823331CC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823331D0: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823331D4: 419A000C  beq cr6, 0x823331e0
	if ctx.cr[6].eq {
	pc = 0x823331E0; continue 'dispatch;
	}
	// 823331D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823331DC: 48000014  b 0x823331f0
	pc = 0x823331F0; continue 'dispatch;
            }
            0x823331E0 => {
    //   block [0x823331E0..0x823331F0)
	// 823331E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823331E4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823331E8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823331EC: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x823331F0; continue 'dispatch;
            }
            0x823331F0 => {
    //   block [0x823331F0..0x82333204)
	// 823331F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823331F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823331F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823331FC: 419A0008  beq cr6, 0x82333204
	if ctx.cr[6].eq {
	pc = 0x82333204; continue 'dispatch;
	}
	// 82333200: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82333204; continue 'dispatch;
            }
            0x82333204 => {
    //   block [0x82333204..0x82333238)
	// 82333204: 814703E0  lwz r10, 0x3e0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(992 as u32) ) } as u64;
	// 82333208: A10A0008  lhz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233320C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82333210: 419A0058  beq cr6, 0x82333268
	if ctx.cr[6].eq {
	pc = 0x82333268; continue 'dispatch;
	}
	// 82333214: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 82333218: 7D2849D6  mullw r9, r8, r9
	ctx.r[9].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8233321C: 7D4A41D6  mullw r10, r10, r8
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82333220: 55293032  slwi r9, r9, 6
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82333224: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82333228: 3BE70080  addi r31, r7, 0x80
	ctx.r[31].s64 = ctx.r[7].s64 + 128;
	// 8233322C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82333230: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82333234: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x82333238; continue 'dispatch;
            }
            0x82333238 => {
    //   block [0x82333238..0x82333268)
	// 82333238: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 8233323C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82333240: 480350B9  bl 0x823682f8
	ctx.lr = 0x82333244;
	sub_823682F8(ctx, base);
	// 82333244: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82333248: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233324C: 48034AE5  bl 0x82367d30
	ctx.lr = 0x82333250;
	sub_82367D30(ctx, base);
	// 82333250: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82333254: 38E70040  addi r7, r7, 0x40
	ctx.r[7].s64 = ctx.r[7].s64 + 64;
	// 82333258: 38C60040  addi r6, r6, 0x40
	ctx.r[6].s64 = ctx.r[6].s64 + 64;
	// 8233325C: 38630040  addi r3, r3, 0x40
	ctx.r[3].s64 = ctx.r[3].s64 + 64;
	// 82333260: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82333264: 409AFFD4  bne cr6, 0x82333238
	if !ctx.cr[6].eq {
	pc = 0x82333238; continue 'dispatch;
	}
	pc = 0x82333268; continue 'dispatch;
            }
            0x82333268 => {
    //   block [0x82333268..0x8233327C)
	// 82333268: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233326C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82333270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82333274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82333278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82333280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82333280 size=1024
    let mut pc: u32 = 0x82333280;
    'dispatch: loop {
        match pc {
            0x82333280 => {
    //   block [0x82333280..0x823332D0)
	// 82333280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82333284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82333288: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233328C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82333290: 814B00C0  lwz r10, 0xc0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 82333294: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 82333298: 409A00EC  bne cr6, 0x82333384
	if !ctx.cr[6].eq {
	pc = 0x82333384; continue 'dispatch;
	}
	// 8233329C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823332A0: C00B00C4  lfs f0, 0xc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823332A4: 812B03CC  lwz r9, 0x3cc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(972 as u32) ) } as u64;
	// 823332A8: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 823332AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823332B0: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823332B4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823332B8: 419A003C  beq cr6, 0x823332f4
	if ctx.cr[6].eq {
	pc = 0x823332F4; continue 'dispatch;
	}
	// 823332BC: 2B0A0028  cmplwi cr6, r10, 0x28
	ctx.cr[6].compare_u32(ctx.r[10].u32, 40 as u32, &mut ctx.xer);
	// 823332C0: 40980010  bge cr6, 0x823332d0
	if !ctx.cr[6].lt {
	pc = 0x823332D0; continue 'dispatch;
	}
	// 823332C4: 2B0A001E  cmplwi cr6, r10, 0x1e
	ctx.cr[6].compare_u32(ctx.r[10].u32, 30 as u32, &mut ctx.xer);
	// 823332C8: 409A0014  bne cr6, 0x823332dc
	if !ctx.cr[6].eq {
	pc = 0x823332DC; continue 'dispatch;
	}
	// 823332CC: 2B0A0028  cmplwi cr6, r10, 0x28
	ctx.cr[6].compare_u32(ctx.r[10].u32, 40 as u32, &mut ctx.xer);
	pc = 0x823332D0; continue 'dispatch;
            }
            0x823332D0 => {
    //   block [0x823332D0..0x823332DC)
	// 823332D0: 409903A0  ble cr6, 0x82333670
	if !ctx.cr[6].gt {
	pc = 0x82333670; continue 'dispatch;
	}
	// 823332D4: 2B0A0032  cmplwi cr6, r10, 0x32
	ctx.cr[6].compare_u32(ctx.r[10].u32, 50 as u32, &mut ctx.xer);
	// 823332D8: 419A0398  beq cr6, 0x82333670
	if ctx.cr[6].eq {
	pc = 0x82333670; continue 'dispatch;
	}
	pc = 0x823332DC; continue 'dispatch;
            }
            0x823332DC => {
    //   block [0x823332DC..0x823332F4)
	// 823332DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823332E0: 914B03CC  stw r10, 0x3cc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(972 as u32), ctx.r[10].u32 ) };
	// 823332E4: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 823332E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823332EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823332F0: 4E800020  blr
	return;
            }
            0x823332F4 => {
    //   block [0x823332F4..0x8233333C)
	// 823332F4: 2B0A0032  cmplwi cr6, r10, 0x32
	ctx.cr[6].compare_u32(ctx.r[10].u32, 50 as u32, &mut ctx.xer);
	// 823332F8: 409A0044  bne cr6, 0x8233333c
	if !ctx.cr[6].eq {
	pc = 0x8233333C; continue 'dispatch;
	}
	// 823332FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82333300: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82333304: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82333308: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 8233330C: 914B03CC  stw r10, 0x3cc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(972 as u32), ctx.r[10].u32 ) };
	// 82333310: C00B00B0  lfs f0, 0xb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333314: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82333318: C00B00B4  lfs f0, 0xb4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233331C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82333320: C00B00B8  lfs f0, 0xb8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333324: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82333328: 4802F359  bl 0x82362680
	ctx.lr = 0x8233332C;
	sub_82362680(ctx, base);
	// 8233332C: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82333330: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82333334: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82333338: 4E800020  blr
	return;
            }
            0x8233333C => {
    //   block [0x8233333C..0x82333384)
	// 8233333C: 2B0A001E  cmplwi cr6, r10, 0x1e
	ctx.cr[6].compare_u32(ctx.r[10].u32, 30 as u32, &mut ctx.xer);
	// 82333340: 409A0330  bne cr6, 0x82333670
	if !ctx.cr[6].eq {
	pc = 0x82333670; continue 'dispatch;
	}
	// 82333344: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82333348: 38A10140  addi r5, r1, 0x140
	ctx.r[5].s64 = ctx.r[1].s64 + 320;
	// 8233334C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82333350: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82333354: 914B03CC  stw r10, 0x3cc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(972 as u32), ctx.r[10].u32 ) };
	// 82333358: C00B00B0  lfs f0, 0xb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233335C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82333360: C00B00B4  lfs f0, 0xb4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333364: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82333368: C00B00B8  lfs f0, 0xb8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233336C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82333370: 4802F311  bl 0x82362680
	ctx.lr = 0x82333374;
	sub_82362680(ctx, base);
	// 82333374: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82333378: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233337C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82333380: 4E800020  blr
	return;
            }
            0x82333384 => {
    //   block [0x82333384..0x823333C0)
	// 82333384: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 82333388: 409A00EC  bne cr6, 0x82333474
	if !ctx.cr[6].eq {
	pc = 0x82333474; continue 'dispatch;
	}
	// 8233338C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82333390: C00B00C4  lfs f0, 0xc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333394: 812B03D0  lwz r9, 0x3d0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(976 as u32) ) } as u64;
	// 82333398: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8233339C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823333A0: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823333A4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823333A8: 419A003C  beq cr6, 0x823333e4
	if ctx.cr[6].eq {
	pc = 0x823333E4; continue 'dispatch;
	}
	// 823333AC: 2B0A0028  cmplwi cr6, r10, 0x28
	ctx.cr[6].compare_u32(ctx.r[10].u32, 40 as u32, &mut ctx.xer);
	// 823333B0: 40980010  bge cr6, 0x823333c0
	if !ctx.cr[6].lt {
	pc = 0x823333C0; continue 'dispatch;
	}
	// 823333B4: 2B0A001E  cmplwi cr6, r10, 0x1e
	ctx.cr[6].compare_u32(ctx.r[10].u32, 30 as u32, &mut ctx.xer);
	// 823333B8: 409A0014  bne cr6, 0x823333cc
	if !ctx.cr[6].eq {
	pc = 0x823333CC; continue 'dispatch;
	}
	// 823333BC: 2B0A0028  cmplwi cr6, r10, 0x28
	ctx.cr[6].compare_u32(ctx.r[10].u32, 40 as u32, &mut ctx.xer);
	pc = 0x823333C0; continue 'dispatch;
            }
            0x823333C0 => {
    //   block [0x823333C0..0x823333CC)
	// 823333C0: 409902B0  ble cr6, 0x82333670
	if !ctx.cr[6].gt {
	pc = 0x82333670; continue 'dispatch;
	}
	// 823333C4: 2B0A0032  cmplwi cr6, r10, 0x32
	ctx.cr[6].compare_u32(ctx.r[10].u32, 50 as u32, &mut ctx.xer);
	// 823333C8: 419A02A8  beq cr6, 0x82333670
	if ctx.cr[6].eq {
	pc = 0x82333670; continue 'dispatch;
	}
	pc = 0x823333CC; continue 'dispatch;
            }
            0x823333CC => {
    //   block [0x823333CC..0x823333E4)
	// 823333CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823333D0: 914B03D0  stw r10, 0x3d0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(976 as u32), ctx.r[10].u32 ) };
	// 823333D4: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 823333D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823333DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823333E0: 4E800020  blr
	return;
            }
            0x823333E4 => {
    //   block [0x823333E4..0x8233342C)
	// 823333E4: 2B0A001E  cmplwi cr6, r10, 0x1e
	ctx.cr[6].compare_u32(ctx.r[10].u32, 30 as u32, &mut ctx.xer);
	// 823333E8: 409A0044  bne cr6, 0x8233342c
	if !ctx.cr[6].eq {
	pc = 0x8233342C; continue 'dispatch;
	}
	// 823333EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823333F0: 38A100E0  addi r5, r1, 0xe0
	ctx.r[5].s64 = ctx.r[1].s64 + 224;
	// 823333F4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 823333F8: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 823333FC: 914B03D0  stw r10, 0x3d0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(976 as u32), ctx.r[10].u32 ) };
	// 82333400: C00B00B0  lfs f0, 0xb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333404: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82333408: C00B00B4  lfs f0, 0xb4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233340C: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82333410: C00B00B8  lfs f0, 0xb8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333414: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82333418: 4802F269  bl 0x82362680
	ctx.lr = 0x8233341C;
	sub_82362680(ctx, base);
	// 8233341C: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82333420: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82333424: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82333428: 4E800020  blr
	return;
            }
            0x8233342C => {
    //   block [0x8233342C..0x82333474)
	// 8233342C: 2B0A0032  cmplwi cr6, r10, 0x32
	ctx.cr[6].compare_u32(ctx.r[10].u32, 50 as u32, &mut ctx.xer);
	// 82333430: 409A0240  bne cr6, 0x82333670
	if !ctx.cr[6].eq {
	pc = 0x82333670; continue 'dispatch;
	}
	// 82333434: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82333438: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8233343C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82333440: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82333444: 914B03D0  stw r10, 0x3d0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(976 as u32), ctx.r[10].u32 ) };
	// 82333448: C00B00B0  lfs f0, 0xb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233344C: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82333450: C00B00B4  lfs f0, 0xb4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333454: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82333458: C00B00B8  lfs f0, 0xb8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233345C: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82333460: 4802F221  bl 0x82362680
	ctx.lr = 0x82333464;
	sub_82362680(ctx, base);
	// 82333464: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82333468: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233346C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82333470: 4E800020  blr
	return;
            }
            0x82333474 => {
    //   block [0x82333474..0x823334AC)
	// 82333474: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82333478: 409A0118  bne cr6, 0x82333590
	if !ctx.cr[6].eq {
	pc = 0x82333590; continue 'dispatch;
	}
	// 8233347C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82333480: C00B00C4  lfs f0, 0xc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333484: 812B03C4  lwz r9, 0x3c4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(964 as u32) ) } as u64;
	// 82333488: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8233348C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82333490: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82333494: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82333498: 419A0048  beq cr6, 0x823334e0
	if ctx.cr[6].eq {
	pc = 0x823334E0; continue 'dispatch;
	}
	// 8233349C: 2B0A0028  cmplwi cr6, r10, 0x28
	ctx.cr[6].compare_u32(ctx.r[10].u32, 40 as u32, &mut ctx.xer);
	// 823334A0: 4098000C  bge cr6, 0x823334ac
	if !ctx.cr[6].lt {
	pc = 0x823334AC; continue 'dispatch;
	}
	// 823334A4: 2B0A003C  cmplwi cr6, r10, 0x3c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 60 as u32, &mut ctx.xer);
	// 823334A8: 409A0020  bne cr6, 0x823334c8
	if !ctx.cr[6].eq {
	pc = 0x823334C8; continue 'dispatch;
	}
	pc = 0x823334AC; continue 'dispatch;
            }
            0x823334AC => {
    //   block [0x823334AC..0x823334C0)
	// 823334AC: 392AFFAF  addi r9, r10, -0x51
	ctx.r[9].s64 = ctx.r[10].s64 + -81;
	// 823334B0: 2B09003A  cmplwi cr6, r9, 0x3a
	ctx.cr[6].compare_u32(ctx.r[9].u32, 58 as u32, &mut ctx.xer);
	// 823334B4: 4199000C  bgt cr6, 0x823334c0
	if ctx.cr[6].gt {
	pc = 0x823334C0; continue 'dispatch;
	}
	// 823334B8: 2B0A0078  cmplwi cr6, r10, 0x78
	ctx.cr[6].compare_u32(ctx.r[10].u32, 120 as u32, &mut ctx.xer);
	// 823334BC: 409A000C  bne cr6, 0x823334c8
	if !ctx.cr[6].eq {
	pc = 0x823334C8; continue 'dispatch;
	}
	pc = 0x823334C0; continue 'dispatch;
            }
            0x823334C0 => {
    //   block [0x823334C0..0x823334C8)
	// 823334C0: 2B0A00A0  cmplwi cr6, r10, 0xa0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 160 as u32, &mut ctx.xer);
	// 823334C4: 409901AC  ble cr6, 0x82333670
	if !ctx.cr[6].gt {
	pc = 0x82333670; continue 'dispatch;
	}
	pc = 0x823334C8; continue 'dispatch;
            }
            0x823334C8 => {
    //   block [0x823334C8..0x823334E0)
	// 823334C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823334CC: 914B03C4  stw r10, 0x3c4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(964 as u32), ctx.r[10].u32 ) };
	// 823334D0: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 823334D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823334D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823334DC: 4E800020  blr
	return;
            }
            0x823334E0 => {
    //   block [0x823334E0..0x82333528)
	// 823334E0: 2B0A003C  cmplwi cr6, r10, 0x3c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 60 as u32, &mut ctx.xer);
	// 823334E4: 409A0044  bne cr6, 0x82333528
	if !ctx.cr[6].eq {
	pc = 0x82333528; continue 'dispatch;
	}
	// 823334E8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823334EC: 38A10120  addi r5, r1, 0x120
	ctx.r[5].s64 = ctx.r[1].s64 + 288;
	// 823334F0: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 823334F4: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 823334F8: 914B03C8  stw r10, 0x3c8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(968 as u32), ctx.r[10].u32 ) };
	// 823334FC: C00B00B0  lfs f0, 0xb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333500: D00100D0  stfs f0, 0xd0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82333504: C00B00B4  lfs f0, 0xb4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333508: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8233350C: C00B00B8  lfs f0, 0xb8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333510: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82333514: 4802F16D  bl 0x82362680
	ctx.lr = 0x82333518;
	sub_82362680(ctx, base);
	// 82333518: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 8233351C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82333520: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82333524: 4E800020  blr
	return;
            }
            0x82333528 => {
    //   block [0x82333528..0x8233355C)
	// 82333528: 2B0A0078  cmplwi cr6, r10, 0x78
	ctx.cr[6].compare_u32(ctx.r[10].u32, 120 as u32, &mut ctx.xer);
	// 8233352C: 409A0030  bne cr6, 0x8233355c
	if !ctx.cr[6].eq {
	pc = 0x8233355C; continue 'dispatch;
	}
	// 82333530: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82333534: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82333538: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 8233353C: 914B03C8  stw r10, 0x3c8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(968 as u32), ctx.r[10].u32 ) };
	// 82333540: C00B00B0  lfs f0, 0xb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333544: D00100F0  stfs f0, 0xf0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82333548: C00B00B4  lfs f0, 0xb4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233354C: D00100F4  stfs f0, 0xf4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82333550: C00B00B8  lfs f0, 0xb8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333554: D00100F8  stfs f0, 0xf8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82333558: 48000110  b 0x82333668
	pc = 0x82333668; continue 'dispatch;
            }
            0x8233355C => {
    //   block [0x8233355C..0x82333590)
	// 8233355C: 2B0A00A0  cmplwi cr6, r10, 0xa0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 160 as u32, &mut ctx.xer);
	// 82333560: 409A0110  bne cr6, 0x82333670
	if !ctx.cr[6].eq {
	pc = 0x82333670; continue 'dispatch;
	}
	// 82333564: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82333568: 38A10100  addi r5, r1, 0x100
	ctx.r[5].s64 = ctx.r[1].s64 + 256;
	// 8233356C: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 82333570: 914B03C8  stw r10, 0x3c8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(968 as u32), ctx.r[10].u32 ) };
	// 82333574: C00B00B0  lfs f0, 0xb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333578: D0010110  stfs f0, 0x110(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 8233357C: C00B00B4  lfs f0, 0xb4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333580: D0010114  stfs f0, 0x114(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82333584: C00B00B8  lfs f0, 0xb8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333588: D0010118  stfs f0, 0x118(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 8233358C: 480000DC  b 0x82333668
	pc = 0x82333668; continue 'dispatch;
            }
            0x82333590 => {
    //   block [0x82333590..0x823335CC)
	// 82333590: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 82333594: 409A00DC  bne cr6, 0x82333670
	if !ctx.cr[6].eq {
	pc = 0x82333670; continue 'dispatch;
	}
	// 82333598: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8233359C: C00B00C4  lfs f0, 0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823335A0: 812B03C8  lwz r9, 0x3c8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(968 as u32) ) } as u64;
	// 823335A4: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 823335A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823335AC: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823335B0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823335B4: 419A003C  beq cr6, 0x823335f0
	if ctx.cr[6].eq {
	pc = 0x823335F0; continue 'dispatch;
	}
	// 823335B8: 2B0A0028  cmplwi cr6, r10, 0x28
	ctx.cr[6].compare_u32(ctx.r[10].u32, 40 as u32, &mut ctx.xer);
	// 823335BC: 40980010  bge cr6, 0x823335cc
	if !ctx.cr[6].lt {
	pc = 0x823335CC; continue 'dispatch;
	}
	// 823335C0: 2B0A001E  cmplwi cr6, r10, 0x1e
	ctx.cr[6].compare_u32(ctx.r[10].u32, 30 as u32, &mut ctx.xer);
	// 823335C4: 409A0014  bne cr6, 0x823335d8
	if !ctx.cr[6].eq {
	pc = 0x823335D8; continue 'dispatch;
	}
	// 823335C8: 2B0A0028  cmplwi cr6, r10, 0x28
	ctx.cr[6].compare_u32(ctx.r[10].u32, 40 as u32, &mut ctx.xer);
	pc = 0x823335CC; continue 'dispatch;
            }
            0x823335CC => {
    //   block [0x823335CC..0x823335D8)
	// 823335CC: 409900A4  ble cr6, 0x82333670
	if !ctx.cr[6].gt {
	pc = 0x82333670; continue 'dispatch;
	}
	// 823335D0: 2B0A008C  cmplwi cr6, r10, 0x8c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 140 as u32, &mut ctx.xer);
	// 823335D4: 419A009C  beq cr6, 0x82333670
	if ctx.cr[6].eq {
	pc = 0x82333670; continue 'dispatch;
	}
	pc = 0x823335D8; continue 'dispatch;
            }
            0x823335D8 => {
    //   block [0x823335D8..0x823335F0)
	// 823335D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823335DC: 914B03C8  stw r10, 0x3c8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(968 as u32), ctx.r[10].u32 ) };
	// 823335E0: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 823335E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823335E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823335EC: 4E800020  blr
	return;
            }
            0x823335F0 => {
    //   block [0x823335F0..0x82333638)
	// 823335F0: 2B0A001E  cmplwi cr6, r10, 0x1e
	ctx.cr[6].compare_u32(ctx.r[10].u32, 30 as u32, &mut ctx.xer);
	// 823335F4: 409A0044  bne cr6, 0x82333638
	if !ctx.cr[6].eq {
	pc = 0x82333638; continue 'dispatch;
	}
	// 823335F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823335FC: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82333600: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 82333604: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82333608: 914B03C8  stw r10, 0x3c8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(968 as u32), ctx.r[10].u32 ) };
	// 8233360C: C00B00B0  lfs f0, 0xb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333610: D0010130  stfs f0, 0x130(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82333614: C00B00B4  lfs f0, 0xb4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333618: D0010134  stfs f0, 0x134(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 8233361C: C00B00B8  lfs f0, 0xb8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333620: D0010138  stfs f0, 0x138(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82333624: 4802F05D  bl 0x82362680
	ctx.lr = 0x82333628;
	sub_82362680(ctx, base);
	// 82333628: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 8233362C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82333630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82333634: 4E800020  blr
	return;
            }
            0x82333638 => {
    //   block [0x82333638..0x82333668)
	// 82333638: 2B0A008C  cmplwi cr6, r10, 0x8c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 140 as u32, &mut ctx.xer);
	// 8233363C: 409A0034  bne cr6, 0x82333670
	if !ctx.cr[6].eq {
	pc = 0x82333670; continue 'dispatch;
	}
	// 82333640: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82333644: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82333648: 38810150  addi r4, r1, 0x150
	ctx.r[4].s64 = ctx.r[1].s64 + 336;
	// 8233364C: 914B03C8  stw r10, 0x3c8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(968 as u32), ctx.r[10].u32 ) };
	// 82333650: C00B00B0  lfs f0, 0xb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333654: D0010150  stfs f0, 0x150(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 82333658: C00B00B4  lfs f0, 0xb4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233365C: D0010154  stfs f0, 0x154(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 82333660: C00B00B8  lfs f0, 0xb8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333664: D0010158  stfs f0, 0x158(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), tmp.u32 ) };
	pc = 0x82333668; continue 'dispatch;
            }
            0x82333668 => {
    //   block [0x82333668..0x82333670)
	// 82333668: 3860001A  li r3, 0x1a
	ctx.r[3].s64 = 26;
	// 8233366C: 4802F015  bl 0x82362680
	ctx.lr = 0x82333670;
	sub_82362680(ctx, base);
	pc = 0x82333670; continue 'dispatch;
            }
            0x82333670 => {
    //   block [0x82333670..0x82333680)
	// 82333670: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82333674: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82333678: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233367C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82333680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82333680 size=180
    let mut pc: u32 = 0x82333680;
    'dispatch: loop {
        match pc {
            0x82333680 => {
    //   block [0x82333680..0x823336B4)
	// 82333680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82333684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82333688: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233368C: 81630398  lwz r11, 0x398(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(920 as u32) ) } as u64;
	// 82333690: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82333694: 40980020  bge cr6, 0x823336b4
	if !ctx.cr[6].lt {
	pc = 0x823336B4; continue 'dispatch;
	}
	// 82333698: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233369C: 41980018  blt cr6, 0x823336b4
	if ctx.cr[6].lt {
	pc = 0x823336B4; continue 'dispatch;
	}
	// 823336A0: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 823336A4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823336A8: 394ABCF0  addi r10, r10, -0x4310
	ctx.r[10].s64 = ctx.r[10].s64 + -17168;
	// 823336AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823336B0: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	pc = 0x823336B4; continue 'dispatch;
            }
            0x823336B4 => {
    //   block [0x823336B4..0x823336E0)
	// 823336B4: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 823336B8: 396B49C8  addi r11, r11, 0x49c8
	ctx.r[11].s64 = ctx.r[11].s64 + 18888;
	// 823336BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823336C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823336C4: 419A002C  beq cr6, 0x823336f0
	if ctx.cr[6].eq {
	pc = 0x823336F0; continue 'dispatch;
	}
	// 823336C8: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823336CC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823336D0: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823336D4: 419A000C  beq cr6, 0x823336e0
	if ctx.cr[6].eq {
	pc = 0x823336E0; continue 'dispatch;
	}
	// 823336D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823336DC: 48000014  b 0x823336f0
	pc = 0x823336F0; continue 'dispatch;
            }
            0x823336E0 => {
    //   block [0x823336E0..0x823336F0)
	// 823336E0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823336E4: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 823336E8: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 823336EC: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	pc = 0x823336F0; continue 'dispatch;
            }
            0x823336F0 => {
    //   block [0x823336F0..0x82333718)
	// 823336F0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 823336F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823336F8: 419A0020  beq cr6, 0x82333718
	if ctx.cr[6].eq {
	pc = 0x82333718; continue 'dispatch;
	}
	// 823336FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82333700: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82333704: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82333708: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8233370C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82333710: 419A0008  beq cr6, 0x82333718
	if ctx.cr[6].eq {
	pc = 0x82333718; continue 'dispatch;
	}
	// 82333714: 4BDE9945  bl 0x8211d058
	ctx.lr = 0x82333718;
	sub_8211D058(ctx, base);
	pc = 0x82333718; continue 'dispatch;
            }
            0x82333718 => {
    //   block [0x82333718..0x82333734)
	// 82333718: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 8233371C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82333720: 916ABC4C  stw r11, -0x43b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17332 as u32), ctx.r[11].u32 ) };
	// 82333724: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82333728: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233372C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82333730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82333738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82333738 size=16
    let mut pc: u32 = 0x82333738;
    'dispatch: loop {
        match pc {
            0x82333738 => {
    //   block [0x82333738..0x82333748)
	// 82333738: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233373C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82333740: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82333744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82333748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82333748 size=16
    let mut pc: u32 = 0x82333748;
    'dispatch: loop {
        match pc {
            0x82333748 => {
    //   block [0x82333748..0x82333758)
	// 82333748: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233374C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82333750: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82333754: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82333758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82333758 size=16
    let mut pc: u32 = 0x82333758;
    'dispatch: loop {
        match pc {
            0x82333758 => {
    //   block [0x82333758..0x82333768)
	// 82333758: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233375C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82333760: 914B0140  stw r10, 0x140(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(320 as u32), ctx.r[10].u32 ) };
	// 82333764: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82333768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82333768 size=16
    let mut pc: u32 = 0x82333768;
    'dispatch: loop {
        match pc {
            0x82333768 => {
    //   block [0x82333768..0x82333778)
	// 82333768: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233376C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82333770: 914B0140  stw r10, 0x140(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(320 as u32), ctx.r[10].u32 ) };
	// 82333774: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82333778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82333778 size=852
    let mut pc: u32 = 0x82333778;
    'dispatch: loop {
        match pc {
            0x82333778 => {
    //   block [0x82333778..0x823337F0)
	// 82333778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233377C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82333780: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82333784: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82333788: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8233378C: 396BDD8C  addi r11, r11, -0x2274
	ctx.r[11].s64 = ctx.r[11].s64 + -8820;
	// 82333790: 38670080  addi r3, r7, 0x80
	ctx.r[3].s64 = ctx.r[7].s64 + 128;
	// 82333794: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82333798: 48001DB9  bl 0x82335550
	ctx.lr = 0x8233379C;
	sub_82335550(ctx, base);
	// 8233379C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823337A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823337A4: 396BDDAC  addi r11, r11, -0x2254
	ctx.r[11].s64 = ctx.r[11].s64 + -8788;
	// 823337A8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823337AC: 90870220  stw r4, 0x220(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(544 as u32), ctx.r[4].u32 ) };
	// 823337B0: 90A70224  stw r5, 0x224(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(548 as u32), ctx.r[5].u32 ) };
	// 823337B4: 81640058  lwz r11, 0x58(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) } as u64;
	// 823337B8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823337BC: 90E70084  stw r7, 0x84(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 823337C0: 91470088  stw r10, 0x88(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 823337C4: 91670228  stw r11, 0x228(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 823337C8: 89640004  lbz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 823337CC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 823337D0: 409A0020  bne cr6, 0x823337f0
	if !ctx.cr[6].eq {
	pc = 0x823337F0; continue 'dispatch;
	}
	// 823337D4: 81640050  lwz r11, 0x50(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) } as u64;
	// 823337D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823337DC: 9167008C  stw r11, 0x8c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 823337E0: 81640050  lwz r11, 0x50(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) } as u64;
	// 823337E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823337E8: 91670090  stw r11, 0x90(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 823337EC: 48000014  b 0x82333800
	pc = 0x82333800; continue 'dispatch;
            }
            0x823337F0 => {
    //   block [0x823337F0..0x82333800)
	// 823337F0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823337F4: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 823337F8: 9167008C  stw r11, 0x8c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 823337FC: 91470090  stw r10, 0x90(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	pc = 0x82333800; continue 'dispatch;
            }
            0x82333800 => {
    //   block [0x82333800..0x823339AC)
	// 82333800: 89640005  lbz r11, 5(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 82333804: 2B0B0021  cmplwi cr6, r11, 0x21
	ctx.cr[6].compare_u32(ctx.r[11].u32, 33 as u32, &mut ctx.xer);
	// 82333808: 409A01A4  bne cr6, 0x823339ac
	if !ctx.cr[6].eq {
	pc = 0x823339AC; continue 'dispatch;
	}
	// 8233380C: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333810: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82333814: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333818: D0070094  stfs f0, 0x94(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8233381C: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333820: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333824: D0070098  stfs f0, 0x98(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82333828: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 8233382C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333830: D007009C  stfs f0, 0x9c(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82333834: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333838: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233383C: D00700A0  stfs f0, 0xa0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82333840: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333844: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333848: D00700A4  stfs f0, 0xa4(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8233384C: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333850: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333854: D00700A8  stfs f0, 0xa8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82333858: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 8233385C: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333860: D00700AC  stfs f0, 0xac(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82333864: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333868: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233386C: D00700B0  stfs f0, 0xb0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82333870: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333874: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333878: D00700B4  stfs f0, 0xb4(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8233387C: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333880: C00B0024  lfs f0, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333884: D00700B8  stfs f0, 0xb8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82333888: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 8233388C: C00B0028  lfs f0, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333890: D00700BC  stfs f0, 0xbc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82333894: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333898: C00B002C  lfs f0, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233389C: D00700C0  stfs f0, 0xc0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 823338A0: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 823338A4: C00B0030  lfs f0, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823338A8: D00700C4  stfs f0, 0xc4(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 823338AC: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 823338B0: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823338B4: D00700C8  stfs f0, 0xc8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 823338B8: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 823338BC: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823338C0: D00700CC  stfs f0, 0xcc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 823338C4: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 823338C8: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823338CC: D00700D0  stfs f0, 0xd0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 823338D0: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 823338D4: C00B0040  lfs f0, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823338D8: D00700D4  stfs f0, 0xd4(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 823338DC: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 823338E0: C00B0044  lfs f0, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823338E4: D00700D8  stfs f0, 0xd8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 823338E8: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 823338EC: C00B0048  lfs f0, 0x48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823338F0: D00700DC  stfs f0, 0xdc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 823338F4: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 823338F8: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823338FC: D00700E0  stfs f0, 0xe0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82333900: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333904: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333908: D00700E4  stfs f0, 0xe4(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8233390C: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333910: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333914: D00700E8  stfs f0, 0xe8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82333918: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 8233391C: C00B0058  lfs f0, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333920: D00700EC  stfs f0, 0xec(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82333924: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333928: C00B005C  lfs f0, 0x5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233392C: D00700F0  stfs f0, 0xf0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82333930: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333934: C00B0060  lfs f0, 0x60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333938: D00700F4  stfs f0, 0xf4(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 8233393C: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333940: C00B0064  lfs f0, 0x64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333944: D00700F8  stfs f0, 0xf8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82333948: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 8233394C: C00B0068  lfs f0, 0x68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333950: D00700FC  stfs f0, 0xfc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82333954: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333958: C00B006C  lfs f0, 0x6c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233395C: D0070100  stfs f0, 0x100(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82333960: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333964: C00B0070  lfs f0, 0x70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333968: D0070104  stfs f0, 0x104(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 8233396C: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333970: C00B0074  lfs f0, 0x74(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333974: D0070108  stfs f0, 0x108(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82333978: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 8233397C: C00B0078  lfs f0, 0x78(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333980: D007010C  stfs f0, 0x10c(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82333984: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333988: C00B007C  lfs f0, 0x7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233398C: D0070110  stfs f0, 0x110(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82333990: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82333994: C00B0080  lfs f0, 0x80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333998: D0070114  stfs f0, 0x114(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 8233399C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823339A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823339A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823339A8: 4E800020  blr
	return;
            }
            0x823339AC => {
    //   block [0x823339AC..0x82333ACC)
	// 823339AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823339B0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823339B4: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 823339B8: C00B209C  lfs f0, 0x209c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823339BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823339C0: C12A22B4  lfs f9, 0x22b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8884 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823339C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823339C8: D12700B4  stfs f9, 0xb4(r7)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 823339CC: D0070094  stfs f0, 0x94(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 823339D0: C18B2068  lfs f12, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823339D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823339D8: C12A2934  lfs f9, 0x2934(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10548 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823339DC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823339E0: D1870098  stfs f12, 0x98(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 823339E4: D18700C0  stfs f12, 0xc0(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 823339E8: D12700C4  stfs f9, 0xc4(r7)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 823339EC: C16BBFFC  lfs f11, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823339F0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823339F4: C18A22B0  lfs f12, 0x22b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8880 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823339F8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823339FC: D18700C8  stfs f12, 0xc8(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82333A00: D167009C  stfs f11, 0x9c(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82333A04: D16700F4  stfs f11, 0xf4(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82333A08: C00BD564  lfs f0, -0x2a9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333A0C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82333A10: C18A22AC  lfs f12, 0x22ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8876 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82333A14: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82333A18: D18700D8  stfs f12, 0xd8(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82333A1C: D18700DC  stfs f12, 0xdc(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82333A20: D00700A0  stfs f0, 0xa0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82333A24: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82333A28: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82333A2C: D00700A4  stfs f0, 0xa4(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82333A30: 396BD6D0  addi r11, r11, -0x2930
	ctx.r[11].s64 = ctx.r[11].s64 + -10544;
	// 82333A34: D00700B8  stfs f0, 0xb8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82333A38: D00700BC  stfs f0, 0xbc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82333A3C: D00700CC  stfs f0, 0xcc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82333A40: D00700FC  stfs f0, 0xfc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82333A44: D1A700A8  stfs f13, 0xa8(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82333A48: C14BFB48  lfs f10, -0x4b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1208 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82333A4C: D14700AC  stfs f10, 0xac(r7)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82333A50: D14700D4  stfs f10, 0xd4(r7)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82333A54: C14A20B0  lfs f10, 0x20b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8368 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82333A58: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82333A5C: C10B0000  lfs f8, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82333A60: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82333A64: D1A700B0  stfs f13, 0xb0(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82333A68: D1A700D0  stfs f13, 0xd0(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82333A6C: D14700E0  stfs f10, 0xe0(r7)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82333A70: C18A207C  lfs f12, 0x207c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8316 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82333A74: D18700E8  stfs f12, 0xe8(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82333A78: C18BD4DC  lfs f12, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82333A7C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82333A80: D18700F0  stfs f12, 0xf0(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82333A84: D1A700E4  stfs f13, 0xe4(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82333A88: D10700EC  stfs f8, 0xec(r7)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82333A8C: D1A700F8  stfs f13, 0xf8(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82333A90: C00BD5B0  lfs f0, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333A94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82333A98: D0070108  stfs f0, 0x108(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82333A9C: D1270100  stfs f9, 0x100(r7)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82333AA0: D1470104  stfs f10, 0x104(r7)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82333AA4: D1A70110  stfs f13, 0x110(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82333AA8: C18B22A8  lfs f12, 0x22a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8872 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82333AAC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82333AB0: D187010C  stfs f12, 0x10c(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82333AB4: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333AB8: D0070114  stfs f0, 0x114(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82333ABC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82333AC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82333AC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82333AC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82333AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82333AD0 size=112
    let mut pc: u32 = 0x82333AD0;
    'dispatch: loop {
        match pc {
            0x82333AD0 => {
    //   block [0x82333AD0..0x82333B30)
	// 82333AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82333AD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82333AD8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82333ADC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82333AE0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82333AE4: 396BDD8C  addi r11, r11, -0x2274
	ctx.r[11].s64 = ctx.r[11].s64 + -8820;
	// 82333AE8: 38670080  addi r3, r7, 0x80
	ctx.r[3].s64 = ctx.r[7].s64 + 128;
	// 82333AEC: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82333AF0: 48001AB1  bl 0x823355a0
	ctx.lr = 0x82333AF4;
	sub_823355A0(ctx, base);
	// 82333AF4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82333AF8: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82333AFC: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 82333B00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82333B04: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82333B08: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82333B0C: 419A0024  beq cr6, 0x82333b30
	if ctx.cr[6].eq {
	pc = 0x82333B30; continue 'dispatch;
	}
	// 82333B10: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82333B14: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82333B18: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82333B1C: 409A0014  bne cr6, 0x82333b30
	if !ctx.cr[6].eq {
	pc = 0x82333B30; continue 'dispatch;
	}
	// 82333B20: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82333B24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82333B28: 99670019  stb r11, 0x19(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82333B2C: 99470025  stb r10, 0x25(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x82333B30; continue 'dispatch;
            }
            0x82333B30 => {
    //   block [0x82333B30..0x82333B40)
	// 82333B30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82333B34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82333B38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82333B3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82333B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82333B40 size=500
    let mut pc: u32 = 0x82333B40;
    'dispatch: loop {
        match pc {
            0x82333B40 => {
    //   block [0x82333B40..0x82333B80)
	// 82333B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82333B44: 48201579  bl 0x825350bc
	ctx.lr = 0x82333B48;
	sub_82535080(ctx, base);
	// 82333B48: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82333B4C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82333B50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82333B54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82333B58: 393D0120  addi r9, r29, 0x120
	ctx.r[9].s64 = ctx.r[29].s64 + 288;
	// 82333B5C: 3969007F  addi r11, r9, 0x7f
	ctx.r[11].s64 = ctx.r[9].s64 + 127;
	// 82333B60: 39490100  addi r10, r9, 0x100
	ctx.r[10].s64 = ctx.r[9].s64 + 256;
	// 82333B64: 55680030  rlwinm r8, r11, 0, 0, 0x18
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82333B68: 554B0030  rlwinm r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82333B6C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82333B70: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82333B74: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82333B78: 419A0008  beq cr6, 0x82333b80
	if ctx.cr[6].eq {
	pc = 0x82333B80; continue 'dispatch;
	}
	// 82333B7C: 7C004A2C  dcbt 0, r9
	pc = 0x82333B80; continue 'dispatch;
            }
            0x82333B80 => {
    //   block [0x82333B80..0x82333B8C)
	// 82333B80: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82333B84: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 82333B88: 41980080  blt cr6, 0x82333c08
	if ctx.cr[6].lt {
	pc = 0x82333C08; continue 'dispatch;
	}
	pc = 0x82333B8C; continue 'dispatch;
            }
            0x82333B8C => {
    //   block [0x82333B8C..0x82333C08)
	// 82333B8C: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 82333B90: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333B94: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82333B98: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 82333B9C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333BA0: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 82333BA4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82333BA8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333BAC: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 82333BB0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82333BB4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333BB8: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 82333BBC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82333BC0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333BC4: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 82333BC8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82333BCC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333BD0: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 82333BD4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82333BD8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333BDC: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 82333BE0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82333BE4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333BE8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82333BEC: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 82333BF0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82333BF4: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 82333BF8: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 82333BFC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82333C00: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82333C04: 4098FF88  bge cr6, 0x82333b8c
	if !ctx.cr[6].lt {
	pc = 0x82333B8C; continue 'dispatch;
	}
	pc = 0x82333C08; continue 'dispatch;
            }
            0x82333C08 => {
    //   block [0x82333C08..0x82333C4C)
	// 82333C08: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 82333C0C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82333C10: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 82333C14: 41990088  bgt cr6, 0x82333c9c
	if ctx.cr[6].gt {
	pc = 0x82333C9C; continue 'dispatch;
	}
	// 82333C18: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 82333C1C: 398C3C30  addi r12, r12, 0x3c30
	ctx.r[12].s64 = ctx.r[12].s64 + 15408;
	// 82333C20: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82333C24: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82333C28: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82333C2C: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x82333C94; continue 'dispatch;
		},
		1 => {
	pc = 0x82333C88; continue 'dispatch;
		},
		2 => {
	pc = 0x82333C7C; continue 'dispatch;
		},
		3 => {
	pc = 0x82333C70; continue 'dispatch;
		},
		4 => {
	pc = 0x82333C64; continue 'dispatch;
		},
		5 => {
	pc = 0x82333C58; continue 'dispatch;
		},
		6 => {
	pc = 0x82333C4C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82333C30: 82333C94  lwz r17, 0x3c94(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(15508 as u32) ) } as u64;
	// 82333C34: 82333C88  lwz r17, 0x3c88(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(15496 as u32) ) } as u64;
	// 82333C38: 82333C7C  lwz r17, 0x3c7c(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(15484 as u32) ) } as u64;
	// 82333C3C: 82333C70  lwz r17, 0x3c70(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(15472 as u32) ) } as u64;
	// 82333C40: 82333C64  lwz r17, 0x3c64(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(15460 as u32) ) } as u64;
	// 82333C44: 82333C58  lwz r17, 0x3c58(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(15448 as u32) ) } as u64;
	// 82333C48: 82333C4C  lwz r17, 0x3c4c(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(15436 as u32) ) } as u64;
            }
            0x82333C4C => {
    //   block [0x82333C4C..0x82333C58)
	// 82333C4C: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 82333C50: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333C54: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82333C58; continue 'dispatch;
            }
            0x82333C58 => {
    //   block [0x82333C58..0x82333C64)
	// 82333C58: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 82333C5C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333C60: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82333C64; continue 'dispatch;
            }
            0x82333C64 => {
    //   block [0x82333C64..0x82333C70)
	// 82333C64: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 82333C68: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333C6C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82333C70; continue 'dispatch;
            }
            0x82333C70 => {
    //   block [0x82333C70..0x82333C7C)
	// 82333C70: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 82333C74: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333C78: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82333C7C; continue 'dispatch;
            }
            0x82333C7C => {
    //   block [0x82333C7C..0x82333C88)
	// 82333C7C: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 82333C80: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333C84: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82333C88; continue 'dispatch;
            }
            0x82333C88 => {
    //   block [0x82333C88..0x82333C94)
	// 82333C88: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 82333C8C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82333C90: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82333C94; continue 'dispatch;
            }
            0x82333C94 => {
    //   block [0x82333C94..0x82333C9C)
	// 82333C94: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 82333C98: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	pc = 0x82333C9C; continue 'dispatch;
            }
            0x82333C9C => {
    //   block [0x82333C9C..0x82333CC0)
	// 82333C9C: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 82333CA0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82333CA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82333CA8: 4099007C  ble cr6, 0x82333d24
	if !ctx.cr[6].gt {
	pc = 0x82333D24; continue 'dispatch;
	}
	// 82333CAC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82333CB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82333CB4: 3BFD0138  addi r31, r29, 0x138
	ctx.r[31].s64 = ctx.r[29].s64 + 312;
	// 82333CB8: C3CABA38  lfs f30, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82333CBC: C3EB206C  lfs f31, 0x206c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8300 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82333CC0; continue 'dispatch;
            }
            0x82333CC0 => {
    //   block [0x82333CC0..0x82333D24)
	// 82333CC0: 481FF551  bl 0x82533210
	ctx.lr = 0x82333CC4;
	sub_82533210(ctx, base);
	// 82333CC4: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82333CC8: C1BD009C  lfs f13, 0x9c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82333CCC: C19D0098  lfs f12, 0x98(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(152 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82333CD0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82333CD4: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82333CD8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82333CDC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82333CE0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82333CE4: EC0DF03A  fmadds f0, f13, f0, f30
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64);
	// 82333CE8: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82333CEC: D01FFFFC  stfs f0, -4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82333CF0: 481FF521  bl 0x82533210
	ctx.lr = 0x82333CF4;
	sub_82533210(ctx, base);
	// 82333CF4: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82333CF8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82333CFC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82333D00: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82333D04: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82333D08: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82333D0C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82333D10: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82333D14: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 82333D18: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82333D1C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82333D20: 4198FFA0  blt cr6, 0x82333cc0
	if ctx.cr[6].lt {
	pc = 0x82333CC0; continue 'dispatch;
	}
	pc = 0x82333D24; continue 'dispatch;
            }
            0x82333D24 => {
    //   block [0x82333D24..0x82333D34)
	// 82333D24: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82333D28: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82333D2C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82333D30: 482013DC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82333D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82333D38 size=480
    let mut pc: u32 = 0x82333D38;
    'dispatch: loop {
        match pc {
            0x82333D38 => {
    //   block [0x82333D38..0x82333DC8)
	// 82333D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82333D3C: 4820136D  bl 0x825350a8
	ctx.lr = 0x82333D40;
	sub_82535080(ctx, base);
	// 82333D40: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82333D44: 48202285  bl 0x82535fc8
	ctx.lr = 0x82333D48;
	sub_82535FB0(ctx, base);
	// 82333D48: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82333D4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82333D50: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82333D54: 3B3E008C  addi r25, r30, 0x8c
	ctx.r[25].s64 = ctx.r[30].s64 + 140;
	// 82333D58: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 82333D5C: C34A1FF8  lfs f26, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82333D60: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82333D64: FF20D090  fmr f25, f26
	ctx.f[25].f64 = ctx.f[26].f64;
	// 82333D68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82333D6C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82333D70: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82333D74: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82333D78: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82333D7C: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82333D80: C00ABFFC  lfs f0, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333D84: EEA06824  fdivs f21, f0, f13
	ctx.f[21].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82333D88: 419A0180  beq cr6, 0x82333f08
	if ctx.cr[6].eq {
	pc = 0x82333F08; continue 'dispatch;
	}
	// 82333D8C: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 82333D90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82333D94: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 82333D98: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82333D9C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82333DA0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82333DA4: 3B6BDD78  addi r27, r11, -0x2288
	ctx.r[27].s64 = ctx.r[11].s64 + -8840;
	// 82333DA8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82333DAC: C2C7BA38  lfs f22, -0x45c8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82333DB0: C2E8206C  lfs f23, 0x206c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8300 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82333DB4: 3BFE0130  addi r31, r30, 0x130
	ctx.r[31].s64 = ctx.r[30].s64 + 304;
	// 82333DB8: C3092C0C  lfs f24, 0x2c0c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(11276 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82333DBC: 3F40830F  lis r26, -0x7cf1
	ctx.r[26].s64 = -2096168960;
	// 82333DC0: C36A2490  lfs f27, 0x2490(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9360 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82333DC4: 3B8BBFF0  addi r28, r11, -0x4010
	ctx.r[28].s64 = ctx.r[11].s64 + -16400;
	pc = 0x82333DC8; continue 'dispatch;
            }
            0x82333DC8 => {
    //   block [0x82333DC8..0x82333EC4)
	// 82333DC8: C01E0094  lfs f0, 0x94(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333DCC: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82333DD0: C3DF0000  lfs f30, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82333DD4: EFED06F2  fmuls f31, f13, f27
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 82333DD8: EFBE0032  fmuls f29, f30, f0
	ctx.f[29].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82333DDC: EC3DFEFA  fmadds f1, f29, f27, f31
	ctx.f[1].f64 = (((ctx.f[29].f64 * ctx.f[27].f64 + ctx.f[31].f64) as f32) as f64);
	// 82333DE0: 4BDE96E9  bl 0x8211d4c8
	ctx.lr = 0x82333DE4;
	sub_8211D4C8(ctx, base);
	// 82333DE4: C01E00A0  lfs f0, 0xa0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333DE8: EF810032  fmuls f28, f1, f0
	ctx.f[28].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82333DEC: EC3DFE3A  fmadds f1, f29, f24, f31
	ctx.f[1].f64 = (((ctx.f[29].f64 * ctx.f[24].f64 + ctx.f[31].f64) as f32) as f64);
	// 82333DF0: 4BDE96D9  bl 0x8211d4c8
	ctx.lr = 0x82333DF4;
	sub_8211D4C8(ctx, base);
	// 82333DF4: EFF906F2  fmuls f31, f25, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[25].f64 * ctx.f[27].f64) as f32) as f64);
	// 82333DF8: C01E00A4  lfs f0, 0xa4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333DFC: EFA10032  fmuls f29, f1, f0
	ctx.f[29].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82333E00: 3BBFFFF0  addi r29, r31, -0x10
	ctx.r[29].s64 = ctx.r[31].s64 + -16;
	// 82333E04: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82333E08: 4BE1F4B1  bl 0x821532b8
	ctx.lr = 0x82333E0C;
	sub_821532B8(ctx, base);
	// 82333E0C: FE800890  fmr f20, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[20].f64 = ctx.f[1].f64;
	// 82333E10: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82333E14: 4BDE96B5  bl 0x8211d4c8
	ctx.lr = 0x82333E18;
	sub_8211D4C8(ctx, base);
	// 82333E18: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82333E1C: D35FFFF4  stfs f26, -0xc(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 82333E20: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82333E24: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82333E28: EC14073A  fmadds f0, f20, f28, f0
	ctx.f[0].f64 = (((ctx.f[20].f64 * ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64);
	// 82333E2C: D01FFFF0  stfs f0, -0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82333E30: 4BE1F489  bl 0x821532b8
	ctx.lr = 0x82333E34;
	sub_821532B8(ctx, base);
	// 82333E34: FE800890  fmr f20, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[20].f64 = ctx.f[1].f64;
	// 82333E38: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82333E3C: 4BDE968D  bl 0x8211d4c8
	ctx.lr = 0x82333E40;
	sub_8211D4C8(ctx, base);
	// 82333E40: EC010732  fmuls f0, f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[28].f64) as f32) as f64);
	// 82333E44: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82333E48: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82333E4C: 616B85E0  ori r11, r11, 0x85e0
	ctx.r[11].u64 = ctx.r[11].u64 | 34272;
	// 82333E50: EC140778  fmsubs f0, f20, f29, f0
	ctx.f[0].f64 = (((ctx.f[20].f64 * ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 82333E54: D01FFFF8  stfs f0, -8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82333E58: 7C1C5C2E  lfsx f0, r28, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333E5C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82333E60: EC1E002A  fadds f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 82333E64: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82333E68: 616B85E0  ori r11, r11, 0x85e0
	ctx.r[11].u64 = ctx.r[11].u64 | 34272;
	// 82333E6C: 7C1C5C2E  lfsx f0, r28, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333E70: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82333E74: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82333E78: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82333E7C: 40980078  bge cr6, 0x82333ef4
	if !ctx.cr[6].lt {
	pc = 0x82333EF4; continue 'dispatch;
	}
	// 82333E80: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 82333E84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82333E88: 419A003C  beq cr6, 0x82333ec4
	if ctx.cr[6].eq {
	pc = 0x82333EC4; continue 'dispatch;
	}
	// 82333E8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82333E90: 809AFAC0  lwz r4, -0x540(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82333E94: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82333E98: 38A00300  li r5, 0x300
	ctx.r[5].s64 = 768;
	// 82333E9C: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 82333EA0: 480365F1  bl 0x8236a490
	ctx.lr = 0x82333EA4;
	sub_8236A490(ctx, base);
	// 82333EA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82333EA8: 419A001C  beq cr6, 0x82333ec4
	if ctx.cr[6].eq {
	pc = 0x82333EC4; continue 'dispatch;
	}
	// 82333EAC: 817E0228  lwz r11, 0x228(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(552 as u32) ) } as u64;
	// 82333EB0: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82333EB4: 815E0224  lwz r10, 0x224(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(548 as u32) ) } as u64;
	// 82333EB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82333EBC: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82333EC0: 48000059  bl 0x82333f18
	ctx.lr = 0x82333EC4;
	sub_82333F18(ctx, base);
	pc = 0x82333EC4; continue 'dispatch;
            }
            0x82333EC4 => {
    //   block [0x82333EC4..0x82333EF4)
	// 82333EC4: 481FF34D  bl 0x82533210
	ctx.lr = 0x82333EC8;
	sub_82533210(ctx, base);
	// 82333EC8: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 82333ECC: C1BE009C  lfs f13, 0x9c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82333ED0: C19E0098  lfs f12, 0x98(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82333ED4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82333ED8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82333EDC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82333EE0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82333EE4: EC0005F2  fmuls f0, f0, f23
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[23].f64) as f32) as f64);
	// 82333EE8: EC0DB03A  fmadds f0, f13, f0, f22
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[22].f64) as f32) as f64);
	// 82333EEC: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82333EF0: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x82333EF4; continue 'dispatch;
            }
            0x82333EF4 => {
    //   block [0x82333EF4..0x82333F08)
	// 82333EF4: 3B18FFFF  addi r24, r24, -1
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	// 82333EF8: EF39A82A  fadds f25, f25, f21
	ctx.f[25].f64 = ((ctx.f[25].f64 + ctx.f[21].f64) as f32) as f64;
	// 82333EFC: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82333F00: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82333F04: 409AFEC4  bne cr6, 0x82333dc8
	if !ctx.cr[6].eq {
	pc = 0x82333DC8; continue 'dispatch;
	}
	pc = 0x82333F08; continue 'dispatch;
            }
            0x82333F08 => {
    //   block [0x82333F08..0x82333F18)
	// 82333F08: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82333F0C: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82333F10: 48202105  bl 0x82536014
	ctx.lr = 0x82333F14;
	sub_82535FFC(ctx, base);
	// 82333F14: 482011E4  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82333F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82333F18 size=2340
    let mut pc: u32 = 0x82333F18;
    'dispatch: loop {
        match pc {
            0x82333F18 => {
    //   block [0x82333F18..0x8233402C)
	// 82333F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82333F1C: 4820117D  bl 0x82535098
	ctx.lr = 0x82333F20;
	sub_82535080(ctx, base);
	// 82333F20: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 82333F24: 482020BD  bl 0x82535fe0
	ctx.lr = 0x82333F28;
	sub_82535FB0(ctx, base);
	// 82333F28: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82333F2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82333F30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82333F34: 396BDDCC  addi r11, r11, -0x2234
	ctx.r[11].s64 = ctx.r[11].s64 + -8756;
	// 82333F38: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82333F3C: 3B9F0080  addi r28, r31, 0x80
	ctx.r[28].s64 = ctx.r[31].s64 + 128;
	// 82333F40: 387F0144  addi r3, r31, 0x144
	ctx.r[3].s64 = ctx.r[31].s64 + 324;
	// 82333F44: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82333F48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82333F4C: 935C0000  stw r26, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82333F50: 935C0004  stw r26, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82333F54: 935F00BC  stw r26, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[26].u32 ) };
	// 82333F58: B35F00C0  sth r26, 0xc0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[26].u16 ) };
	// 82333F5C: B35F00C2  sth r26, 0xc2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(194 as u32), ctx.r[26].u16 ) };
	// 82333F60: 90BF0118  stw r5, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[5].u32 ) };
	// 82333F64: 480015ED  bl 0x82335550
	ctx.lr = 0x82333F68;
	sub_82335550(ctx, base);
	// 82333F68: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82333F6C: 396BDDEC  addi r11, r11, -0x2214
	ctx.r[11].s64 = ctx.r[11].s64 + -8724;
	// 82333F70: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82333F74: 909F011C  stw r4, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[4].u32 ) };
	// 82333F78: 481FF299  bl 0x82533210
	ctx.lr = 0x82333F7C;
	sub_82533210(ctx, base);
	// 82333F7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82333F80: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82333F84: 3D4051EB  lis r10, 0x51eb
	ctx.r[10].s64 = 1374355456;
	// 82333F88: C01E0048  lfs f0, 0x48(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82333F8C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82333F90: 615D851F  ori r29, r10, 0x851f
	ctx.r[29].u64 = ctx.r[10].u64 | 34079;
	// 82333F94: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 82333F98: C3CB20B0  lfs f30, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82333F9C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82333FA0: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 82333FA4: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82333FA8: 38CBDD80  addi r6, r11, -0x2280
	ctx.r[6].s64 = ctx.r[11].s64 + -8832;
	// 82333FAC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82333FB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82333FB4: 386ADBE0  addi r3, r10, -0x2420
	ctx.r[3].s64 = ctx.r[10].s64 + -9248;
	// 82333FB8: 7D4BE896  mulhw r10, r11, r29
	ctx.r[10].s64 = ((ctx.r[11].s32 as i64 * ctx.r[29].s32 as i64) >> 32);
	// 82333FBC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82333FC0: 7D4A2E70  srawi r10, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 82333FC4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82333FC8: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82333FCC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82333FD0: 1D4A0064  mulli r10, r10, 0x64
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 100 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82333FD4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82333FD8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82333FDC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82333FE0: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82333FE4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82333FE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82333FEC: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82333FF0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82333FF4: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82333FF8: EC00FFBA  fmadds f0, f0, f30, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64);
	// 82333FFC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82334000: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82334004: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 82334008: 83010060  lwz r24, 0x60(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8233400C: 571B482C  slwi r27, r24, 9
	ctx.r[27].u32 = ctx.r[24].u32.wrapping_shl(9);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82334010: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82334014: 4BEC12D5  bl 0x821f52e8
	ctx.lr = 0x82334018;
	sub_821F52E8(ctx, base);
	// 82334018: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233401C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82334020: 409A000C  bne cr6, 0x8233402c
	if !ctx.cr[6].eq {
	pc = 0x8233402C; continue 'dispatch;
	}
	// 82334024: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82334028: 4800002C  b 0x82334054
	pc = 0x82334054; continue 'dispatch;
            }
            0x8233402C => {
    //   block [0x8233402C..0x82334044)
	// 8233402C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82334030: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82334034: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82334038: 419A000C  beq cr6, 0x82334044
	if ctx.cr[6].eq {
	pc = 0x82334044; continue 'dispatch;
	}
	// 8233403C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82334040: 48000014  b 0x82334054
	pc = 0x82334054; continue 'dispatch;
            }
            0x82334044 => {
    //   block [0x82334044..0x82334054)
	// 82334044: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82334048: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8233404C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82334050: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x82334054; continue 'dispatch;
            }
            0x82334054 => {
    //   block [0x82334054..0x82334078)
	// 82334054: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82334058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233405C: 419A07CC  beq cr6, 0x82334828
	if ctx.cr[6].eq {
	pc = 0x82334828; continue 'dispatch;
	}
	// 82334060: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82334064: 4BEF9385  bl 0x8222d3e8
	ctx.lr = 0x82334068;
	sub_8222D3E8(ctx, base);
	// 82334068: 2B1B0100  cmplwi cr6, r27, 0x100
	ctx.cr[6].compare_u32(ctx.r[27].u32, 256 as u32, &mut ctx.xer);
	// 8233406C: 4098000C  bge cr6, 0x82334078
	if !ctx.cr[6].lt {
	pc = 0x82334078; continue 'dispatch;
	}
	// 82334070: 7C001A2C  dcbt 0, r3
	// 82334074: 4800015C  b 0x823341d0
	pc = 0x823341D0; continue 'dispatch;
            }
            0x82334078 => {
    //   block [0x82334078..0x82334088)
	// 82334078: 3D600004  lis r11, 4
	ctx.r[11].s64 = 262144;
	// 8233407C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82334080: 41980008  blt cr6, 0x82334088
	if ctx.cr[6].lt {
	pc = 0x82334088; continue 'dispatch;
	}
	// 82334084: 3F600004  lis r27, 4
	ctx.r[27].s64 = 262144;
	pc = 0x82334088; continue 'dispatch;
            }
            0x82334088 => {
    //   block [0x82334088..0x823340AC)
	// 82334088: 3963007F  addi r11, r3, 0x7f
	ctx.r[11].s64 = ctx.r[3].s64 + 127;
	// 8233408C: 7D5B1A14  add r10, r27, r3
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[3].u64;
	// 82334090: 55690030  rlwinm r9, r11, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82334094: 554B0030  rlwinm r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82334098: 7F091840  cmplw cr6, r9, r3
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[3].u32, &mut ctx.xer);
	// 8233409C: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 823340A0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 823340A4: 419A0008  beq cr6, 0x823340ac
	if ctx.cr[6].eq {
	pc = 0x823340AC; continue 'dispatch;
	}
	// 823340A8: 7C001A2C  dcbt 0, r3
	pc = 0x823340AC; continue 'dispatch;
            }
            0x823340AC => {
    //   block [0x823340AC..0x823340B8)
	// 823340AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823340B0: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 823340B4: 41980084  blt cr6, 0x82334138
	if ctx.cr[6].lt {
	pc = 0x82334138; continue 'dispatch;
	}
	pc = 0x823340B8; continue 'dispatch;
            }
            0x823340B8 => {
    //   block [0x823340B8..0x82334138)
	// 823340B8: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 823340BC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823340C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823340C4: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 823340C8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823340CC: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 823340D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823340D4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823340D8: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 823340DC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823340E0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823340E4: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 823340E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823340EC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823340F0: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 823340F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823340F8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823340FC: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 82334100: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82334104: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82334108: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 8233410C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82334110: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82334114: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82334118: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 8233411C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82334120: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 82334124: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 82334128: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8233412C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82334130: 4098FF88  bge cr6, 0x823340b8
	if !ctx.cr[6].lt {
	pc = 0x823340B8; continue 'dispatch;
	}
	// 82334134: 83010060  lwz r24, 0x60(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	pc = 0x82334138; continue 'dispatch;
            }
            0x82334138 => {
    //   block [0x82334138..0x8233417C)
	// 82334138: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 8233413C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82334140: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 82334144: 4199008C  bgt cr6, 0x823341d0
	if ctx.cr[6].gt {
	pc = 0x823341D0; continue 'dispatch;
	}
	// 82334148: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 8233414C: 398C4160  addi r12, r12, 0x4160
	ctx.r[12].s64 = ctx.r[12].s64 + 16736;
	// 82334150: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82334154: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82334158: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8233415C: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x823341C4; continue 'dispatch;
		},
		1 => {
	pc = 0x823341B8; continue 'dispatch;
		},
		2 => {
	pc = 0x823341AC; continue 'dispatch;
		},
		3 => {
	pc = 0x823341A0; continue 'dispatch;
		},
		4 => {
	pc = 0x82334194; continue 'dispatch;
		},
		5 => {
	pc = 0x82334188; continue 'dispatch;
		},
		6 => {
	pc = 0x8233417C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82334160: 823341C4  lwz r17, 0x41c4(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(16836 as u32) ) } as u64;
	// 82334164: 823341B8  lwz r17, 0x41b8(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(16824 as u32) ) } as u64;
	// 82334168: 823341AC  lwz r17, 0x41ac(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(16812 as u32) ) } as u64;
	// 8233416C: 823341A0  lwz r17, 0x41a0(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(16800 as u32) ) } as u64;
	// 82334170: 82334194  lwz r17, 0x4194(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(16788 as u32) ) } as u64;
	// 82334174: 82334188  lwz r17, 0x4188(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(16776 as u32) ) } as u64;
	// 82334178: 8233417C  lwz r17, 0x417c(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(16764 as u32) ) } as u64;
            }
            0x8233417C => {
    //   block [0x8233417C..0x82334188)
	// 8233417C: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 82334180: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82334184: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82334188; continue 'dispatch;
            }
            0x82334188 => {
    //   block [0x82334188..0x82334194)
	// 82334188: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 8233418C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82334190: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82334194; continue 'dispatch;
            }
            0x82334194 => {
    //   block [0x82334194..0x823341A0)
	// 82334194: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 82334198: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8233419C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823341A0; continue 'dispatch;
            }
            0x823341A0 => {
    //   block [0x823341A0..0x823341AC)
	// 823341A0: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 823341A4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823341A8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823341AC; continue 'dispatch;
            }
            0x823341AC => {
    //   block [0x823341AC..0x823341B8)
	// 823341AC: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 823341B0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823341B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823341B8; continue 'dispatch;
            }
            0x823341B8 => {
    //   block [0x823341B8..0x823341C4)
	// 823341B8: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 823341BC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823341C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823341C4; continue 'dispatch;
            }
            0x823341C4 => {
    //   block [0x823341C4..0x823341D0)
	// 823341C4: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 823341C8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823341CC: 83010060  lwz r24, 0x60(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	pc = 0x823341D0; continue 'dispatch;
            }
            0x823341D0 => {
    //   block [0x823341D0..0x823347B0)
	// 823341D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823341D4: 4BEF9215  bl 0x8222d3e8
	ctx.lr = 0x823341D8;
	sub_8222D3E8(ctx, base);
	// 823341D8: 570B3830  slwi r11, r24, 7
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(7);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823341DC: 907F0114  stw r3, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[3].u32 ) };
	// 823341E0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823341E4: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 823341E8: 931F0110  stw r24, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[24].u32 ) };
	// 823341EC: D3E1007C  stfs f31, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 823341F0: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 823341F4: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 823341F8: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 823341FC: C3AA1FF8  lfs f29, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82334200: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82334204: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82334208: C01E0040  lfs f0, 0x40(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233420C: D01F013C  stfs f0, 0x13c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 82334210: C01E0028  lfs f0, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334214: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82334218: C01E002C  lfs f0, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233421C: D01F0124  stfs f0, 0x124(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82334220: C01E0078  lfs f0, 0x78(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334224: D01F0128  stfs f0, 0x128(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82334228: C01E0044  lfs f0, 0x44(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233422C: D01F012C  stfs f0, 0x12c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82334230: C01E0070  lfs f0, 0x70(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334234: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82334238: C38ABFFC  lfs f28, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8233423C: C01E0074  lfs f0, 0x74(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334240: D3A10070  stfs f29, 0x70(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82334244: D3A10074  stfs f29, 0x74(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82334248: D3A10078  stfs f29, 0x78(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8233424C: D3810080  stfs f28, 0x80(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82334250: D3A10084  stfs f29, 0x84(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82334254: D3A10088  stfs f29, 0x88(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82334258: D3A10090  stfs f29, 0x90(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8233425C: D3810094  stfs f28, 0x94(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82334260: D3A10098  stfs f29, 0x98(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82334264: D38100A0  stfs f28, 0xa0(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82334268: D38100A4  stfs f28, 0xa4(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8233426C: D3A100A8  stfs f29, 0xa8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82334270: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82334274: D38100B0  stfs f28, 0xb0(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82334278: D3A100B4  stfs f29, 0xb4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8233427C: D3A100B8  stfs f29, 0xb8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82334280: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82334284: D3E100C0  stfs f31, 0xc0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82334288: D3A100C4  stfs f29, 0xc4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8233428C: D3A100C8  stfs f29, 0xc8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82334290: D3E100CC  stfs f31, 0xcc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82334294: D38100D0  stfs f28, 0xd0(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82334298: D38100D4  stfs f28, 0xd4(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8233429C: D3A100D8  stfs f29, 0xd8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 823342A0: D3E100DC  stfs f31, 0xdc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 823342A4: D3E100E0  stfs f31, 0xe0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 823342A8: D38100E4  stfs f28, 0xe4(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 823342AC: D3A100E8  stfs f29, 0xe8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 823342B0: D3E100EC  stfs f31, 0xec(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 823342B4: D3A100F0  stfs f29, 0xf0(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 823342B8: D38100F4  stfs f28, 0xf4(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 823342BC: D3A100F8  stfs f29, 0xf8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 823342C0: D3E100FC  stfs f31, 0xfc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 823342C4: D3810100  stfs f28, 0x100(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 823342C8: D3810104  stfs f28, 0x104(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 823342CC: D3A10108  stfs f29, 0x108(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 823342D0: D3E1010C  stfs f31, 0x10c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 823342D4: D3A10110  stfs f29, 0x110(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 823342D8: D3E10114  stfs f31, 0x114(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 823342DC: D3A10118  stfs f29, 0x118(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 823342E0: D3E1011C  stfs f31, 0x11c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 823342E4: D3810120  stfs f28, 0x120(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 823342E8: D3E10124  stfs f31, 0x124(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 823342EC: D3A10128  stfs f29, 0x128(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 823342F0: D3E1012C  stfs f31, 0x12c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 823342F4: D3810130  stfs f28, 0x130(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 823342F8: D3810134  stfs f28, 0x134(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 823342FC: D3A10138  stfs f29, 0x138(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82334300: D3E1013C  stfs f31, 0x13c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 82334304: D3E10140  stfs f31, 0x140(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 82334308: D01F0134  stfs f0, 0x134(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 8233430C: D3810144  stfs f28, 0x144(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82334310: D3A10148  stfs f29, 0x148(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82334314: D3E1014C  stfs f31, 0x14c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82334318: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 8233431C: D3810150  stfs f28, 0x150(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 82334320: 3AE00020  li r23, 0x20
	ctx.r[23].s64 = 32;
	// 82334324: D3E10154  stfs f31, 0x154(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 82334328: D3A10158  stfs f29, 0x158(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 8233432C: D3E1015C  stfs f31, 0x15c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 82334330: D3E10160  stfs f31, 0x160(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 82334334: D3E10164  stfs f31, 0x164(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82334338: D3A10168  stfs f29, 0x168(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 8233433C: D3E1016C  stfs f31, 0x16c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 82334340: 419A0470  beq cr6, 0x823347b0
	if ctx.cr[6].eq {
	pc = 0x823347B0; continue 'dispatch;
	}
	// 82334344: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82334348: 3A800050  li r20, 0x50
	ctx.r[20].s64 = 80;
	// 8233434C: 3AA00080  li r21, 0x80
	ctx.r[21].s64 = 128;
	// 82334350: 3AC000B0  li r22, 0xb0
	ctx.r[22].s64 = 176;
	// 82334354: C34B2074  lfs f26, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82334358: 481FEEB9  bl 0x82533210
	ctx.lr = 0x8233435C;
	sub_82533210(ctx, base);
	// 8233435C: 7C6B1670  srawi r11, r3, 2
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[3].s32 >> 2) as i64;
	// 82334360: C37E001C  lfs f27, 0x1c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82334364: 577C3830  slwi r28, r27, 7
	ctx.r[28].u32 = ctx.r[27].u32.wrapping_shl(7);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82334368: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 8233436C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82334370: 7F2B1850  subf r25, r11, r3
	ctx.r[25].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82334374: 481FEE9D  bl 0x82533210
	ctx.lr = 0x82334378;
	sub_82533210(ctx, base);
	// 82334378: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8233437C: EC1B0732  fmuls f0, f27, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[28].f64) as f32) as f64);
	// 82334380: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82334384: 7D63E896  mulhw r11, r3, r29
	ctx.r[11].s64 = ((ctx.r[3].s32 as i64 * ctx.r[29].s32 as i64) >> 32);
	// 82334388: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 8233438C: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82334390: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82334394: 1D6B0064  mulli r11, r11, 0x64
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82334398: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 8233439C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823343A0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823343A4: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823343A8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823343AC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823343B0: EDAD06F2  fmuls f13, f13, f27
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 823343B4: EC0D07B8  fmsubs f0, f13, f30, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 823343B8: D0090040  stfs f0, 0x40(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 823343BC: 481FEE55  bl 0x82533210
	ctx.lr = 0x823343C0;
	sub_82533210(ctx, base);
	// 823343C0: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 823343C4: C01E0020  lfs f0, 0x20(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823343C8: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 823343CC: 7D63E896  mulhw r11, r3, r29
	ctx.r[11].s64 = ((ctx.r[3].s32 as i64 * ctx.r[29].s32 as i64) >> 32);
	// 823343D0: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 823343D4: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823343D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823343DC: 1D6B0064  mulli r11, r11, 0x64
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823343E0: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 823343E4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823343E8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 823343EC: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 823343F0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823343F4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823343F8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823343FC: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82334400: D0090044  stfs f0, 0x44(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82334404: 481FEE0D  bl 0x82533210
	ctx.lr = 0x82334408;
	sub_82533210(ctx, base);
	// 82334408: 7D63E896  mulhw r11, r3, r29
	ctx.r[11].s64 = ((ctx.r[3].s32 as i64 * ctx.r[29].s32 as i64) >> 32);
	// 8233440C: C01E0024  lfs f0, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334410: C1BE001C  lfs f13, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82334414: EDAD0732  fmuls f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 82334418: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 8233441C: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82334420: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82334424: 1D6B0064  mulli r11, r11, 0x64
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82334428: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 8233442C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82334430: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82334434: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82334438: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8233443C: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 82334440: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82334444: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82334448: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8233444C: EC006FB8  fmsubs f0, f0, f30, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 82334450: D00B0048  stfs f0, 0x48(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82334454: 481FEDBD  bl 0x82533210
	ctx.lr = 0x82334458;
	sub_82533210(ctx, base);
	// 82334458: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8233445C: C01E005C  lfs f0, 0x5c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334460: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82334464: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82334468: 7D63E896  mulhw r11, r3, r29
	ctx.r[11].s64 = ((ctx.r[3].s32 as i64 * ctx.r[29].s32 as i64) >> 32);
	// 8233446C: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 82334470: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82334474: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82334478: 1D6B0064  mulli r11, r11, 0x64
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8233447C: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82334480: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82334484: F9610198  std r11, 0x198(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), ctx.r[11].u64 ) };
	// 82334488: C9810198  lfd f12, 0x198(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(408 as u32) ) };
	// 8233448C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82334490: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82334494: EC0C07BA  fmadds f0, f12, f30, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 82334498: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 8233449C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823344A0: D0090008  stfs f0, 8(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823344A4: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 823344A8: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 823344AC: 934B0014  stw r26, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 823344B0: 481FED61  bl 0x82533210
	ctx.lr = 0x823344B4;
	sub_82533210(ctx, base);
	// 823344B4: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 823344B8: C01E0064  lfs f0, 0x64(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823344BC: C1BE0060  lfs f13, 0x60(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823344C0: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 823344C4: 7D63E896  mulhw r11, r3, r29
	ctx.r[11].s64 = ((ctx.r[3].s32 as i64 * ctx.r[29].s32 as i64) >> 32);
	// 823344C8: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 823344CC: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823344D0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823344D4: 1D6B0064  mulli r11, r11, 0x64
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823344D8: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 823344DC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823344E0: F9610170  std r11, 0x170(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[11].u64 ) };
	// 823344E4: C9810170  lfd f12, 0x170(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 823344E8: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 823344EC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 823344F0: EC0C07BA  fmadds f0, f12, f30, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 823344F4: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 823344F8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823344FC: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 82334500: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82334504: 481FED0D  bl 0x82533210
	ctx.lr = 0x82334508;
	sub_82533210(ctx, base);
	// 82334508: 7D63E896  mulhw r11, r3, r29
	ctx.r[11].s64 = ((ctx.r[3].s32 as i64 * ctx.r[29].s32 as i64) >> 32);
	// 8233450C: C01E0054  lfs f0, 0x54(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334510: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 82334514: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82334518: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8233451C: 1D6B0064  mulli r11, r11, 0x64
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82334520: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82334524: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82334528: F9610180  std r11, 0x180(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[11].u64 ) };
	// 8233452C: C9A10180  lfd f13, 0x180(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(384 as u32) ) };
	// 82334530: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82334534: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82334538: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8233453C: C1BE004C  lfs f13, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82334540: EC00FFBA  fmadds f0, f0, f30, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64);
	// 82334544: EF600372  fmuls f27, f0, f13
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82334548: 481FECC9  bl 0x82533210
	ctx.lr = 0x8233454C;
	sub_82533210(ctx, base);
	// 8233454C: 7D43E896  mulhw r10, r3, r29
	ctx.r[10].s64 = ((ctx.r[3].s32 as i64 * ctx.r[29].s32 as i64) >> 32);
	// 82334550: C01E0054  lfs f0, 0x54(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334554: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 82334558: C1BE0050  lfs f13, 0x50(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233455C: 7D4A2E70  srawi r10, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 82334560: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82334564: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82334568: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8233456C: 1D4A0064  mulli r10, r10, 0x64
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 100 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82334570: D36B0050  stfs f27, 0x50(r11)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82334574: D3AB0054  stfs f29, 0x54(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82334578: D3EB005C  stfs f31, 0x5c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8233457C: 7D4A1850  subf r10, r10, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[10].s64;
	// 82334580: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82334584: F9410190  std r10, 0x190(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[10].u64 ) };
	// 82334588: C9810190  lfd f12, 0x190(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) };
	// 8233458C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82334590: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82334594: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82334598: EC00FFBA  fmadds f0, f0, f30, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64);
	// 8233459C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823345A0: D00B0058  stfs f0, 0x58(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 823345A4: 481FEC6D  bl 0x82533210
	ctx.lr = 0x823345A8;
	sub_82533210(ctx, base);
	// 823345A8: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 823345AC: C01E0080  lfs f0, 0x80(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823345B0: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 823345B4: C1BE007C  lfs f13, 0x7c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823345B8: 7D63E896  mulhw r11, r3, r29
	ctx.r[11].s64 = ((ctx.r[3].s32 as i64 * ctx.r[29].s32 as i64) >> 32);
	// 823345BC: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 823345C0: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823345C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823345C8: 1D6B0064  mulli r11, r11, 0x64
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823345CC: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 823345D0: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823345D4: F9610178  std r11, 0x178(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[11].u64 ) };
	// 823345D8: C9810178  lfd f12, 0x178(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) };
	// 823345DC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 823345E0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 823345E4: EC0C07BA  fmadds f0, f12, f30, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 823345E8: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 823345EC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823345F0: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 823345F4: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 823345F8: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 823345FC: C01E0068  lfs f0, 0x68(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334600: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82334604: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82334608: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8233460C: C01E006C  lfs f0, 0x6c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334610: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82334614: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82334618: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8233461C: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334620: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82334624: D00B0068  stfs f0, 0x68(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82334628: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8233462C: C01E0030  lfs f0, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334630: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82334634: D00B006C  stfs f0, 0x6c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82334638: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8233463C: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334640: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82334644: D00B0070  stfs f0, 0x70(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82334648: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8233464C: C01E003C  lfs f0, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334650: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82334654: D00B0074  stfs f0, 0x74(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82334658: 481FEBB9  bl 0x82533210
	ctx.lr = 0x8233465C;
	sub_82533210(ctx, base);
	// 8233465C: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 82334660: 7F690034  cntlzw r9, r27
	ctx.r[9].u64 = if ctx.r[27].u32 == 0 { 32 } else { ctx.r[27].u32.leading_zeros() as u64 };
	// 82334664: 572A3032  slwi r10, r25, 6
	ctx.r[10].u32 = ctx.r[25].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82334668: C01E0088  lfs f0, 0x88(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233466C: 7CDC5A14  add r6, r28, r11
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82334670: C1BE0084  lfs f13, 0x84(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82334674: 552BDFFE  rlwinm r11, r9, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82334678: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 8233467C: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82334680: 69680001  xori r8, r11, 1
	ctx.r[8].u64 = ctx.r[11].u64 ^ 1;
	// 82334684: 576B083C  slwi r11, r27, 1
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x823347B0; continue 'dispatch;
            }
            0x823347B0 => {
    //   block [0x823347B0..0x82334828)
	// 823347B0: 80DF0118  lwz r6, 0x118(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 823347B4: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 823347B8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823347BC: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 823347C0: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 823347C4: 935F00A8  stw r26, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[26].u32 ) };
	// 823347C8: 390A8E40  addi r8, r10, -0x71c0
	ctx.r[8].s64 = ctx.r[10].s64 + -29120;
	// 823347CC: 935F009C  stw r26, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[26].u32 ) };
	// 823347D0: 397F00D0  addi r11, r31, 0xd0
	ctx.r[11].s64 = ctx.r[31].s64 + 208;
	// 823347D4: 90DF008C  stw r6, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 823347D8: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 823347DC: 3D403F80  lis r10, 0x3f80
	ctx.r[10].s64 = 1065353216;
	// 823347E0: 913F0090  stw r9, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 823347E4: 90FF0098  stw r7, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[7].u32 ) };
	// 823347E8: D3BF00A0  stfs f29, 0xa0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 823347EC: D3BF00A4  stfs f29, 0xa4(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 823347F0: 911F00BC  stw r8, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[8].u32 ) };
	// 823347F4: B35F00C0  sth r26, 0xc0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[26].u16 ) };
	// 823347F8: B35F00C2  sth r26, 0xc2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(194 as u32), ctx.r[26].u16 ) };
	pc = 0x82334828; continue 'dispatch;
            }
            0x82334828 => {
    //   block [0x82334828..0x8233483C)
	// 82334828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233482C: 38210240  addi r1, r1, 0x240
	ctx.r[1].s64 = ctx.r[1].s64 + 576;
	// 82334830: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 82334834: 482017F9  bl 0x8253602c
	ctx.lr = 0x82334838;
	sub_82535FFC(ctx, base);
	// 82334838: 482008B0  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82334840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82334840 size=136
    let mut pc: u32 = 0x82334840;
    'dispatch: loop {
        match pc {
            0x82334840 => {
    //   block [0x82334840..0x82334874)
	// 82334840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82334844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82334848: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233484C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82334850: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82334854: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82334858: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8233485C: 387F0144  addi r3, r31, 0x144
	ctx.r[3].s64 = ctx.r[31].s64 + 324;
	// 82334860: 48000D41  bl 0x823355a0
	ctx.lr = 0x82334864;
	sub_823355A0(ctx, base);
	// 82334864: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82334868: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233486C: 419A0008  beq cr6, 0x82334874
	if ctx.cr[6].eq {
	pc = 0x82334874; continue 'dispatch;
	}
	// 82334870: 4BDE87E9  bl 0x8211d058
	ctx.lr = 0x82334874;
	sub_8211D058(ctx, base);
	pc = 0x82334874; continue 'dispatch;
            }
            0x82334874 => {
    //   block [0x82334874..0x823348B0)
	// 82334874: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82334878: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8233487C: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 82334880: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82334884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82334888: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233488C: 419A0024  beq cr6, 0x823348b0
	if ctx.cr[6].eq {
	pc = 0x823348B0; continue 'dispatch;
	}
	// 82334890: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82334894: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82334898: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8233489C: 409A0014  bne cr6, 0x823348b0
	if !ctx.cr[6].eq {
	pc = 0x823348B0; continue 'dispatch;
	}
	// 823348A0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 823348A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823348A8: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 823348AC: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x823348B0; continue 'dispatch;
            }
            0x823348B0 => {
    //   block [0x823348B0..0x823348C8)
	// 823348B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823348B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823348B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823348BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823348C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823348C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823348C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823348C8 size=104
    let mut pc: u32 = 0x823348C8;
    'dispatch: loop {
        match pc {
            0x823348C8 => {
    //   block [0x823348C8..0x823348EC)
	// 823348C8: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 823348CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823348D0: 419A002C  beq cr6, 0x823348fc
	if ctx.cr[6].eq {
	pc = 0x823348FC; continue 'dispatch;
	}
	// 823348D4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823348D8: 81230088  lwz r9, 0x88(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 823348DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823348E0: 419A000C  beq cr6, 0x823348ec
	if ctx.cr[6].eq {
	pc = 0x823348EC; continue 'dispatch;
	}
	// 823348E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823348E8: 48000014  b 0x823348fc
	pc = 0x823348FC; continue 'dispatch;
            }
            0x823348EC => {
    //   block [0x823348EC..0x823348FC)
	// 823348EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823348F0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823348F4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823348F8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x823348FC; continue 'dispatch;
            }
            0x823348FC => {
    //   block [0x823348FC..0x82334930)
	// 823348FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82334900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82334904: 409A002C  bne cr6, 0x82334930
	if !ctx.cr[6].eq {
		sub_82334930(ctx, base);
		return;
	}
	// 82334908: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8233490C: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82334910: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82334914: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82334918: 91630140  stw r11, 0x140(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 8233491C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82334920: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82334924: 99630025  stb r11, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 82334928: 99430019  stb r10, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 8233492C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82334930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82334930 size=12
    let mut pc: u32 = 0x82334930;
    'dispatch: loop {
        match pc {
            0x82334930 => {
    //   block [0x82334930..0x8233493C)
	// 82334930: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82334934: 91630140  stw r11, 0x140(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82334938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82334940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82334940 size=2404
    //   switch @ 0x82334AB0: r11 with 5 label(s)
    //       case  0  0x82334AC8
    //       case  1  0x82334AD8
    //       case  2  0x82334B04
    //       case  3  0x82334B28
    //       case  4  0x82334B4C
    let mut pc: u32 = 0x82334940;
    'dispatch: loop {
        match pc {
            0x82334940 => {
    //   block [0x82334940..0x82334AC8)
	// 82334940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82334944: 4820073D  bl 0x82535080
	ctx.lr = 0x82334948;
	sub_82535080(ctx, base);
	// 82334948: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 8233494C: 48201665  bl 0x82535fb0
	ctx.lr = 0x82334950;
	sub_82535FB0(ctx, base);
	// 82334950: 3980FEA0  li r12, -0x160
	ctx.r[12].s64 = -352;
	pc = 0x82334AC8; continue 'dispatch;
            }
            0x82334AC8 => {
    //   block [0x82334AC8..0x82334AD8)
	// 82334AC8: FF00E800  fcmpu cr6, f0, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82334ACC: 409900AC  ble cr6, 0x82334b78
	if !ctx.cr[6].gt {
	pc = 0x82334B78; continue 'dispatch;
	}
	// 82334AD0: 91DF0014  stw r14, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[14].u32 ) };
	// 82334AD4: 480000A4  b 0x82334b78
	pc = 0x82334B78; continue 'dispatch;
            }
            0x82334AD8 => {
    //   block [0x82334AD8..0x82334B04)
	// 82334AD8: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334ADC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82334AE0: 40980098  bge cr6, 0x82334b78
	if !ctx.cr[6].lt {
	pc = 0x82334B78; continue 'dispatch;
	}
	// 82334AE4: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82334AE8: EC0D07BA  fmadds f0, f13, f30, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 82334AEC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82334AF0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82334AF4: 41980084  blt cr6, 0x82334b78
	if ctx.cr[6].lt {
	pc = 0x82334B78; continue 'dispatch;
	}
	// 82334AF8: D3FF0000  stfs f31, 0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82334AFC: 923F0014  stw r17, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[17].u32 ) };
	// 82334B00: 48000078  b 0x82334b78
	pc = 0x82334B78; continue 'dispatch;
            }
            0x82334B04 => {
    //   block [0x82334B04..0x82334B28)
	// 82334B04: C1BF0044  lfs f13, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82334B08: FF0D8800  fcmpu cr6, f13, f17
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[17].f64);
	// 82334B0C: 40980008  bge cr6, 0x82334b14
	if !ctx.cr[6].lt {
	pc = 0x82334B14; continue 'dispatch;
	}
	// 82334B10: 925F0014  stw r18, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[18].u32 ) };
	// 82334B14: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82334B18: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82334B1C: 4099005C  ble cr6, 0x82334b78
	if !ctx.cr[6].gt {
	pc = 0x82334B78; continue 'dispatch;
	}
	// 82334B20: 92BF0014  stw r21, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[21].u32 ) };
	// 82334B24: 48000054  b 0x82334b78
	pc = 0x82334B78; continue 'dispatch;
            }
            0x82334B28 => {
    //   block [0x82334B28..0x82334B4C)
	// 82334B28: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334B2C: C1A100B4  lfs f13, 0xb4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82334B30: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82334B34: 4099000C  ble cr6, 0x82334b40
	if !ctx.cr[6].gt {
	pc = 0x82334B40; continue 'dispatch;
	}
	// 82334B38: 92BF0014  stw r21, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[21].u32 ) };
	// 82334B3C: 4800003C  b 0x82334b78
	pc = 0x82334B78; continue 'dispatch;
	// 82334B40: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82334B44: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82334B48: 48000030  b 0x82334b78
	pc = 0x82334B78; continue 'dispatch;
            }
            0x82334B4C => {
    //   block [0x82334B4C..0x823352A4)
	// 82334B4C: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82334B50: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82334B54: 40990020  ble cr6, 0x82334b74
	if !ctx.cr[6].gt {
	pc = 0x82334B74; continue 'dispatch;
	}
	// 82334B58: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82334B5C: EC0D07BC  fnmsubs f0, f13, f30, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82334B60: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82334B64: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82334B68: 41990010  bgt cr6, 0x82334b78
	if ctx.cr[6].gt {
	pc = 0x82334B78; continue 'dispatch;
	}
	// 82334B6C: D3BF0000  stfs f29, 0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82334B70: 48000008  b 0x82334b78
	pc = 0x82334B78; continue 'dispatch;
	// 82334B74: 91FF0014  stw r15, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[15].u32 ) };
	// 82334B78: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82334B7C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82334B80: 419A0008  beq cr6, 0x82334b88
	if ctx.cr[6].eq {
	pc = 0x82334B88; continue 'dispatch;
	}
	// 82334B84: 3A000000  li r16, 0
	ctx.r[16].s64 = 0;
	// 82334B88: 3BBF0040  addi r29, r31, 0x40
	ctx.r[29].s64 = ctx.r[31].s64 + 64;
	// 82334B8C: C19F0070  lfs f12, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82334B90: 396100E0  addi r11, r1, 0xe0
	ctx.r[11].s64 = ctx.r[1].s64 + 224;
	// 82334B94: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82334B98: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823352A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823352A8 size=44
    let mut pc: u32 = 0x823352A8;
    'dispatch: loop {
        match pc {
            0x823352A8 => {
    //   block [0x823352A8..0x823352D4)
	// 823352A8: 81630140  lwz r11, 0x140(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(320 as u32) ) } as u64;
	// 823352AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823352B0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 823352B4: 81630110  lwz r11, 0x110(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) } as u64;
	// 823352B8: 390300D0  addi r8, r3, 0xd0
	ctx.r[8].s64 = ctx.r[3].s64 + 208;
	// 823352BC: 80E300C4  lwz r7, 0xc4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 823352C0: 38C3008C  addi r6, r3, 0x8c
	ctx.r[6].s64 = ctx.r[3].s64 + 140;
	// 823352C4: 38A300BC  addi r5, r3, 0xbc
	ctx.r[5].s64 = ctx.r[3].s64 + 188;
	// 823352C8: 388BFFFF  addi r4, r11, -1
	ctx.r[4].s64 = ctx.r[11].s64 + -1;
	// 823352CC: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 823352D0: 48038188  b 0x8236d458
	sub_8236D458(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823352D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823352D4 size=4
    let mut pc: u32 = 0x823352D4;
    'dispatch: loop {
        match pc {
            0x823352D4 => {
    //   block [0x823352D4..0x823352D8)
	// 823352D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823352D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823352D8 size=104
    let mut pc: u32 = 0x823352D8;
    'dispatch: loop {
        match pc {
            0x823352D8 => {
    //   block [0x823352D8..0x823352F4)
	// 823352D8: 39630080  addi r11, r3, 0x80
	ctx.r[11].s64 = ctx.r[3].s64 + 128;
	// 823352DC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823352E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823352E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823352E8: 409A000C  bne cr6, 0x823352f4
	if !ctx.cr[6].eq {
	pc = 0x823352F4; continue 'dispatch;
	}
	// 823352EC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 823352F0: 4800002C  b 0x8233531c
	pc = 0x8233531C; continue 'dispatch;
            }
            0x823352F4 => {
    //   block [0x823352F4..0x8233530C)
	// 823352F4: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823352F8: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823352FC: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82335300: 419A000C  beq cr6, 0x8233530c
	if ctx.cr[6].eq {
	pc = 0x8233530C; continue 'dispatch;
	}
	// 82335304: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82335308: 48000014  b 0x8233531c
	pc = 0x8233531C; continue 'dispatch;
            }
            0x8233530C => {
    //   block [0x8233530C..0x8233531C)
	// 8233530C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82335310: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82335314: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82335318: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	pc = 0x8233531C; continue 'dispatch;
            }
            0x8233531C => {
    //   block [0x8233531C..0x82335340)
	// 8233531C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82335320: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82335324: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82335328: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8233532C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82335330: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82335334: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82335338: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8233533C: 4BDE7D1C  b 0x8211d058
	sub_8211D058(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82335340 size=4
    let mut pc: u32 = 0x82335340;
    'dispatch: loop {
        match pc {
            0x82335340 => {
    //   block [0x82335340..0x82335344)
	// 82335340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82335348 size=504
    let mut pc: u32 = 0x82335348;
    'dispatch: loop {
        match pc {
            0x82335348 => {
    //   block [0x82335348..0x82335540)
	// 82335348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233534C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82335350: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82335354: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 82335358: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8233535C: 388B5C40  addi r4, r11, 0x5c40
	ctx.r[4].s64 = ctx.r[11].s64 + 23616;
	// 82335360: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82335364: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82335368: C18B1FF8  lfs f12, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8233536C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82335370: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82335374: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82335378: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8233537C: C16BBA38  lfs f11, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82335380: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82335384: 48032905  bl 0x82367c88
	ctx.lr = 0x82335388;
	sub_82367C88(ctx, base);
	// 82335388: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8233538C: 81070100  lwz r8, 0x100(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(256 as u32) ) } as u64;
	// 82335390: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82335550 size=64
    let mut pc: u32 = 0x82335550;
    'dispatch: loop {
        match pc {
            0x82335550 => {
    //   block [0x82335550..0x8233556C)
	// 82335550: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82335554: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82335558: 390BDE2C  addi r8, r11, -0x21d4
	ctx.r[8].s64 = ctx.r[11].s64 + -8660;
	// 8233555C: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 82335560: 394B49D8  addi r10, r11, 0x49d8
	ctx.r[10].s64 = ctx.r[11].s64 + 18904;
	// 82335564: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82335568: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x8233556C; continue 'dispatch;
            }
            0x8233556C => {
    //   block [0x8233556C..0x82335590)
	// 8233556C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82335570: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82335574: 419A001C  beq cr6, 0x82335590
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82335590);
		return;
	}
	// 82335578: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8233557C: 390A0100  addi r8, r10, 0x100
	ctx.r[8].s64 = ctx.r[10].s64 + 256;
	// 82335580: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82335584: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82335588: 4198FFE4  blt cr6, 0x8233556c
	if ctx.cr[6].lt {
	pc = 0x8233556C; continue 'dispatch;
	}
	// 8233558C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823355A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823355A0 size=64
    let mut pc: u32 = 0x823355A0;
    'dispatch: loop {
        match pc {
            0x823355A0 => {
    //   block [0x823355A0..0x823355BC)
	// 823355A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823355A4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823355A8: 390BDE2C  addi r8, r11, -0x21d4
	ctx.r[8].s64 = ctx.r[11].s64 + -8660;
	// 823355AC: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 823355B0: 394B49D8  addi r10, r11, 0x49d8
	ctx.r[10].s64 = ctx.r[11].s64 + 18904;
	// 823355B4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 823355B8: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x823355BC; continue 'dispatch;
            }
            0x823355BC => {
    //   block [0x823355BC..0x823355E0)
	// 823355BC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823355C0: 7F081840  cmplw cr6, r8, r3
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[3].u32, &mut ctx.xer);
	// 823355C4: 419A001C  beq cr6, 0x823355e0
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x823355E0);
		return;
	}
	// 823355C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823355CC: 390A0100  addi r8, r10, 0x100
	ctx.r[8].s64 = ctx.r[10].s64 + 256;
	// 823355D0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823355D4: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 823355D8: 4198FFE4  blt cr6, 0x823355bc
	if ctx.cr[6].lt {
	pc = 0x823355BC; continue 'dispatch;
	}
	// 823355DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823355F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823355F0 size=16
    let mut pc: u32 = 0x823355F0;
    'dispatch: loop {
        match pc {
            0x823355F0 => {
    //   block [0x823355F0..0x82335600)
	// 823355F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 823355F4: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823355F8: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 823355FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82335600 size=844
    let mut pc: u32 = 0x82335600;
    'dispatch: loop {
        match pc {
            0x82335600 => {
    //   block [0x82335600..0x8233566C)
	// 82335600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82335604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82335608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233560C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82335610: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82335614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82335618: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 8233561C: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82335620: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 82335624: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82335628: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233562C: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82335630: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82335634: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82335638: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8233563C: 419902F8  bgt cr6, 0x82335934
	if ctx.cr[6].gt {
	pc = 0x82335934; continue 'dispatch;
	}
	// 82335640: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 82335644: 398C5658  addi r12, r12, 0x5658
	ctx.r[12].s64 = ctx.r[12].s64 + 22104;
	// 82335648: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8233564C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82335650: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82335654: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x8233566C; continue 'dispatch;
		},
		1 => {
	pc = 0x82335764; continue 'dispatch;
		},
		2 => {
	pc = 0x82335810; continue 'dispatch;
		},
		3 => {
	pc = 0x82335870; continue 'dispatch;
		},
		4 => {
	pc = 0x823358C4; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82335658: 8233566C  lwz r17, 0x566c(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(22124 as u32) ) } as u64;
	// 8233565C: 82335764  lwz r17, 0x5764(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(22372 as u32) ) } as u64;
	// 82335660: 82335810  lwz r17, 0x5810(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(22544 as u32) ) } as u64;
	// 82335664: 82335870  lwz r17, 0x5870(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(22640 as u32) ) } as u64;
	// 82335668: 823358C4  lwz r17, 0x58c4(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(22724 as u32) ) } as u64;
            }
            0x8233566C => {
    //   block [0x8233566C..0x82335764)
	// 8233566C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	pc = 0x82335764; continue 'dispatch;
            }
            0x82335764 => {
    //   block [0x82335764..0x82335810)
	// 82335764: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82335768: 3BDF0090  addi r30, r31, 0x90
	ctx.r[30].s64 = ctx.r[31].s64 + 144;
	pc = 0x82335810; continue 'dispatch;
            }
            0x82335810 => {
    //   block [0x82335810..0x82335870)
	// 82335810: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82335814: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82335818: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 8233581C: EDA0683A  fmadds f13, f0, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82335820: C00A2C7C  lfs f0, 0x2c7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82335824: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82335828: 40990010  ble cr6, 0x82335838
	if !ctx.cr[6].gt {
	pc = 0x82335838; continue 'dispatch;
	}
	// 8233582C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82335830: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82335834: 480000FC  b 0x82335930
	pc = 0x82335930; continue 'dispatch;
	// 82335838: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8233583C: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82335840: C1AA1FF8  lfs f13, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82335844: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82335848: 409A00D0  bne cr6, 0x82335918
	if !ctx.cr[6].eq {
	pc = 0x82335918; continue 'dispatch;
	}
	// 8233584C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82335850: 388B0030  addi r4, r11, 0x30
	ctx.r[4].s64 = ctx.r[11].s64 + 48;
	// 82335854: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82335858: 4802CE29  bl 0x82362680
	ctx.lr = 0x8233585C;
	sub_82362680(ctx, base);
	// 8233585C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82335860: C1BF008C  lfs f13, 0x8c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82335864: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82335868: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8233586C: 480000C4  b 0x82335930
	pc = 0x82335930; continue 'dispatch;
            }
            0x82335870 => {
    //   block [0x82335870..0x823358C4)
	// 82335870: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82335874: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 82335878: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 8233587C: EDA0683A  fmadds f13, f0, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82335880: C00AD588  lfs f0, -0x2a78(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10872 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82335884: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82335888: 4199FFA4  bgt cr6, 0x8233582c
	if ctx.cr[6].gt {
	pc = 0x8233582C; continue 'dispatch;
	}
	// 8233588C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82335890: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82335894: C1AA1FF8  lfs f13, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82335898: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8233589C: 409A007C  bne cr6, 0x82335918
	if !ctx.cr[6].eq {
	pc = 0x82335918; continue 'dispatch;
	}
	// 823358A0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 823358A4: 388B0030  addi r4, r11, 0x30
	ctx.r[4].s64 = ctx.r[11].s64 + 48;
	// 823358A8: 3860000E  li r3, 0xe
	ctx.r[3].s64 = 14;
	// 823358AC: 4802CDD5  bl 0x82362680
	ctx.lr = 0x823358B0;
	sub_82362680(ctx, base);
	// 823358B0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823358B4: C1BF008C  lfs f13, 0x8c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823358B8: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823358BC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823358C0: 48000070  b 0x82335930
	pc = 0x82335930; continue 'dispatch;
            }
            0x823358C4 => {
    //   block [0x823358C4..0x82335934)
	// 823358C4: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823358C8: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 823358CC: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 823358D0: EDA0683A  fmadds f13, f0, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823358D4: C00AD588  lfs f0, -0x2a78(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10872 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823358D8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823358DC: 4199FF50  bgt cr6, 0x8233582c
	if ctx.cr[6].gt {
	pc = 0x8233582C; continue 'dispatch;
	}
	// 823358E0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823358E4: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823358E8: C1AA1FF8  lfs f13, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823358EC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823358F0: 409A0028  bne cr6, 0x82335918
	if !ctx.cr[6].eq {
	pc = 0x82335918; continue 'dispatch;
	}
	// 823358F4: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 823358F8: 388B0030  addi r4, r11, 0x30
	ctx.r[4].s64 = ctx.r[11].s64 + 48;
	// 823358FC: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82335900: 4802CD81  bl 0x82362680
	ctx.lr = 0x82335904;
	sub_82362680(ctx, base);
	// 82335904: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82335908: C1BF008C  lfs f13, 0x8c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233590C: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82335910: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82335914: 4800001C  b 0x82335930
	pc = 0x82335930; continue 'dispatch;
	// 82335918: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8233591C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82335920: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 82335924: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82335928: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233592C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82335930: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
            }
            0x82335934 => {
    //   block [0x82335934..0x8233594C)
	// 82335934: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82335938: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233593C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82335940: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82335944: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82335948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82335950 size=88
    let mut pc: u32 = 0x82335950;
    'dispatch: loop {
        match pc {
            0x82335950 => {
    //   block [0x82335950..0x82335998)
	// 82335950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82335954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82335958: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233595C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82335960: 814B03A0  lwz r10, 0x3a0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(928 as u32) ) } as u64;
	// 82335964: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82335968: 409A0030  bne cr6, 0x82335998
	if !ctx.cr[6].eq {
	pc = 0x82335998; continue 'dispatch;
	}
	// 8233596C: 814B03A8  lwz r10, 0x3a8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(936 as u32) ) } as u64;
	// 82335970: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82335974: 409A0024  bne cr6, 0x82335998
	if !ctx.cr[6].eq {
	pc = 0x82335998; continue 'dispatch;
	}
	// 82335978: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8233597C: 388B0360  addi r4, r11, 0x360
	ctx.r[4].s64 = ctx.r[11].s64 + 864;
	// 82335980: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82335984: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82335988: 914B03A8  stw r10, 0x3a8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(936 as u32), ctx.r[10].u32 ) };
	// 8233598C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82335990: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82335994: 4802CCED  bl 0x82362680
	ctx.lr = 0x82335998;
	sub_82362680(ctx, base);
	pc = 0x82335998; continue 'dispatch;
            }
            0x82335998 => {
    //   block [0x82335998..0x823359A8)
	// 82335998: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8233599C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823359A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823359A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823359A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823359A8 size=40
    let mut pc: u32 = 0x823359A8;
    'dispatch: loop {
        match pc {
            0x823359A8 => {
    //   block [0x823359A8..0x823359C0)
	// 823359A8: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823359AC: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 823359B0: 419A0010  beq cr6, 0x823359c0
	if ctx.cr[6].eq {
	pc = 0x823359C0; continue 'dispatch;
	}
	// 823359B4: 816303A0  lwz r11, 0x3a0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(928 as u32) ) } as u64;
	// 823359B8: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823359BC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x823359C0; continue 'dispatch;
            }
            0x823359C0 => {
    //   block [0x823359C0..0x823359D0)
	// 823359C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823359C4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823359C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823359CC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823359D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823359D8 size=164
    let mut pc: u32 = 0x823359D8;
    'dispatch: loop {
        match pc {
            0x823359D8 => {
    //   block [0x823359D8..0x82335A58)
	// 823359D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823359DC: 481FF6D9  bl 0x825350b4
	ctx.lr = 0x823359E0;
	sub_82535080(ctx, base);
	// 823359E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823359E4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823359E8: 7D264B78  mr r6, r9
	ctx.r[6].u64 = ctx.r[9].u64;
	// 823359EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823359F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823359F4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 823359F8: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823359FC: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82335A00: 4BFF8B31  bl 0x8232e530
	ctx.lr = 0x82335A04;
	sub_8232E530(ctx, base);
	// 82335A04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82335A08: 387F03AC  addi r3, r31, 0x3ac
	ctx.r[3].s64 = ctx.r[31].s64 + 940;
	// 82335A0C: 396BDE6C  addi r11, r11, -0x2194
	ctx.r[11].s64 = ctx.r[11].s64 + -8596;
	// 82335A10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82335A14: 4BFFFB3D  bl 0x82335550
	ctx.lr = 0x82335A18;
	sub_82335550(ctx, base);
	// 82335A18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82335A1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82335A20: 396BDE8C  addi r11, r11, -0x2174
	ctx.r[11].s64 = ctx.r[11].s64 + -8564;
	// 82335A24: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82335A28: 93DF0390  stw r30, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[30].u32 ) };
	// 82335A2C: 937F039C  stw r27, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[27].u32 ) };
	// 82335A30: 93BF0394  stw r29, 0x394(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[29].u32 ) };
	// 82335A34: 939F0398  stw r28, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[28].u32 ) };
	// 82335A38: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82335A3C: 93FF03B0  stw r31, 0x3b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(944 as u32), ctx.r[31].u32 ) };
	// 82335A40: 897E0004  lbz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82335A44: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82335A48: 41980010  blt cr6, 0x82335a58
	if ctx.cr[6].lt {
	pc = 0x82335A58; continue 'dispatch;
	}
	// 82335A4C: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82335A50: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82335A54: 917F03A0  stw r11, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[11].u32 ) };
	pc = 0x82335A58; continue 'dispatch;
            }
            0x82335A58 => {
    //   block [0x82335A58..0x82335A74)
	// 82335A58: 897E0004  lbz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82335A5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82335A60: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82335A64: 41980010  blt cr6, 0x82335a74
	if ctx.cr[6].lt {
	pc = 0x82335A74; continue 'dispatch;
	}
	// 82335A68: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82335A6C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82335A70: 917F03A4  stw r11, 0x3a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(932 as u32), ctx.r[11].u32 ) };
	pc = 0x82335A74; continue 'dispatch;
            }
            0x82335A74 => {
    //   block [0x82335A74..0x82335A7C)
	// 82335A74: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82335A78: 481FF68C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82335A80 size=112
    let mut pc: u32 = 0x82335A80;
    'dispatch: loop {
        match pc {
            0x82335A80 => {
    //   block [0x82335A80..0x82335AE0)
	// 82335A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82335A84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82335A88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82335A8C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82335A90: 386703AC  addi r3, r7, 0x3ac
	ctx.r[3].s64 = ctx.r[7].s64 + 940;
	// 82335A94: 4BFFFB0D  bl 0x823355a0
	ctx.lr = 0x82335A98;
	sub_823355A0(ctx, base);
	// 82335A98: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82335A9C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82335AA0: 396B4634  addi r11, r11, 0x4634
	ctx.r[11].s64 = ctx.r[11].s64 + 17972;
	// 82335AA4: 394ADED0  addi r10, r10, -0x2130
	ctx.r[10].s64 = ctx.r[10].s64 + -8496;
	// 82335AA8: 548907FE  clrlwi r9, r4, 0x1f
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82335AAC: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82335AB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82335AB4: 91670370  stw r11, 0x370(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(880 as u32), ctx.r[11].u32 ) };
	// 82335AB8: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82335ABC: 419A0024  beq cr6, 0x82335ae0
	if ctx.cr[6].eq {
	pc = 0x82335AE0; continue 'dispatch;
	}
	// 82335AC0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82335AC4: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82335AC8: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82335ACC: 409A0014  bne cr6, 0x82335ae0
	if !ctx.cr[6].eq {
	pc = 0x82335AE0; continue 'dispatch;
	}
	// 82335AD0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82335AD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82335AD8: 99670019  stb r11, 0x19(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82335ADC: 99470025  stb r10, 0x25(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x82335AE0; continue 'dispatch;
            }
            0x82335AE0 => {
    //   block [0x82335AE0..0x82335AF0)
	// 82335AE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82335AE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82335AE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82335AEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82335AF0 size=48
    let mut pc: u32 = 0x82335AF0;
    'dispatch: loop {
        match pc {
            0x82335AF0 => {
    //   block [0x82335AF0..0x82335B20)
	// 82335AF0: 81630374  lwz r11, 0x374(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(884 as u32) ) } as u64;
	// 82335AF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82335AF8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82335AFC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82335B00: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82335B04: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82335B08: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82335B0C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82335B10: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82335B14: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82335B18: 99430025  stb r10, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 82335B1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82335B20 size=180
    let mut pc: u32 = 0x82335B20;
    'dispatch: loop {
        match pc {
            0x82335B20 => {
    //   block [0x82335B20..0x82335B78)
	// 82335B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82335B24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82335B28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82335B2C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82335B30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82335B34: 817F03A8  lwz r11, 0x3a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(936 as u32) ) } as u64;
	// 82335B38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82335B3C: 419A003C  beq cr6, 0x82335b78
	if ctx.cr[6].eq {
	pc = 0x82335B78; continue 'dispatch;
	}
	// 82335B40: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82335B44: C01F00C4  lfs f0, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82335B48: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82335B4C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82335B50: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82335B54: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82335B58: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82335B5C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82335B60: 41980018  blt cr6, 0x82335b78
	if ctx.cr[6].lt {
	pc = 0x82335B78; continue 'dispatch;
	}
	// 82335B64: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82335B68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82335B6C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82335B70: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82335B74: 915F03A8  stw r10, 0x3a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(936 as u32), ctx.r[10].u32 ) };
	pc = 0x82335B78; continue 'dispatch;
            }
            0x82335B78 => {
    //   block [0x82335B78..0x82335BC0)
	// 82335B78: 817F0394  lwz r11, 0x394(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 82335B7C: C01F00C4  lfs f0, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82335B80: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 82335B84: D01F037C  stfs f0, 0x37c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), tmp.u32 ) };
	// 82335B88: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82335B8C: 4BEE8845  bl 0x8221e3d0
	ctx.lr = 0x82335B90;
	sub_8221E3D0(ctx, base);
	// 82335B90: 817F03A8  lwz r11, 0x3a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(936 as u32) ) } as u64;
	// 82335B94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82335B98: 419A0028  beq cr6, 0x82335bc0
	if ctx.cr[6].eq {
	pc = 0x82335BC0; continue 'dispatch;
	}
	// 82335B9C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82335BA0: C1BF00C4  lfs f13, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82335BA4: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82335BA8: C19F00C8  lfs f12, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82335BAC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82335BB0: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 82335BB4: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82335BB8: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82335BBC: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	pc = 0x82335BC0; continue 'dispatch;
            }
            0x82335BC0 => {
    //   block [0x82335BC0..0x82335BD4)
	// 82335BC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82335BC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82335BC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82335BCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82335BD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82335BD8 size=172
    let mut pc: u32 = 0x82335BD8;
    'dispatch: loop {
        match pc {
            0x82335BD8 => {
    //   block [0x82335BD8..0x82335C4C)
	// 82335BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82335BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82335BE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82335BE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82335BE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82335BEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82335BF0: 396BDED8  addi r11, r11, -0x2128
	ctx.r[11].s64 = ctx.r[11].s64 + -8488;
	// 82335BF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82335BF8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82335BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82335C00: 419A004C  beq cr6, 0x82335c4c
	if ctx.cr[6].eq {
	pc = 0x82335C4C; continue 'dispatch;
	}
	// 82335C04: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82335C08: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82335C0C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82335C10: 409A003C  bne cr6, 0x82335c4c
	if !ctx.cr[6].eq {
	pc = 0x82335C4C; continue 'dispatch;
	}
	// 82335C14: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82335C18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82335C1C: 419A0030  beq cr6, 0x82335c4c
	if ctx.cr[6].eq {
	pc = 0x82335C4C; continue 'dispatch;
	}
	// 82335C20: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82335C24: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82335C28: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82335C2C: 409A0020  bne cr6, 0x82335c4c
	if !ctx.cr[6].eq {
	pc = 0x82335C4C; continue 'dispatch;
	}
	// 82335C30: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82335C34: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82335C38: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82335C3C: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 82335C40: 610A8000  ori r10, r8, 0x8000
	ctx.r[10].u64 = ctx.r[8].u64 | 32768;
	// 82335C44: 992B0025  stb r9, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[9].u8 ) };
	// 82335C48: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x82335C4C; continue 'dispatch;
            }
            0x82335C4C => {
    //   block [0x82335C4C..0x82335C70)
	// 82335C4C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82335C50: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82335C54: 396B3BF8  addi r11, r11, 0x3bf8
	ctx.r[11].s64 = ctx.r[11].s64 + 15352;
	// 82335C58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82335C5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82335C60: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82335C64: 419A000C  beq cr6, 0x82335c70
	if ctx.cr[6].eq {
	pc = 0x82335C70; continue 'dispatch;
	}
	// 82335C68: 481FCF51  bl 0x82532bb8
	ctx.lr = 0x82335C6C;
	sub_82532BB8(ctx, base);
	// 82335C6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82335C70; continue 'dispatch;
            }
            0x82335C70 => {
    //   block [0x82335C70..0x82335C84)
	// 82335C70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82335C74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82335C78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82335C7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82335C80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82335C88 size=16
    let mut pc: u32 = 0x82335C88;
    'dispatch: loop {
        match pc {
            0x82335C88 => {
    //   block [0x82335C88..0x82335C98)
	// 82335C88: A163000A  lhz r11, 0xa(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(10 as u32) ) } as u64;
	// 82335C8C: 556B383E  rotlwi r11, r11, 7
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(7)) as u64;
	// 82335C90: 386B0060  addi r3, r11, 0x60
	ctx.r[3].s64 = ctx.r[11].s64 + 96;
	// 82335C94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82335C98 size=48
    let mut pc: u32 = 0x82335C98;
    'dispatch: loop {
        match pc {
            0x82335C98 => {
    //   block [0x82335C98..0x82335CC8)
	// 82335C98: A1430008  lhz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82335C9C: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82335CA0: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82335CA4: 396BB670  addi r11, r11, -0x4990
	ctx.r[11].s64 = ctx.r[11].s64 + -18832;
	// 82335CA8: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82335CAC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 82335CB0: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 82335CB4: A1630008  lhz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82335CB8: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82335CBC: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82335CC0: 7D4B412E  stwx r10, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 82335CC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82335CC8 size=248
    let mut pc: u32 = 0x82335CC8;
    'dispatch: loop {
        match pc {
            0x82335CC8 => {
    //   block [0x82335CC8..0x82335D30)
	// 82335CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82335CCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82335CD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82335CD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82335CD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82335CDC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82335CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82335CE4: 419A004C  beq cr6, 0x82335d30
	if ctx.cr[6].eq {
	pc = 0x82335D30; continue 'dispatch;
	}
	// 82335CE8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82335CEC: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82335CF0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82335CF4: 409A003C  bne cr6, 0x82335d30
	if !ctx.cr[6].eq {
	pc = 0x82335D30; continue 'dispatch;
	}
	// 82335CF8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82335CFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82335D00: 419A0030  beq cr6, 0x82335d30
	if ctx.cr[6].eq {
	pc = 0x82335D30; continue 'dispatch;
	}
	// 82335D04: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82335D08: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82335D0C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82335D10: 409A0020  bne cr6, 0x82335d30
	if !ctx.cr[6].eq {
	pc = 0x82335D30; continue 'dispatch;
	}
	// 82335D14: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82335D18: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82335D1C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82335D20: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 82335D24: 610A8000  ori r10, r8, 0x8000
	ctx.r[10].u64 = ctx.r[8].u64 | 32768;
	// 82335D28: 992B0025  stb r9, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[9].u8 ) };
	// 82335D2C: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x82335D30; continue 'dispatch;
            }
            0x82335D30 => {
    //   block [0x82335D30..0x82335D64)
	// 82335D30: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82335D34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82335D38: 38EB1160  addi r7, r11, 0x1160
	ctx.r[7].s64 = ctx.r[11].s64 + 4448;
	// 82335D3C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82335D40: 38A00300  li r5, 0x300
	ctx.r[5].s64 = 768;
	// 82335D44: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 82335D48: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82335D4C: 48034745  bl 0x8236a490
	ctx.lr = 0x82335D50;
	sub_8236A490(ctx, base);
	// 82335D50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82335D54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82335D58: 419A000C  beq cr6, 0x82335d64
	if ctx.cr[6].eq {
	pc = 0x82335D64; continue 'dispatch;
	}
	// 82335D5C: 81430030  lwz r10, 0x30(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82335D60: 48000008  b 0x82335d68
	pc = 0x82335D68; continue 'dispatch;
            }
            0x82335D64 => {
    //   block [0x82335D64..0x82335D68)
	// 82335D64: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82335D68; continue 'dispatch;
            }
            0x82335D68 => {
    //   block [0x82335D68..0x82335DAC)
	// 82335D68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82335D6C: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82335D70: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 82335D74: 419A0038  beq cr6, 0x82335dac
	if ctx.cr[6].eq {
	pc = 0x82335DAC; continue 'dispatch;
	}
	// 82335D78: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 82335D7C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82335D80: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82335D84: 38E7DEB8  addi r7, r7, -0x2148
	ctx.r[7].s64 = ctx.r[7].s64 + -8520;
	// 82335D88: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82335D8C: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82335D90: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82335D94: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82335D98: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82335D9C: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82335DA0: 914300A0  stw r10, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 82335DA4: 9123009C  stw r9, 0x9c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), ctx.r[9].u32 ) };
	// 82335DA8: 91030080  stw r8, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	pc = 0x82335DAC; continue 'dispatch;
            }
            0x82335DAC => {
    //   block [0x82335DAC..0x82335DC0)
	// 82335DAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82335DB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82335DB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82335DB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82335DBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82335DC0 size=164
    let mut pc: u32 = 0x82335DC0;
    'dispatch: loop {
        match pc {
            0x82335DC0 => {
    //   block [0x82335DC0..0x82335E50)
	// 82335DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82335DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82335DC8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82335DCC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82335DD0: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82335DD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82335DD8: 419A0078  beq cr6, 0x82335e50
	if ctx.cr[6].eq {
	pc = 0x82335E50; continue 'dispatch;
	}
	// 82335DDC: 390A002F  addi r8, r10, 0x2f
	ctx.r[8].s64 = ctx.r[10].s64 + 47;
	// 82335DE0: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82335DE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82335DE8: 90AA0014  stw r5, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 82335DEC: 55030036  rlwinm r3, r8, 0, 0, 0x1b
	ctx.r[3].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 82335DF0: 396BDED8  addi r11, r11, -0x2128
	ctx.r[11].s64 = ctx.r[11].s64 + -8488;
	// 82335DF4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82335DF8: 38850010  addi r4, r5, 0x10
	ctx.r[4].s64 = ctx.r[5].s64 + 16;
	// 82335DFC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82335E00: F90A0018  std r8, 0x18(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[8].u64 ) };
	// 82335E04: A165000A  lhz r11, 0xa(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(10 as u32) ) } as u64;
	// 82335E08: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 82335E0C: B16A0008  sth r11, 8(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u16 ) };
	// 82335E10: A1650008  lhz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82335E14: 906A000C  stw r3, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82335E18: B16A000A  sth r11, 0xa(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(10 as u32), ctx.r[11].u16 ) };
	// 82335E1C: 48032BAD  bl 0x823689c8
	ctx.lr = 0x82335E20;
	sub_823689C8(ctx, base);
	// 82335E20: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82335E24: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82335E28: A12A000A  lhz r9, 0xa(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(10 as u32) ) } as u64;
	// 82335E2C: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 82335E30: 5529303E  rotlwi r9, r9, 6
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(6)) as u64;
	// 82335E34: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82335E38: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82335E3C: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82335E40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82335E44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82335E48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82335E4C: 4E800020  blr
	return;
            }
            0x82335E50 => {
    //   block [0x82335E50..0x82335E64)
	// 82335E50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82335E54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82335E58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82335E5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82335E60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82335E68 size=16
    let mut pc: u32 = 0x82335E68;
    'dispatch: loop {
        match pc {
            0x82335E68 => {
    //   block [0x82335E68..0x82335E78)
	// 82335E68: A1630008  lhz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82335E6C: 556B383E  rotlwi r11, r11, 7
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(7)) as u64;
	// 82335E70: 386B0060  addi r3, r11, 0x60
	ctx.r[3].s64 = ctx.r[11].s64 + 96;
	// 82335E74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82335E78 size=140
    let mut pc: u32 = 0x82335E78;
    'dispatch: loop {
        match pc {
            0x82335E78 => {
    //   block [0x82335E78..0x82335EB0)
	// 82335E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82335E7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82335E80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82335E84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82335E88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82335E8C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82335E90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82335E94: 396BDEB8  addi r11, r11, -0x2148
	ctx.r[11].s64 = ctx.r[11].s64 + -8520;
	// 82335E98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82335E9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82335EA0: 807F0090  lwz r3, 0x90(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82335EA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82335EA8: 419A0008  beq cr6, 0x82335eb0
	if ctx.cr[6].eq {
	pc = 0x82335EB0; continue 'dispatch;
	}
	// 82335EAC: 4BDE71AD  bl 0x8211d058
	ctx.lr = 0x82335EB0;
	sub_8211D058(ctx, base);
	pc = 0x82335EB0; continue 'dispatch;
            }
            0x82335EB0 => {
    //   block [0x82335EB0..0x82335EEC)
	// 82335EB0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82335EB4: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82335EB8: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 82335EBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82335EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82335EC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82335EC8: 419A0024  beq cr6, 0x82335eec
	if ctx.cr[6].eq {
	pc = 0x82335EEC; continue 'dispatch;
	}
	// 82335ECC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82335ED0: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82335ED4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82335ED8: 409A0014  bne cr6, 0x82335eec
	if !ctx.cr[6].eq {
	pc = 0x82335EEC; continue 'dispatch;
	}
	// 82335EDC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82335EE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82335EE4: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82335EE8: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x82335EEC; continue 'dispatch;
            }
            0x82335EEC => {
    //   block [0x82335EEC..0x82335F04)
	// 82335EEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82335EF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82335EF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82335EF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82335EFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82335F00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82335F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82335F08 size=708
    let mut pc: u32 = 0x82335F08;
    'dispatch: loop {
        match pc {
            0x82335F08 => {
    //   block [0x82335F08..0x82335F64)
	// 82335F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82335F0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82335F10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82335F14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82335F18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82335F1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82335F20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82335F24: 38CBDEAC  addi r6, r11, -0x2154
	ctx.r[6].s64 = ctx.r[11].s64 + -8532;
	// 82335F28: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 82335F2C: 3BDF008C  addi r30, r31, 0x8c
	ctx.r[30].s64 = ctx.r[31].s64 + 140;
	// 82335F30: 386BDBE0  addi r3, r11, -0x2420
	ctx.r[3].s64 = ctx.r[11].s64 + -9248;
	// 82335F34: 3CA00001  lis r5, 1
	ctx.r[5].s64 = 65536;
	// 82335F38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82335F3C: 4BEBF3AD  bl 0x821f52e8
	ctx.lr = 0x82335F40;
	sub_821F52E8(ctx, base);
	// 82335F40: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82335F44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82335F48: 419A002C  beq cr6, 0x82335f74
	if ctx.cr[6].eq {
	pc = 0x82335F74; continue 'dispatch;
	}
	// 82335F4C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82335F50: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82335F54: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82335F58: 419A000C  beq cr6, 0x82335f64
	if ctx.cr[6].eq {
	pc = 0x82335F64; continue 'dispatch;
	}
	// 82335F5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82335F60: 48000014  b 0x82335f74
	pc = 0x82335F74; continue 'dispatch;
            }
            0x82335F64 => {
    //   block [0x82335F64..0x82335F74)
	// 82335F64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82335F68: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82335F6C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82335F70: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x82335F74; continue 'dispatch;
            }
            0x82335F74 => {
    //   block [0x82335F74..0x82335FA4)
	// 82335F74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82335F78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82335F7C: 409A0028  bne cr6, 0x82335fa4
	if !ctx.cr[6].eq {
	pc = 0x82335FA4; continue 'dispatch;
	}
	// 82335F80: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82335F84: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82335F88: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82335F8C: 409A0228  bne cr6, 0x823361b4
	if !ctx.cr[6].eq {
	pc = 0x823361B4; continue 'dispatch;
	}
	// 82335F90: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82335F94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82335F98: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82335F9C: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 82335FA0: 48000214  b 0x823361b4
	pc = 0x823361B4; continue 'dispatch;
            }
            0x82335FA4 => {
    //   block [0x82335FA4..0x82335FD0)
	// 82335FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82335FA8: 4BEF7441  bl 0x8222d3e8
	ctx.lr = 0x82335FAC;
	sub_8222D3E8(ctx, base);
	// 82335FAC: 3963007F  addi r11, r3, 0x7f
	ctx.r[11].s64 = ctx.r[3].s64 + 127;
	// 82335FB0: 3D430001  addis r10, r3, 1
	ctx.r[10].s64 = ctx.r[3].s64 + 65536;
	// 82335FB4: 55690030  rlwinm r9, r11, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82335FB8: 554B0030  rlwinm r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82335FBC: 7F091840  cmplw cr6, r9, r3
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82335FC0: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82335FC4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82335FC8: 419A0008  beq cr6, 0x82335fd0
	if ctx.cr[6].eq {
	pc = 0x82335FD0; continue 'dispatch;
	}
	// 82335FCC: 7C001A2C  dcbt 0, r3
	pc = 0x82335FD0; continue 'dispatch;
            }
            0x82335FD0 => {
    //   block [0x82335FD0..0x82335FDC)
	// 82335FD0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82335FD4: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 82335FD8: 41980080  blt cr6, 0x82336058
	if ctx.cr[6].lt {
	pc = 0x82336058; continue 'dispatch;
	}
	pc = 0x82335FDC; continue 'dispatch;
            }
            0x82335FDC => {
    //   block [0x82335FDC..0x82336058)
	// 82335FDC: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 82335FE0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82335FE4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82335FE8: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 82335FEC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82335FF0: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 82335FF4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82335FF8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82335FFC: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 82336000: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82336004: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82336008: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 8233600C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82336010: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82336014: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 82336018: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8233601C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82336020: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 82336024: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82336028: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8233602C: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 82336030: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82336034: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82336038: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8233603C: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 82336040: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82336044: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 82336048: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 8233604C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82336050: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82336054: 4098FF88  bge cr6, 0x82335fdc
	if !ctx.cr[6].lt {
	pc = 0x82335FDC; continue 'dispatch;
	}
	pc = 0x82336058; continue 'dispatch;
            }
            0x82336058 => {
    //   block [0x82336058..0x8233609C)
	// 82336058: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 8233605C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82336060: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 82336064: 41990088  bgt cr6, 0x823360ec
	if ctx.cr[6].gt {
	pc = 0x823360EC; continue 'dispatch;
	}
	// 82336068: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 8233606C: 398C6080  addi r12, r12, 0x6080
	ctx.r[12].s64 = ctx.r[12].s64 + 24704;
	// 82336070: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82336074: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82336078: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8233607C: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x823360E4; continue 'dispatch;
		},
		1 => {
	pc = 0x823360D8; continue 'dispatch;
		},
		2 => {
	pc = 0x823360CC; continue 'dispatch;
		},
		3 => {
	pc = 0x823360C0; continue 'dispatch;
		},
		4 => {
	pc = 0x823360B4; continue 'dispatch;
		},
		5 => {
	pc = 0x823360A8; continue 'dispatch;
		},
		6 => {
	pc = 0x8233609C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82336080: 823360E4  lwz r17, 0x60e4(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(24804 as u32) ) } as u64;
	// 82336084: 823360D8  lwz r17, 0x60d8(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(24792 as u32) ) } as u64;
	// 82336088: 823360CC  lwz r17, 0x60cc(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(24780 as u32) ) } as u64;
	// 8233608C: 823360C0  lwz r17, 0x60c0(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(24768 as u32) ) } as u64;
	// 82336090: 823360B4  lwz r17, 0x60b4(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(24756 as u32) ) } as u64;
	// 82336094: 823360A8  lwz r17, 0x60a8(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(24744 as u32) ) } as u64;
	// 82336098: 8233609C  lwz r17, 0x609c(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(24732 as u32) ) } as u64;
            }
            0x8233609C => {
    //   block [0x8233609C..0x823360A8)
	// 8233609C: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 823360A0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823360A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823360A8; continue 'dispatch;
            }
            0x823360A8 => {
    //   block [0x823360A8..0x823360B4)
	// 823360A8: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 823360AC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823360B0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823360B4; continue 'dispatch;
            }
            0x823360B4 => {
    //   block [0x823360B4..0x823360C0)
	// 823360B4: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 823360B8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823360BC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823360C0; continue 'dispatch;
            }
            0x823360C0 => {
    //   block [0x823360C0..0x823360CC)
	// 823360C0: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 823360C4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823360C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823360CC; continue 'dispatch;
            }
            0x823360CC => {
    //   block [0x823360CC..0x823360D8)
	// 823360CC: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 823360D0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823360D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823360D8; continue 'dispatch;
            }
            0x823360D8 => {
    //   block [0x823360D8..0x823360E4)
	// 823360D8: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 823360DC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 823360E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x823360E4; continue 'dispatch;
            }
            0x823360E4 => {
    //   block [0x823360E4..0x823360EC)
	// 823360E4: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 823360E8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	pc = 0x823360EC; continue 'dispatch;
            }
            0x823360EC => {
    //   block [0x823360EC..0x82336138)
	// 823360EC: 811F0080  lwz r8, 0x80(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 823360F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823360F4: A1680008  lhz r11, 8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 823360F8: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 823360FC: 4BEF72ED  bl 0x8222d3e8
	ctx.lr = 0x82336100;
	sub_8222D3E8(ctx, base);
	// 82336100: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82336104: 80BF00A4  lwz r5, 0xa4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82336108: 3BDF0084  addi r30, r31, 0x84
	ctx.r[30].s64 = ctx.r[31].s64 + 132;
	// 8233610C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82336110: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82336114: 90DF0098  stw r6, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[6].u32 ) };
	// 82336118: 80880060  lwz r4, 0x60(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(96 as u32) ) } as u64;
	// 8233611C: 4BEECB4D  bl 0x82222c68
	ctx.lr = 0x82336120;
	sub_82222C68(ctx, base);
	// 82336120: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82336124: 816BB9D8  lwz r11, -0x4628(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 82336128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233612C: 419A000C  beq cr6, 0x82336138
	if ctx.cr[6].eq {
	pc = 0x82336138; continue 'dispatch;
	}
	// 82336130: 386B0100  addi r3, r11, 0x100
	ctx.r[3].s64 = ctx.r[11].s64 + 256;
	// 82336134: 4BE5FD85  bl 0x82195eb8
	ctx.lr = 0x82336138;
	sub_82195EB8(ctx, base);
	pc = 0x82336138; continue 'dispatch;
            }
            0x82336138 => {
    //   block [0x82336138..0x82336188)
	// 82336138: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8233613C: 809F009C  lwz r4, 0x9c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82336140: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82336144: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82336148: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233614C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82336150: D00BF358  stfs f0, -0xca8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-3240 as u32), tmp.u32 ) };
	// 82336154: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82336158: C00B2294  lfs f0, 0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233615C: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 82336160: D00B64DC  stfs f0, 0x64dc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(25820 as u32), tmp.u32 ) };
	// 82336164: 4BEED005  bl 0x82223168
	ctx.lr = 0x82336168;
	sub_82223168(ctx, base);
	// 82336168: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8233616C: 80CB0064  lwz r6, 0x64(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82336170: 7C00322C  dcbt 0, r6
	// 82336174: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82336178: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 8233617C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336180: 40990034  ble cr6, 0x823361b4
	if !ctx.cr[6].gt {
	pc = 0x823361B4; continue 'dispatch;
	}
	// 82336184: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x82336188; continue 'dispatch;
            }
            0x82336188 => {
    //   block [0x82336188..0x823361B4)
	// 82336188: 815F009C  lwz r10, 0x9c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 8233618C: 7CA83214  add r5, r8, r6
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 82336190: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82336194: 7C885214  add r4, r8, r10
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82336198: 7C6B4214  add r3, r11, r8
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 8233619C: 48031B95  bl 0x82367d30
	ctx.lr = 0x823361A0;
	sub_82367D30(ctx, base);
	// 823361A0: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 823361A4: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 823361A8: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 823361AC: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823361B0: 4198FFD8  blt cr6, 0x82336188
	if ctx.cr[6].lt {
	pc = 0x82336188; continue 'dispatch;
	}
	pc = 0x823361B4; continue 'dispatch;
            }
            0x823361B4 => {
    //   block [0x823361B4..0x823361CC)
	// 823361B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823361B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823361BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823361C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823361C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823361C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823361D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823361D0 size=220
    let mut pc: u32 = 0x823361D0;
    'dispatch: loop {
        match pc {
            0x823361D0 => {
    //   block [0x823361D0..0x82336214)
	// 823361D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823361D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823361D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823361DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823361E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823361E4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 823361E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823361EC: 3BCBBFF0  addi r30, r11, -0x4010
	ctx.r[30].s64 = ctx.r[11].s64 + -16400;
	// 823361F0: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823361F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823361F8: 409A009C  bne cr6, 0x82336294
	if !ctx.cr[6].eq {
	pc = 0x82336294; continue 'dispatch;
	}
	// 823361FC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82336200: 816BB9D8  lwz r11, -0x4628(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 82336204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336208: 419A000C  beq cr6, 0x82336214
	if ctx.cr[6].eq {
	pc = 0x82336214; continue 'dispatch;
	}
	// 8233620C: 386B0100  addi r3, r11, 0x100
	ctx.r[3].s64 = ctx.r[11].s64 + 256;
	// 82336210: 4BE5FCA9  bl 0x82195eb8
	ctx.lr = 0x82336214;
	sub_82195EB8(ctx, base);
	pc = 0x82336214; continue 'dispatch;
            }
            0x82336214 => {
    //   block [0x82336214..0x82336268)
	// 82336214: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82336218: 809F009C  lwz r4, 0x9c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 8233621C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82336220: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 82336224: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 82336228: 7C1E5C2E  lfsx f0, r30, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233622C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82336230: D00BF358  stfs f0, -0xca8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-3240 as u32), tmp.u32 ) };
	// 82336234: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82336238: C00B2294  lfs f0, 0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233623C: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 82336240: D00B64DC  stfs f0, 0x64dc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(25820 as u32), tmp.u32 ) };
	// 82336244: 4BEECF25  bl 0x82223168
	ctx.lr = 0x82336248;
	sub_82223168(ctx, base);
	// 82336248: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8233624C: 80CB0064  lwz r6, 0x64(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82336250: 7C00322C  dcbt 0, r6
	// 82336254: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82336258: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 8233625C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336260: 40990034  ble cr6, 0x82336294
	if !ctx.cr[6].gt {
	pc = 0x82336294; continue 'dispatch;
	}
	// 82336264: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x82336268; continue 'dispatch;
            }
            0x82336268 => {
    //   block [0x82336268..0x82336294)
	// 82336268: 815F009C  lwz r10, 0x9c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 8233626C: 7CA83214  add r5, r8, r6
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 82336270: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82336274: 7C885214  add r4, r8, r10
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82336278: 7C6B4214  add r3, r11, r8
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 8233627C: 48031AB5  bl 0x82367d30
	ctx.lr = 0x82336280;
	sub_82367D30(ctx, base);
	// 82336280: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82336284: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82336288: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 8233628C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82336290: 4198FFD8  blt cr6, 0x82336268
	if ctx.cr[6].lt {
	pc = 0x82336268; continue 'dispatch;
	}
	pc = 0x82336294; continue 'dispatch;
            }
            0x82336294 => {
    //   block [0x82336294..0x823362AC)
	// 82336294: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82336298: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233629C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823362A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823362A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823362A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823362B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823362B0 size=32
    let mut pc: u32 = 0x823362B0;
    'dispatch: loop {
        match pc {
            0x823362B0 => {
    //   block [0x823362B0..0x823362D0)
	// 823362B0: 3963008C  addi r11, r3, 0x8c
	ctx.r[11].s64 = ctx.r[3].s64 + 140;
	// 823362B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823362B8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823362BC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823362C0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823362C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823362C8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 823362CC: 4BDE6D8C  b 0x8211d058
	sub_8211D058(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823362D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823362D8 size=188
    let mut pc: u32 = 0x823362D8;
    'dispatch: loop {
        match pc {
            0x823362D8 => {
    //   block [0x823362D8..0x823362F8)
	// 823362D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823362DC: 481FEDD9  bl 0x825350b4
	ctx.lr = 0x823362E0;
	sub_82535080(ctx, base);
	// 823362E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823362E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823362E8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823362EC: 397D00F8  addi r11, r29, 0xf8
	ctx.r[11].s64 = ctx.r[29].s64 + 248;
	// 823362F0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 823362F4: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	pc = 0x823362F8; continue 'dispatch;
            }
            0x823362F8 => {
    //   block [0x823362F8..0x8233630C)
	// 823362F8: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 823362FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82336300: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82336304: 419A0008  beq cr6, 0x8233630c
	if ctx.cr[6].eq {
	pc = 0x8233630C; continue 'dispatch;
	}
	// 82336308: 4BDE6D51  bl 0x8211d058
	ctx.lr = 0x8233630C;
	sub_8211D058(ctx, base);
	pc = 0x8233630C; continue 'dispatch;
            }
            0x8233630C => {
    //   block [0x8233630C..0x82336324)
	// 8233630C: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 82336310: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82336314: 4098FFE4  bge cr6, 0x823362f8
	if !ctx.cr[6].lt {
	pc = 0x823362F8; continue 'dispatch;
	}
	// 82336318: 3BFD00E0  addi r31, r29, 0xe0
	ctx.r[31].s64 = ctx.r[29].s64 + 224;
	// 8233631C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82336320: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82336324; continue 'dispatch;
            }
            0x82336324 => {
    //   block [0x82336324..0x82336350)
	// 82336324: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82336328: E87F0000  ld r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 8233632C: 48046B8D  bl 0x8237ceb8
	ctx.lr = 0x82336330;
	sub_8237CEB8(ctx, base);
	// 82336330: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 82336334: FB9F0000  std r28, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 82336338: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8233633C: 4098FFE8  bge cr6, 0x82336324
	if !ctx.cr[6].lt {
	pc = 0x82336324; continue 'dispatch;
	}
	// 82336340: 807D00AC  lwz r3, 0xac(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 82336344: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82336348: 419A0008  beq cr6, 0x82336350
	if ctx.cr[6].eq {
	pc = 0x82336350; continue 'dispatch;
	}
	// 8233634C: 4BDE6D0D  bl 0x8211d058
	ctx.lr = 0x82336350;
	sub_8211D058(ctx, base);
	pc = 0x82336350; continue 'dispatch;
            }
            0x82336350 => {
    //   block [0x82336350..0x8233638C)
	// 82336350: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82336354: 576A07FE  clrlwi r10, r27, 0x1f
	ctx.r[10].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	// 82336358: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 8233635C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82336360: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82336364: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82336368: 419A0024  beq cr6, 0x8233638c
	if ctx.cr[6].eq {
	pc = 0x8233638C; continue 'dispatch;
	}
	// 8233636C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82336370: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82336374: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82336378: 409A0014  bne cr6, 0x8233638c
	if !ctx.cr[6].eq {
	pc = 0x8233638C; continue 'dispatch;
	}
	// 8233637C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82336380: 997D0019  stb r11, 0x19(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82336384: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82336388: 997D0025  stb r11, 0x25(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	pc = 0x8233638C; continue 'dispatch;
            }
            0x8233638C => {
    //   block [0x8233638C..0x82336394)
	// 8233638C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82336390: 481FED74  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823363A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823363A0 size=604
    let mut pc: u32 = 0x823363A0;
    'dispatch: loop {
        match pc {
            0x823363A0 => {
    //   block [0x823363A0..0x8233640C)
	// 823363A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823363A4: 481FED0D  bl 0x825350b0
	ctx.lr = 0x823363A8;
	sub_82535080(ctx, base);
	// 823363A8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823363AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823363B0: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 823363B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823363B8: 409A023C  bne cr6, 0x823365f4
	if !ctx.cr[6].eq {
	pc = 0x823365F4; continue 'dispatch;
	}
	// 823363BC: 3FC0829F  lis r30, -0x7d61
	ctx.r[30].s64 = -2103508992;
	// 823363C0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823363C4: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 823363C8: 817EB51C  lwz r11, -0x4ae4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-19172 as u32) ) } as u64;
	// 823363CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823363D0: 409A003C  bne cr6, 0x8233640c
	if !ctx.cr[6].eq {
	pc = 0x8233640C; continue 'dispatch;
	}
	// 823363D4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823363D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823363DC: FB8B0000  std r28, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 823363E0: FB8B0008  std r28, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u64 ) };
	// 823363E4: FB8B0010  std r28, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[28].u64 ) };
	// 823363E8: FB8B0018  std r28, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[28].u64 ) };
	// 823363EC: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 823363F0: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 823363F4: 396B2380  addi r11, r11, 0x2380
	ctx.r[11].s64 = ctx.r[11].s64 + 9088;
	// 823363F8: C00B002C  lfs f0, 0x2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823363FC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82336400: 48100991  bl 0x82436d90
	ctx.lr = 0x82336404;
	sub_82436D90(ctx, base);
	// 82336404: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82336408: 917EB51C  stw r11, -0x4ae4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-19172 as u32), ctx.r[11].u32 ) };
	pc = 0x8233640C; continue 'dispatch;
            }
            0x8233640C => {
    //   block [0x8233640C..0x82336430)
	// 8233640C: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82336410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336414: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 82336418: 3B6BDBE0  addi r27, r11, -0x2420
	ctx.r[27].s64 = ctx.r[11].s64 + -9248;
	// 8233641C: 409A0098  bne cr6, 0x823364b4
	if !ctx.cr[6].eq {
	pc = 0x823364B4; continue 'dispatch;
	}
	// 82336420: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82336424: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82336428: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 8233642C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82336430; continue 'dispatch;
            }
            0x82336430 => {
    //   block [0x82336430..0x823364B4)
	// 82336430: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82336434: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82336438: 4200FFF8  bdnz 0x82336430
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82336430; continue 'dispatch;
	}
	// 8233643C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82336440: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82336444: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82336448: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 8233644C: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 82336450: 816BBD10  lwz r11, -0x42f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17136 as u32) ) } as u64;
	// 82336454: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82336458: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 8233645C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82336460: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82336464: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82336468: 3D600180  lis r11, 0x180
	ctx.r[11].s64 = 25165824;
	// 8233646C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82336470: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82336474: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82336478: 480FF641  bl 0x82435ab8
	ctx.lr = 0x8233647C;
	sub_82435AB8(ctx, base);
	// 8233647C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82336480: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82336484: 3BDF00A8  addi r30, r31, 0xa8
	ctx.r[30].s64 = ctx.r[31].s64 + 168;
	// 82336488: 38CBDF04  addi r6, r11, -0x20fc
	ctx.r[6].s64 = ctx.r[11].s64 + -8444;
	// 8233648C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82336490: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82336494: 90A1006C  stw r5, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[5].u32 ) };
	// 82336498: 4BEBEE51  bl 0x821f52e8
	ctx.lr = 0x8233649C;
	sub_821F52E8(ctx, base);
	// 8233649C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823364A0: 4BEF6F49  bl 0x8222d3e8
	ctx.lr = 0x823364A4;
	sub_8222D3E8(ctx, base);
	// 823364A4: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 823364A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823364AC: 480FFF05  bl 0x824363b0
	ctx.lr = 0x823364B0;
	sub_824363B0(ctx, base);
	// 823364B0: 907F00B4  stw r3, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	pc = 0x823364B4; continue 'dispatch;
            }
            0x823364B4 => {
    //   block [0x823364B4..0x823364E4)
	// 823364B4: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 823364B8: 391F00B8  addi r8, r31, 0xb8
	ctx.r[8].s64 = ctx.r[31].s64 + 184;
	// 823364BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823364C0: 409A0024  bne cr6, 0x823364e4
	if !ctx.cr[6].eq {
	pc = 0x823364E4; continue 'dispatch;
	}
	// 823364C4: 395F00D0  addi r10, r31, 0xd0
	ctx.r[10].s64 = ctx.r[31].s64 + 208;
	// 823364C8: 80FF0094  lwz r7, 0x94(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 823364CC: 393F00C0  addi r9, r31, 0xc0
	ctx.r[9].s64 = ctx.r[31].s64 + 192;
	// 823364D0: 80DF008C  lwz r6, 0x8c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 823364D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823364D8: 80BF0088  lwz r5, 0x88(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 823364DC: 809F0084  lwz r4, 0x84(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 823364E0: 48000239  bl 0x82336718
	ctx.lr = 0x823364E4;
	sub_82336718(ctx, base);
	pc = 0x823364E4; continue 'dispatch;
            }
            0x823364E4 => {
    //   block [0x823364E4..0x82336514)
	// 823364E4: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 823364E8: 391F00BC  addi r8, r31, 0xbc
	ctx.r[8].s64 = ctx.r[31].s64 + 188;
	// 823364EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823364F0: 409A0024  bne cr6, 0x82336514
	if !ctx.cr[6].eq {
	pc = 0x82336514; continue 'dispatch;
	}
	// 823364F4: 395F00D8  addi r10, r31, 0xd8
	ctx.r[10].s64 = ctx.r[31].s64 + 216;
	// 823364F8: 80FF0098  lwz r7, 0x98(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 823364FC: 393F00C8  addi r9, r31, 0xc8
	ctx.r[9].s64 = ctx.r[31].s64 + 200;
	// 82336500: 80DF0090  lwz r6, 0x90(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82336504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82336508: 80BF0088  lwz r5, 0x88(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 8233650C: 809F0084  lwz r4, 0x84(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82336510: 48000209  bl 0x82336718
	ctx.lr = 0x82336514;
	sub_82336718(ctx, base);
	pc = 0x82336514; continue 'dispatch;
            }
            0x82336514 => {
    //   block [0x82336514..0x8233653C)
	// 82336514: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82336518: 389F00E0  addi r4, r31, 0xe0
	ctx.r[4].s64 = ctx.r[31].s64 + 224;
	// 8233651C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82336520: 396B00FF  addi r11, r11, 0xff
	ctx.r[11].s64 = ctx.r[11].s64 + 255;
	// 82336524: 557D002E  rlwinm r29, r11, 0, 0, 0x17
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82336528: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233652C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336530: 409A000C  bne cr6, 0x8233653c
	if !ctx.cr[6].eq {
	pc = 0x8233653C; continue 'dispatch;
	}
	// 82336534: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82336538: 4800002C  b 0x82336564
	pc = 0x82336564; continue 'dispatch;
            }
            0x8233653C => {
    //   block [0x8233653C..0x82336554)
	// 8233653C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82336540: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82336544: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82336548: 419A000C  beq cr6, 0x82336554
	if ctx.cr[6].eq {
	pc = 0x82336554; continue 'dispatch;
	}
	// 8233654C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82336550: 48000014  b 0x82336564
	pc = 0x82336564; continue 'dispatch;
            }
            0x82336554 => {
    //   block [0x82336554..0x82336564)
	// 82336554: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82336558: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8233655C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82336560: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x82336564; continue 'dispatch;
            }
            0x82336564 => {
    //   block [0x82336564..0x8233658C)
	// 82336564: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82336568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233656C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82336570: 3BCBDF2C  addi r30, r11, -0x20d4
	ctx.r[30].s64 = ctx.r[11].s64 + -8404;
	// 82336574: 409A0018  bne cr6, 0x8233658c
	if !ctx.cr[6].eq {
	pc = 0x8233658C; continue 'dispatch;
	}
	// 82336578: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 8233657C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82336580: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82336584: 7CABE9D6  mullw r5, r11, r29
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * ctx.r[29].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82336588: 4BEBED61  bl 0x821f52e8
	ctx.lr = 0x8233658C;
	sub_821F52E8(ctx, base);
	pc = 0x8233658C; continue 'dispatch;
            }
            0x8233658C => {
    //   block [0x8233658C..0x823365A4)
	// 8233658C: 389F00EC  addi r4, r31, 0xec
	ctx.r[4].s64 = ctx.r[31].s64 + 236;
	// 82336590: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82336594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336598: 409A000C  bne cr6, 0x823365a4
	if !ctx.cr[6].eq {
	pc = 0x823365A4; continue 'dispatch;
	}
	// 8233659C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 823365A0: 4800002C  b 0x823365cc
	pc = 0x823365CC; continue 'dispatch;
            }
            0x823365A4 => {
    //   block [0x823365A4..0x823365BC)
	// 823365A4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823365A8: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 823365AC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823365B0: 419A000C  beq cr6, 0x823365bc
	if ctx.cr[6].eq {
	pc = 0x823365BC; continue 'dispatch;
	}
	// 823365B4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 823365B8: 48000014  b 0x823365cc
	pc = 0x823365CC; continue 'dispatch;
            }
            0x823365BC => {
    //   block [0x823365BC..0x823365CC)
	// 823365BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823365C0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823365C4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823365C8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x823365CC; continue 'dispatch;
            }
            0x823365CC => {
    //   block [0x823365CC..0x823365EC)
	// 823365CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823365D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823365D4: 409A0018  bne cr6, 0x823365ec
	if !ctx.cr[6].eq {
	pc = 0x823365EC; continue 'dispatch;
	}
	// 823365D8: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 823365DC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 823365E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823365E4: 7CABE9D6  mullw r5, r11, r29
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * ctx.r[29].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 823365E8: 4BEBED01  bl 0x821f52e8
	ctx.lr = 0x823365EC;
	sub_821F52E8(ctx, base);
	pc = 0x823365EC; continue 'dispatch;
            }
            0x823365EC => {
    //   block [0x823365EC..0x823365F4)
	// 823365EC: 939F00F8  stw r28, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[28].u32 ) };
	// 823365F0: 935F009C  stw r26, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[26].u32 ) };
	pc = 0x823365F4; continue 'dispatch;
            }
            0x823365F4 => {
    //   block [0x823365F4..0x823365FC)
	// 823365F4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 823365F8: 481FEB08  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82336600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82336600 size=276
    let mut pc: u32 = 0x82336600;
    'dispatch: loop {
        match pc {
            0x82336600 => {
    //   block [0x82336600..0x82336658)
	// 82336600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82336604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82336608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233660C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82336610: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82336614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82336618: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 8233661C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336620: 419A00DC  beq cr6, 0x823366fc
	if ctx.cr[6].eq {
	pc = 0x823366FC; continue 'dispatch;
	}
	// 82336624: 807F00B4  lwz r3, 0xb4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82336628: 480FC8B1  bl 0x82432ed8
	ctx.lr = 0x8233662C;
	sub_82432ED8(ctx, base);
	// 8233662C: 807F00B4  lwz r3, 0xb4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82336630: 480FFD79  bl 0x824363a8
	ctx.lr = 0x82336634;
	sub_824363A8(ctx, base);
	// 82336634: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82336638: 397F00A8  addi r11, r31, 0xa8
	ctx.r[11].s64 = ctx.r[31].s64 + 168;
	// 8233663C: 93DF00B4  stw r30, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 82336640: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82336644: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82336648: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8233664C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82336650: 419A0008  beq cr6, 0x82336658
	if ctx.cr[6].eq {
	pc = 0x82336658; continue 'dispatch;
	}
	// 82336654: 4BDE6A05  bl 0x8211d058
	ctx.lr = 0x82336658;
	sub_8211D058(ctx, base);
	pc = 0x82336658; continue 'dispatch;
            }
            0x82336658 => {
    //   block [0x82336658..0x82336674)
	// 82336658: 397F00E0  addi r11, r31, 0xe0
	ctx.r[11].s64 = ctx.r[31].s64 + 224;
	// 8233665C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82336660: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82336664: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82336668: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233666C: 419A0008  beq cr6, 0x82336674
	if ctx.cr[6].eq {
	pc = 0x82336674; continue 'dispatch;
	}
	// 82336670: 4BDE69E9  bl 0x8211d058
	ctx.lr = 0x82336674;
	sub_8211D058(ctx, base);
	pc = 0x82336674; continue 'dispatch;
            }
            0x82336674 => {
    //   block [0x82336674..0x82336688)
	// 82336674: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82336678: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233667C: 419A000C  beq cr6, 0x82336688
	if ctx.cr[6].eq {
	pc = 0x82336688; continue 'dispatch;
	}
	// 82336680: 48064A21  bl 0x8239b0a0
	ctx.lr = 0x82336684;
	sub_8239B0A0(ctx, base);
	// 82336684: 93DF00B8  stw r30, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[30].u32 ) };
	pc = 0x82336688; continue 'dispatch;
            }
            0x82336688 => {
    //   block [0x82336688..0x8233669C)
	// 82336688: E87F00C0  ld r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	// 8233668C: 2B230000  cmpldi cr6, r3, 0
	ctx.cr[6].compare_u64(ctx.r[3].u64, 0, &mut ctx.xer);
	// 82336690: 419A000C  beq cr6, 0x8233669c
	if ctx.cr[6].eq {
	pc = 0x8233669C; continue 'dispatch;
	}
	// 82336694: 48046825  bl 0x8237ceb8
	ctx.lr = 0x82336698;
	sub_8237CEB8(ctx, base);
	// 82336698: FBDF00C0  std r30, 0xc0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	pc = 0x8233669C; continue 'dispatch;
            }
            0x8233669C => {
    //   block [0x8233669C..0x823366C4)
	// 8233669C: E87F00D0  ld r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	// 823366A0: 48046819  bl 0x8237ceb8
	ctx.lr = 0x823366A4;
	sub_8237CEB8(ctx, base);
	// 823366A4: 397F00EC  addi r11, r31, 0xec
	ctx.r[11].s64 = ctx.r[31].s64 + 236;
	// 823366A8: FBDF00D0  std r30, 0xd0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[30].u64 ) };
	// 823366AC: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823366B0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823366B4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823366B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823366BC: 419A0008  beq cr6, 0x823366c4
	if ctx.cr[6].eq {
	pc = 0x823366C4; continue 'dispatch;
	}
	// 823366C0: 4BDE6999  bl 0x8211d058
	ctx.lr = 0x823366C4;
	sub_8211D058(ctx, base);
	pc = 0x823366C4; continue 'dispatch;
            }
            0x823366C4 => {
    //   block [0x823366C4..0x823366D8)
	// 823366C4: 807F00BC  lwz r3, 0xbc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 823366C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823366CC: 419A000C  beq cr6, 0x823366d8
	if ctx.cr[6].eq {
	pc = 0x823366D8; continue 'dispatch;
	}
	// 823366D0: 480649D1  bl 0x8239b0a0
	ctx.lr = 0x823366D4;
	sub_8239B0A0(ctx, base);
	// 823366D4: 93DF00BC  stw r30, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[30].u32 ) };
	pc = 0x823366D8; continue 'dispatch;
            }
            0x823366D8 => {
    //   block [0x823366D8..0x823366EC)
	// 823366D8: E87F00C8  ld r3, 0xc8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	// 823366DC: 2B230000  cmpldi cr6, r3, 0
	ctx.cr[6].compare_u64(ctx.r[3].u64, 0, &mut ctx.xer);
	// 823366E0: 419A000C  beq cr6, 0x823366ec
	if ctx.cr[6].eq {
	pc = 0x823366EC; continue 'dispatch;
	}
	// 823366E4: 480467D5  bl 0x8237ceb8
	ctx.lr = 0x823366E8;
	sub_8237CEB8(ctx, base);
	// 823366E8: FBDF00C8  std r30, 0xc8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[30].u64 ) };
	pc = 0x823366EC; continue 'dispatch;
            }
            0x823366EC => {
    //   block [0x823366EC..0x823366FC)
	// 823366EC: E87F00D8  ld r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	// 823366F0: 480467C9  bl 0x8237ceb8
	ctx.lr = 0x823366F4;
	sub_8237CEB8(ctx, base);
	// 823366F4: FBDF00D8  std r30, 0xd8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[30].u64 ) };
	// 823366F8: 93DF009C  stw r30, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	pc = 0x823366FC; continue 'dispatch;
            }
            0x823366FC => {
    //   block [0x823366FC..0x82336714)
	// 823366FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82336700: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82336704: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82336708: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233670C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82336710: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82336718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82336718 size=272
    let mut pc: u32 = 0x82336718;
    'dispatch: loop {
        match pc {
            0x82336718 => {
    //   block [0x82336718..0x82336758)
	// 82336718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233671C: 481FE985  bl 0x825350a0
	ctx.lr = 0x82336720;
	sub_82535080(ctx, base);
	// 82336720: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82336724: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 82336728: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8233672C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82336730: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82336734: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 82336738: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233673C: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 82336740: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 82336744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336748: 419A0010  beq cr6, 0x82336758
	if ctx.cr[6].eq {
	pc = 0x82336758; continue 'dispatch;
	}
	// 8233674C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82336750: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82336754: 481FE99C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82336758 => {
    //   block [0x82336758..0x823367A4)
	// 82336758: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8233675C: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 82336760: 396B00FF  addi r11, r11, 0xff
	ctx.r[11].s64 = ctx.r[11].s64 + 255;
	// 82336764: 3BCA2200  addi r30, r10, 0x2200
	ctx.r[30].s64 = ctx.r[10].s64 + 8704;
	// 82336768: 556B002E  rlwinm r11, r11, 0, 0, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8233676C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82336770: 7D6BD1D6  mullw r11, r11, r26
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[26].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82336774: 3B8B1000  addi r28, r11, 0x1000
	ctx.r[28].s64 = ctx.r[11].s64 + 4096;
	// 82336778: 483D6AE5  bl 0x8270d25c
	ctx.lr = 0x8233677C;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 8233677C: 38A01000  li r5, 0x1000
	ctx.r[5].s64 = 4096;
	// 82336780: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82336784: 387E0024  addi r3, r30, 0x24
	ctx.r[3].s64 = ctx.r[30].s64 + 36;
	// 82336788: 48074599  bl 0x823aad20
	ctx.lr = 0x8233678C;
	sub_823AAD20(ctx, base);
	// 8233678C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82336790: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82336794: 483D6AD9  bl 0x8270d26c
	ctx.lr = 0x82336798;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82336798: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8233679C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823367A0: 409A0010  bne cr6, 0x823367b0
	if !ctx.cr[6].eq {
	pc = 0x823367B0; continue 'dispatch;
	}
	pc = 0x823367A4; continue 'dispatch;
            }
            0x823367A4 => {
    //   block [0x823367A4..0x823367B0)
	// 823367A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823367A8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823367AC: 481FE944  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x823367B0 => {
    //   block [0x823367B0..0x82336828)
	// 823367B0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 823367B4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 823367B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823367BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823367C0: 48048D99  bl 0x8237f558
	ctx.lr = 0x823367C4;
	sub_8237F558(ctx, base);
	// 823367C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823367C8: 419AFFDC  beq cr6, 0x823367a4
	if ctx.cr[6].eq {
	pc = 0x823367A4; continue 'dispatch;
	}
	// 823367CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823367D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823367D4: 394B105F  addi r10, r11, 0x105f
	ctx.r[10].s64 = ctx.r[11].s64 + 4191;
	// 823367D8: 55430026  rlwinm r3, r10, 0, 0, 0x13
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823367DC: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 823367E0: 7CABE214  add r5, r11, r28
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 823367E4: 481FE9ED  bl 0x825351d0
	ctx.lr = 0x823367E8;
	sub_825351D0(ctx, base);
	// 823367E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823367EC: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 823367F0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823367F4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 823367F8: 480463A1  bl 0x8237cb98
	ctx.lr = 0x823367FC;
	sub_8237CB98(ctx, base);
	// 823367FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82336800: 2B240000  cmpldi cr6, r4, 0
	ctx.cr[6].compare_u64(ctx.r[4].u64, 0, &mut ctx.xer);
	// 82336804: F8970000  std r4, 0(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 82336808: 419AFF9C  beq cr6, 0x823367a4
	if ctx.cr[6].eq {
	pc = 0x823367A4; continue 'dispatch;
	}
	// 8233680C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82336810: 4BED3D69  bl 0x8220a578
	ctx.lr = 0x82336814;
	sub_8220A578(ctx, base);
	// 82336814: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82336818: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8233681C: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82336820: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82336824: 481FE8CC  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82336828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82336828 size=236
    let mut pc: u32 = 0x82336828;
    'dispatch: loop {
        match pc {
            0x82336828 => {
    //   block [0x82336828..0x823368A4)
	// 82336828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233682C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82336830: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82336834: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82336838: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233683C: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82336840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336844: 419A00BC  beq cr6, 0x82336900
	if ctx.cr[6].eq {
	pc = 0x82336900; continue 'dispatch;
	}
	// 82336848: 807F00B4  lwz r3, 0xb4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 8233684C: 48100395  bl 0x82436be0
	ctx.lr = 0x82336850;
	sub_82436BE0(ctx, base);
	// 82336850: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82336854: 807F00B4  lwz r3, 0xb4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82336858: 480FE279  bl 0x82434ad0
	ctx.lr = 0x8233685C;
	sub_82434AD0(ctx, base);
	// 8233685C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82336860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336864: 419A0050  beq cr6, 0x823368b4
	if ctx.cr[6].eq {
	pc = 0x823368B4; continue 'dispatch;
	}
	// 82336868: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 8233686C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82336870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82336874: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82336878: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 8233687C: 4800009D  bl 0x82336918
	ctx.lr = 0x82336880;
	sub_82336918(ctx, base);
	// 82336880: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82336884: 807F00B4  lwz r3, 0xb4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82336888: 409A001C  bne cr6, 0x823368a4
	if !ctx.cr[6].eq {
	pc = 0x823368A4; continue 'dispatch;
	}
	// 8233688C: 480FD955  bl 0x824341e0
	ctx.lr = 0x82336890;
	sub_824341E0(ctx, base);
	// 82336890: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82336894: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82336898: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233689C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823368A0: 4E800020  blr
	return;
            }
            0x823368A4 => {
    //   block [0x823368A4..0x823368B4)
	// 823368A4: 480FD93D  bl 0x824341e0
	ctx.lr = 0x823368A8;
	sub_824341E0(ctx, base);
	// 823368A8: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 823368AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823368B0: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	pc = 0x823368B4; continue 'dispatch;
            }
            0x823368B4 => {
    //   block [0x823368B4..0x823368D4)
	// 823368B4: 807F00B4  lwz r3, 0xb4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 823368B8: 480FCBC9  bl 0x82433480
	ctx.lr = 0x823368BC;
	sub_82433480(ctx, base);
	// 823368BC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 823368C0: 419A0014  beq cr6, 0x823368d4
	if ctx.cr[6].eq {
	pc = 0x823368D4; continue 'dispatch;
	}
	// 823368C4: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 823368C8: 419A000C  beq cr6, 0x823368d4
	if ctx.cr[6].eq {
	pc = 0x823368D4; continue 'dispatch;
	}
	// 823368CC: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 823368D0: 409A0030  bne cr6, 0x82336900
	if !ctx.cr[6].eq {
	pc = 0x82336900; continue 'dispatch;
	}
	pc = 0x823368D4; continue 'dispatch;
            }
            0x823368D4 => {
    //   block [0x823368D4..0x82336900)
	// 823368D4: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 823368D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823368DC: 409A0024  bne cr6, 0x82336900
	if !ctx.cr[6].eq {
	pc = 0x82336900; continue 'dispatch;
	}
	// 823368E0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 823368E4: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 823368E8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 823368EC: 409A0014  bne cr6, 0x82336900
	if !ctx.cr[6].eq {
	pc = 0x82336900; continue 'dispatch;
	}
	// 823368F0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 823368F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823368F8: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 823368FC: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x82336900; continue 'dispatch;
            }
            0x82336900 => {
    //   block [0x82336900..0x82336914)
	// 82336900: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82336904: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82336908: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233690C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82336910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82336918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82336918 size=224
    let mut pc: u32 = 0x82336918;
    'dispatch: loop {
        match pc {
            0x82336918 => {
    //   block [0x82336918..0x8233695C)
	// 82336918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233691C: 481FE799  bl 0x825350b4
	ctx.lr = 0x82336920;
	sub_82535080(ctx, base);
	// 82336920: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82336924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82336928: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8233692C: 815F00F8  lwz r10, 0xf8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82336930: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82336934: 394A002E  addi r10, r10, 0x2e
	ctx.r[10].s64 = ctx.r[10].s64 + 46;
	// 82336938: 813F0088  lwz r9, 0x88(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 8233693C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82336940: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82336944: 396B00FF  addi r11, r11, 0xff
	ctx.r[11].s64 = ctx.r[11].s64 + 255;
	// 82336948: 5564002E  rlwinm r4, r11, 0, 0, 0x17
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8233694C: 7D6AF82E  lwzx r11, r10, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82336950: 7F8921D6  mullw r28, r9, r4
	ctx.r[28].s32 = ((ctx.r[9].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 82336954: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336958: 409A0010  bne cr6, 0x82336968
	if !ctx.cr[6].eq {
	pc = 0x82336968; continue 'dispatch;
	}
	pc = 0x8233695C; continue 'dispatch;
            }
            0x8233695C => {
    //   block [0x8233695C..0x82336968)
	// 8233695C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82336960: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82336964: 481FE7A0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x82336968 => {
    //   block [0x82336968..0x823369DC)
	// 82336968: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 8233696C: 392B002E  addi r9, r11, 0x2e
	ctx.r[9].s64 = ctx.r[11].s64 + 46;
	// 82336970: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82336974: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82336978: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8233697C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82336980: 7D49F82E  lwzx r10, r9, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82336984: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82336988: 394A105F  addi r10, r10, 0x105f
	ctx.r[10].s64 = ctx.r[10].s64 + 4191;
	// 8233698C: 386B00E0  addi r3, r11, 0xe0
	ctx.r[3].s64 = ctx.r[11].s64 + 224;
	// 82336990: 555D0026  rlwinm r29, r10, 0, 0, 0x13
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82336994: 4BEF6A55  bl 0x8222d3e8
	ctx.lr = 0x82336998;
	sub_8222D3E8(ctx, base);
	// 82336998: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233699C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823369A0: 419AFFBC  beq cr6, 0x8233695c
	if ctx.cr[6].eq {
	pc = 0x8233695C; continue 'dispatch;
	}
	// 823369A4: 80BB0010  lwz r5, 0x10(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 823369A8: 807F00B4  lwz r3, 0xb4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 823369AC: 480FBA5D  bl 0x82432408
	ctx.lr = 0x823369B0;
	sub_82432408(ctx, base);
	// 823369B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823369B4: 807F00B4  lwz r3, 0xb4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 823369B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823369BC: 481005C5  bl 0x82436f80
	ctx.lr = 0x823369C0;
	sub_82436F80(ctx, base);
	// 823369C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823369C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823369C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823369CC: 481FE185  bl 0x82534b50
	ctx.lr = 0x823369D0;
	sub_82534B50(ctx, base);
	// 823369D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823369D4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823369D8: 419A0014  beq cr6, 0x823369ec
	if ctx.cr[6].eq {
	pc = 0x823369EC; continue 'dispatch;
	}
	pc = 0x823369DC; continue 'dispatch;
            }
            0x823369DC => {
    //   block [0x823369DC..0x823369EC)
	// 823369DC: 7C0BE86C  dcbst r11, r29
	// 823369E0: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 823369E4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 823369E8: 4198FFF4  blt cr6, 0x823369dc
	if ctx.cr[6].lt {
	pc = 0x823369DC; continue 'dispatch;
	}
	pc = 0x823369EC; continue 'dispatch;
            }
            0x823369EC => {
    //   block [0x823369EC..0x823369F8)
	// 823369EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823369F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823369F4: 481FE710  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823369F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823369F8 size=184
    let mut pc: u32 = 0x823369F8;
    'dispatch: loop {
        match pc {
            0x823369F8 => {
    //   block [0x823369F8..0x82336A3C)
	// 823369F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823369FC: 481FE6B5  bl 0x825350b0
	ctx.lr = 0x82336A00;
	sub_82535080(ctx, base);
	// 82336A00: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82336A04: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82336A08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82336A0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82336A10: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82336A14: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82336A18: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82336A1C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82336A20: 4BED3D31  bl 0x8220a750
	ctx.lr = 0x82336A24;
	sub_8220A750(ctx, base);
	// 82336A24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82336A28: 419A0014  beq cr6, 0x82336a3c
	if ctx.cr[6].eq {
	pc = 0x82336A3C; continue 'dispatch;
	}
	// 82336A2C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82336A30: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82336A34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82336A38: 4BED3E71  bl 0x8220a8a8
	ctx.lr = 0x82336A3C;
	sub_8220A8A8(ctx, base);
	pc = 0x82336A3C; continue 'dispatch;
            }
            0x82336A3C => {
    //   block [0x82336A3C..0x82336A54)
	// 82336A3C: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82336A40: 419A0014  beq cr6, 0x82336a54
	if ctx.cr[6].eq {
	pc = 0x82336A54; continue 'dispatch;
	}
	// 82336A44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82336A48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82336A4C: 4BED4455  bl 0x8220aea0
	ctx.lr = 0x82336A50;
	sub_8220AEA0(ctx, base);
	// 82336A50: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	pc = 0x82336A54; continue 'dispatch;
            }
            0x82336A54 => {
    //   block [0x82336A54..0x82336A90)
	// 82336A54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82336A58: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82336A5C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82336A60: 419A0030  beq cr6, 0x82336a90
	if ctx.cr[6].eq {
	pc = 0x82336A90; continue 'dispatch;
	}
	// 82336A64: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82336A68: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82336A6C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82336A70: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82336A74: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82336A78: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82336A7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82336A80: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 82336A84: 4E800421  bctrl
	ctx.lr = 0x82336A88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82336A88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82336A8C: 419A001C  beq cr6, 0x82336aa8
	if ctx.cr[6].eq {
	pc = 0x82336AA8; continue 'dispatch;
	}
            }
            0x82336A90 => {
    //   block [0x82336A90..0x82336AA8)
	// 82336A90: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82336A94: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82336A98: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82336A9C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82336AA0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82336AA4: 48035665  bl 0x8236c108
	ctx.lr = 0x82336AA8;
	sub_8236C108(ctx, base);
	pc = 0x82336AA8; continue 'dispatch;
            }
            0x82336AA8 => {
    //   block [0x82336AA8..0x82336AB0)
	// 82336AA8: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82336AAC: 481FE654  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82336AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82336AB0 size=384
    let mut pc: u32 = 0x82336AB0;
    'dispatch: loop {
        match pc {
            0x82336AB0 => {
    //   block [0x82336AB0..0x82336B1C)
	// 82336AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82336AB4: 481FE605  bl 0x825350b8
	ctx.lr = 0x82336AB8;
	sub_82535080(ctx, base);
	// 82336AB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82336ABC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82336AC0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82336AC4: 2B1D0004  cmplwi cr6, r29, 4
	ctx.cr[6].compare_u32(ctx.r[29].u32, 4 as u32, &mut ctx.xer);
	// 82336AC8: 4098015C  bge cr6, 0x82336c24
	if !ctx.cr[6].lt {
	pc = 0x82336C24; continue 'dispatch;
	}
	// 82336ACC: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 82336AD0: 57AA3032  slwi r10, r29, 6
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82336AD4: 396BB520  addi r11, r11, -0x4ae0
	ctx.r[11].s64 = ctx.r[11].s64 + -19168;
	// 82336AD8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82336ADC: 7D6BE0AE  lbzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82336AE0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82336AE4: 40980140  bge cr6, 0x82336c24
	if !ctx.cr[6].lt {
	pc = 0x82336C24; continue 'dispatch;
	}
	// 82336AE8: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 82336AEC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82336AF0: 3BEB4AD8  addi r31, r11, 0x4ad8
	ctx.r[31].s64 = ctx.r[11].s64 + 19160;
	// 82336AF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82336AF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336AFC: 419A0020  beq cr6, 0x82336b1c
	if ctx.cr[6].eq {
	pc = 0x82336B1C; continue 'dispatch;
	}
	// 82336B00: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82336B04: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82336B08: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82336B0C: 409A0010  bne cr6, 0x82336b1c
	if !ctx.cr[6].eq {
	pc = 0x82336B1C; continue 'dispatch;
	}
	// 82336B10: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82336B14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82336B18: 409A0070  bne cr6, 0x82336b88
	if !ctx.cr[6].eq {
	pc = 0x82336B88; continue 'dispatch;
	}
	pc = 0x82336B1C; continue 'dispatch;
            }
            0x82336B1C => {
    //   block [0x82336B1C..0x82336B48)
	// 82336B1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82336B20: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 82336B24: 38EBDF58  addi r7, r11, -0x20a8
	ctx.r[7].s64 = ctx.r[11].s64 + -8360;
	// 82336B28: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82336B2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82336B30: 38600300  li r3, 0x300
	ctx.r[3].s64 = 768;
	// 82336B34: 4803395D  bl 0x8236a490
	ctx.lr = 0x82336B38;
	sub_8236A490(ctx, base);
	// 82336B38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82336B3C: 419A000C  beq cr6, 0x82336b48
	if ctx.cr[6].eq {
	pc = 0x82336B48; continue 'dispatch;
	}
	// 82336B40: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82336B44: 48000008  b 0x82336b4c
	pc = 0x82336B4C; continue 'dispatch;
            }
            0x82336B48 => {
    //   block [0x82336B48..0x82336B4C)
	// 82336B48: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82336B4C; continue 'dispatch;
            }
            0x82336B4C => {
    //   block [0x82336B4C..0x82336B84)
	// 82336B4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82336B50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82336B54: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82336B58: 419A002C  beq cr6, 0x82336b84
	if ctx.cr[6].eq {
	pc = 0x82336B84; continue 'dispatch;
	}
	// 82336B5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82336B60: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82336B64: 396BDF64  addi r11, r11, -0x209c
	ctx.r[11].s64 = ctx.r[11].s64 + -8348;
	// 82336B68: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82336B6C: 93C30084  stw r30, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82336B70: 93C30080  stw r30, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82336B74: 93A300C8  stw r29, 0xc8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), ctx.r[29].u32 ) };
	// 82336B78: 93C300CC  stw r30, 0xcc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	// 82336B7C: 93C300D0  stw r30, 0xd0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[30].u32 ) };
	// 82336B80: 48000008  b 0x82336b88
	pc = 0x82336B88; continue 'dispatch;
            }
            0x82336B84 => {
    //   block [0x82336B84..0x82336B88)
	// 82336B84: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x82336B88; continue 'dispatch;
            }
            0x82336B88 => {
    //   block [0x82336B88..0x82336BA4)
	// 82336B88: 39690080  addi r11, r9, 0x80
	ctx.r[11].s64 = ctx.r[9].s64 + 128;
	// 82336B8C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82336B90: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82336B94: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82336B98: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82336B9C: 40980008  bge cr6, 0x82336ba4
	if !ctx.cr[6].lt {
	pc = 0x82336BA4; continue 'dispatch;
	}
	// 82336BA0: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	pc = 0x82336BA4; continue 'dispatch;
            }
            0x82336BA4 => {
    //   block [0x82336BA4..0x82336BB8)
	// 82336BA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82336BA8: 2F0A0040  cmpwi cr6, r10, 0x40
	ctx.cr[6].compare_i32(ctx.r[10].s32, 64, &mut ctx.xer);
	// 82336BAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82336BB0: 40980008  bge cr6, 0x82336bb8
	if !ctx.cr[6].lt {
	pc = 0x82336BB8; continue 'dispatch;
	}
	// 82336BB4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x82336BB8; continue 'dispatch;
            }
            0x82336BB8 => {
    //   block [0x82336BB8..0x82336BC4)
	// 82336BB8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82336BBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82336BC0: 419A0010  beq cr6, 0x82336bd0
	if ctx.cr[6].eq {
	pc = 0x82336BD0; continue 'dispatch;
	}
	pc = 0x82336BC4; continue 'dispatch;
            }
            0x82336BC4 => {
    //   block [0x82336BC4..0x82336BD0)
	// 82336BC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82336BC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82336BCC: 481FE53C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x82336BD0 => {
    //   block [0x82336BD0..0x82336BF8)
	// 82336BD0: 814900C8  lwz r10, 0xc8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(200 as u32) ) } as u64;
	// 82336BD4: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82336BD8: 409AFFEC  bne cr6, 0x82336bc4
	if !ctx.cr[6].eq {
	pc = 0x82336BC4; continue 'dispatch;
	}
	// 82336BDC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82336BE0: 5788063E  clrlwi r8, r28, 0x18
	ctx.r[8].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82336BE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82336BE8: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82336BEC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82336BF0: 40980008  bge cr6, 0x82336bf8
	if !ctx.cr[6].lt {
	pc = 0x82336BF8; continue 'dispatch;
	}
	// 82336BF4: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	pc = 0x82336BF8; continue 'dispatch;
            }
            0x82336BF8 => {
    //   block [0x82336BF8..0x82336C24)
	// 82336BF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82336BFC: 2F0A0040  cmpwi cr6, r10, 0x40
	ctx.cr[6].compare_i32(ctx.r[10].s32, 64, &mut ctx.xer);
	// 82336C00: 40980024  bge cr6, 0x82336c24
	if !ctx.cr[6].lt {
	pc = 0x82336C24; continue 'dispatch;
	}
	// 82336C04: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82336C08: 990A0008  stb r8, 8(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u8 ) };
	// 82336C0C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82336C10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82336C14: 2F0A0040  cmpwi cr6, r10, 0x40
	ctx.cr[6].compare_i32(ctx.r[10].s32, 64, &mut ctx.xer);
	// 82336C18: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82336C1C: 41980008  blt cr6, 0x82336c24
	if ctx.cr[6].lt {
	pc = 0x82336C24; continue 'dispatch;
	}
	// 82336C20: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x82336C24; continue 'dispatch;
            }
            0x82336C24 => {
    //   block [0x82336C24..0x82336C30)
	// 82336C24: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82336C28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82336C2C: 481FE4DC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82336C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82336C30 size=1108
    let mut pc: u32 = 0x82336C30;
    'dispatch: loop {
        match pc {
            0x82336C30 => {
    //   block [0x82336C30..0x82336C7C)
	// 82336C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82336C34: 481FE489  bl 0x825350bc
	ctx.lr = 0x82336C38;
	sub_82535080(ctx, base);
	// 82336C38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82336C3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82336C40: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82336C44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82336C48: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82336C4C: 41990274  bgt cr6, 0x82336ec0
	if ctx.cr[6].gt {
	pc = 0x82336EC0; continue 'dispatch;
	}
	// 82336C50: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 82336C54: 398C6C68  addi r12, r12, 0x6c68
	ctx.r[12].s64 = ctx.r[12].s64 + 27752;
	// 82336C58: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82336C5C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82336C60: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82336C64: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x82336C7C; continue 'dispatch;
		},
		1 => {
	pc = 0x82336D20; continue 'dispatch;
		},
		2 => {
	pc = 0x82336D6C; continue 'dispatch;
		},
		3 => {
	pc = 0x82336EA4; continue 'dispatch;
		},
		4 => {
	pc = 0x82336DE8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82336C68: 82336C7C  lwz r17, 0x6c7c(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(27772 as u32) ) } as u64;
	// 82336C6C: 82336D20  lwz r17, 0x6d20(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(27936 as u32) ) } as u64;
	// 82336C70: 82336D6C  lwz r17, 0x6d6c(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(28012 as u32) ) } as u64;
	// 82336C74: 82336EA4  lwz r17, 0x6ea4(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(28324 as u32) ) } as u64;
	// 82336C78: 82336DE8  lwz r17, 0x6de8(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(28136 as u32) ) } as u64;
            }
            0x82336C7C => {
    //   block [0x82336C7C..0x82336CB0)
	// 82336C7C: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82336C80: 3D40829A  lis r10, -0x7d66
	ctx.r[10].s64 = -2103836672;
	// 82336C84: 394A4558  addi r10, r10, 0x4558
	ctx.r[10].s64 = ctx.r[10].s64 + 17752;
	// 82336C88: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82336C8C: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82336C90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82336C94: 419A001C  beq cr6, 0x82336cb0
	if ctx.cr[6].eq {
	pc = 0x82336CB0; continue 'dispatch;
	}
	// 82336C98: 3D40829A  lis r10, -0x7d66
	ctx.r[10].s64 = -2103836672;
	// 82336C9C: 1D6B0134  mulli r11, r11, 0x134
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 308 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82336CA0: 394A4088  addi r10, r10, 0x4088
	ctx.r[10].s64 = ctx.r[10].s64 + 16520;
	// 82336CA4: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82336CA8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82336CAC: 409A0014  bne cr6, 0x82336cc0
	if !ctx.cr[6].eq {
	pc = 0x82336CC0; continue 'dispatch;
	}
	pc = 0x82336CB0; continue 'dispatch;
            }
            0x82336CB0 => {
    //   block [0x82336CB0..0x82336CC0)
	// 82336CB0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82336CB4: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82336CB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82336CBC: 481FE450  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82336CC0 => {
    //   block [0x82336CC0..0x82336CF4)
	// 82336CC0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82336CC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336CC8: 419AFFE8  beq cr6, 0x82336cb0
	if ctx.cr[6].eq {
	pc = 0x82336CB0; continue 'dispatch;
	}
	// 82336CCC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82336CD0: 38DF00F8  addi r6, r31, 0xf8
	ctx.r[6].s64 = ctx.r[31].s64 + 248;
	// 82336CD4: 38FF00D4  addi r7, r31, 0xd4
	ctx.r[7].s64 = ctx.r[31].s64 + 212;
	// 82336CD8: 38BF00F0  addi r5, r31, 0xf0
	ctx.r[5].s64 = ctx.r[31].s64 + 240;
	// 82336CDC: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82336CE0: 93BF00F0  stw r29, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[29].u32 ) };
	// 82336CE4: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82336CE8: FBA60000  std r29, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 82336CEC: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82336CF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82336CF4; continue 'dispatch;
            }
            0x82336CF4 => {
    //   block [0x82336CF4..0x82336D20)
	// 82336CF4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82336CF8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82336CFC: 4200FFF8  bdnz 0x82336cf4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82336CF4; continue 'dispatch;
	}
	// 82336D00: 807F00C8  lwz r3, 0xc8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82336D04: 480895ED  bl 0x823c02f0
	ctx.lr = 0x82336D08;
	sub_823C02F0(ctx, base);
	// 82336D08: 2B0303E5  cmplwi cr6, r3, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[3].u32, 997 as u32, &mut ctx.xer);
	// 82336D0C: 409A0370  bne cr6, 0x8233707c
	if !ctx.cr[6].eq {
	pc = 0x8233707C; continue 'dispatch;
	}
	// 82336D10: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82336D14: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82336D18: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82336D1C: 481FE3F0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82336D20 => {
    //   block [0x82336D20..0x82336D54)
	// 82336D20: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82336D24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82336D28: 387F00D4  addi r3, r31, 0xd4
	ctx.r[3].s64 = ctx.r[31].s64 + 212;
	// 82336D2C: 4808946D  bl 0x823c0198
	ctx.lr = 0x82336D30;
	sub_823C0198(ctx, base);
	// 82336D30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82336D34: 409A0020  bne cr6, 0x82336d54
	if !ctx.cr[6].eq {
	pc = 0x82336D54; continue 'dispatch;
	}
	// 82336D38: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82336D3C: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 82336D40: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82336D44: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82336D48: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82336D4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82336D50: 481FE3BC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82336D54 => {
    //   block [0x82336D54..0x82336D6C)
	// 82336D54: 2B0303E4  cmplwi cr6, r3, 0x3e4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 996 as u32, &mut ctx.xer);
	// 82336D58: 419A0324  beq cr6, 0x8233707c
	if ctx.cr[6].eq {
	pc = 0x8233707C; continue 'dispatch;
	}
	// 82336D5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82336D60: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82336D64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82336D68: 481FE3A4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82336D6C => {
    //   block [0x82336D6C..0x82336D9C)
	// 82336D6C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 82336D70: 3BCBA4D8  addi r30, r11, -0x5b28
	ctx.r[30].s64 = ctx.r[11].s64 + -23336;
	// 82336D74: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82336D78: 483D6505  bl 0x8270d27c
	ctx.lr = 0x82336D7C;
	// extern call 0x8270D27C  crate::xboxkrnl::RtlTryEnterCriticalSection
	crate::xboxkrnl::RtlTryEnterCriticalSection(ctx, base);
	// 82336D7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82336D80: 419A02FC  beq cr6, 0x8233707c
	if ctx.cr[6].eq {
	pc = 0x8233707C; continue 'dispatch;
	}
	// 82336D84: 38BF00D4  addi r5, r31, 0xd4
	ctx.r[5].s64 = ctx.r[31].s64 + 212;
	// 82336D88: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82336D8C: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82336D90: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82336D94: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82336D98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82336D9C; continue 'dispatch;
            }
            0x82336D9C => {
    //   block [0x82336D9C..0x82336DD8)
	// 82336D9C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82336DA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82336DA4: 4200FFF8  bdnz 0x82336d9c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82336D9C; continue 'dispatch;
	}
	// 82336DA8: 389F0100  addi r4, r31, 0x100
	ctx.r[4].s64 = ctx.r[31].s64 + 256;
	// 82336DAC: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82336DB0: 48088EA9  bl 0x823bfc58
	ctx.lr = 0x82336DB4;
	sub_823BFC58(ctx, base);
	// 82336DB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82336DB8: 419A00F8  beq cr6, 0x82336eb0
	if ctx.cr[6].eq {
	pc = 0x82336EB0; continue 'dispatch;
	}
	// 82336DBC: 2B0303E5  cmplwi cr6, r3, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[3].u32, 997 as u32, &mut ctx.xer);
	// 82336DC0: 419A0018  beq cr6, 0x82336dd8
	if ctx.cr[6].eq {
	pc = 0x82336DD8; continue 'dispatch;
	}
	// 82336DC4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82336DC8: 483D64A5  bl 0x8270d26c
	ctx.lr = 0x82336DCC;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82336DCC: 93BF00CC  stw r29, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[29].u32 ) };
	// 82336DD0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82336DD4: 481FE338  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82336DD8 => {
    //   block [0x82336DD8..0x82336DE8)
	// 82336DD8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82336DDC: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82336DE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82336DE4: 481FE328  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82336DE8 => {
    //   block [0x82336DE8..0x82336E18)
	// 82336DE8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82336DEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82336DF0: 387F00D4  addi r3, r31, 0xd4
	ctx.r[3].s64 = ctx.r[31].s64 + 212;
	// 82336DF4: 480893A5  bl 0x823c0198
	ctx.lr = 0x82336DF8;
	sub_823C0198(ctx, base);
	// 82336DF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82336DFC: 409A0080  bne cr6, 0x82336e7c
	if !ctx.cr[6].eq {
	pc = 0x82336E7C; continue 'dispatch;
	}
	// 82336E00: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82336E04: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82336E08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336E0C: 419A000C  beq cr6, 0x82336e18
	if ctx.cr[6].eq {
	pc = 0x82336E18; continue 'dispatch;
	}
	// 82336E10: 93BF00CC  stw r29, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[29].u32 ) };
	// 82336E14: 4800004C  b 0x82336e60
	pc = 0x82336E60; continue 'dispatch;
            }
            0x82336E18 => {
    //   block [0x82336E18..0x82336E38)
	// 82336E18: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82336E1C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82336E20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82336E24: 4099003C  ble cr6, 0x82336e60
	if !ctx.cr[6].gt {
	pc = 0x82336E60; continue 'dispatch;
	}
	// 82336E28: 3D20829F  lis r9, -0x7d61
	ctx.r[9].s64 = -2103508992;
	// 82336E2C: 397F0104  addi r11, r31, 0x104
	ctx.r[11].s64 = ctx.r[31].s64 + 260;
	// 82336E30: 38E9B520  addi r7, r9, -0x4ae0
	ctx.r[7].s64 = ctx.r[9].s64 + -19168;
	// 82336E34: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	pc = 0x82336E38; continue 'dispatch;
            }
            0x82336E38 => {
    //   block [0x82336E38..0x82336E60)
	// 82336E38: 813F00C8  lwz r9, 0xc8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82336E3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82336E40: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82336E44: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82336E48: 55293032  slwi r9, r9, 6
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82336E4C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82336E50: 7CC939AE  stbx r6, r9, r7
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[6].u8) };
	// 82336E54: 813F00D0  lwz r9, 0xd0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82336E58: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82336E5C: 4198FFDC  blt cr6, 0x82336e38
	if ctx.cr[6].lt {
	pc = 0x82336E38; continue 'dispatch;
	}
	pc = 0x82336E60; continue 'dispatch;
            }
            0x82336E60 => {
    //   block [0x82336E60..0x82336E7C)
	// 82336E60: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 82336E64: 93BF00CC  stw r29, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[29].u32 ) };
	// 82336E68: 396BA4D8  addi r11, r11, -0x5b28
	ctx.r[11].s64 = ctx.r[11].s64 + -23336;
	// 82336E6C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82336E70: 483D63FD  bl 0x8270d26c
	ctx.lr = 0x82336E74;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82336E74: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82336E78: 481FE294  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82336E7C => {
    //   block [0x82336E7C..0x82336EA4)
	// 82336E7C: 2B0303E5  cmplwi cr6, r3, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[3].u32, 997 as u32, &mut ctx.xer);
	// 82336E80: 419A01FC  beq cr6, 0x8233707c
	if ctx.cr[6].eq {
	pc = 0x8233707C; continue 'dispatch;
	}
	// 82336E84: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 82336E88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82336E8C: 396BA4D8  addi r11, r11, -0x5b28
	ctx.r[11].s64 = ctx.r[11].s64 + -23336;
	// 82336E90: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82336E94: 915F00CC  stw r10, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[10].u32 ) };
	// 82336E98: 483D63D5  bl 0x8270d26c
	ctx.lr = 0x82336E9C;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82336E9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82336EA0: 481FE26C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82336EA4 => {
    //   block [0x82336EA4..0x82336EB0)
	// 82336EA4: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82336EA8: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 82336EAC: 419A01D0  beq cr6, 0x8233707c
	if ctx.cr[6].eq {
	pc = 0x8233707C; continue 'dispatch;
	}
	pc = 0x82336EB0; continue 'dispatch;
            }
            0x82336EB0 => {
    //   block [0x82336EB0..0x82336EC0)
	// 82336EB0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82336EB4: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82336EB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82336EBC: 481FE250  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82336EC0 => {
    //   block [0x82336EC0..0x82336EE4)
	// 82336EC0: 389F0080  addi r4, r31, 0x80
	ctx.r[4].s64 = ctx.r[31].s64 + 128;
	// 82336EC4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82336EC8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82336ECC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82336ED0: 419A018C  beq cr6, 0x8233705c
	if ctx.cr[6].eq {
	pc = 0x8233705C; continue 'dispatch;
	}
	// 82336ED4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82336ED8: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 82336EDC: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82336EE0: 38EBB520  addi r7, r11, -0x4ae0
	ctx.r[7].s64 = ctx.r[11].s64 + -19168;
	pc = 0x82336EE4; continue 'dispatch;
            }
            0x82336EE4 => {
    //   block [0x82336EE4..0x82336F00)
	// 82336EE4: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82336EE8: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82336EEC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82336EF0: 7D4B38AE  lbzx r10, r11, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82336EF4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82336EF8: 409A0008  bne cr6, 0x82336f00
	if !ctx.cr[6].eq {
	pc = 0x82336F00; continue 'dispatch;
	}
	// 82336EFC: 7FAB39AE  stbx r29, r11, r7
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[29].u8) };
	pc = 0x82336F00; continue 'dispatch;
            }
            0x82336F00 => {
    //   block [0x82336F00..0x82336F20)
	// 82336F00: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82336F04: 39470001  addi r10, r7, 1
	ctx.r[10].s64 = ctx.r[7].s64 + 1;
	// 82336F08: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82336F0C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82336F10: 7D0B50AE  lbzx r8, r11, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82336F14: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 82336F18: 409A0008  bne cr6, 0x82336f20
	if !ctx.cr[6].eq {
	pc = 0x82336F20; continue 'dispatch;
	}
	// 82336F1C: 7FAB51AE  stbx r29, r11, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u8) };
	pc = 0x82336F20; continue 'dispatch;
            }
            0x82336F20 => {
    //   block [0x82336F20..0x82336F40)
	// 82336F20: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82336F24: 39470002  addi r10, r7, 2
	ctx.r[10].s64 = ctx.r[7].s64 + 2;
	// 82336F28: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82336F2C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82336F30: 7D0B50AE  lbzx r8, r11, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82336F34: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 82336F38: 409A0008  bne cr6, 0x82336f40
	if !ctx.cr[6].eq {
	pc = 0x82336F40; continue 'dispatch;
	}
	// 82336F3C: 7FAB51AE  stbx r29, r11, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u8) };
	pc = 0x82336F40; continue 'dispatch;
            }
            0x82336F40 => {
    //   block [0x82336F40..0x82336F60)
	// 82336F40: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82336F44: 39470003  addi r10, r7, 3
	ctx.r[10].s64 = ctx.r[7].s64 + 3;
	// 82336F48: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82336F4C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82336F50: 7D0B50AE  lbzx r8, r11, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82336F54: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 82336F58: 409A0008  bne cr6, 0x82336f60
	if !ctx.cr[6].eq {
	pc = 0x82336F60; continue 'dispatch;
	}
	// 82336F5C: 7FAB51AE  stbx r29, r11, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u8) };
	pc = 0x82336F60; continue 'dispatch;
            }
            0x82336F60 => {
    //   block [0x82336F60..0x82336F8C)
	// 82336F60: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82336F64: 2F090040  cmpwi cr6, r9, 0x40
	ctx.cr[6].compare_i32(ctx.r[9].s32, 64, &mut ctx.xer);
	// 82336F68: 4198FF7C  blt cr6, 0x82336ee4
	if ctx.cr[6].lt {
	pc = 0x82336EE4; continue 'dispatch;
	}
	// 82336F6C: 93BF00D0  stw r29, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 82336F70: 395F0100  addi r10, r31, 0x100
	ctx.r[10].s64 = ctx.r[31].s64 + 256;
	// 82336F74: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82336F78: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82336F7C: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82336F80: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82336F84: 419A009C  beq cr6, 0x82337020
	if ctx.cr[6].eq {
	pc = 0x82337020; continue 'dispatch;
	}
	// 82336F88: 38BF0300  addi r5, r31, 0x300
	ctx.r[5].s64 = ctx.r[31].s64 + 768;
	pc = 0x82336F8C; continue 'dispatch;
            }
            0x82336F8C => {
    //   block [0x82336F8C..0x82336FC4)
	// 82336F8C: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82336F90: 40980090  bge cr6, 0x82337020
	if !ctx.cr[6].lt {
	pc = 0x82337020; continue 'dispatch;
	}
	// 82336F94: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82336F98: 81040004  lwz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82336F9C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82336FA0: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82336FA4: 7D292214  add r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 82336FA8: 89290008  lbz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82336FAC: 419A0018  beq cr6, 0x82336fc4
	if ctx.cr[6].eq {
	pc = 0x82336FC4; continue 'dispatch;
	}
	// 82336FB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82336FB4: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82336FB8: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82336FBC: 41980008  blt cr6, 0x82336fc4
	if ctx.cr[6].lt {
	pc = 0x82336FC4; continue 'dispatch;
	}
	// 82336FC0: 93A40000  stw r29, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x82336FC4; continue 'dispatch;
            }
            0x82336FC4 => {
    //   block [0x82336FC4..0x82337010)
	// 82336FC4: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82336FC8: 2B0B0040  cmplwi cr6, r11, 0x40
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64 as u32, &mut ctx.xer);
	// 82336FCC: 40980044  bge cr6, 0x82337010
	if !ctx.cr[6].lt {
	pc = 0x82337010; continue 'dispatch;
	}
	// 82336FD0: 813F00C8  lwz r9, 0xc8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82336FD4: 55283032  slwi r8, r9, 6
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82336FD8: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82336FDC: 7D0838AE  lbzx r8, r8, r7
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82336FE0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82336FE4: 409A002C  bne cr6, 0x82337010
	if !ctx.cr[6].eq {
	pc = 0x82337010; continue 'dispatch;
	}
	// 82336FE8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82336FEC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82336FF0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82336FF4: 813F00C8  lwz r9, 0xc8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82336FF8: 811F00D0  lwz r8, 0xd0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82336FFC: 55293032  slwi r9, r9, 6
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82337000: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82337004: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82337008: 911F00D0  stw r8, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[8].u32 ) };
	// 8233700C: 7CCB39AE  stbx r6, r11, r7
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[6].u8) };
	pc = 0x82337010; continue 'dispatch;
            }
            0x82337010 => {
    //   block [0x82337010..0x82337020)
	// 82337010: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337014: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337018: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8233701C: 409AFF70  bne cr6, 0x82336f8c
	if !ctx.cr[6].eq {
	pc = 0x82336F8C; continue 'dispatch;
	}
	pc = 0x82337020; continue 'dispatch;
            }
            0x82337020 => {
    //   block [0x82337020..0x82337038)
	// 82337020: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82337024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82337028: 40990010  ble cr6, 0x82337038
	if !ctx.cr[6].gt {
	pc = 0x82337038; continue 'dispatch;
	}
	// 8233702C: 90DF00CC  stw r6, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[6].u32 ) };
	// 82337030: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82337034: 481FE0D8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82337038 => {
    //   block [0x82337038..0x8233705C)
	// 82337038: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8233703C: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82337040: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82337044: 409A0038  bne cr6, 0x8233707c
	if !ctx.cr[6].eq {
	pc = 0x8233707C; continue 'dispatch;
	}
	// 82337048: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8233704C: 98DF0025  stb r6, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[6].u8 ) };
	// 82337050: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82337054: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82337058: 481FE0B4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x8233705C => {
    //   block [0x8233705C..0x8233707C)
	// 8233705C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82337060: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82337064: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82337068: 409A0014  bne cr6, 0x8233707c
	if !ctx.cr[6].eq {
	pc = 0x8233707C; continue 'dispatch;
	}
	// 8233706C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82337070: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82337074: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 82337078: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	pc = 0x8233707C; continue 'dispatch;
            }
            0x8233707C => {
    //   block [0x8233707C..0x82337084)
	// 8233707C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82337080: 481FE08C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82337088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82337088 size=296
    let mut pc: u32 = 0x82337088;
    'dispatch: loop {
        match pc {
            0x82337088 => {
    //   block [0x82337088..0x823370CC)
	// 82337088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233708C: 481FE02D  bl 0x825350b8
	ctx.lr = 0x82337090;
	sub_82535080(ctx, base);
	// 82337090: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82337094: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 82337098: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8233709C: 3BEB4AE0  addi r31, r11, 0x4ae0
	ctx.r[31].s64 = ctx.r[11].s64 + 19168;
	// 823370A0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823370A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823370A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823370AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823370B0: 419A001C  beq cr6, 0x823370cc
	if ctx.cr[6].eq {
	pc = 0x823370CC; continue 'dispatch;
	}
	// 823370B4: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 823370B8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823370BC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823370C0: 409A000C  bne cr6, 0x823370cc
	if !ctx.cr[6].eq {
	pc = 0x823370CC; continue 'dispatch;
	}
	// 823370C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823370C8: 409A0070  bne cr6, 0x82337138
	if !ctx.cr[6].eq {
	pc = 0x82337138; continue 'dispatch;
	}
	pc = 0x823370CC; continue 'dispatch;
            }
            0x823370CC => {
    //   block [0x823370CC..0x823370F8)
	// 823370CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823370D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823370D4: 38EBDF84  addi r7, r11, -0x207c
	ctx.r[7].s64 = ctx.r[11].s64 + -8316;
	// 823370D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823370DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823370E0: 386002E0  li r3, 0x2e0
	ctx.r[3].s64 = 736;
	// 823370E4: 480333AD  bl 0x8236a490
	ctx.lr = 0x823370E8;
	sub_8236A490(ctx, base);
	// 823370E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823370EC: 419A000C  beq cr6, 0x823370f8
	if ctx.cr[6].eq {
	pc = 0x823370F8; continue 'dispatch;
	}
	// 823370F0: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 823370F4: 48000008  b 0x823370fc
	pc = 0x823370FC; continue 'dispatch;
            }
            0x823370F8 => {
    //   block [0x823370F8..0x823370FC)
	// 823370F8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x823370FC; continue 'dispatch;
            }
            0x823370FC => {
    //   block [0x823370FC..0x82337134)
	// 823370FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82337100: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82337104: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82337108: 419A002C  beq cr6, 0x82337134
	if ctx.cr[6].eq {
	pc = 0x82337134; continue 'dispatch;
	}
	// 8233710C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82337110: 396BDF8C  addi r11, r11, -0x2074
	ctx.r[11].s64 = ctx.r[11].s64 + -8308;
	// 82337114: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82337118: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8233711C: FBC30080  std r30, 0x80(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[30].u64 ) };
	// 82337120: 93C30094  stw r30, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 82337124: 93C30090  stw r30, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 82337128: 93C3008C  stw r30, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 8233712C: 93C302D8  stw r30, 0x2d8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(728 as u32), ctx.r[30].u32 ) };
	// 82337130: 48000008  b 0x82337138
	pc = 0x82337138; continue 'dispatch;
            }
            0x82337134 => {
    //   block [0x82337134..0x82337138)
	// 82337134: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82337138; continue 'dispatch;
            }
            0x82337138 => {
    //   block [0x82337138..0x82337160)
	// 82337138: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 8233713C: 396B0090  addi r11, r11, 0x90
	ctx.r[11].s64 = ctx.r[11].s64 + 144;
	// 82337140: C00AD564  lfs f0, -0x2a9c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82337144: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337148: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8233714C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337150: 7D295050  subf r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82337154: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82337158: 40980008  bge cr6, 0x82337160
	if !ctx.cr[6].lt {
	pc = 0x82337160; continue 'dispatch;
	}
	// 8233715C: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	pc = 0x82337160; continue 'dispatch;
            }
            0x82337160 => {
    //   block [0x82337160..0x823371A8)
	// 82337160: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82337164: 2F090010  cmpwi cr6, r9, 0x10
	ctx.cr[6].compare_i32(ctx.r[9].s32, 16, &mut ctx.xer);
	// 82337168: 40980040  bge cr6, 0x823371a8
	if !ctx.cr[6].lt {
	pc = 0x823371A8; continue 'dispatch;
	}
	// 8233716C: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82337170: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82337174: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82337178: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8233717C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82337180: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82337184: 93AA0000  stw r29, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82337188: 938A0004  stw r28, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 8233718C: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82337190: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337194: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82337198: 2F0A0010  cmpwi cr6, r10, 0x10
	ctx.cr[6].compare_i32(ctx.r[10].s32, 16, &mut ctx.xer);
	// 8233719C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823371A0: 41980008  blt cr6, 0x823371a8
	if ctx.cr[6].lt {
	pc = 0x823371A8; continue 'dispatch;
	}
	// 823371A4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x823371A8; continue 'dispatch;
            }
            0x823371A8 => {
    //   block [0x823371A8..0x823371B0)
	// 823371A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823371AC: 481FDF5C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823371B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823371B0 size=88
    let mut pc: u32 = 0x823371B0;
    'dispatch: loop {
        match pc {
            0x823371B0 => {
    //   block [0x823371B0..0x82337208)
	// 823371B0: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 823371B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823371B8: 916ABD14  stw r11, -0x42ec(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17132 as u32), ctx.r[11].u32 ) };
	// 823371BC: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 823371C0: 394B4AE0  addi r10, r11, 0x4ae0
	ctx.r[10].s64 = ctx.r[11].s64 + 19168;
	// 823371C4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823371C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823371CC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 823371D0: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 823371D4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823371D8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823371DC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 823371E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823371E4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 823371E8: A14B0014  lhz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823371EC: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 823371F0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823371F4: 614A8000  ori r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 32768;
	// 823371F8: 992B0019  stb r9, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[9].u8 ) };
	// 823371FC: 990B0025  stb r8, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[8].u8 ) };
	// 82337200: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 82337204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82337208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82337208 size=708
    let mut pc: u32 = 0x82337208;
    'dispatch: loop {
        match pc {
            0x82337208 => {
    //   block [0x82337208..0x8233722C)
	// 82337208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233720C: 481FDEA5  bl 0x825350b0
	ctx.lr = 0x82337210;
	sub_82535080(ctx, base);
	// 82337210: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82337214: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82337218: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233721C: 816BBD14  lwz r11, -0x42ec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17132 as u32) ) } as u64;
	// 82337220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82337224: 419A02A0  beq cr6, 0x823374c4
	if ctx.cr[6].eq {
	pc = 0x823374C4; continue 'dispatch;
	}
	// 82337228: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x8233722C; continue 'dispatch;
            }
            0x8233722C => {
    //   block [0x8233722C..0x82337298)
	// 8233722C: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82337230: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82337234: 40980148  bge cr6, 0x8233737c
	if !ctx.cr[6].lt {
	pc = 0x8233737C; continue 'dispatch;
	}
	// 82337238: 397F0090  addi r11, r31, 0x90
	ctx.r[11].s64 = ctx.r[31].s64 + 144;
	// 8233723C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337240: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337244: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82337248: 419A025C  beq cr6, 0x823374a4
	if ctx.cr[6].eq {
	pc = 0x823374A4; continue 'dispatch;
	}
	// 8233724C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82337250: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337254: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337258: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8233725C: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82337260: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82337264: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82337268: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8233726C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82337270: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337274: 836A0004  lwz r27, 4(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337278: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233727C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82337280: 419A0018  beq cr6, 0x82337298
	if ctx.cr[6].eq {
	pc = 0x82337298; continue 'dispatch;
	}
	// 82337284: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 82337288: 2F0A0010  cmpwi cr6, r10, 0x10
	ctx.cr[6].compare_i32(ctx.r[10].s32, 16, &mut ctx.xer);
	// 8233728C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82337290: 41980008  blt cr6, 0x82337298
	if ctx.cr[6].lt {
	pc = 0x82337298; continue 'dispatch;
	}
	// 82337294: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82337298; continue 'dispatch;
            }
            0x82337298 => {
    //   block [0x82337298..0x823372AC)
	// 82337298: 817F02D8  lwz r11, 0x2d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 8233729C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 823372A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823372A4: 40990028  ble cr6, 0x823372cc
	if !ctx.cr[6].gt {
	pc = 0x823372CC; continue 'dispatch;
	}
	// 823372A8: 397F0258  addi r11, r31, 0x258
	ctx.r[11].s64 = ctx.r[31].s64 + 600;
	pc = 0x823372AC; continue 'dispatch;
            }
            0x823372AC => {
    //   block [0x823372AC..0x823372CC)
	// 823372AC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823372B0: 7F09E840  cmplw cr6, r9, r29
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[29].u32, &mut ctx.xer);
	// 823372B4: 419AFF78  beq cr6, 0x8233722c
	if ctx.cr[6].eq {
	pc = 0x8233722C; continue 'dispatch;
	}
	// 823372B8: 813F02D8  lwz r9, 0x2d8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 823372BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823372C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823372C4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823372C8: 4198FFE4  blt cr6, 0x823372ac
	if ctx.cr[6].lt {
	pc = 0x823372AC; continue 'dispatch;
	}
	pc = 0x823372CC; continue 'dispatch;
            }
            0x823372CC => {
    //   block [0x823372CC..0x823372F8)
	// 823372CC: 817F02D8  lwz r11, 0x2d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 823372D0: 396B0096  addi r11, r11, 0x96
	ctx.r[11].s64 = ctx.r[11].s64 + 150;
	// 823372D4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823372D8: 7FABF92E  stwx r29, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[29].u32) };
	// 823372DC: 817F02D8  lwz r11, 0x2d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 823372E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823372E4: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 823372E8: 917F02D8  stw r11, 0x2d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), ctx.r[11].u32 ) };
	// 823372EC: 4198000C  blt cr6, 0x823372f8
	if ctx.cr[6].lt {
	pc = 0x823372F8; continue 'dispatch;
	}
	// 823372F0: 3960001F  li r11, 0x1f
	ctx.r[11].s64 = 31;
	// 823372F4: 917F02D8  stw r11, 0x2d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), ctx.r[11].u32 ) };
	pc = 0x823372F8; continue 'dispatch;
            }
            0x823372F8 => {
    //   block [0x823372F8..0x8233737C)
	// 823372F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823372FC: 4BF355FD  bl 0x8226c8f8
	ctx.lr = 0x82337300;
	sub_8226C8F8(ctx, base);
	// 82337300: 39600019  li r11, 0x19
	ctx.r[11].s64 = 25;
	// 82337304: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82337308: 93C1009C  stw r30, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 8233730C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82337310: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82337314: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82337318: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8233731C: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82337320: 9B81011D  stb r28, 0x11d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(285 as u32), ctx.r[28].u8 ) };
	// 82337324: 9B81011E  stb r28, 0x11e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(286 as u32), ctx.r[28].u8 ) };
	// 82337328: 9B810121  stb r28, 0x121(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(289 as u32), ctx.r[28].u8 ) };
	// 8233732C: C00BAC48  lfs f0, -0x53b8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82337330: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82337334: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82337338: C00B3180  lfs f0, 0x3180(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12672 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233733C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82337340: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82337344: C00B2074  lfs f0, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82337348: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 8233734C: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82337350: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82337354: 9961011C  stb r11, 0x11c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[11].u8 ) };
	// 82337358: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8233735C: 409A00DC  bne cr6, 0x82337438
	if !ctx.cr[6].eq {
	pc = 0x82337438; continue 'dispatch;
	}
	// 82337360: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82337364: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82337368: 614A94F8  ori r10, r10, 0x94f8
	ctx.r[10].u64 = ctx.r[10].u64 | 38136;
	// 8233736C: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82337370: 4BF8FDC1  bl 0x822c7130
	ctx.lr = 0x82337374;
	sub_822C7130(ctx, base);
	// 82337374: 906100F4  stw r3, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[3].u32 ) };
	// 82337378: 48000104  b 0x8233747c
	pc = 0x8233747C; continue 'dispatch;
            }
            0x8233737C => {
    //   block [0x8233737C..0x823373A4)
	// 8233737C: 419A0034  beq cr6, 0x823373b0
	if ctx.cr[6].eq {
	pc = 0x823373B0; continue 'dispatch;
	}
	// 82337380: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82337384: 40980140  bge cr6, 0x823374c4
	if !ctx.cr[6].lt {
	pc = 0x823374C4; continue 'dispatch;
	}
	// 82337388: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 8233738C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82337390: 419A0014  beq cr6, 0x823373a4
	if ctx.cr[6].eq {
	pc = 0x823373A4; continue 'dispatch;
	}
	// 82337394: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82337398: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8233739C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823373A0: 419A0124  beq cr6, 0x823374c4
	if ctx.cr[6].eq {
	pc = 0x823374C4; continue 'dispatch;
	}
	pc = 0x823373A4; continue 'dispatch;
            }
            0x823373A4 => {
    //   block [0x823373A4..0x823373B0)
	// 823373A4: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 823373A8: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 823373AC: 481FDD54  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x823373B0 => {
    //   block [0x823373B0..0x82337410)
	// 823373B0: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 823373B4: C1BF0088  lfs f13, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823373B8: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 823373BC: C00B06B4  lfs f0, 0x6b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1716 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823373C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823373C4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823373C8: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 823373CC: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823373D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823373D4: 419900F0  bgt cr6, 0x823374c4
	if ctx.cr[6].gt {
	pc = 0x823374C4; continue 'dispatch;
	}
	// 823373D8: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 823373DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823373E0: 419A0048  beq cr6, 0x82337428
	if ctx.cr[6].eq {
	pc = 0x82337428; continue 'dispatch;
	}
	// 823373E4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 823373E8: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 823373EC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823373F0: 409A0038  bne cr6, 0x82337428
	if !ctx.cr[6].eq {
	pc = 0x82337428; continue 'dispatch;
	}
	// 823373F4: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 823373F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823373FC: 419A0014  beq cr6, 0x82337410
	if ctx.cr[6].eq {
	pc = 0x82337410; continue 'dispatch;
	}
	// 82337400: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82337404: 813F0080  lwz r9, 0x80(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82337408: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8233740C: 419A0008  beq cr6, 0x82337414
	if ctx.cr[6].eq {
	pc = 0x82337414; continue 'dispatch;
	}
	pc = 0x82337410; continue 'dispatch;
            }
            0x82337410 => {
    //   block [0x82337410..0x82337414)
	// 82337410: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82337414; continue 'dispatch;
            }
            0x82337414 => {
    //   block [0x82337414..0x82337428)
	// 82337414: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337418: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8233741C: 816A0028  lwz r11, 0x28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82337420: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82337424: 4E800421  bctrl
	ctx.lr = 0x82337428;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82337428 => {
    //   block [0x82337428..0x82337438)
	// 82337428: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8233742C: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82337430: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82337434: 481FDCCC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x82337438 => {
    //   block [0x82337438..0x8233747C)
	// 82337438: 3BCBBFF0  addi r30, r11, -0x4010
	ctx.r[30].s64 = ctx.r[11].s64 + -16400;
	// 8233743C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82337440: 3BBF0158  addi r29, r31, 0x158
	ctx.r[29].s64 = ctx.r[31].s64 + 344;
	// 82337444: 616B94F8  ori r11, r11, 0x94f8
	ctx.r[11].u64 = ctx.r[11].u64 | 38136;
	// 82337448: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8233744C: 4BF8FCE5  bl 0x822c7130
	ctx.lr = 0x82337450;
	sub_822C7130(ctx, base);
	// 82337450: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82337454: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82337458: 616B94F8  ori r11, r11, 0x94f8
	ctx.r[11].u64 = ctx.r[11].u64 | 38136;
	// 8233745C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82337460: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82337464: 4BF8FCCD  bl 0x822c7130
	ctx.lr = 0x82337468;
	sub_822C7130(ctx, base);
	// 82337468: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8233746C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82337470: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82337474: 481FB7AD  bl 0x82532c20
	ctx.lr = 0x82337478;
	sub_82532C20(ctx, base);
	// 82337478: 93A100F4  stw r29, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[29].u32 ) };
	pc = 0x8233747C; continue 'dispatch;
            }
            0x8233747C => {
    //   block [0x8233747C..0x823374A4)
	// 8233747C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82337480: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82337484: 4BF356AD  bl 0x8226cb30
	ctx.lr = 0x82337488;
	sub_8226CB30(ctx, base);
	// 82337488: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8233748C: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82337490: 939F008C  stw r28, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[28].u32 ) };
	// 82337494: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82337498: F97F0080  std r11, 0x80(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 8233749C: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 823374A0: 481FDC60  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x823374A4 => {
    //   block [0x823374A4..0x823374C4)
	// 823374A4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 823374A8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 823374AC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 823374B0: 409A0014  bne cr6, 0x823374c4
	if !ctx.cr[6].eq {
	pc = 0x823374C4; continue 'dispatch;
	}
	// 823374B4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 823374B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823374BC: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 823374C0: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x823374C4; continue 'dispatch;
            }
            0x823374C4 => {
    //   block [0x823374C4..0x823374CC)
	// 823374C4: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 823374C8: 481FDC38  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823374D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823374D0 size=136
    let mut pc: u32 = 0x823374D0;
    'dispatch: loop {
        match pc {
            0x823374D0 => {
    //   block [0x823374D0..0x82337514)
	// 823374D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823374D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823374D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823374DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823374E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823374E4: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 823374E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823374EC: 394B61D0  addi r10, r11, 0x61d0
	ctx.r[10].s64 = ctx.r[11].s64 + 25040;
	// 823374F0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823374F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823374F8: 419A001C  beq cr6, 0x82337514
	if ctx.cr[6].eq {
	pc = 0x82337514; continue 'dispatch;
	}
	// 823374FC: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82337500: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337504: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82337508: 409A000C  bne cr6, 0x82337514
	if !ctx.cr[6].eq {
	pc = 0x82337514; continue 'dispatch;
	}
	// 8233750C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82337510: 409A0030  bne cr6, 0x82337540
	if !ctx.cr[6].eq {
	pc = 0x82337540; continue 'dispatch;
	}
	pc = 0x82337514; continue 'dispatch;
            }
            0x82337514 => {
    //   block [0x82337514..0x82337518)
	// 82337514: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82337518; continue 'dispatch;
            }
            0x82337518 => {
    //   block [0x82337518..0x82337540)
	// 82337518: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233751C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82337520: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82337524: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82337528: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8233752C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82337530: 4E800421  bctrl
	ctx.lr = 0x82337534;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82337534: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82337538: 2F1F001F  cmpwi cr6, r31, 0x1f
	ctx.cr[6].compare_i32(ctx.r[31].s32, 31, &mut ctx.xer);
	// 8233753C: 4198FFDC  blt cr6, 0x82337518
	if ctx.cr[6].lt {
	pc = 0x82337518; continue 'dispatch;
	}
            }
            0x82337540 => {
    //   block [0x82337540..0x82337558)
	// 82337540: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82337544: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82337548: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233754C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82337550: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82337554: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82337558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82337558 size=204
    let mut pc: u32 = 0x82337558;
    'dispatch: loop {
        match pc {
            0x82337558 => {
    //   block [0x82337558..0x823375F0)
	// 82337558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233755C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82337560: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82337564: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82337568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233756C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82337570: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82337574: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233757C: 409A008C  bne cr6, 0x82337608
	if !ctx.cr[6].eq {
	pc = 0x82337608; continue 'dispatch;
	}
	// 82337580: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337584: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82337588: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233758C: 4E800421  bctrl
	ctx.lr = 0x82337590;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82337590: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82337594: 419A0074  beq cr6, 0x82337608
	if ctx.cr[6].eq {
	pc = 0x82337608; continue 'dispatch;
	}
	// 82337598: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8233759C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823375A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 823375A4: 93FF000C  stw r31, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 823375A8: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 823375AC: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 823375B0: 390BDFAC  addi r8, r11, -0x2054
	ctx.r[8].s64 = ctx.r[11].s64 + -8276;
	// 823375B4: 3D608233  lis r11, -0x7dcd
	ctx.r[11].s64 = -2110586880;
	// 823375B8: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 823375BC: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 823375C0: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 823375C4: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 823375C8: 38E04000  li r7, 0x4000
	ctx.r[7].s64 = 16384;
	// 823375CC: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 823375D0: 388B7628  addi r4, r11, 0x7628
	ctx.r[4].s64 = ctx.r[11].s64 + 30248;
	// 823375D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823375D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 823375DC: 4E800421  bctrl
	ctx.lr = 0x823375E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823375E0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 823375E4: 409A000C  bne cr6, 0x823375f0
	if !ctx.cr[6].eq {
	pc = 0x823375F0; continue 'dispatch;
	}
	// 823375E8: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823375EC: 48000008  b 0x823375f4
	pc = 0x823375F4; continue 'dispatch;
            }
            0x823375F0 => {
    //   block [0x823375F0..0x823375F4)
	// 823375F0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x823375F4; continue 'dispatch;
            }
            0x823375F4 => {
    //   block [0x823375F4..0x82337608)
	// 823375F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823375F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823375FC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82337600: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82337604: 4E800421  bctrl
	ctx.lr = 0x82337608;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82337608 => {
    //   block [0x82337608..0x82337624)
	// 82337608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233760C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82337610: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82337614: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82337618: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233761C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82337620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82337628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82337628 size=764
    let mut pc: u32 = 0x82337628;
    'dispatch: loop {
        match pc {
            0x82337628 => {
    //   block [0x82337628..0x82337658)
	// 82337628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233762C: 481FDA89  bl 0x825350b4
	ctx.lr = 0x82337630;
	sub_82535080(ctx, base);
	// 82337630: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 82337634: 9421EF70  stwu r1, -0x1090(r1)
	ea = ctx.r[1].u32.wrapping_add(-4240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82337638: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8233763C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82337640: 83BC0004  lwz r29, 4(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337644: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337648: 2F1D001F  cmpwi cr6, r29, 0x1f
	ctx.cr[6].compare_i32(ctx.r[29].s32, 31, &mut ctx.xer);
	// 8233764C: 4198000C  blt cr6, 0x82337658
	if ctx.cr[6].lt {
	pc = 0x82337658; continue 'dispatch;
	}
	// 82337650: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82337654: 4800000C  b 0x82337660
	pc = 0x82337660; continue 'dispatch;
            }
            0x82337658 => {
    //   block [0x82337658..0x82337660)
	// 82337658: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8233765C: 40980034  bge cr6, 0x82337690
	if !ctx.cr[6].lt {
	pc = 0x82337690; continue 'dispatch;
	}
	pc = 0x82337660; continue 'dispatch;
            }
            0x82337660 => {
    //   block [0x82337660..0x82337664)
	// 82337660: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x82337664; continue 'dispatch;
            }
            0x82337664 => {
    //   block [0x82337664..0x82337690)
	// 82337664: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337668: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8233766C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82337670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337674: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82337678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233767C: 4E800421  bctrl
	ctx.lr = 0x82337680;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82337680: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82337684: 2F1E001F  cmpwi cr6, r30, 0x1f
	ctx.cr[6].compare_i32(ctx.r[30].s32, 31, &mut ctx.xer);
	// 82337688: 4198FFDC  blt cr6, 0x82337664
	if ctx.cr[6].lt {
	pc = 0x82337664; continue 'dispatch;
	}
	// 8233768C: 48000020  b 0x823376ac
	pc = 0x823376AC; continue 'dispatch;
            }
            0x82337690 => {
    //   block [0x82337690..0x823376AC)
	// 82337690: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337694: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82337698: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8233769C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823376A0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823376A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823376A8: 4E800421  bctrl
	ctx.lr = 0x823376AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823376AC => {
    //   block [0x823376AC..0x8233771C)
	// 823376AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823376B0: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 823376B4: 38A01000  li r5, 0x1000
	ctx.r[5].s64 = 4096;
	// 823376B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823376BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823376C0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823376C4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823376C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823376CC: 4E800421  bctrl
	ctx.lr = 0x823376D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823376D0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 823376D4: 419A014C  beq cr6, 0x82337820
	if ctx.cr[6].eq {
	pc = 0x82337820; continue 'dispatch;
	}
	// 823376D8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 823376DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823376E0: 409A0140  bne cr6, 0x82337820
	if !ctx.cr[6].eq {
	pc = 0x82337820; continue 'dispatch;
	}
	// 823376E4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 823376E8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 823376EC: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 823376F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823376F4: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 823376F8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823376FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337700: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82337704: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337708: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8233770C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82337710: 4E800421  bctrl
	ctx.lr = 0x82337714;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82337714: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82337718: 419A0108  beq cr6, 0x82337820
	if ctx.cr[6].eq {
	pc = 0x82337820; continue 'dispatch;
	}
            }
            0x8233771C => {
    //   block [0x8233771C..0x8233773C)
	// 8233771C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82337720: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82337724: 409A00FC  bne cr6, 0x82337820
	if !ctx.cr[6].eq {
	pc = 0x82337820; continue 'dispatch;
	}
	// 82337728: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8233772C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82337730: 4198000C  blt cr6, 0x8233773c
	if ctx.cr[6].lt {
	pc = 0x8233773C; continue 'dispatch;
	}
	// 82337734: 7F1D2000  cmpw cr6, r29, r4
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82337738: 409A00C4  bne cr6, 0x823377fc
	if !ctx.cr[6].eq {
	pc = 0x823377FC; continue 'dispatch;
	}
	pc = 0x8233773C; continue 'dispatch;
            }
            0x8233773C => {
    //   block [0x8233773C..0x82337778)
	// 8233773C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82337740: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82337744: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82337748: 419900B4  bgt cr6, 0x823377fc
	if ctx.cr[6].gt {
	pc = 0x823377FC; continue 'dispatch;
	}
	// 8233774C: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 82337750: 398C7764  addi r12, r12, 0x7764
	ctx.r[12].s64 = ctx.r[12].s64 + 30564;
	// 82337754: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82337758: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8233775C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82337760: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x82337778; continue 'dispatch;
		},
		1 => {
	pc = 0x823377A8; continue 'dispatch;
		},
		2 => {
	pc = 0x823377B8; continue 'dispatch;
		},
		3 => {
	pc = 0x823377C8; continue 'dispatch;
		},
		4 => {
	pc = 0x823377D8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82337764: 82337778  lwz r17, 0x7778(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(30584 as u32) ) } as u64;
	// 82337768: 823377A8  lwz r17, 0x77a8(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(30632 as u32) ) } as u64;
	// 8233776C: 823377B8  lwz r17, 0x77b8(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(30648 as u32) ) } as u64;
	// 82337770: 823377C8  lwz r17, 0x77c8(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(30664 as u32) ) } as u64;
	// 82337774: 823377D8  lwz r17, 0x77d8(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(30680 as u32) ) } as u64;
            }
            0x82337778 => {
    //   block [0x82337778..0x823377A8)
	// 82337778: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8233777C: 2B050011  cmplwi cr6, r5, 0x11
	ctx.cr[6].compare_u32(ctx.r[5].u32, 17 as u32, &mut ctx.xer);
	// 82337780: 4199007C  bgt cr6, 0x823377fc
	if ctx.cr[6].gt {
	pc = 0x823377FC; continue 'dispatch;
	}
	// 82337784: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337788: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8233778C: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82337790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337794: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82337798: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233779C: 4E800421  bctrl
	ctx.lr = 0x823377A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823377A0: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823377A4: 48000040  b 0x823377e4
	pc = 0x823377E4; continue 'dispatch;
            }
            0x823377A8 => {
    //   block [0x823377A8..0x823377B8)
	// 823377A8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823377AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823377B0: 4199004C  bgt cr6, 0x823377fc
	if ctx.cr[6].gt {
	pc = 0x823377FC; continue 'dispatch;
	}
	// 823377B4: 48000030  b 0x823377e4
	pc = 0x823377E4; continue 'dispatch;
            }
            0x823377B8 => {
    //   block [0x823377B8..0x823377C8)
	// 823377B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823377BC: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 823377C0: 4199003C  bgt cr6, 0x823377fc
	if ctx.cr[6].gt {
	pc = 0x823377FC; continue 'dispatch;
	}
	// 823377C4: 48000020  b 0x823377e4
	pc = 0x823377E4; continue 'dispatch;
            }
            0x823377C8 => {
    //   block [0x823377C8..0x823377D8)
	// 823377C8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823377CC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 823377D0: 4199002C  bgt cr6, 0x823377fc
	if ctx.cr[6].gt {
	pc = 0x823377FC; continue 'dispatch;
	}
	// 823377D4: 48000010  b 0x823377e4
	pc = 0x823377E4; continue 'dispatch;
            }
            0x823377D8 => {
    //   block [0x823377D8..0x823377E4)
	// 823377D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823377DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823377E0: 409A001C  bne cr6, 0x823377fc
	if !ctx.cr[6].eq {
	pc = 0x823377FC; continue 'dispatch;
	}
	pc = 0x823377E4; continue 'dispatch;
            }
            0x823377E4 => {
    //   block [0x823377E4..0x823377FC)
	// 823377E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823377E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 823377EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823377F0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823377F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823377F8: 4E800421  bctrl
	ctx.lr = 0x823377FC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823377FC => {
    //   block [0x823377FC..0x82337820)
	// 823377FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337800: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82337804: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82337808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233780C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82337810: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82337814: 4E800421  bctrl
	ctx.lr = 0x82337818;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82337818: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233781C: 409AFF00  bne cr6, 0x8233771c
	if !ctx.cr[6].eq {
	pc = 0x8233771C; continue 'dispatch;
	}
            }
            0x82337820 => {
    //   block [0x82337820..0x82337868)
	// 82337820: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337824: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82337828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233782C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82337830: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82337834: 4E800421  bctrl
	ctx.lr = 0x82337838;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82337838: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8233783C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337844: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 82337848: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 8233784C: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82337850: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82337854: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82337858: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8233785C: 4E800421  bctrl
	ctx.lr = 0x82337860;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82337860: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82337864: 409A0034  bne cr6, 0x82337898
	if !ctx.cr[6].eq {
	pc = 0x82337898; continue 'dispatch;
	}
            }
            0x82337868 => {
    //   block [0x82337868..0x82337898)
	// 82337868: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233786C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337870: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82337874: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82337878: 4E800421  bctrl
	ctx.lr = 0x8233787C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8233787C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337884: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82337888: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233788C: 4E800421  bctrl
	ctx.lr = 0x82337890;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82337890: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82337894: 419AFFD4  beq cr6, 0x82337868
	if ctx.cr[6].eq {
	pc = 0x82337868; continue 'dispatch;
	}
            }
            0x82337898 => {
    //   block [0x82337898..0x823378B0)
	// 82337898: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233789C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823378A0: 419A0060  beq cr6, 0x82337900
	if ctx.cr[6].eq {
	pc = 0x82337900; continue 'dispatch;
	}
	// 823378A4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823378A8: 40980034  bge cr6, 0x823378dc
	if !ctx.cr[6].lt {
	pc = 0x823378DC; continue 'dispatch;
	}
	// 823378AC: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x823378B0; continue 'dispatch;
            }
            0x823378B0 => {
    //   block [0x823378B0..0x823378DC)
	// 823378B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823378B4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823378B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823378BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823378C0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823378C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823378C8: 4E800421  bctrl
	ctx.lr = 0x823378CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823378CC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823378D0: 2F1E001F  cmpwi cr6, r30, 0x1f
	ctx.cr[6].compare_i32(ctx.r[30].s32, 31, &mut ctx.xer);
	// 823378D4: 4198FFDC  blt cr6, 0x823378b0
	if ctx.cr[6].lt {
	pc = 0x823378B0; continue 'dispatch;
	}
	// 823378D8: 48000020  b 0x823378f8
	pc = 0x823378F8; continue 'dispatch;
            }
            0x823378DC => {
    //   block [0x823378DC..0x823378F8)
	// 823378DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823378E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823378E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823378E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823378EC: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823378F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823378F4: 4E800421  bctrl
	ctx.lr = 0x823378F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823378F8 => {
    //   block [0x823378F8..0x82337900)
	// 823378F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823378FC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82337900; continue 'dispatch;
            }
            0x82337900 => {
    //   block [0x82337900..0x82337924)
	// 82337900: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337908: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 8233790C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82337910: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82337914: 4E800421  bctrl
	ctx.lr = 0x82337918;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82337918: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8233791C: 38211090  addi r1, r1, 0x1090
	ctx.r[1].s64 = ctx.r[1].s64 + 4240;
	// 82337920: 481FD7E4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82337928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82337928 size=1080
    let mut pc: u32 = 0x82337928;
    'dispatch: loop {
        match pc {
            0x82337928 => {
    //   block [0x82337928..0x82337958)
	// 82337928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233792C: 481FD755  bl 0x82535080
	ctx.lr = 0x82337930;
	sub_82535080(ctx, base);
	// 82337930: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82337934: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82337938: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8233793C: 3905FFFF  addi r8, r5, -1
	ctx.r[8].s64 = ctx.r[5].s64 + -1;
	// 82337940: 2F080100  cmpwi cr6, r8, 0x100
	ctx.cr[6].compare_i32(ctx.r[8].s32, 256, &mut ctx.xer);
	// 82337944: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82337948: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8233794C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82337950: 41980008  blt cr6, 0x82337958
	if ctx.cr[6].lt {
	pc = 0x82337958; continue 'dispatch;
	}
	// 82337954: 39000100  li r8, 0x100
	ctx.r[8].s64 = 256;
	pc = 0x82337958; continue 'dispatch;
            }
            0x82337958 => {
    //   block [0x82337958..0x8233797C)
	// 82337958: 7D442A14  add r10, r4, r5
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[5].u64;
	// 8233795C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82337960: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82337964: 894AFFFF  lbz r10, -1(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-1 as u32) ) } as u64;
	// 82337968: 419A0044  beq cr6, 0x823379ac
	if ctx.cr[6].eq {
	pc = 0x823379AC; continue 'dispatch;
	}
	// 8233796C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82337970: 7CC92050  subf r6, r9, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82337974: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82337978: 38E9DFB8  addi r7, r9, -0x2048
	ctx.r[7].s64 = ctx.r[9].s64 + -8264;
	pc = 0x8233797C; continue 'dispatch;
            }
            0x8233797C => {
    //   block [0x8233797C..0x823379AC)
	// 8233797C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82337980: 7C8A38AE  lbzx r4, r10, r7
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82337984: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 82337988: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8233798C: 54AA063E  clrlwi r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82337990: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82337994: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82337998: 7C8648AE  lbzx r4, r6, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8233799C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823379A0: 7C852A78  xor r5, r4, r5
	ctx.r[5].u64 = ctx.r[4].u64 ^ ctx.r[5].u64;
	// 823379A4: 98A90000  stb r5, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 823379A8: 4198FFD4  blt cr6, 0x8233797c
	if ctx.cr[6].lt {
	pc = 0x8233797C; continue 'dispatch;
	}
	pc = 0x823379AC; continue 'dispatch;
            }
            0x823379AC => {
    //   block [0x823379AC..0x82337A24)
	// 823379AC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823379B0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823379B4: 7F885A14  add r28, r8, r11
	ctx.r[28].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 823379B8: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 823379BC: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 823379C0: 40980248  bge cr6, 0x82337c08
	if !ctx.cr[6].lt {
	pc = 0x82337C08; continue 'dispatch;
	}
	// 823379C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823379C8: 39C00002  li r14, 2
	ctx.r[14].s64 = 2;
	// 823379CC: 3B6BE0FC  addi r27, r11, -0x1f04
	ctx.r[27].s64 = ctx.r[11].s64 + -7940;
	// 823379D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823379D4: 39E00003  li r15, 3
	ctx.r[15].s64 = 3;
	// 823379D8: 3B4BE0F4  addi r26, r11, -0x1f0c
	ctx.r[26].s64 = ctx.r[11].s64 + -7948;
	// 823379DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823379E0: 3A000004  li r16, 4
	ctx.r[16].s64 = 4;
	// 823379E4: 3B2BE0EC  addi r25, r11, -0x1f14
	ctx.r[25].s64 = ctx.r[11].s64 + -7956;
	// 823379E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823379EC: 3A200005  li r17, 5
	ctx.r[17].s64 = 5;
	// 823379F0: 3B0BE0E4  addi r24, r11, -0x1f1c
	ctx.r[24].s64 = ctx.r[11].s64 + -7964;
	// 823379F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823379F8: 3AEBE0DC  addi r23, r11, -0x1f24
	ctx.r[23].s64 = ctx.r[11].s64 + -7972;
	// 823379FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82337A00: 3ACBE0D4  addi r22, r11, -0x1f2c
	ctx.r[22].s64 = ctx.r[11].s64 + -7980;
	// 82337A04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82337A08: 3AABE0CC  addi r21, r11, -0x1f34
	ctx.r[21].s64 = ctx.r[11].s64 + -7988;
	// 82337A0C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82337A10: 3A8BE0C4  addi r20, r11, -0x1f3c
	ctx.r[20].s64 = ctx.r[11].s64 + -7996;
	// 82337A14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82337A18: 3A6BE0C0  addi r19, r11, -0x1f40
	ctx.r[19].s64 = ctx.r[11].s64 + -8000;
	// 82337A1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82337A20: 3A4BE0B8  addi r18, r11, -0x1f48
	ctx.r[18].s64 = ctx.r[11].s64 + -8008;
	pc = 0x82337A24; continue 'dispatch;
            }
            0x82337A24 => {
    //   block [0x82337A24..0x82337A98)
	// 82337A24: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337A28: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82337A2C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82337A30: 419A0280  beq cr6, 0x82337cb0
	if ctx.cr[6].eq {
	pc = 0x82337CB0; continue 'dispatch;
	}
	// 82337A34: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 82337A38: 419A0278  beq cr6, 0x82337cb0
	if ctx.cr[6].eq {
	pc = 0x82337CB0; continue 'dispatch;
	}
	// 82337A3C: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 82337A40: 419A0270  beq cr6, 0x82337cb0
	if ctx.cr[6].eq {
	pc = 0x82337CB0; continue 'dispatch;
	}
	// 82337A44: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 82337A48: 419A0268  beq cr6, 0x82337cb0
	if ctx.cr[6].eq {
	pc = 0x82337CB0; continue 'dispatch;
	}
	// 82337A4C: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 82337A50: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82337A54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337A58: 481FB739  bl 0x82533190
	ctx.lr = 0x82337A5C;
	sub_82533190(ctx, base);
	// 82337A5C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82337A60: 409A0104  bne cr6, 0x82337b64
	if !ctx.cr[6].eq {
	pc = 0x82337B64; continue 'dispatch;
	}
	// 82337A64: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 82337A68: 397F0003  addi r11, r31, 3
	ctx.r[11].s64 = ctx.r[31].s64 + 3;
	// 82337A6C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82337A70: 41990028  bgt cr6, 0x82337a98
	if ctx.cr[6].gt {
	pc = 0x82337A98; continue 'dispatch;
	}
	// 82337A74: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82337A78: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82337A7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337A80: 481FB711  bl 0x82533190
	ctx.lr = 0x82337A84;
	sub_82533190(ctx, base);
	// 82337A84: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82337A88: 409A0010  bne cr6, 0x82337a98
	if !ctx.cr[6].eq {
	pc = 0x82337A98; continue 'dispatch;
	}
	// 82337A8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82337A90: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82337A94: 4800005C  b 0x82337af0
	pc = 0x82337AF0; continue 'dispatch;
            }
            0x82337A98 => {
    //   block [0x82337A98..0x82337AC4)
	// 82337A98: 397F0006  addi r11, r31, 6
	ctx.r[11].s64 = ctx.r[31].s64 + 6;
	// 82337A9C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82337AA0: 41990024  bgt cr6, 0x82337ac4
	if ctx.cr[6].gt {
	pc = 0x82337AC4; continue 'dispatch;
	}
	// 82337AA4: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 82337AA8: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82337AAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337AB0: 481FB6E1  bl 0x82533190
	ctx.lr = 0x82337AB4;
	sub_82533190(ctx, base);
	// 82337AB4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82337AB8: 409A000C  bne cr6, 0x82337ac4
	if !ctx.cr[6].eq {
	pc = 0x82337AC4; continue 'dispatch;
	}
	// 82337ABC: 91DE0000  stw r14, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[14].u32 ) };
	// 82337AC0: 48000030  b 0x82337af0
	pc = 0x82337AF0; continue 'dispatch;
            }
            0x82337AC4 => {
    //   block [0x82337AC4..0x82337AEC)
	// 82337AC4: 3BBF0005  addi r29, r31, 5
	ctx.r[29].s64 = ctx.r[31].s64 + 5;
	// 82337AC8: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82337ACC: 41990020  bgt cr6, 0x82337aec
	if ctx.cr[6].gt {
	pc = 0x82337AEC; continue 'dispatch;
	}
	// 82337AD0: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 82337AD4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82337AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337ADC: 481FB6B5  bl 0x82533190
	ctx.lr = 0x82337AE0;
	sub_82533190(ctx, base);
	// 82337AE0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82337AE4: 409A0030  bne cr6, 0x82337b14
	if !ctx.cr[6].eq {
	pc = 0x82337B14; continue 'dispatch;
	}
	// 82337AE8: 91FE0000  stw r15, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	pc = 0x82337AEC; continue 'dispatch;
            }
            0x82337AEC => {
    //   block [0x82337AEC..0x82337AF0)
	// 82337AEC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82337AF0; continue 'dispatch;
            }
            0x82337AF0 => {
    //   block [0x82337AF0..0x82337AF8)
	// 82337AF0: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82337AF4: 40980114  bge cr6, 0x82337c08
	if !ctx.cr[6].lt {
	pc = 0x82337C08; continue 'dispatch;
	}
	pc = 0x82337AF8; continue 'dispatch;
            }
            0x82337AF8 => {
    //   block [0x82337AF8..0x82337B14)
	// 82337AF8: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337AFC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82337B00: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 82337B04: 419A01B0  beq cr6, 0x82337cb4
	if ctx.cr[6].eq {
	pc = 0x82337CB4; continue 'dispatch;
	}
	// 82337B08: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82337B0C: 4198FFEC  blt cr6, 0x82337af8
	if ctx.cr[6].lt {
	pc = 0x82337AF8; continue 'dispatch;
	}
	// 82337B10: 480000F8  b 0x82337c08
	pc = 0x82337C08; continue 'dispatch;
            }
            0x82337B14 => {
    //   block [0x82337B14..0x82337B3C)
	// 82337B14: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82337B18: 4199FFD4  bgt cr6, 0x82337aec
	if ctx.cr[6].gt {
	pc = 0x82337AEC; continue 'dispatch;
	}
	// 82337B1C: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 82337B20: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82337B24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337B28: 481FB669  bl 0x82533190
	ctx.lr = 0x82337B2C;
	sub_82533190(ctx, base);
	// 82337B2C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82337B30: 409A000C  bne cr6, 0x82337b3c
	if !ctx.cr[6].eq {
	pc = 0x82337B3C; continue 'dispatch;
	}
	// 82337B34: 921E0000  stw r16, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[16].u32 ) };
	// 82337B38: 4BFFFFB4  b 0x82337aec
	pc = 0x82337AEC; continue 'dispatch;
            }
            0x82337B3C => {
    //   block [0x82337B3C..0x82337B64)
	// 82337B3C: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82337B40: 4199FFAC  bgt cr6, 0x82337aec
	if ctx.cr[6].gt {
	pc = 0x82337AEC; continue 'dispatch;
	}
	// 82337B44: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 82337B48: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82337B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337B50: 481FB641  bl 0x82533190
	ctx.lr = 0x82337B54;
	sub_82533190(ctx, base);
	// 82337B54: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82337B58: 409AFF94  bne cr6, 0x82337aec
	if !ctx.cr[6].eq {
	pc = 0x82337AEC; continue 'dispatch;
	}
	// 82337B5C: 923E0000  stw r17, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 82337B60: 4BFFFF8C  b 0x82337aec
	pc = 0x82337AEC; continue 'dispatch;
            }
            0x82337B64 => {
    //   block [0x82337B64..0x82337B8C)
	// 82337B64: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 82337B68: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82337B6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337B70: 481FB621  bl 0x82533190
	ctx.lr = 0x82337B74;
	sub_82533190(ctx, base);
	// 82337B74: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82337B78: 409A0058  bne cr6, 0x82337bd0
	if !ctx.cr[6].eq {
	pc = 0x82337BD0; continue 'dispatch;
	}
	// 82337B7C: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 82337B80: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82337B84: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82337B88: 40980080  bge cr6, 0x82337c08
	if !ctx.cr[6].lt {
	pc = 0x82337C08; continue 'dispatch;
	}
	pc = 0x82337B8C; continue 'dispatch;
            }
            0x82337B8C => {
    //   block [0x82337B8C..0x82337BD0)
	// 82337B8C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337B90: 7D690774  extsb r9, r11
	ctx.r[9].s64 = ctx.r[11].s8 as i64;
	// 82337B94: 2F090030  cmpwi cr6, r9, 0x30
	ctx.cr[6].compare_i32(ctx.r[9].s32, 48, &mut ctx.xer);
	// 82337B98: 4198FF58  blt cr6, 0x82337af0
	if ctx.cr[6].lt {
	pc = 0x82337AF0; continue 'dispatch;
	}
	// 82337B9C: 2F090039  cmpwi cr6, r9, 0x39
	ctx.cr[6].compare_i32(ctx.r[9].s32, 57, &mut ctx.xer);
	// 82337BA0: 4199FF50  bgt cr6, 0x82337af0
	if ctx.cr[6].gt {
	pc = 0x82337AF0; continue 'dispatch;
	}
	// 82337BA4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337BA8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82337BAC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82337BB0: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82337BB4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82337BB8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82337BBC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82337BC0: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 82337BC4: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82337BC8: 4198FFC4  blt cr6, 0x82337b8c
	if ctx.cr[6].lt {
	pc = 0x82337B8C; continue 'dispatch;
	}
	// 82337BCC: 4800003C  b 0x82337c08
	pc = 0x82337C08; continue 'dispatch;
            }
            0x82337BD0 => {
    //   block [0x82337BD0..0x82337C08)
	// 82337BD0: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 82337BD4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82337BD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337BDC: 481FB5B5  bl 0x82533190
	ctx.lr = 0x82337BE0;
	sub_82533190(ctx, base);
	// 82337BE0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82337BE4: 409A0060  bne cr6, 0x82337c44
	if !ctx.cr[6].eq {
	pc = 0x82337C44; continue 'dispatch;
	}
	// 82337BE8: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 82337BEC: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 82337BF0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82337BF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337BF8: 481FB599  bl 0x82533190
	ctx.lr = 0x82337BFC;
	sub_82533190(ctx, base);
	// 82337BFC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82337C00: 419AFEF0  beq cr6, 0x82337af0
	if ctx.cr[6].eq {
	pc = 0x82337AF0; continue 'dispatch;
	}
	// 82337C04: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x82337C08; continue 'dispatch;
            }
            0x82337C08 => {
    //   block [0x82337C08..0x82337C44)
	// 82337C08: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337C0C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82337C10: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82337C14: 419900CC  bgt cr6, 0x82337ce0
	if ctx.cr[6].gt {
	pc = 0x82337CE0; continue 'dispatch;
	}
	// 82337C18: 3D808233  lis r12, -0x7dcd
	ctx.r[12].s64 = -2110586880;
	// 82337C1C: 398C7C30  addi r12, r12, 0x7c30
	ctx.r[12].s64 = ctx.r[12].s64 + 31792;
	// 82337C20: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82337C24: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82337C28: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82337C2C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x82337CEC; continue 'dispatch;
		},
		1 => {
	pc = 0x82337D24; continue 'dispatch;
		},
		2 => {
	pc = 0x82337D08; continue 'dispatch;
		},
		3 => {
	pc = 0x82337CC0; continue 'dispatch;
		},
		4 => {
	pc = 0x82337D40; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82337C30: 82337CEC  lwz r17, 0x7cec(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(31980 as u32) ) } as u64;
	// 82337C34: 82337D24  lwz r17, 0x7d24(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(32036 as u32) ) } as u64;
	// 82337C38: 82337D08  lwz r17, 0x7d08(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(32008 as u32) ) } as u64;
	// 82337C3C: 82337CC0  lwz r17, 0x7cc0(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(31936 as u32) ) } as u64;
	// 82337C40: 82337D40  lwz r17, 0x7d40(r19)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(32064 as u32) ) } as u64;
            }
            0x82337C44 => {
    //   block [0x82337C44..0x82337C6C)
	// 82337C44: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82337C48: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82337C4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337C50: 481FB541  bl 0x82533190
	ctx.lr = 0x82337C54;
	sub_82533190(ctx, base);
	// 82337C54: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82337C58: 409AFE98  bne cr6, 0x82337af0
	if !ctx.cr[6].eq {
	pc = 0x82337AF0; continue 'dispatch;
	}
	// 82337C5C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82337C60: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82337C64: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82337C68: 4098FFA0  bge cr6, 0x82337c08
	if !ctx.cr[6].lt {
	pc = 0x82337C08; continue 'dispatch;
	}
	pc = 0x82337C6C; continue 'dispatch;
            }
            0x82337C6C => {
    //   block [0x82337C6C..0x82337CB0)
	// 82337C6C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337C70: 7D690774  extsb r9, r11
	ctx.r[9].s64 = ctx.r[11].s8 as i64;
	// 82337C74: 2F090030  cmpwi cr6, r9, 0x30
	ctx.cr[6].compare_i32(ctx.r[9].s32, 48, &mut ctx.xer);
	// 82337C78: 4198FE78  blt cr6, 0x82337af0
	if ctx.cr[6].lt {
	pc = 0x82337AF0; continue 'dispatch;
	}
	// 82337C7C: 2F090039  cmpwi cr6, r9, 0x39
	ctx.cr[6].compare_i32(ctx.r[9].s32, 57, &mut ctx.xer);
	// 82337C80: 4199FE70  bgt cr6, 0x82337af0
	if ctx.cr[6].gt {
	pc = 0x82337AF0; continue 'dispatch;
	}
	// 82337C84: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82337C88: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82337C8C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82337C90: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82337C94: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82337C98: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82337C9C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82337CA0: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 82337CA4: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82337CA8: 4198FFC4  blt cr6, 0x82337c6c
	if ctx.cr[6].lt {
	pc = 0x82337C6C; continue 'dispatch;
	}
	// 82337CAC: 4BFFFF5C  b 0x82337c08
	pc = 0x82337C08; continue 'dispatch;
            }
            0x82337CB0 => {
    //   block [0x82337CB0..0x82337CB4)
	// 82337CB0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	pc = 0x82337CB4; continue 'dispatch;
            }
            0x82337CB4 => {
    //   block [0x82337CB4..0x82337CC0)
	// 82337CB4: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82337CB8: 4198FD6C  blt cr6, 0x82337a24
	if ctx.cr[6].lt {
	pc = 0x82337A24; continue 'dispatch;
	}
	// 82337CBC: 4BFFFF4C  b 0x82337c08
	pc = 0x82337C08; continue 'dispatch;
            }
            0x82337CC0 => {
    //   block [0x82337CC0..0x82337CD8)
	// 82337CC0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337CC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82337CC8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82337CCC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82337CD0: 4198000C  blt cr6, 0x82337cdc
	if ctx.cr[6].lt {
	pc = 0x82337CDC; continue 'dispatch;
	}
	// 82337CD4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	pc = 0x82337CD8; continue 'dispatch;
            }
            0x82337CD8 => {
    //   block [0x82337CD8..0x82337CDC)
	// 82337CD8: 40990008  ble cr6, 0x82337ce0
	if !ctx.cr[6].gt {
	pc = 0x82337CE0; continue 'dispatch;
	}
	pc = 0x82337CDC; continue 'dispatch;
            }
            0x82337CDC => {
    //   block [0x82337CDC..0x82337CE0)
	// 82337CDC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x82337CE0; continue 'dispatch;
            }
            0x82337CE0 => {
    //   block [0x82337CE0..0x82337CEC)
	// 82337CE0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337CE4: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 82337CE8: 481FD3E8  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            0x82337CEC => {
    //   block [0x82337CEC..0x82337D08)
	// 82337CEC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337CF0: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82337CF4: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 82337CF8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82337CFC: 4198FFE0  blt cr6, 0x82337cdc
	if ctx.cr[6].lt {
	pc = 0x82337CDC; continue 'dispatch;
	}
	// 82337D00: 2F0B001D  cmpwi cr6, r11, 0x1d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 29, &mut ctx.xer);
	// 82337D04: 4BFFFFD4  b 0x82337cd8
	pc = 0x82337CD8; continue 'dispatch;
            }
            0x82337D08 => {
    //   block [0x82337D08..0x82337D24)
	// 82337D08: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337D0C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82337D10: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82337D14: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82337D18: 4198FFC4  blt cr6, 0x82337cdc
	if ctx.cr[6].lt {
	pc = 0x82337CDC; continue 'dispatch;
	}
	// 82337D1C: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 82337D20: 4BFFFFB8  b 0x82337cd8
	pc = 0x82337CD8; continue 'dispatch;
            }
            0x82337D24 => {
    //   block [0x82337D24..0x82337D40)
	// 82337D24: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337D28: 396B000A  addi r11, r11, 0xa
	ctx.r[11].s64 = ctx.r[11].s64 + 10;
	// 82337D2C: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 82337D30: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82337D34: 4198FFA8  blt cr6, 0x82337cdc
	if ctx.cr[6].lt {
	pc = 0x82337CDC; continue 'dispatch;
	}
	// 82337D38: 2F0B000B  cmpwi cr6, r11, 0xb
	ctx.cr[6].compare_i32(ctx.r[11].s32, 11, &mut ctx.xer);
	// 82337D3C: 4BFFFF9C  b 0x82337cd8
	pc = 0x82337CD8; continue 'dispatch;
            }
            0x82337D40 => {
    //   block [0x82337D40..0x82337D60)
	// 82337D40: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337D44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82337D48: 409AFF94  bne cr6, 0x82337cdc
	if !ctx.cr[6].eq {
	pc = 0x82337CDC; continue 'dispatch;
	}
	// 82337D4C: 3960001E  li r11, 0x1e
	ctx.r[11].s64 = 30;
	// 82337D50: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337D54: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82337D58: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 82337D5C: 481FD374  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82337D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82337D60 size=24
    let mut pc: u32 = 0x82337D60;
    'dispatch: loop {
        match pc {
            0x82337D60 => {
    //   block [0x82337D60..0x82337D78)
	// 82337D60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82337D64: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 82337D68: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82337D6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337D70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82337D74: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82337D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82337D78 size=24
    let mut pc: u32 = 0x82337D78;
    'dispatch: loop {
        match pc {
            0x82337D78 => {
    //   block [0x82337D78..0x82337D90)
	// 82337D78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82337D7C: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82337D80: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82337D84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82337D88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82337D8C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82337D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82337D90 size=24
    let mut pc: u32 = 0x82337D90;
    'dispatch: loop {
        match pc {
            0x82337D90 => {
    //   block [0x82337D90..0x82337DA8)
	// 82337D90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82337D94: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82337D98: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82337D9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337DA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82337DA4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82337DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82337DA8 size=24
    let mut pc: u32 = 0x82337DA8;
    'dispatch: loop {
        match pc {
            0x82337DA8 => {
    //   block [0x82337DA8..0x82337DC0)
	// 82337DA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82337DAC: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 82337DB0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82337DB4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82337DB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82337DBC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82337DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82337DC0 size=128
    let mut pc: u32 = 0x82337DC0;
    'dispatch: loop {
        match pc {
            0x82337DC0 => {
    //   block [0x82337DC0..0x82337E24)
	// 82337DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82337DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82337DC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82337DCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82337DD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82337DD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82337DD8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82337DDC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82337DE0: 38E00134  li r7, 0x134
	ctx.r[7].s64 = 308;
	// 82337DE4: 393F0014  addi r9, r31, 0x14
	ctx.r[9].s64 = ctx.r[31].s64 + 20;
	// 82337DE8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82337DEC: 391F000C  addi r8, r31, 0xc
	ctx.r[8].s64 = ctx.r[31].s64 + 12;
	// 82337DF0: B0BF0010  sth r5, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[5].u16 ) };
	// 82337DF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82337DF8: 7CEA3B96  divwu r7, r10, r7
	ctx.r[7].u32 = ctx.r[10].u32 / ctx.r[7].u32;
	// 82337DFC: B07F0012  sth r3, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[3].u16 ) };
	// 82337E00: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82337E04: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82337E08: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82337E0C: 480884ED  bl 0x823c02f8
	ctx.lr = 0x82337E10;
	sub_823C02F8(ctx, base);
	// 82337E10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82337E14: 419A0010  beq cr6, 0x82337e24
	if ctx.cr[6].eq {
	pc = 0x82337E24; continue 'dispatch;
	}
	// 82337E18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82337E1C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82337E20: 48000008  b 0x82337e28
	pc = 0x82337E28; continue 'dispatch;
            }
            0x82337E24 => {
    //   block [0x82337E24..0x82337E28)
	// 82337E24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82337E28; continue 'dispatch;
            }
            0x82337E28 => {
    //   block [0x82337E28..0x82337E40)
	// 82337E28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82337E2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82337E30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82337E34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82337E38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82337E3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82337E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82337E40 size=252
    let mut pc: u32 = 0x82337E40;
    'dispatch: loop {
        match pc {
            0x82337E40 => {
    //   block [0x82337E40..0x82337EF0)
	// 82337E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82337E44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82337E48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82337E4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82337E50: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 82337E54: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82337E58: 3BEB4AE8  addi r31, r11, 0x4ae8
	ctx.r[31].s64 = ctx.r[11].s64 + 19176;
	// 82337E5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82337E60: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82337E64: 396BE15C  addi r11, r11, -0x1ea4
	ctx.r[11].s64 = ctx.r[11].s64 + -7844;
	// 82337E68: 394AFEE8  addi r10, r10, -0x118
	ctx.r[10].s64 = ctx.r[10].s64 + -280;
	// 82337E6C: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82337E70: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 82337E74: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82337E78: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82337E7C: 3929E1B0  addi r9, r9, -0x1e50
	ctx.r[9].s64 = ctx.r[9].s64 + -7760;
	// 82337E80: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82337E84: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82337E88: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82337E8C: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82337E90: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82337E94: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82337E98: 913F0024  stw r9, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 82337E9C: 483D53F1  bl 0x8270d28c
	ctx.lr = 0x82337EA0;
	// extern call 0x8270D28C  crate::xboxkrnl::RtlInitializeCriticalSection
	crate::xboxkrnl::RtlInitializeCriticalSection(ctx, base);
	// 82337EA0: 38A01638  li r5, 0x1638
	ctx.r[5].s64 = 5688;
	// 82337EA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82337EA8: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82337EAC: 481FD325  bl 0x825351d0
	ctx.lr = 0x82337EB0;
	sub_825351D0(ctx, base);
	// 82337EB0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82337EB4: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 82337EB8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82337EBC: 387F16A5  addi r3, r31, 0x16a5
	ctx.r[3].s64 = ctx.r[31].s64 + 5797;
	// 82337EC0: 917F16A0  stw r11, 0x16a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5792 as u32), ctx.r[11].u32 ) };
	// 82337EC4: 481FD30D  bl 0x825351d0
	ctx.lr = 0x82337EC8;
	sub_825351D0(ctx, base);
	// 82337EC8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82337ECC: 38A00037  li r5, 0x37
	ctx.r[5].s64 = 55;
	// 82337ED0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82337ED4: 387F16B1  addi r3, r31, 0x16b1
	ctx.r[3].s64 = ctx.r[31].s64 + 5809;
	// 82337ED8: 917F169C  stw r11, 0x169c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5788 as u32), ctx.r[11].u32 ) };
	// 82337EDC: 481FD2F5  bl 0x825351d0
	ctx.lr = 0x82337EE0;
	sub_825351D0(ctx, base);
	// 82337EE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82337EE4: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82337EE8: 397F0044  addi r11, r31, 0x44
	ctx.r[11].s64 = ctx.r[31].s64 + 68;
	// 82337EEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82337EF0; continue 'dispatch;
            }
            0x82337EF0 => {
    //   block [0x82337EF0..0x82337F3C)
	// 82337EF0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82337EF4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82337EF8: 4200FFF8  bdnz 0x82337ef0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82337EF0; continue 'dispatch;
	}
	// 82337EFC: B12B0000  sth r9, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 82337F00: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82337F04: 992B0002  stb r9, 2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[9].u8 ) };
	// 82337F08: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82337F0C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82337F10: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82337F14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82337F18: 997F16A4  stb r11, 0x16a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(5796 as u32), ctx.r[11].u8 ) };
	// 82337F1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82337F20: 4E800421  bctrl
	ctx.lr = 0x82337F24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82337F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337F28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82337F2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82337F30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82337F34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82337F38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82337F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82337F40 size=164
    let mut pc: u32 = 0x82337F40;
    'dispatch: loop {
        match pc {
            0x82337F40 => {
    //   block [0x82337F40..0x82337FA0)
	// 82337F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82337F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82337F48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82337F4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82337F50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82337F54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82337F58: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82337F5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82337F60: 419A0060  beq cr6, 0x82337fc0
	if ctx.cr[6].eq {
	pc = 0x82337FC0; continue 'dispatch;
	}
	// 82337F64: 2B1E0150  cmplwi cr6, r30, 0x150
	ctx.cr[6].compare_u32(ctx.r[30].u32, 336 as u32, &mut ctx.xer);
	// 82337F68: 41980058  blt cr6, 0x82337fc0
	if ctx.cr[6].lt {
	pc = 0x82337FC0; continue 'dispatch;
	}
	// 82337F6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82337F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337F74: 481FD25D  bl 0x825351d0
	ctx.lr = 0x82337F78;
	sub_825351D0(ctx, base);
	// 82337F78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82337F7C: 393EFFE4  addi r9, r30, -0x1c
	ctx.r[9].s64 = ctx.r[30].s64 + -28;
	// 82337F80: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82337F84: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82337F88: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 82337F8C: B15F0012  sth r10, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[10].u16 ) };
	// 82337F90: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82337F94: B17F0010  sth r11, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82337F98: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82337F9C: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	pc = 0x82337FA0; continue 'dispatch;
            }
            0x82337FA0 => {
    //   block [0x82337FA0..0x82337FC0)
	// 82337FA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82337FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82337FA8: 4BFFFE19  bl 0x82337dc0
	ctx.lr = 0x82337FAC;
	sub_82337DC0(ctx, base);
	// 82337FAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82337FB0: 409A002C  bne cr6, 0x82337fdc
	if !ctx.cr[6].eq {
	pc = 0x82337FDC; continue 'dispatch;
	}
	// 82337FB4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82337FB8: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 82337FBC: 4198FFE4  blt cr6, 0x82337fa0
	if ctx.cr[6].lt {
	pc = 0x82337FA0; continue 'dispatch;
	}
	pc = 0x82337FC0; continue 'dispatch;
            }
            0x82337FC0 => {
    //   block [0x82337FC0..0x82337FC4)
	// 82337FC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82337FC4; continue 'dispatch;
            }
            0x82337FC4 => {
    //   block [0x82337FC4..0x82337FDC)
	// 82337FC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82337FC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82337FCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82337FD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82337FD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82337FD8: 4E800020  blr
	return;
            }
            0x82337FDC => {
    //   block [0x82337FDC..0x82337FE4)
	// 82337FDC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82337FE0: 4BFFFFE4  b 0x82337fc4
	pc = 0x82337FC4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82337FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82337FE8 size=272
    let mut pc: u32 = 0x82337FE8;
    'dispatch: loop {
        match pc {
            0x82337FE8 => {
    //   block [0x82337FE8..0x82338004)
	// 82337FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82337FEC: 481FD0C9  bl 0x825350b4
	ctx.lr = 0x82337FF0;
	sub_82535080(ctx, base);
	// 82337FF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82337FF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82337FF8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82337FFC: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82338000: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	pc = 0x82338004; continue 'dispatch;
            }
            0x82338004 => {
    //   block [0x82338004..0x82338050)
	// 82338004: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82338008: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 8233800C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82338010: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 82338014: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82338018: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8233801C: 419900A0  bgt cr6, 0x823380bc
	if ctx.cr[6].gt {
	pc = 0x823380BC; continue 'dispatch;
	}
	// 82338020: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82338024: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82338028: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8233802C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82338030: 389F001C  addi r4, r31, 0x1c
	ctx.r[4].s64 = ctx.r[31].s64 + 28;
	// 82338034: 48088EE5  bl 0x823c0f18
	ctx.lr = 0x82338038;
	sub_823C0F18(ctx, base);
	// 82338038: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233803C: 419A00A8  beq cr6, 0x823380e4
	if ctx.cr[6].eq {
	pc = 0x823380E4; continue 'dispatch;
	}
	// 82338040: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82338044: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82338048: 419A0008  beq cr6, 0x82338050
	if ctx.cr[6].eq {
	pc = 0x82338050; continue 'dispatch;
	}
	// 8233804C: 4808890D  bl 0x823c0958
	ctx.lr = 0x82338050;
	sub_823C0958(ctx, base);
	pc = 0x82338050; continue 'dispatch;
            }
            0x82338050 => {
    //   block [0x82338050..0x82338074)
	// 82338050: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82338054: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82338058: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8233805C: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82338060: B3BF0010  sth r29, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u16 ) };
	// 82338064: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82338068: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 8233806C: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82338070: 40980038  bge cr6, 0x823380a8
	if !ctx.cr[6].lt {
	pc = 0x823380A8; continue 'dispatch;
	}
	pc = 0x82338074; continue 'dispatch;
            }
            0x82338074 => {
    //   block [0x82338074..0x823380A4)
	// 82338074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82338078: A09F0012  lhz r4, 0x12(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 8233807C: 4BFFFD45  bl 0x82337dc0
	ctx.lr = 0x82338080;
	sub_82337DC0(ctx, base);
	// 82338080: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82338084: 409A0020  bne cr6, 0x823380a4
	if !ctx.cr[6].eq {
	pc = 0x823380A4; continue 'dispatch;
	}
	// 82338088: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 8233808C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82338090: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82338094: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82338098: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 8233809C: 4198FFD8  blt cr6, 0x82338074
	if ctx.cr[6].lt {
	pc = 0x82338074; continue 'dispatch;
	}
	// 823380A0: 48000008  b 0x823380a8
	pc = 0x823380A8; continue 'dispatch;
            }
            0x823380A4 => {
    //   block [0x823380A4..0x823380A8)
	// 823380A4: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	pc = 0x823380A8; continue 'dispatch;
            }
            0x823380A8 => {
    //   block [0x823380A8..0x823380BC)
	// 823380A8: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 823380AC: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 823380B0: 4098003C  bge cr6, 0x823380ec
	if !ctx.cr[6].lt {
	pc = 0x823380EC; continue 'dispatch;
	}
	// 823380B4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823380B8: 409AFF4C  bne cr6, 0x82338004
	if !ctx.cr[6].eq {
	pc = 0x82338004; continue 'dispatch;
	}
	pc = 0x823380BC; continue 'dispatch;
            }
            0x823380BC => {
    //   block [0x823380BC..0x823380E4)
	// 823380BC: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823380C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823380C4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823380C8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823380CC: 1D4A0134  mulli r10, r10, 0x134
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 308 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823380D0: B17F0010  sth r11, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 823380D4: 7D6AFA14  add r11, r10, r31
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 823380D8: 386B001C  addi r3, r11, 0x1c
	ctx.r[3].s64 = ctx.r[11].s64 + 28;
	// 823380DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823380E0: 481FD024  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x823380E4 => {
    //   block [0x823380E4..0x823380EC)
	// 823380E4: B3BF0010  sth r29, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u16 ) };
	// 823380E8: 4BFFFFD4  b 0x823380bc
	pc = 0x823380BC; continue 'dispatch;
            }
            0x823380EC => {
    //   block [0x823380EC..0x823380F8)
	// 823380EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823380F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823380F4: 481FD010  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823380F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823380F8 size=308
    let mut pc: u32 = 0x823380F8;
    'dispatch: loop {
        match pc {
            0x823380F8 => {
    //   block [0x823380F8..0x82338120)
	// 823380F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823380FC: 481FCFA9  bl 0x825350a4
	ctx.lr = 0x82338100;
	sub_82535080(ctx, base);
	// 82338100: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82338104: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82338108: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 8233810C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82338110: 409A0010  bne cr6, 0x82338120
	if !ctx.cr[6].eq {
	pc = 0x82338120; continue 'dispatch;
	}
	// 82338114: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82338118: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 8233811C: 481FCFD8  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            0x82338120 => {
    //   block [0x82338120..0x8233813C)
	// 82338120: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82338124: 3F008000  lis r24, -0x8000
	ctx.r[24].s64 = -2147483648;
	// 82338128: 3B6BE10C  addi r27, r11, -0x1ef4
	ctx.r[27].s64 = ctx.r[11].s64 + -7924;
	// 8233812C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82338130: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82338134: 3B8BE104  addi r28, r11, -0x1efc
	ctx.r[28].s64 = ctx.r[11].s64 + -7932;
	// 82338138: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	pc = 0x8233813C; continue 'dispatch;
            }
            0x8233813C => {
    //   block [0x8233813C..0x823381EC)
	// 8233813C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82338140: 4BFFFEA9  bl 0x82337fe8
	ctx.lr = 0x82338144;
	sub_82337FE8(ctx, base);
	// 82338144: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82338148: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8233814C: 419A00D4  beq cr6, 0x82338220
	if ctx.cr[6].eq {
	pc = 0x82338220; continue 'dispatch;
	}
	// 82338150: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82338154: A07D0012  lhz r3, 0x12(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82338158: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8233815C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 82338160: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82338164: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82338168: 48088221  bl 0x823c0388
	ctx.lr = 0x8233816C;
	sub_823C0388(ctx, base);
	// 8233816C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82338170: 409A00A0  bne cr6, 0x82338210
	if !ctx.cr[6].eq {
	pc = 0x82338210; continue 'dispatch;
	}
	// 82338174: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82338178: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 8233817C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 82338180: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82338184: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82338188: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8233818C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82338190: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82338194: 480884F5  bl 0x823c0688
	ctx.lr = 0x82338198;
	sub_823C0688(ctx, base);
	// 82338198: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233819C: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 823381A0: 419A004C  beq cr6, 0x823381ec
	if ctx.cr[6].eq {
	pc = 0x823381EC; continue 'dispatch;
	}
	// 823381A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823381A8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823381AC: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 823381B0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823381B4: 4808821D  bl 0x823c03d0
	ctx.lr = 0x823381B8;
	sub_823C03D0(ctx, base);
	// 823381B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823381BC: 4808879D  bl 0x823c0958
	ctx.lr = 0x823381C0;
	sub_823C0958(ctx, base);
	// 823381C0: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823381C4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823381C8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823381CC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 823381D0: 7F4559AE  stbx r26, r5, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[26].u8) };
	// 823381D4: 4BFFF755  bl 0x82337928
	ctx.lr = 0x823381D8;
	sub_82337928(ctx, base);
	// 823381D8: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 823381DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823381E0: 419A0010  beq cr6, 0x823381f0
	if ctx.cr[6].eq {
	pc = 0x823381F0; continue 'dispatch;
	}
	// 823381E4: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 823381E8: 48000008  b 0x823381f0
	pc = 0x823381F0; continue 'dispatch;
            }
            0x823381EC => {
    //   block [0x823381EC..0x823381F0)
	// 823381EC: 933D0018  stw r25, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[25].u32 ) };
	pc = 0x823381F0; continue 'dispatch;
            }
            0x823381F0 => {
    //   block [0x823381F0..0x82338210)
	// 823381F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823381F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823381F8: 480880E9  bl 0x823c02e0
	ctx.lr = 0x823381FC;
	sub_823C02E0(ctx, base);
	// 823381FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82338200: 419AFF3C  beq cr6, 0x8233813c
	if ctx.cr[6].eq {
	pc = 0x8233813C; continue 'dispatch;
	}
	// 82338204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82338208: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 8233820C: 481FCEE8  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            0x82338210 => {
    //   block [0x82338210..0x82338220)
	// 82338210: 2B030570  cmplwi cr6, r3, 0x570
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1392 as u32, &mut ctx.xer);
	// 82338214: 409AFF28  bne cr6, 0x8233813c
	if !ctx.cr[6].eq {
	pc = 0x8233813C; continue 'dispatch;
	}
	// 82338218: 933D0018  stw r25, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[25].u32 ) };
	// 8233821C: 4BFFFF20  b 0x8233813c
	pc = 0x8233813C; continue 'dispatch;
            }
            0x82338220 => {
    //   block [0x82338220..0x8233822C)
	// 82338220: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82338224: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 82338228: 481FCECC  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82338230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82338230 size=100
    let mut pc: u32 = 0x82338230;
    'dispatch: loop {
        match pc {
            0x82338230 => {
    //   block [0x82338230..0x82338264)
	// 82338230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82338234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82338238: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233823C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82338240: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82338244: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82338248: 409A001C  bne cr6, 0x82338264
	if !ctx.cr[6].eq {
	pc = 0x82338264; continue 'dispatch;
	}
	// 8233824C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82338250: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82338254: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82338258: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233825C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82338260: 4E800020  blr
	return;
            }
            0x82338264 => {
    //   block [0x82338264..0x82338274)
	// 82338264: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82338268: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 8233826C: 419A0008  beq cr6, 0x82338274
	if ctx.cr[6].eq {
	pc = 0x82338274; continue 'dispatch;
	}
	// 82338270: 480886E9  bl 0x823c0958
	ctx.lr = 0x82338274;
	sub_823C0958(ctx, base);
	pc = 0x82338274; continue 'dispatch;
            }
            0x82338274 => {
    //   block [0x82338274..0x82338294)
	// 82338274: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82338278: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8233827C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82338280: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82338284: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82338288: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233828C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82338290: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82338298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82338298 size=32
    let mut pc: u32 = 0x82338298;
    'dispatch: loop {
        match pc {
            0x82338298 => {
    //   block [0x82338298..0x823382B8)
	// 82338298: 2B04001E  cmplwi cr6, r4, 0x1e
	ctx.cr[6].compare_u32(ctx.r[4].u32, 30 as u32, &mut ctx.xer);
	// 8233829C: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
	// 823382A0: 3964FFF4  addi r11, r4, -0xc
	ctx.r[11].s64 = ctx.r[4].s64 + -12;
	// 823382A4: 2B0B0011  cmplwi cr6, r11, 0x11
	ctx.cr[6].compare_u32(ctx.r[11].u32, 17 as u32, &mut ctx.xer);
	// 823382A8: 40990010  ble cr6, 0x823382b8
	if !ctx.cr[6].gt {
		sub_823382B8(ctx, base);
		return;
	}
	// 823382AC: 7D441A14  add r10, r4, r3
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[3].u64;
	// 823382B0: 98AA0044  stb r5, 0x44(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(68 as u32), ctx.r[5].u8 ) };
	// 823382B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823382B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823382B8 size=36
    let mut pc: u32 = 0x823382B8;
    'dispatch: loop {
        match pc {
            0x823382B8 => {
    //   block [0x823382B8..0x823382DC)
	// 823382B8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 823382BC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 823382C0: 1D64013C  mulli r11, r4, 0x13c
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 316 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823382C4: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 823382C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823382CC: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 823382D0: 994BF2A0  stb r10, -0xd60(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-3424 as u32), ctx.r[10].u8 ) };
	// 823382D4: 912BF2CC  stw r9, -0xd34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-3380 as u32), ctx.r[9].u32 ) };
	// 823382D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823382E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823382E0 size=16
    let mut pc: u32 = 0x823382E0;
    'dispatch: loop {
        match pc {
            0x823382E0 => {
    //   block [0x823382E0..0x823382F0)
	// 823382E0: 2B04001E  cmplwi cr6, r4, 0x1e
	ctx.cr[6].compare_u32(ctx.r[4].u32, 30 as u32, &mut ctx.xer);
	// 823382E4: 4099000C  ble cr6, 0x823382f0
	if !ctx.cr[6].gt {
		sub_823382F0(ctx, base);
		return;
	}
	// 823382E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823382EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823382F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823382F0 size=32
    let mut pc: u32 = 0x823382F0;
    'dispatch: loop {
        match pc {
            0x823382F0 => {
    //   block [0x823382F0..0x82338310)
	// 823382F0: 2F040002  cmpwi cr6, r4, 2
	ctx.cr[6].compare_i32(ctx.r[4].s32, 2, &mut ctx.xer);
	// 823382F4: 419A0040  beq cr6, 0x82338334
	if ctx.cr[6].eq {
		sub_82338310(ctx, base);
		return;
	}
	// 823382F8: 3964FFF4  addi r11, r4, -0xc
	ctx.r[11].s64 = ctx.r[4].s64 + -12;
	// 823382FC: 2B0B0011  cmplwi cr6, r11, 0x11
	ctx.cr[6].compare_u32(ctx.r[11].u32, 17 as u32, &mut ctx.xer);
	// 82338300: 40990010  ble cr6, 0x82338310
	if !ctx.cr[6].gt {
		sub_82338310(ctx, base);
		return;
	}
	// 82338304: 7D641A14  add r11, r4, r3
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[3].u64;
	// 82338308: 886B0044  lbz r3, 0x44(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 8233830C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


