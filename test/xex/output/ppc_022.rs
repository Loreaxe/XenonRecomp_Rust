pub fn sub_822DFA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DFA00 size=72
    let mut pc: u32 = 0x822DFA00;
    'dispatch: loop {
        match pc {
            0x822DFA00 => {
    //   block [0x822DFA00..0x822DFA14)
	// 822DFA00: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFA04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DFA08: 409A000C  bne cr6, 0x822dfa14
	if !ctx.cr[6].eq {
	pc = 0x822DFA14; continue 'dispatch;
	}
	// 822DFA0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFA10: 48000020  b 0x822dfa30
	pc = 0x822DFA30; continue 'dispatch;
            }
            0x822DFA14 => {
    //   block [0x822DFA14..0x822DFA2C)
	// 822DFA14: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFA18: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DFA1C: 7D2B4851  subf. r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822DFA20: 4082000C  bne 0x822dfa2c
	if !ctx.cr[0].eq {
	pc = 0x822DFA2C; continue 'dispatch;
	}
	// 822DFA24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFA28: 48000008  b 0x822dfa30
	pc = 0x822DFA30; continue 'dispatch;
            }
            0x822DFA2C => {
    //   block [0x822DFA2C..0x822DFA30)
	// 822DFA2C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	pc = 0x822DFA30; continue 'dispatch;
            }
            0x822DFA30 => {
    //   block [0x822DFA30..0x822DFA48)
	// 822DFA30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DFA34: 409A0014  bne cr6, 0x822dfa48
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x822DFA48);
		return;
	}
	// 822DFA38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822DFA3C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DFA40: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822DFA44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFA68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DFA68 size=716
    let mut pc: u32 = 0x822DFA68;
    'dispatch: loop {
        match pc {
            0x822DFA68 => {
    //   block [0x822DFA68..0x822DFA90)
	// 822DFA68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DFA6C: 48255651  bl 0x825350bc
	ctx.lr = 0x822DFA70;
	sub_82535080(ctx, base);
	// 822DFA70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DFA74: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFA78: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822DFA7C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822DFA80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DFA84: 409A000C  bne cr6, 0x822dfa90
	if !ctx.cr[6].eq {
	pc = 0x822DFA90; continue 'dispatch;
	}
	// 822DFA88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFA8C: 48000020  b 0x822dfaac
	pc = 0x822DFAAC; continue 'dispatch;
            }
            0x822DFA90 => {
    //   block [0x822DFA90..0x822DFAA8)
	// 822DFA90: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFA94: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DFA98: 7D2B4851  subf. r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822DFA9C: 4082000C  bne 0x822dfaa8
	if !ctx.cr[0].eq {
	pc = 0x822DFAA8; continue 'dispatch;
	}
	// 822DFAA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFAA4: 48000008  b 0x822dfaac
	pc = 0x822DFAAC; continue 'dispatch;
            }
            0x822DFAA8 => {
    //   block [0x822DFAA8..0x822DFAAC)
	// 822DFAA8: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	pc = 0x822DFAAC; continue 'dispatch;
            }
            0x822DFAAC => {
    //   block [0x822DFAAC..0x822DFAC8)
	// 822DFAAC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DFAB0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DFAB4: 40980274  bge cr6, 0x822dfd28
	if !ctx.cr[6].lt {
	pc = 0x822DFD28; continue 'dispatch;
	}
	// 822DFAB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DFABC: 409A000C  bne cr6, 0x822dfac8
	if !ctx.cr[6].eq {
	pc = 0x822DFAC8; continue 'dispatch;
	}
	// 822DFAC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFAC4: 48000020  b 0x822dfae4
	pc = 0x822DFAE4; continue 'dispatch;
            }
            0x822DFAC8 => {
    //   block [0x822DFAC8..0x822DFAE0)
	// 822DFAC8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFACC: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DFAD0: 7D2B4851  subf. r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822DFAD4: 4082000C  bne 0x822dfae0
	if !ctx.cr[0].eq {
	pc = 0x822DFAE0; continue 'dispatch;
	}
	// 822DFAD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFADC: 48000008  b 0x822dfae4
	pc = 0x822DFAE4; continue 'dispatch;
            }
            0x822DFAE0 => {
    //   block [0x822DFAE0..0x822DFAE4)
	// 822DFAE0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	pc = 0x822DFAE4; continue 'dispatch;
            }
            0x822DFAE4 => {
    //   block [0x822DFAE4..0x822DFB00)
	// 822DFAE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFAE8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822DFAEC: 409A0040  bne cr6, 0x822dfb2c
	if !ctx.cr[6].eq {
	pc = 0x822DFB2C; continue 'dispatch;
	}
	// 822DFAF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DFAF4: 409A000C  bne cr6, 0x822dfb00
	if !ctx.cr[6].eq {
	pc = 0x822DFB00; continue 'dispatch;
	}
	// 822DFAF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFAFC: 48000020  b 0x822dfb1c
	pc = 0x822DFB1C; continue 'dispatch;
            }
            0x822DFB00 => {
    //   block [0x822DFB00..0x822DFB18)
	// 822DFB00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFB04: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DFB08: 7D2B4851  subf. r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822DFB0C: 4082000C  bne 0x822dfb18
	if !ctx.cr[0].eq {
	pc = 0x822DFB18; continue 'dispatch;
	}
	// 822DFB10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFB14: 48000008  b 0x822dfb1c
	pc = 0x822DFB1C; continue 'dispatch;
            }
            0x822DFB18 => {
    //   block [0x822DFB18..0x822DFB1C)
	// 822DFB18: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	pc = 0x822DFB1C; continue 'dispatch;
            }
            0x822DFB1C => {
    //   block [0x822DFB1C..0x822DFB2C)
	// 822DFB1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFB20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DFB24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822DFB28: 419A0008  beq cr6, 0x822dfb30
	if ctx.cr[6].eq {
	pc = 0x822DFB30; continue 'dispatch;
	}
	pc = 0x822DFB2C; continue 'dispatch;
            }
            0x822DFB2C => {
    //   block [0x822DFB2C..0x822DFB30)
	// 822DFB2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822DFB30; continue 'dispatch;
            }
            0x822DFB30 => {
    //   block [0x822DFB30..0x822DFB80)
	// 822DFB30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822DFB34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DFB38: 419A005C  beq cr6, 0x822dfb94
	if ctx.cr[6].eq {
	pc = 0x822DFB94; continue 'dispatch;
	}
	// 822DFB3C: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 822DFB40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DFB44: 419A003C  beq cr6, 0x822dfb80
	if ctx.cr[6].eq {
	pc = 0x822DFB80; continue 'dispatch;
	}
	// 822DFB48: 4BFFFEB9  bl 0x822dfa00
	ctx.lr = 0x822DFB4C;
	sub_822DFA00(ctx, base);
	// 822DFB4C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822DFB50: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822DFB54: 396BC11C  addi r11, r11, -0x3ee4
	ctx.r[11].s64 = ctx.r[11].s64 + -16100;
	// 822DFB58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DFB5C: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DFB60: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 822DFB64: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DFB68: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 822DFB6C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822DFB70: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822DFB74: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822DFB78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DFB7C: 48255590  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x822DFB80 => {
    //   block [0x822DFB80..0x822DFB94)
	// 822DFB80: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822DFB84: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822DFB88: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822DFB8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DFB90: 4825557C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x822DFB94 => {
    //   block [0x822DFB94..0x822DFBA4)
	// 822DFB94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DFB98: 409A000C  bne cr6, 0x822dfba4
	if !ctx.cr[6].eq {
	pc = 0x822DFBA4; continue 'dispatch;
	}
	// 822DFB9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFBA0: 48000020  b 0x822dfbc0
	pc = 0x822DFBC0; continue 'dispatch;
            }
            0x822DFBA4 => {
    //   block [0x822DFBA4..0x822DFBBC)
	// 822DFBA4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFBA8: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DFBAC: 7D2B4851  subf. r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822DFBB0: 4082000C  bne 0x822dfbbc
	if !ctx.cr[0].eq {
	pc = 0x822DFBBC; continue 'dispatch;
	}
	// 822DFBB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFBB8: 48000008  b 0x822dfbc0
	pc = 0x822DFBC0; continue 'dispatch;
            }
            0x822DFBBC => {
    //   block [0x822DFBBC..0x822DFBC0)
	// 822DFBBC: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	pc = 0x822DFBC0; continue 'dispatch;
            }
            0x822DFBC0 => {
    //   block [0x822DFBC0..0x822DFBDC)
	// 822DFBC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFBC4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822DFBC8: 409A0040  bne cr6, 0x822dfc08
	if !ctx.cr[6].eq {
	pc = 0x822DFC08; continue 'dispatch;
	}
	// 822DFBCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DFBD0: 409A000C  bne cr6, 0x822dfbdc
	if !ctx.cr[6].eq {
	pc = 0x822DFBDC; continue 'dispatch;
	}
	// 822DFBD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFBD8: 48000020  b 0x822dfbf8
	pc = 0x822DFBF8; continue 'dispatch;
            }
            0x822DFBDC => {
    //   block [0x822DFBDC..0x822DFBF4)
	// 822DFBDC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFBE0: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DFBE4: 7D2B4851  subf. r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822DFBE8: 4082000C  bne 0x822dfbf4
	if !ctx.cr[0].eq {
	pc = 0x822DFBF4; continue 'dispatch;
	}
	// 822DFBEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFBF0: 48000008  b 0x822dfbf8
	pc = 0x822DFBF8; continue 'dispatch;
            }
            0x822DFBF4 => {
    //   block [0x822DFBF4..0x822DFBF8)
	// 822DFBF4: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	pc = 0x822DFBF8; continue 'dispatch;
            }
            0x822DFBF8 => {
    //   block [0x822DFBF8..0x822DFC08)
	// 822DFBF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFBFC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822DFC00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822DFC04: 419A0008  beq cr6, 0x822dfc0c
	if ctx.cr[6].eq {
	pc = 0x822DFC0C; continue 'dispatch;
	}
	pc = 0x822DFC08; continue 'dispatch;
            }
            0x822DFC08 => {
    //   block [0x822DFC08..0x822DFC0C)
	// 822DFC08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822DFC0C; continue 'dispatch;
            }
            0x822DFC0C => {
    //   block [0x822DFC0C..0x822DFC18)
	// 822DFC0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822DFC10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DFC14: 419A0054  beq cr6, 0x822dfc68
	if ctx.cr[6].eq {
	pc = 0x822DFC68; continue 'dispatch;
	}
	pc = 0x822DFC18; continue 'dispatch;
            }
            0x822DFC18 => {
    //   block [0x822DFC18..0x822DFC54)
	// 822DFC18: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 822DFC1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DFC20: 419A0034  beq cr6, 0x822dfc54
	if ctx.cr[6].eq {
	pc = 0x822DFC54; continue 'dispatch;
	}
	// 822DFC24: 4BFFFDDD  bl 0x822dfa00
	ctx.lr = 0x822DFC28;
	sub_822DFA00(ctx, base);
	// 822DFC28: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822DFC2C: 1D7E002C  mulli r11, r30, 0x2c
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822DFC30: 394AC130  addi r10, r10, -0x3ed0
	ctx.r[10].s64 = ctx.r[10].s64 + -16080;
	// 822DFC34: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 822DFC38: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 822DFC3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822DFC40: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822DFC44: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822DFC48: 913D0000  stw r9, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DFC4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DFC50: 482554BC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x822DFC54 => {
    //   block [0x822DFC54..0x822DFC68)
	// 822DFC54: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822DFC58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822DFC5C: 913D0000  stw r9, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DFC60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DFC64: 482554A8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x822DFC68 => {
    //   block [0x822DFC68..0x822DFC78)
	// 822DFC68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DFC6C: 409A000C  bne cr6, 0x822dfc78
	if !ctx.cr[6].eq {
	pc = 0x822DFC78; continue 'dispatch;
	}
	// 822DFC70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFC74: 48000020  b 0x822dfc94
	pc = 0x822DFC94; continue 'dispatch;
            }
            0x822DFC78 => {
    //   block [0x822DFC78..0x822DFC90)
	// 822DFC78: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFC7C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DFC80: 7D2B4851  subf. r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822DFC84: 4082000C  bne 0x822dfc90
	if !ctx.cr[0].eq {
	pc = 0x822DFC90; continue 'dispatch;
	}
	// 822DFC88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFC8C: 48000008  b 0x822dfc94
	pc = 0x822DFC94; continue 'dispatch;
            }
            0x822DFC90 => {
    //   block [0x822DFC90..0x822DFC94)
	// 822DFC90: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	pc = 0x822DFC94; continue 'dispatch;
            }
            0x822DFC94 => {
    //   block [0x822DFC94..0x822DFCB0)
	// 822DFC94: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFC98: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822DFC9C: 4199007C  bgt cr6, 0x822dfd18
	if ctx.cr[6].gt {
	pc = 0x822DFD18; continue 'dispatch;
	}
	// 822DFCA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DFCA4: 409A000C  bne cr6, 0x822dfcb0
	if !ctx.cr[6].eq {
	pc = 0x822DFCB0; continue 'dispatch;
	}
	// 822DFCA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFCAC: 48000020  b 0x822dfccc
	pc = 0x822DFCCC; continue 'dispatch;
            }
            0x822DFCB0 => {
    //   block [0x822DFCB0..0x822DFCC8)
	// 822DFCB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFCB4: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DFCB8: 7D2B4851  subf. r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822DFCBC: 4082000C  bne 0x822dfcc8
	if !ctx.cr[0].eq {
	pc = 0x822DFCC8; continue 'dispatch;
	}
	// 822DFCC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFCC4: 48000008  b 0x822dfccc
	pc = 0x822DFCCC; continue 'dispatch;
            }
            0x822DFCC8 => {
    //   block [0x822DFCC8..0x822DFCCC)
	// 822DFCC8: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	pc = 0x822DFCCC; continue 'dispatch;
            }
            0x822DFCCC => {
    //   block [0x822DFCCC..0x822DFCE8)
	// 822DFCCC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFCD0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822DFCD4: 409A003C  bne cr6, 0x822dfd10
	if !ctx.cr[6].eq {
	pc = 0x822DFD10; continue 'dispatch;
	}
	// 822DFCD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DFCDC: 409A000C  bne cr6, 0x822dfce8
	if !ctx.cr[6].eq {
	pc = 0x822DFCE8; continue 'dispatch;
	}
	// 822DFCE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFCE4: 48000020  b 0x822dfd04
	pc = 0x822DFD04; continue 'dispatch;
            }
            0x822DFCE8 => {
    //   block [0x822DFCE8..0x822DFD00)
	// 822DFCE8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFCEC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DFCF0: 7D4B5051  subf. r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822DFCF4: 4082000C  bne 0x822dfd00
	if !ctx.cr[0].eq {
	pc = 0x822DFD00; continue 'dispatch;
	}
	// 822DFCF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFCFC: 48000008  b 0x822dfd04
	pc = 0x822DFD04; continue 'dispatch;
            }
            0x822DFD00 => {
    //   block [0x822DFD00..0x822DFD04)
	// 822DFD00: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	pc = 0x822DFD04; continue 'dispatch;
            }
            0x822DFD04 => {
    //   block [0x822DFD04..0x822DFD10)
	// 822DFD04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFD08: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 822DFD0C: 4098000C  bge cr6, 0x822dfd18
	if !ctx.cr[6].lt {
	pc = 0x822DFD18; continue 'dispatch;
	}
	pc = 0x822DFD10; continue 'dispatch;
            }
            0x822DFD10 => {
    //   block [0x822DFD10..0x822DFD18)
	// 822DFD10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFD14: 48000008  b 0x822dfd1c
	pc = 0x822DFD1C; continue 'dispatch;
            }
            0x822DFD18 => {
    //   block [0x822DFD18..0x822DFD1C)
	// 822DFD18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x822DFD1C; continue 'dispatch;
            }
            0x822DFD1C => {
    //   block [0x822DFD1C..0x822DFD28)
	// 822DFD1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822DFD20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DFD24: 409AFEF4  bne cr6, 0x822dfc18
	if !ctx.cr[6].eq {
	pc = 0x822DFC18; continue 'dispatch;
	}
	pc = 0x822DFD28; continue 'dispatch;
            }
            0x822DFD28 => {
    //   block [0x822DFD28..0x822DFD34)
	// 822DFD28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822DFD2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DFD30: 482553DC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DFD38 size=140
    let mut pc: u32 = 0x822DFD38;
    'dispatch: loop {
        match pc {
            0x822DFD38 => {
    //   block [0x822DFD38..0x822DFD78)
	// 822DFD38: 7C8B6670  srawi r11, r4, 0xc
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 12) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 12) as i64;
	// 822DFD3C: 5489057E  clrlwi r9, r4, 0x15
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x000007FFu64;
	// 822DFD40: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 822DFD44: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 822DFD48: 4098007C  bge cr6, 0x822dfdc4
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x822DFDC4);
		return;
	}
	// 822DFD4C: 394B0006  addi r10, r11, 6
	ctx.r[10].s64 = ctx.r[11].s64 + 6;
	// 822DFD50: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822DFD54: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 822DFD58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DFD5C: 419A0068  beq cr6, 0x822dfdc4
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x822DFDC4);
		return;
	}
	// 822DFD60: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 822DFD64: 40980014  bge cr6, 0x822dfd78
	if !ctx.cr[6].lt {
	pc = 0x822DFD78; continue 'dispatch;
	}
	// 822DFD68: 394B0006  addi r10, r11, 6
	ctx.r[10].s64 = ctx.r[11].s64 + 6;
	// 822DFD6C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822DFD70: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 822DFD74: 48000008  b 0x822dfd7c
	pc = 0x822DFD7C; continue 'dispatch;
            }
            0x822DFD78 => {
    //   block [0x822DFD78..0x822DFD7C)
	// 822DFD78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x822DFD7C; continue 'dispatch;
            }
            0x822DFD7C => {
    //   block [0x822DFD7C..0x822DFD98)
	// 822DFD7C: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFD80: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 822DFD84: 40980014  bge cr6, 0x822dfd98
	if !ctx.cr[6].lt {
	pc = 0x822DFD98; continue 'dispatch;
	}
	// 822DFD88: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 822DFD8C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DFD90: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822DFD94: 48000008  b 0x822dfd9c
	pc = 0x822DFD9C; continue 'dispatch;
            }
            0x822DFD98 => {
    //   block [0x822DFD98..0x822DFD9C)
	// 822DFD98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822DFD9C; continue 'dispatch;
            }
            0x822DFD9C => {
    //   block [0x822DFD9C..0x822DFDC4)
	// 822DFD9C: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 822DFDA0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DFDA4: 40980020  bge cr6, 0x822dfdc4
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x822DFDC4);
		return;
	}
	// 822DFDA8: 7D6A4A14  add r11, r10, r9
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822DFDAC: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822DFDB0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822DFDB4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DFDB8: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822DFDBC: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 822DFDC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822DFDD0 size=156
    let mut pc: u32 = 0x822DFDD0;
    'dispatch: loop {
        match pc {
            0x822DFDD0 => {
    //   block [0x822DFDD0..0x822DFE40)
	// 822DFDD0: 396300D8  addi r11, r3, 0xd8
	ctx.r[11].s64 = ctx.r[3].s64 + 216;
	// 822DFDD4: A1430002  lhz r10, 2(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 822DFDD8: 81030448  lwz r8, 0x448(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1096 as u32) ) } as u64;
	// 822DFDDC: C0030008  lfs f0, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822DFDE0: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 822DFDE4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822DFDE8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFDEC: 39290006  addi r9, r9, 6
	ctx.r[9].s64 = ctx.r[9].s64 + 6;
	// 822DFDF0: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822DFDF4: 7D495B2E  sthx r10, r9, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u16) };
	// 822DFDF8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFDFC: 394A0066  addi r10, r10, 0x66
	ctx.r[10].s64 = ctx.r[10].s64 + 102;
	// 822DFE00: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822DFE04: 7C8A5B2E  sthx r4, r10, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u16) };
	// 822DFE08: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFE0C: 394A0026  addi r10, r10, 0x26
	ctx.r[10].s64 = ctx.r[10].s64 + 38;
	// 822DFE10: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822DFE14: 419A002C  beq cr6, 0x822dfe40
	if ctx.cr[6].eq {
	pc = 0x822DFE40; continue 'dispatch;
	}
	// 822DFE18: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 822DFE1C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822DFE20: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 822DFE24: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 822DFE28: 7D2A5B2E  sthx r9, r10, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u16) };
	// 822DFE2C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFE30: 394A0046  addi r10, r10, 0x46
	ctx.r[10].s64 = ctx.r[10].s64 + 70;
	// 822DFE34: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822DFE38: 7D0A5B2E  sthx r8, r10, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u16) };
	// 822DFE3C: 48000008  b 0x822dfe44
	pc = 0x822DFE44; continue 'dispatch;
            }
            0x822DFE40 => {
    //   block [0x822DFE40..0x822DFE44)
	// 822DFE40: 7CEA5B2E  sthx r7, r10, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u16) };
	pc = 0x822DFE44; continue 'dispatch;
            }
            0x822DFE44 => {
    //   block [0x822DFE44..0x822DFE6C)
	// 822DFE44: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFE48: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFE4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DFE50: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822DFE54: 2B0A0020  cmplwi cr6, r10, 0x20
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32 as u32, &mut ctx.xer);
	// 822DFE58: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DFE5C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DFE60: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 822DFE64: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 822DFE68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DFE70 size=700
    let mut pc: u32 = 0x822DFE70;
    'dispatch: loop {
        match pc {
            0x822DFE70 => {
    //   block [0x822DFE70..0x822DFF5C)
	// 822DFE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DFE74: 48255245  bl 0x825350b8
	ctx.lr = 0x822DFE78;
	sub_82535080(ctx, base);
	// 822DFE78: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 822DFE7C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822DFE80: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DFE84: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822DFE88: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 822DFE8C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 822DFE90: 614A9504  ori r10, r10, 0x9504
	ctx.r[10].u64 = ctx.r[10].u64 | 38148;
	// 822DFE94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822DFE98: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822DFE9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DFEA0: 419A027C  beq cr6, 0x822e011c
	if ctx.cr[6].eq {
	pc = 0x822E011C; continue 'dispatch;
	}
	// 822DFEA4: A1440008  lhz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DFEA8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 822DFEAC: A124000E  lhz r9, 0xe(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(14 as u32) ) } as u64;
	// 822DFEB0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822DFEB4: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822DFEB8: A1040026  lhz r8, 0x26(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(38 as u32) ) } as u64;
	// 822DFEBC: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822DFEC0: A0E40034  lhz r7, 0x34(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 822DFEC4: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822DFEC8: 396BD4E0  addi r11, r11, -0x2b20
	ctx.r[11].s64 = ctx.r[11].s64 + -11040;
	// 822DFECC: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 822DFED0: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 822DFED4: 54EA1E78  rlwinm r10, r7, 3, 0x19, 0x1c
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x1FFFFFFFu64;
	// 822DFED8: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 822DFEDC: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 822DFEE0: F9010070  std r8, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	// 822DFEE4: C9A10070  lfd f13, 0x70(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 822DFEE8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822DFEEC: 7F8A5A14  add r28, r10, r11
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822DFEF0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822DFEF4: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 822DFEF8: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822DFEFC: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 822DFF00: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822DFF04: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822DFF08: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 822DFF0C: FD6C0028  fsub f11, f12, f0
	ctx.f[11].f64 = ctx.f[12].f64 - ctx.f[0].f64;
	// 822DFF10: FC0B032E  fsel f0, f11, f12, f0
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 822DFF14: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822DFF18: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 822DFF1C: FC0C682E  fsel f0, f12, f0, f13
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 822DFF20: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822DFF24: C00A2094  lfs f0, 0x2094(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822DFF28: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822DFF2C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 822DFF30: C9AA2318  lfd f13, 0x2318(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8984 as u32) ) };
	// 822DFF34: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822DFF38: FD8D0028  fsub f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 - ctx.f[0].f64;
	// 822DFF3C: FC0C682E  fsel f0, f12, f0, f13
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 822DFF40: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822DFF44: C00A2164  lfs f0, 0x2164(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8548 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822DFF48: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822DFF4C: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822DFF50: C00A20D8  lfs f0, 0x20d8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8408 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822DFF54: EFDF0032  fmuls f30, f31, f0
	ctx.f[30].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 822DFF58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x822DFF5C; continue 'dispatch;
            }
            0x822DFF5C => {
    //   block [0x822DFF5C..0x822DFF88)
	// 822DFF5C: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFF60: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 822DFF64: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 822DFF68: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822DFF6C: 4200FFF0  bdnz 0x822dff5c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822DFF5C; continue 'dispatch;
	}
	// 822DFF70: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822DFF74: 556A00C8  rlwinm r10, r11, 0, 3, 4
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822DFF78: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 822DFF7C: 419A000C  beq cr6, 0x822dff88
	if ctx.cr[6].eq {
	pc = 0x822DFF88; continue 'dispatch;
	}
	// 822DFF80: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822DFF84: 48000078  b 0x822dfffc
	pc = 0x822DFFFC; continue 'dispatch;
            }
            0x822DFF88 => {
    //   block [0x822DFF88..0x822DFFA8)
	// 822DFF88: 756A0540  andis. r10, r11, 0x540
	ctx.r[10].u64 = ctx.r[11].u64 & 88080384;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822DFF8C: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 822DFF90: 419A0020  beq cr6, 0x822dffb0
	if ctx.cr[6].eq {
	pc = 0x822DFFB0; continue 'dispatch;
	}
	// 822DFF94: 556B01CE  rlwinm r11, r11, 0, 7, 7
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822DFF98: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 822DFF9C: 419A000C  beq cr6, 0x822dffa8
	if ctx.cr[6].eq {
	pc = 0x822DFFA8; continue 'dispatch;
	}
	// 822DFFA0: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 822DFFA4: 48000058  b 0x822dfffc
	pc = 0x822DFFFC; continue 'dispatch;
            }
            0x822DFFA8 => {
    //   block [0x822DFFA8..0x822DFFB0)
	// 822DFFA8: 38800017  li r4, 0x17
	ctx.r[4].s64 = 23;
	// 822DFFAC: 48000050  b 0x822dfffc
	pc = 0x822DFFFC; continue 'dispatch;
            }
            0x822DFFB0 => {
    //   block [0x822DFFB0..0x822DFFE0)
	// 822DFFB0: 3D80001B  lis r12, 0x1b
	ctx.r[12].s64 = 1769472;
	// 822DFFB4: 618CF0C0  ori r12, r12, 0xf0c0
	ctx.r[12].u64 = ctx.r[12].u64 | 61632;
	// 822DFFB8: 7D6A6038  and r10, r11, r12
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 822DFFBC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822DFFC0: 419A0028  beq cr6, 0x822dffe8
	if ctx.cr[6].eq {
	pc = 0x822DFFE8; continue 'dispatch;
	}
	// 822DFFC4: 3D800009  lis r12, 9
	ctx.r[12].s64 = 589824;
	// 822DFFC8: 618C5040  ori r12, r12, 0x5040
	ctx.r[12].u64 = ctx.r[12].u64 | 20544;
	// 822DFFCC: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 822DFFD0: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 822DFFD4: 419A000C  beq cr6, 0x822dffe0
	if ctx.cr[6].eq {
	pc = 0x822DFFE0; continue 'dispatch;
	}
	// 822DFFD8: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 822DFFDC: 48000020  b 0x822dfffc
	pc = 0x822DFFFC; continue 'dispatch;
            }
            0x822DFFE0 => {
    //   block [0x822DFFE0..0x822DFFE8)
	// 822DFFE0: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 822DFFE4: 48000018  b 0x822dfffc
	pc = 0x822DFFFC; continue 'dispatch;
            }
            0x822DFFE8 => {
    //   block [0x822DFFE8..0x822DFFFC)
	// 822DFFE8: 716B0510  andi. r11, r11, 0x510
	ctx.r[11].u64 = ctx.r[11].u64 & 1296;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DFFEC: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 822DFFF0: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 822DFFF4: 409A0008  bne cr6, 0x822dfffc
	if !ctx.cr[6].eq {
	pc = 0x822DFFFC; continue 'dispatch;
	}
	// 822DFFF8: 3880000D  li r4, 0xd
	ctx.r[4].s64 = 13;
	pc = 0x822DFFFC; continue 'dispatch;
            }
            0x822DFFFC => {
    //   block [0x822DFFFC..0x822E00C4)
	// 822DFFFC: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 822E0000: 387D0030  addi r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 + 48;
	// 822E0004: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E0008: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E000C: 4E800421  bctrl
	ctx.lr = 0x822E0010;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E0010: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 822E0014: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E0018: 38EA09C0  addi r7, r10, 0x9c0
	ctx.r[7].s64 = ctx.r[10].s64 + 2496;
	// 822E001C: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 822E0020: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 822E0024: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E0028: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E002C: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 822E0030: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822E0034: 83EAB9D8  lwz r31, -0x4628(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 822E0038: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E003C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822E0040: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0044: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E0048: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822E004C: 4808A445  bl 0x8236a490
	ctx.lr = 0x822E0050;
	sub_8236A490(ctx, base);
	// 822E0050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E0054: 419A00C8  beq cr6, 0x822e011c
	if ctx.cr[6].eq {
	pc = 0x822E011C; continue 'dispatch;
	}
	// 822E0058: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E005C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822E0060: C0AB1FF8  lfs f5, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 822E0064: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822E0068: C00ABA38  lfs f0, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E006C: 396B0AAC  addi r11, r11, 0xaac
	ctx.r[11].s64 = ctx.r[11].s64 + 2732;
	// 822E0070: D0A300B0  stfs f5, 0xb0(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822E0074: D0A300B4  stfs f5, 0xb4(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822E0078: D0A300B8  stfs f5, 0xb8(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822E007C: D00300BC  stfs f0, 0xbc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 822E0080: D0A300A0  stfs f5, 0xa0(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 822E0084: D0A300A4  stfs f5, 0xa4(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 822E0088: D0A300A8  stfs f5, 0xa8(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E008C: D00300AC  stfs f0, 0xac(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822E0090: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E0094: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E0098: D0A300C4  stfs f5, 0xc4(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822E009C: 93C300C0  stw r30, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 822E00A0: B1630088  sth r11, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u16 ) };
	// 822E00A4: 93E30090  stw r31, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 822E00A8: 93C30084  stw r30, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 822E00AC: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E00B0: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 822E00B4: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E00B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E00BC: 419A0008  beq cr6, 0x822e00c4
	if ctx.cr[6].eq {
	pc = 0x822E00C4; continue 'dispatch;
	}
	// 822E00C0: 906B0084  stw r3, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
            }
            0x822E00C4 => {
    //   block [0x822E00C4..0x822E0118)
	// 822E00C4: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E00C8: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 822E00CC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E00D0: C05C0000  lfs f2, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822E00D4: 614A9B74  ori r10, r10, 0x9b74
	ctx.r[10].u64 = ctx.r[10].u64 | 39796;
	// 822E00D8: FC80F090  fmr f4, f30
	ctx.f[4].f64 = ctx.f[30].f64;
	// 822E00DC: 616BE304  ori r11, r11, 0xe304
	ctx.r[11].u64 = ctx.r[11].u64 | 58116;
	// 822E00E0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822E00E4: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 822E00E8: 7C1D542E  lfsx f0, r29, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E00EC: FCC00050  fneg f6, f0
	ctx.f[6].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 822E00F0: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E00F4: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E00F8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822E00FC: EC60302A  fadds f3, f0, f6
	ctx.f[3].f64 = ((ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64;
	// 822E0100: 419A0018  beq cr6, 0x822e0118
	if ctx.cr[6].eq {
	pc = 0x822E0118; continue 'dispatch;
	}
	// 822E0104: 4BEB7F15  bl 0x82198018
	ctx.lr = 0x822E0108;
	sub_82198018(ctx, base);
	// 822E0108: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822E010C: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822E0110: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822E0114: 48254FF4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x822E0118 => {
    //   block [0x822E0118..0x822E011C)
	// 822E0118: 4BEB7E21  bl 0x82197f38
	ctx.lr = 0x822E011C;
	sub_82197F38(ctx, base);
	pc = 0x822E011C; continue 'dispatch;
            }
            0x822E011C => {
    //   block [0x822E011C..0x822E012C)
	// 822E011C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822E0120: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822E0124: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822E0128: 48254FE0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0130 size=132
    let mut pc: u32 = 0x822E0130;
    'dispatch: loop {
        match pc {
            0x822E0130 => {
    //   block [0x822E0130..0x822E01B4)
	// 822E0130: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0134: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E0138: 616BFAF0  ori r11, r11, 0xfaf0
	ctx.r[11].u64 = ctx.r[11].u64 | 64240;
	// 822E013C: 614AFAF8  ori r10, r10, 0xfaf8
	ctx.r[10].u64 = ctx.r[10].u64 | 64248;
	// 822E0140: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822E0144: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 822E0148: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 822E014C: 7C83592E  stwx r4, r3, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u32) };
	// 822E0150: 6108FB00  ori r8, r8, 0xfb00
	ctx.r[8].u64 = ctx.r[8].u64 | 64256;
	// 822E0154: A1640000  lhz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0158: 60E7FB08  ori r7, r7, 0xfb08
	ctx.r[7].u64 = ctx.r[7].u64 | 64264;
	// 822E015C: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 822E0160: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E0164: 3CA00001  lis r5, 1
	ctx.r[5].s64 = 65536;
	// 822E0168: 60C6FAFC  ori r6, r6, 0xfafc
	ctx.r[6].u64 = ctx.r[6].u64 | 64252;
	// 822E016C: 60A5FAF4  ori r5, r5, 0xfaf4
	ctx.r[5].u64 = ctx.r[5].u64 | 64244;
	// 822E0170: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 822E0174: A1640000  lhz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0178: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E017C: 7D2B5830  slw r11, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 822E0180: 7D63412E  stwx r11, r3, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 822E0184: A1640002  lhz r11, 2(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E0188: 7D633B2E  sthx r11, r3, r7
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u16) };
	// 822E018C: A1640000  lhz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0190: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E0194: 216B0001  subfic r11, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[11].s64 = (1 as i64) - ctx.r[11].s64;
	// 822E0198: 1D4B0458  mulli r10, r11, 0x458
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 1112 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822E019C: 7D63312E  stwx r11, r3, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 822E01A0: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 822E01A4: 3D4A0002  addis r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 131072;
	// 822E01A8: 394AEEC8  addi r10, r10, -0x1138
	ctx.r[10].s64 = ctx.r[10].s64 + -4408;
	// 822E01AC: 7D43292E  stwx r10, r3, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[5].u32), ctx.r[10].u32) };
	// 822E01B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E01B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E01B8 size=600
    let mut pc: u32 = 0x822E01B8;
    'dispatch: loop {
        match pc {
            0x822E01B8 => {
    //   block [0x822E01B8..0x822E02B8)
	// 822E01B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E01BC: 48254EF1  bl 0x825350ac
	ctx.lr = 0x822E01C0;
	sub_82535080(ctx, base);
	// 822E01C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E01C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E01C8: 3D030002  addis r8, r3, 2
	ctx.r[8].s64 = ctx.r[3].s64 + 131072;
	// 822E01CC: 3FA30002  addis r29, r3, 2
	ctx.r[29].s64 = ctx.r[3].s64 + 131072;
	// 822E01D0: 3908FAF0  addi r8, r8, -0x510
	ctx.r[8].s64 = ctx.r[8].s64 + -1296;
	// 822E01D4: 3BBDFAF8  addi r29, r29, -0x508
	ctx.r[29].s64 = ctx.r[29].s64 + -1288;
	// 822E01D8: C18B1FF8  lfs f12, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E01DC: 1D660458  mulli r11, r6, 0x458
	ctx.r[11].s32 = ((ctx.r[6].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E01E0: FD606090  fmr f11, f12
	ctx.f[11].f64 = ctx.f[12].f64;
	// 822E01E4: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 822E01E8: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822E01EC: 3F830002  addis r28, r3, 2
	ctx.r[28].s64 = ctx.r[3].s64 + 131072;
	// 822E01F0: 3CEB0002  addis r7, r11, 2
	ctx.r[7].s64 = ctx.r[11].s64 + 131072;
	// 822E01F4: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E01F8: 3B9CFB00  addi r28, r28, -0x500
	ctx.r[28].s64 = ctx.r[28].s64 + -1280;
	// 822E01FC: 3F630002  addis r27, r3, 2
	ctx.r[27].s64 = ctx.r[3].s64 + 131072;
	// 822E0200: 392BA908  addi r9, r11, -0x56f8
	ctx.r[9].s64 = ctx.r[11].s64 + -22264;
	// 822E0204: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0208: 3B7BFB08  addi r27, r27, -0x4f8
	ctx.r[27].s64 = ctx.r[27].s64 + -1272;
	// 822E020C: 3F430002  addis r26, r3, 2
	ctx.r[26].s64 = ctx.r[3].s64 + 131072;
	// 822E0210: 3F230002  addis r25, r3, 2
	ctx.r[25].s64 = ctx.r[3].s64 + 131072;
	// 822E0214: 3B5AFAFC  addi r26, r26, -0x504
	ctx.r[26].s64 = ctx.r[26].s64 + -1284;
	// 822E0218: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E021C: 3B39FAF4  addi r25, r25, -0x50c
	ctx.r[25].s64 = ctx.r[25].s64 + -1292;
	// 822E0220: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0224: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E0228: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822E022C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E0230: 38E7EEC8  addi r7, r7, -0x1138
	ctx.r[7].s64 = ctx.r[7].s64 + -4408;
	// 822E0234: 2B1F0001  cmplwi cr6, r31, 1
	ctx.cr[6].compare_u32(ctx.r[31].u32, 1 as u32, &mut ctx.xer);
	// 822E0238: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822E023C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0240: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822E0244: A17B0000  lhz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0248: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E024C: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822E0250: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0254: 91690010  stw r11, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 822E0258: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E025C: 91690014  stw r11, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 822E0260: 4198006C  blt cr6, 0x822e02cc
	if ctx.cr[6].lt {
	pc = 0x822E02CC; continue 'dispatch;
	}
	// 822E0264: 419A0064  beq cr6, 0x822e02c8
	if ctx.cr[6].eq {
	pc = 0x822E02C8; continue 'dispatch;
	}
	// 822E0268: 2B1F0003  cmplwi cr6, r31, 3
	ctx.cr[6].compare_u32(ctx.r[31].u32, 3 as u32, &mut ctx.xer);
	// 822E026C: 4198004C  blt cr6, 0x822e02b8
	if ctx.cr[6].lt {
	pc = 0x822E02B8; continue 'dispatch;
	}
	// 822E0270: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E0274: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 822E0278: 7D650734  extsh r5, r11
	ctx.r[5].s64 = ctx.r[11].s16 as i64;
	// 822E027C: 48002D9D  bl 0x822e3018
	ctx.lr = 0x822E0280;
	sub_822E3018(ctx, base);
	// 822E0280: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0284: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822E0288: FD600890  fmr f11, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = ctx.f[1].f64;
	// 822E028C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E0290: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822E0294: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 822E0298: FC00581E  fctiwz f0, f11
	ctx.f[0].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 822E029C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E02A0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822E02A4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 822E02A8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E02AC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822E02B0: 41990008  bgt cr6, 0x822e02b8
	if ctx.cr[6].gt {
	pc = 0x822E02B8; continue 'dispatch;
	}
	// 822E02B4: FD606090  fmr f11, f12
	ctx.f[11].f64 = ctx.f[12].f64;
	pc = 0x822E02B8; continue 'dispatch;
            }
            0x822E02B8 => {
    //   block [0x822E02B8..0x822E02C8)
	// 822E02B8: A17E0002  lhz r11, 2(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E02BC: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 822E02C0: 7D650734  extsh r5, r11
	ctx.r[5].s64 = ctx.r[11].s16 as i64;
	// 822E02C4: 48002D55  bl 0x822e3018
	ctx.lr = 0x822E02C8;
	sub_822E3018(ctx, base);
	pc = 0x822E02C8; continue 'dispatch;
            }
            0x822E02C8 => {
    //   block [0x822E02C8..0x822E02CC)
	// 822E02C8: A0BE0000  lhz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822E02CC; continue 'dispatch;
            }
            0x822E02CC => {
    //   block [0x822E02CC..0x822E0324)
	// 822E02CC: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E02D0: 816BA900  lwz r11, -0x5700(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22272 as u32) ) } as u64;
	// 822E02D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E02D8: 419A0088  beq cr6, 0x822e0360
	if ctx.cr[6].eq {
	pc = 0x822E0360; continue 'dispatch;
	}
	// 822E02DC: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E02E0: C00BA8FC  lfs f0, -0x5704(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E02E4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 822E02E8: 4198003C  blt cr6, 0x822e0324
	if ctx.cr[6].lt {
	pc = 0x822E0324; continue 'dispatch;
	}
	// 822E02EC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E02F0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822E02F4: FD600090  fmr f11, f0
	ctx.f[11].f64 = ctx.f[0].f64;
	// 822E02F8: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E02FC: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 822E0300: 7DA057AE  stfiwx f13, 0, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 822E0304: FDA0581E  fctiwz f13, f11
	ctx.f[13].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 822E0308: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E030C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822E0310: 7DA057AE  stfiwx f13, 0, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 822E0314: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E0318: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822E031C: 41990008  bgt cr6, 0x822e0324
	if ctx.cr[6].gt {
	pc = 0x822E0324; continue 'dispatch;
	}
	// 822E0320: FD606090  fmr f11, f12
	ctx.f[11].f64 = ctx.f[12].f64;
	pc = 0x822E0324; continue 'dispatch;
            }
            0x822E0324 => {
    //   block [0x822E0324..0x822E0360)
	// 822E0324: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 822E0328: 40980038  bge cr6, 0x822e0360
	if !ctx.cr[6].lt {
	pc = 0x822E0360; continue 'dispatch;
	}
	// 822E032C: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0330: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E0334: B0AA00AC  sth r5, 0xac(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(172 as u32), ctx.r[5].u16 ) };
	// 822E0338: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E033C: 816BA924  lwz r11, -0x56dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22236 as u32) ) } as u64;
	// 822E0340: B0CA00AE  sth r6, 0xae(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(174 as u32), ctx.r[6].u16 ) };
	// 822E0344: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0348: D02A00B4  stfs f1, 0xb4(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822E034C: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0350: D00A00B8  stfs f0, 0xb8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822E0354: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0358: B16A00B0  sth r11, 0xb0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(176 as u32), ctx.r[11].u16 ) };
	// 822E035C: 48000078  b 0x822e03d4
	pc = 0x822E03D4; continue 'dispatch;
            }
            0x822E0360 => {
    //   block [0x822E0360..0x822E0384)
	// 822E0360: 2F1F0003  cmpwi cr6, r31, 3
	ctx.cr[6].compare_i32(ctx.r[31].s32, 3, &mut ctx.xer);
	// 822E0364: 4099003C  ble cr6, 0x822e03a0
	if !ctx.cr[6].gt {
	pc = 0x822E03A0; continue 'dispatch;
	}
	// 822E0368: 397FFFFD  addi r11, r31, -3
	ctx.r[11].s64 = ctx.r[31].s64 + -3;
	// 822E036C: 395E0006  addi r10, r30, 6
	ctx.r[10].s64 = ctx.r[30].s64 + 6;
	// 822E0370: 38C7008C  addi r6, r7, 0x8c
	ctx.r[6].s64 = ctx.r[7].s64 + 140;
	// 822E0374: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E0378: 91670088  stw r11, 0x88(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 822E037C: 4099002C  ble cr6, 0x822e03a8
	if !ctx.cr[6].gt {
	pc = 0x822E03A8; continue 'dispatch;
	}
	// 822E0380: 7CCA3050  subf r6, r10, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	pc = 0x822E0384; continue 'dispatch;
            }
            0x822E0384 => {
    //   block [0x822E0384..0x822E03A0)
	// 822E0384: A08A0000  lhz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0388: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E038C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E0390: 7C86532E  sthx r4, r6, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32), ctx.r[4].u16) };
	// 822E0394: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 822E0398: 4199FFEC  bgt cr6, 0x822e0384
	if ctx.cr[6].gt {
	pc = 0x822E0384; continue 'dispatch;
	}
	// 822E039C: 4800000C  b 0x822e03a8
	pc = 0x822E03A8; continue 'dispatch;
            }
            0x822E03A0 => {
    //   block [0x822E03A0..0x822E03A8)
	// 822E03A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E03A4: 91670088  stw r11, 0x88(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	pc = 0x822E03A8; continue 'dispatch;
            }
            0x822E03A8 => {
    //   block [0x822E03A8..0x822E03C8)
	// 822E03A8: D1670060  stfs f11, 0x60(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E03AC: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 822E03B0: D027005C  stfs f1, 0x5c(r7)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822E03B4: B0A70052  sth r5, 0x52(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(82 as u32), ctx.r[5].u16 ) };
	// 822E03B8: 409A0010  bne cr6, 0x822e03c8
	if !ctx.cr[6].eq {
	pc = 0x822E03C8; continue 'dispatch;
	}
	// 822E03BC: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 822E03C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E03C4: 916AA554  stw r11, -0x5aac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-23212 as u32), ctx.r[11].u32 ) };
	pc = 0x822E03C8; continue 'dispatch;
            }
            0x822E03C8 => {
    //   block [0x822E03C8..0x822E03D4)
	// 822E03C8: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E03CC: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E03D0: B167004E  sth r11, 0x4e(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(78 as u32), ctx.r[11].u16 ) };
	pc = 0x822E03D4; continue 'dispatch;
            }
            0x822E03D4 => {
    //   block [0x822E03D4..0x822E0410)
	// 822E03D4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E03D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E03DC: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E03E0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E03E4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E03E8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E03EC: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E03F0: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E03F4: B17B0000  sth r11, 0(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E03F8: 81690010  lwz r11, 0x10(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 822E03FC: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E0400: 81690014  lwz r11, 0x14(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 822E0404: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E0408: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822E040C: 48254CF0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0410 size=16
    let mut pc: u32 = 0x822E0410;
    'dispatch: loop {
        match pc {
            0x822E0410 => {
    //   block [0x822E0410..0x822E0420)
	// 822E0410: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0414: 616BFAF8  ori r11, r11, 0xfaf8
	ctx.r[11].u64 = ctx.r[11].u64 | 64248;
	// 822E0418: 7CC3582E  lwzx r6, r3, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E041C: 4BFFFD9C  b 0x822e01b8
	sub_822E01B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0420 size=8
    let mut pc: u32 = 0x822E0420;
    'dispatch: loop {
        match pc {
            0x822E0420 => {
    //   block [0x822E0420..0x822E0428)
	// 822E0420: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E0424: 4BFFFD94  b 0x822e01b8
	sub_822E01B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0428 size=8
    let mut pc: u32 = 0x822E0428;
    'dispatch: loop {
        match pc {
            0x822E0428 => {
    //   block [0x822E0428..0x822E0430)
	// 822E0428: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822E042C: 4BFFFD8C  b 0x822e01b8
	sub_822E01B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0430 size=16
    let mut pc: u32 = 0x822E0430;
    'dispatch: loop {
        match pc {
            0x822E0430 => {
    //   block [0x822E0430..0x822E0440)
	// 822E0430: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0434: 616BFAFC  ori r11, r11, 0xfafc
	ctx.r[11].u64 = ctx.r[11].u64 | 64252;
	// 822E0438: 7CC3582E  lwzx r6, r3, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E043C: 4BFFFD7C  b 0x822e01b8
	sub_822E01B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E0440 size=256
    let mut pc: u32 = 0x822E0440;
    'dispatch: loop {
        match pc {
            0x822E0440 => {
    //   block [0x822E0440..0x822E0488)
	// 822E0440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0444: 48254C6D  bl 0x825350b0
	ctx.lr = 0x822E0448;
	sub_82535080(ctx, base);
	// 822E0448: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E044C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0450: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E0454: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822E0458: 616BFB1C  ori r11, r11, 0xfb1c
	ctx.r[11].u64 = ctx.r[11].u64 | 64284;
	// 822E045C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822E0460: A37C0000  lhz r27, 0(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0464: 7FBF582E  lwzx r29, r31, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E0468: 7F640734  extsh r4, r27
	ctx.r[4].s64 = ctx.r[27].s16 as i64;
	// 822E046C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E0470: 4BFFF8C9  bl 0x822dfd38
	ctx.lr = 0x822E0474;
	sub_822DFD38(ctx, base);
	// 822E0474: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 822E0478: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822E047C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822E0480: 419A0008  beq cr6, 0x822e0488
	if ctx.cr[6].eq {
	pc = 0x822E0488; continue 'dispatch;
	}
	// 822E0484: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	pc = 0x822E0488; continue 'dispatch;
            }
            0x822E0488 => {
    //   block [0x822E0488..0x822E04DC)
	// 822E0488: 3FBF0002  addis r29, r31, 2
	ctx.r[29].s64 = ctx.r[31].s64 + 131072;
	// 822E048C: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 822E0490: 3BBDFB08  addi r29, r29, -0x4f8
	ctx.r[29].s64 = ctx.r[29].s64 + -1272;
	// 822E0494: A35D0000  lhz r26, 0(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0498: B37D0000  sth r27, 0(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[27].u16 ) };
	// 822E049C: 40990040  ble cr6, 0x822e04dc
	if !ctx.cr[6].gt {
	pc = 0x822E04DC; continue 'dispatch;
	}
	// 822E04A0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822E04A4: 419A0040  beq cr6, 0x822e04e4
	if ctx.cr[6].eq {
	pc = 0x822E04E4; continue 'dispatch;
	}
	// 822E04A8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E04AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E04B0: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 822E04B4: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E04B8: 38DC0002  addi r6, r28, 2
	ctx.r[6].s64 = ctx.r[28].s64 + 2;
	// 822E04BC: 396BA928  addi r11, r11, -0x56d8
	ctx.r[11].s64 = ctx.r[11].s64 + -22232;
	// 822E04C0: 914B0BD8  stw r10, 0xbd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3032 as u32), ctx.r[10].u32 ) };
	// 822E04C4: B14B0BDC  sth r10, 0xbdc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(3036 as u32), ctx.r[10].u16 ) };
	// 822E04C8: 914B0BE0  stw r10, 0xbe0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3040 as u32), ctx.r[10].u32 ) };
	// 822E04CC: 7D5F48AE  lbzx r10, r31, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E04D0: 393EFFFF  addi r9, r30, -1
	ctx.r[9].s64 = ctx.r[30].s64 + -1;
	// 822E04D4: 7D250734  extsh r5, r9
	ctx.r[5].s64 = ctx.r[9].s16 as i64;
	// 822E04D8: 48000048  b 0x822e0520
	pc = 0x822E0520; continue 'dispatch;
            }
            0x822E04DC => {
    //   block [0x822E04DC..0x822E04E4)
	// 822E04DC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822E04E0: 409A0014  bne cr6, 0x822e04f4
	if !ctx.cr[6].eq {
	pc = 0x822E04F4; continue 'dispatch;
	}
	pc = 0x822E04E4; continue 'dispatch;
            }
            0x822E04E4 => {
    //   block [0x822E04E4..0x822E04F4)
	// 822E04E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E04E8: B35D0000  sth r26, 0(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[26].u16 ) };
	// 822E04EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822E04F0: 48254C10  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822E04F4 => {
    //   block [0x822E04F4..0x822E0520)
	// 822E04F4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E04F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E04FC: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 822E0500: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E0504: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E0508: 396BA928  addi r11, r11, -0x56d8
	ctx.r[11].s64 = ctx.r[11].s64 + -22232;
	// 822E050C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E0510: 914B0BD8  stw r10, 0xbd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3032 as u32), ctx.r[10].u32 ) };
	// 822E0514: B14B0BDC  sth r10, 0xbdc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(3036 as u32), ctx.r[10].u16 ) };
	// 822E0518: 914B0BE0  stw r10, 0xbe0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3040 as u32), ctx.r[10].u32 ) };
	// 822E051C: 7D5F48AE  lbzx r10, r31, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	pc = 0x822E0520; continue 'dispatch;
            }
            0x822E0520 => {
    //   block [0x822E0520..0x822E0540)
	// 822E0520: 1D4A01E0  mulli r10, r10, 0x1e0
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 480 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822E0524: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E0528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E052C: 914B03C0  stw r10, 0x3c0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(960 as u32), ctx.r[10].u32 ) };
	// 822E0530: 48004279  bl 0x822e47a8
	ctx.lr = 0x822E0534;
	sub_822E47A8(ctx, base);
	// 822E0534: B35D0000  sth r26, 0(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[26].u16 ) };
	// 822E0538: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822E053C: 48254BC4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E0540 size=160
    let mut pc: u32 = 0x822E0540;
    'dispatch: loop {
        match pc {
            0x822E0540 => {
    //   block [0x822E0540..0x822E05A4)
	// 822E0540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E0548: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E054C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0550: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E0554: 3FE0829F  lis r31, -0x7d61
	ctx.r[31].s64 = -2103508992;
	// 822E0558: 3D20829F  lis r9, -0x7d61
	ctx.r[9].s64 = -2103508992;
	// 822E055C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E0560: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 822E0564: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 822E0568: 917FA900  stw r11, -0x5700(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-22272 as u32), ctx.r[11].u32 ) };
	// 822E056C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E0570: 2F080002  cmpwi cr6, r8, 2
	ctx.cr[6].compare_i32(ctx.r[8].s32, 2, &mut ctx.xer);
	// 822E0574: C00B2074  lfs f0, 0x2074(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E0578: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E057C: D009A8FC  stfs f0, -0x5704(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-22276 as u32), tmp.u32 ) };
	// 822E0580: 914BA924  stw r10, -0x56dc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-22236 as u32), ctx.r[10].u32 ) };
	// 822E0584: 41980034  blt cr6, 0x822e05b8
	if ctx.cr[6].lt {
	pc = 0x822E05B8; continue 'dispatch;
	}
	// 822E0588: A1470002  lhz r10, 2(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E058C: 7D450734  extsh r5, r10
	ctx.r[5].s64 = ctx.r[10].s16 as i64;
	// 822E0590: 2F05FFFE  cmpwi cr6, r5, -2
	ctx.cr[6].compare_i32(ctx.r[5].s32, -2, &mut ctx.xer);
	// 822E0594: 409A0010  bne cr6, 0x822e05a4
	if !ctx.cr[6].eq {
	pc = 0x822E05A4; continue 'dispatch;
	}
	// 822E0598: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822E059C: 914BA924  stw r10, -0x56dc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-22236 as u32), ctx.r[10].u32 ) };
	// 822E05A0: 48000018  b 0x822e05b8
	pc = 0x822E05B8; continue 'dispatch;
            }
            0x822E05A4 => {
    //   block [0x822E05A4..0x822E05B8)
	// 822E05A4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E05A8: 616BFAF0  ori r11, r11, 0xfaf0
	ctx.r[11].u64 = ctx.r[11].u64 | 64240;
	// 822E05AC: 7C83582E  lwzx r4, r3, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E05B0: 48002A69  bl 0x822e3018
	ctx.lr = 0x822E05B4;
	sub_822E3018(ctx, base);
	// 822E05B4: D029A8FC  stfs f1, -0x5704(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-22276 as u32), tmp.u32 ) };
	pc = 0x822E05B8; continue 'dispatch;
            }
            0x822E05B8 => {
    //   block [0x822E05B8..0x822E05E0)
	// 822E05B8: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 822E05BC: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 822E05C0: 4BFFFE81  bl 0x822e0440
	ctx.lr = 0x822E05C4;
	sub_822E0440(ctx, base);
	// 822E05C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E05C8: 917FA900  stw r11, -0x5700(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-22272 as u32), ctx.r[11].u32 ) };
	// 822E05CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E05D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E05D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E05D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E05DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E05E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E05E0 size=40
    let mut pc: u32 = 0x822E05E0;
    'dispatch: loop {
        match pc {
            0x822E05E0 => {
    //   block [0x822E05E0..0x822E0608)
	// 822E05E0: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E05E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E05E8: 614AFAF0  ori r10, r10, 0xfaf0
	ctx.r[10].u64 = ctx.r[10].u64 | 64240;
	// 822E05EC: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 822E05F0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822E05F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E05F8: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E05FC: B12B00AC  sth r9, 0xac(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), ctx.r[9].u16 ) };
	// 822E0600: B10B00B0  sth r8, 0xb0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[8].u16 ) };
	// 822E0604: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E0608 size=328
    let mut pc: u32 = 0x822E0608;
    'dispatch: loop {
        match pc {
            0x822E0608 => {
    //   block [0x822E0608..0x822E0644)
	// 822E0608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E060C: 48254AB1  bl 0x825350bc
	ctx.lr = 0x822E0610;
	sub_82535080(ctx, base);
	// 822E0610: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0614: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E0618: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822E061C: 614AFAF0  ori r10, r10, 0xfaf0
	ctx.r[10].u64 = ctx.r[10].u64 | 64240;
	// 822E0620: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 822E0624: 7FFD502E  lwzx r31, r29, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E0628: A15F00AC  lhz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 822E062C: 7D450734  extsh r5, r10
	ctx.r[5].s64 = ctx.r[10].s16 as i64;
	// 822E0630: 2F05FFFF  cmpwi cr6, r5, -1
	ctx.cr[6].compare_i32(ctx.r[5].s32, -1, &mut ctx.xer);
	// 822E0634: 409A0010  bne cr6, 0x822e0644
	if !ctx.cr[6].eq {
	pc = 0x822E0644; continue 'dispatch;
	}
	// 822E0638: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E063C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E0640: 48254ACC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x822E0644 => {
    //   block [0x822E0644..0x822E0674)
	// 822E0644: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E0648: 614AD380  ori r10, r10, 0xd380
	ctx.r[10].u64 = ctx.r[10].u64 | 54144;
	// 822E064C: 7D5D522E  lhzx r10, r29, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E0650: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E0654: 419A0020  beq cr6, 0x822e0674
	if ctx.cr[6].eq {
	pc = 0x822E0674; continue 'dispatch;
	}
	// 822E0658: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822E065C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E0660: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E0664: B17F00AC  sth r11, 0xac(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u16 ) };
	// 822E0668: B15F00B0  sth r10, 0xb0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u16 ) };
	// 822E066C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E0670: 48254A9C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x822E0674 => {
    //   block [0x822E0674..0x822E06D8)
	// 822E0674: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 822E0678: 419A0070  beq cr6, 0x822e06e8
	if ctx.cr[6].eq {
	pc = 0x822E06E8; continue 'dispatch;
	}
	// 822E067C: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0680: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 822E0684: 409A0064  bne cr6, 0x822e06e8
	if !ctx.cr[6].eq {
	pc = 0x822E06E8; continue 'dispatch;
	}
	// 822E0688: A17F00AE  lhz r11, 0xae(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(174 as u32) ) } as u64;
	// 822E068C: C03F00B4  lfs f1, 0xb4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E0690: A15F0000  lhz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0694: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822E0698: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 822E069C: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 822E06A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E06A4: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 822E06A8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822E06AC: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 822E06B0: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 822E06B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E06B8: 419A0020  beq cr6, 0x822e06d8
	if ctx.cr[6].eq {
	pc = 0x822E06D8; continue 'dispatch;
	}
	// 822E06BC: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 822E06C0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 822E06C4: 48001115  bl 0x822e17d8
	ctx.lr = 0x822E06C8;
	sub_822E17D8(ctx, base);
	// 822E06C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E06CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E06D0: 48000111  bl 0x822e07e0
	ctx.lr = 0x822E06D4;
	sub_822E07E0(ctx, base);
	// 822E06D4: 48000050  b 0x822e0724
	pc = 0x822E0724; continue 'dispatch;
            }
            0x822E06D8 => {
    //   block [0x822E06D8..0x822E06E8)
	// 822E06D8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 822E06DC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 822E06E0: 480010F9  bl 0x822e17d8
	ctx.lr = 0x822E06E4;
	sub_822E17D8(ctx, base);
	// 822E06E4: 48000034  b 0x822e0718
	pc = 0x822E0718; continue 'dispatch;
            }
            0x822E06E8 => {
    //   block [0x822E06E8..0x822E0718)
	// 822E06E8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822E06EC: A17F00AE  lhz r11, 0xae(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(174 as u32) ) } as u64;
	// 822E06F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E06F4: C03F00B4  lfs f1, 0xb4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E06F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822E06FC: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 822E0700: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 822E0704: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 822E0708: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 822E070C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E0710: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 822E0714: 480010C5  bl 0x822e17d8
	ctx.lr = 0x822E0718;
	sub_822E17D8(ctx, base);
	pc = 0x822E0718; continue 'dispatch;
            }
            0x822E0718 => {
    //   block [0x822E0718..0x822E0724)
	// 822E0718: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822E071C: B3DF00B0  sth r30, 0xb0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[30].u16 ) };
	// 822E0720: B17F00AC  sth r11, 0xac(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u16 ) };
	pc = 0x822E0724; continue 'dispatch;
            }
            0x822E0724 => {
    //   block [0x822E0724..0x822E0750)
	// 822E0724: A17F00AE  lhz r11, 0xae(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(174 as u32) ) } as u64;
	// 822E0728: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E072C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822E0730: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E0734: 614AEEF4  ori r10, r10, 0xeef4
	ctx.r[10].u64 = ctx.r[10].u64 | 61172;
	// 822E0738: 1D6B0458  mulli r11, r11, 0x458
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E073C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 822E0740: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E0744: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 822E0748: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E074C: 482549C0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0750 size=32
    let mut pc: u32 = 0x822E0750;
    'dispatch: loop {
        match pc {
            0x822E0750 => {
    //   block [0x822E0750..0x822E0770)
	// 822E0750: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0754: 616BFAF0  ori r11, r11, 0xfaf0
	ctx.r[11].u64 = ctx.r[11].u64 | 64240;
	// 822E0758: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E075C: A14B00AC  lhz r10, 0xac(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 822E0760: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 822E0764: 409A000C  bne cr6, 0x822e0770
	if !ctx.cr[6].eq {
		sub_822E0770(ctx, base);
		return;
	}
	// 822E0768: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E076C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E0770 size=36
    let mut pc: u32 = 0x822E0770;
    'dispatch: loop {
        match pc {
            0x822E0770 => {
    //   block [0x822E0770..0x822E0794)
	// 822E0770: A12B00B0  lhz r9, 0xb0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) } as u64;
	// 822E0774: C00B00B4  lfs f0, 0xb4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E0778: A10B00AE  lhz r8, 0xae(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(174 as u32) ) } as u64;
	// 822E077C: D00B00C4  stfs f0, 0xc4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822E0780: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E0784: B14B00BC  sth r10, 0xbc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), ctx.r[10].u16 ) };
	// 822E0788: B12B00C0  sth r9, 0xc0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), ctx.r[9].u16 ) };
	// 822E078C: B10B00BE  sth r8, 0xbe(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(190 as u32), ctx.r[8].u16 ) };
	// 822E0790: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0798 size=32
    let mut pc: u32 = 0x822E0798;
    'dispatch: loop {
        match pc {
            0x822E0798 => {
    //   block [0x822E0798..0x822E07B8)
	// 822E0798: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E079C: 616BFAF0  ori r11, r11, 0xfaf0
	ctx.r[11].u64 = ctx.r[11].u64 | 64240;
	// 822E07A0: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E07A4: A14B00BC  lhz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 822E07A8: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 822E07AC: 409A000C  bne cr6, 0x822e07b8
	if !ctx.cr[6].eq {
		sub_822E07B8(ctx, base);
		return;
	}
	// 822E07B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E07B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E07B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E07B8 size=36
    let mut pc: u32 = 0x822E07B8;
    'dispatch: loop {
        match pc {
            0x822E07B8 => {
    //   block [0x822E07B8..0x822E07DC)
	// 822E07B8: A12B00C0  lhz r9, 0xc0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 822E07BC: C00B00B4  lfs f0, 0xb4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E07C0: A10B00BE  lhz r8, 0xbe(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(190 as u32) ) } as u64;
	// 822E07C4: D00B00C4  stfs f0, 0xc4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822E07C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E07CC: B14B00AC  sth r10, 0xac(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), ctx.r[10].u16 ) };
	// 822E07D0: B12B00B0  sth r9, 0xb0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[9].u16 ) };
	// 822E07D4: B10B00AE  sth r8, 0xae(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(174 as u32), ctx.r[8].u16 ) };
	// 822E07D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E07E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E07E0 size=344
    let mut pc: u32 = 0x822E07E0;
    'dispatch: loop {
        match pc {
            0x822E07E0 => {
    //   block [0x822E07E0..0x822E081C)
	// 822E07E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E07E4: 482548D9  bl 0x825350bc
	ctx.lr = 0x822E07E8;
	sub_82535080(ctx, base);
	// 822E07E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E07EC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E07F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822E07F4: 616BE2D4  ori r11, r11, 0xe2d4
	ctx.r[11].u64 = ctx.r[11].u64 | 58068;
	// 822E07F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E07FC: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E0800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E0804: 409A0018  bne cr6, 0x822e081c
	if !ctx.cr[6].eq {
	pc = 0x822E081C; continue 'dispatch;
	}
	// 822E0808: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E080C: 616BE2D8  ori r11, r11, 0xe2d8
	ctx.r[11].u64 = ctx.r[11].u64 | 58072;
	// 822E0810: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E0814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E0818: 419A0020  beq cr6, 0x822e0838
	if ctx.cr[6].eq {
	pc = 0x822E0838; continue 'dispatch;
	}
	pc = 0x822E081C; continue 'dispatch;
            }
            0x822E081C => {
    //   block [0x822E081C..0x822E0838)
	// 822E081C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0820: 616BE2DC  ori r11, r11, 0xe2dc
	ctx.r[11].u64 = ctx.r[11].u64 | 58076;
	// 822E0824: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E0828: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822E082C: 409A000C  bne cr6, 0x822e0838
	if !ctx.cr[6].eq {
	pc = 0x822E0838; continue 'dispatch;
	}
	// 822E0830: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E0834: 48003845  bl 0x822e4078
	ctx.lr = 0x822E0838;
	sub_822E4078(ctx, base);
	pc = 0x822E0838; continue 'dispatch;
            }
            0x822E0838 => {
    //   block [0x822E0838..0x822E0844)
	// 822E0838: 395F01E4  addi r10, r31, 0x1e4
	ctx.r[10].s64 = ctx.r[31].s64 + 484;
	// 822E083C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 822E0840: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	pc = 0x822E0844; continue 'dispatch;
            }
            0x822E0844 => {
    //   block [0x822E0844..0x822E0894)
	// 822E0844: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E0848: B3CA0000  sth r30, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u16 ) };
	// 822E084C: 394A0024  addi r10, r10, 0x24
	ctx.r[10].s64 = ctx.r[10].s64 + 36;
	// 822E0850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E0854: 409AFFF0  bne cr6, 0x822e0844
	if !ctx.cr[6].eq {
	pc = 0x822E0844; continue 'dispatch;
	}
	// 822E0858: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E085C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E0860: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0864: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E0868: 48000E09  bl 0x822e1670
	ctx.lr = 0x822E086C;
	sub_822E1670(ctx, base);
	// 822E086C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E0870: 419A0050  beq cr6, 0x822e08c0
	if ctx.cr[6].eq {
	pc = 0x822E08C0; continue 'dispatch;
	}
	// 822E0874: A17F0002  lhz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E0878: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E087C: 419A0044  beq cr6, 0x822e08c0
	if ctx.cr[6].eq {
	pc = 0x822E08C0; continue 'dispatch;
	}
	// 822E0880: 3D5D0002  addis r10, r29, 2
	ctx.r[10].s64 = ctx.r[29].s64 + 131072;
	// 822E0884: E91F0430  ld r8, 0x430(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(1072 as u32) ) };
	// 822E0888: E93F0428  ld r9, 0x428(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(1064 as u32) ) };
	// 822E088C: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 822E0890: 394AEB00  addi r10, r10, -0x1500
	ctx.r[10].s64 = ctx.r[10].s64 + -5376;
	pc = 0x822E0894; continue 'dispatch;
            }
            0x822E0894 => {
    //   block [0x822E0894..0x822E08A8)
	// 822E0894: 790707E0  clrldi r7, r8, 0x3f
	ctx.r[7].u64 = ctx.r[8].u64 & 0x0000000000000001u64;
	// 822E0898: 2B270000  cmpldi cr6, r7, 0
	ctx.cr[6].compare_u64(ctx.r[7].u64, 0, &mut ctx.xer);
	// 822E089C: 419A000C  beq cr6, 0x822e08a8
	if ctx.cr[6].eq {
	pc = 0x822E08A8; continue 'dispatch;
	}
	// 822E08A0: 552707FE  clrlwi r7, r9, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 822E08A4: 98EA0000  stb r7, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	pc = 0x822E08A8; continue 'dispatch;
            }
            0x822E08A8 => {
    //   block [0x822E08A8..0x822E08C0)
	// 822E08A8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E08AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E08B0: 7908F842  rldicl r8, r8, 0x3f, 1
	ctx.r[8].u64 = ctx.r[8].u64 & 0x0000000000000001u64;
	// 822E08B4: 7929F842  rldicl r9, r9, 0x3f, 1
	ctx.r[9].u64 = ctx.r[9].u64 & 0x0000000000000001u64;
	// 822E08B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E08BC: 409AFFD8  bne cr6, 0x822e0894
	if !ctx.cr[6].eq {
	pc = 0x822E0894; continue 'dispatch;
	}
	pc = 0x822E08C0; continue 'dispatch;
            }
            0x822E08C0 => {
    //   block [0x822E08C0..0x822E090C)
	// 822E08C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E08C4: 815F00D0  lwz r10, 0xd0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E08C8: B3DF00CC  sth r30, 0xcc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[30].u16 ) };
	// 822E08CC: B3DF00BC  sth r30, 0xbc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[30].u16 ) };
	// 822E08D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E08D4: B3DF00AC  sth r30, 0xac(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u16 ) };
	// 822E08D8: B3DF0052  sth r30, 0x52(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(82 as u32), ctx.r[30].u16 ) };
	// 822E08DC: B17F0028  sth r11, 0x28(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u16 ) };
	// 822E08E0: B17F0026  sth r11, 0x26(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[11].u16 ) };
	// 822E08E4: B3DF0002  sth r30, 2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[30].u16 ) };
	// 822E08E8: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 822E08EC: B17F00C0  sth r11, 0xc0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u16 ) };
	// 822E08F0: B17F00B0  sth r11, 0xb0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u16 ) };
	// 822E08F4: 917F0448  stw r11, 0x448(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1096 as u32), ctx.r[11].u32 ) };
	// 822E08F8: 419A0014  beq cr6, 0x822e090c
	if ctx.cr[6].eq {
	pc = 0x822E090C; continue 'dispatch;
	}
	// 822E08FC: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 822E0900: B3CB0002  sth r30, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[30].u16 ) };
	// 822E0904: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E0908: B3CB0002  sth r30, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[30].u16 ) };
	pc = 0x822E090C; continue 'dispatch;
            }
            0x822E090C => {
    //   block [0x822E090C..0x822E0930)
	// 822E090C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0910: 616BFAF0  ori r11, r11, 0xfaf0
	ctx.r[11].u64 = ctx.r[11].u64 | 64240;
	// 822E0914: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E0918: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822E091C: 409A0014  bne cr6, 0x822e0930
	if !ctx.cr[6].eq {
	pc = 0x822E0930; continue 'dispatch;
	}
	// 822E0920: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E0924: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 822E0928: 396BA928  addi r11, r11, -0x56d8
	ctx.r[11].s64 = ctx.r[11].s64 + -22232;
	// 822E092C: 914B0BD8  stw r10, 0xbd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3032 as u32), ctx.r[10].u32 ) };
	pc = 0x822E0930; continue 'dispatch;
            }
            0x822E0930 => {
    //   block [0x822E0930..0x822E0938)
	// 822E0930: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E0934: 482547D8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E0938 size=552
    let mut pc: u32 = 0x822E0938;
    'dispatch: loop {
        match pc {
            0x822E0938 => {
    //   block [0x822E0938..0x822E0A48)
	// 822E0938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E093C: 48254771  bl 0x825350ac
	ctx.lr = 0x822E0940;
	sub_82535080(ctx, base);
	// 822E0940: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0944: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 822E0948: 40990208  ble cr6, 0x822e0b50
	if !ctx.cr[6].gt {
	pc = 0x822E0B50; continue 'dispatch;
	}
	// 822E094C: A1660000  lhz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0950: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 822E0954: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822E0958: 409901F8  ble cr6, 0x822e0b50
	if !ctx.cr[6].gt {
	pc = 0x822E0B50; continue 'dispatch;
	}
	// 822E095C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822E0960: C0040008  lfs f0, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E0964: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822E0968: 7D650734  extsh r5, r11
	ctx.r[5].s64 = ctx.r[11].s16 as i64;
	// 822E096C: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 822E0970: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E0974: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822E0978: 409901D8  ble cr6, 0x822e0b50
	if !ctx.cr[6].gt {
	pc = 0x822E0B50; continue 'dispatch;
	}
	// 822E097C: 3D030002  addis r8, r3, 2
	ctx.r[8].s64 = ctx.r[3].s64 + 131072;
	// 822E0980: A1640000  lhz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0984: 3FA30002  addis r29, r3, 2
	ctx.r[29].s64 = ctx.r[3].s64 + 131072;
	// 822E0988: 3908FAF0  addi r8, r8, -0x510
	ctx.r[8].s64 = ctx.r[8].s64 + -1296;
	// 822E098C: 7D660734  extsh r6, r11
	ctx.r[6].s64 = ctx.r[11].s16 as i64;
	// 822E0990: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E0994: 3BBDFAF8  addi r29, r29, -0x508
	ctx.r[29].s64 = ctx.r[29].s64 + -1288;
	// 822E0998: 392BA908  addi r9, r11, -0x56f8
	ctx.r[9].s64 = ctx.r[11].s64 + -22264;
	// 822E099C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E09A0: 3F830002  addis r28, r3, 2
	ctx.r[28].s64 = ctx.r[3].s64 + 131072;
	// 822E09A4: 3F630002  addis r27, r3, 2
	ctx.r[27].s64 = ctx.r[3].s64 + 131072;
	// 822E09A8: 3B9CFB00  addi r28, r28, -0x500
	ctx.r[28].s64 = ctx.r[28].s64 + -1280;
	// 822E09AC: 3B7BFB08  addi r27, r27, -0x4f8
	ctx.r[27].s64 = ctx.r[27].s64 + -1272;
	// 822E09B0: 3F430002  addis r26, r3, 2
	ctx.r[26].s64 = ctx.r[3].s64 + 131072;
	// 822E09B4: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E09B8: 3F230002  addis r25, r3, 2
	ctx.r[25].s64 = ctx.r[3].s64 + 131072;
	// 822E09BC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E09C0: 3B5AFAFC  addi r26, r26, -0x504
	ctx.r[26].s64 = ctx.r[26].s64 + -1284;
	// 822E09C4: 1D460458  mulli r10, r6, 0x458
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * 1112 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822E09C8: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822E09CC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E09D0: 3B39FAF4  addi r25, r25, -0x50c
	ctx.r[25].s64 = ctx.r[25].s64 + -1292;
	// 822E09D4: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 822E09D8: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822E09DC: A17B0000  lhz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E09E0: 3CEA0002  addis r7, r10, 2
	ctx.r[7].s64 = ctx.r[10].s64 + 131072;
	// 822E09E4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E09E8: 38E7EEC8  addi r7, r7, -0x1138
	ctx.r[7].s64 = ctx.r[7].s64 + -4408;
	// 822E09EC: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 822E09F0: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822E09F4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E09F8: 91690010  stw r11, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 822E09FC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0A00: 91690014  stw r11, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 822E0A04: 48002615  bl 0x822e3018
	ctx.lr = 0x822E0A08;
	sub_822E3018(ctx, base);
	// 822E0A08: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0A0C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822E0A10: FD800890  fmr f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ctx.f[1].f64;
	// 822E0A14: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E0A18: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822E0A1C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822E0A20: FC00601E  fctiwz f0, f12
	ctx.f[0].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 822E0A24: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E0A28: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822E0A2C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822E0A30: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E0A34: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822E0A38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E0A3C: C16B1FF8  lfs f11, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E0A40: 41990008  bgt cr6, 0x822e0a48
	if ctx.cr[6].gt {
	pc = 0x822E0A48; continue 'dispatch;
	}
	// 822E0A44: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	pc = 0x822E0A48; continue 'dispatch;
            }
            0x822E0A48 => {
    //   block [0x822E0A48..0x822E0A94)
	// 822E0A48: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E0A4C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 822E0A50: 480025C9  bl 0x822e3018
	ctx.lr = 0x822E0A54;
	sub_822E3018(ctx, base);
	// 822E0A54: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E0A58: 816BA900  lwz r11, -0x5700(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22272 as u32) ) } as u64;
	// 822E0A5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E0A60: 419A0070  beq cr6, 0x822e0ad0
	if ctx.cr[6].eq {
	pc = 0x822E0AD0; continue 'dispatch;
	}
	// 822E0A64: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E0A68: C00BA8FC  lfs f0, -0x5704(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E0A6C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 822E0A70: 41980024  blt cr6, 0x822e0a94
	if ctx.cr[6].lt {
	pc = 0x822E0A94; continue 'dispatch;
	}
	// 822E0A74: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 822E0A78: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822E0A7C: FDA0601E  fctiwz f13, f12
	ctx.f[13].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 822E0A80: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822E0A84: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E0A88: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822E0A8C: 41990008  bgt cr6, 0x822e0a94
	if ctx.cr[6].gt {
	pc = 0x822E0A94; continue 'dispatch;
	}
	// 822E0A90: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	pc = 0x822E0A94; continue 'dispatch;
            }
            0x822E0A94 => {
    //   block [0x822E0A94..0x822E0AD0)
	// 822E0A94: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 822E0A98: 40980038  bge cr6, 0x822e0ad0
	if !ctx.cr[6].lt {
	pc = 0x822E0AD0; continue 'dispatch;
	}
	// 822E0A9C: 3940FFFD  li r10, -3
	ctx.r[10].s64 = -3;
	// 822E0AA0: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E0AA4: B15F00AC  sth r10, 0xac(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u16 ) };
	// 822E0AA8: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0AAC: 816BA924  lwz r11, -0x56dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22236 as u32) ) } as u64;
	// 822E0AB0: B0CA00AE  sth r6, 0xae(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(174 as u32), ctx.r[6].u16 ) };
	// 822E0AB4: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0AB8: D02A00B4  stfs f1, 0xb4(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822E0ABC: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0AC0: D00A00B8  stfs f0, 0xb8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822E0AC4: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0AC8: B16A00B0  sth r11, 0xb0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(176 as u32), ctx.r[11].u16 ) };
	// 822E0ACC: 48000048  b 0x822e0b14
	pc = 0x822E0B14; continue 'dispatch;
            }
            0x822E0AD0 => {
    //   block [0x822E0AD0..0x822E0B00)
	// 822E0AD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E0AD4: D1870060  stfs f12, 0x60(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E0AD8: D027005C  stfs f1, 0x5c(r7)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822E0ADC: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 822E0AE0: 91670088  stw r11, 0x88(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 822E0AE4: 409A001C  bne cr6, 0x822e0b00
	if !ctx.cr[6].eq {
	pc = 0x822E0B00; continue 'dispatch;
	}
	// 822E0AE8: 38C0FFFD  li r6, -3
	ctx.r[6].s64 = -3;
	// 822E0AEC: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 822E0AF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E0AF4: B0C70052  sth r6, 0x52(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(82 as u32), ctx.r[6].u16 ) };
	// 822E0AF8: 916AA554  stw r11, -0x5aac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-23212 as u32), ctx.r[11].u32 ) };
	// 822E0AFC: 4800000C  b 0x822e0b08
	pc = 0x822E0B08; continue 'dispatch;
            }
            0x822E0B00 => {
    //   block [0x822E0B00..0x822E0B08)
	// 822E0B00: 3960FFFD  li r11, -3
	ctx.r[11].s64 = -3;
	// 822E0B04: B1670052  sth r11, 0x52(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	pc = 0x822E0B08; continue 'dispatch;
            }
            0x822E0B08 => {
    //   block [0x822E0B08..0x822E0B14)
	// 822E0B08: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0B0C: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0B10: B167004E  sth r11, 0x4e(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(78 as u32), ctx.r[11].u16 ) };
	pc = 0x822E0B14; continue 'dispatch;
            }
            0x822E0B14 => {
    //   block [0x822E0B14..0x822E0B50)
	// 822E0B14: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0B18: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E0B1C: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E0B20: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E0B24: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E0B28: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E0B2C: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E0B30: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E0B34: B17B0000  sth r11, 0(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E0B38: 81690010  lwz r11, 0x10(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 822E0B3C: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E0B40: 81690014  lwz r11, 0x14(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 822E0B44: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E0B48: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822E0B4C: 482545B0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x822E0B50 => {
    //   block [0x822E0B50..0x822E0B60)
	// 822E0B50: 4BFFFC91  bl 0x822e07e0
	ctx.lr = 0x822E0B54;
	sub_822E07E0(ctx, base);
	// 822E0B54: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E0B58: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822E0B5C: 482545A0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0B60 size=24
    let mut pc: u32 = 0x822E0B60;
    'dispatch: loop {
        match pc {
            0x822E0B60 => {
    //   block [0x822E0B60..0x822E0B78)
	// 822E0B60: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0B64: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 822E0B68: 616BFAF0  ori r11, r11, 0xfaf0
	ctx.r[11].u64 = ctx.r[11].u64 | 64240;
	// 822E0B6C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822E0B70: 7C83582E  lwzx r4, r3, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E0B74: 4BFFFDC4  b 0x822e0938
	sub_822E0938(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0B78 size=20
    let mut pc: u32 = 0x822E0B78;
    'dispatch: loop {
        match pc {
            0x822E0B78 => {
    //   block [0x822E0B78..0x822E0B8C)
	// 822E0B78: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 822E0B7C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822E0B80: 3C830002  addis r4, r3, 2
	ctx.r[4].s64 = ctx.r[3].s64 + 131072;
	// 822E0B84: 3884EEC8  addi r4, r4, -0x1138
	ctx.r[4].s64 = ctx.r[4].s64 + -4408;
	// 822E0B88: 4BFFFDB0  b 0x822e0938
	sub_822E0938(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0B90 size=20
    let mut pc: u32 = 0x822E0B90;
    'dispatch: loop {
        match pc {
            0x822E0B90 => {
    //   block [0x822E0B90..0x822E0BA4)
	// 822E0B90: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 822E0B94: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822E0B98: 3C830002  addis r4, r3, 2
	ctx.r[4].s64 = ctx.r[3].s64 + 131072;
	// 822E0B9C: 3884F320  addi r4, r4, -0xce0
	ctx.r[4].s64 = ctx.r[4].s64 + -3296;
	// 822E0BA0: 4BFFFD98  b 0x822e0938
	sub_822E0938(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0BA8 size=24
    let mut pc: u32 = 0x822E0BA8;
    'dispatch: loop {
        match pc {
            0x822E0BA8 => {
    //   block [0x822E0BA8..0x822E0BC0)
	// 822E0BA8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0BAC: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 822E0BB0: 616BFAF4  ori r11, r11, 0xfaf4
	ctx.r[11].u64 = ctx.r[11].u64 | 64244;
	// 822E0BB4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822E0BB8: 7C83582E  lwzx r4, r3, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E0BBC: 4BFFFD7C  b 0x822e0938
	sub_822E0938(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0BC0 size=48
    let mut pc: u32 = 0x822E0BC0;
    'dispatch: loop {
        match pc {
            0x822E0BC0 => {
    //   block [0x822E0BC0..0x822E0BF0)
	// 822E0BC0: A1450000  lhz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0BC4: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E0BC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E0BCC: A1050002  lhz r8, 2(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E0BD0: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E0BD4: 6129FAF0  ori r9, r9, 0xfaf0
	ctx.r[9].u64 = ctx.r[9].u64 | 64240;
	// 822E0BD8: 394A002A  addi r10, r10, 0x2a
	ctx.r[10].s64 = ctx.r[10].s64 + 42;
	// 822E0BDC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E0BE0: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E0BE4: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E0BE8: 7D0A5B2E  sthx r8, r10, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u16) };
	// 822E0BEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0BF0 size=40
    let mut pc: u32 = 0x822E0BF0;
    'dispatch: loop {
        match pc {
            0x822E0BF0 => {
    //   block [0x822E0BF0..0x822E0C18)
	// 822E0BF0: A1450000  lhz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0BF4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E0BF8: A1250002  lhz r9, 2(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E0BFC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E0C00: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E0C04: 3D4A0001  addis r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 65536;
	// 822E0C08: 394AF78E  addi r10, r10, -0x872
	ctx.r[10].s64 = ctx.r[10].s64 + -2162;
	// 822E0C0C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E0C10: 7D2A5B2E  sthx r9, r10, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u16) };
	// 822E0C14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0C18 size=40
    let mut pc: u32 = 0x822E0C18;
    'dispatch: loop {
        match pc {
            0x822E0C18 => {
    //   block [0x822E0C18..0x822E0C40)
	// 822E0C18: A1450000  lhz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0C1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E0C20: A1250002  lhz r9, 2(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E0C24: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E0C28: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E0C2C: 3D4A0001  addis r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 65536;
	// 822E0C30: 394AF9BA  addi r10, r10, -0x646
	ctx.r[10].s64 = ctx.r[10].s64 + -1606;
	// 822E0C34: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E0C38: 7D2A5B2E  sthx r9, r10, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u16) };
	// 822E0C3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0C40 size=48
    let mut pc: u32 = 0x822E0C40;
    'dispatch: loop {
        match pc {
            0x822E0C40 => {
    //   block [0x822E0C40..0x822E0C70)
	// 822E0C40: A1450000  lhz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0C44: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E0C48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E0C4C: A1050002  lhz r8, 2(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E0C50: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E0C54: 6129FAF4  ori r9, r9, 0xfaf4
	ctx.r[9].u64 = ctx.r[9].u64 | 64244;
	// 822E0C58: 394A002A  addi r10, r10, 0x2a
	ctx.r[10].s64 = ctx.r[10].s64 + 42;
	// 822E0C5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E0C60: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E0C64: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E0C68: 7D0A5B2E  sthx r8, r10, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u16) };
	// 822E0C6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0C70 size=272
    let mut pc: u32 = 0x822E0C70;
    'dispatch: loop {
        match pc {
            0x822E0C70 => {
    //   block [0x822E0C70..0x822E0C98)
	// 822E0C70: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 822E0C74: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0C78: 3904FFFF  addi r8, r4, -1
	ctx.r[8].s64 = ctx.r[4].s64 + -1;
	// 822E0C7C: 616BFAF0  ori r11, r11, 0xfaf0
	ctx.r[11].u64 = ctx.r[11].u64 | 64240;
	// 822E0C80: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E0C84: 2F080010  cmpwi cr6, r8, 0x10
	ctx.cr[6].compare_i32(ctx.r[8].s32, 16, &mut ctx.xer);
	// 822E0C88: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E0C8C: 38EB01E4  addi r7, r11, 0x1e4
	ctx.r[7].s64 = ctx.r[11].s64 + 484;
	// 822E0C90: 419900E4  bgt cr6, 0x822e0d74
	if ctx.cr[6].gt {
	pc = 0x822E0D74; continue 'dispatch;
	}
	// 822E0C94: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x822E0C98; continue 'dispatch;
            }
            0x822E0C98 => {
    //   block [0x822E0C98..0x822E0CB4)
	// 822E0C98: A1670000  lhz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0C9C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E0CA0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822E0CA4: 409A0078  bne cr6, 0x822e0d1c
	if !ctx.cr[6].eq {
	pc = 0x822E0D1C; continue 'dispatch;
	}
	// 822E0CA8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 822E0CAC: 409A0070  bne cr6, 0x822e0d1c
	if !ctx.cr[6].eq {
	pc = 0x822E0D1C; continue 'dispatch;
	}
	// 822E0CB0: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	pc = 0x822E0CB4; continue 'dispatch;
            }
            0x822E0CB4 => {
    //   block [0x822E0CB4..0x822E0CF4)
	// 822E0CB4: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 822E0CB8: 38E70024  addi r7, r7, 0x24
	ctx.r[7].s64 = ctx.r[7].s64 + 36;
	// 822E0CBC: 2F040010  cmpwi cr6, r4, 0x10
	ctx.cr[6].compare_i32(ctx.r[4].s32, 16, &mut ctx.xer);
	// 822E0CC0: 4198FFD8  blt cr6, 0x822e0c98
	if ctx.cr[6].lt {
	pc = 0x822E0C98; continue 'dispatch;
	}
	// 822E0CC4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 822E0CC8: 419A00AC  beq cr6, 0x822e0d74
	if ctx.cr[6].eq {
	pc = 0x822E0D74; continue 'dispatch;
	}
	// 822E0CCC: A1650000  lhz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0CD0: 39250002  addi r9, r5, 2
	ctx.r[9].s64 = ctx.r[5].s64 + 2;
	// 822E0CD4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822E0CD8: 99060002  stb r8, 2(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(2 as u32), ctx.r[8].u8 ) };
	// 822E0CDC: B1660000  sth r11, 0(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E0CE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E0CE4: 99660003  stb r11, 3(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 822E0CE8: 40990028  ble cr6, 0x822e0d10
	if !ctx.cr[6].gt {
	pc = 0x822E0D10; continue 'dispatch;
	}
	// 822E0CEC: 39460004  addi r10, r6, 4
	ctx.r[10].s64 = ctx.r[6].s64 + 4;
	// 822E0CF0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x822E0CF4; continue 'dispatch;
            }
            0x822E0CF4 => {
    //   block [0x822E0CF4..0x822E0D10)
	// 822E0CF4: A1090000  lhz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0CF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E0CFC: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 822E0D00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E0D04: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 822E0D08: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 822E0D0C: 409AFFE8  bne cr6, 0x822e0cf4
	if !ctx.cr[6].eq {
	pc = 0x822E0CF4; continue 'dispatch;
	}
	pc = 0x822E0D10; continue 'dispatch;
            }
            0x822E0D10 => {
    //   block [0x822E0D10..0x822E0D1C)
	// 822E0D10: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E0D14: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 822E0D18: 4E800020  blr
	return;
            }
            0x822E0D1C => {
    //   block [0x822E0D1C..0x822E0D50)
	// 822E0D1C: A1450000  lhz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0D20: 39250002  addi r9, r5, 2
	ctx.r[9].s64 = ctx.r[5].s64 + 2;
	// 822E0D24: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E0D28: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822E0D2C: 409AFF88  bne cr6, 0x822e0cb4
	if !ctx.cr[6].eq {
	pc = 0x822E0CB4; continue 'dispatch;
	}
	// 822E0D30: 89670002  lbz r11, 2(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E0D34: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 822E0D38: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 822E0D3C: 409AFF78  bne cr6, 0x822e0cb4
	if !ctx.cr[6].eq {
	pc = 0x822E0CB4; continue 'dispatch;
	}
	// 822E0D40: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E0D44: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822E0D48: 4099002C  ble cr6, 0x822e0d74
	if !ctx.cr[6].gt {
	pc = 0x822E0D74; continue 'dispatch;
	}
	// 822E0D4C: 39670004  addi r11, r7, 4
	ctx.r[11].s64 = ctx.r[7].s64 + 4;
	pc = 0x822E0D50; continue 'dispatch;
            }
            0x822E0D50 => {
    //   block [0x822E0D50..0x822E0D74)
	// 822E0D50: A0690000  lhz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0D54: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 822E0D58: A3EB0000  lhz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0D5C: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 822E0D60: 409AFF54  bne cr6, 0x822e0cb4
	if !ctx.cr[6].eq {
	pc = 0x822E0CB4; continue 'dispatch;
	}
	// 822E0D64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E0D68: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 822E0D6C: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 822E0D70: 4198FFE0  blt cr6, 0x822e0d50
	if ctx.cr[6].lt {
	pc = 0x822E0D50; continue 'dispatch;
	}
	pc = 0x822E0D74; continue 'dispatch;
            }
            0x822E0D74 => {
    //   block [0x822E0D74..0x822E0D80)
	// 822E0D74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E0D78: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 822E0D7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E0D80 size=112
    let mut pc: u32 = 0x822E0D80;
    'dispatch: loop {
        match pc {
            0x822E0D80 => {
    //   block [0x822E0D80..0x822E0DB4)
	// 822E0D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0D84: 48254331  bl 0x825350b4
	ctx.lr = 0x822E0D88;
	sub_82535080(ctx, base);
	// 822E0D88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0D8C: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 822E0D90: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822E0D94: 616BA9C0  ori r11, r11, 0xa9c0
	ctx.r[11].u64 = ctx.r[11].u64 | 43456;
	// 822E0D98: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 822E0D9C: 7FA3582E  lwzx r29, r3, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E0DA0: 3FFD0002  addis r31, r29, 2
	ctx.r[31].s64 = ctx.r[29].s64 + 131072;
	// 822E0DA4: 3D7D0002  addis r11, r29, 2
	ctx.r[11].s64 = ctx.r[29].s64 + 131072;
	// 822E0DA8: 3BFFEC70  addi r31, r31, -0x1390
	ctx.r[31].s64 = ctx.r[31].s64 + -5008;
	// 822E0DAC: 396BECCC  addi r11, r11, -0x1334
	ctx.r[11].s64 = ctx.r[11].s64 + -4916;
	// 822E0DB0: 7F9F5850  subf r28, r31, r11
	ctx.r[28].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	pc = 0x822E0DB4; continue 'dispatch;
            }
            0x822E0DB4 => {
    //   block [0x822E0DB4..0x822E0DD8)
	// 822E0DB4: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0DB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E0DBC: 419A001C  beq cr6, 0x822e0dd8
	if ctx.cr[6].eq {
	pc = 0x822E0DD8; continue 'dispatch;
	}
	// 822E0DC0: 38C0000F  li r6, 0xf
	ctx.r[6].s64 = 15;
	// 822E0DC4: 7CBCF8AE  lbzx r5, r28, r31
	ctx.r[5].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822E0DC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E0DCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E0DD0: 4BE45849  bl 0x82126618
	ctx.lr = 0x822E0DD4;
	sub_82126618(ctx, base);
	// 822E0DD4: 9B7F0000  stb r27, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	pc = 0x822E0DD8; continue 'dispatch;
            }
            0x822E0DD8 => {
    //   block [0x822E0DD8..0x822E0DF0)
	// 822E0DD8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822E0DDC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822E0DE0: 2F1E005C  cmpwi cr6, r30, 0x5c
	ctx.cr[6].compare_i32(ctx.r[30].s32, 92, &mut ctx.xer);
	// 822E0DE4: 4198FFD0  blt cr6, 0x822e0db4
	if ctx.cr[6].lt {
	pc = 0x822E0DB4; continue 'dispatch;
	}
	// 822E0DE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E0DEC: 48254318  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E0DF0 size=60
    let mut pc: u32 = 0x822E0DF0;
    'dispatch: loop {
        match pc {
            0x822E0DF0 => {
    //   block [0x822E0DF0..0x822E0E2C)
	// 822E0DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E0DF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0DFC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0E00: A1450000  lhz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0E04: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822E0E08: 616BFB00  ori r11, r11, 0xfb00
	ctx.r[11].u64 = ctx.r[11].u64 | 64256;
	// 822E0E0C: 7D440734  extsh r4, r10
	ctx.r[4].s64 = ctx.r[10].s16 as i64;
	// 822E0E10: 7CC3582E  lwzx r6, r3, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E0E14: 4BE45805  bl 0x82126618
	ctx.lr = 0x822E0E18;
	sub_82126618(ctx, base);
	// 822E0E18: 7C630734  extsh r3, r3
	ctx.r[3].s64 = ctx.r[3].s16 as i64;
	// 822E0E1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E0E20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E0E24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E0E28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E0E30 size=60
    let mut pc: u32 = 0x822E0E30;
    'dispatch: loop {
        match pc {
            0x822E0E30 => {
    //   block [0x822E0E30..0x822E0E6C)
	// 822E0E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0E34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E0E38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0E3C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0E40: A1450000  lhz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0E44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E0E48: 616BFB00  ori r11, r11, 0xfb00
	ctx.r[11].u64 = ctx.r[11].u64 | 64256;
	// 822E0E4C: 7D440734  extsh r4, r10
	ctx.r[4].s64 = ctx.r[10].s16 as i64;
	// 822E0E50: 7CC3582E  lwzx r6, r3, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E0E54: 4BE457C5  bl 0x82126618
	ctx.lr = 0x822E0E58;
	sub_82126618(ctx, base);
	// 822E0E58: 7C630734  extsh r3, r3
	ctx.r[3].s64 = ctx.r[3].s16 as i64;
	// 822E0E5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E0E60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E0E64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E0E68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E0E70 size=64
    let mut pc: u32 = 0x822E0E70;
    'dispatch: loop {
        match pc {
            0x822E0E70 => {
    //   block [0x822E0E70..0x822E0EB0)
	// 822E0E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0E74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E0E78: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0E7C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0E80: A1250000  lhz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0E84: A1450002  lhz r10, 2(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E0E88: 616BFB00  ori r11, r11, 0xfb00
	ctx.r[11].u64 = ctx.r[11].u64 | 64256;
	// 822E0E8C: 7D450734  extsh r5, r10
	ctx.r[5].s64 = ctx.r[10].s16 as i64;
	// 822E0E90: 7D240734  extsh r4, r9
	ctx.r[4].s64 = ctx.r[9].s16 as i64;
	// 822E0E94: 7CC3582E  lwzx r6, r3, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E0E98: 4BE45711  bl 0x821265a8
	ctx.lr = 0x822E0E9C;
	sub_821265A8(ctx, base);
	// 822E0E9C: 7C630734  extsh r3, r3
	ctx.r[3].s64 = ctx.r[3].s16 as i64;
	// 822E0EA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E0EA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E0EA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E0EAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E0EB0 size=212
    let mut pc: u32 = 0x822E0EB0;
    'dispatch: loop {
        match pc {
            0x822E0EB0 => {
    //   block [0x822E0EB0..0x822E0F20)
	// 822E0EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0EB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E0EB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E0EBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E0EC0: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 822E0EC4: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 822E0EC8: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822E0ECC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0ED0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E0ED4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E0ED8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E0EDC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822E0EE0: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 822E0EE4: C3EB2074  lfs f31, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E0EE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E0EEC: C3AA1FF8  lfs f29, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822E0EF0: C3CB20B0  lfs f30, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822E0EF4: 4198002C  blt cr6, 0x822e0f20
	if ctx.cr[6].lt {
	pc = 0x822E0F20; continue 'dispatch;
	}
	// 822E0EF8: 419A0028  beq cr6, 0x822e0f20
	if ctx.cr[6].eq {
	pc = 0x822E0F20; continue 'dispatch;
	}
	// 822E0EFC: A07F0004  lhz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E0F00: 4BE35671  bl 0x82116570
	ctx.lr = 0x822E0F04;
	sub_82116570(ctx, base);
	// 822E0F04: EC0107B2  fmuls f0, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 822E0F08: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E0F0C: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 822E0F10: FC0D076E  fsel f0, f13, f29, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[29].f64 } else { ctx.f[0].f64 };
	// 822E0F14: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E0F18: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E0F1C: FFEC682E  fsel f31, f12, f0, f13
	ctx.f[31].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	pc = 0x822E0F20; continue 'dispatch;
            }
            0x822E0F20 => {
    //   block [0x822E0F20..0x822E0F54)
	// 822E0F20: A07F0002  lhz r3, 2(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E0F24: 4BE3564D  bl 0x82116570
	ctx.lr = 0x822E0F28;
	sub_82116570(ctx, base);
	// 822E0F28: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0F2C: FF1FE800  fcmpu cr6, f31, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 822E0F30: EC0107B2  fmuls f0, f1, f30
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 822E0F34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E0F38: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E0F3C: 394B7B89  addi r10, r11, 0x7b89
	ctx.r[10].s64 = ctx.r[11].s64 + 31625;
	// 822E0F40: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E0F44: 7FEAF52E  stfsx f31, r10, r30
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 822E0F48: 4198000C  blt cr6, 0x822e0f54
	if ctx.cr[6].lt {
	pc = 0x822E0F54; continue 'dispatch;
	}
	// 822E0F4C: 396B7B97  addi r11, r11, 0x7b97
	ctx.r[11].s64 = ctx.r[11].s64 + 31639;
	// 822E0F50: 48000008  b 0x822e0f58
	pc = 0x822E0F58; continue 'dispatch;
            }
            0x822E0F54 => {
    //   block [0x822E0F54..0x822E0F58)
	// 822E0F54: 396B7B7B  addi r11, r11, 0x7b7b
	ctx.r[11].s64 = ctx.r[11].s64 + 31611;
	pc = 0x822E0F58; continue 'dispatch;
            }
            0x822E0F58 => {
    //   block [0x822E0F58..0x822E0F84)
	// 822E0F58: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E0F5C: 7C0BF52E  stfsx f0, r11, r30
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 822E0F60: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E0F64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E0F68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E0F6C: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822E0F70: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822E0F74: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822E0F78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E0F7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E0F80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0F88 size=340
    let mut pc: u32 = 0x822E0F88;
    'dispatch: loop {
        match pc {
            0x822E0F88 => {
    //   block [0x822E0F88..0x822E0FD0)
	// 822E0F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0F8C: 48254125  bl 0x825350b0
	ctx.lr = 0x822E0F90;
	sub_82535080(ctx, base);
	// 822E0F90: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0F94: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822E0F98: 617AEEC8  ori r26, r11, 0xeec8
	ctx.r[26].u64 = ctx.r[11].u64 | 61128;
	// 822E0F9C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0FA0: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 822E0FA4: 617FF8E0  ori r31, r11, 0xf8e0
	ctx.r[31].u64 = ctx.r[11].u64 | 63712;
	// 822E0FA8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0FAC: 3B600002  li r27, 2
	ctx.r[27].s64 = 2;
	// 822E0FB0: 6164F990  ori r4, r11, 0xf990
	ctx.r[4].u64 = ctx.r[11].u64 | 63888;
	// 822E0FB4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0FB8: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 822E0FBC: 6165F780  ori r5, r11, 0xf780
	ctx.r[5].u64 = ctx.r[11].u64 | 63360;
	// 822E0FC0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E0FC4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 822E0FC8: 6166F830  ori r6, r11, 0xf830
	ctx.r[6].u64 = ctx.r[11].u64 | 63536;
	// 822E0FCC: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	pc = 0x822E0FD0; continue 'dispatch;
            }
            0x822E0FD0 => {
    //   block [0x822E0FD0..0x822E1008)
	// 822E0FD0: 1D7E0458  mulli r11, r30, 0x458
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E0FD4: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822E0FD8: 2B1E0001  cmplwi cr6, r30, 1
	ctx.cr[6].compare_u32(ctx.r[30].u32, 1 as u32, &mut ctx.xer);
	// 822E0FDC: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 822E0FE0: B3CB0000  sth r30, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u16 ) };
	// 822E0FE4: 41980024  blt cr6, 0x822e1008
	if ctx.cr[6].lt {
	pc = 0x822E1008; continue 'dispatch;
	}
	// 822E0FE8: 409A0038  bne cr6, 0x822e1020
	if !ctx.cr[6].eq {
	pc = 0x822E1020; continue 'dispatch;
	}
	// 822E0FEC: 7D43FA14  add r10, r3, r31
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[31].u64;
	// 822E0FF0: 7D232214  add r9, r3, r4
	ctx.r[9].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 822E0FF4: 914B00D0  stw r10, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 822E0FF8: B36A0000  sth r27, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[27].u16 ) };
	// 822E0FFC: 912B00D4  stw r9, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[9].u32 ) };
	// 822E1000: B3890000  sth r28, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[28].u16 ) };
	// 822E1004: 4800001C  b 0x822e1020
	pc = 0x822E1020; continue 'dispatch;
            }
            0x822E1008 => {
    //   block [0x822E1008..0x822E1020)
	// 822E1008: 7D432A14  add r10, r3, r5
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[5].u64;
	// 822E100C: 7D233214  add r9, r3, r6
	ctx.r[9].u64 = ctx.r[3].u64 + ctx.r[6].u64;
	// 822E1010: 914B00D0  stw r10, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 822E1014: B0EA0000  sth r7, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 822E1018: 912B00D4  stw r9, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[9].u32 ) };
	// 822E101C: B3A90000  sth r29, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[29].u16 ) };
	pc = 0x822E1020; continue 'dispatch;
            }
            0x822E1020 => {
    //   block [0x822E1020..0x822E1068)
	// 822E1020: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E1024: B0EB0028  sth r7, 0x28(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[7].u16 ) };
	// 822E1028: B0EB0026  sth r7, 0x26(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(38 as u32), ctx.r[7].u16 ) };
	// 822E102C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E1030: B10B00CC  sth r8, 0xcc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(204 as u32), ctx.r[8].u16 ) };
	// 822E1034: B10B00BC  sth r8, 0xbc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), ctx.r[8].u16 ) };
	// 822E1038: B10B00AC  sth r8, 0xac(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), ctx.r[8].u16 ) };
	// 822E103C: B10B0052  sth r8, 0x52(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(82 as u32), ctx.r[8].u16 ) };
	// 822E1040: B10B0002  sth r8, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 822E1044: 90EB002C  stw r7, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[7].u32 ) };
	// 822E1048: B0EB00C0  sth r7, 0xc0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), ctx.r[7].u16 ) };
	// 822E104C: B0EB00B0  sth r7, 0xb0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[7].u16 ) };
	// 822E1050: 90EB0448  stw r7, 0x448(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1096 as u32), ctx.r[7].u32 ) };
	// 822E1054: 419A0014  beq cr6, 0x822e1068
	if ctx.cr[6].eq {
	pc = 0x822E1068; continue 'dispatch;
	}
	// 822E1058: 814B00D4  lwz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 822E105C: B10A0002  sth r8, 2(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 822E1060: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E1064: B10A0002  sth r8, 2(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	pc = 0x822E1068; continue 'dispatch;
            }
            0x822E1068 => {
    //   block [0x822E1068..0x822E1070)
	// 822E1068: 394B01E4  addi r10, r11, 0x1e4
	ctx.r[10].s64 = ctx.r[11].s64 + 484;
	// 822E106C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	pc = 0x822E1070; continue 'dispatch;
            }
            0x822E1070 => {
    //   block [0x822E1070..0x822E10DC)
	// 822E1070: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E1074: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 822E1078: 394A0024  addi r10, r10, 0x24
	ctx.r[10].s64 = ctx.r[10].s64 + 36;
	// 822E107C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E1080: 409AFFF0  bne cr6, 0x822e1070
	if !ctx.cr[6].eq {
	pc = 0x822E1070; continue 'dispatch;
	}
	// 822E1084: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822E1088: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 822E108C: 4099FF44  ble cr6, 0x822e0fd0
	if !ctx.cr[6].gt {
	pc = 0x822E0FD0; continue 'dispatch;
	}
	// 822E1090: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E1094: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E1098: 616BFA42  ori r11, r11, 0xfa42
	ctx.r[11].u64 = ctx.r[11].u64 | 64066;
	// 822E109C: 614AF846  ori r10, r10, 0xf846
	ctx.r[10].u64 = ctx.r[10].u64 | 63558;
	// 822E10A0: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E10A4: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 822E10A8: 6129F796  ori r9, r9, 0xf796
	ctx.r[9].u64 = ctx.r[9].u64 | 63382;
	// 822E10AC: 7D035B2E  sthx r8, r3, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u16) };
	// 822E10B0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E10B4: 7CE3532E  sthx r7, r3, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u16) };
	// 822E10B8: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E10BC: 60C6F9A6  ori r6, r6, 0xf9a6
	ctx.r[6].u64 = ctx.r[6].u64 | 63910;
	// 822E10C0: 616BF8F6  ori r11, r11, 0xf8f6
	ctx.r[11].u64 = ctx.r[11].u64 | 63734;
	// 822E10C4: 614AFA56  ori r10, r10, 0xfa56
	ctx.r[10].u64 = ctx.r[10].u64 | 64086;
	// 822E10C8: 7CE34B2E  sthx r7, r3, r9
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u16) };
	// 822E10CC: 7FA3332E  sthx r29, r3, r6
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[6].u32), ctx.r[29].u16) };
	// 822E10D0: 7FA35B2E  sthx r29, r3, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[29].u16) };
	// 822E10D4: 7D03532E  sthx r8, r3, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u16) };
	// 822E10D8: 48254028  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E10E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E10E0 size=84
    let mut pc: u32 = 0x822E10E0;
    'dispatch: loop {
        match pc {
            0x822E10E0 => {
    //   block [0x822E10E0..0x822E1134)
	// 822E10E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E10E4: 812300D0  lwz r9, 0xd0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E10E8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822E10EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822E10F0: B1430028  sth r10, 0x28(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[10].u16 ) };
	// 822E10F4: B1430026  sth r10, 0x26(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(38 as u32), ctx.r[10].u16 ) };
	// 822E10F8: B16300CC  sth r11, 0xcc(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), ctx.r[11].u16 ) };
	// 822E10FC: B16300BC  sth r11, 0xbc(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), ctx.r[11].u16 ) };
	// 822E1100: B16300AC  sth r11, 0xac(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[11].u16 ) };
	// 822E1104: B1630052  sth r11, 0x52(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 822E1108: B1630002  sth r11, 2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	// 822E110C: 9143002C  stw r10, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 822E1110: B14300C0  sth r10, 0xc0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[10].u16 ) };
	// 822E1114: B14300B0  sth r10, 0xb0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[10].u16 ) };
	// 822E1118: 91430448  stw r10, 0x448(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1096 as u32), ctx.r[10].u32 ) };
	// 822E111C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822E1120: 814300D4  lwz r10, 0xd4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 822E1124: B16A0002  sth r11, 2(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	// 822E1128: 814300D0  lwz r10, 0xd0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E112C: B16A0002  sth r11, 2(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	// 822E1130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E1138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E1138 size=376
    let mut pc: u32 = 0x822E1138;
    'dispatch: loop {
        match pc {
            0x822E1138 => {
    //   block [0x822E1138..0x822E1184)
	// 822E1138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E113C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E1140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E1144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E1148: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E114C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E1150: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E1154: A17F0052  lhz r11, 0x52(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(82 as u32) ) } as u64;
	// 822E1158: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E115C: 419A013C  beq cr6, 0x822e1298
	if ctx.cr[6].eq {
	pc = 0x822E1298; continue 'dispatch;
	}
	// 822E1160: A17F0054  lhz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 822E1164: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E1168: 419A001C  beq cr6, 0x822e1184
	if ctx.cr[6].eq {
	pc = 0x822E1184; continue 'dispatch;
	}
	// 822E116C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E1170: 614AEB39  ori r10, r10, 0xeb39
	ctx.r[10].u64 = ctx.r[10].u64 | 60217;
	// 822E1174: 7D5E50AE  lbzx r10, r30, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E1178: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E117C: 419A0008  beq cr6, 0x822e1184
	if ctx.cr[6].eq {
	pc = 0x822E1184; continue 'dispatch;
	}
	// 822E1180: B17F0052  sth r11, 0x52(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	pc = 0x822E1184; continue 'dispatch;
            }
            0x822E1184 => {
    //   block [0x822E1184..0x822E11A8)
	// 822E1184: A17F0056  lhz r11, 0x56(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(86 as u32) ) } as u64;
	// 822E1188: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E118C: 614AEB22  ori r10, r10, 0xeb22
	ctx.r[10].u64 = ctx.r[10].u64 | 60194;
	// 822E1190: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E1194: 419A0014  beq cr6, 0x822e11a8
	if ctx.cr[6].eq {
	pc = 0x822E11A8; continue 'dispatch;
	}
	// 822E1198: 7D3E50AE  lbzx r9, r30, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E119C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822E11A0: 419A0008  beq cr6, 0x822e11a8
	if ctx.cr[6].eq {
	pc = 0x822E11A8; continue 'dispatch;
	}
	// 822E11A4: B17F0052  sth r11, 0x52(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	pc = 0x822E11A8; continue 'dispatch;
            }
            0x822E11A8 => {
    //   block [0x822E11A8..0x822E11E4)
	// 822E11A8: A17F0058  lhz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 822E11AC: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E11B0: 419A0034  beq cr6, 0x822e11e4
	if ctx.cr[6].eq {
	pc = 0x822E11E4; continue 'dispatch;
	}
	// 822E11B4: 7D5E50AE  lbzx r10, r30, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E11B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E11BC: 419A0028  beq cr6, 0x822e11e4
	if ctx.cr[6].eq {
	pc = 0x822E11E4; continue 'dispatch;
	}
	// 822E11C0: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 822E11C4: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E11C8: 614AA9C0  ori r10, r10, 0xa9c0
	ctx.r[10].u64 = ctx.r[10].u64 | 43456;
	// 822E11CC: 6129E2E0  ori r9, r9, 0xe2e0
	ctx.r[9].u64 = ctx.r[9].u64 | 58080;
	// 822E11D0: 7D5E502E  lwzx r10, r30, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E11D4: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E11D8: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 822E11DC: 41980008  blt cr6, 0x822e11e4
	if ctx.cr[6].lt {
	pc = 0x822E11E4; continue 'dispatch;
	}
	// 822E11E0: B17F0052  sth r11, 0x52(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	pc = 0x822E11E4; continue 'dispatch;
            }
            0x822E11E4 => {
    //   block [0x822E11E4..0x822E1220)
	// 822E11E4: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E11E8: A15F004E  lhz r10, 0x4e(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(78 as u32) ) } as u64;
	// 822E11EC: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 822E11F0: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 822E11F4: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 822E11F8: 1D6B0458  mulli r11, r11, 0x458
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E11FC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822E1200: 3D6B0002  addis r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 131072;
	// 822E1204: 396BEEC8  addi r11, r11, -0x1138
	ctx.r[11].s64 = ctx.r[11].s64 + -4408;
	// 822E1208: 409A0018  bne cr6, 0x822e1220
	if !ctx.cr[6].eq {
	pc = 0x822E1220; continue 'dispatch;
	}
	// 822E120C: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1210: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E1214: 409A000C  bne cr6, 0x822e1220
	if !ctx.cr[6].eq {
	pc = 0x822E1220; continue 'dispatch;
	}
	// 822E1218: C00B0020  lfs f0, 0x20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E121C: 48000008  b 0x822e1224
	pc = 0x822E1224; continue 'dispatch;
            }
            0x822E1220 => {
    //   block [0x822E1220..0x822E1224)
	// 822E1220: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x822E1224; continue 'dispatch;
            }
            0x822E1224 => {
    //   block [0x822E1224..0x822E1290)
	// 822E1224: C1BF0060  lfs f13, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E1228: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822E122C: 4199006C  bgt cr6, 0x822e1298
	if ctx.cr[6].gt {
	pc = 0x822E1298; continue 'dispatch;
	}
	// 822E1230: A17F0052  lhz r11, 0x52(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(82 as u32) ) } as u64;
	// 822E1234: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E1238: 7D650734  extsh r5, r11
	ctx.r[5].s64 = ctx.r[11].s16 as i64;
	// 822E123C: 2F05FFFD  cmpwi cr6, r5, -3
	ctx.cr[6].compare_i32(ctx.r[5].s32, -3, &mut ctx.xer);
	// 822E1240: 419A0050  beq cr6, 0x822e1290
	if ctx.cr[6].eq {
	pc = 0x822E1290; continue 'dispatch;
	}
	// 822E1244: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 822E1248: 38DF008C  addi r6, r31, 0x8c
	ctx.r[6].s64 = ctx.r[31].s64 + 140;
	// 822E124C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E1250: C03F005C  lfs f1, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E1254: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822E1258: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 822E125C: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 822E1260: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822E1264: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 822E1268: 48000571  bl 0x822e17d8
	ctx.lr = 0x822E126C;
	sub_822E17D8(ctx, base);
	// 822E126C: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1270: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E1274: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822E1278: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E127C: 614AEEF4  ori r10, r10, 0xeef4
	ctx.r[10].u64 = ctx.r[10].u64 | 61172;
	// 822E1280: 1D6B0458  mulli r11, r11, 0x458
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E1284: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822E1288: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 822E128C: 4800000C  b 0x822e1298
	pc = 0x822E1298; continue 'dispatch;
            }
            0x822E1290 => {
    //   block [0x822E1290..0x822E1298)
	// 822E1290: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E1294: 4BFFF54D  bl 0x822e07e0
	ctx.lr = 0x822E1298;
	sub_822E07E0(ctx, base);
	pc = 0x822E1298; continue 'dispatch;
            }
            0x822E1298 => {
    //   block [0x822E1298..0x822E12B0)
	// 822E1298: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E129C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E12A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E12A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E12A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E12AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E12B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E12B0 size=632
    let mut pc: u32 = 0x822E12B0;
    'dispatch: loop {
        match pc {
            0x822E12B0 => {
    //   block [0x822E12B0..0x822E1324)
	// 822E12B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E12B4: 48253DDD  bl 0x82535090
	ctx.lr = 0x822E12B8;
	sub_82535080(ctx, base);
	// 822E12B8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E12BC: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 822E12C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822E12C4: 1D740458  mulli r11, r20, 0x458
	ctx.r[11].s32 = ((ctx.r[20].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E12C8: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 822E12CC: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 822E12D0: 3FEB0002  addis r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 131072;
	// 822E12D4: 3BFFEEC8  addi r31, r31, -0x1138
	ctx.r[31].s64 = ctx.r[31].s64 + -4408;
	// 822E12D8: A17F004C  lhz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 822E12DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E12E0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E12E4: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 822E12E8: B17F004C  sth r11, 0x4c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u16 ) };
	// 822E12EC: 419901EC  bgt cr6, 0x822e14d8
	if ctx.cr[6].gt {
	pc = 0x822E14D8; continue 'dispatch;
	}
	// 822E12F0: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E12F4: 3E5D0005  addis r18, r29, 5
	ctx.r[18].s64 = ctx.r[29].s64 + 327680;
	// 822E12F8: 3B8BA928  addi r28, r11, -0x56d8
	ctx.r[28].s64 = ctx.r[11].s64 + -22232;
	// 822E12FC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E1300: 3A527DE8  addi r18, r18, 0x7de8
	ctx.r[18].s64 = ctx.r[18].s64 + 32232;
	// 822E1304: 3A6BBFF0  addi r19, r11, -0x4010
	ctx.r[19].s64 = ctx.r[11].s64 + -16400;
	// 822E1308: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E130C: 3F40829F  lis r26, -0x7d61
	ctx.r[26].s64 = -2103508992;
	// 822E1310: 6175FB1C  ori r21, r11, 0xfb1c
	ctx.r[21].u64 = ctx.r[11].u64 | 64284;
	// 822E1314: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E1318: 3EE0829F  lis r23, -0x7d61
	ctx.r[23].s64 = -2103508992;
	// 822E131C: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 822E1320: 6179BE64  ori r25, r11, 0xbe64
	ctx.r[25].u64 = ctx.r[11].u64 | 48740;
	pc = 0x822E1324; continue 'dispatch;
            }
            0x822E1324 => {
    //   block [0x822E1324..0x822E133C)
	// 822E1324: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E1328: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E132C: 4BFFEE05  bl 0x822e0130
	ctx.lr = 0x822E1330;
	sub_822E0130(ctx, base);
	// 822E1330: 4BFFFE09  bl 0x822e1138
	ctx.lr = 0x822E1334;
	sub_822E1138(ctx, base);
	// 822E1334: 3BDF01E4  addi r30, r31, 0x1e4
	ctx.r[30].s64 = ctx.r[31].s64 + 484;
	// 822E1338: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	pc = 0x822E133C; continue 'dispatch;
            }
            0x822E133C => {
    //   block [0x822E133C..0x822E138C)
	// 822E133C: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1340: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E1344: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822E1348: 419A0044  beq cr6, 0x822e138c
	if ctx.cr[6].eq {
	pc = 0x822E138C; continue 'dispatch;
	}
	// 822E134C: 895E0003  lbz r10, 3(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(3 as u32) ) } as u64;
	// 822E1350: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E1354: 409A0038  bne cr6, 0x822e138c
	if !ctx.cr[6].eq {
	pc = 0x822E138C; continue 'dispatch;
	}
	// 822E1358: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 822E135C: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E1360: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822E1364: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 822E1368: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822E136C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822E1370: 4199001C  bgt cr6, 0x822e138c
	if ctx.cr[6].gt {
	pc = 0x822E138C; continue 'dispatch;
	}
	// 822E1374: 897E0002  lbz r11, 2(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E1378: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 822E137C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E1380: 9B1E0003  stb r24, 3(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(3 as u32), ctx.r[24].u8 ) };
	// 822E1384: 7D640774  extsb r4, r11
	ctx.r[4].s64 = ctx.r[11].s8 as i64;
	// 822E1388: 4BE35399  bl 0x82116720
	ctx.lr = 0x822E138C;
	sub_82116720(ctx, base);
	pc = 0x822E138C; continue 'dispatch;
            }
            0x822E138C => {
    //   block [0x822E138C..0x822E13B4)
	// 822E138C: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 822E1390: 3BDE0024  addi r30, r30, 0x24
	ctx.r[30].s64 = ctx.r[30].s64 + 36;
	// 822E1394: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822E1398: 409AFFA4  bne cr6, 0x822e133c
	if !ctx.cr[6].eq {
	pc = 0x822E133C; continue 'dispatch;
	}
	// 822E139C: A17F0002  lhz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E13A0: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 822E13A4: 2F04FFFE  cmpwi cr6, r4, -2
	ctx.cr[6].compare_i32(ctx.r[4].s32, -2, &mut ctx.xer);
	// 822E13A8: 4198000C  blt cr6, 0x822e13b4
	if ctx.cr[6].lt {
	pc = 0x822E13B4; continue 'dispatch;
	}
	// 822E13AC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 822E13B0: 41980080  blt cr6, 0x822e1430
	if ctx.cr[6].lt {
	pc = 0x822E1430; continue 'dispatch;
	}
	pc = 0x822E13B4; continue 'dispatch;
            }
            0x822E13B4 => {
    //   block [0x822E13B4..0x822E13D4)
	// 822E13B4: 7FDDA82E  lwzx r30, r29, r21
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 822E13B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E13BC: 4BFFE97D  bl 0x822dfd38
	ctx.lr = 0x822E13C0;
	sub_822DFD38(ctx, base);
	// 822E13C0: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 822E13C4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 822E13C8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822E13CC: 419A0008  beq cr6, 0x822e13d4
	if ctx.cr[6].eq {
	pc = 0x822E13D4; continue 'dispatch;
	}
	// 822E13D0: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	pc = 0x822E13D4; continue 'dispatch;
            }
            0x822E13D4 => {
    //   block [0x822E13D4..0x822E1430)
	// 822E13D4: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 822E13D8: A0BF0064  lhz r5, 0x64(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 822E13DC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822E13E0: B31F0048  sth r24, 0x48(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[24].u16 ) };
	// 822E13E4: 9177A900  stw r11, -0x5700(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(-22272 as u32), ctx.r[11].u32 ) };
	// 822E13E8: 917AA554  stw r11, -0x5aac(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(-23212 as u32), ctx.r[11].u32 ) };
	// 822E13EC: 419A0044  beq cr6, 0x822e1430
	if ctx.cr[6].eq {
	pc = 0x822E1430; continue 'dispatch;
	}
	// 822E13F0: 917C0BD8  stw r11, 0xbd8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(3032 as u32), ctx.r[11].u32 ) };
	// 822E13F4: 38DF0066  addi r6, r31, 0x66
	ctx.r[6].s64 = ctx.r[31].s64 + 102;
	// 822E13F8: B17C0BDC  sth r11, 0xbdc(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(3036 as u32), ctx.r[11].u16 ) };
	// 822E13FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E1400: 917C0BE0  stw r11, 0xbe0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(3040 as u32), ctx.r[11].u32 ) };
	// 822E1404: 7D7DC8AE  lbzx r11, r29, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 822E1408: 1D6B01E0  mulli r11, r11, 0x1e0
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 480 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E140C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 822E1410: 917C03C0  stw r11, 0x3c0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(960 as u32), ctx.r[11].u32 ) };
	// 822E1414: 48003395  bl 0x822e47a8
	ctx.lr = 0x822E1418;
	sub_822E47A8(ctx, base);
	// 822E1418: 817AA554  lwz r11, -0x5aac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-23212 as u32) ) } as u64;
	// 822E141C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E1420: 419A0010  beq cr6, 0x822e1430
	if ctx.cr[6].eq {
	pc = 0x822E1430; continue 'dispatch;
	}
	// 822E1424: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E1428: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E142C: 4BFFFD0D  bl 0x822e1138
	ctx.lr = 0x822E1430;
	sub_822E1138(ctx, base);
	pc = 0x822E1430; continue 'dispatch;
            }
            0x822E1430 => {
    //   block [0x822E1430..0x822E1458)
	// 822E1430: A17F0002  lhz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E1434: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E1438: 419A0034  beq cr6, 0x822e146c
	if ctx.cr[6].eq {
	pc = 0x822E146C; continue 'dispatch;
	}
	// 822E143C: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E1440: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822E1444: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E1448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E144C: 419A000C  beq cr6, 0x822e1458
	if ctx.cr[6].eq {
	pc = 0x822E1458; continue 'dispatch;
	}
	// 822E1450: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E1454: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x822E1458; continue 'dispatch;
            }
            0x822E1458 => {
    //   block [0x822E1458..0x822E146C)
	// 822E1458: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 822E145C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E1460: 419A000C  beq cr6, 0x822e146c
	if ctx.cr[6].eq {
	pc = 0x822E146C; continue 'dispatch;
	}
	// 822E1464: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E1468: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x822E146C; continue 'dispatch;
            }
            0x822E146C => {
    //   block [0x822E146C..0x822E149C)
	// 822E146C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E1470: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E1474: 4BFFE95D  bl 0x822dfdd0
	ctx.lr = 0x822E1478;
	sub_822DFDD0(ctx, base);
	// 822E1478: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 822E147C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E1480: 419A001C  beq cr6, 0x822e149c
	if ctx.cr[6].eq {
	pc = 0x822E149C; continue 'dispatch;
	}
	// 822E1484: A17F0048  lhz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 822E1488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E148C: 409A0010  bne cr6, 0x822e149c
	if !ctx.cr[6].eq {
	pc = 0x822E149C; continue 'dispatch;
	}
	// 822E1490: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 822E1494: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E1498: 48000091  bl 0x822e1528
	ctx.lr = 0x822E149C;
	sub_822E1528(ctx, base);
	pc = 0x822E149C; continue 'dispatch;
            }
            0x822E149C => {
    //   block [0x822E149C..0x822E14D8)
	// 822E149C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E14A0: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 822E14A4: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 822E14A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E14AC: 7C135C2E  lfsx f0, r19, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E14B0: D0120000  stfs f0, 0(r18)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E14B4: 480015F5  bl 0x822e2aa8
	ctx.lr = 0x822E14B8;
	sub_822E2AA8(ctx, base);
	// 822E14B8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 822E14BC: 419A0064  beq cr6, 0x822e1520
	if ctx.cr[6].eq {
	pc = 0x822E1520; continue 'dispatch;
	}
	// 822E14C0: A17F004C  lhz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 822E14C4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E14C8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E14CC: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 822E14D0: B17F004C  sth r11, 0x4c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u16 ) };
	// 822E14D4: 4099FE50  ble cr6, 0x822e1324
	if !ctx.cr[6].gt {
	pc = 0x822E1324; continue 'dispatch;
	}
	pc = 0x822E14D8; continue 'dispatch;
            }
            0x822E14D8 => {
    //   block [0x822E14D8..0x822E1518)
	// 822E14D8: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 822E14DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E14E0: 409A0038  bne cr6, 0x822e1518
	if !ctx.cr[6].eq {
	pc = 0x822E1518; continue 'dispatch;
	}
	// 822E14E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E14E8: 92C1005C  stw r22, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 822E14EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E14F0: 92C10054  stw r22, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	// 822E14F4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822E14F8: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 822E14FC: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 822E1500: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E1504: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E1508: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822E150C: 480002CD  bl 0x822e17d8
	ctx.lr = 0x822E1510;
	sub_822E17D8(ctx, base);
	// 822E1510: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822E1514: 48253BCC  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
            }
            0x822E1518 => {
    //   block [0x822E1518..0x822E1520)
	// 822E1518: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E151C: 4BFFF2C5  bl 0x822e07e0
	ctx.lr = 0x822E1520;
	sub_822E07E0(ctx, base);
	pc = 0x822E1520; continue 'dispatch;
            }
            0x822E1520 => {
    //   block [0x822E1520..0x822E1528)
	// 822E1520: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822E1524: 48253BBC  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E1528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E1528 size=324
    let mut pc: u32 = 0x822E1528;
    'dispatch: loop {
        match pc {
            0x822E1528 => {
    //   block [0x822E1528..0x822E15E4)
	// 822E1528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E152C: 48253B8D  bl 0x825350b8
	ctx.lr = 0x822E1530;
	sub_82535080(ctx, base);
	// 822E1530: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E1534: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E1538: 1D640458  mulli r11, r4, 0x458
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E153C: 7D4BFA14  add r10, r11, r31
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 822E1540: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E1544: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E1548: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 822E154C: 616BEEC8  ori r11, r11, 0xeec8
	ctx.r[11].u64 = ctx.r[11].u64 | 61128;
	// 822E1550: 6129FAF0  ori r9, r9, 0xfaf0
	ctx.r[9].u64 = ctx.r[9].u64 | 64240;
	// 822E1554: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E1558: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 822E155C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E1560: 6108FAF8  ori r8, r8, 0xfaf8
	ctx.r[8].u64 = ctx.r[8].u64 | 64248;
	// 822E1564: 6165FAFC  ori r5, r11, 0xfafc
	ctx.r[5].u64 = ctx.r[11].u64 | 64252;
	// 822E1568: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E156C: 7FDF492E  stwx r30, r31, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	// 822E1570: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 822E1574: 6164FAF4  ori r4, r11, 0xfaf4
	ctx.r[4].u64 = ctx.r[11].u64 | 64244;
	// 822E1578: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E157C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E1580: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E1584: 614AFB00  ori r10, r10, 0xfb00
	ctx.r[10].u64 = ctx.r[10].u64 | 64256;
	// 822E1588: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 822E158C: 60E7FB08  ori r7, r7, 0xfb08
	ctx.r[7].u64 = ctx.r[7].u64 | 64264;
	// 822E1590: 7D7F412E  stwx r11, r31, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 822E1594: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1598: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E159C: 7F8B5830  slw r11, r28, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[28].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 822E15A0: 7D7F512E  stwx r11, r31, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 822E15A4: A17E0002  lhz r11, 2(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E15A8: 7D7F3B2E  sthx r11, r31, r7
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u16) };
	// 822E15AC: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E15B0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E15B4: 216B0001  subfic r11, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[11].s64 = (1 as i64) - ctx.r[11].s64;
	// 822E15B8: 1D4B0458  mulli r10, r11, 0x458
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 1112 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822E15BC: 7D7F292E  stwx r11, r31, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[5].u32), ctx.r[11].u32) };
	// 822E15C0: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 822E15C4: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 822E15C8: 7D5F212E  stwx r10, r31, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[4].u32), ctx.r[10].u32) };
	// 822E15CC: A17E0002  lhz r11, 2(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E15D0: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 822E15D4: 2F04FFFE  cmpwi cr6, r4, -2
	ctx.cr[6].compare_i32(ctx.r[4].s32, -2, &mut ctx.xer);
	// 822E15D8: 4198000C  blt cr6, 0x822e15e4
	if ctx.cr[6].lt {
	pc = 0x822E15E4; continue 'dispatch;
	}
	// 822E15DC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 822E15E0: 41980084  blt cr6, 0x822e1664
	if ctx.cr[6].lt {
	pc = 0x822E1664; continue 'dispatch;
	}
	pc = 0x822E15E4; continue 'dispatch;
            }
            0x822E15E4 => {
    //   block [0x822E15E4..0x822E160C)
	// 822E15E4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E15E8: 616BFB1C  ori r11, r11, 0xfb1c
	ctx.r[11].u64 = ctx.r[11].u64 | 64284;
	// 822E15EC: 7FBF582E  lwzx r29, r31, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E15F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E15F4: 4BFFE745  bl 0x822dfd38
	ctx.lr = 0x822E15F8;
	sub_822DFD38(ctx, base);
	// 822E15F8: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 822E15FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822E1600: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822E1604: 419A0008  beq cr6, 0x822e160c
	if ctx.cr[6].eq {
	pc = 0x822E160C; continue 'dispatch;
	}
	// 822E1608: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	pc = 0x822E160C; continue 'dispatch;
            }
            0x822E160C => {
    //   block [0x822E160C..0x822E1664)
	// 822E160C: A17E004C  lhz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 822E1610: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822E1614: A0BE0064  lhz r5, 0x64(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 822E1618: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E161C: B39E0048  sth r28, 0x48(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(72 as u32), ctx.r[28].u16 ) };
	// 822E1620: B17E004C  sth r11, 0x4c(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(76 as u32), ctx.r[11].u16 ) };
	// 822E1624: 419A0040  beq cr6, 0x822e1664
	if ctx.cr[6].eq {
	pc = 0x822E1664; continue 'dispatch;
	}
	// 822E1628: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E162C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E1630: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 822E1634: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E1638: 38DE0066  addi r6, r30, 0x66
	ctx.r[6].s64 = ctx.r[30].s64 + 102;
	// 822E163C: 396BA928  addi r11, r11, -0x56d8
	ctx.r[11].s64 = ctx.r[11].s64 + -22232;
	// 822E1640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E1644: 914B0BD8  stw r10, 0xbd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3032 as u32), ctx.r[10].u32 ) };
	// 822E1648: B14B0BDC  sth r10, 0xbdc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(3036 as u32), ctx.r[10].u16 ) };
	// 822E164C: 914B0BE0  stw r10, 0xbe0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3040 as u32), ctx.r[10].u32 ) };
	// 822E1650: 7D5F48AE  lbzx r10, r31, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E1654: 1D4A01E0  mulli r10, r10, 0x1e0
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 480 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822E1658: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E165C: 914B03C0  stw r10, 0x3c0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(960 as u32), ctx.r[10].u32 ) };
	// 822E1660: 48003149  bl 0x822e47a8
	ctx.lr = 0x822E1664;
	sub_822E47A8(ctx, base);
	pc = 0x822E1664; continue 'dispatch;
            }
            0x822E1664 => {
    //   block [0x822E1664..0x822E166C)
	// 822E1664: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E1668: 48253AA0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E1670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E1670 size=360
    let mut pc: u32 = 0x822E1670;
    'dispatch: loop {
        match pc {
            0x822E1670 => {
    //   block [0x822E1670..0x822E1748)
	// 822E1670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E1674: 48253A29  bl 0x8253509c
	ctx.lr = 0x822E1678;
	sub_82535080(ctx, base);
	// 822E1678: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E167C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822E1680: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E1684: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822E1688: 419A0148  beq cr6, 0x822e17d0
	if ctx.cr[6].eq {
	pc = 0x822E17D0; continue 'dispatch;
	}
	// 822E168C: A17D0002  lhz r11, 2(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E1690: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E1694: 419A013C  beq cr6, 0x822e17d0
	if ctx.cr[6].eq {
	pc = 0x822E17D0; continue 'dispatch;
	}
	// 822E1698: A17D0026  lhz r11, 0x26(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(38 as u32) ) } as u64;
	// 822E169C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E16A0: 409A0130  bne cr6, 0x822e17d0
	if !ctx.cr[6].eq {
	pc = 0x822E17D0; continue 'dispatch;
	}
	// 822E16A4: 3F7E0002  addis r27, r30, 2
	ctx.r[27].s64 = ctx.r[30].s64 + 131072;
	// 822E16A8: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E16AC: 3B7BFAF0  addi r27, r27, -0x510
	ctx.r[27].s64 = ctx.r[27].s64 + -1296;
	// 822E16B0: 3F5E0002  addis r26, r30, 2
	ctx.r[26].s64 = ctx.r[30].s64 + 131072;
	// 822E16B4: 3BEBA908  addi r31, r11, -0x56f8
	ctx.r[31].s64 = ctx.r[11].s64 + -22264;
	// 822E16B8: 3B5AFAF8  addi r26, r26, -0x508
	ctx.r[26].s64 = ctx.r[26].s64 + -1288;
	// 822E16BC: 3F3E0002  addis r25, r30, 2
	ctx.r[25].s64 = ctx.r[30].s64 + 131072;
	// 822E16C0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E16C4: 3F1E0002  addis r24, r30, 2
	ctx.r[24].s64 = ctx.r[30].s64 + 131072;
	// 822E16C8: 3B39FB00  addi r25, r25, -0x500
	ctx.r[25].s64 = ctx.r[25].s64 + -1280;
	// 822E16CC: 3B18FB08  addi r24, r24, -0x4f8
	ctx.r[24].s64 = ctx.r[24].s64 + -1272;
	// 822E16D0: 3EFE0002  addis r23, r30, 2
	ctx.r[23].s64 = ctx.r[30].s64 + 131072;
	// 822E16D4: 3EDE0002  addis r22, r30, 2
	ctx.r[22].s64 = ctx.r[30].s64 + 131072;
	// 822E16D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E16DC: 3AF7FAFC  addi r23, r23, -0x504
	ctx.r[23].s64 = ctx.r[23].s64 + -1284;
	// 822E16E0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E16E4: 3AD6FAF4  addi r22, r22, -0x50c
	ctx.r[22].s64 = ctx.r[22].s64 + -1292;
	// 822E16E8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822E16EC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E16F0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822E16F4: A1780000  lhz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E16F8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E16FC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822E1700: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1704: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 822E1708: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E170C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 822E1710: 4BFFEA21  bl 0x822e0130
	ctx.lr = 0x822E1714;
	sub_822E0130(ctx, base);
	// 822E1714: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E1718: A15D0002  lhz r10, 2(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E171C: 616BFB1C  ori r11, r11, 0xfb1c
	ctx.r[11].u64 = ctx.r[11].u64 | 64284;
	// 822E1720: 7D440734  extsh r4, r10
	ctx.r[4].s64 = ctx.r[10].s16 as i64;
	// 822E1724: 7F9E582E  lwzx r28, r30, r11
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E1728: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822E172C: 4BFFE60D  bl 0x822dfd38
	ctx.lr = 0x822E1730;
	sub_822DFD38(ctx, base);
	// 822E1730: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 822E1734: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 822E1738: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822E173C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 822E1740: 419A0008  beq cr6, 0x822e1748
	if ctx.cr[6].eq {
	pc = 0x822E1748; continue 'dispatch;
	}
	// 822E1744: 7C8BE214  add r4, r11, r28
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x822E1748; continue 'dispatch;
            }
            0x822E1748 => {
    //   block [0x822E1748..0x822E179C)
	// 822E1748: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E174C: B2BD0048  sth r21, 0x48(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(72 as u32), ctx.r[21].u16 ) };
	// 822E1750: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822E1754: B17D0028  sth r11, 0x28(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[11].u16 ) };
	// 822E1758: 419A0044  beq cr6, 0x822e179c
	if ctx.cr[6].eq {
	pc = 0x822E179C; continue 'dispatch;
	}
	// 822E175C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E1760: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 822E1764: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 822E1768: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E176C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E1770: 396BA928  addi r11, r11, -0x56d8
	ctx.r[11].s64 = ctx.r[11].s64 + -22232;
	// 822E1774: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E1778: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E177C: 914B0BD8  stw r10, 0xbd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3032 as u32), ctx.r[10].u32 ) };
	// 822E1780: B14B0BDC  sth r10, 0xbdc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(3036 as u32), ctx.r[10].u16 ) };
	// 822E1784: 914B0BE0  stw r10, 0xbe0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3040 as u32), ctx.r[10].u32 ) };
	// 822E1788: 7D5E48AE  lbzx r10, r30, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E178C: 1D4A01E0  mulli r10, r10, 0x1e0
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 480 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822E1790: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E1794: 914B03C0  stw r10, 0x3c0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(960 as u32), ctx.r[10].u32 ) };
	// 822E1798: 48003011  bl 0x822e47a8
	ctx.lr = 0x822E179C;
	sub_822E47A8(ctx, base);
	pc = 0x822E179C; continue 'dispatch;
            }
            0x822E179C => {
    //   block [0x822E179C..0x822E17D0)
	// 822E179C: B2BD0028  sth r21, 0x28(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[21].u16 ) };
	// 822E17A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E17A4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E17A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E17AC: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E17B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E17B4: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E17B8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E17BC: B1780000  sth r11, 0(r24)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E17C0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822E17C4: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E17C8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822E17CC: 91760000  stw r11, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x822E17D0; continue 'dispatch;
            }
            0x822E17D0 => {
    //   block [0x822E17D0..0x822E17D8)
	// 822E17D0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822E17D4: 48253918  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E17D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E17D8 size=3548
    let mut pc: u32 = 0x822E17D8;
    'dispatch: loop {
        match pc {
            0x822E17D8 => {
    //   block [0x822E17D8..0x822E1848)
	// 822E17D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E17DC: 482538A5  bl 0x82535080
	ctx.lr = 0x822E17E0;
	sub_82535080(ctx, base);
	// 822E17E0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 822E17E4: 48254801  bl 0x82535fe4
	ctx.lr = 0x822E17E8;
	sub_82535FB0(ctx, base);
	// 822E17E8: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E17EC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822E17F0: 816101A4  lwz r11, 0x1a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 822E17F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E17F8: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 822E17FC: 1F7A0458  mulli r27, r26, 0x458
	ctx.r[27].s32 = ((ctx.r[26].s32 as i64 * 1112 as i64) as i32);
	ctx.r[27].s64 = ctx.r[27].s32 as i64;
	// 822E1800: 7D334B78  mr r19, r9
	ctx.r[19].u64 = ctx.r[9].u64;
	// 822E1804: 7D3BFA14  add r9, r27, r31
	ctx.r[9].u64 = ctx.r[27].u64 + ctx.r[31].u64;
	// 822E1808: 39E00000  li r15, 0
	ctx.r[15].s64 = 0;
	// 822E180C: 3EC90002  addis r22, r9, 2
	ctx.r[22].s64 = ctx.r[9].s64 + 131072;
	// 822E1810: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822E1814: 3AD6EEC8  addi r22, r22, -0x1138
	ctx.r[22].s64 = ctx.r[22].s64 + -4408;
	// 822E1818: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 822E181C: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 822E1820: 91E10068  stw r15, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[15].u32 ) };
	// 822E1824: 91E10064  stw r15, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[15].u32 ) };
	// 822E1828: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E182C: 82B600D0  lwz r21, 0xd0(r22)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E1830: B1760064  sth r11, 0x64(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(100 as u32), ctx.r[11].u16 ) };
	// 822E1834: 40990014  ble cr6, 0x822e1848
	if !ctx.cr[6].gt {
	pc = 0x822E1848; continue 'dispatch;
	}
	// 822E1838: 5565083C  slwi r5, r11, 1
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 822E183C: 808101AC  lwz r4, 0x1ac(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(428 as u32) ) } as u64;
	// 822E1840: 38760066  addi r3, r22, 0x66
	ctx.r[3].s64 = ctx.r[22].s64 + 102;
	// 822E1844: 4825330D  bl 0x82534b50
	ctx.lr = 0x822E1848;
	sub_82534B50(ctx, base);
	pc = 0x822E1848; continue 'dispatch;
            }
            0x822E1848 => {
    //   block [0x822E1848..0x822E186C)
	// 822E1848: 39C00001  li r14, 1
	ctx.r[14].s64 = 1;
	// 822E184C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822E1850: 409A0064  bne cr6, 0x822e18b4
	if !ctx.cr[6].eq {
	pc = 0x822E18B4; continue 'dispatch;
	}
	// 822E1854: A1760002  lhz r11, 2(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E1858: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E185C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822E1860: 409A000C  bne cr6, 0x822e186c
	if !ctx.cr[6].eq {
	pc = 0x822E186C; continue 'dispatch;
	}
	// 822E1864: B1D6001E  sth r14, 0x1e(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(30 as u32), ctx.r[14].u16 ) };
	// 822E1868: 48000050  b 0x822e18b8
	pc = 0x822E18B8; continue 'dispatch;
            }
            0x822E186C => {
    //   block [0x822E186C..0x822E18B4)
	// 822E186C: 3FDF0002  addis r30, r31, 2
	ctx.r[30].s64 = ctx.r[31].s64 + 131072;
	// 822E1870: B1F6001E  sth r15, 0x1e(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(30 as u32), ctx.r[15].u16 ) };
	// 822E1874: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E1878: 3BDEEB04  addi r30, r30, -0x14fc
	ctx.r[30].s64 = ctx.r[30].s64 + -5372;
	// 822E187C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E1880: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 822E1884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E1888: 8BBE0000  lbz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E188C: 4BFFFDE5  bl 0x822e1670
	ctx.lr = 0x822E1890;
	sub_822E1670(ctx, base);
	// 822E1890: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822E1894: 419A0024  beq cr6, 0x822e18b8
	if ctx.cr[6].eq {
	pc = 0x822E18B8; continue 'dispatch;
	}
	// 822E1898: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E189C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E18A0: 419A0018  beq cr6, 0x822e18b8
	if ctx.cr[6].eq {
	pc = 0x822E18B8; continue 'dispatch;
	}
	// 822E18A4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E18A8: 616BEB20  ori r11, r11, 0xeb20
	ctx.r[11].u64 = ctx.r[11].u64 | 60192;
	// 822E18AC: 7DDF59AE  stbx r14, r31, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[14].u8) };
	// 822E18B0: 48000008  b 0x822e18b8
	pc = 0x822E18B8; continue 'dispatch;
            }
            0x822E18B4 => {
    //   block [0x822E18B4..0x822E18B8)
	// 822E18B4: B1F6001E  sth r15, 0x1e(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(30 as u32), ctx.r[15].u16 ) };
	pc = 0x822E18B8; continue 'dispatch;
            }
            0x822E18B8 => {
    //   block [0x822E18B8..0x822E1928)
	// 822E18B8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E18BC: 616BEB30  ori r11, r11, 0xeb30
	ctx.r[11].u64 = ctx.r[11].u64 | 60208;
	// 822E18C0: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E18C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E18C8: 419A0060  beq cr6, 0x822e1928
	if ctx.cr[6].eq {
	pc = 0x822E1928; continue 'dispatch;
	}
	// 822E18CC: A176001E  lhz r11, 0x1e(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(30 as u32) ) } as u64;
	// 822E18D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E18D4: 409A0054  bne cr6, 0x822e1928
	if !ctx.cr[6].eq {
	pc = 0x822E1928; continue 'dispatch;
	}
	// 822E18D8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E18DC: 3D5F0002  addis r10, r31, 2
	ctx.r[10].s64 = ctx.r[31].s64 + 131072;
	// 822E18E0: 616B9CD8  ori r11, r11, 0x9cd8
	ctx.r[11].u64 = ctx.r[11].u64 | 40152;
	// 822E18E4: 394A9B74  addi r10, r10, -0x648c
	ctx.r[10].s64 = ctx.r[10].s64 + -25740;
	// 822E18E8: 7C1F5C2E  lfsx f0, r31, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E18EC: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E18F0: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E18F4: 480862AD  bl 0x82367ba0
	ctx.lr = 0x822E18F8;
	sub_82367BA0(ctx, base);
	// 822E18F8: FD800890  fmr f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ctx.f[1].f64;
	// 822E18FC: EC2D602A  fadds f1, f13, f12
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 822E1900: 480862A1  bl 0x82367ba0
	ctx.lr = 0x822E1904;
	sub_82367BA0(ctx, base);
	// 822E1904: D02A0000  stfs f1, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E1908: 3D5F0002  addis r10, r31, 2
	ctx.r[10].s64 = ctx.r[31].s64 + 131072;
	// 822E190C: 394AE9E0  addi r10, r10, -0x1620
	ctx.r[10].s64 = ctx.r[10].s64 + -5664;
	// 822E1910: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E1914: EC206028  fsubs f1, f0, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 822E1918: 48086289  bl 0x82367ba0
	ctx.lr = 0x822E191C;
	sub_82367BA0(ctx, base);
	// 822E191C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E1920: D02A0000  stfs f1, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E1924: 4BE5B90D  bl 0x8213d230
	ctx.lr = 0x822E1928;
	sub_8213D230(ctx, base);
	pc = 0x822E1928; continue 'dispatch;
            }
            0x822E1928 => {
    //   block [0x822E1928..0x822E1964)
	// 822E1928: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E192C: A13600B0  lhz r9, 0xb0(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(176 as u32) ) } as u64;
	// 822E1930: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 822E1934: B3960002  sth r28, 2(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(2 as u32), ctx.r[28].u16 ) };
	// 822E1938: B1F60048  sth r15, 0x48(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(72 as u32), ctx.r[15].u16 ) };
	// 822E193C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822E1940: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E1944: D3F6044C  stfs f31, 0x44c(r22)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(1100 as u32), tmp.u32 ) };
	// 822E1948: B3360052  sth r25, 0x52(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(82 as u32), ctx.r[25].u16 ) };
	// 822E194C: B3360058  sth r25, 0x58(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(88 as u32), ctx.r[25].u16 ) };
	// 822E1950: B3360056  sth r25, 0x56(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(86 as u32), ctx.r[25].u16 ) };
	// 822E1954: B3360054  sth r25, 0x54(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(84 as u32), ctx.r[25].u16 ) };
	// 822E1958: 409A000C  bne cr6, 0x822e1964
	if !ctx.cr[6].eq {
	pc = 0x822E1964; continue 'dispatch;
	}
	// 822E195C: B33600AC  sth r25, 0xac(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(172 as u32), ctx.r[25].u16 ) };
	// 822E1960: B1F600B0  sth r15, 0xb0(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(176 as u32), ctx.r[15].u16 ) };
	pc = 0x822E1964; continue 'dispatch;
            }
            0x822E1964 => {
    //   block [0x822E1964..0x822E196C)
	// 822E1964: 395601E4  addi r10, r22, 0x1e4
	ctx.r[10].s64 = ctx.r[22].s64 + 484;
	// 822E1968: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	pc = 0x822E196C; continue 'dispatch;
            }
            0x822E196C => {
    //   block [0x822E196C..0x822E1988)
	// 822E196C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E1970: B32A0000  sth r25, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u16 ) };
	// 822E1974: 394A0024  addi r10, r10, 0x24
	ctx.r[10].s64 = ctx.r[10].s64 + 36;
	// 822E1978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E197C: 409AFFF0  bne cr6, 0x822e196c
	if !ctx.cr[6].eq {
	pc = 0x822E196C; continue 'dispatch;
	}
	// 822E1980: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 822E1984: 41990018  bgt cr6, 0x822e199c
	if ctx.cr[6].gt {
	pc = 0x822E199C; continue 'dispatch;
	}
	pc = 0x822E1988; continue 'dispatch;
            }
            0x822E1988 => {
    //   block [0x822E1988..0x822E199C)
	// 822E1988: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E198C: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822E1990: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 822E1994: 4825469D  bl 0x82536030
	ctx.lr = 0x822E1998;
	sub_82535FFC(ctx, base);
	// 822E1998: 48253738  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            0x822E199C => {
    //   block [0x822E199C..0x822E19BC)
	// 822E199C: 3D7F0002  addis r11, r31, 2
	ctx.r[11].s64 = ctx.r[31].s64 + 131072;
	// 822E19A0: 396BFB1C  addi r11, r11, -0x4e4
	ctx.r[11].s64 = ctx.r[11].s64 + -1252;
	// 822E19A4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E19A8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 822E19AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822E19B0: 409A000C  bne cr6, 0x822e19bc
	if !ctx.cr[6].eq {
	pc = 0x822E19BC; continue 'dispatch;
	}
	// 822E19B4: 7DF87B78  mr r24, r15
	ctx.r[24].u64 = ctx.r[15].u64;
	// 822E19B8: 48000014  b 0x822e19cc
	pc = 0x822E19CC; continue 'dispatch;
            }
            0x822E19BC => {
    //   block [0x822E19BC..0x822E19CC)
	// 822E19BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822E19C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E19C4: 4BFFE375  bl 0x822dfd38
	ctx.lr = 0x822E19C8;
	sub_822DFD38(ctx, base);
	// 822E19C8: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	pc = 0x822E19CC; continue 'dispatch;
            }
            0x822E19CC => {
    //   block [0x822E19CC..0x822E1A08)
	// 822E19CC: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 822E19D0: 3E2B0002  addis r17, r11, 2
	ctx.r[17].s64 = ctx.r[11].s64 + 131072;
	// 822E19D4: 3A31F320  addi r17, r17, -0xce0
	ctx.r[17].s64 = ctx.r[17].s64 + -3296;
	// 822E19D8: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 822E19DC: 419A002C  beq cr6, 0x822e1a08
	if ctx.cr[6].eq {
	pc = 0x822E1A08; continue 'dispatch;
	}
	// 822E19E0: A1710002  lhz r11, 2(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[17].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E19E4: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 822E19E8: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 822E19EC: 4099001C  ble cr6, 0x822e1a08
	if !ctx.cr[6].gt {
	pc = 0x822E1A08; continue 'dispatch;
	}
	// 822E19F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822E19F4: 419A0014  beq cr6, 0x822e1a08
	if ctx.cr[6].eq {
	pc = 0x822E1A08; continue 'dispatch;
	}
	// 822E19F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E19FC: 4BFFE33D  bl 0x822dfd38
	ctx.lr = 0x822E1A00;
	sub_822DFD38(ctx, base);
	// 822E1A00: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 822E1A04: 48000008  b 0x822e1a0c
	pc = 0x822E1A0C; continue 'dispatch;
            }
            0x822E1A08 => {
    //   block [0x822E1A08..0x822E1A0C)
	// 822E1A08: 7DF47B78  mr r20, r15
	ctx.r[20].u64 = ctx.r[15].u64;
	pc = 0x822E1A0C; continue 'dispatch;
            }
            0x822E1A0C => {
    //   block [0x822E1A0C..0x822E1A60)
	// 822E1A0C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 822E1A10: 419A0B90  beq cr6, 0x822e25a0
	if ctx.cr[6].eq {
	pc = 0x822E25A0; continue 'dispatch;
	}
	// 822E1A14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E1A18: D3760008  stfs f27, 8(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E1A1C: D3760014  stfs f27, 0x14(r22)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 822E1A20: B1F6001A  sth r15, 0x1a(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(26 as u32), ctx.r[15].u16 ) };
	// 822E1A24: B1F6001C  sth r15, 0x1c(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(28 as u32), ctx.r[15].u16 ) };
	// 822E1A28: C0180030  lfs f0, 0x30(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E1A2C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822E1A30: C3AB20B0  lfs f29, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822E1A34: 4198002C  blt cr6, 0x822e1a60
	if ctx.cr[6].lt {
	pc = 0x822E1A60; continue 'dispatch;
	}
	// 822E1A38: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 822E1A3C: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 822E1A40: 419A0020  beq cr6, 0x822e1a60
	if ctx.cr[6].eq {
	pc = 0x822E1A60; continue 'dispatch;
	}
	// 822E1A44: A1760002  lhz r11, 2(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E1A48: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E1A4C: 419A0014  beq cr6, 0x822e1a60
	if ctx.cr[6].eq {
	pc = 0x822E1A60; continue 'dispatch;
	}
	// 822E1A50: D0160030  stfs f0, 0x30(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 822E1A54: D0160034  stfs f0, 0x34(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 822E1A58: D3F60040  stfs f31, 0x40(r22)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E1A5C: D3F6003C  stfs f31, 0x3c(r22)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x822E1A60; continue 'dispatch;
            }
            0x822E1A60 => {
    //   block [0x822E1A60..0x822E1A8C)
	// 822E1A60: A1760002  lhz r11, 2(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E1A64: 91F60004  stw r15, 4(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(4 as u32), ctx.r[15].u32 ) };
	// 822E1A68: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E1A6C: B1F60024  sth r15, 0x24(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(36 as u32), ctx.r[15].u16 ) };
	// 822E1A70: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E1A74: 6166EB00  ori r6, r11, 0xeb00
	ctx.r[6].u64 = ctx.r[11].u64 | 60160;
	// 822E1A78: 419A0040  beq cr6, 0x822e1ab8
	if ctx.cr[6].eq {
	pc = 0x822E1AB8; continue 'dispatch;
	}
	// 822E1A7C: E9160430  ld r8, 0x430(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[22].u32.wrapping_add(1072 as u32) ) };
	// 822E1A80: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 822E1A84: E9360428  ld r9, 0x428(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[22].u32.wrapping_add(1064 as u32) ) };
	// 822E1A88: 7D5F3214  add r10, r31, r6
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[6].u64;
	pc = 0x822E1A8C; continue 'dispatch;
            }
            0x822E1A8C => {
    //   block [0x822E1A8C..0x822E1AA0)
	// 822E1A8C: 790707E0  clrldi r7, r8, 0x3f
	ctx.r[7].u64 = ctx.r[8].u64 & 0x0000000000000001u64;
	// 822E1A90: 2B270000  cmpldi cr6, r7, 0
	ctx.cr[6].compare_u64(ctx.r[7].u64, 0, &mut ctx.xer);
	// 822E1A94: 419A000C  beq cr6, 0x822e1aa0
	if ctx.cr[6].eq {
	pc = 0x822E1AA0; continue 'dispatch;
	}
	// 822E1A98: 552707FE  clrlwi r7, r9, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 822E1A9C: 98EA0000  stb r7, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	pc = 0x822E1AA0; continue 'dispatch;
            }
            0x822E1AA0 => {
    //   block [0x822E1AA0..0x822E1AB8)
	// 822E1AA0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E1AA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E1AA8: 7908F842  rldicl r8, r8, 0x3f, 1
	ctx.r[8].u64 = ctx.r[8].u64 & 0x0000000000000001u64;
	// 822E1AAC: 7929F842  rldicl r9, r9, 0x3f, 1
	ctx.r[9].u64 = ctx.r[9].u64 & 0x0000000000000001u64;
	// 822E1AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E1AB4: 409AFFD8  bne cr6, 0x822e1a8c
	if !ctx.cr[6].eq {
	pc = 0x822E1A8C; continue 'dispatch;
	}
	pc = 0x822E1AB8; continue 'dispatch;
            }
            0x822E1AB8 => {
    //   block [0x822E1AB8..0x822E1AFC)
	// 822E1AB8: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E1ABC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E1AC0: 6128EB38  ori r8, r9, 0xeb38
	ctx.r[8].u64 = ctx.r[9].u64 | 60216;
	// 822E1AC4: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E1AC8: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E1ACC: 616BEB16  ori r11, r11, 0xeb16
	ctx.r[11].u64 = ctx.r[11].u64 | 60182;
	// 822E1AD0: 614AEB37  ori r10, r10, 0xeb37
	ctx.r[10].u64 = ctx.r[10].u64 | 60215;
	// 822E1AD4: 6125EB2B  ori r5, r9, 0xeb2b
	ctx.r[5].u64 = ctx.r[9].u64 | 60203;
	// 822E1AD8: 7DDF41AE  stbx r14, r31, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32), ctx.r[14].u8) };
	// 822E1ADC: 38F60438  addi r7, r22, 0x438
	ctx.r[7].s64 = ctx.r[22].s64 + 1080;
	// 822E1AE0: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 822E1AE4: 7DDF59AE  stbx r14, r31, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[14].u8) };
	// 822E1AE8: 39780020  addi r11, r24, 0x20
	ctx.r[11].s64 = ctx.r[24].s64 + 32;
	// 822E1AEC: 7DDF51AE  stbx r14, r31, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[14].u8) };
	// 822E1AF0: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 822E1AF4: 7DFF29AE  stbx r15, r31, r5
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[5].u32), ctx.r[15].u8) };
	// 822E1AF8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x822E1AFC; continue 'dispatch;
            }
            0x822E1AFC => {
    //   block [0x822E1AFC..0x822E1B24)
	// 822E1AFC: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1B00: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E1B04: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 822E1B08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E1B0C: 4200FFF0  bdnz 0x822e1afc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822E1AFC; continue 'dispatch;
	}
	// 822E1B10: 39360440  addi r9, r22, 0x440
	ctx.r[9].s64 = ctx.r[22].s64 + 1088;
	// 822E1B14: 39780028  addi r11, r24, 0x28
	ctx.r[11].s64 = ctx.r[24].s64 + 40;
	// 822E1B18: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 822E1B1C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 822E1B20: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x822E1B24; continue 'dispatch;
            }
            0x822E1B24 => {
    //   block [0x822E1B24..0x822E1B60)
	// 822E1B24: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1B28: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E1B2C: 990A0000  stb r8, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 822E1B30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E1B34: 4200FFF0  bdnz 0x822e1b24
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822E1B24; continue 'dispatch;
	}
	// 822E1B38: A1760002  lhz r11, 2(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E1B3C: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E1B40: 419A0084  beq cr6, 0x822e1bc4
	if ctx.cr[6].eq {
	pc = 0x822E1BC4; continue 'dispatch;
	}
	// 822E1B44: EBA70000  ld r29, 0(r7)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 822E1B48: 7F7F3214  add r27, r31, r6
	ctx.r[27].u64 = ctx.r[31].u64 + ctx.r[6].u64;
	// 822E1B4C: EB890000  ld r28, 0(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 822E1B50: 7DFE7B78  mr r30, r15
	ctx.r[30].u64 = ctx.r[15].u64;
	// 822E1B54: F9F60428  std r15, 0x428(r22)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[22].u32.wrapping_add(1064 as u32), ctx.r[15].u64 ) };
	// 822E1B58: 7F8BEB78  or r11, r28, r29
	ctx.r[11].u64 = ctx.r[28].u64 | ctx.r[29].u64;
	// 822E1B5C: F9760430  std r11, 0x430(r22)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[22].u32.wrapping_add(1072 as u32), ctx.r[11].u64 ) };
	pc = 0x822E1B60; continue 'dispatch;
            }
            0x822E1B60 => {
    //   block [0x822E1B60..0x822E1B90)
	// 822E1B60: 7D7ED8AE  lbzx r11, r30, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 822E1B64: 7BAA07E0  clrldi r10, r29, 0x3f
	ctx.r[10].u64 = ctx.r[29].u64 & 0x0000000000000001u64;
	// 822E1B68: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 822E1B6C: 7D6BF030  slw r11, r11, r30
	if (ctx.r[30].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[30].u8 & 0x1F) as u32)) as u64;
	}
	// 822E1B70: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E1B74: F9760428  std r11, 0x428(r22)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[22].u32.wrapping_add(1064 as u32), ctx.r[11].u64 ) };
	// 822E1B78: 419A0018  beq cr6, 0x822e1b90
	if ctx.cr[6].eq {
	pc = 0x822E1B90; continue 'dispatch;
	}
	// 822E1B7C: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 822E1B80: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822E1B84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E1B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E1B8C: 4BE44A8D  bl 0x82126618
	ctx.lr = 0x822E1B90;
	sub_82126618(ctx, base);
	pc = 0x822E1B90; continue 'dispatch;
            }
            0x822E1B90 => {
    //   block [0x822E1B90..0x822E1BB0)
	// 822E1B90: 7B8B07E0  clrldi r11, r28, 0x3f
	ctx.r[11].u64 = ctx.r[28].u64 & 0x0000000000000001u64;
	// 822E1B94: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 822E1B98: 419A0018  beq cr6, 0x822e1bb0
	if ctx.cr[6].eq {
	pc = 0x822E1BB0; continue 'dispatch;
	}
	// 822E1B9C: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 822E1BA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E1BA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E1BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E1BAC: 4BE44A6D  bl 0x82126618
	ctx.lr = 0x822E1BB0;
	sub_82126618(ctx, base);
	pc = 0x822E1BB0; continue 'dispatch;
            }
            0x822E1BB0 => {
    //   block [0x822E1BB0..0x822E1BC4)
	// 822E1BB0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822E1BB4: 7BBDF842  rldicl r29, r29, 0x3f, 1
	ctx.r[29].u64 = ctx.r[29].u64 & 0x0000000000000001u64;
	// 822E1BB8: 7B9CF842  rldicl r28, r28, 0x3f, 1
	ctx.r[28].u64 = ctx.r[28].u64 & 0x0000000000000001u64;
	// 822E1BBC: 2F1E0040  cmpwi cr6, r30, 0x40
	ctx.cr[6].compare_i32(ctx.r[30].s32, 64, &mut ctx.xer);
	// 822E1BC0: 4198FFA0  blt cr6, 0x822e1b60
	if ctx.cr[6].lt {
	pc = 0x822E1B60; continue 'dispatch;
	}
	pc = 0x822E1BC4; continue 'dispatch;
            }
            0x822E1BC4 => {
    //   block [0x822E1BC4..0x822E1C08)
	// 822E1BC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E1BC8: 92E10070  stw r23, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[23].u32 ) };
	// 822E1BCC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E1BD0: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 822E1BD4: 7DFB7B78  mr r27, r15
	ctx.r[27].u64 = ctx.r[15].u64;
	// 822E1BD8: 3BD80004  addi r30, r24, 4
	ctx.r[30].s64 = ctx.r[24].s64 + 4;
	// 822E1BDC: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 822E1BE0: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E1BE4: 3D7A0001  addis r11, r26, 1
	ctx.r[11].s64 = ctx.r[26].s64 + 65536;
	// 822E1BE8: C3CA20AC  lfs f30, 0x20ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8364 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822E1BEC: 7DFA7B78  mr r26, r15
	ctx.r[26].u64 = ctx.r[15].u64;
	// 822E1BF0: 396B5F7B  addi r11, r11, 0x5f7b
	ctx.r[11].s64 = ctx.r[11].s64 + 24443;
	// 822E1BF4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E1BF8: 7C0BFD2E  stfsx f0, r11, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 822E1BFC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E1C00: B1F6004A  sth r15, 0x4a(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(74 as u32), ctx.r[15].u16 ) };
	// 822E1C04: C38B24DC  lfs f28, 0x24dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9436 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	pc = 0x822E1C08; continue 'dispatch;
            }
            0x822E1C08 => {
    //   block [0x822E1C08..0x822E1C24)
	// 822E1C08: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1C0C: A13EFFFC  lhz r9, -4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822E1C10: 895E0003  lbz r10, 3(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(3 as u32) ) } as u64;
	// 822E1C14: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822E1C18: 7D250734  extsh r5, r9
	ctx.r[5].s64 = ctx.r[9].s16 as i64;
	// 822E1C1C: 419A0008  beq cr6, 0x822e1c24
	if ctx.cr[6].eq {
	pc = 0x822E1C24; continue 'dispatch;
	}
	// 822E1C20: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	pc = 0x822E1C24; continue 'dispatch;
            }
            0x822E1C24 => {
    //   block [0x822E1C24..0x822E1C30)
	// 822E1C24: 2F130000  cmpwi cr6, r19, 0
	ctx.cr[6].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 822E1C28: 419A0008  beq cr6, 0x822e1c30
	if ctx.cr[6].eq {
	pc = 0x822E1C30; continue 'dispatch;
	}
	// 822E1C2C: 60A58000  ori r5, r5, 0x8000
	ctx.r[5].u64 = ctx.r[5].u64 | 32768;
	pc = 0x822E1C30; continue 'dispatch;
            }
            0x822E1C30 => {
    //   block [0x822E1C30..0x822E1CC4)
	// 822E1C30: 7D5C0734  extsh r28, r10
	ctx.r[28].s64 = ctx.r[10].s16 as i64;
	// 822E1C34: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1C38: A15EFFFE  lhz r10, -2(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(-2 as u32) ) } as u64;
	// 822E1C3C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E1C40: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E1C44: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E1C48: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E1C4C: EC400772  fmuls f2, f0, f29
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 822E1C50: EC2D0772  fmuls f1, f13, f29
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 822E1C54: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 822E1C58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E1C5C: 88DE0002  lbz r6, 2(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E1C60: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 822E1C64: FCA0D890  fmr f5, f27
	ctx.f[5].f64 = ctx.f[27].f64;
	// 822E1C68: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 822E1C6C: F9410080  std r10, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u64 ) };
	// 822E1C70: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 822E1C74: C8010078  lfd f0, 0x78(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 822E1C78: C9A10080  lfd f13, 0x80(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 822E1C7C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E1C80: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E1C84: FC800018  frsp f4, f0
	ctx.f[4].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E1C88: FC606818  frsp f3, f13
	ctx.f[3].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E1C8C: 4800151D  bl 0x822e31a8
	ctx.lr = 0x822E1C90;
	sub_822E31A8(ctx, base);
	// 822E1C90: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 822E1C94: 419A0038  beq cr6, 0x822e1ccc
	if ctx.cr[6].eq {
	pc = 0x822E1CCC; continue 'dispatch;
	}
	// 822E1C98: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E1C9C: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 822E1CA0: 419A0024  beq cr6, 0x822e1cc4
	if ctx.cr[6].eq {
	pc = 0x822E1CC4; continue 'dispatch;
	}
	// 822E1CA4: C0150040  lfs f0, 0x40(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E1CA8: ED9E0028  fsubs f12, f30, f0
	ctx.f[12].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E1CAC: C1B50030  lfs f13, 0x30(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E1CB0: FC0C07AE  fsel f0, f12, f30, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[0].f64 };
	// 822E1CB4: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 822E1CB8: EDBF0028  fsubs f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E1CBC: FFED07EE  fsel f31, f13, f31, f0
	ctx.f[31].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[0].f64 };
	// 822E1CC0: 4800000C  b 0x822e1ccc
	pc = 0x822E1CCC; continue 'dispatch;
            }
            0x822E1CC4 => {
    //   block [0x822E1CC4..0x822E1CCC)
	// 822E1CC4: 7DCBD830  slw r11, r14, r27
	if (ctx.r[27].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[14].u32) << ((ctx.r[27].u8 & 0x1F) as u32)) as u64;
	}
	// 822E1CC8: 7D7AD378  or r26, r11, r26
	ctx.r[26].u64 = ctx.r[11].u64 | ctx.r[26].u64;
	pc = 0x822E1CCC; continue 'dispatch;
            }
            0x822E1CCC => {
    //   block [0x822E1CCC..0x822E1CDC)
	// 822E1CCC: 578B073E  clrlwi r11, r28, 0x1c
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x0000000Fu64;
	// 822E1CD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E1CD4: 419A0008  beq cr6, 0x822e1cdc
	if ctx.cr[6].eq {
	pc = 0x822E1CDC; continue 'dispatch;
	}
	// 822E1CD8: B176004A  sth r11, 0x4a(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(74 as u32), ctx.r[11].u16 ) };
	pc = 0x822E1CDC; continue 'dispatch;
            }
            0x822E1CDC => {
    //   block [0x822E1CDC..0x822E1D20)
	// 822E1CDC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 822E1CE0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822E1CE4: 3AB500B0  addi r21, r21, 0xb0
	ctx.r[21].s64 = ctx.r[21].s64 + 176;
	// 822E1CE8: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 822E1CEC: 2F1B0002  cmpwi cr6, r27, 2
	ctx.cr[6].compare_i32(ctx.r[27].s32, 2, &mut ctx.xer);
	// 822E1CF0: 4198FF18  blt cr6, 0x822e1c08
	if ctx.cr[6].lt {
	pc = 0x822E1C08; continue 'dispatch;
	}
	// 822E1CF4: A1780034  lhz r11, 0x34(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[24].u32.wrapping_add(52 as u32) ) } as u64;
	// 822E1CF8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E1CFC: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 822E1D00: 419A0020  beq cr6, 0x822e1d20
	if ctx.cr[6].eq {
	pc = 0x822E1D20; continue 'dispatch;
	}
	// 822E1D04: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E1D08: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 822E1D0C: C8010080  lfd f0, 0x80(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 822E1D10: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E1D14: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E1D18: D0160010  stfs f0, 0x10(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822E1D1C: 48000008  b 0x822e1d24
	pc = 0x822E1D24; continue 'dispatch;
            }
            0x822E1D20 => {
    //   block [0x822E1D20..0x822E1D24)
	// 822E1D20: D3F60010  stfs f31, 0x10(r22)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x822E1D24; continue 'dispatch;
            }
            0x822E1D24 => {
    //   block [0x822E1D24..0x822E1D4C)
	// 822E1D24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E1D28: C0160010  lfs f0, 0x10(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E1D2C: 83B600D0  lwz r29, 0xd0(r22)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E1D30: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 822E1D34: C1AB2150  lfs f13, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E1D38: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E1D3C: FFEC682E  fsel f31, f12, f0, f13
	ctx.f[31].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 822E1D40: 419A008C  beq cr6, 0x822e1dcc
	if ctx.cr[6].eq {
	pc = 0x822E1DCC; continue 'dispatch;
	}
	// 822E1D44: 3BD80002  addi r30, r24, 2
	ctx.r[30].s64 = ctx.r[24].s64 + 2;
	// 822E1D48: 3B810070  addi r28, r1, 0x70
	ctx.r[28].s64 = ctx.r[1].s64 + 112;
	pc = 0x822E1D4C; continue 'dispatch;
            }
            0x822E1D4C => {
    //   block [0x822E1D4C..0x822E1DB4)
	// 822E1D4C: 574B07FE  clrlwi r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	// 822E1D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E1D54: 419A0060  beq cr6, 0x822e1db4
	if ctx.cr[6].eq {
	pc = 0x822E1DB4; continue 'dispatch;
	}
	// 822E1D58: A17E0002  lhz r11, 2(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E1D5C: C01D0030  lfs f0, 0x30(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E1D60: A15E0000  lhz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1D64: C1BE0006  lfs f13, 6(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E1D68: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E1D6C: EC40F824  fdivs f2, f0, f31
	ctx.f[2].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 822E1D70: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E1D74: EC2D0772  fmuls f1, f13, f29
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 822E1D78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822E1D7C: 891E0005  lbz r8, 5(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(5 as u32) ) } as u64;
	// 822E1D80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E1D84: 88DE0004  lbz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E1D88: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1D8C: FCA0D890  fmr f5, f27
	ctx.f[5].f64 = ctx.f[27].f64;
	// 822E1D90: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 822E1D94: F9410078  std r10, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u64 ) };
	// 822E1D98: C8010080  lfd f0, 0x80(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 822E1D9C: C9A10078  lfd f13, 0x78(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 822E1DA0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E1DA4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E1DA8: FC800018  frsp f4, f0
	ctx.f[4].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E1DAC: FC606818  frsp f3, f13
	ctx.f[3].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E1DB0: 480013F9  bl 0x822e31a8
	ctx.lr = 0x822E1DB4;
	sub_822E31A8(ctx, base);
	pc = 0x822E1DB4; continue 'dispatch;
            }
            0x822E1DB4 => {
    //   block [0x822E1DB4..0x822E1DCC)
	// 822E1DB4: 575AF87E  srwi r26, r26, 1
	ctx.r[26].u32 = ctx.r[26].u32.wrapping_shr(1);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 822E1DB8: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 822E1DBC: 3BBD00B0  addi r29, r29, 0xb0
	ctx.r[29].s64 = ctx.r[29].s64 + 176;
	// 822E1DC0: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 822E1DC4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 822E1DC8: 409AFF84  bne cr6, 0x822e1d4c
	if !ctx.cr[6].eq {
	pc = 0x822E1D4C; continue 'dispatch;
	}
	pc = 0x822E1DCC; continue 'dispatch;
            }
            0x822E1DCC => {
    //   block [0x822E1DCC..0x822E1DE0)
	// 822E1DCC: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 822E1DD0: 409A0010  bne cr6, 0x822e1de0
	if !ctx.cr[6].eq {
	pc = 0x822E1DE0; continue 'dispatch;
	}
	// 822E1DD4: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 822E1DD8: 616B8F94  ori r11, r11, 0x8f94
	ctx.r[11].u64 = ctx.r[11].u64 | 36756;
	// 822E1DDC: 7DFF592E  stwx r15, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[15].u32) };
	pc = 0x822E1DE0; continue 'dispatch;
            }
            0x822E1DE0 => {
    //   block [0x822E1DE0..0x822E1E14)
	// 822E1DE0: 3E7F0002  addis r19, r31, 2
	ctx.r[19].s64 = ctx.r[31].s64 + 131072;
	// 822E1DE4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E1DE8: 3A73FAF8  addi r19, r19, -0x508
	ctx.r[19].s64 = ctx.r[19].s64 + -1288;
	// 822E1DEC: 616AF318  ori r10, r11, 0xf318
	ctx.r[10].u64 = ctx.r[11].u64 | 62232;
	// 822E1DF0: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1DF4: 1D6B0458  mulli r11, r11, 0x458
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E1DF8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 822E1DFC: 7DEB512E  stwx r15, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[15].u32) };
	// 822E1E00: 81760450  lwz r11, 0x450(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1104 as u32) ) } as u64;
	// 822E1E04: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822E1E08: 419A000C  beq cr6, 0x822e1e14
	if ctx.cr[6].eq {
	pc = 0x822E1E14; continue 'dispatch;
	}
	// 822E1E0C: 83D8003C  lwz r30, 0x3c(r24)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(60 as u32) ) } as u64;
	// 822E1E10: 48000008  b 0x822e1e18
	pc = 0x822E1E18; continue 'dispatch;
            }
            0x822E1E14 => {
    //   block [0x822E1E14..0x822E1E18)
	// 822E1E14: 83D80040  lwz r30, 0x40(r24)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(64 as u32) ) } as u64;
	pc = 0x822E1E18; continue 'dispatch;
            }
            0x822E1E18 => {
    //   block [0x822E1E18..0x822E1E48)
	// 822E1E18: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E1E1C: 3A000002  li r16, 2
	ctx.r[16].s64 = 2;
	// 822E1E20: 6172E308  ori r18, r11, 0xe308
	ctx.r[18].u64 = ctx.r[11].u64 | 58120;
	// 822E1E24: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E1E28: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 822E1E2C: 3AABBFF0  addi r21, r11, -0x4010
	ctx.r[21].s64 = ctx.r[11].s64 + -16400;
	// 822E1E30: 419A0024  beq cr6, 0x822e1e54
	if ctx.cr[6].eq {
	pc = 0x822E1E54; continue 'dispatch;
	}
	// 822E1E34: 81710450  lwz r11, 0x450(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(1104 as u32) ) } as u64;
	// 822E1E38: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822E1E3C: 419A000C  beq cr6, 0x822e1e48
	if ctx.cr[6].eq {
	pc = 0x822E1E48; continue 'dispatch;
	}
	// 822E1E40: 8174003C  lwz r11, 0x3c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(60 as u32) ) } as u64;
	// 822E1E44: 48000008  b 0x822e1e4c
	pc = 0x822E1E4C; continue 'dispatch;
            }
            0x822E1E48 => {
    //   block [0x822E1E48..0x822E1E4C)
	// 822E1E48: 81740040  lwz r11, 0x40(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(64 as u32) ) } as u64;
	pc = 0x822E1E4C; continue 'dispatch;
            }
            0x822E1E4C => {
    //   block [0x822E1E4C..0x822E1E54)
	// 822E1E4C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822E1E50: 409A0554  bne cr6, 0x822e23a4
	if !ctx.cr[6].eq {
	pc = 0x822E23A4; continue 'dispatch;
	}
	pc = 0x822E1E54; continue 'dispatch;
            }
            0x822E1E54 => {
    //   block [0x822E1E54..0x822E1EB8)
	// 822E1E54: 3FBF0002  addis r29, r31, 2
	ctx.r[29].s64 = ctx.r[31].s64 + 131072;
	// 822E1E58: 3BBDE2D4  addi r29, r29, -0x1d2c
	ctx.r[29].s64 = ctx.r[29].s64 + -7468;
	// 822E1E5C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E1E64: 419A0060  beq cr6, 0x822e1ec4
	if ctx.cr[6].eq {
	pc = 0x822E1EC4; continue 'dispatch;
	}
	// 822E1E68: A14B0036  lhz r10, 0x36(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 822E1E6C: C1B6000C  lfs f13, 0xc(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E1E70: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E1E74: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 822E1E78: F9210080  std r9, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[9].u64 ) };
	// 822E1E7C: C8010080  lfd f0, 0x80(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 822E1E80: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E1E84: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E1E88: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822E1E8C: 4098002C  bge cr6, 0x822e1eb8
	if !ctx.cr[6].lt {
	pc = 0x822E1EB8; continue 'dispatch;
	}
	// 822E1E90: A16B0038  lhz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 822E1E94: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E1E98: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822E1E9C: 409A0028  bne cr6, 0x822e1ec4
	if !ctx.cr[6].eq {
	pc = 0x822E1EC4; continue 'dispatch;
	}
	// 822E1EA0: C1B60060  lfs f13, 0x60(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E1EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E1EA8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822E1EAC: 419A001C  beq cr6, 0x822e1ec8
	if ctx.cr[6].eq {
	pc = 0x822E1EC8; continue 'dispatch;
	}
	// 822E1EB0: 480021C9  bl 0x822e4078
	ctx.lr = 0x822E1EB4;
	sub_822E4078(ctx, base);
	// 822E1EB4: 48000018  b 0x822e1ecc
	pc = 0x822E1ECC; continue 'dispatch;
            }
            0x822E1EB8 => {
    //   block [0x822E1EB8..0x822E1EC4)
	// 822E1EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E1EBC: 480021BD  bl 0x822e4078
	ctx.lr = 0x822E1EC0;
	sub_822E4078(ctx, base);
	// 822E1EC0: 4800000C  b 0x822e1ecc
	pc = 0x822E1ECC; continue 'dispatch;
            }
            0x822E1EC4 => {
    //   block [0x822E1EC4..0x822E1EC8)
	// 822E1EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x822E1EC8; continue 'dispatch;
            }
            0x822E1EC8 => {
    //   block [0x822E1EC8..0x822E1ECC)
	// 822E1EC8: 48001FE9  bl 0x822e3eb0
	ctx.lr = 0x822E1ECC;
	sub_822E3EB0(ctx, base);
	pc = 0x822E1ECC; continue 'dispatch;
            }
            0x822E1ECC => {
    //   block [0x822E1ECC..0x822E1F94)
	// 822E1ECC: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 822E1ED0: 419A04C8  beq cr6, 0x822e2398
	if ctx.cr[6].eq {
	pc = 0x822E2398; continue 'dispatch;
	}
	// 822E1ED4: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 822E1ED8: 3D7F0002  addis r11, r31, 2
	ctx.r[11].s64 = ctx.r[31].s64 + 131072;
	// 822E1EDC: 6108E2DC  ori r8, r8, 0xe2dc
	ctx.r[8].u64 = ctx.r[8].u64 | 58076;
	// 822E1EE0: 396BE300  addi r11, r11, -0x1d00
	ctx.r[11].s64 = ctx.r[11].s64 + -7424;
	// 822E1EE4: 3D5F0002  addis r10, r31, 2
	ctx.r[10].s64 = ctx.r[31].s64 + 131072;
	// 822E1EE8: 57C704E6  rlwinm r7, r30, 0, 0x13, 0x13
	ctx.r[7].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 822E1EEC: 394A9BA0  addi r10, r10, -0x6460
	ctx.r[10].s64 = ctx.r[10].s64 + -25696;
	// 822E1EF0: 7EDF412E  stwx r22, r31, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32), ctx.r[22].u32) };
	// 822E1EF4: 3D3F0002  addis r9, r31, 2
	ctx.r[9].s64 = ctx.r[31].s64 + 131072;
	// 822E1EF8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1EFC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 822E1F00: 3929E2F0  addi r9, r9, -0x1d10
	ctx.r[9].s64 = ctx.r[9].s64 + -7440;
	// 822E1F04: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 822E1F08: E8EA0000  ld r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 822E1F0C: 3F3F0006  addis r25, r31, 6
	ctx.r[25].s64 = ctx.r[31].s64 + 393216;
	// 822E1F10: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 822E1F14: 3B399228  addi r25, r25, -0x6dd8
	ctx.r[25].s64 = ctx.r[25].s64 + -28120;
	// 822E1F18: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 822E1F1C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822E1F20: F8E90000  std r7, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 822E1F24: F9490008  std r10, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 822E1F28: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E1F2C: 92190000  stw r16, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[16].u32 ) };
	// 822E1F30: 6128E2D8  ori r8, r9, 0xe2d8
	ctx.r[8].u64 = ctx.r[9].u64 | 58072;
	// 822E1F34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1F38: 419A00D4  beq cr6, 0x822e200c
	if ctx.cr[6].eq {
	pc = 0x822E200C; continue 'dispatch;
	}
	// 822E1F3C: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E1F40: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822E1F44: 91FD0000  stw r15, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	// 822E1F48: 554A04E2  rlwinm r10, r10, 0, 0x13, 0x11
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822E1F4C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822E1F50: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E1F54: 7D7F412E  stwx r11, r31, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 822E1F58: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E1F5C: 616B94C8  ori r11, r11, 0x94c8
	ctx.r[11].u64 = ctx.r[11].u64 | 38088;
	// 822E1F60: 7D75582E  lwzx r11, r21, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E1F64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E1F68: 419A043C  beq cr6, 0x822e23a4
	if ctx.cr[6].eq {
	pc = 0x822E23A4; continue 'dispatch;
	}
	// 822E1F6C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E1F70: 616BE994  ori r11, r11, 0xe994
	ctx.r[11].u64 = ctx.r[11].u64 | 59796;
	// 822E1F74: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E1F78: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 822E1F7C: 409A0428  bne cr6, 0x822e23a4
	if !ctx.cr[6].eq {
	pc = 0x822E23A4; continue 'dispatch;
	}
	// 822E1F80: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E1F84: 616BE748  ori r11, r11, 0xe748
	ctx.r[11].u64 = ctx.r[11].u64 | 59208;
	// 822E1F88: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E1F8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E1F90: 419A003C  beq cr6, 0x822e1fcc
	if ctx.cr[6].eq {
	pc = 0x822E1FCC; continue 'dispatch;
	}
	pc = 0x822E1F94; continue 'dispatch;
            }
            0x822E1F94 => {
    //   block [0x822E1F94..0x822E1FB8)
	// 822E1F94: 894B0017  lbz r10, 0x17(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(23 as u32) ) } as u64;
	// 822E1F98: 7DCA5036  sld r10, r14, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = (ctx.r[14].u64) << ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 822E1F9C: 554A03BE  clrlwi r10, r10, 0xe
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0003FFFFu64;
	// 822E1FA0: 554A07FA  rlwinm r10, r10, 0, 0x1f, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822E1FA4: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 822E1FA8: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 822E1FAC: 7DCA7378  mr r10, r14
	ctx.r[10].u64 = ctx.r[14].u64;
	// 822E1FB0: 409A0008  bne cr6, 0x822e1fb8
	if !ctx.cr[6].eq {
	pc = 0x822E1FB8; continue 'dispatch;
	}
	// 822E1FB4: 7DEA7B78  mr r10, r15
	ctx.r[10].u64 = ctx.r[15].u64;
	pc = 0x822E1FB8; continue 'dispatch;
            }
            0x822E1FB8 => {
    //   block [0x822E1FB8..0x822E1FCC)
	// 822E1FB8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822E1FBC: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 822E1FC0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822E1FC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E1FC8: 409AFFCC  bne cr6, 0x822e1f94
	if !ctx.cr[6].eq {
	pc = 0x822E1F94; continue 'dispatch;
	}
	pc = 0x822E1FCC; continue 'dispatch;
            }
            0x822E1FCC => {
    //   block [0x822E1FCC..0x822E1FEC)
	// 822E1FCC: 3D7F0002  addis r11, r31, 2
	ctx.r[11].s64 = ctx.r[31].s64 + 131072;
	// 822E1FD0: 396BE338  addi r11, r11, -0x1cc8
	ctx.r[11].s64 = ctx.r[11].s64 + -7368;
	// 822E1FD4: 814B040C  lwz r10, 0x40c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1036 as u32) ) } as u64;
	// 822E1FD8: 2F0A0015  cmpwi cr6, r10, 0x15
	ctx.cr[6].compare_i32(ctx.r[10].s32, 21, &mut ctx.xer);
	// 822E1FDC: 409903C8  ble cr6, 0x822e23a4
	if !ctx.cr[6].gt {
	pc = 0x822E23A4; continue 'dispatch;
	}
	// 822E1FE0: 816B0410  lwz r11, 0x410(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1040 as u32) ) } as u64;
	// 822E1FE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E1FE8: 419A03BC  beq cr6, 0x822e23a4
	if ctx.cr[6].eq {
	pc = 0x822E23A4; continue 'dispatch;
	}
	pc = 0x822E1FEC; continue 'dispatch;
            }
            0x822E1FEC => {
    //   block [0x822E1FEC..0x822E1FFC)
	// 822E1FEC: 894B0017  lbz r10, 0x17(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(23 as u32) ) } as u64;
	// 822E1FF0: 2B0A0015  cmplwi cr6, r10, 0x15
	ctx.cr[6].compare_u32(ctx.r[10].u32, 21 as u32, &mut ctx.xer);
	// 822E1FF4: 409A0008  bne cr6, 0x822e1ffc
	if !ctx.cr[6].eq {
	pc = 0x822E1FFC; continue 'dispatch;
	}
	// 822E1FF8: B1EB0014  sth r15, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[15].u16 ) };
	pc = 0x822E1FFC; continue 'dispatch;
            }
            0x822E1FFC => {
    //   block [0x822E1FFC..0x822E200C)
	// 822E1FFC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822E2000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E2004: 409AFFE8  bne cr6, 0x822e1fec
	if !ctx.cr[6].eq {
	pc = 0x822E1FEC; continue 'dispatch;
	}
	// 822E2008: 4800039C  b 0x822e23a4
	pc = 0x822E23A4; continue 'dispatch;
            }
            0x822E200C => {
    //   block [0x822E200C..0x822E2088)
	// 822E200C: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E2010: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E2014: 6127E2C8  ori r7, r9, 0xe2c8
	ctx.r[7].u64 = ctx.r[9].u64 | 58056;
	// 822E2018: 614AEB1B  ori r10, r10, 0xeb1b
	ctx.r[10].u64 = ctx.r[10].u64 | 60187;
	// 822E201C: 3D200005  lis r9, 5
	ctx.r[9].s64 = 327680;
	// 822E2020: 7DF77B78  mr r23, r15
	ctx.r[23].u64 = ctx.r[15].u64;
	// 822E2024: 612691F6  ori r6, r9, 0x91f6
	ctx.r[6].u64 = ctx.r[9].u64 | 37366;
	// 822E2028: 57C9083C  slwi r9, r30, 1
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E202C: 7DDF51AE  stbx r14, r31, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[14].u8) };
	// 822E2030: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 822E2034: 7D3E4A14  add r9, r30, r9
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[9].u64;
	// 822E2038: 614591FA  ori r5, r10, 0x91fa
	ctx.r[5].u64 = ctx.r[10].u64 | 37370;
	// 822E203C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822E2040: 55292834  slwi r9, r9, 5
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E2044: 7DFF412E  stwx r15, r31, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32), ctx.r[15].u32) };
	// 822E2048: FAE10070  std r23, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[23].u64 ) };
	// 822E204C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822E2050: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E2054: 557C003E  slwi r28, r11, 0
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 822E2058: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 822E205C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E2060: 7F9F392E  stwx r28, r31, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[7].u32), ctx.r[28].u32) };
	// 822E2064: A17C0058  lhz r11, 0x58(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 822E2068: 7D7F332E  sthx r11, r31, r6
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u16) };
	// 822E206C: A17C0058  lhz r11, 0x58(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 822E2070: 7D7F2B2E  sthx r11, r31, r5
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[5].u32), ctx.r[11].u16) };
	// 822E2074: 419A002C  beq cr6, 0x822e20a0
	if ctx.cr[6].eq {
	pc = 0x822E20A0; continue 'dispatch;
	}
	// 822E2078: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 822E207C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 822E2080: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 822E2084: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x822E2088; continue 'dispatch;
            }
            0x822E2088 => {
    //   block [0x822E2088..0x822E20A0)
	// 822E2088: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E208C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E2090: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 822E2094: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E2098: 4200FFF0  bdnz 0x822e2088
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822E2088; continue 'dispatch;
	}
	// 822E209C: EAE10070  ld r23, 0x70(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	pc = 0x822E20A0; continue 'dispatch;
            }
            0x822E20A0 => {
    //   block [0x822E20A0..0x822E2114)
	// 822E20A0: 3FBF0002  addis r29, r31, 2
	ctx.r[29].s64 = ctx.r[31].s64 + 131072;
	// 822E20A4: 3FDF0002  addis r30, r31, 2
	ctx.r[30].s64 = ctx.r[31].s64 + 131072;
	// 822E20A8: 3BBDEB21  addi r29, r29, -0x14df
	ctx.r[29].s64 = ctx.r[29].s64 + -5343;
	// 822E20AC: 3BDEEB23  addi r30, r30, -0x14dd
	ctx.r[30].s64 = ctx.r[30].s64 + -5341;
	// 822E20B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E20B4: 7DF87B78  mr r24, r15
	ctx.r[24].u64 = ctx.r[15].u64;
	// 822E20B8: 8B7D0000  lbz r27, 0(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E20BC: 8B5E0000  lbz r26, 0(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E20C0: 48001319  bl 0x822e33d8
	ctx.lr = 0x822E20C4;
	sub_822E33D8(ctx, base);
	// 822E20C4: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E20C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E20CC: 419A0048  beq cr6, 0x822e2114
	if ctx.cr[6].eq {
	pc = 0x822E2114; continue 'dispatch;
	}
	// 822E20D0: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 822E20D4: 99FE0000  stb r15, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[15].u8 ) };
	// 822E20D8: 3D200005  lis r9, 5
	ctx.r[9].s64 = 327680;
	// 822E20DC: 91F90000  stw r15, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	// 822E20E0: 614A922C  ori r10, r10, 0x922c
	ctx.r[10].u64 = ctx.r[10].u64 | 37420;
	// 822E20E4: 3D000005  lis r8, 5
	ctx.r[8].s64 = 327680;
	// 822E20E8: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 822E20EC: 61299230  ori r9, r9, 0x9230
	ctx.r[9].u64 = ctx.r[9].u64 | 37424;
	// 822E20F0: 61089234  ori r8, r8, 0x9234
	ctx.r[8].u64 = ctx.r[8].u64 | 37428;
	// 822E20F4: 7DFF512E  stwx r15, r31, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[15].u32) };
	// 822E20F8: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E20FC: 60E7EB22  ori r7, r7, 0xeb22
	ctx.r[7].u64 = ctx.r[7].u64 | 60194;
	// 822E2100: 614AEB39  ori r10, r10, 0xeb39
	ctx.r[10].u64 = ctx.r[10].u64 | 60217;
	// 822E2104: 7DFF492E  stwx r15, r31, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), ctx.r[15].u32) };
	// 822E2108: 7DFF412E  stwx r15, r31, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32), ctx.r[15].u32) };
	// 822E210C: 7DFF39AE  stbx r15, r31, r7
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[7].u32), ctx.r[15].u8) };
	// 822E2110: 7DFF51AE  stbx r15, r31, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[15].u8) };
	pc = 0x822E2114; continue 'dispatch;
            }
            0x822E2114 => {
    //   block [0x822E2114..0x822E2178)
	// 822E2114: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E2118: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E211C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E2120: 7D6BDB78  or r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[27].u64;
	// 822E2124: 7D4AD378  or r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[26].u64;
	// 822E2128: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 822E212C: 995E0000  stb r10, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 822E2130: 4BEBC239  bl 0x8219e368
	ctx.lr = 0x822E2134;
	sub_8219E368(ctx, base);
	// 822E2134: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E2138: 6168E994  ori r8, r11, 0xe994
	ctx.r[8].u64 = ctx.r[11].u64 | 59796;
	// 822E213C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E2140: 616B94C8  ori r11, r11, 0x94c8
	ctx.r[11].u64 = ctx.r[11].u64 | 38088;
	// 822E2144: 7D75582E  lwzx r11, r21, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E2148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E214C: 419A005C  beq cr6, 0x822e21a8
	if ctx.cr[6].eq {
	pc = 0x822E21A8; continue 'dispatch;
	}
	// 822E2150: 7D7F402E  lwzx r11, r31, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 822E2154: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 822E2158: 409A0050  bne cr6, 0x822e21a8
	if !ctx.cr[6].eq {
	pc = 0x822E21A8; continue 'dispatch;
	}
	// 822E215C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E2160: 616BE748  ori r11, r11, 0xe748
	ctx.r[11].u64 = ctx.r[11].u64 | 59208;
	// 822E2164: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E2168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E216C: 419A003C  beq cr6, 0x822e21a8
	if ctx.cr[6].eq {
	pc = 0x822E21A8; continue 'dispatch;
	}
	// 822E2170: 66E90003  oris r9, r23, 3
	ctx.r[9].u64 = ctx.r[23].u64 | 196608;
	// 822E2174: 6129FFFD  ori r9, r9, 0xfffd
	ctx.r[9].u64 = ctx.r[9].u64 | 65533;
	pc = 0x822E2178; continue 'dispatch;
            }
            0x822E2178 => {
    //   block [0x822E2178..0x822E2194)
	// 822E2178: 894B0017  lbz r10, 0x17(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(23 as u32) ) } as u64;
	// 822E217C: 7DCA5036  sld r10, r14, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = (ctx.r[14].u64) << ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 822E2180: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 822E2184: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 822E2188: 7DCA7378  mr r10, r14
	ctx.r[10].u64 = ctx.r[14].u64;
	// 822E218C: 409A0008  bne cr6, 0x822e2194
	if !ctx.cr[6].eq {
	pc = 0x822E2194; continue 'dispatch;
	}
	// 822E2190: 7DEA7B78  mr r10, r15
	ctx.r[10].u64 = ctx.r[15].u64;
	pc = 0x822E2194; continue 'dispatch;
            }
            0x822E2194 => {
    //   block [0x822E2194..0x822E21A8)
	// 822E2194: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822E2198: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 822E219C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822E21A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E21A4: 409AFFD4  bne cr6, 0x822e2178
	if !ctx.cr[6].eq {
	pc = 0x822E2178; continue 'dispatch;
	}
	pc = 0x822E21A8; continue 'dispatch;
            }
            0x822E21A8 => {
    //   block [0x822E21A8..0x822E2200)
	// 822E21A8: 3D800600  lis r12, 0x600
	ctx.r[12].s64 = 100663296;
	// 822E21AC: 618C003F  ori r12, r12, 0x3f
	ctx.r[12].u64 = ctx.r[12].u64 | 63;
	// 822E21B0: 798CB264  sldi r12, r12, 0x16
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(22);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 822E21B4: 7EEB6038  and r11, r23, r12
	ctx.r[11].u64 = ctx.r[23].u64 & ctx.r[12].u64;
	// 822E21B8: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 822E21BC: 419A0154  beq cr6, 0x822e2310
	if ctx.cr[6].eq {
	pc = 0x822E2310; continue 'dispatch;
	}
	// 822E21C0: A17C0034  lhz r11, 0x34(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 822E21C4: 7DCA7378  mr r10, r14
	ctx.r[10].u64 = ctx.r[14].u64;
	// 822E21C8: 556B06F6  rlwinm r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822E21CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E21D0: 419A0030  beq cr6, 0x822e2200
	if ctx.cr[6].eq {
	pc = 0x822E2200; continue 'dispatch;
	}
	// 822E21D4: A17C000A  lhz r11, 0xa(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(10 as u32) ) } as u64;
	// 822E21D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E21DC: 409A0024  bne cr6, 0x822e2200
	if !ctx.cr[6].eq {
	pc = 0x822E2200; continue 'dispatch;
	}
	// 822E21E0: A17C000C  lhz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E21E4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E21E8: 7D69FE70  srawi r9, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 822E21EC: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 822E21F0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822E21F4: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 822E21F8: 40980008  bge cr6, 0x822e2200
	if !ctx.cr[6].lt {
	pc = 0x822E2200; continue 'dispatch;
	}
	// 822E21FC: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	pc = 0x822E2200; continue 'dispatch;
            }
            0x822E2200 => {
    //   block [0x822E2200..0x822E229C)
	// 822E2200: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E2204: 616BBEBA  ori r11, r11, 0xbeba
	ctx.r[11].u64 = ctx.r[11].u64 | 48826;
	// 822E2208: 7D7F5A2E  lhzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E220C: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 822E2210: 2B0B001A  cmplwi cr6, r11, 0x1a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 26 as u32, &mut ctx.xer);
	// 822E2214: 41990094  bgt cr6, 0x822e22a8
	if ctx.cr[6].gt {
	pc = 0x822E22A8; continue 'dispatch;
	}
	// 822E2218: 3D80822E  lis r12, -0x7dd2
	ctx.r[12].s64 = -2110914560;
	// 822E221C: 398C2230  addi r12, r12, 0x2230
	ctx.r[12].s64 = ctx.r[12].s64 + 8752;
	// 822E2220: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 822E2224: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 822E2228: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 822E222C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x822E22B4; continue 'dispatch;
		},
		1 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		2 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		3 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		4 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		5 => {
	pc = 0x822E22B4; continue 'dispatch;
		},
		6 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		7 => {
	pc = 0x822E229C; continue 'dispatch;
		},
		8 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		9 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		10 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		11 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		12 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		13 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		14 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		15 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		16 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		17 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		18 => {
	pc = 0x822E229C; continue 'dispatch;
		},
		19 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		20 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		21 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		22 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		23 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		24 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		25 => {
	pc = 0x822E22A8; continue 'dispatch;
		},
		26 => {
	pc = 0x822E22B4; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 822E2230: 822E22B4  lwz r17, 0x22b4(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8884 as u32) ) } as u64;
	// 822E2234: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2238: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E223C: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2240: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2244: 822E22B4  lwz r17, 0x22b4(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8884 as u32) ) } as u64;
	// 822E2248: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E224C: 822E229C  lwz r17, 0x229c(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8860 as u32) ) } as u64;
	// 822E2250: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2254: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2258: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E225C: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2260: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2264: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2268: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E226C: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2270: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2274: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2278: 822E229C  lwz r17, 0x229c(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8860 as u32) ) } as u64;
	// 822E227C: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2280: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2284: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2288: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E228C: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2290: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2294: 822E22A8  lwz r17, 0x22a8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8872 as u32) ) } as u64;
	// 822E2298: 822E22B4  lwz r17, 0x22b4(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8884 as u32) ) } as u64;
            }
            0x822E229C => {
    //   block [0x822E229C..0x822E22A8)
	// 822E229C: 7DF87B78  mr r24, r15
	ctx.r[24].u64 = ctx.r[15].u64;
	// 822E22A0: 91C10064  stw r14, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[14].u32 ) };
	// 822E22A4: 4800008C  b 0x822e2330
	pc = 0x822E2330; continue 'dispatch;
            }
            0x822E22A8 => {
    //   block [0x822E22A8..0x822E22B4)
	// 822E22A8: 56EB0212  rlwinm r11, r23, 0, 8, 9
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 822E22AC: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 822E22B0: 419A000C  beq cr6, 0x822e22bc
	if ctx.cr[6].eq {
	pc = 0x822E22BC; continue 'dispatch;
	}
	pc = 0x822E22B4; continue 'dispatch;
            }
            0x822E22B4 => {
    //   block [0x822E22B4..0x822E22BC)
	// 822E22B4: 7DF87B78  mr r24, r15
	ctx.r[24].u64 = ctx.r[15].u64;
	// 822E22B8: 48000078  b 0x822e2330
	pc = 0x822E2330; continue 'dispatch;
            }
            0x822E22BC => {
    //   block [0x822E22BC..0x822E22D0)
	// 822E22BC: 56EB018E  rlwinm r11, r23, 0, 6, 7
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 822E22C0: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 822E22C4: 419A000C  beq cr6, 0x822e22d0
	if ctx.cr[6].eq {
	pc = 0x822E22D0; continue 'dispatch;
	}
	// 822E22C8: 7DD87378  mr r24, r14
	ctx.r[24].u64 = ctx.r[14].u64;
	// 822E22CC: 48000064  b 0x822e2330
	pc = 0x822E2330; continue 'dispatch;
            }
            0x822E22D0 => {
    //   block [0x822E22D0..0x822E22F0)
	// 822E22D0: 3D800020  lis r12, 0x20
	ctx.r[12].s64 = 2097152;
	// 822E22D4: 618C0001  ori r12, r12, 1
	ctx.r[12].u64 = ctx.r[12].u64 | 1;
	// 822E22D8: 798CD164  sldi r12, r12, 0x1a
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(26);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 822E22DC: 7EEB6038  and r11, r23, r12
	ctx.r[11].u64 = ctx.r[23].u64 & ctx.r[12].u64;
	// 822E22E0: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 822E22E4: 419A000C  beq cr6, 0x822e22f0
	if ctx.cr[6].eq {
	pc = 0x822E22F0; continue 'dispatch;
	}
	// 822E22E8: 7E188378  mr r24, r16
	ctx.r[24].u64 = ctx.r[16].u64;
	// 822E22EC: 48000044  b 0x822e2330
	pc = 0x822E2330; continue 'dispatch;
            }
            0x822E22F0 => {
    //   block [0x822E22F0..0x822E2310)
	// 822E22F0: 3D800020  lis r12, 0x20
	ctx.r[12].s64 = 2097152;
	// 822E22F4: 618C0001  ori r12, r12, 1
	ctx.r[12].u64 = ctx.r[12].u64 | 1;
	// 822E22F8: 798CD924  sldi r12, r12, 0x1b
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(27);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 822E22FC: 7EEB6038  and r11, r23, r12
	ctx.r[11].u64 = ctx.r[23].u64 & ctx.r[12].u64;
	// 822E2300: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 822E2304: 419A002C  beq cr6, 0x822e2330
	if ctx.cr[6].eq {
	pc = 0x822E2330; continue 'dispatch;
	}
	// 822E2308: 3B000003  li r24, 3
	ctx.r[24].s64 = 3;
	// 822E230C: 48000024  b 0x822e2330
	pc = 0x822E2330; continue 'dispatch;
            }
            0x822E2310 => {
    //   block [0x822E2310..0x822E2330)
	// 822E2310: 3D80001B  lis r12, 0x1b
	ctx.r[12].s64 = 1769472;
	// 822E2314: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 822E2318: 618CF0C0  ori r12, r12, 0xf0c0
	ctx.r[12].u64 = ctx.r[12].u64 | 61632;
	// 822E231C: 7EEB6038  and r11, r23, r12
	ctx.r[11].u64 = ctx.r[23].u64 & ctx.r[12].u64;
	// 822E2320: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822E2324: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822E2328: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 822E232C: 3B0B0004  addi r24, r11, 4
	ctx.r[24].s64 = ctx.r[11].s64 + 4;
	pc = 0x822E2330; continue 'dispatch;
            }
            0x822E2330 => {
    //   block [0x822E2330..0x822E2378)
	// 822E2330: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E2334: 7D1F402E  lwzx r8, r31, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 822E2338: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E233C: 7F1F912E  stwx r24, r31, r18
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[18].u32), ctx.r[24].u32) };
	// 822E2340: 616BE304  ori r11, r11, 0xe304
	ctx.r[11].u64 = ctx.r[11].u64 | 58116;
	// 822E2344: 6129E30C  ori r9, r9, 0xe30c
	ctx.r[9].u64 = ctx.r[9].u64 | 58124;
	// 822E2348: 2F080005  cmpwi cr6, r8, 5
	ctx.cr[6].compare_i32(ctx.r[8].s32, 5, &mut ctx.xer);
	// 822E234C: 7D5F592E  stwx r10, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 822E2350: 7F1F492E  stwx r24, r31, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), ctx.r[24].u32) };
	// 822E2354: 409A0050  bne cr6, 0x822e23a4
	if !ctx.cr[6].eq {
	pc = 0x822E23A4; continue 'dispatch;
	}
	// 822E2358: 3D7F0002  addis r11, r31, 2
	ctx.r[11].s64 = ctx.r[31].s64 + 131072;
	// 822E235C: 396BE338  addi r11, r11, -0x1cc8
	ctx.r[11].s64 = ctx.r[11].s64 + -7368;
	// 822E2360: 814B040C  lwz r10, 0x40c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1036 as u32) ) } as u64;
	// 822E2364: 2F0A0015  cmpwi cr6, r10, 0x15
	ctx.cr[6].compare_i32(ctx.r[10].s32, 21, &mut ctx.xer);
	// 822E2368: 4099003C  ble cr6, 0x822e23a4
	if !ctx.cr[6].gt {
	pc = 0x822E23A4; continue 'dispatch;
	}
	// 822E236C: 816B0410  lwz r11, 0x410(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1040 as u32) ) } as u64;
	// 822E2370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E2374: 419A0030  beq cr6, 0x822e23a4
	if ctx.cr[6].eq {
	pc = 0x822E23A4; continue 'dispatch;
	}
	pc = 0x822E2378; continue 'dispatch;
            }
            0x822E2378 => {
    //   block [0x822E2378..0x822E2388)
	// 822E2378: 894B0017  lbz r10, 0x17(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(23 as u32) ) } as u64;
	// 822E237C: 2B0A0015  cmplwi cr6, r10, 0x15
	ctx.cr[6].compare_u32(ctx.r[10].u32, 21 as u32, &mut ctx.xer);
	// 822E2380: 409A0008  bne cr6, 0x822e2388
	if !ctx.cr[6].eq {
	pc = 0x822E2388; continue 'dispatch;
	}
	// 822E2384: B1CB0014  sth r14, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[14].u16 ) };
	pc = 0x822E2388; continue 'dispatch;
            }
            0x822E2388 => {
    //   block [0x822E2388..0x822E2398)
	// 822E2388: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822E238C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E2390: 409AFFE8  bne cr6, 0x822e2378
	if !ctx.cr[6].eq {
	pc = 0x822E2378; continue 'dispatch;
	}
	// 822E2394: 48000010  b 0x822e23a4
	pc = 0x822E23A4; continue 'dispatch;
            }
            0x822E2398 => {
    //   block [0x822E2398..0x822E23A4)
	// 822E2398: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E239C: 616BE300  ori r11, r11, 0xe300
	ctx.r[11].u64 = ctx.r[11].u64 | 58112;
	// 822E23A0: 7DFF592E  stwx r15, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[15].u32) };
	pc = 0x822E23A4; continue 'dispatch;
            }
            0x822E23A4 => {
    //   block [0x822E23A4..0x822E23D8)
	// 822E23A4: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E23A8: 616B9468  ori r11, r11, 0x9468
	ctx.r[11].u64 = ctx.r[11].u64 | 37992;
	// 822E23AC: 7D75582E  lwzx r11, r21, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E23B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E23B4: 409AF5D4  bne cr6, 0x822e1988
	if !ctx.cr[6].eq {
	pc = 0x822E1988; continue 'dispatch;
	}
	// 822E23B8: A1760002  lhz r11, 2(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E23BC: B1D60026  sth r14, 0x26(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(38 as u32), ctx.r[14].u16 ) };
	// 822E23C0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E23C4: B1F60048  sth r15, 0x48(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(72 as u32), ctx.r[15].u16 ) };
	// 822E23C8: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 822E23CC: 4198000C  blt cr6, 0x822e23d8
	if ctx.cr[6].lt {
	pc = 0x822E23D8; continue 'dispatch;
	}
	// 822E23D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E23D4: 41980180  blt cr6, 0x822e2554
	if ctx.cr[6].lt {
	pc = 0x822E2554; continue 'dispatch;
	}
	pc = 0x822E23D8; continue 'dispatch;
            }
            0x822E23D8 => {
    //   block [0x822E23D8..0x822E2478)
	// 822E23D8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E23DC: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822E23E0: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E23E4: 616BFAF0  ori r11, r11, 0xfaf0
	ctx.r[11].u64 = ctx.r[11].u64 | 64240;
	// 822E23E8: 6129FB08  ori r9, r9, 0xfb08
	ctx.r[9].u64 = ctx.r[9].u64 | 64264;
	// 822E23EC: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 822E23F0: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E23F4: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E23F8: 60E7FAF4  ori r7, r7, 0xfaf4
	ctx.r[7].u64 = ctx.r[7].u64 | 64244;
	// 822E23FC: 7EDF592E  stwx r22, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[22].u32) };
	// 822E2400: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E2404: 614AFB00  ori r10, r10, 0xfb00
	ctx.r[10].u64 = ctx.r[10].u64 | 64256;
	// 822E2408: 6168FAFC  ori r8, r11, 0xfafc
	ctx.r[8].u64 = ctx.r[11].u64 | 64252;
	// 822E240C: A1760000  lhz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E2410: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E2414: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E2418: 91730000  stw r11, 0(r19)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E241C: A1760000  lhz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E2420: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E2424: 7DCB5830  slw r11, r14, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[14].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 822E2428: 7D7F512E  stwx r11, r31, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 822E242C: A1760002  lhz r11, 2(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E2430: 7D7F4B2E  sthx r11, r31, r9
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u16) };
	// 822E2434: A1760000  lhz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E2438: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E243C: 216B0001  subfic r11, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[11].s64 = (1 as i64) - ctx.r[11].s64;
	// 822E2440: 1D4B0458  mulli r10, r11, 0x458
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 1112 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822E2444: 7D7F412E  stwx r11, r31, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 822E2448: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 822E244C: 3D4A0002  addis r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 131072;
	// 822E2450: 394AEEC8  addi r10, r10, -0x1138
	ctx.r[10].s64 = ctx.r[10].s64 + -4408;
	// 822E2454: 7D5F392E  stwx r10, r31, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[7].u32), ctx.r[10].u32) };
	// 822E2458: A1760002  lhz r11, 2(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E245C: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 822E2460: 4BFFD8D9  bl 0x822dfd38
	ctx.lr = 0x822E2464;
	sub_822DFD38(ctx, base);
	// 822E2464: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 822E2468: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 822E246C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822E2470: 419A0008  beq cr6, 0x822e2478
	if ctx.cr[6].eq {
	pc = 0x822E2478; continue 'dispatch;
	}
	// 822E2474: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	pc = 0x822E2478; continue 'dispatch;
            }
            0x822E2478 => {
    //   block [0x822E2478..0x822E2498)
	// 822E2478: A176004C  lhz r11, 0x4c(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(76 as u32) ) } as u64;
	// 822E247C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822E2480: A0B60064  lhz r5, 0x64(r22)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 822E2484: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E2488: B176004C  sth r11, 0x4c(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(76 as u32), ctx.r[11].u16 ) };
	// 822E248C: 409A000C  bne cr6, 0x822e2498
	if !ctx.cr[6].eq {
	pc = 0x822E2498; continue 'dispatch;
	}
	// 822E2490: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 822E2494: 48000040  b 0x822e24d4
	pc = 0x822E24D4; continue 'dispatch;
            }
            0x822E2498 => {
    //   block [0x822E2498..0x822E24D4)
	// 822E2498: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E249C: 7DEA7B78  mr r10, r15
	ctx.r[10].u64 = ctx.r[15].u64;
	// 822E24A0: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 822E24A4: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E24A8: 38D60066  addi r6, r22, 0x66
	ctx.r[6].s64 = ctx.r[22].s64 + 102;
	// 822E24AC: 396BA928  addi r11, r11, -0x56d8
	ctx.r[11].s64 = ctx.r[11].s64 + -22232;
	// 822E24B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E24B4: 914B0BD8  stw r10, 0xbd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3032 as u32), ctx.r[10].u32 ) };
	// 822E24B8: B14B0BDC  sth r10, 0xbdc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(3036 as u32), ctx.r[10].u16 ) };
	// 822E24BC: 914B0BE0  stw r10, 0xbe0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3040 as u32), ctx.r[10].u32 ) };
	// 822E24C0: 7D5F48AE  lbzx r10, r31, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E24C4: 1D4A01E0  mulli r10, r10, 0x1e0
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 480 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822E24C8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E24CC: 914B03C0  stw r10, 0x3c0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(960 as u32), ctx.r[10].u32 ) };
	// 822E24D0: 480022D9  bl 0x822e47a8
	ctx.lr = 0x822E24D4;
	sub_822E47A8(ctx, base);
	pc = 0x822E24D4; continue 'dispatch;
            }
            0x822E24D4 => {
    //   block [0x822E24D4..0x822E2534)
	// 822E24D4: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 822E24D8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 822E24DC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822E24E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E24E4: 419A0070  beq cr6, 0x822e2554
	if ctx.cr[6].eq {
	pc = 0x822E2554; continue 'dispatch;
	}
	// 822E24E8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E24EC: 616BED30  ori r11, r11, 0xed30
	ctx.r[11].u64 = ctx.r[11].u64 | 60720;
	// 822E24F0: 7D7F5A2E  lhzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E24F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E24F8: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 822E24FC: 41990054  bgt cr6, 0x822e2550
	if ctx.cr[6].gt {
	pc = 0x822E2550; continue 'dispatch;
	}
	// 822E2500: 3D80822E  lis r12, -0x7dd2
	ctx.r[12].s64 = -2110914560;
	// 822E2504: 398C2518  addi r12, r12, 0x2518
	ctx.r[12].s64 = ctx.r[12].s64 + 9496;
	// 822E2508: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 822E250C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 822E2510: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 822E2514: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x822E2534; continue 'dispatch;
		},
		1 => {
	pc = 0x822E2534; continue 'dispatch;
		},
		2 => {
	pc = 0x822E2550; continue 'dispatch;
		},
		3 => {
	pc = 0x822E2534; continue 'dispatch;
		},
		4 => {
	pc = 0x822E253C; continue 'dispatch;
		},
		5 => {
	pc = 0x822E2544; continue 'dispatch;
		},
		6 => {
	pc = 0x822E2534; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 822E2518: 822E2534  lwz r17, 0x2534(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(9524 as u32) ) } as u64;
	// 822E251C: 822E2534  lwz r17, 0x2534(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(9524 as u32) ) } as u64;
	// 822E2520: 822E2550  lwz r17, 0x2550(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(9552 as u32) ) } as u64;
	// 822E2524: 822E2534  lwz r17, 0x2534(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(9524 as u32) ) } as u64;
	// 822E2528: 822E253C  lwz r17, 0x253c(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(9532 as u32) ) } as u64;
	// 822E252C: 822E2544  lwz r17, 0x2544(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(9540 as u32) ) } as u64;
	// 822E2530: 822E2534  lwz r17, 0x2534(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(9524 as u32) ) } as u64;
            }
            0x822E2534 => {
    //   block [0x822E2534..0x822E253C)
	// 822E2534: 7DDF912E  stwx r14, r31, r18
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[18].u32), ctx.r[14].u32) };
	// 822E2538: 4800001C  b 0x822e2554
	pc = 0x822E2554; continue 'dispatch;
            }
            0x822E253C => {
    //   block [0x822E253C..0x822E2544)
	// 822E253C: 7E1F912E  stwx r16, r31, r18
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[18].u32), ctx.r[16].u32) };
	// 822E2540: 48000014  b 0x822e2554
	pc = 0x822E2554; continue 'dispatch;
            }
            0x822E2544 => {
    //   block [0x822E2544..0x822E2550)
	// 822E2544: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 822E2548: 7D7F912E  stwx r11, r31, r18
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[18].u32), ctx.r[11].u32) };
	// 822E254C: 48000008  b 0x822e2554
	pc = 0x822E2554; continue 'dispatch;
            }
            0x822E2550 => {
    //   block [0x822E2550..0x822E2554)
	// 822E2550: 7DFF912E  stwx r15, r31, r18
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[18].u32), ctx.r[15].u32) };
	pc = 0x822E2554; continue 'dispatch;
            }
            0x822E2554 => {
    //   block [0x822E2554..0x822E2580)
	// 822E2554: B1F60026  sth r15, 0x26(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(38 as u32), ctx.r[15].u16 ) };
	// 822E2558: A1760002  lhz r11, 2(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[22].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E255C: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E2560: 419A0034  beq cr6, 0x822e2594
	if ctx.cr[6].eq {
	pc = 0x822E2594; continue 'dispatch;
	}
	// 822E2564: C0160008  lfs f0, 8(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E2568: D0160020  stfs f0, 0x20(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822E256C: 817600D0  lwz r11, 0xd0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E2570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E2574: 419A000C  beq cr6, 0x822e2580
	if ctx.cr[6].eq {
	pc = 0x822E2580; continue 'dispatch;
	}
	// 822E2578: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E257C: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x822E2580; continue 'dispatch;
            }
            0x822E2580 => {
    //   block [0x822E2580..0x822E2594)
	// 822E2580: 817600D4  lwz r11, 0xd4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(212 as u32) ) } as u64;
	// 822E2584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E2588: 419A000C  beq cr6, 0x822e2594
	if ctx.cr[6].eq {
	pc = 0x822E2594; continue 'dispatch;
	}
	// 822E258C: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E2590: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x822E2594; continue 'dispatch;
            }
            0x822E2594 => {
    //   block [0x822E2594..0x822E25A0)
	// 822E2594: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E2598: 616BFB0C  ori r11, r11, 0xfb0c
	ctx.r[11].u64 = ctx.r[11].u64 | 64268;
	// 822E259C: 7DFF592E  stwx r15, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[15].u32) };
	pc = 0x822E25A0; continue 'dispatch;
            }
            0x822E25A0 => {
    //   block [0x822E25A0..0x822E25B4)
	// 822E25A0: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 822E25A4: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822E25A8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 822E25AC: 48253A85  bl 0x82536030
	ctx.lr = 0x822E25B0;
	sub_82535FFC(ctx, base);
	// 822E25B0: 48252B20  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E25B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E25B8 size=724
    let mut pc: u32 = 0x822E25B8;
    'dispatch: loop {
        match pc {
            0x822E25B8 => {
    //   block [0x822E25B8..0x822E26CC)
	// 822E25B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E25BC: 48252AF9  bl 0x825350b4
	ctx.lr = 0x822E25C0;
	sub_82535080(ctx, base);
	// 822E25C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E25C4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E25C8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 822E25CC: 394BBFF0  addi r10, r11, -0x4010
	ctx.r[10].s64 = ctx.r[11].s64 + -16400;
	// 822E25D0: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E25D4: 3C670006  addis r3, r7, 6
	ctx.r[3].s64 = ctx.r[7].s64 + 393216;
	// 822E25D8: 616B8654  ori r11, r11, 0x8654
	ctx.r[11].u64 = ctx.r[11].u64 | 34388;
	// 822E25DC: 3863A9C0  addi r3, r3, -0x5640
	ctx.r[3].s64 = ctx.r[3].s64 + -22080;
	// 822E25E0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E25E4: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E25E8: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 822E25EC: 419A0298  beq cr6, 0x822e2884
	if ctx.cr[6].eq {
	pc = 0x822E2884; continue 'dispatch;
	}
	// 822E25F0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E25F4: 616BE99C  ori r11, r11, 0xe99c
	ctx.r[11].u64 = ctx.r[11].u64 | 59804;
	// 822E25F8: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E25FC: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 822E2600: 409A0284  bne cr6, 0x822e2884
	if !ctx.cr[6].eq {
	pc = 0x822E2884; continue 'dispatch;
	}
	// 822E2604: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E2608: 616BED6C  ori r11, r11, 0xed6c
	ctx.r[11].u64 = ctx.r[11].u64 | 60780;
	// 822E260C: 7D685A2E  lhzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E2610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E2614: 409A0270  bne cr6, 0x822e2884
	if !ctx.cr[6].eq {
	pc = 0x822E2884; continue 'dispatch;
	}
	// 822E2618: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E261C: 90EA001C  stw r7, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 822E2620: 6169F322  ori r9, r11, 0xf322
	ctx.r[9].u64 = ctx.r[11].u64 | 62242;
	// 822E2624: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E2628: 6166EB15  ori r6, r11, 0xeb15
	ctx.r[6].u64 = ctx.r[11].u64 | 60181;
	// 822E262C: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E2630: 7D274A2E  lhzx r9, r7, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E2634: 396BA920  addi r11, r11, -0x56e0
	ctx.r[11].s64 = ctx.r[11].s64 + -22240;
	// 822E2638: 908BFFE4  stw r4, -0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28 as u32), ctx.r[4].u32 ) };
	// 822E263C: 3C800003  lis r4, 3
	ctx.r[4].s64 = 196608;
	// 822E2640: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 822E2644: 3CA00005  lis r5, 5
	ctx.r[5].s64 = 327680;
	// 822E2648: 608494CC  ori r4, r4, 0x94cc
	ctx.r[4].u64 = ctx.r[4].u64 | 38092;
	// 822E264C: 90EBFFD8  stw r7, -0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-40 as u32), ctx.r[7].u32 ) };
	// 822E2650: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E2654: 60A58F94  ori r5, r5, 0x8f94
	ctx.r[5].u64 = ctx.r[5].u64 | 36756;
	// 822E2658: 616B9B84  ori r11, r11, 0x9b84
	ctx.r[11].u64 = ctx.r[11].u64 | 39812;
	// 822E265C: 7D2A232E  sthx r9, r10, r4
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32), ctx.r[9].u16) };
	// 822E2660: 3C800003  lis r4, 3
	ctx.r[4].s64 = 196608;
	// 822E2664: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822E2668: 608494D0  ori r4, r4, 0x94d0
	ctx.r[4].u64 = ctx.r[4].u64 | 38096;
	// 822E266C: 7D2A212E  stwx r9, r10, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32), ctx.r[9].u32) };
	// 822E2670: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822E2674: 7D4830AE  lbzx r10, r8, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 822E2678: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E267C: 419A0050  beq cr6, 0x822e26cc
	if ctx.cr[6].eq {
	pc = 0x822E26CC; continue 'dispatch;
	}
	// 822E2680: 3FE00001  lis r31, 1
	ctx.r[31].s64 = 65536;
	// 822E2684: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E2688: 3FC00001  lis r30, 1
	ctx.r[30].s64 = 65536;
	// 822E268C: 63FFEC85  ori r31, r31, 0xec85
	ctx.r[31].u64 = ctx.r[31].u64 | 60549;
	// 822E2690: 63DEECE1  ori r30, r30, 0xece1
	ctx.r[30].u64 = ctx.r[30].u64 | 60641;
	// 822E2694: 3FA00001  lis r29, 1
	ctx.r[29].s64 = 65536;
	// 822E2698: 3F800001  lis r28, 1
	ctx.r[28].s64 = 65536;
	// 822E269C: 3F600001  lis r27, 1
	ctx.r[27].s64 = 65536;
	// 822E26A0: 7C8AF9AE  stbx r4, r10, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[4].u8) };
	// 822E26A4: 63BDEC82  ori r29, r29, 0xec82
	ctx.r[29].u64 = ctx.r[29].u64 | 60546;
	// 822E26A8: 7D2AF1AE  stbx r9, r10, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32), ctx.r[9].u8) };
	// 822E26AC: 639CECDE  ori r28, r28, 0xecde
	ctx.r[28].u64 = ctx.r[28].u64 | 60638;
	// 822E26B0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E26B4: 637BD338  ori r27, r27, 0xd338
	ctx.r[27].u64 = ctx.r[27].u64 | 54072;
	// 822E26B8: 7C8AE9AE  stbx r4, r10, r29
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32), ctx.r[4].u8) };
	// 822E26BC: 7D2AE1AE  stbx r9, r10, r28
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u8) };
	// 822E26C0: 7C08DC2E  lfsx f0, r8, r27
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[27].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E26C4: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 822E26C8: 7D28292E  stwx r9, r8, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32), ctx.r[9].u32) };
	pc = 0x822E26CC; continue 'dispatch;
            }
            0x822E26CC => {
    //   block [0x822E26CC..0x822E2710)
	// 822E26CC: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E26D0: 614A9B80  ori r10, r10, 0x9b80
	ctx.r[10].u64 = ctx.r[10].u64 | 39808;
	// 822E26D4: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 822E26D8: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 822E26DC: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E26E0: 614A9B88  ori r10, r10, 0x9b88
	ctx.r[10].u64 = ctx.r[10].u64 | 39816;
	// 822E26E4: 7C081C2E  lfsx f0, r8, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E26E8: 7C07FD2E  stfsx f0, r7, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 822E26EC: 7C08542E  lfsx f0, r8, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E26F0: 7C07552E  stfsx f0, r7, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 822E26F4: 3D470002  addis r10, r7, 2
	ctx.r[10].s64 = ctx.r[7].s64 + 131072;
	// 822E26F8: 7C075C2E  lfsx f0, r7, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E26FC: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 822E2700: 354AEB00  addic. r10, r10, -0x1500
	ctx.xer.ca = (ctx.r[10].u32 > (!(-5376 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -5376;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822E2704: 7D2731AE  stbx r9, r7, r6
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[9].u8) };
	// 822E2708: 40820008  bne 0x822e2710
	if !ctx.cr[0].eq {
	pc = 0x822E2710; continue 'dispatch;
	}
	// 822E270C: 7D27292E  stwx r9, r7, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[5].u32), ctx.r[9].u32) };
	pc = 0x822E2710; continue 'dispatch;
            }
            0x822E2710 => {
    //   block [0x822E2710..0x822E27F0)
	// 822E2710: 3D680002  addis r11, r8, 2
	ctx.r[11].s64 = ctx.r[8].s64 + 131072;
	// 822E2714: 396BE780  addi r11, r11, -0x1880
	ctx.r[11].s64 = ctx.r[11].s64 + -6272;
	// 822E2718: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E271C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E2720: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 822E2724: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822E2728: 419900C8  bgt cr6, 0x822e27f0
	if ctx.cr[6].gt {
	pc = 0x822E27F0; continue 'dispatch;
	}
	// 822E272C: 3D670006  addis r11, r7, 6
	ctx.r[11].s64 = ctx.r[7].s64 + 393216;
	// 822E2730: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E2734: 396B8990  addi r11, r11, -0x7670
	ctx.r[11].s64 = ctx.r[11].s64 + -30320;
	// 822E2738: 6149E9E0  ori r9, r10, 0xe9e0
	ctx.r[9].u64 = ctx.r[10].u64 | 59872;
	// 822E273C: 3CC70002  addis r6, r7, 2
	ctx.r[6].s64 = ctx.r[7].s64 + 131072;
	// 822E2740: 38C69CDC  addi r6, r6, -0x6324
	ctx.r[6].s64 = ctx.r[6].s64 + -25380;
	// 822E2744: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E2748: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E274C: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 822E2750: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E2754: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E2758: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E275C: A16B0010  lhz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822E2760: 556B0026  rlwinm r11, r11, 0, 0, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822E2764: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822E2768: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E276C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E2770: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E2774: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E2778: C00B2154  lfs f0, 0x2154(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E277C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E2780: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E2784: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E2788: 7DA84C2E  lfsx f13, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E278C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E2790: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E2794: EC2D0028  fsubs f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E2798: 48085409  bl 0x82367ba0
	ctx.lr = 0x822E279C;
	sub_82367BA0(ctx, base);
	// 822E279C: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 822E27A0: 4BE5AB39  bl 0x8213d2d8
	ctx.lr = 0x822E27A4;
	sub_8213D2D8(ctx, base);
	// 822E27A4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E27A8: C0060000  lfs f0, 0(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E27AC: 616A9B74  ori r10, r11, 0x9b74
	ctx.r[10].u64 = ctx.r[11].u64 | 39796;
	// 822E27B0: 7DA8542E  lfsx f13, r8, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E27B4: EC2D0028  fsubs f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E27B8: 480853E9  bl 0x82367ba0
	ctx.lr = 0x822E27BC;
	sub_82367BA0(ctx, base);
	// 822E27BC: 7C07542E  lfsx f0, r7, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E27C0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 822E27C4: EC210028  fsubs f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E27C8: 4BE5AB11  bl 0x8213d2d8
	ctx.lr = 0x822E27CC;
	sub_8213D2D8(ctx, base);
	// 822E27CC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E27D0: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E27D4: 616BEB20  ori r11, r11, 0xeb20
	ctx.r[11].u64 = ctx.r[11].u64 | 60192;
	// 822E27D8: 614AEB04  ori r10, r10, 0xeb04
	ctx.r[10].u64 = ctx.r[10].u64 | 60164;
	// 822E27DC: 7D6858AE  lbzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E27E0: 7D4850AE  lbzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E27E4: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 822E27E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E27EC: 419A005C  beq cr6, 0x822e2848
	if ctx.cr[6].eq {
	pc = 0x822E2848; continue 'dispatch;
	}
	pc = 0x822E27F0; continue 'dispatch;
            }
            0x822E27F0 => {
    //   block [0x822E27F0..0x822E2848)
	// 822E27F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E27F4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E27F8: 3D680002  addis r11, r8, 2
	ctx.r[11].s64 = ctx.r[8].s64 + 131072;
	// 822E27FC: 396BF780  addi r11, r11, -0x880
	ctx.r[11].s64 = ctx.r[11].s64 + -2176;
	// 822E2800: D00B0068  stfs f0, 0x68(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822E2804: D00B0064  stfs f0, 0x64(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822E2808: D00B0060  stfs f0, 0x60(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E280C: 3D680002  addis r11, r8, 2
	ctx.r[11].s64 = ctx.r[8].s64 + 131072;
	// 822E2810: 396BF830  addi r11, r11, -0x7d0
	ctx.r[11].s64 = ctx.r[11].s64 + -2000;
	// 822E2814: D00B0068  stfs f0, 0x68(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822E2818: D00B0064  stfs f0, 0x64(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822E281C: D00B0060  stfs f0, 0x60(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E2820: 3D680002  addis r11, r8, 2
	ctx.r[11].s64 = ctx.r[8].s64 + 131072;
	// 822E2824: 396BF8E0  addi r11, r11, -0x720
	ctx.r[11].s64 = ctx.r[11].s64 + -1824;
	// 822E2828: D00B0068  stfs f0, 0x68(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822E282C: D00B0064  stfs f0, 0x64(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822E2830: D00B0060  stfs f0, 0x60(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E2834: 3D680002  addis r11, r8, 2
	ctx.r[11].s64 = ctx.r[8].s64 + 131072;
	// 822E2838: 396BF990  addi r11, r11, -0x670
	ctx.r[11].s64 = ctx.r[11].s64 + -1648;
	// 822E283C: D00B0068  stfs f0, 0x68(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822E2840: D00B0064  stfs f0, 0x64(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822E2844: D00B0060  stfs f0, 0x60(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	pc = 0x822E2848; continue 'dispatch;
            }
            0x822E2848 => {
    //   block [0x822E2848..0x822E2884)
	// 822E2848: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E284C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E2850: 616BFAF0  ori r11, r11, 0xfaf0
	ctx.r[11].u64 = ctx.r[11].u64 | 64240;
	// 822E2854: 614AEB1C  ori r10, r10, 0xeb1c
	ctx.r[10].u64 = ctx.r[10].u64 | 60188;
	// 822E2858: 7D67582E  lwzx r11, r7, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E285C: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E2860: 7C8751AE  stbx r4, r7, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[4].u8) };
	// 822E2864: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E2868: 1D6B0458  mulli r11, r11, 0x458
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E286C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 822E2870: 3D6B0002  addis r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 131072;
	// 822E2874: 396BEEC8  addi r11, r11, -0x1138
	ctx.r[11].s64 = ctx.r[11].s64 + -4408;
	// 822E2878: E94B0430  ld r10, 0x430(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(1072 as u32) ) };
	// 822E287C: 654A1000  oris r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 268435456;
	// 822E2880: F94B0430  std r10, 0x430(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(1072 as u32), ctx.r[10].u64 ) };
	pc = 0x822E2884; continue 'dispatch;
            }
            0x822E2884 => {
    //   block [0x822E2884..0x822E288C)
	// 822E2884: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822E2888: 4825287C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E2890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E2890 size=536
    let mut pc: u32 = 0x822E2890;
    'dispatch: loop {
        match pc {
            0x822E2890 => {
    //   block [0x822E2890..0x822E2950)
	// 822E2890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E2894: 48252829  bl 0x825350bc
	ctx.lr = 0x822E2898;
	sub_82535080(ctx, base);
	// 822E2898: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822E289C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E28A0: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E28A4: 396BA904  addi r11, r11, -0x56fc
	ctx.r[11].s64 = ctx.r[11].s64 + -22268;
	// 822E28A8: 83CBFFF4  lwz r30, -0xc(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 822E28AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822E28B0: 419A01EC  beq cr6, 0x822e2a9c
	if ctx.cr[6].eq {
	pc = 0x822E2A9C; continue 'dispatch;
	}
	// 822E28B4: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 822E28B8: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822E28BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822E28C0: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E28C4: 6148A9C0  ori r8, r10, 0xa9c0
	ctx.r[8].u64 = ctx.r[10].u64 | 43456;
	// 822E28C8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E28CC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 822E28D0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822E28D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822E28D8: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 822E28DC: 7FFE402E  lwzx r31, r30, r8
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 822E28E0: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 822E28E4: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E28E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E28EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E28F0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822E28F4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 822E28F8: 90CBFFF4  stw r6, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[6].u32 ) };
	// 822E28FC: 4BFFEEDD  bl 0x822e17d8
	ctx.lr = 0x822E2900;
	sub_822E17D8(ctx, base);
	// 822E2900: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E2904: 390BBFF0  addi r8, r11, -0x4010
	ctx.r[8].s64 = ctx.r[11].s64 + -16400;
	// 822E2908: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E290C: 616B8654  ori r11, r11, 0x8654
	ctx.r[11].u64 = ctx.r[11].u64 | 34388;
	// 822E2910: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E2914: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 822E2918: 409A0074  bne cr6, 0x822e298c
	if !ctx.cr[6].eq {
	pc = 0x822E298C; continue 'dispatch;
	}
	// 822E291C: 3D7E0002  addis r11, r30, 2
	ctx.r[11].s64 = ctx.r[30].s64 + 131072;
	// 822E2920: 396BE1FC  addi r11, r11, -0x1e04
	ctx.r[11].s64 = ctx.r[11].s64 + -7684;
	// 822E2924: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E2928: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E292C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822E2930: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E2934: 616B93DC  ori r11, r11, 0x93dc
	ctx.r[11].u64 = ctx.r[11].u64 | 37852;
	// 822E2938: 7D685A2E  lhzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E293C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E2940: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E2944: 4098000C  bge cr6, 0x822e2950
	if !ctx.cr[6].lt {
	pc = 0x822E2950; continue 'dispatch;
	}
	// 822E2948: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822E294C: 48000010  b 0x822e295c
	pc = 0x822E295C; continue 'dispatch;
            }
            0x822E2950 => {
    //   block [0x822E2950..0x822E295C)
	// 822E2950: 2F0B000B  cmpwi cr6, r11, 0xb
	ctx.cr[6].compare_i32(ctx.r[11].s32, 11, &mut ctx.xer);
	// 822E2954: 40990008  ble cr6, 0x822e295c
	if !ctx.cr[6].gt {
	pc = 0x822E295C; continue 'dispatch;
	}
	// 822E2958: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
	pc = 0x822E295C; continue 'dispatch;
            }
            0x822E295C => {
    //   block [0x822E295C..0x822E298C)
	// 822E295C: 1D6B00C4  mulli r11, r11, 0xc4
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 196 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E2960: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822E2964: 3D5E0002  addis r10, r30, 2
	ctx.r[10].s64 = ctx.r[30].s64 + 131072;
	// 822E2968: 3D6B0002  addis r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 131072;
	// 822E296C: 394AD808  addi r10, r10, -0x27f8
	ctx.r[10].s64 = ctx.r[10].s64 + -10232;
	// 822E2970: 396BD8CC  addi r11, r11, -0x2734
	ctx.r[11].s64 = ctx.r[11].s64 + -10036;
	// 822E2974: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E2978: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822E297C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822E2980: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E2984: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E2988: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x822E298C; continue 'dispatch;
            }
            0x822E298C => {
    //   block [0x822E298C..0x822E29CC)
	// 822E298C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E2990: FC00F890  fmr f0, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[31].f64;
	// 822E2994: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E2998: 616BED3A  ori r11, r11, 0xed3a
	ctx.r[11].u64 = ctx.r[11].u64 | 60730;
	// 822E299C: 3940000D  li r10, 0xd
	ctx.r[10].s64 = 13;
	// 822E29A0: 6129E2D8  ori r9, r9, 0xe2d8
	ctx.r[9].u64 = ctx.r[9].u64 | 58072;
	// 822E29A4: 7D5F5B2E  sthx r10, r31, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u16) };
	// 822E29A8: 7D7E482E  lwzx r11, r30, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E29AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E29B0: 419A001C  beq cr6, 0x822e29cc
	if ctx.cr[6].eq {
	pc = 0x822E29CC; continue 'dispatch;
	}
	// 822E29B4: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E29B8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E29BC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822E29C0: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822E29C4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E29C8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	pc = 0x822E29CC; continue 'dispatch;
            }
            0x822E29CC => {
    //   block [0x822E29CC..0x822E29F0)
	// 822E29CC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E29D0: 616BEDCE  ori r11, r11, 0xedce
	ctx.r[11].u64 = ctx.r[11].u64 | 60878;
	// 822E29D4: 7D7F5A2E  lhzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E29D8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E29DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E29E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E29E4: 4098000C  bge cr6, 0x822e29f0
	if !ctx.cr[6].lt {
	pc = 0x822E29F0; continue 'dispatch;
	}
	// 822E29E8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822E29EC: 48000010  b 0x822e29fc
	pc = 0x822E29FC; continue 'dispatch;
            }
            0x822E29F0 => {
    //   block [0x822E29F0..0x822E29FC)
	// 822E29F0: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 822E29F4: 41980008  blt cr6, 0x822e29fc
	if ctx.cr[6].lt {
	pc = 0x822E29FC; continue 'dispatch;
	}
	// 822E29F8: 39600013  li r11, 0x13
	ctx.r[11].s64 = 19;
	pc = 0x822E29FC; continue 'dispatch;
            }
            0x822E29FC => {
    //   block [0x822E29FC..0x822E2A9C)
	// 822E29FC: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E2A00: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E2A04: 6149E330  ori r9, r10, 0xe330
	ctx.r[9].u64 = ctx.r[10].u64 | 58160;
	// 822E2A08: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 822E2A0C: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 822E2A10: 394AD808  addi r10, r10, -0x27f8
	ctx.r[10].s64 = ctx.r[10].s64 + -10232;
	// 822E2A14: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 822E2A18: 7D3F482E  lwzx r9, r31, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E2A1C: 3CA00001  lis r5, 1
	ctx.r[5].s64 = 65536;
	// 822E2A20: 60E7D398  ori r7, r7, 0xd398
	ctx.r[7].u64 = ctx.r[7].u64 | 54168;
	// 822E2A24: 55292036  slwi r9, r9, 4
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E2A28: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E2A2C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E2A30: 60C6D38C  ori r6, r6, 0xd38c
	ctx.r[6].u64 = ctx.r[6].u64 | 54156;
	// 822E2A34: 616AD384  ori r10, r11, 0xd384
	ctx.r[10].u64 = ctx.r[11].u64 | 54148;
	// 822E2A38: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E2A3C: 60A5D388  ori r5, r5, 0xd388
	ctx.r[5].u64 = ctx.r[5].u64 | 54152;
	// 822E2A40: 616B94D4  ori r11, r11, 0x94d4
	ctx.r[11].u64 = ctx.r[11].u64 | 38100;
	// 822E2A44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E2A48: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E2A4C: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 822E2A50: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 822E2A54: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E2A58: 6108D390  ori r8, r8, 0xd390
	ctx.r[8].u64 = ctx.r[8].u64 | 54160;
	// 822E2A5C: 6129D394  ori r9, r9, 0xd394
	ctx.r[9].u64 = ctx.r[9].u64 | 54164;
	// 822E2A60: C18B0048  lfs f12, 0x48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E2A64: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E2A68: 7DBF3D2E  stfsx f13, r31, r7
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 822E2A6C: 7FFF452E  stfsx f31, r31, r8
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 822E2A70: 7FFF4D2E  stfsx f31, r31, r9
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 822E2A74: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E2A78: 7C1F352E  stfsx f0, r31, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 822E2A7C: 7C1F2D2E  stfsx f0, r31, r5
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 822E2A80: 7C1F552E  stfsx f0, r31, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 822E2A84: 4BE5A8DD  bl 0x8213d360
	ctx.lr = 0x822E2A88;
	sub_8213D360(ctx, base);
	// 822E2A88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E2A8C: 4BE5A8D5  bl 0x8213d360
	ctx.lr = 0x822E2A90;
	sub_8213D360(ctx, base);
	// 822E2A90: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 822E2A94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E2A98: 4BE5A9A1  bl 0x8213d438
	ctx.lr = 0x822E2A9C;
	sub_8213D438(ctx, base);
	pc = 0x822E2A9C; continue 'dispatch;
            }
            0x822E2A9C => {
    //   block [0x822E2A9C..0x822E2AA8)
	// 822E2A9C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822E2AA0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822E2AA4: 48252668  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E2AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E2AA8 size=216
    let mut pc: u32 = 0x822E2AA8;
    'dispatch: loop {
        match pc {
            0x822E2AA8 => {
    //   block [0x822E2AA8..0x822E2ADC)
	// 822E2AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E2AAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E2AB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E2AB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E2AB8: 1D640458  mulli r11, r4, 0x458
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E2ABC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E2AC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E2AC4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 822E2AC8: 3C8B0002  addis r4, r11, 2
	ctx.r[4].s64 = ctx.r[11].s64 + 131072;
	// 822E2ACC: 3884EEC8  addi r4, r4, -0x1138
	ctx.r[4].s64 = ctx.r[4].s64 + -4408;
	// 822E2AD0: A1640048  lhz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 822E2AD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E2AD8: 409A001C  bne cr6, 0x822e2af4
	if !ctx.cr[6].eq {
	pc = 0x822E2AF4; continue 'dispatch;
	}
	pc = 0x822E2ADC; continue 'dispatch;
            }
            0x822E2ADC => {
    //   block [0x822E2ADC..0x822E2AF4)
	// 822E2ADC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E2AE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E2AE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E2AE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E2AEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E2AF0: 4E800020  blr
	return;
            }
            0x822E2AF4 => {
    //   block [0x822E2AF4..0x822E2B30)
	// 822E2AF4: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E2AF8: 816BA8F8  lwz r11, -0x5708(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22280 as u32) ) } as u64;
	// 822E2AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E2B00: 409AFFDC  bne cr6, 0x822e2adc
	if !ctx.cr[6].eq {
	pc = 0x822E2ADC; continue 'dispatch;
	}
	// 822E2B04: A1640002  lhz r11, 2(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E2B08: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E2B0C: 419A005C  beq cr6, 0x822e2b68
	if ctx.cr[6].eq {
	pc = 0x822E2B68; continue 'dispatch;
	}
	// 822E2B10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E2B14: 4BE5921D  bl 0x8213bd30
	ctx.lr = 0x822E2B18;
	sub_8213BD30(ctx, base);
	// 822E2B18: 48000069  bl 0x822e2b80
	ctx.lr = 0x822E2B1C;
	sub_822E2B80(ctx, base);
	// 822E2B1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E2B20: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822E2B24: 390400D0  addi r8, r4, 0xd0
	ctx.r[8].s64 = ctx.r[4].s64 + 208;
	// 822E2B28: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 822E2B2C: C12B1FF8  lfs f9, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	pc = 0x822E2B30; continue 'dispatch;
            }
            0x822E2B30 => {
    //   block [0x822E2B30..0x822E2B54)
	// 822E2B30: 80A80000  lwz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E2B34: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 822E2B38: 419A0020  beq cr6, 0x822e2b58
	if ctx.cr[6].eq {
	pc = 0x822E2B58; continue 'dispatch;
	}
	// 822E2B3C: A1650002  lhz r11, 2(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E2B40: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E2B44: 419A0010  beq cr6, 0x822e2b54
	if ctx.cr[6].eq {
	pc = 0x822E2B54; continue 'dispatch;
	}
	// 822E2B48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E2B4C: 480002ED  bl 0x822e2e38
	ctx.lr = 0x822E2B50;
	sub_822E2E38(ctx, base);
	// 822E2B50: 48000008  b 0x822e2b58
	pc = 0x822E2B58; continue 'dispatch;
            }
            0x822E2B54 => {
    //   block [0x822E2B54..0x822E2B58)
	// 822E2B54: D1250020  stfs f9, 0x20(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(32 as u32), tmp.u32 ) };
	pc = 0x822E2B58; continue 'dispatch;
            }
            0x822E2B58 => {
    //   block [0x822E2B58..0x822E2B68)
	// 822E2B58: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 822E2B5C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 822E2B60: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822E2B64: 409AFFCC  bne cr6, 0x822e2b30
	if !ctx.cr[6].eq {
	pc = 0x822E2B30; continue 'dispatch;
	}
	pc = 0x822E2B68; continue 'dispatch;
            }
            0x822E2B68 => {
    //   block [0x822E2B68..0x822E2B80)
	// 822E2B68: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 822E2B6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E2B70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E2B74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E2B78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E2B7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E2B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E2B80 size=692
    let mut pc: u32 = 0x822E2B80;
    'dispatch: loop {
        match pc {
            0x822E2B80 => {
    //   block [0x822E2B80..0x822E2BE8)
	// 822E2B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E2B84: 48252535  bl 0x825350b8
	ctx.lr = 0x822E2B88;
	sub_82535080(ctx, base);
	// 822E2B88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E2B8C: C0E40008  lfs f7, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822E2B90: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822E2B94: C0A40040  lfs f5, 0x40(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 822E2B98: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E2B9C: C1040010  lfs f8, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822E2BA0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 822E2BA4: D0E4000C  stfs f7, 0xc(r4)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822E2BA8: 3CA30002  addis r5, r3, 2
	ctx.r[5].s64 = ctx.r[3].s64 + 131072;
	// 822E2BAC: FC603890  fmr f3, f7
	ctx.f[3].f64 = ctx.f[7].f64;
	// 822E2BB0: C14B1FF8  lfs f10, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E2BB4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E2BB8: 3FE30002  addis r31, r3, 2
	ctx.r[31].s64 = ctx.r[3].s64 + 131072;
	// 822E2BBC: C0C9BA38  lfs f6, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822E2BC0: 38CBBFF0  addi r6, r11, -0x4010
	ctx.r[6].s64 = ctx.r[11].s64 + -16400;
	// 822E2BC4: C04A2068  lfs f2, 0x2068(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8296 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822E2BC8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E2BCC: FC805090  fmr f4, f10
	ctx.f[4].f64 = ctx.f[10].f64;
	// 822E2BD0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 822E2BD4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 822E2BD8: 38A5D3A4  addi r5, r5, -0x2c5c
	ctx.r[5].s64 = ctx.r[5].s64 + -11356;
	// 822E2BDC: 3BFFBE64  addi r31, r31, -0x419c
	ctx.r[31].s64 = ctx.r[31].s64 + -16796;
	// 822E2BE0: 617DEB1C  ori r29, r11, 0xeb1c
	ctx.r[29].u64 = ctx.r[11].u64 | 60188;
	// 822E2BE4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x822E2BE8; continue 'dispatch;
            }
            0x822E2BE8 => {
    //   block [0x822E2BE8..0x822E2C28)
	// 822E2BE8: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E2BEC: FF055000  fcmpu cr6, f5, f10
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[10].f64);
	// 822E2BF0: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 822E2BF4: 7DA65C2E  lfsx f13, r6, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E2BF8: 40990030  ble cr6, 0x822e2c28
	if !ctx.cr[6].gt {
	pc = 0x822E2C28; continue 'dispatch;
	}
	// 822E2BFC: EC053028  fsubs f0, f5, f6
	ctx.f[0].f64 = (((ctx.f[5].f64 - ctx.f[6].f64) as f32) as f64);
	// 822E2C00: C1840030  lfs f12, 0x30(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E2C04: C1640038  lfs f11, 0x38(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E2C08: EDAB637A  fmadds f13, f11, f13, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 822E2C0C: D0040040  stfs f0, 0x40(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E2C10: D1A40030  stfs f13, 0x30(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 822E2C14: FCA00090  fmr f5, f0
	ctx.f[5].f64 = ctx.f[0].f64;
	// 822E2C18: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 822E2C1C: 41990030  bgt cr6, 0x822e2c4c
	if ctx.cr[6].gt {
	pc = 0x822E2C4C; continue 'dispatch;
	}
	// 822E2C20: C0040034  lfs f0, 0x34(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E2C24: 48000024  b 0x822e2c48
	pc = 0x822E2C48; continue 'dispatch;
            }
            0x822E2C28 => {
    //   block [0x822E2C28..0x822E2C48)
	// 822E2C28: C184003C  lfs f12, 0x3c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E2C2C: FF0C5000  fcmpu cr6, f12, f10
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[10].f64);
	// 822E2C30: 4099001C  ble cr6, 0x822e2c4c
	if !ctx.cr[6].gt {
	pc = 0x822E2C4C; continue 'dispatch;
	}
	// 822E2C34: C0040030  lfs f0, 0x30(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E2C38: C1640034  lfs f11, 0x34(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E2C3C: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E2C40: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 822E2C44: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	pc = 0x822E2C48; continue 'dispatch;
            }
            0x822E2C48 => {
    //   block [0x822E2C48..0x822E2C4C)
	// 822E2C48: D0040030  stfs f0, 0x30(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(48 as u32), tmp.u32 ) };
	pc = 0x822E2C4C; continue 'dispatch;
            }
            0x822E2C4C => {
    //   block [0x822E2C4C..0x822E2C98)
	// 822E2C4C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E2C50: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E2C54: C0040030  lfs f0, 0x30(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E2C58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E2C5C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E2C60: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E2C64: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 822E2C68: 7DA65C2E  lfsx f13, r6, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E2C6C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E2C70: 419A0028  beq cr6, 0x822e2c98
	if ctx.cr[6].eq {
	pc = 0x822E2C98; continue 'dispatch;
	}
	// 822E2C74: 7D63E8AE  lbzx r11, r3, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 822E2C78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E2C7C: 419A001C  beq cr6, 0x822e2c98
	if ctx.cr[6].eq {
	pc = 0x822E2C98; continue 'dispatch;
	}
	// 822E2C80: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E2C84: 616B94D0  ori r11, r11, 0x94d0
	ctx.r[11].u64 = ctx.r[11].u64 | 38096;
	// 822E2C88: 7D66582E  lwzx r11, r6, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E2C8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E2C90: 409A0008  bne cr6, 0x822e2c98
	if !ctx.cr[6].eq {
	pc = 0x822E2C98; continue 'dispatch;
	}
	// 822E2C94: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	pc = 0x822E2C98; continue 'dispatch;
            }
            0x822E2C98 => {
    //   block [0x822E2C98..0x822E2CEC)
	// 822E2C98: ED87002A  fadds f12, f7, f0
	ctx.f[12].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 822E2C9C: 550A063E  clrlwi r10, r8, 0x18
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 822E2CA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E2CA4: ED2C002A  fadds f9, f12, f0
	ctx.f[9].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 822E2CA8: 419A009C  beq cr6, 0x822e2d44
	if ctx.cr[6].eq {
	pc = 0x822E2D44; continue 'dispatch;
	}
	// 822E2CAC: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E2CB0: ED686028  fsubs f11, f8, f12
	ctx.f[11].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 822E2CB4: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 822E2CB8: 7DA65C2E  lfsx f13, r6, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E2CBC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E2CC0: ED6B0024  fdivs f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 822E2CC4: FC006E5E  fctidz f0, f13
	ctx.f[0].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 822E2CC8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E2CCC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E2CD0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E2CD4: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 822E2CD8: 40990014  ble cr6, 0x822e2cec
	if !ctx.cr[6].gt {
	pc = 0x822E2CEC; continue 'dispatch;
	}
	// 822E2CDC: FF0B1000  fcmpu cr6, f11, f2
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[2].f64);
	// 822E2CE0: 4198000C  blt cr6, 0x822e2cec
	if ctx.cr[6].lt {
	pc = 0x822E2CEC; continue 'dispatch;
	}
	// 822E2CE4: EC0B3028  fsubs f0, f11, f6
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 822E2CE8: EC8A0024  fdivs f4, f10, f0
	ctx.f[4].f64 = ((ctx.f[10].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x822E2CEC; continue 'dispatch;
            }
            0x822E2CEC => {
    //   block [0x822E2CEC..0x822E2D1C)
	// 822E2CEC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 822E2CF0: FF045000  fcmpu cr6, f4, f10
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[10].f64);
	// 822E2CF4: 419A002C  beq cr6, 0x822e2d20
	if ctx.cr[6].eq {
	pc = 0x822E2D20; continue 'dispatch;
	}
	// 822E2CF8: C004044C  lfs f0, 0x44c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(1100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E2CFC: EC00202A  fadds f0, f0, f4
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[4].f64) as f32) as f64;
	// 822E2D00: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 822E2D04: 41980018  blt cr6, 0x822e2d1c
	if ctx.cr[6].lt {
	pc = 0x822E2D1C; continue 'dispatch;
	}
	// 822E2D08: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 822E2D0C: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 822E2D10: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E2D14: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E2D18: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x822E2D1C; continue 'dispatch;
            }
            0x822E2D1C => {
    //   block [0x822E2D1C..0x822E2D20)
	// 822E2D1C: D004044C  stfs f0, 0x44c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(1100 as u32), tmp.u32 ) };
	pc = 0x822E2D20; continue 'dispatch;
            }
            0x822E2D20 => {
    //   block [0x822E2D20..0x822E2D44)
	// 822E2D20: 3961FFCC  addi r11, r1, -0x34
	ctx.r[11].s64 = ctx.r[1].s64 + -52;
	// 822E2D24: FC00581E  fctiwz f0, f11
	ctx.f[0].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 822E2D28: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822E2D2C: 8161FFCC  lwz r11, -0x34(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-52 as u32) ) } as u64;
	// 822E2D30: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822E2D34: 40990010  ble cr6, 0x822e2d44
	if !ctx.cr[6].gt {
	pc = 0x822E2D44; continue 'dispatch;
	}
	// 822E2D38: 352BFFFE  addic. r9, r11, -2
	ctx.xer.ca = (ctx.r[11].u32 > (!(-2 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + -2;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822E2D3C: 41810008  bgt 0x822e2d44
	if ctx.cr[0].gt {
	pc = 0x822E2D44; continue 'dispatch;
	}
	// 822E2D40: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	pc = 0x822E2D44; continue 'dispatch;
            }
            0x822E2D44 => {
    //   block [0x822E2D44..0x822E2D60)
	// 822E2D44: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 822E2D48: FF074000  fcmpu cr6, f7, f8
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[8].f64);
	// 822E2D4C: 40980014  bge cr6, 0x822e2d60
	if !ctx.cr[6].lt {
	pc = 0x822E2D60; continue 'dispatch;
	}
	// 822E2D50: FF094000  fcmpu cr6, f9, f8
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[8].f64);
	// 822E2D54: 4099000C  ble cr6, 0x822e2d60
	if !ctx.cr[6].gt {
	pc = 0x822E2D60; continue 'dispatch;
	}
	// 822E2D58: FD804090  fmr f12, f8
	ctx.f[12].f64 = ctx.f[8].f64;
	// 822E2D5C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x822E2D60; continue 'dispatch;
            }
            0x822E2D60 => {
    //   block [0x822E2D60..0x822E2DA0)
	// 822E2D60: 3961FFC0  addi r11, r1, -0x40
	ctx.r[11].s64 = ctx.r[1].s64 + -64;
	// 822E2D64: FC00601E  fctiwz f0, f12
	ctx.f[0].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 822E2D68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E2D6C: FDA0181E  fctiwz f13, f3
	ctx.f[13].s64 = if ctx.f[3].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[3].f64.trunc() as i32 as i64 };
	// 822E2D70: D1840008  stfs f12, 8(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E2D74: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822E2D78: 8141FFC0  lwz r10, -0x40(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) } as u64;
	// 822E2D7C: 3961FFC4  addi r11, r1, -0x3c
	ctx.r[11].s64 = ctx.r[1].s64 + -60;
	// 822E2D80: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822E2D84: 8161FFC4  lwz r11, -0x3c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-60 as u32) ) } as u64;
	// 822E2D88: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822E2D8C: B164001C  sth r11, 0x1c(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), ctx.r[11].u16 ) };
	// 822E2D90: 419A0010  beq cr6, 0x822e2da0
	if ctx.cr[6].eq {
	pc = 0x822E2DA0; continue 'dispatch;
	}
	// 822E2D94: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E2D98: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E2D9C: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x822E2DA0; continue 'dispatch;
            }
            0x822E2DA0 => {
    //   block [0x822E2DA0..0x822E2DF0)
	// 822E2DA0: 81640448  lwz r11, 0x448(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(1096 as u32) ) } as u64;
	// 822E2DA4: FCE06090  fmr f7, f12
	ctx.f[7].f64 = ctx.f[12].f64;
	// 822E2DA8: FF0C4000  fcmpu cr6, f12, f8
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[8].f64);
	// 822E2DAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E2DB0: 91640448  stw r11, 0x448(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(1096 as u32), ctx.r[11].u32 ) };
	// 822E2DB4: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E2DB8: 616B85E4  ori r11, r11, 0x85e4
	ctx.r[11].u64 = ctx.r[11].u64 | 34276;
	// 822E2DBC: 4199004C  bgt cr6, 0x822e2e08
	if ctx.cr[6].gt {
	pc = 0x822E2E08; continue 'dispatch;
	}
	// 822E2DC0: 7D66582E  lwzx r11, r6, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E2DC4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822E2DC8: 419A0028  beq cr6, 0x822e2df0
	if ctx.cr[6].eq {
	pc = 0x822E2DF0; continue 'dispatch;
	}
	// 822E2DCC: 3961FFC8  addi r11, r1, -0x38
	ctx.r[11].s64 = ctx.r[1].s64 + -56;
	// 822E2DD0: FC00181E  fctiwz f0, f3
	ctx.f[0].s64 = if ctx.f[3].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[3].f64.trunc() as i32 as i64 };
	// 822E2DD4: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822E2DD8: 8161FFC8  lwz r11, -0x38(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) } as u64;
	// 822E2DDC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822E2DE0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822E2DE4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822E2DE8: B164001A  sth r11, 0x1a(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(26 as u32), ctx.r[11].u16 ) };
	// 822E2DEC: 48000008  b 0x822e2df4
	pc = 0x822E2DF4; continue 'dispatch;
            }
            0x822E2DF0 => {
    //   block [0x822E2DF0..0x822E2DF4)
	// 822E2DF0: B3C4001A  sth r30, 0x1a(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(26 as u32), ctx.r[30].u16 ) };
	pc = 0x822E2DF4; continue 'dispatch;
            }
            0x822E2DF4 => {
    //   block [0x822E2DF4..0x822E2E08)
	// 822E2DF4: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 822E2DF8: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 822E2DFC: 4199FDEC  bgt cr6, 0x822e2be8
	if ctx.cr[6].gt {
	pc = 0x822E2BE8; continue 'dispatch;
	}
	// 822E2E00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E2E04: 48252304  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x822E2E08 => {
    //   block [0x822E2E08..0x822E2E28)
	// 822E2E08: D1040008  stfs f8, 8(r4)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E2E0C: B3840024  sth r28, 0x24(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(36 as u32), ctx.r[28].u16 ) };
	// 822E2E10: 7D66582E  lwzx r11, r6, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E2E14: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822E2E18: 409A0010  bne cr6, 0x822e2e28
	if !ctx.cr[6].eq {
	pc = 0x822E2E28; continue 'dispatch;
	}
	// 822E2E1C: B3C4001A  sth r30, 0x1a(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(26 as u32), ctx.r[30].u16 ) };
	// 822E2E20: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E2E24: 482522E4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x822E2E28 => {
    //   block [0x822E2E28..0x822E2E34)
	// 822E2E28: B384001A  sth r28, 0x1a(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(26 as u32), ctx.r[28].u16 ) };
	// 822E2E2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E2E30: 482522D8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E2E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E2E38 size=228
    let mut pc: u32 = 0x822E2E38;
    'dispatch: loop {
        match pc {
            0x822E2E38 => {
    //   block [0x822E2E38..0x822E2E90)
	// 822E2E38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E2E3C: C0050050  lfs f0, 0x50(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E2E40: C1650020  lfs f11, 0x20(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E2E44: D1650038  stfs f11, 0x38(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 822E2E48: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E2E4C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822E2E50: 40990040  ble cr6, 0x822e2e90
	if !ctx.cr[6].gt {
	pc = 0x822E2E90; continue 'dispatch;
	}
	// 822E2E54: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E2E58: C1850040  lfs f12, 0x40(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E2E5C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 822E2E60: C1450048  lfs f10, 0x48(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E2E64: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 822E2E68: ED8A602A  fadds f12, f10, f12
	ctx.f[12].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 822E2E6C: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 822E2E70: D1850040  stfs f12, 0x40(r5)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E2E74: 7D8B542E  lfsx f12, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E2E78: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 822E2E7C: D0050050  stfs f0, 0x50(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822E2E80: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822E2E84: 4199002C  bgt cr6, 0x822e2eb0
	if ctx.cr[6].gt {
	pc = 0x822E2EB0; continue 'dispatch;
	}
	// 822E2E88: C0050044  lfs f0, 0x44(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E2E8C: 48000020  b 0x822e2eac
	pc = 0x822E2EAC; continue 'dispatch;
            }
            0x822E2E90 => {
    //   block [0x822E2E90..0x822E2EAC)
	// 822E2E90: C185004C  lfs f12, 0x4c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E2E94: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 822E2E98: 40990018  ble cr6, 0x822e2eb0
	if !ctx.cr[6].gt {
	pc = 0x822E2EB0; continue 'dispatch;
	}
	// 822E2E9C: C0050040  lfs f0, 0x40(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E2EA0: C1A50044  lfs f13, 0x44(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E2EA4: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E2EA8: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	pc = 0x822E2EAC; continue 'dispatch;
            }
            0x822E2EAC => {
    //   block [0x822E2EAC..0x822E2EB0)
	// 822E2EAC: D0050040  stfs f0, 0x40(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(64 as u32), tmp.u32 ) };
	pc = 0x822E2EB0; continue 'dispatch;
            }
            0x822E2EB0 => {
    //   block [0x822E2EB0..0x822E2F1C)
	// 822E2EB0: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E2EB4: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E2EB8: 3D200005  lis r9, 5
	ctx.r[9].s64 = 327680;
	// 822E2EBC: C0050040  lfs f0, 0x40(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E2EC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E2EC4: C1A5002C  lfs f13, 0x2c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E2EC8: 614AD3A4  ori r10, r10, 0xd3a4
	ctx.r[10].u64 = ctx.r[10].u64 | 54180;
	// 822E2ECC: 61297DE8  ori r9, r9, 0x7de8
	ctx.r[9].u64 = ctx.r[9].u64 | 32232;
	// 822E2ED0: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822E2ED4: C1440030  lfs f10, 0x30(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E2ED8: 7D83542E  lfsx f12, r3, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E2EDC: ED8C02B2  fmuls f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[10].f64) as f32) as f64);
	// 822E2EE0: 7D434C2E  lfsx f10, r3, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E2EE4: ED8C02B2  fmuls f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[10].f64) as f32) as f64);
	// 822E2EE8: EC0C583A  fmadds f0, f12, f0, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 822E2EEC: D0050020  stfs f0, 0x20(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822E2EF0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822E2EF4: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 822E2EF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E2EFC: A1450008  lhz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E2F00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E2F04: B165000A  sth r11, 0xa(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(10 as u32), ctx.r[11].u16 ) };
	// 822E2F08: 419A0014  beq cr6, 0x822e2f1c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x822E2F1C);
		return;
	}
	// 822E2F0C: C1A50030  lfs f13, 0x30(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E2F10: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E2F14: D0050020  stfs f0, 0x20(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822E2F18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E2F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E2F28 size=72
    let mut pc: u32 = 0x822E2F28;
    'dispatch: loop {
        match pc {
            0x822E2F28 => {
    //   block [0x822E2F28..0x822E2F70)
	// 822E2F28: 1D640458  mulli r11, r4, 0x458
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E2F2C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822E2F30: 3D6B0002  addis r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 131072;
	// 822E2F34: 396BEEC8  addi r11, r11, -0x1138
	ctx.r[11].s64 = ctx.r[11].s64 + -4408;
	// 822E2F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E2F3C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822E2F40: A14B0002  lhz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E2F44: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 822E2F48: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822E2F4C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E2F50: D02B0034  stfs f1, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 822E2F54: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 822E2F58: C1AA1FF8  lfs f13, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E2F5C: 41990014  bgt cr6, 0x822e2f70
	if ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x822E2F70);
		return;
	}
	// 822E2F60: D02B0030  stfs f1, 0x30(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 822E2F64: D1AB0040  stfs f13, 0x40(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E2F68: D1AB003C  stfs f13, 0x3c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 822E2F6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E2FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E2FA0 size=72
    let mut pc: u32 = 0x822E2FA0;
    'dispatch: loop {
        match pc {
            0x822E2FA0 => {
    //   block [0x822E2FA0..0x822E2FE8)
	// 822E2FA0: 1D6400B0  mulli r11, r4, 0xb0
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 176 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E2FA4: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822E2FA8: 3D6B0002  addis r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 131072;
	// 822E2FAC: 396BF780  addi r11, r11, -0x880
	ctx.r[11].s64 = ctx.r[11].s64 + -2176;
	// 822E2FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E2FB4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822E2FB8: A14B0002  lhz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E2FBC: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 822E2FC0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822E2FC4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E2FC8: D02B0044  stfs f1, 0x44(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 822E2FCC: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 822E2FD0: C1AA1FF8  lfs f13, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E2FD4: 41990014  bgt cr6, 0x822e2fe8
	if ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x822E2FE8);
		return;
	}
	// 822E2FD8: D02B0040  stfs f1, 0x40(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E2FDC: D1AB0050  stfs f13, 0x50(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822E2FE0: D1AB004C  stfs f13, 0x4c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 822E2FE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E3018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E3018 size=40
    let mut pc: u32 = 0x822E3018;
    'dispatch: loop {
        match pc {
            0x822E3018 => {
    //   block [0x822E3018..0x822E3040)
	// 822E3018: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E301C: 2F056000  cmpwi cr6, r5, 0x6000
	ctx.cr[6].compare_i32(ctx.r[5].s32, 24576, &mut ctx.xer);
	// 822E3020: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E3024: 4098001C  bge cr6, 0x822e3040
	if !ctx.cr[6].lt {
		sub_822E3040(ctx, base);
		return;
	}
	// 822E3028: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
	// 822E302C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 822E3030: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E3034: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E3038: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E303C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E3040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E3040 size=356
    let mut pc: u32 = 0x822E3040;
    'dispatch: loop {
        match pc {
            0x822E3040 => {
    //   block [0x822E3040..0x822E3064)
	// 822E3040: 2F056C00  cmpwi cr6, r5, 0x6c00
	ctx.cr[6].compare_i32(ctx.r[5].s32, 27648, &mut ctx.xer);
	// 822E3044: 41990020  bgt cr6, 0x822e3064
	if ctx.cr[6].gt {
	pc = 0x822E3064; continue 'dispatch;
	}
	// 822E3048: A1640000  lhz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E304C: 38A51000  addi r5, r5, 0x1000
	ctx.r[5].s64 = ctx.r[5].s64 + 4096;
	// 822E3050: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E3054: 1D6B0458  mulli r11, r11, 0x458
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E3058: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 822E305C: 3C8B0002  addis r4, r11, 2
	ctx.r[4].s64 = ctx.r[11].s64 + 131072;
	// 822E3060: 3884F320  addi r4, r4, -0xce0
	ctx.r[4].s64 = ctx.r[4].s64 + -3296;
	pc = 0x822E3064; continue 'dispatch;
            }
            0x822E3064 => {
    //   block [0x822E3064..0x822E30AC)
	// 822E3064: 39650100  addi r11, r5, 0x100
	ctx.r[11].s64 = ctx.r[5].s64 + 256;
	// 822E3068: 7D6B4E70  srawi r11, r11, 9
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 9) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 9) as i64;
	// 822E306C: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 822E3070: 396BFFC6  addi r11, r11, -0x3a
	ctx.r[11].s64 = ctx.r[11].s64 + -58;
	// 822E3074: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 822E3078: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
	// 822E307C: 3D80822E  lis r12, -0x7dd2
	ctx.r[12].s64 = -2110914560;
	// 822E3080: 398C3094  addi r12, r12, 0x3094
	ctx.r[12].s64 = ctx.r[12].s64 + 12436;
	// 822E3084: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 822E3088: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 822E308C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 822E3090: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x822E30DC; continue 'dispatch;
		},
		1 => {
	pc = 0x822E3100; continue 'dispatch;
		},
		2 => {
	pc = 0x822E3124; continue 'dispatch;
		},
		3 => {
	pc = 0x822E30AC; continue 'dispatch;
		},
		4 => {
	pc = 0x822E314C; continue 'dispatch;
		},
		5 => {
	pc = 0x822E3178; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 822E3094: 822E30DC  lwz r17, 0x30dc(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(12508 as u32) ) } as u64;
	// 822E3098: 822E3100  lwz r17, 0x3100(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(12544 as u32) ) } as u64;
	// 822E309C: 822E3124  lwz r17, 0x3124(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(12580 as u32) ) } as u64;
	// 822E30A0: 822E30AC  lwz r17, 0x30ac(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(12460 as u32) ) } as u64;
	// 822E30A4: 822E314C  lwz r17, 0x314c(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(12620 as u32) ) } as u64;
	// 822E30A8: 822E3178  lwz r17, 0x3178(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(12664 as u32) ) } as u64;
            }
            0x822E30AC => {
    //   block [0x822E30AC..0x822E30DC)
	// 822E30AC: 39458600  addi r10, r5, -0x7a00
	ctx.r[10].s64 = ctx.r[5].s64 + -31232;
	// 822E30B0: 816400D0  lwz r11, 0xd0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E30B4: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822E30B8: C1AB0020  lfs f13, 0x20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E30BC: C00B0024  lfs f0, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E30C0: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 822E30C4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E30C8: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E30CC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E30D0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E30D4: EC20682A  fadds f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 822E30D8: 4E800020  blr
	return;
            }
            0x822E30DC => {
    //   block [0x822E30DC..0x822E3100)
	// 822E30DC: 39658C00  addi r11, r5, -0x7400
	ctx.r[11].s64 = ctx.r[5].s64 + -29696;
	// 822E30E0: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E30E4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E30E8: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 822E30EC: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E30F0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E30F4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E30F8: EC2D002A  fadds f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 822E30FC: 4E800020  blr
	return;
            }
            0x822E3100 => {
    //   block [0x822E3100..0x822E3124)
	// 822E3100: 39658A00  addi r11, r5, -0x7600
	ctx.r[11].s64 = ctx.r[5].s64 + -30208;
	// 822E3104: C0040010  lfs f0, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E3108: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E310C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 822E3110: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E3114: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E3118: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E311C: EC2D002A  fadds f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 822E3120: 4E800020  blr
	return;
            }
            0x822E3124 => {
    //   block [0x822E3124..0x822E314C)
	// 822E3124: 39658800  addi r11, r5, -0x7800
	ctx.r[11].s64 = ctx.r[5].s64 + -30720;
	// 822E3128: 814400D0  lwz r10, 0xd0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E312C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E3130: C00A0020  lfs f0, 0x20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E3134: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 822E3138: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E313C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E3140: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E3144: EC2D002A  fadds f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 822E3148: 4E800020  blr
	return;
            }
            0x822E314C => {
    //   block [0x822E314C..0x822E3178)
	// 822E314C: 39658400  addi r11, r5, -0x7c00
	ctx.r[11].s64 = ctx.r[5].s64 + -31744;
	// 822E3150: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E3154: C0040030  lfs f0, 0x30(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E3158: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E315C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 822E3160: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 822E3164: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E3168: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E316C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E3170: EC20682A  fadds f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 822E3174: 4E800020  blr
	return;
            }
            0x822E3178 => {
    //   block [0x822E3178..0x822E31A4)
	// 822E3178: 39658200  addi r11, r5, -0x7e00
	ctx.r[11].s64 = ctx.r[5].s64 + -32256;
	// 822E317C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E3180: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E3184: 614AE320  ori r10, r10, 0xe320
	ctx.r[10].u64 = ctx.r[10].u64 | 58144;
	// 822E3188: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 822E318C: 7C03542E  lfsx f0, r3, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E3190: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E3194: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E3198: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E319C: EC2D002A  fadds f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 822E31A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E31A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E31A8 size=472
    let mut pc: u32 = 0x822E31A8;
    'dispatch: loop {
        match pc {
            0x822E31A8 => {
    //   block [0x822E31A8..0x822E3204)
	// 822E31A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E31AC: 48251F0D  bl 0x825350b8
	ctx.lr = 0x822E31B0;
	sub_82535080(ctx, base);
	// 822E31B0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822E31B4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E31B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E31BC: FDA00890  fmr f13, f1
	ctx.f[13].f64 = ctx.f[1].f64;
	// 822E31C0: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 822E31C4: 2F05FFFF  cmpwi cr6, r5, -1
	ctx.cr[6].compare_i32(ctx.r[5].s32, -1, &mut ctx.xer);
	// 822E31C8: B0BF0002  sth r5, 2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[5].u16 ) };
	// 822E31CC: 419A01A4  beq cr6, 0x822e3370
	if ctx.cr[6].eq {
	pc = 0x822E3370; continue 'dispatch;
	}
	// 822E31D0: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E31D4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822E31D8: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 822E31DC: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 822E31E0: 1D6400B0  mulli r11, r4, 0xb0
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 176 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E31E4: 7FAB1A14  add r29, r11, r3
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822E31E8: 3FDD0006  addis r30, r29, 6
	ctx.r[30].s64 = ctx.r[29].s64 + 393216;
	// 822E31EC: 3BDE8830  addi r30, r30, -0x77d0
	ctx.r[30].s64 = ctx.r[30].s64 + -30672;
	// 822E31F0: 4BE43D29  bl 0x82126f18
	ctx.lr = 0x822E31F4;
	sub_82126F18(ctx, base);
	// 822E31F4: 54AB057E  clrlwi r11, r5, 0x15
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000007FFu64;
	// 822E31F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E31FC: 40980008  bge cr6, 0x822e3204
	if !ctx.cr[6].lt {
	pc = 0x822E3204; continue 'dispatch;
	}
	// 822E3200: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x822E3204; continue 'dispatch;
            }
            0x822E3204 => {
    //   block [0x822E3204..0x822E3248)
	// 822E3204: 392B0002  addi r9, r11, 2
	ctx.r[9].s64 = ctx.r[11].s64 + 2;
	// 822E3208: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E320C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E3210: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E3214: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E3218: FF04F800  fcmpu cr6, f4, f31
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[31].f64);
	// 822E321C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E3220: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E3224: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E3228: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822E322C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E3230: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E3234: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E3238: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822E323C: 4099000C  ble cr6, 0x822e3248
	if !ctx.cr[6].gt {
	pc = 0x822E3248; continue 'dispatch;
	}
	// 822E3240: ED802028  fsubs f12, f0, f4
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[4].f64) as f32) as f64);
	// 822E3244: FC0C012E  fsel f0, f12, f4, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[4].f64 } else { ctx.f[0].f64 };
	pc = 0x822E3248; continue 'dispatch;
            }
            0x822E3248 => {
    //   block [0x822E3248..0x822E325C)
	// 822E3248: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 822E324C: FF03F800  fcmpu cr6, f3, f31
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[31].f64);
	// 822E3250: 419A000C  beq cr6, 0x822e325c
	if ctx.cr[6].eq {
	pc = 0x822E325C; continue 'dispatch;
	}
	// 822E3254: D07F0028  stfs f3, 0x28(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822E3258: 48000008  b 0x822e3260
	pc = 0x822E3260; continue 'dispatch;
            }
            0x822E325C => {
    //   block [0x822E325C..0x822E3260)
	// 822E325C: D3FF0028  stfs f31, 0x28(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	pc = 0x822E3260; continue 'dispatch;
            }
            0x822E3260 => {
    //   block [0x822E3260..0x822E32A4)
	// 822E3260: C01F0028  lfs f0, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E3264: 3D7D0002  addis r11, r29, 2
	ctx.r[11].s64 = ctx.r[29].s64 + 131072;
	// 822E3268: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 822E326C: C19F002C  lfs f12, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E3270: 396BF780  addi r11, r11, -0x880
	ctx.r[11].s64 = ctx.r[11].s64 + -2176;
	// 822E3274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E3278: FC0B07EE  fsel f0, f11, f31, f0
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[0].f64 };
	// 822E327C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E3280: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 822E3284: 419A0020  beq cr6, 0x822e32a4
	if ctx.cr[6].eq {
	pc = 0x822E32A4; continue 'dispatch;
	}
	// 822E3288: A14B0002  lhz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E328C: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 822E3290: 419A0014  beq cr6, 0x822e32a4
	if ctx.cr[6].eq {
	pc = 0x822E32A4; continue 'dispatch;
	}
	// 822E3294: D04B0040  stfs f2, 0x40(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E3298: D04B0044  stfs f2, 0x44(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 822E329C: D3EB0050  stfs f31, 0x50(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822E32A0: D3EB004C  stfs f31, 0x4c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	pc = 0x822E32A4; continue 'dispatch;
            }
            0x822E32A4 => {
    //   block [0x822E32A4..0x822E330C)
	// 822E32A4: 7CCB0734  extsh r11, r6
	ctx.r[11].s64 = ctx.r[6].s16 as i64;
	// 822E32A8: C01F0028  lfs f0, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E32AC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822E32B0: EC02017A  fmadds f0, f2, f5, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 * ctx.f[5].f64 + ctx.f[0].f64) as f32) as f64);
	// 822E32B4: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 822E32B8: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822E32BC: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822E32C0: FC206890  fmr f1, f13
	ctx.f[1].f64 = ctx.f[13].f64;
	// 822E32C4: B17F000E  sth r11, 0xe(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(14 as u32), ctx.r[11].u16 ) };
	// 822E32C8: B3BF0018  sth r29, 0x18(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u16 ) };
	// 822E32CC: 4BE43CF5  bl 0x82126fc0
	ctx.lr = 0x822E32D0;
	sub_82126FC0(ctx, base);
	// 822E32D0: 578B073E  clrlwi r11, r28, 0x1c
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x0000000Fu64;
	// 822E32D4: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 822E32D8: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 822E32DC: B17F000C  sth r11, 0xc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u16 ) };
	// 822E32E0: 419A003C  beq cr6, 0x822e331c
	if ctx.cr[6].eq {
	pc = 0x822E331C; continue 'dispatch;
	}
	// 822E32E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E32E8: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 822E32EC: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E32F0: 419A001C  beq cr6, 0x822e330c
	if ctx.cr[6].eq {
	pc = 0x822E330C; continue 'dispatch;
	}
	// 822E32F4: D01E00A8  stfs f0, 0xa8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E32F8: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 822E32FC: D01E00A0  stfs f0, 0xa0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 822E3300: 419A0024  beq cr6, 0x822e3324
	if ctx.cr[6].eq {
	pc = 0x822E3324; continue 'dispatch;
	}
	// 822E3304: D01E00A4  stfs f0, 0xa4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 822E3308: 48000020  b 0x822e3328
	pc = 0x822E3328; continue 'dispatch;
            }
            0x822E330C => {
    //   block [0x822E330C..0x822E331C)
	// 822E330C: D01E00A4  stfs f0, 0xa4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 822E3310: D3FE00A8  stfs f31, 0xa8(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E3314: D3FE00A0  stfs f31, 0xa0(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 822E3318: 48000010  b 0x822e3328
	pc = 0x822E3328; continue 'dispatch;
            }
            0x822E331C => {
    //   block [0x822E331C..0x822E3324)
	// 822E331C: D3FE00A8  stfs f31, 0xa8(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E3320: D3FE00A0  stfs f31, 0xa0(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(160 as u32), tmp.u32 ) };
	pc = 0x822E3324; continue 'dispatch;
            }
            0x822E3324 => {
    //   block [0x822E3324..0x822E3328)
	// 822E3324: D3FE00A4  stfs f31, 0xa4(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(164 as u32), tmp.u32 ) };
	pc = 0x822E3328; continue 'dispatch;
            }
            0x822E3328 => {
    //   block [0x822E3328..0x822E3354)
	// 822E3328: 578B0630  rlwinm r11, r28, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 822E332C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E3330: 419A0024  beq cr6, 0x822e3354
	if ctx.cr[6].eq {
	pc = 0x822E3354; continue 'dispatch;
	}
	// 822E3334: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E3338: B3BF0092  sth r29, 0x92(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(146 as u32), ctx.r[29].u16 ) };
	// 822E333C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E3340: B3BF000A  sth r29, 0xa(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(10 as u32), ctx.r[29].u16 ) };
	// 822E3344: B17F0014  sth r11, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 822E3348: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822E334C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822E3350: 48251DB8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x822E3354 => {
    //   block [0x822E3354..0x822E3370)
	// 822E3354: B3BF0014  sth r29, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u16 ) };
	// 822E3358: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E335C: B3BF0092  sth r29, 0x92(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(146 as u32), ctx.r[29].u16 ) };
	// 822E3360: B3BF000A  sth r29, 0xa(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(10 as u32), ctx.r[29].u16 ) };
	// 822E3364: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822E3368: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822E336C: 48251D9C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x822E3370 => {
    //   block [0x822E3370..0x822E3380)
	// 822E3370: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E3374: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822E3378: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822E337C: 48251D8C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E3380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E3380 size=84
    let mut pc: u32 = 0x822E3380;
    'dispatch: loop {
        match pc {
            0x822E3380 => {
    //   block [0x822E3380..0x822E33B8)
	// 822E3380: 1D640458  mulli r11, r4, 0x458
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E3384: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822E3388: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822E338C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 822E3390: 3D6B0002  addis r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 131072;
	// 822E3394: 396BEFA0  addi r11, r11, -0x1060
	ctx.r[11].s64 = ctx.r[11].s64 + -4192;
	// 822E3398: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 822E339C: 38EB00CC  addi r7, r11, 0xcc
	ctx.r[7].s64 = ctx.r[11].s64 + 204;
	// 822E33A0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822E33A4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 822E33A8: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822E33AC: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 822E33B0: 7D083850  subf r8, r8, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 822E33B4: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	pc = 0x822E33B8; continue 'dispatch;
            }
            0x822E33B8 => {
    //   block [0x822E33B8..0x822E33D4)
	// 822E33B8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822E33BC: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 822E33C0: 7D285B2E  sthx r9, r8, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u16) };
	// 822E33C4: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 822E33C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E33CC: 409AFFEC  bne cr6, 0x822e33b8
	if !ctx.cr[6].eq {
	pc = 0x822E33B8; continue 'dispatch;
	}
	// 822E33D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E33D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E33D8 size=2332
    let mut pc: u32 = 0x822E33D8;
    'dispatch: loop {
        match pc {
            0x822E33D8 => {
    //   block [0x822E33D8..0x822E3490)
	// 822E33D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E33DC: 48251CA5  bl 0x82535080
	ctx.lr = 0x822E33E0;
	sub_82535080(ctx, base);
	// 822E33E0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E33E4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E33E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E33EC: 616BEB1B  ori r11, r11, 0xeb1b
	ctx.r[11].u64 = ctx.r[11].u64 | 60187;
	// 822E33F0: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E33F4: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E33F8: 614AE2D4  ori r10, r10, 0xe2d4
	ctx.r[10].u64 = ctx.r[10].u64 | 58068;
	// 822E33FC: 6129E2DC  ori r9, r9, 0xe2dc
	ctx.r[9].u64 = ctx.r[9].u64 | 58076;
	// 822E3400: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E3404: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 822E3408: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 822E340C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E3410: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E3414: 7FDF502E  lwzx r30, r31, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E3418: 7DDF482E  lwzx r14, r31, r9
	ctx.r[14].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E341C: 3B6BBFF0  addi r27, r11, -0x4010
	ctx.r[27].s64 = ctx.r[11].s64 + -16400;
	// 822E3420: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 822E3424: 419A0218  beq cr6, 0x822e363c
	if ctx.cr[6].eq {
	pc = 0x822E363C; continue 'dispatch;
	}
	// 822E3428: 3D7F0002  addis r11, r31, 2
	ctx.r[11].s64 = ctx.r[31].s64 + 131072;
	// 822E342C: 3FBF0002  addis r29, r31, 2
	ctx.r[29].s64 = ctx.r[31].s64 + 131072;
	// 822E3430: 396BEB21  addi r11, r11, -0x14df
	ctx.r[11].s64 = ctx.r[11].s64 + -5343;
	// 822E3434: 3BBDEB23  addi r29, r29, -0x14dd
	ctx.r[29].s64 = ctx.r[29].s64 + -5341;
	// 822E3438: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822E343C: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E3440: 8B9D0000  lbz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E3444: 9B0B0000  stb r24, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	// 822E3448: 9B1D0000  stb r24, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	// 822E344C: 419A0204  beq cr6, 0x822e3650
	if ctx.cr[6].eq {
	pc = 0x822E3650; continue 'dispatch;
	}
	// 822E3450: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 822E3454: C00E0008  lfs f0, 8(r14)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E3458: A15E0036  lhz r10, 0x36(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(54 as u32) ) } as u64;
	// 822E345C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822E3460: A13E0038  lhz r9, 0x38(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 822E3464: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E3468: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E346C: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 822E3470: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822E3474: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822E3478: 40980018  bge cr6, 0x822e3490
	if !ctx.cr[6].lt {
	pc = 0x822E3490; continue 'dispatch;
	}
	// 822E347C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E3480: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822E3484: 614AED2C  ori r10, r10, 0xed2c
	ctx.r[10].u64 = ctx.r[10].u64 | 60716;
	// 822E3488: 7D3F532E  sthx r9, r31, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u16) };
	// 822E348C: 48000060  b 0x822e34ec
	pc = 0x822E34EC; continue 'dispatch;
            }
            0x822E3490 => {
    //   block [0x822E3490..0x822E34B0)
	// 822E3490: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 822E3494: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E3498: 6129ED2C  ori r9, r9, 0xed2c
	ctx.r[9].u64 = ctx.r[9].u64 | 60716;
	// 822E349C: 41990014  bgt cr6, 0x822e34b0
	if ctx.cr[6].gt {
	pc = 0x822E34B0; continue 'dispatch;
	}
	// 822E34A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822E34A4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 822E34A8: 7CFF4B2E  sthx r7, r31, r9
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u16) };
	// 822E34AC: 48000040  b 0x822e34ec
	pc = 0x822E34EC; continue 'dispatch;
            }
            0x822E34B0 => {
    //   block [0x822E34B0..0x822E34E0)
	// 822E34B0: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822E34B4: C00E000C  lfs f0, 0xc(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E34B8: F9410070  std r10, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u64 ) };
	// 822E34BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822E34C0: C9A10070  lfd f13, 0x70(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 822E34C4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E34C8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E34CC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822E34D0: 40980010  bge cr6, 0x822e34e0
	if !ctx.cr[6].lt {
	pc = 0x822E34E0; continue 'dispatch;
	}
	// 822E34D4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 822E34D8: 7CFF4B2E  sthx r7, r31, r9
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u16) };
	// 822E34DC: 48000010  b 0x822e34ec
	pc = 0x822E34EC; continue 'dispatch;
            }
            0x822E34E0 => {
    //   block [0x822E34E0..0x822E34EC)
	// 822E34E0: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 822E34E4: 995D0000  stb r10, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 822E34E8: 7D1F4B2E  sthx r8, r31, r9
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u16) };
	pc = 0x822E34EC; continue 'dispatch;
            }
            0x822E34EC => {
    //   block [0x822E34EC..0x822E3514)
	// 822E34EC: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E34F0: 614AEB22  ori r10, r10, 0xeb22
	ctx.r[10].u64 = ctx.r[10].u64 | 60194;
	// 822E34F4: 7D5F50AE  lbzx r10, r31, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E34F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E34FC: 409A0018  bne cr6, 0x822e3514
	if !ctx.cr[6].eq {
	pc = 0x822E3514; continue 'dispatch;
	}
	// 822E3500: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E3504: 614AEB39  ori r10, r10, 0xeb39
	ctx.r[10].u64 = ctx.r[10].u64 | 60217;
	// 822E3508: 7D5F50AE  lbzx r10, r31, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E350C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E3510: 419A000C  beq cr6, 0x822e351c
	if ctx.cr[6].eq {
	pc = 0x822E351C; continue 'dispatch;
	}
	pc = 0x822E3514; continue 'dispatch;
            }
            0x822E3514 => {
    //   block [0x822E3514..0x822E351C)
	// 822E3514: 9B0B0000  stb r24, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	// 822E3518: 9B1D0000  stb r24, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	pc = 0x822E351C; continue 'dispatch;
            }
            0x822E351C => {
    //   block [0x822E351C..0x822E3598)
	// 822E351C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 822E3520: 409A0078  bne cr6, 0x822e3598
	if !ctx.cr[6].eq {
	pc = 0x822E3598; continue 'dispatch;
	}
	// 822E3524: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E3528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E352C: 419A006C  beq cr6, 0x822e3598
	if ctx.cr[6].eq {
	pc = 0x822E3598; continue 'dispatch;
	}
	// 822E3530: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E3534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E3538: 4BFFC939  bl 0x822dfe70
	ctx.lr = 0x822E353C;
	sub_822DFE70(ctx, base);
	// 822E353C: A17E003A  lhz r11, 0x3a(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(58 as u32) ) } as u64;
	// 822E3540: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E3544: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 822E3548: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E354C: C8010070  lfd f0, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 822E3550: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E3554: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E3558: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E355C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822E3560: 40990038  ble cr6, 0x822e3598
	if !ctx.cr[6].gt {
	pc = 0x822E3598; continue 'dispatch;
	}
	// 822E3564: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E3568: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E356C: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E3570: 616BE7D0  ori r11, r11, 0xe7d0
	ctx.r[11].u64 = ctx.r[11].u64 | 59344;
	// 822E3574: 614AD384  ori r10, r10, 0xd384
	ctx.r[10].u64 = ctx.r[10].u64 | 54148;
	// 822E3578: 6129D388  ori r9, r9, 0xd388
	ctx.r[9].u64 = ctx.r[9].u64 | 54152;
	// 822E357C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E3580: 38800064  li r4, 0x64
	ctx.r[4].s64 = 100;
	// 822E3584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E3588: 7C1F5C2E  lfsx f0, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E358C: 7C1F552E  stfsx f0, r31, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 822E3590: 7C1F4D2E  stfsx f0, r31, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 822E3594: 4BE455BD  bl 0x82128b50
	ctx.lr = 0x822E3598;
	sub_82128B50(ctx, base);
	pc = 0x822E3598; continue 'dispatch;
            }
            0x822E3598 => {
    //   block [0x822E3598..0x822E35F4)
	// 822E3598: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822E359C: 409A00B4  bne cr6, 0x822e3650
	if !ctx.cr[6].eq {
	pc = 0x822E3650; continue 'dispatch;
	}
	// 822E35A0: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E35A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E35A8: 419A00A8  beq cr6, 0x822e3650
	if ctx.cr[6].eq {
	pc = 0x822E3650; continue 'dispatch;
	}
	// 822E35AC: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E35B0: 616B8654  ori r11, r11, 0x8654
	ctx.r[11].u64 = ctx.r[11].u64 | 34388;
	// 822E35B4: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E35B8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 822E35BC: 409A0094  bne cr6, 0x822e3650
	if !ctx.cr[6].eq {
	pc = 0x822E3650; continue 'dispatch;
	}
	// 822E35C0: 3D7F0002  addis r11, r31, 2
	ctx.r[11].s64 = ctx.r[31].s64 + 131072;
	// 822E35C4: 396BE1F8  addi r11, r11, -0x1e08
	ctx.r[11].s64 = ctx.r[11].s64 + -7688;
	// 822E35C8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E35CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E35D0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822E35D4: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E35D8: 616B93DC  ori r11, r11, 0x93dc
	ctx.r[11].u64 = ctx.r[11].u64 | 37852;
	// 822E35DC: 7D7B5A2E  lhzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E35E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E35E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E35E8: 4098000C  bge cr6, 0x822e35f4
	if !ctx.cr[6].lt {
	pc = 0x822E35F4; continue 'dispatch;
	}
	// 822E35EC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 822E35F0: 48000010  b 0x822e3600
	pc = 0x822E3600; continue 'dispatch;
            }
            0x822E35F4 => {
    //   block [0x822E35F4..0x822E3600)
	// 822E35F4: 2F0B000B  cmpwi cr6, r11, 0xb
	ctx.cr[6].compare_i32(ctx.r[11].s32, 11, &mut ctx.xer);
	// 822E35F8: 40990008  ble cr6, 0x822e3600
	if !ctx.cr[6].gt {
	pc = 0x822E3600; continue 'dispatch;
	}
	// 822E35FC: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
	pc = 0x822E3600; continue 'dispatch;
            }
            0x822E3600 => {
    //   block [0x822E3600..0x822E363C)
	// 822E3600: 1D6B00C4  mulli r11, r11, 0xc4
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 196 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E3604: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 822E3608: 3D5F0002  addis r10, r31, 2
	ctx.r[10].s64 = ctx.r[31].s64 + 131072;
	// 822E360C: 3D6B0002  addis r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 131072;
	// 822E3610: 394AD804  addi r10, r10, -0x27fc
	ctx.r[10].s64 = ctx.r[10].s64 + -10236;
	// 822E3614: 396BD8C8  addi r11, r11, -0x2738
	ctx.r[11].s64 = ctx.r[11].s64 + -10040;
	// 822E3618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E361C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E3620: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822E3624: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822E3628: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E362C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E3630: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E3634: 4BE5C735  bl 0x8213fd68
	ctx.lr = 0x822E3638;
	sub_8213FD68(ctx, base);
	// 822E3638: 48000018  b 0x822e3650
	pc = 0x822E3650; continue 'dispatch;
            }
            0x822E363C => {
    //   block [0x822E363C..0x822E3650)
	// 822E363C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E3640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E3644: 616BED2C  ori r11, r11, 0xed2c
	ctx.r[11].u64 = ctx.r[11].u64 | 60716;
	// 822E3648: 7F1F5B2E  sthx r24, r31, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[24].u16) };
	// 822E364C: 4BEBAD1D  bl 0x8219e368
	ctx.lr = 0x822E3650;
	sub_8219E368(ctx, base);
	pc = 0x822E3650; continue 'dispatch;
            }
            0x822E3650 => {
    //   block [0x822E3650..0x822E3884)
	// 822E3650: 3CFF0006  addis r7, r31, 6
	ctx.r[7].s64 = ctx.r[31].s64 + 393216;
	// 822E3654: 3CDF0006  addis r6, r31, 6
	ctx.r[6].s64 = ctx.r[31].s64 + 393216;
	// 822E3658: 3C7F0006  addis r3, r31, 6
	ctx.r[3].s64 = ctx.r[31].s64 + 393216;
	// 822E365C: 3FBF0006  addis r29, r31, 6
	ctx.r[29].s64 = ctx.r[31].s64 + 393216;
	// 822E3660: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822E3664: 38E791E0  addi r7, r7, -0x6e20
	ctx.r[7].s64 = ctx.r[7].s64 + -28192;
	// 822E3668: 38C691DA  addi r6, r6, -0x6e26
	ctx.r[6].s64 = ctx.r[6].s64 + -28198;
	// 822E366C: 386391D8  addi r3, r3, -0x6e28
	ctx.r[3].s64 = ctx.r[3].s64 + -28200;
	// 822E3670: 3BBD91D6  addi r29, r29, -0x6e2a
	ctx.r[29].s64 = ctx.r[29].s64 + -28202;
	// 822E3674: 3D5F0006  addis r10, r31, 6
	ctx.r[10].s64 = ctx.r[31].s64 + 393216;
	// 822E3678: 3F5F0006  addis r26, r31, 6
	ctx.r[26].s64 = ctx.r[31].s64 + 393216;
	// 822E367C: 90E10060  stw r7, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[7].u32 ) };
	// 822E3680: 3F9F0006  addis r28, r31, 6
	ctx.r[28].s64 = ctx.r[31].s64 + 393216;
	// 822E3684: 90C1006C  stw r6, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[6].u32 ) };
	// 822E3688: 3D3F0006  addis r9, r31, 6
	ctx.r[9].s64 = ctx.r[31].s64 + 393216;
	// 822E368C: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 822E3690: 3D1F0006  addis r8, r31, 6
	ctx.r[8].s64 = ctx.r[31].s64 + 393216;
	// 822E3694: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 822E3698: 3E3F0006  addis r17, r31, 6
	ctx.r[17].s64 = ctx.r[31].s64 + 393216;
	// 822E369C: B1670000  sth r11, 0(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E36A0: 3EBF0006  addis r21, r31, 6
	ctx.r[21].s64 = ctx.r[31].s64 + 393216;
	// 822E36A4: B1660000  sth r11, 0(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E36A8: 3CBF0006  addis r5, r31, 6
	ctx.r[5].s64 = ctx.r[31].s64 + 393216;
	// 822E36AC: B1630000  sth r11, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E36B0: 3C9F0006  addis r4, r31, 6
	ctx.r[4].s64 = ctx.r[31].s64 + 393216;
	// 822E36B4: B17D0000  sth r11, 0(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E36B8: 3F7F0006  addis r27, r31, 6
	ctx.r[27].s64 = ctx.r[31].s64 + 393216;
	// 822E36BC: 3F3F0006  addis r25, r31, 6
	ctx.r[25].s64 = ctx.r[31].s64 + 393216;
	// 822E36C0: 3E1F0006  addis r16, r31, 6
	ctx.r[16].s64 = ctx.r[31].s64 + 393216;
	// 822E36C4: 3E9F0006  addis r20, r31, 6
	ctx.r[20].s64 = ctx.r[31].s64 + 393216;
	// 822E36C8: 3DFF0006  addis r15, r31, 6
	ctx.r[15].s64 = ctx.r[31].s64 + 393216;
	// 822E36CC: 3E7F0006  addis r19, r31, 6
	ctx.r[19].s64 = ctx.r[31].s64 + 393216;
	// 822E36D0: 3E5F0006  addis r18, r31, 6
	ctx.r[18].s64 = ctx.r[31].s64 + 393216;
	// 822E36D4: 394A91EA  addi r10, r10, -0x6e16
	ctx.r[10].s64 = ctx.r[10].s64 + -28182;
	// 822E36D8: 392991E8  addi r9, r9, -0x6e18
	ctx.r[9].s64 = ctx.r[9].s64 + -28184;
	// 822E36DC: 390891E2  addi r8, r8, -0x6e1e
	ctx.r[8].s64 = ctx.r[8].s64 + -28190;
	// 822E36E0: 3B5A91EE  addi r26, r26, -0x6e12
	ctx.r[26].s64 = ctx.r[26].s64 + -28178;
	// 822E36E4: 3B9C91EC  addi r28, r28, -0x6e14
	ctx.r[28].s64 = ctx.r[28].s64 + -28180;
	// 822E36E8: 3A3191D2  addi r17, r17, -0x6e2e
	ctx.r[17].s64 = ctx.r[17].s64 + -28206;
	// 822E36EC: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 822E36F0: 3AB591D0  addi r21, r21, -0x6e30
	ctx.r[21].s64 = ctx.r[21].s64 + -28208;
	// 822E36F4: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E36F8: 38A591C2  addi r5, r5, -0x6e3e
	ctx.r[5].s64 = ctx.r[5].s64 + -28222;
	// 822E36FC: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 822E3700: 388491C0  addi r4, r4, -0x6e40
	ctx.r[4].s64 = ctx.r[4].s64 + -28224;
	// 822E3704: 91010068  stw r8, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 822E3708: 3B7B91CA  addi r27, r27, -0x6e36
	ctx.r[27].s64 = ctx.r[27].s64 + -28214;
	// 822E370C: B17A0000  sth r11, 0(r26)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3710: 3B3991C8  addi r25, r25, -0x6e38
	ctx.r[25].s64 = ctx.r[25].s64 + -28216;
	// 822E3714: B17C0000  sth r11, 0(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3718: 3A1091E6  addi r16, r16, -0x6e1a
	ctx.r[16].s64 = ctx.r[16].s64 + -28186;
	// 822E371C: B1690000  sth r11, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3720: 3A9491E4  addi r20, r20, -0x6e1c
	ctx.r[20].s64 = ctx.r[20].s64 + -28188;
	// 822E3724: B1680000  sth r11, 0(r8)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3728: 39EF91DE  addi r15, r15, -0x6e22
	ctx.r[15].s64 = ctx.r[15].s64 + -28194;
	// 822E372C: B1710000  sth r11, 0(r17)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3730: 3A7391DC  addi r19, r19, -0x6e24
	ctx.r[19].s64 = ctx.r[19].s64 + -28196;
	// 822E3734: B1750000  sth r11, 0(r21)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3738: 3A5291D4  addi r18, r18, -0x6e2c
	ctx.r[18].s64 = ctx.r[18].s64 + -28204;
	// 822E373C: B1650000  sth r11, 0(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3740: 3EDF0006  addis r22, r31, 6
	ctx.r[22].s64 = ctx.r[31].s64 + 393216;
	// 822E3744: B1640000  sth r11, 0(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3748: 3EFF0006  addis r23, r31, 6
	ctx.r[23].s64 = ctx.r[31].s64 + 393216;
	// 822E374C: B17B0000  sth r11, 0(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3750: 3CDF0006  addis r6, r31, 6
	ctx.r[6].s64 = ctx.r[31].s64 + 393216;
	// 822E3754: B1790000  sth r11, 0(r25)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3758: 3CFF0006  addis r7, r31, 6
	ctx.r[7].s64 = ctx.r[31].s64 + 393216;
	// 822E375C: B1700000  sth r11, 0(r16)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3760: 3FBF0006  addis r29, r31, 6
	ctx.r[29].s64 = ctx.r[31].s64 + 393216;
	// 822E3764: B1740000  sth r11, 0(r20)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3768: 3C7F0006  addis r3, r31, 6
	ctx.r[3].s64 = ctx.r[31].s64 + 393216;
	// 822E376C: B16F0000  sth r11, 0(r15)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[15].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3770: B1730000  sth r11, 0(r19)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[19].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3774: 3AD691CE  addi r22, r22, -0x6e32
	ctx.r[22].s64 = ctx.r[22].s64 + -28210;
	// 822E3778: B1720000  sth r11, 0(r18)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E377C: 3AF791CC  addi r23, r23, -0x6e34
	ctx.r[23].s64 = ctx.r[23].s64 + -28212;
	// 822E3780: 38C691BE  addi r6, r6, -0x6e42
	ctx.r[6].s64 = ctx.r[6].s64 + -28226;
	// 822E3784: 38E791BC  addi r7, r7, -0x6e44
	ctx.r[7].s64 = ctx.r[7].s64 + -28228;
	// 822E3788: 3BBD91C6  addi r29, r29, -0x6e3a
	ctx.r[29].s64 = ctx.r[29].s64 + -28218;
	// 822E378C: 386391C4  addi r3, r3, -0x6e3c
	ctx.r[3].s64 = ctx.r[3].s64 + -28220;
	// 822E3790: 3D5F0006  addis r10, r31, 6
	ctx.r[10].s64 = ctx.r[31].s64 + 393216;
	// 822E3794: 3D3F0006  addis r9, r31, 6
	ctx.r[9].s64 = ctx.r[31].s64 + 393216;
	// 822E3798: B1760000  sth r11, 0(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E379C: 394A91F0  addi r10, r10, -0x6e10
	ctx.r[10].s64 = ctx.r[10].s64 + -28176;
	// 822E37A0: B1770000  sth r11, 0(r23)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E37A4: 392991F2  addi r9, r9, -0x6e0e
	ctx.r[9].s64 = ctx.r[9].s64 + -28174;
	// 822E37A8: B1660000  sth r11, 0(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E37AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822E37B0: B1670000  sth r11, 0(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E37B4: B17D0000  sth r11, 0(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E37B8: B1630000  sth r11, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E37BC: B30A0000  sth r24, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	// 822E37C0: B3090000  sth r24, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	// 822E37C4: 419A0528  beq cr6, 0x822e3cec
	if ctx.cr[6].eq {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E37C8: A17E0058  lhz r11, 0x58(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 822E37CC: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E37D0: 419A051C  beq cr6, 0x822e3cec
	if ctx.cr[6].eq {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E37D4: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 822E37D8: C00E0008  lfs f0, 8(r14)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E37DC: 3F000001  lis r24, 1
	ctx.r[24].s64 = 65536;
	// 822E37E0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822E37E4: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 822E37E8: 6108EB39  ori r8, r8, 0xeb39
	ctx.r[8].u64 = ctx.r[8].u64 | 60217;
	// 822E37EC: 6318EB22  ori r24, r24, 0xeb22
	ctx.r[24].u64 = ctx.r[24].u64 | 60194;
	// 822E37F0: 616B91F6  ori r11, r11, 0x91f6
	ctx.r[11].u64 = ctx.r[11].u64 | 37366;
	// 822E37F4: 39C10054  addi r14, r1, 0x54
	ctx.r[14].s64 = ctx.r[1].s64 + 84;
	// 822E37F8: 7D1F40AE  lbzx r8, r31, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 822E37FC: 7F1FC0AE  lbzx r24, r31, r24
	ctx.r[24].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 822E3800: 7D7F5A2E  lhzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E3804: 7C0077AE  stfiwx f0, 0, r14
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[14].u32, tmp.u32) };
	// 822E3808: 7D0EC378  or r14, r8, r24
	ctx.r[14].u64 = ctx.r[8].u64 | ctx.r[24].u64;
	// 822E380C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 822E3810: 556B93BE  srwi r11, r11, 0xe
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(14);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E3814: 5518057E  clrlwi r24, r8, 0x15
	ctx.r[24].u64 = ctx.r[8].u32 as u64 & 0x000007FFu64;
	// 822E3818: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E381C: 550BAF7E  rlwinm r11, r8, 0x15, 0x1d, 0x1f
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000007FFu64;
	// 822E3820: B1690000  sth r11, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3824: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 822E3828: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 822E382C: 4199011C  bgt cr6, 0x822e3948
	if ctx.cr[6].gt {
	pc = 0x822E3948; continue 'dispatch;
	}
	// 822E3830: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E3834: A11E0036  lhz r8, 0x36(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(54 as u32) ) } as u64;
	// 822E3838: A09E0038  lhz r4, 0x38(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 822E383C: 392B0067  addi r9, r11, 0x67
	ctx.r[9].s64 = ctx.r[11].s64 + 103;
	// 822E3840: 614AE784  ori r10, r10, 0xe784
	ctx.r[10].u64 = ctx.r[10].u64 | 59268;
	// 822E3844: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E3848: 7D050734  extsh r5, r8
	ctx.r[5].s64 = ctx.r[8].s16 as i64;
	// 822E384C: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E3850: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E3854: 7C840734  extsh r4, r4
	ctx.r[4].s64 = ctx.r[4].s16 as i64;
	// 822E3858: 7D1F502E  lwzx r8, r31, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E385C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 822E3860: 614A94D4  ori r10, r10, 0x94d4
	ctx.r[10].u64 = ctx.r[10].u64 | 38100;
	// 822E3864: 7D5E502E  lwzx r10, r30, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E3868: 551E06B4  rlwinm r30, r8, 0, 0x1a, 0x1a
	ctx.r[30].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 822E386C: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 822E3870: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E3874: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822E3878: 419A000C  beq cr6, 0x822e3884
	if ctx.cr[6].eq {
	pc = 0x822E3884; continue 'dispatch;
	}
	// 822E387C: 38C0FFFC  li r6, -4
	ctx.r[6].s64 = -4;
	// 822E3880: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	pc = 0x822E3884; continue 'dispatch;
            }
            0x822E3884 => {
    //   block [0x822E3884..0x822E3898)
	// 822E3884: 55080672  rlwinm r8, r8, 0, 0x19, 0x19
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 822E3888: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822E388C: 419A000C  beq cr6, 0x822e3898
	if ctx.cr[6].eq {
	pc = 0x822E3898; continue 'dispatch;
	}
	// 822E3890: 38C60002  addi r6, r6, 2
	ctx.r[6].s64 = ctx.r[6].s64 + 2;
	// 822E3894: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	pc = 0x822E3898; continue 'dispatch;
            }
            0x822E3898 => {
    //   block [0x822E3898..0x822E38B0)
	// 822E3898: A1090000  lhz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E389C: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E38A0: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 822E38A4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822E38A8: 41980008  blt cr6, 0x822e38b0
	if ctx.cr[6].lt {
	pc = 0x822E38B0; continue 'dispatch;
	}
	// 822E38AC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x822E38B0; continue 'dispatch;
            }
            0x822E38B0 => {
    //   block [0x822E38B0..0x822E38C8)
	// 822E38B0: A1290002  lhz r9, 2(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E38B4: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E38B8: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 822E38BC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822E38C0: 41990008  bgt cr6, 0x822e38c8
	if ctx.cr[6].gt {
	pc = 0x822E38C8; continue 'dispatch;
	}
	// 822E38C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x822E38C8; continue 'dispatch;
            }
            0x822E38C8 => {
    //   block [0x822E38C8..0x822E38F4)
	// 822E38C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E38CC: B3070000  sth r24, 0(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	// 822E38D0: 419A0028  beq cr6, 0x822e38f8
	if ctx.cr[6].eq {
	pc = 0x822E38F8; continue 'dispatch;
	}
	// 822E38D4: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 822E38D8: 614A9210  ori r10, r10, 0x9210
	ctx.r[10].u64 = ctx.r[10].u64 | 37392;
	// 822E38DC: 7D5F502E  lwzx r10, r31, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E38E0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E38E4: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 822E38E8: 2F0B000F  cmpwi cr6, r11, 0xf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 15, &mut ctx.xer);
	// 822E38EC: 41980008  blt cr6, 0x822e38f4
	if ctx.cr[6].lt {
	pc = 0x822E38F4; continue 'dispatch;
	}
	// 822E38F0: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	pc = 0x822E38F4; continue 'dispatch;
            }
            0x822E38F4 => {
    //   block [0x822E38F4..0x822E38F8)
	// 822E38F4: 5578043E  clrlwi r24, r11, 0x10
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	pc = 0x822E38F8; continue 'dispatch;
            }
            0x822E38F8 => {
    //   block [0x822E38F8..0x822E3924)
	// 822E38F8: 2F0E0000  cmpwi cr6, r14, 0
	ctx.cr[6].compare_i32(ctx.r[14].s32, 0, &mut ctx.xer);
	// 822E38FC: B3030000  sth r24, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	// 822E3900: 409A03EC  bne cr6, 0x822e3cec
	if !ctx.cr[6].eq {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E3904: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822E3908: 7D482A14  add r10, r8, r5
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[5].u64;
	// 822E390C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822E3910: 41980014  blt cr6, 0x822e3924
	if ctx.cr[6].lt {
	pc = 0x822E3924; continue 'dispatch;
	}
	// 822E3914: 7D492A14  add r10, r9, r5
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 822E3918: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822E391C: 41990008  bgt cr6, 0x822e3924
	if ctx.cr[6].gt {
	pc = 0x822E3924; continue 'dispatch;
	}
	// 822E3920: B3170000  sth r24, 0(r23)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	pc = 0x822E3924; continue 'dispatch;
            }
            0x822E3924 => {
    //   block [0x822E3924..0x822E3948)
	// 822E3924: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 822E3928: 419803C4  blt cr6, 0x822e3cec
	if ctx.cr[6].lt {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E392C: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 822E3930: 419903BC  bgt cr6, 0x822e3cec
	if ctx.cr[6].gt {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E3934: B3140000  sth r24, 0(r20)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	// 822E3938: B3130000  sth r24, 0(r19)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[19].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	// 822E393C: B3120000  sth r24, 0(r18)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	// 822E3940: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 822E3944: 4825178C  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            0x822E3948 => {
    //   block [0x822E3948..0x822E39B0)
	// 822E3948: 2B0B001F  cmplwi cr6, r11, 0x1f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 31 as u32, &mut ctx.xer);
	// 822E394C: 41990130  bgt cr6, 0x822e3a7c
	if ctx.cr[6].gt {
	pc = 0x822E3A7C; continue 'dispatch;
	}
	// 822E3950: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E3954: A13E0036  lhz r9, 0x36(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(54 as u32) ) } as u64;
	// 822E3958: 3D6B0001  addis r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 65536;
	// 822E395C: A11E0038  lhz r8, 0x38(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 822E3960: 614AE784  ori r10, r10, 0xe784
	ctx.r[10].u64 = ctx.r[10].u64 | 59268;
	// 822E3964: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E3968: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 822E396C: 7D230734  extsh r3, r9
	ctx.r[3].s64 = ctx.r[9].s16 as i64;
	// 822E3970: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 822E3974: 7D1E0734  extsh r30, r8
	ctx.r[30].s64 = ctx.r[8].s16 as i64;
	// 822E3978: 7D5F502E  lwzx r10, r31, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E397C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 822E3980: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822E3984: 55490738  rlwinm r9, r10, 0, 0x1c, 0x1c
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822E3988: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822E398C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822E3990: 39250077  addi r9, r5, 0x77
	ctx.r[9].s64 = ctx.r[5].s64 + 119;
	// 822E3994: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E3998: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 822E399C: 612994D4  ori r9, r9, 0x94d4
	ctx.r[9].u64 = ctx.r[9].u64 | 38100;
	// 822E39A0: 7D3B482E  lwzx r9, r27, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E39A4: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 822E39A8: 419A0008  beq cr6, 0x822e39b0
	if ctx.cr[6].eq {
	pc = 0x822E39B0; continue 'dispatch;
	}
	// 822E39AC: 38E0FFFC  li r7, -4
	ctx.r[7].s64 = -4;
	pc = 0x822E39B0; continue 'dispatch;
            }
            0x822E39B0 => {
    //   block [0x822E39B0..0x822E39C4)
	// 822E39B0: 554A06F6  rlwinm r10, r10, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822E39B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E39B8: 419A000C  beq cr6, 0x822e39c4
	if ctx.cr[6].eq {
	pc = 0x822E39C4; continue 'dispatch;
	}
	// 822E39BC: 38E70003  addi r7, r7, 3
	ctx.r[7].s64 = ctx.r[7].s64 + 3;
	// 822E39C0: 3880FFFD  li r4, -3
	ctx.r[4].s64 = -3;
	pc = 0x822E39C4; continue 'dispatch;
            }
            0x822E39C4 => {
    //   block [0x822E39C4..0x822E39DC)
	// 822E39C4: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E39C8: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E39CC: 7D0A3A14  add r8, r10, r7
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 822E39D0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822E39D4: 41980008  blt cr6, 0x822e39dc
	if ctx.cr[6].lt {
	pc = 0x822E39DC; continue 'dispatch;
	}
	// 822E39D8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x822E39DC; continue 'dispatch;
            }
            0x822E39DC => {
    //   block [0x822E39DC..0x822E39F4)
	// 822E39DC: A1490002  lhz r10, 2(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E39E0: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E39E4: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 822E39E8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822E39EC: 41990008  bgt cr6, 0x822e39f4
	if ctx.cr[6].gt {
	pc = 0x822E39F4; continue 'dispatch;
	}
	// 822E39F0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x822E39F4; continue 'dispatch;
            }
            0x822E39F4 => {
    //   block [0x822E39F4..0x822E3A20)
	// 822E39F4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 822E39F8: B1660000  sth r11, 0(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E39FC: 419A0028  beq cr6, 0x822e3a24
	if ctx.cr[6].eq {
	pc = 0x822E3A24; continue 'dispatch;
	}
	// 822E3A00: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 822E3A04: 616B9210  ori r11, r11, 0x9210
	ctx.r[11].u64 = ctx.r[11].u64 | 37392;
	// 822E3A08: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E3A0C: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 822E3A10: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 822E3A14: 2F0B000F  cmpwi cr6, r11, 0xf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 15, &mut ctx.xer);
	// 822E3A18: 41980008  blt cr6, 0x822e3a20
	if ctx.cr[6].lt {
	pc = 0x822E3A20; continue 'dispatch;
	}
	// 822E3A1C: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	pc = 0x822E3A20; continue 'dispatch;
            }
            0x822E3A20 => {
    //   block [0x822E3A20..0x822E3A24)
	// 822E3A20: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	pc = 0x822E3A24; continue 'dispatch;
            }
            0x822E3A24 => {
    //   block [0x822E3A24..0x822E3A54)
	// 822E3A24: 2F0E0000  cmpwi cr6, r14, 0
	ctx.cr[6].compare_i32(ctx.r[14].s32, 0, &mut ctx.xer);
	// 822E3A28: B17D0000  sth r11, 0(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3A2C: 409A02C0  bne cr6, 0x822e3cec
	if !ctx.cr[6].eq {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E3A30: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822E3A34: 7D081A14  add r8, r8, r3
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 822E3A38: B17C0000  sth r11, 0(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3A3C: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 822E3A40: 41980014  blt cr6, 0x822e3a54
	if ctx.cr[6].lt {
	pc = 0x822E3A54; continue 'dispatch;
	}
	// 822E3A44: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 822E3A48: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 822E3A4C: 41990008  bgt cr6, 0x822e3a54
	if ctx.cr[6].gt {
	pc = 0x822E3A54; continue 'dispatch;
	}
	// 822E3A50: B1760000  sth r11, 0(r22)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	pc = 0x822E3A54; continue 'dispatch;
            }
            0x822E3A54 => {
    //   block [0x822E3A54..0x822E3A7C)
	// 822E3A54: 7F0A1800  cmpw cr6, r10, r3
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[3].s32, &mut ctx.xer);
	// 822E3A58: 41980294  blt cr6, 0x822e3cec
	if ctx.cr[6].lt {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E3A5C: 7F0AF000  cmpw cr6, r10, r30
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822E3A60: 4199028C  bgt cr6, 0x822e3cec
	if ctx.cr[6].gt {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E3A64: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822E3A68: B16F0000  sth r11, 0(r15)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[15].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3A6C: B1700000  sth r11, 0(r16)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3A70: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3A74: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 822E3A78: 48251658  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            0x822E3A7C => {
    //   block [0x822E3A7C..0x822E3AE8)
	// 822E3A7C: 2B0B002F  cmplwi cr6, r11, 0x2f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 47 as u32, &mut ctx.xer);
	// 822E3A80: 41990138  bgt cr6, 0x822e3bb8
	if ctx.cr[6].gt {
	pc = 0x822E3BB8; continue 'dispatch;
	}
	// 822E3A84: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E3A88: A13E0036  lhz r9, 0x36(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(54 as u32) ) } as u64;
	// 822E3A8C: 3D6B0001  addis r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 65536;
	// 822E3A90: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E3A94: 614AE784  ori r10, r10, 0xe784
	ctx.r[10].u64 = ctx.r[10].u64 | 59268;
	// 822E3A98: A11E0038  lhz r8, 0x38(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 822E3A9C: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 822E3AA0: 7D230734  extsh r3, r9
	ctx.r[3].s64 = ctx.r[9].s16 as i64;
	// 822E3AA4: 5567043E  clrlwi r7, r11, 0x10
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 822E3AA8: 7D1E0734  extsh r30, r8
	ctx.r[30].s64 = ctx.r[8].s16 as i64;
	// 822E3AAC: 7D3F502E  lwzx r9, r31, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E3AB0: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 822E3AB4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822E3AB8: 552B06B4  rlwinm r11, r9, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 822E3ABC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E3AC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E3AC4: 39650087  addi r11, r5, 0x87
	ctx.r[11].s64 = ctx.r[5].s64 + 135;
	// 822E3AC8: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E3ACC: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E3AD0: 616B94D4  ori r11, r11, 0x94d4
	ctx.r[11].u64 = ctx.r[11].u64 | 38100;
	// 822E3AD4: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E3AD8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E3ADC: 419A000C  beq cr6, 0x822e3ae8
	if ctx.cr[6].eq {
	pc = 0x822E3AE8; continue 'dispatch;
	}
	// 822E3AE0: 3900FFFC  li r8, -4
	ctx.r[8].s64 = -4;
	// 822E3AE4: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	pc = 0x822E3AE8; continue 'dispatch;
            }
            0x822E3AE8 => {
    //   block [0x822E3AE8..0x822E3AFC)
	// 822E3AE8: 552A0672  rlwinm r10, r9, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 822E3AEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E3AF0: 419A000C  beq cr6, 0x822e3afc
	if ctx.cr[6].eq {
	pc = 0x822E3AFC; continue 'dispatch;
	}
	// 822E3AF4: 39080002  addi r8, r8, 2
	ctx.r[8].s64 = ctx.r[8].s64 + 2;
	// 822E3AF8: 38C6FFFE  addi r6, r6, -2
	ctx.r[6].s64 = ctx.r[6].s64 + -2;
	pc = 0x822E3AFC; continue 'dispatch;
            }
            0x822E3AFC => {
    //   block [0x822E3AFC..0x822E3B14)
	// 822E3AFC: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E3B00: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E3B04: 7D2A4214  add r9, r10, r8
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822E3B08: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822E3B0C: 41980008  blt cr6, 0x822e3b14
	if ctx.cr[6].lt {
	pc = 0x822E3B14; continue 'dispatch;
	}
	// 822E3B10: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x822E3B14; continue 'dispatch;
            }
            0x822E3B14 => {
    //   block [0x822E3B14..0x822E3B2C)
	// 822E3B14: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E3B18: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E3B1C: 7D4B3214  add r10, r11, r6
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 822E3B20: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822E3B24: 41990008  bgt cr6, 0x822e3b2c
	if ctx.cr[6].gt {
	pc = 0x822E3B2C; continue 'dispatch;
	}
	// 822E3B28: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x822E3B2C; continue 'dispatch;
            }
            0x822E3B2C => {
    //   block [0x822E3B2C..0x822E3B58)
	// 822E3B2C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 822E3B30: B0E40000  sth r7, 0(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 822E3B34: 419A0028  beq cr6, 0x822e3b5c
	if ctx.cr[6].eq {
	pc = 0x822E3B5C; continue 'dispatch;
	}
	// 822E3B38: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 822E3B3C: 616B9210  ori r11, r11, 0x9210
	ctx.r[11].u64 = ctx.r[11].u64 | 37392;
	// 822E3B40: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E3B44: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 822E3B48: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 822E3B4C: 2F0B000F  cmpwi cr6, r11, 0xf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 15, &mut ctx.xer);
	// 822E3B50: 41980008  blt cr6, 0x822e3b58
	if ctx.cr[6].lt {
	pc = 0x822E3B58; continue 'dispatch;
	}
	// 822E3B54: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	pc = 0x822E3B58; continue 'dispatch;
            }
            0x822E3B58 => {
    //   block [0x822E3B58..0x822E3B5C)
	// 822E3B58: 5567043E  clrlwi r7, r11, 0x10
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	pc = 0x822E3B5C; continue 'dispatch;
            }
            0x822E3B5C => {
    //   block [0x822E3B5C..0x822E3B88)
	// 822E3B5C: 2F0E0000  cmpwi cr6, r14, 0
	ctx.cr[6].compare_i32(ctx.r[14].s32, 0, &mut ctx.xer);
	// 822E3B60: B0F90000  sth r7, 0(r25)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 822E3B64: 409A0188  bne cr6, 0x822e3cec
	if !ctx.cr[6].eq {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E3B68: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822E3B6C: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 822E3B70: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 822E3B74: 41980014  blt cr6, 0x822e3b88
	if ctx.cr[6].lt {
	pc = 0x822E3B88; continue 'dispatch;
	}
	// 822E3B78: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 822E3B7C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822E3B80: 41990008  bgt cr6, 0x822e3b88
	if ctx.cr[6].gt {
	pc = 0x822E3B88; continue 'dispatch;
	}
	// 822E3B84: B0F50000  sth r7, 0(r21)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	pc = 0x822E3B88; continue 'dispatch;
            }
            0x822E3B88 => {
    //   block [0x822E3B88..0x822E3BB8)
	// 822E3B88: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 822E3B8C: 41980160  blt cr6, 0x822e3cec
	if ctx.cr[6].lt {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E3B90: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822E3B94: 41990158  bgt cr6, 0x822e3cec
	if ctx.cr[6].gt {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E3B98: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822E3B9C: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 822E3BA0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822E3BA4: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 822E3BA8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822E3BAC: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 822E3BB0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 822E3BB4: 4825151C  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            0x822E3BB8 => {
    //   block [0x822E3BB8..0x822E3C20)
	// 822E3BB8: 2B0B003F  cmplwi cr6, r11, 0x3f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 63 as u32, &mut ctx.xer);
	// 822E3BBC: 41990130  bgt cr6, 0x822e3cec
	if ctx.cr[6].gt {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E3BC0: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E3BC4: A13E0036  lhz r9, 0x36(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(54 as u32) ) } as u64;
	// 822E3BC8: 3D6B0001  addis r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 65536;
	// 822E3BCC: A11E0038  lhz r8, 0x38(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 822E3BD0: 614AE784  ori r10, r10, 0xe784
	ctx.r[10].u64 = ctx.r[10].u64 | 59268;
	// 822E3BD4: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E3BD8: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 822E3BDC: 7D230734  extsh r3, r9
	ctx.r[3].s64 = ctx.r[9].s16 as i64;
	// 822E3BE0: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 822E3BE4: 7D1E0734  extsh r30, r8
	ctx.r[30].s64 = ctx.r[8].s16 as i64;
	// 822E3BE8: 7D5F502E  lwzx r10, r31, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E3BEC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 822E3BF0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822E3BF4: 55490738  rlwinm r9, r10, 0, 0x1c, 0x1c
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822E3BF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822E3BFC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822E3C00: 39260097  addi r9, r6, 0x97
	ctx.r[9].s64 = ctx.r[6].s64 + 151;
	// 822E3C04: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E3C08: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 822E3C0C: 612994D4  ori r9, r9, 0x94d4
	ctx.r[9].u64 = ctx.r[9].u64 | 38100;
	// 822E3C10: 7D3D482E  lwzx r9, r29, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E3C14: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 822E3C18: 419A0008  beq cr6, 0x822e3c20
	if ctx.cr[6].eq {
	pc = 0x822E3C20; continue 'dispatch;
	}
	// 822E3C1C: 38E0FFFC  li r7, -4
	ctx.r[7].s64 = -4;
	pc = 0x822E3C20; continue 'dispatch;
            }
            0x822E3C20 => {
    //   block [0x822E3C20..0x822E3C34)
	// 822E3C20: 554A06F6  rlwinm r10, r10, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822E3C24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E3C28: 419A000C  beq cr6, 0x822e3c34
	if ctx.cr[6].eq {
	pc = 0x822E3C34; continue 'dispatch;
	}
	// 822E3C2C: 38E70003  addi r7, r7, 3
	ctx.r[7].s64 = ctx.r[7].s64 + 3;
	// 822E3C30: 3880FFFD  li r4, -3
	ctx.r[4].s64 = -3;
	pc = 0x822E3C34; continue 'dispatch;
            }
            0x822E3C34 => {
    //   block [0x822E3C34..0x822E3C4C)
	// 822E3C34: A1490000  lhz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E3C38: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E3C3C: 7D0A3A14  add r8, r10, r7
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 822E3C40: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822E3C44: 41980008  blt cr6, 0x822e3c4c
	if ctx.cr[6].lt {
	pc = 0x822E3C4C; continue 'dispatch;
	}
	// 822E3C48: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x822E3C4C; continue 'dispatch;
            }
            0x822E3C4C => {
    //   block [0x822E3C4C..0x822E3C64)
	// 822E3C4C: A1490002  lhz r10, 2(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E3C50: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E3C54: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 822E3C58: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822E3C5C: 41990008  bgt cr6, 0x822e3c64
	if ctx.cr[6].gt {
	pc = 0x822E3C64; continue 'dispatch;
	}
	// 822E3C60: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x822E3C64; continue 'dispatch;
            }
            0x822E3C64 => {
    //   block [0x822E3C64..0x822E3C90)
	// 822E3C64: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 822E3C68: B1650000  sth r11, 0(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3C6C: 419A0028  beq cr6, 0x822e3c94
	if ctx.cr[6].eq {
	pc = 0x822E3C94; continue 'dispatch;
	}
	// 822E3C70: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 822E3C74: 616B9210  ori r11, r11, 0x9210
	ctx.r[11].u64 = ctx.r[11].u64 | 37392;
	// 822E3C78: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E3C7C: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 822E3C80: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 822E3C84: 2F0B000F  cmpwi cr6, r11, 0xf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 15, &mut ctx.xer);
	// 822E3C88: 41980008  blt cr6, 0x822e3c90
	if ctx.cr[6].lt {
	pc = 0x822E3C90; continue 'dispatch;
	}
	// 822E3C8C: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	pc = 0x822E3C90; continue 'dispatch;
            }
            0x822E3C90 => {
    //   block [0x822E3C90..0x822E3C94)
	// 822E3C90: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	pc = 0x822E3C94; continue 'dispatch;
            }
            0x822E3C94 => {
    //   block [0x822E3C94..0x822E3CC4)
	// 822E3C94: 2F0E0000  cmpwi cr6, r14, 0
	ctx.cr[6].compare_i32(ctx.r[14].s32, 0, &mut ctx.xer);
	// 822E3C98: B17B0000  sth r11, 0(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3C9C: 409A0050  bne cr6, 0x822e3cec
	if !ctx.cr[6].eq {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E3CA0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822E3CA4: 7D081A14  add r8, r8, r3
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 822E3CA8: B17A0000  sth r11, 0(r26)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3CAC: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 822E3CB0: 41980014  blt cr6, 0x822e3cc4
	if ctx.cr[6].lt {
	pc = 0x822E3CC4; continue 'dispatch;
	}
	// 822E3CB4: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 822E3CB8: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 822E3CBC: 41990008  bgt cr6, 0x822e3cc4
	if ctx.cr[6].gt {
	pc = 0x822E3CC4; continue 'dispatch;
	}
	// 822E3CC0: B1710000  sth r11, 0(r17)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	pc = 0x822E3CC4; continue 'dispatch;
            }
            0x822E3CC4 => {
    //   block [0x822E3CC4..0x822E3CEC)
	// 822E3CC4: 7F0A1800  cmpw cr6, r10, r3
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[3].s32, &mut ctx.xer);
	// 822E3CC8: 41980024  blt cr6, 0x822e3cec
	if ctx.cr[6].lt {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E3CCC: 7F0AF000  cmpw cr6, r10, r30
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822E3CD0: 4199001C  bgt cr6, 0x822e3cec
	if ctx.cr[6].gt {
	pc = 0x822E3CEC; continue 'dispatch;
	}
	// 822E3CD4: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 822E3CD8: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3CDC: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822E3CE0: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 822E3CE4: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 822E3CE8: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	pc = 0x822E3CEC; continue 'dispatch;
            }
            0x822E3CEC => {
    //   block [0x822E3CEC..0x822E3CF4)
	// 822E3CEC: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 822E3CF0: 482513E0  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E3CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E3CF8 size=388
    let mut pc: u32 = 0x822E3CF8;
    'dispatch: loop {
        match pc {
            0x822E3CF8 => {
    //   block [0x822E3CF8..0x822E3D70)
	// 822E3CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E3CFC: 482513B9  bl 0x825350b4
	ctx.lr = 0x822E3D00;
	sub_82535080(ctx, base);
	// 822E3D00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E3D04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E3D08: 3F7E0002  addis r27, r30, 2
	ctx.r[27].s64 = ctx.r[30].s64 + 131072;
	// 822E3D0C: 3B7BE2D4  addi r27, r27, -0x1d2c
	ctx.r[27].s64 = ctx.r[27].s64 + -7468;
	// 822E3D10: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E3D14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E3D18: 419A015C  beq cr6, 0x822e3e74
	if ctx.cr[6].eq {
	pc = 0x822E3E74; continue 'dispatch;
	}
	// 822E3D1C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E3D20: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E3D24: 617DF318  ori r29, r11, 0xf318
	ctx.r[29].u64 = ctx.r[11].u64 | 62232;
	// 822E3D28: 3D7E0002  addis r11, r30, 2
	ctx.r[11].s64 = ctx.r[30].s64 + 131072;
	// 822E3D2C: 6149EECA  ori r9, r10, 0xeeca
	ctx.r[9].u64 = ctx.r[10].u64 | 61130;
	// 822E3D30: 396BFAF8  addi r11, r11, -0x508
	ctx.r[11].s64 = ctx.r[11].s64 + -1288;
	// 822E3D34: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E3D38: 1D4A0458  mulli r10, r10, 0x458
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 1112 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822E3D3C: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 822E3D40: 7C8AE92E  stwx r4, r10, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32), ctx.r[4].u32) };
	// 822E3D44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E3D48: 1D6B0458  mulli r11, r11, 0x458
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E3D4C: 7F8BF214  add r28, r11, r30
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822E3D50: 7D7C4A2E  lhzx r11, r28, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E3D54: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 822E3D58: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E3D5C: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 822E3D60: 617FFB1C  ori r31, r11, 0xfb1c
	ctx.r[31].u64 = ctx.r[11].u64 | 64284;
	// 822E3D64: 4199000C  bgt cr6, 0x822e3d70
	if ctx.cr[6].gt {
	pc = 0x822E3D70; continue 'dispatch;
	}
	// 822E3D68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E3D6C: 48000014  b 0x822e3d80
	pc = 0x822E3D80; continue 'dispatch;
            }
            0x822E3D70 => {
    //   block [0x822E3D70..0x822E3D80)
	// 822E3D70: 7C7EF82E  lwzx r3, r30, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822E3D74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E3D78: 419A0008  beq cr6, 0x822e3d80
	if ctx.cr[6].eq {
	pc = 0x822E3D80; continue 'dispatch;
	}
	// 822E3D7C: 4BFFBFBD  bl 0x822dfd38
	ctx.lr = 0x822E3D80;
	sub_822DFD38(ctx, base);
	pc = 0x822E3D80; continue 'dispatch;
            }
            0x822E3D80 => {
    //   block [0x822E3D80..0x822E3D94)
	// 822E3D80: 7D7CE82E  lwzx r11, r28, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 822E3D84: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822E3D88: 419A000C  beq cr6, 0x822e3d94
	if ctx.cr[6].eq {
	pc = 0x822E3D94; continue 'dispatch;
	}
	// 822E3D8C: 8143003C  lwz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 822E3D90: 48000008  b 0x822e3d98
	pc = 0x822E3D98; continue 'dispatch;
            }
            0x822E3D94 => {
    //   block [0x822E3D94..0x822E3D98)
	// 822E3D94: 81430040  lwz r10, 0x40(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	pc = 0x822E3D98; continue 'dispatch;
            }
            0x822E3D98 => {
    //   block [0x822E3D98..0x822E3E04)
	// 822E3D98: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E3D9C: 7D7EF82E  lwzx r11, r30, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822E3DA0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822E3DA4: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E3DA8: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822E3DAC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822E3DB0: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 822E3DB4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E3DB8: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 822E3DBC: 612994C8  ori r9, r9, 0x94c8
	ctx.r[9].u64 = ctx.r[9].u64 | 38088;
	// 822E3DC0: 394ABFF0  addi r10, r10, -0x4010
	ctx.r[10].s64 = ctx.r[10].s64 + -16400;
	// 822E3DC4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E3DC8: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E3DCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E3DD0: 419A009C  beq cr6, 0x822e3e6c
	if ctx.cr[6].eq {
	pc = 0x822E3E6C; continue 'dispatch;
	}
	// 822E3DD4: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E3DD8: 614AE994  ori r10, r10, 0xe994
	ctx.r[10].u64 = ctx.r[10].u64 | 59796;
	// 822E3DDC: 7D5E502E  lwzx r10, r30, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E3DE0: 2F0A0005  cmpwi cr6, r10, 5
	ctx.cr[6].compare_i32(ctx.r[10].s32, 5, &mut ctx.xer);
	// 822E3DE4: 409A0088  bne cr6, 0x822e3e6c
	if !ctx.cr[6].eq {
	pc = 0x822E3E6C; continue 'dispatch;
	}
	// 822E3DE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E3DEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E3DF0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 822E3DF4: 419A0024  beq cr6, 0x822e3e18
	if ctx.cr[6].eq {
	pc = 0x822E3E18; continue 'dispatch;
	}
	// 822E3DF8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822E3DFC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 822E3E00: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x822E3E04; continue 'dispatch;
            }
            0x822E3E04 => {
    //   block [0x822E3E04..0x822E3E18)
	// 822E3E04: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E3E08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E3E0C: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 822E3E10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E3E14: 4200FFF0  bdnz 0x822e3e04
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822E3E04; continue 'dispatch;
	}
	pc = 0x822E3E18; continue 'dispatch;
            }
            0x822E3E18 => {
    //   block [0x822E3E18..0x822E3E3C)
	// 822E3E18: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E3E1C: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E3E20: 616BE748  ori r11, r11, 0xe748
	ctx.r[11].u64 = ctx.r[11].u64 | 59208;
	// 822E3E24: 65480003  oris r8, r10, 3
	ctx.r[8].u64 = ctx.r[10].u64 | 196608;
	// 822E3E28: 6108FFFD  ori r8, r8, 0xfffd
	ctx.r[8].u64 = ctx.r[8].u64 | 65533;
	// 822E3E2C: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E3E30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E3E34: 419A0038  beq cr6, 0x822e3e6c
	if ctx.cr[6].eq {
	pc = 0x822E3E6C; continue 'dispatch;
	}
	// 822E3E38: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x822E3E3C; continue 'dispatch;
            }
            0x822E3E3C => {
    //   block [0x822E3E3C..0x822E3E58)
	// 822E3E3C: 894B0017  lbz r10, 0x17(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(23 as u32) ) } as u64;
	// 822E3E40: 7D2A5036  sld r10, r9, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = (ctx.r[9].u64) << ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 822E3E44: 7D4A4038  and r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[8].u64;
	// 822E3E48: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 822E3E4C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 822E3E50: 409A0008  bne cr6, 0x822e3e58
	if !ctx.cr[6].eq {
	pc = 0x822E3E58; continue 'dispatch;
	}
	// 822E3E54: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x822E3E58; continue 'dispatch;
            }
            0x822E3E58 => {
    //   block [0x822E3E58..0x822E3E6C)
	// 822E3E58: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822E3E5C: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 822E3E60: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822E3E64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E3E68: 409AFFD4  bne cr6, 0x822e3e3c
	if !ctx.cr[6].eq {
	pc = 0x822E3E3C; continue 'dispatch;
	}
	pc = 0x822E3E6C; continue 'dispatch;
            }
            0x822E3E6C => {
    //   block [0x822E3E6C..0x822E3E74)
	// 822E3E6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E3E70: 4BFFF569  bl 0x822e33d8
	ctx.lr = 0x822E3E74;
	sub_822E33D8(ctx, base);
	pc = 0x822E3E74; continue 'dispatch;
            }
            0x822E3E74 => {
    //   block [0x822E3E74..0x822E3E7C)
	// 822E3E74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822E3E78: 4825128C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E3E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E3E80 size=44
    let mut pc: u32 = 0x822E3E80;
    'dispatch: loop {
        match pc {
            0x822E3E80 => {
    //   block [0x822E3E80..0x822E3EAC)
	// 822E3E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E3E84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E3E88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E3E8C: A1650000  lhz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E3E90: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 822E3E94: 4BFFFE65  bl 0x822e3cf8
	ctx.lr = 0x822E3E98;
	sub_822E3CF8(ctx, base);
	// 822E3E98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E3E9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E3EA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E3EA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E3EA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E3EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E3EB0 size=456
    let mut pc: u32 = 0x822E3EB0;
    'dispatch: loop {
        match pc {
            0x822E3EB0 => {
    //   block [0x822E3EB0..0x822E3F94)
	// 822E3EB0: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 822E3EB4: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 822E3EB8: 616AA9C0  ori r10, r11, 0xa9c0
	ctx.r[10].u64 = ctx.r[11].u64 | 43456;
	// 822E3EBC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E3EC0: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 822E3EC4: 6169EB1B  ori r9, r11, 0xeb1b
	ctx.r[9].u64 = ctx.r[11].u64 | 60187;
	// 822E3EC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E3ECC: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 822E3ED0: 7D43502E  lwzx r10, r3, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E3ED4: 6108EB22  ori r8, r8, 0xeb22
	ctx.r[8].u64 = ctx.r[8].u64 | 60194;
	// 822E3ED8: 60E7EB39  ori r7, r7, 0xeb39
	ctx.r[7].u64 = ctx.r[7].u64 | 60217;
	// 822E3EDC: 60C6EB23  ori r6, r6, 0xeb23
	ctx.r[6].u64 = ctx.r[6].u64 | 60195;
	// 822E3EE0: 7D6349AE  stbx r11, r3, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u8) };
	// 822E3EE4: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E3EE8: 3CA00001  lis r5, 1
	ctx.r[5].s64 = 65536;
	// 822E3EEC: 6129EB21  ori r9, r9, 0xeb21
	ctx.r[9].u64 = ctx.r[9].u64 | 60193;
	// 822E3EF0: 7D6341AE  stbx r11, r3, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u8) };
	// 822E3EF4: 7D6339AE  stbx r11, r3, r7
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u8) };
	// 822E3EF8: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 822E3EFC: 7D6331AE  stbx r11, r3, r6
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u8) };
	// 822E3F00: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 822E3F04: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 822E3F08: 6108E304  ori r8, r8, 0xe304
	ctx.r[8].u64 = ctx.r[8].u64 | 58116;
	// 822E3F0C: 7D6349AE  stbx r11, r3, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u8) };
	// 822E3F10: 60E7E308  ori r7, r7, 0xe308
	ctx.r[7].u64 = ctx.r[7].u64 | 58120;
	// 822E3F14: 60C6E314  ori r6, r6, 0xe314
	ctx.r[6].u64 = ctx.r[6].u64 | 58132;
	// 822E3F18: 60A5E2D4  ori r5, r5, 0xe2d4
	ctx.r[5].u64 = ctx.r[5].u64 | 58068;
	// 822E3F1C: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 822E3F20: 7D63412E  stwx r11, r3, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 822E3F24: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 822E3F28: 7D63392E  stwx r11, r3, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 822E3F2C: 3CE00005  lis r7, 5
	ctx.r[7].s64 = 327680;
	// 822E3F30: 6108E2D8  ori r8, r8, 0xe2d8
	ctx.r[8].u64 = ctx.r[8].u64 | 58072;
	// 822E3F34: 7D63292E  stwx r11, r3, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[5].u32), ctx.r[11].u32) };
	// 822E3F38: 3CA00001  lis r5, 1
	ctx.r[5].s64 = 65536;
	// 822E3F3C: 7D23312E  stwx r9, r3, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[6].u32), ctx.r[9].u32) };
	// 822E3F40: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 822E3F44: 60E79224  ori r7, r7, 0x9224
	ctx.r[7].u64 = ctx.r[7].u64 | 37412;
	// 822E3F48: 60C6F318  ori r6, r6, 0xf318
	ctx.r[6].u64 = ctx.r[6].u64 | 62232;
	// 822E3F4C: 60A5F770  ori r5, r5, 0xf770
	ctx.r[5].u64 = ctx.r[5].u64 | 63344;
	// 822E3F50: 7D63412E  stwx r11, r3, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 822E3F54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E3F58: 7D233B2E  sthx r9, r3, r7
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[7].u32), ctx.r[9].u16) };
	// 822E3F5C: 7D63312E  stwx r11, r3, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 822E3F60: 7D63292E  stwx r11, r3, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[5].u32), ctx.r[11].u32) };
	// 822E3F64: 419A0030  beq cr6, 0x822e3f94
	if ctx.cr[6].eq {
	pc = 0x822E3F94; continue 'dispatch;
	}
	// 822E3F68: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E3F6C: 6129BEBA  ori r9, r9, 0xbeba
	ctx.r[9].u64 = ctx.r[9].u64 | 48826;
	// 822E3F70: 7D2A4A2E  lhzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E3F74: 2B090005  cmplwi cr6, r9, 5
	ctx.cr[6].compare_u32(ctx.r[9].u32, 5 as u32, &mut ctx.xer);
	// 822E3F78: 409A001C  bne cr6, 0x822e3f94
	if !ctx.cr[6].eq {
	pc = 0x822E3F94; continue 'dispatch;
	}
	// 822E3F7C: 3D4A0002  addis r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 131072;
	// 822E3F80: 394AED3A  addi r10, r10, -0x12c6
	ctx.r[10].s64 = ctx.r[10].s64 + -4806;
	// 822E3F84: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E3F88: 2B09000C  cmplwi cr6, r9, 0xc
	ctx.cr[6].compare_u32(ctx.r[9].u32, 12 as u32, &mut ctx.xer);
	// 822E3F8C: 409A0008  bne cr6, 0x822e3f94
	if !ctx.cr[6].eq {
	pc = 0x822E3F94; continue 'dispatch;
	}
	// 822E3F90: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	pc = 0x822E3F94; continue 'dispatch;
            }
            0x822E3F94 => {
    //   block [0x822E3F94..0x822E4000)
	// 822E3F94: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 822E3F98: 3D200005  lis r9, 5
	ctx.r[9].s64 = 327680;
	// 822E3F9C: 614A922C  ori r10, r10, 0x922c
	ctx.r[10].u64 = ctx.r[10].u64 | 37420;
	// 822E3FA0: 61299230  ori r9, r9, 0x9230
	ctx.r[9].u64 = ctx.r[9].u64 | 37424;
	// 822E3FA4: 3D000005  lis r8, 5
	ctx.r[8].s64 = 327680;
	// 822E3FA8: 61089234  ori r8, r8, 0x9234
	ctx.r[8].u64 = ctx.r[8].u64 | 37428;
	// 822E3FAC: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 822E3FB0: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 822E3FB4: 7D63492E  stwx r11, r3, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u32) };
	// 822E3FB8: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 822E3FBC: 394ABFF0  addi r10, r10, -0x4010
	ctx.r[10].s64 = ctx.r[10].s64 + -16400;
	// 822E3FC0: 612994C8  ori r9, r9, 0x94c8
	ctx.r[9].u64 = ctx.r[9].u64 | 38088;
	// 822E3FC4: 7D63412E  stwx r11, r3, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 822E3FC8: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E3FCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E3FD0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822E3FD4: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E3FD8: 614AE994  ori r10, r10, 0xe994
	ctx.r[10].u64 = ctx.r[10].u64 | 59796;
	// 822E3FDC: 7D43502E  lwzx r10, r3, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E3FE0: 2F0A0005  cmpwi cr6, r10, 5
	ctx.cr[6].compare_i32(ctx.r[10].s32, 5, &mut ctx.xer);
	// 822E3FE4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 822E3FE8: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E3FEC: 614AE748  ori r10, r10, 0xe748
	ctx.r[10].u64 = ctx.r[10].u64 | 59208;
	// 822E3FF0: 7D43502E  lwzx r10, r3, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E3FF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E3FF8: 419A0040  beq cr6, 0x822e4038
	if ctx.cr[6].eq {
	pc = 0x822E4038; continue 'dispatch;
	}
	// 822E3FFC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x822E4000; continue 'dispatch;
            }
            0x822E4000 => {
    //   block [0x822E4000..0x822E4024)
	// 822E4000: 892A0017  lbz r9, 0x17(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(23 as u32) ) } as u64;
	// 822E4004: 7D094836  sld r9, r8, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = (ctx.r[8].u64) << ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 822E4008: 552903BE  clrlwi r9, r9, 0xe
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0003FFFFu64;
	// 822E400C: 552907FA  rlwinm r9, r9, 0, 0x1f, 0x1d
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 822E4010: 79290020  clrldi r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 822E4014: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 822E4018: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 822E401C: 409A0008  bne cr6, 0x822e4024
	if !ctx.cr[6].eq {
	pc = 0x822E4024; continue 'dispatch;
	}
	// 822E4020: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x822E4024; continue 'dispatch;
            }
            0x822E4024 => {
    //   block [0x822E4024..0x822E4038)
	// 822E4024: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 822E4028: B12A0014  sth r9, 0x14(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	// 822E402C: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 822E4030: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E4034: 409AFFCC  bne cr6, 0x822e4000
	if !ctx.cr[6].eq {
	pc = 0x822E4000; continue 'dispatch;
	}
	pc = 0x822E4038; continue 'dispatch;
            }
            0x822E4038 => {
    //   block [0x822E4038..0x822E4058)
	// 822E4038: 3D430002  addis r10, r3, 2
	ctx.r[10].s64 = ctx.r[3].s64 + 131072;
	// 822E403C: 394AE338  addi r10, r10, -0x1cc8
	ctx.r[10].s64 = ctx.r[10].s64 + -7368;
	// 822E4040: 812A040C  lwz r9, 0x40c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1036 as u32) ) } as u64;
	// 822E4044: 2F090015  cmpwi cr6, r9, 0x15
	ctx.cr[6].compare_i32(ctx.r[9].s32, 21, &mut ctx.xer);
	// 822E4048: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 822E404C: 814A0410  lwz r10, 0x410(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1040 as u32) ) } as u64;
	// 822E4050: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E4054: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x822E4058; continue 'dispatch;
            }
            0x822E4058 => {
    //   block [0x822E4058..0x822E4068)
	// 822E4058: 892A0017  lbz r9, 0x17(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(23 as u32) ) } as u64;
	// 822E405C: 2B090015  cmplwi cr6, r9, 0x15
	ctx.cr[6].compare_u32(ctx.r[9].u32, 21 as u32, &mut ctx.xer);
	// 822E4060: 409A0008  bne cr6, 0x822e4068
	if !ctx.cr[6].eq {
	pc = 0x822E4068; continue 'dispatch;
	}
	// 822E4064: B16A0014  sth r11, 0x14(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	pc = 0x822E4068; continue 'dispatch;
            }
            0x822E4068 => {
    //   block [0x822E4068..0x822E4078)
	// 822E4068: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 822E406C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E4070: 409AFFE8  bne cr6, 0x822e4058
	if !ctx.cr[6].eq {
	pc = 0x822E4058; continue 'dispatch;
	}
	// 822E4074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E4078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E4078 size=204
    let mut pc: u32 = 0x822E4078;
    'dispatch: loop {
        match pc {
            0x822E4078 => {
    //   block [0x822E4078..0x822E40BC)
	// 822E4078: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 822E407C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E4080: 616BA9C0  ori r11, r11, 0xa9c0
	ctx.r[11].u64 = ctx.r[11].u64 | 43456;
	// 822E4084: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E4088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E408C: 419A0030  beq cr6, 0x822e40bc
	if ctx.cr[6].eq {
	pc = 0x822E40BC; continue 'dispatch;
	}
	// 822E4090: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E4094: 6129BEBA  ori r9, r9, 0xbeba
	ctx.r[9].u64 = ctx.r[9].u64 | 48826;
	// 822E4098: 7D2B4A2E  lhzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E409C: 2B090005  cmplwi cr6, r9, 5
	ctx.cr[6].compare_u32(ctx.r[9].u32, 5 as u32, &mut ctx.xer);
	// 822E40A0: 409A001C  bne cr6, 0x822e40bc
	if !ctx.cr[6].eq {
	pc = 0x822E40BC; continue 'dispatch;
	}
	// 822E40A4: 3D6B0002  addis r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 131072;
	// 822E40A8: 396BED3A  addi r11, r11, -0x12c6
	ctx.r[11].s64 = ctx.r[11].s64 + -4806;
	// 822E40AC: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E40B0: 2B09000C  cmplwi cr6, r9, 0xc
	ctx.cr[6].compare_u32(ctx.r[9].u32, 12 as u32, &mut ctx.xer);
	// 822E40B4: 409A0008  bne cr6, 0x822e40bc
	if !ctx.cr[6].eq {
	pc = 0x822E40BC; continue 'dispatch;
	}
	// 822E40B8: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	pc = 0x822E40BC; continue 'dispatch;
            }
            0x822E40BC => {
    //   block [0x822E40BC..0x822E4130)
	// 822E40BC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E40C0: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E40C4: 616BE304  ori r11, r11, 0xe304
	ctx.r[11].u64 = ctx.r[11].u64 | 58116;
	// 822E40C8: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 822E40CC: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 822E40D0: 6129EB22  ori r9, r9, 0xeb22
	ctx.r[9].u64 = ctx.r[9].u64 | 60194;
	// 822E40D4: 6108EB39  ori r8, r8, 0xeb39
	ctx.r[8].u64 = ctx.r[8].u64 | 60217;
	// 822E40D8: 60E7EB23  ori r7, r7, 0xeb23
	ctx.r[7].u64 = ctx.r[7].u64 | 60195;
	// 822E40DC: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E40E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E40E4: 7D4349AE  stbx r10, r3, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u8) };
	// 822E40E8: 7D4341AE  stbx r10, r3, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u8) };
	// 822E40EC: 7D4339AE  stbx r10, r3, r7
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[7].u32), ctx.r[10].u8) };
	// 822E40F0: 419A0040  beq cr6, 0x822e4130
	if ctx.cr[6].eq {
	pc = 0x822E4130; continue 'dispatch;
	}
	// 822E40F4: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E40F8: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E40FC: 614AE2D4  ori r10, r10, 0xe2d4
	ctx.r[10].u64 = ctx.r[10].u64 | 58068;
	// 822E4100: 6129E2D8  ori r9, r9, 0xe2d8
	ctx.r[9].u64 = ctx.r[9].u64 | 58072;
	// 822E4104: 3D000005  lis r8, 5
	ctx.r[8].s64 = 327680;
	// 822E4108: 3CE00005  lis r7, 5
	ctx.r[7].s64 = 327680;
	// 822E410C: 3CC00005  lis r6, 5
	ctx.r[6].s64 = 327680;
	// 822E4110: 7D43502E  lwzx r10, r3, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4114: 6108922C  ori r8, r8, 0x922c
	ctx.r[8].u64 = ctx.r[8].u64 | 37420;
	// 822E4118: 7D23482E  lwzx r9, r3, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E411C: 60E79230  ori r7, r7, 0x9230
	ctx.r[7].u64 = ctx.r[7].u64 | 37424;
	// 822E4120: 60C69234  ori r6, r6, 0x9234
	ctx.r[6].u64 = ctx.r[6].u64 | 37428;
	// 822E4124: 7D63412E  stwx r11, r3, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 822E4128: 7D43392E  stwx r10, r3, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[7].u32), ctx.r[10].u32) };
	// 822E412C: 7D23312E  stwx r9, r3, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[6].u32), ctx.r[9].u32) };
	pc = 0x822E4130; continue 'dispatch;
            }
            0x822E4130 => {
    //   block [0x822E4130..0x822E4144)
	// 822E4130: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 822E4134: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822E4138: 616B9228  ori r11, r11, 0x9228
	ctx.r[11].u64 = ctx.r[11].u64 | 37416;
	// 822E413C: 7D43592E  stwx r10, r3, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 822E4140: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E4148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E4148 size=164
    let mut pc: u32 = 0x822E4148;
    'dispatch: loop {
        match pc {
            0x822E4148 => {
    //   block [0x822E4148..0x822E41D0)
	// 822E4148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E414C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E4150: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E4154: 3C830006  addis r4, r3, 6
	ctx.r[4].s64 = ctx.r[3].s64 + 393216;
	// 822E4158: 38849228  addi r4, r4, -0x6dd8
	ctx.r[4].s64 = ctx.r[4].s64 + -28120;
	// 822E415C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E4160: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822E4164: 419A006C  beq cr6, 0x822e41d0
	if ctx.cr[6].eq {
	pc = 0x822E41D0; continue 'dispatch;
	}
	// 822E4168: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 822E416C: 409A0070  bne cr6, 0x822e41dc
	if !ctx.cr[6].eq {
	pc = 0x822E41DC; continue 'dispatch;
	}
	// 822E4170: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E4174: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 822E4178: 616AEB22  ori r10, r11, 0xeb22
	ctx.r[10].u64 = ctx.r[11].u64 | 60194;
	// 822E417C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E4180: 6129EB39  ori r9, r9, 0xeb39
	ctx.r[9].u64 = ctx.r[9].u64 | 60217;
	// 822E4184: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 822E4188: 3CE00005  lis r7, 5
	ctx.r[7].s64 = 327680;
	// 822E418C: 6108EB23  ori r8, r8, 0xeb23
	ctx.r[8].u64 = ctx.r[8].u64 | 60195;
	// 822E4190: 7D6351AE  stbx r11, r3, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u8) };
	// 822E4194: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 822E4198: 7D6349AE  stbx r11, r3, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u8) };
	// 822E419C: 3D200005  lis r9, 5
	ctx.r[9].s64 = 327680;
	// 822E41A0: 60E7922C  ori r7, r7, 0x922c
	ctx.r[7].u64 = ctx.r[7].u64 | 37420;
	// 822E41A4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E41A8: 614A9230  ori r10, r10, 0x9230
	ctx.r[10].u64 = ctx.r[10].u64 | 37424;
	// 822E41AC: 61299234  ori r9, r9, 0x9234
	ctx.r[9].u64 = ctx.r[9].u64 | 37428;
	// 822E41B0: 7D6341AE  stbx r11, r3, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u8) };
	// 822E41B4: 7D63392E  stwx r11, r3, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 822E41B8: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 822E41BC: 7D63492E  stwx r11, r3, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u32) };
	// 822E41C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E41C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E41C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E41CC: 4E800020  blr
	return;
            }
            0x822E41D0 => {
    //   block [0x822E41D0..0x822E41DC)
	// 822E41D0: 4BFFFCE1  bl 0x822e3eb0
	ctx.lr = 0x822E41D4;
	sub_822E3EB0(ctx, base);
	// 822E41D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E41D8: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x822E41DC; continue 'dispatch;
            }
            0x822E41DC => {
    //   block [0x822E41DC..0x822E41EC)
	// 822E41DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E41E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E41E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E41E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E41F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E41F0 size=232
    let mut pc: u32 = 0x822E41F0;
    'dispatch: loop {
        match pc {
            0x822E41F0 => {
    //   block [0x822E41F0..0x822E4274)
	// 822E41F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E41F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E41F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E41FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E4200: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E4204: 39442A44  addi r10, r4, 0x2a44
	ctx.r[10].s64 = ctx.r[4].s64 + 10820;
	// 822E4208: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E420C: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E4210: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822E4214: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E4218: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E421C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E4220: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E4224: 409A0098  bne cr6, 0x822e42bc
	if !ctx.cr[6].eq {
	pc = 0x822E42BC; continue 'dispatch;
	}
	// 822E4228: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 822E422C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822E4230: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E4234: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E4238: 4E800421  bctrl
	ctx.lr = 0x822E423C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E423C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E4240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E4244: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 822E4248: C05F0038  lfs f2, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822E424C: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E4250: C03F0030  lfs f1, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E4254: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 822E4258: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822E425C: 40990018  ble cr6, 0x822e4274
	if !ctx.cr[6].gt {
	pc = 0x822E4274; continue 'dispatch;
	}
	// 822E4260: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E4264: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 822E4268: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E426C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E4270: 41990008  bgt cr6, 0x822e4278
	if ctx.cr[6].gt {
	pc = 0x822E4278; continue 'dispatch;
	}
            }
            0x822E4274 => {
    //   block [0x822E4274..0x822E4278)
	// 822E4274: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822E4278; continue 'dispatch;
            }
            0x822E4278 => {
    //   block [0x822E4278..0x822E4290)
	// 822E4278: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E427C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E4280: 409A0010  bne cr6, 0x822e4290
	if !ctx.cr[6].eq {
	pc = 0x822E4290; continue 'dispatch;
	}
	// 822E4284: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E4288: 4BED3241  bl 0x821b74c8
	ctx.lr = 0x822E428C;
	sub_821B74C8(ctx, base);
	// 822E428C: 48000018  b 0x822e42a4
	pc = 0x822E42A4; continue 'dispatch;
            }
            0x822E4290 => {
    //   block [0x822E4290..0x822E42A4)
	// 822E4290: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E4294: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E4298: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822E429C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822E42A0: 4BED3291  bl 0x821b7530
	ctx.lr = 0x822E42A4;
	sub_821B7530(ctx, base);
	pc = 0x822E42A4; continue 'dispatch;
            }
            0x822E42A4 => {
    //   block [0x822E42A4..0x822E42BC)
	// 822E42A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E42A8: D03E0008  stfs f1, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E42AC: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E42B0: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 822E42B4: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822E42B8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x822E42BC; continue 'dispatch;
            }
            0x822E42BC => {
    //   block [0x822E42BC..0x822E42D8)
	// 822E42BC: C03E0004  lfs f1, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E42C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E42C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E42C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E42CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E42D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E42D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E42D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E42D8 size=68
    let mut pc: u32 = 0x822E42D8;
    'dispatch: loop {
        match pc {
            0x822E42D8 => {
    //   block [0x822E42D8..0x822E42F4)
	// 822E42D8: 1D640160  mulli r11, r4, 0x160
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 352 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E42DC: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822E42E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E42E4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822E42E8: 3D4A0006  addis r10, r10, 6
	ctx.r[10].s64 = ctx.r[10].s64 + 393216;
	// 822E42EC: 394A8830  addi r10, r10, -0x77d0
	ctx.r[10].s64 = ctx.r[10].s64 + -30672;
	// 822E42F0: 394A0094  addi r10, r10, 0x94
	ctx.r[10].s64 = ctx.r[10].s64 + 148;
	pc = 0x822E42F4; continue 'dispatch;
            }
            0x822E42F4 => {
    //   block [0x822E42F4..0x822E4308)
	// 822E42F4: 7D285830  slw r8, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 822E42F8: 7D083038  and r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 & ctx.r[6].u64;
	// 822E42FC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822E4300: 419A0008  beq cr6, 0x822e4308
	if ctx.cr[6].eq {
	pc = 0x822E4308; continue 'dispatch;
	}
	// 822E4304: D02A0000  stfs f1, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x822E4308; continue 'dispatch;
            }
            0x822E4308 => {
    //   block [0x822E4308..0x822E431C)
	// 822E4308: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E430C: 394A00B0  addi r10, r10, 0xb0
	ctx.r[10].s64 = ctx.r[10].s64 + 176;
	// 822E4310: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822E4314: 4198FFE0  blt cr6, 0x822e42f4
	if ctx.cr[6].lt {
	pc = 0x822E42F4; continue 'dispatch;
	}
	// 822E4318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E4320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E4320 size=312
    let mut pc: u32 = 0x822E4320;
    'dispatch: loop {
        match pc {
            0x822E4320 => {
    //   block [0x822E4320..0x822E43A4)
	// 822E4320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E4324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E4328: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E432C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E4330: 1D640458  mulli r11, r4, 0x458
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 1112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E4334: FD800890  fmr f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ctx.f[1].f64;
	// 822E4338: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822E433C: 90E100A4  stw r7, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 822E4340: 1D640160  mulli r11, r4, 0x160
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 352 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E4344: 3FEA0002  addis r31, r10, 2
	ctx.r[31].s64 = ctx.r[10].s64 + 131072;
	// 822E4348: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822E434C: 3BFFEEC8  addi r31, r31, -0x1138
	ctx.r[31].s64 = ctx.r[31].s64 + -4408;
	// 822E4350: 3D2B0002  addis r9, r11, 2
	ctx.r[9].s64 = ctx.r[11].s64 + 131072;
	// 822E4354: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 822E4358: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E435C: 3929F780  addi r9, r9, -0x880
	ctx.r[9].s64 = ctx.r[9].s64 + -2176;
	// 822E4360: 4BFFECB9  bl 0x822e3018
	ctx.lr = 0x822E4364;
	sub_822E3018(ctx, base);
	// 822E4364: 396100A4  addi r11, r1, 0xa4
	ctx.r[11].s64 = ctx.r[1].s64 + 164;
	// 822E4368: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 822E436C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822E4370: 80E100A4  lwz r7, 0xa4(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 822E4374: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 822E4378: 409A002C  bne cr6, 0x822e43a4
	if !ctx.cr[6].eq {
	pc = 0x822E43A4; continue 'dispatch;
	}
	// 822E437C: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E4380: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822E4384: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E4388: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E438C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822E4390: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822E4394: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E4398: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 822E439C: 41990008  bgt cr6, 0x822e43a4
	if ctx.cr[6].gt {
	pc = 0x822E43A4; continue 'dispatch;
	}
	// 822E43A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x822E43A4; continue 'dispatch;
            }
            0x822E43A4 => {
    //   block [0x822E43A4..0x822E43B8)
	// 822E43A4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E43A8: 39690092  addi r11, r9, 0x92
	ctx.r[11].s64 = ctx.r[9].s64 + 146;
	// 822E43AC: 7CC80734  extsh r8, r6
	ctx.r[8].s64 = ctx.r[6].s16 as i64;
	// 822E43B0: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 822E43B4: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x822E43B8; continue 'dispatch;
            }
            0x822E43B8 => {
    //   block [0x822E43B8..0x822E4400)
	// 822E43B8: 7D0A0734  extsh r10, r8
	ctx.r[10].s64 = ctx.r[8].s16 as i64;
	// 822E43BC: D18B0012  stfs f12, 0x12(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), tmp.u32 ) };
	// 822E43C0: B10B0000  sth r8, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 822E43C4: 90EB0006  stw r7, 6(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[7].u32 ) };
	// 822E43C8: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E43CC: D1AB0016  stfs f13, 0x16(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(22 as u32), tmp.u32 ) };
	// 822E43D0: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 822E43D4: 41990060  bgt cr6, 0x822e4434
	if ctx.cr[6].gt {
	pc = 0x822E4434; continue 'dispatch;
	}
	// 822E43D8: 3D80822E  lis r12, -0x7dd2
	ctx.r[12].s64 = -2110914560;
	// 822E43DC: 398C43F0  addi r12, r12, 0x43f0
	ctx.r[12].s64 = ctx.r[12].s64 + 17392;
	// 822E43E0: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 822E43E4: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 822E43E8: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 822E43EC: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x822E4400; continue 'dispatch;
		},
		1 => {
	pc = 0x822E4430; continue 'dispatch;
		},
		2 => {
	pc = 0x822E4408; continue 'dispatch;
		},
		3 => {
	pc = 0x822E4428; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 822E43F0: 822E4400  lwz r17, 0x4400(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(17408 as u32) ) } as u64;
	// 822E43F4: 822E4430  lwz r17, 0x4430(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(17456 as u32) ) } as u64;
	// 822E43F8: 822E4408  lwz r17, 0x4408(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(17416 as u32) ) } as u64;
	// 822E43FC: 822E4428  lwz r17, 0x4428(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(17448 as u32) ) } as u64;
            }
            0x822E4400 => {
    //   block [0x822E4400..0x822E4408)
	// 822E4400: D00B0002  stfs f0, 2(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), tmp.u32 ) };
	// 822E4404: 48000030  b 0x822e4434
	pc = 0x822E4434; continue 'dispatch;
            }
            0x822E4408 => {
    //   block [0x822E4408..0x822E4428)
	// 822E4408: 7CEA07B4  extsw r10, r7
	ctx.r[10].s64 = ctx.r[7].s32 as i64;
	// 822E440C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 822E4410: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E4414: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E4418: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E441C: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 822E4420: D1AB000A  stfs f13, 0xa(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), tmp.u32 ) };
	// 822E4424: 48000010  b 0x822e4434
	pc = 0x822E4434; continue 'dispatch;
            }
            0x822E4428 => {
    //   block [0x822E4428..0x822E4430)
	// 822E4428: D04B000E  stfs f2, 0xe(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(14 as u32), tmp.u32 ) };
	// 822E442C: 48000008  b 0x822e4434
	pc = 0x822E4434; continue 'dispatch;
            }
            0x822E4430 => {
    //   block [0x822E4430..0x822E4434)
	// 822E4430: D18B0002  stfs f12, 2(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), tmp.u32 ) };
	pc = 0x822E4434; continue 'dispatch;
            }
            0x822E4434 => {
    //   block [0x822E4434..0x822E4458)
	// 822E4434: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 822E4438: 396B00B0  addi r11, r11, 0xb0
	ctx.r[11].s64 = ctx.r[11].s64 + 176;
	// 822E443C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822E4440: 409AFF78  bne cr6, 0x822e43b8
	if !ctx.cr[6].eq {
	pc = 0x822E43B8; continue 'dispatch;
	}
	// 822E4444: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E4448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E444C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E4450: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E4454: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E4458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E4458 size=312
    let mut pc: u32 = 0x822E4458;
    'dispatch: loop {
        match pc {
            0x822E4458 => {
    //   block [0x822E4458..0x822E4528)
	// 822E4458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E445C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E4460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E4464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E4468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E446C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822E4470: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 822E4474: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 822E4478: A1460002  lhz r10, 2(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E447C: A1260004  lhz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E4480: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 822E4484: 6108FAF0  ori r8, r8, 0xfaf0
	ctx.r[8].u64 = ctx.r[8].u64 | 64240;
	// 822E4488: 7D450734  extsh r5, r10
	ctx.r[5].s64 = ctx.r[10].s16 as i64;
	// 822E448C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822E4490: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E4494: 39658001  addi r11, r5, -0x7fff
	ctx.r[11].s64 = ctx.r[5].s64 + -32767;
	// 822E4498: 39498001  addi r10, r9, -0x7fff
	ctx.r[10].s64 = ctx.r[9].s64 + -32767;
	// 822E449C: 7D03402E  lwzx r8, r3, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 822E44A0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822E44A4: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 822E44A8: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 822E44AC: 555EDFFE  rlwinm r30, r10, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822E44B0: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E44B4: 7CDF0734  extsh r31, r6
	ctx.r[31].s64 = ctx.r[6].s16 as i64;
	// 822E44B8: 5566DFFE  rlwinm r6, r11, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822E44BC: 4BFFEB5D  bl 0x822e3018
	ctx.lr = 0x822E44C0;
	sub_822E3018(ctx, base);
	// 822E44C0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822E44C4: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 822E44C8: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 822E44CC: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 822E44D0: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822E44D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E44D8: 7D690734  extsh r9, r11
	ctx.r[9].s64 = ctx.r[11].s16 as i64;
	// 822E44DC: 4BFFEB3D  bl 0x822e3018
	ctx.lr = 0x822E44E0;
	sub_822E3018(ctx, base);
	// 822E44E0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822E44E4: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 822E44E8: 3967FFFF  addi r11, r7, -1
	ctx.r[11].s64 = ctx.r[7].s64 + -1;
	// 822E44EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E44F0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822E44F4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 822E44F8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E44FC: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822E4500: 419A005C  beq cr6, 0x822e455c
	if ctx.cr[6].eq {
	pc = 0x822E455C; continue 'dispatch;
	}
	// 822E4504: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822E4508: 409A0070  bne cr6, 0x822e4578
	if !ctx.cr[6].eq {
	pc = 0x822E4578; continue 'dispatch;
	}
	// 822E450C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 822E4510: 409A0018  bne cr6, 0x822e4528
	if !ctx.cr[6].eq {
	pc = 0x822E4528; continue 'dispatch;
	}
	// 822E4514: 7D2B0734  extsh r11, r9
	ctx.r[11].s64 = ctx.r[9].s16 as i64;
	// 822E4518: 7FE90734  extsh r9, r31
	ctx.r[9].s64 = ctx.r[31].s16 as i64;
	// 822E451C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 822E4520: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822E4524: 41990008  bgt cr6, 0x822e452c
	if ctx.cr[6].gt {
	pc = 0x822E452C; continue 'dispatch;
	}
	pc = 0x822E4528; continue 'dispatch;
            }
            0x822E4528 => {
    //   block [0x822E4528..0x822E452C)
	// 822E4528: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x822E452C; continue 'dispatch;
            }
            0x822E452C => {
    //   block [0x822E452C..0x822E4548)
	// 822E452C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822E4530: 409A0018  bne cr6, 0x822e4548
	if !ctx.cr[6].eq {
	pc = 0x822E4548; continue 'dispatch;
	}
	// 822E4534: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 822E4538: 7FEA0734  extsh r10, r31
	ctx.r[10].s64 = ctx.r[31].s16 as i64;
	// 822E453C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822E4540: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E4544: 41990008  bgt cr6, 0x822e454c
	if ctx.cr[6].gt {
	pc = 0x822E454C; continue 'dispatch;
	}
	pc = 0x822E4548; continue 'dispatch;
            }
            0x822E4548 => {
    //   block [0x822E4548..0x822E454C)
	// 822E4548: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x822E454C; continue 'dispatch;
            }
            0x822E454C => {
    //   block [0x822E454C..0x822E455C)
	// 822E454C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822E4550: 419A0028  beq cr6, 0x822e4578
	if ctx.cr[6].eq {
	pc = 0x822E4578; continue 'dispatch;
	}
	// 822E4554: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E4558: 48000018  b 0x822e4570
	pc = 0x822E4570; continue 'dispatch;
            }
            0x822E455C => {
    //   block [0x822E455C..0x822E4570)
	// 822E455C: 7D2B0734  extsh r11, r9
	ctx.r[11].s64 = ctx.r[9].s16 as i64;
	// 822E4560: 7FEA0734  extsh r10, r31
	ctx.r[10].s64 = ctx.r[31].s16 as i64;
	// 822E4564: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822E4568: 419A000C  beq cr6, 0x822e4574
	if ctx.cr[6].eq {
	pc = 0x822E4574; continue 'dispatch;
	}
	// 822E456C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	pc = 0x822E4570; continue 'dispatch;
            }
            0x822E4570 => {
    //   block [0x822E4570..0x822E4574)
	// 822E4570: 419A0008  beq cr6, 0x822e4578
	if ctx.cr[6].eq {
	pc = 0x822E4578; continue 'dispatch;
	}
	pc = 0x822E4574; continue 'dispatch;
            }
            0x822E4574 => {
    //   block [0x822E4574..0x822E4578)
	// 822E4574: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x822E4578; continue 'dispatch;
            }
            0x822E4578 => {
    //   block [0x822E4578..0x822E4590)
	// 822E4578: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E457C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E4580: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E4584: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E4588: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E458C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E4590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E4590 size=92
    let mut pc: u32 = 0x822E4590;
    'dispatch: loop {
        match pc {
            0x822E4590 => {
    //   block [0x822E4590..0x822E45EC)
	// 822E4590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E4594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E4598: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E459C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E45A0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E45A4: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 822E45A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E45AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E45B0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 822E45B4: 57E5083C  slwi r5, r31, 1
	ctx.r[5].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 822E45B8: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 822E45BC: B1610050  sth r11, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u16 ) };
	// 822E45C0: 48250591  bl 0x82534b50
	ctx.lr = 0x822E45C4;
	sub_82534B50(ctx, base);
	// 822E45C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822E45C8: 389F0001  addi r4, r31, 1
	ctx.r[4].s64 = ctx.r[31].s64 + 1;
	// 822E45CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E45D0: 4BE4DB01  bl 0x821320d0
	ctx.lr = 0x822E45D4;
	sub_821320D0(ctx, base);
	// 822E45D4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 822E45D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E45DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E45E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E45E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E45E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E45F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E45F0 size=140
    let mut pc: u32 = 0x822E45F0;
    'dispatch: loop {
        match pc {
            0x822E45F0 => {
    //   block [0x822E45F0..0x822E4628)
	// 822E45F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E45F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E45F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E45FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E4600: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822E4604: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 822E4608: 419A0020  beq cr6, 0x822e4628
	if ctx.cr[6].eq {
	pc = 0x822E4628; continue 'dispatch;
	}
	// 822E460C: 48082DAD  bl 0x823673b8
	ctx.lr = 0x822E4610;
	sub_823673B8(ctx, base);
	// 822E4610: 5463043E  clrlwi r3, r3, 0x10
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 822E4614: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E4618: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E461C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E4620: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E4624: 4E800020  blr
	return;
            }
            0x822E4628 => {
    //   block [0x822E4628..0x822E467C)
	// 822E4628: 48082F21  bl 0x82367548
	ctx.lr = 0x822E462C;
	sub_82367548(ctx, base);
	// 822E462C: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E4630: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4634: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4638: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E463C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822E4640: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E4644: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E4648: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E464C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E4650: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E4654: C00B2314  lfs f0, 0x2314(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E4658: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E465C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822E4660: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 822E4664: A0610056  lhz r3, 0x56(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 822E4668: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E466C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E4670: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E4674: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E4678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E4680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E4680 size=292
    let mut pc: u32 = 0x822E4680;
    'dispatch: loop {
        match pc {
            0x822E4680 => {
    //   block [0x822E4680..0x822E4694)
	// 822E4680: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E4684: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822E4688: 396BA928  addi r11, r11, -0x56d8
	ctx.r[11].s64 = ctx.r[11].s64 + -22232;
	// 822E468C: 394001E0  li r10, 0x1e0
	ctx.r[10].s64 = 480;
	// 822E4690: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x822E4694; continue 'dispatch;
            }
            0x822E4694 => {
    //   block [0x822E4694..0x822E47A4)
	// 822E4694: B12B0000  sth r9, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 822E4698: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 822E469C: 4200FFF8  bdnz 0x822e4694
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822E4694; continue 'dispatch;
	}
	// 822E46A0: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 822E46A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E46A8: 396B1290  addi r11, r11, 0x1290
	ctx.r[11].s64 = ctx.r[11].s64 + 4752;
	// 822E46AC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822E46B0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822E46B4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822E46B8: C1AABA38  lfs f13, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E46BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E46C0: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822E46C4: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E46C8: 914B0030  stw r10, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 822E46CC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E46D0: C18A20C8  lfs f12, 0x20c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8392 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E46D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E46D8: D18B0010  stfs f12, 0x10(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822E46DC: 914B002C  stw r10, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 822E46E0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E46E4: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E46E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E46EC: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 822E46F0: 914B005C  stw r10, 0x5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822E46F4: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 822E46F8: 914B0058  stw r10, 0x58(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 822E46FC: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 822E4700: C16AD4CC  lfs f11, -0x2b34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11060 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E4704: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E4708: D16B001C  stfs f11, 0x1c(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 822E470C: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 822E4710: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822E4714: C14A2938  lfs f10, 0x2938(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10552 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E4718: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E471C: D14B0020  stfs f10, 0x20(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822E4720: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 822E4724: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E4728: C12A2094  lfs f9, 0x2094(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8340 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822E472C: D12B0024  stfs f9, 0x24(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822E4730: D00B0028  stfs f0, 0x28(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822E4734: D1AB0038  stfs f13, 0x38(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 822E4738: D1AB0034  stfs f13, 0x34(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 822E473C: D18B003C  stfs f12, 0x3c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 822E4740: D00B0040  stfs f0, 0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E4744: D00B0044  stfs f0, 0x44(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 822E4748: D16B0048  stfs f11, 0x48(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 822E474C: D14B004C  stfs f10, 0x4c(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 822E4750: D12B0050  stfs f9, 0x50(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822E4754: D00B0054  stfs f0, 0x54(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822E4758: D1AB0064  stfs f13, 0x64(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822E475C: D1AB0060  stfs f13, 0x60(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E4760: D18B0068  stfs f12, 0x68(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822E4764: D00B006C  stfs f0, 0x6c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822E4768: D00B0070  stfs f0, 0x70(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822E476C: D16B0074  stfs f11, 0x74(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822E4770: D14B0078  stfs f10, 0x78(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822E4774: D12B007C  stfs f9, 0x7c(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822E4778: D00B0080  stfs f0, 0x80(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 822E477C: D1AB0090  stfs f13, 0x90(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 822E4780: D1AB008C  stfs f13, 0x8c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 822E4784: D18B0094  stfs f12, 0x94(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 822E4788: D00B0098  stfs f0, 0x98(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 822E478C: D00B009C  stfs f0, 0x9c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 822E4790: D16B00A0  stfs f11, 0xa0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 822E4794: D14B00A4  stfs f10, 0xa4(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 822E4798: D12B00A8  stfs f9, 0xa8(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E479C: D00B00AC  stfs f0, 0xac(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822E47A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E47A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E47A8 size=3808
    let mut pc: u32 = 0x822E47A8;
    'dispatch: loop {
        match pc {
            0x822E47A8 => {
    //   block [0x822E47A8..0x822E47E4)
	// 822E47A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E47AC: 482508F9  bl 0x825350a4
	ctx.lr = 0x822E47B0;
	sub_82535080(ctx, base);
	// 822E47B0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E47B4: 3D608285  lis r11, -0x7d7b
	ctx.r[11].s64 = -2105212928;
	// 822E47B8: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 822E47BC: 3B2B6650  addi r25, r11, 0x6650
	ctx.r[25].s64 = ctx.r[11].s64 + 26192;
	// 822E47C0: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822E47C4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822E47C8: 3BEBA928  addi r31, r11, -0x56d8
	ctx.r[31].s64 = ctx.r[11].s64 + -22232;
	// 822E47CC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822E47D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822E47D4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 822E47D8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822E47DC: A17F03CE  lhz r11, 0x3ce(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(974 as u32) ) } as u64;
	// 822E47E0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x822E47E4; continue 'dispatch;
            }
            0x822E47E4 => {
    //   block [0x822E47E4..0x822E47F0)
	// 822E47E4: 80BF03C0  lwz r5, 0x3c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 822E47E8: 813F03D0  lwz r9, 0x3d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 822E47EC: 815F03D4  lwz r10, 0x3d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	pc = 0x822E47F0; continue 'dispatch;
            }
            0x822E47F0 => {
    //   block [0x822E47F0..0x822E490C)
	// 822E47F0: 7F7EE8AE  lbzx r27, r30, r29
	ctx.r[27].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 822E47F4: 5767067E  clrlwi r7, r27, 0x19
	ctx.r[7].u64 = ctx.r[27].u32 as u64 & 0x0000007Fu64;
	// 822E47F8: 2B07003C  cmplwi cr6, r7, 0x3c
	ctx.cr[6].compare_u32(ctx.r[7].u32, 60 as u32, &mut ctx.xer);
	// 822E47FC: 419902C0  bgt cr6, 0x822e4abc
	if ctx.cr[6].gt {
	pc = 0x822E4ABC; continue 'dispatch;
	}
	// 822E4800: 3D80822E  lis r12, -0x7dd2
	ctx.r[12].s64 = -2110914560;
	// 822E4804: 398C4818  addi r12, r12, 0x4818
	ctx.r[12].s64 = ctx.r[12].s64 + 18456;
	// 822E4808: 54E0103A  slwi r0, r7, 2
	ctx.r[0].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 822E480C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 822E4810: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 822E4814: 4E800420  bctr
	match ctx.r[7].u64 {
		0 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		1 => {
	pc = 0x822E490C; continue 'dispatch;
		},
		2 => {
	pc = 0x822E5648; continue 'dispatch;
		},
		3 => {
	pc = 0x822E4970; continue 'dispatch;
		},
		4 => {
	pc = 0x822E4970; continue 'dispatch;
		},
		5 => {
	pc = 0x822E55F0; continue 'dispatch;
		},
		6 => {
	pc = 0x822E5648; continue 'dispatch;
		},
		7 => {
	pc = 0x822E5610; continue 'dispatch;
		},
		8 => {
	pc = 0x822E5638; continue 'dispatch;
		},
		9 => {
	pc = 0x822E4990; continue 'dispatch;
		},
		10 => {
	pc = 0x822E49B0; continue 'dispatch;
		},
		11 => {
	pc = 0x822E4990; continue 'dispatch;
		},
		12 => {
	pc = 0x822E4A34; continue 'dispatch;
		},
		13 => {
	pc = 0x822E4A78; continue 'dispatch;
		},
		14 => {
	pc = 0x822E4AE8; continue 'dispatch;
		},
		15 => {
	pc = 0x822E4B2C; continue 'dispatch;
		},
		16 => {
	pc = 0x822E4B70; continue 'dispatch;
		},
		17 => {
	pc = 0x822E4BB8; continue 'dispatch;
		},
		18 => {
	pc = 0x822E4BE0; continue 'dispatch;
		},
		19 => {
	pc = 0x822E4C80; continue 'dispatch;
		},
		20 => {
	pc = 0x822E4D20; continue 'dispatch;
		},
		21 => {
	pc = 0x822E4D64; continue 'dispatch;
		},
		22 => {
	pc = 0x822E4DA8; continue 'dispatch;
		},
		23 => {
	pc = 0x822E4DD4; continue 'dispatch;
		},
		24 => {
	pc = 0x822E4E18; continue 'dispatch;
		},
		25 => {
	pc = 0x822E4E5C; continue 'dispatch;
		},
		26 => {
	pc = 0x822E4EF8; continue 'dispatch;
		},
		27 => {
	pc = 0x822E4FA8; continue 'dispatch;
		},
		28 => {
	pc = 0x822E5058; continue 'dispatch;
		},
		29 => {
	pc = 0x822E5114; continue 'dispatch;
		},
		30 => {
	pc = 0x822E51D0; continue 'dispatch;
		},
		31 => {
	pc = 0x822E52A4; continue 'dispatch;
		},
		32 => {
	pc = 0x822E52F0; continue 'dispatch;
		},
		33 => {
	pc = 0x822E5340; continue 'dispatch;
		},
		34 => {
	pc = 0x822E5390; continue 'dispatch;
		},
		35 => {
	pc = 0x822E53E0; continue 'dispatch;
		},
		36 => {
	pc = 0x822E5430; continue 'dispatch;
		},
		37 => {
	pc = 0x822E5480; continue 'dispatch;
		},
		38 => {
	pc = 0x822E5518; continue 'dispatch;
		},
		39 => {
	pc = 0x822E5544; continue 'dispatch;
		},
		40 => {
	pc = 0x822E5568; continue 'dispatch;
		},
		41 => {
	pc = 0x822E55AC; continue 'dispatch;
		},
		42 => {
	pc = 0x822E4970; continue 'dispatch;
		},
		43 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		44 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		45 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		46 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		47 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		48 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		49 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		50 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		51 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		52 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		53 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		54 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		55 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		56 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		57 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		58 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		59 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		60 => {
	pc = 0x822E4AB8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 822E4818: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E481C: 822E490C  lwz r17, 0x490c(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(18700 as u32) ) } as u64;
	// 822E4820: 822E5648  lwz r17, 0x5648(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(22088 as u32) ) } as u64;
	// 822E4824: 822E4970  lwz r17, 0x4970(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(18800 as u32) ) } as u64;
	// 822E4828: 822E4970  lwz r17, 0x4970(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(18800 as u32) ) } as u64;
	// 822E482C: 822E55F0  lwz r17, 0x55f0(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(22000 as u32) ) } as u64;
	// 822E4830: 822E5648  lwz r17, 0x5648(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(22088 as u32) ) } as u64;
	// 822E4834: 822E5610  lwz r17, 0x5610(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(22032 as u32) ) } as u64;
	// 822E4838: 822E5638  lwz r17, 0x5638(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(22072 as u32) ) } as u64;
	// 822E483C: 822E4990  lwz r17, 0x4990(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(18832 as u32) ) } as u64;
	// 822E4840: 822E49B0  lwz r17, 0x49b0(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822E4844: 822E4990  lwz r17, 0x4990(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(18832 as u32) ) } as u64;
	// 822E4848: 822E4A34  lwz r17, 0x4a34(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(18996 as u32) ) } as u64;
	// 822E484C: 822E4A78  lwz r17, 0x4a78(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19064 as u32) ) } as u64;
	// 822E4850: 822E4AE8  lwz r17, 0x4ae8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19176 as u32) ) } as u64;
	// 822E4854: 822E4B2C  lwz r17, 0x4b2c(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19244 as u32) ) } as u64;
	// 822E4858: 822E4B70  lwz r17, 0x4b70(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19312 as u32) ) } as u64;
	// 822E485C: 822E4BB8  lwz r17, 0x4bb8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19384 as u32) ) } as u64;
	// 822E4860: 822E4BE0  lwz r17, 0x4be0(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19424 as u32) ) } as u64;
	// 822E4864: 822E4C80  lwz r17, 0x4c80(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19584 as u32) ) } as u64;
	// 822E4868: 822E4D20  lwz r17, 0x4d20(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19744 as u32) ) } as u64;
	// 822E486C: 822E4D64  lwz r17, 0x4d64(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19812 as u32) ) } as u64;
	// 822E4870: 822E4DA8  lwz r17, 0x4da8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19880 as u32) ) } as u64;
	// 822E4874: 822E4DD4  lwz r17, 0x4dd4(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19924 as u32) ) } as u64;
	// 822E4878: 822E4E18  lwz r17, 0x4e18(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19992 as u32) ) } as u64;
	// 822E487C: 822E4E5C  lwz r17, 0x4e5c(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(20060 as u32) ) } as u64;
	// 822E4880: 822E4EF8  lwz r17, 0x4ef8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(20216 as u32) ) } as u64;
	// 822E4884: 822E4FA8  lwz r17, 0x4fa8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(20392 as u32) ) } as u64;
	// 822E4888: 822E5058  lwz r17, 0x5058(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(20568 as u32) ) } as u64;
	// 822E488C: 822E5114  lwz r17, 0x5114(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(20756 as u32) ) } as u64;
	// 822E4890: 822E51D0  lwz r17, 0x51d0(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(20944 as u32) ) } as u64;
	// 822E4894: 822E52A4  lwz r17, 0x52a4(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(21156 as u32) ) } as u64;
	// 822E4898: 822E52F0  lwz r17, 0x52f0(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(21232 as u32) ) } as u64;
	// 822E489C: 822E5340  lwz r17, 0x5340(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(21312 as u32) ) } as u64;
	// 822E48A0: 822E5390  lwz r17, 0x5390(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(21392 as u32) ) } as u64;
	// 822E48A4: 822E53E0  lwz r17, 0x53e0(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(21472 as u32) ) } as u64;
	// 822E48A8: 822E5430  lwz r17, 0x5430(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(21552 as u32) ) } as u64;
	// 822E48AC: 822E5480  lwz r17, 0x5480(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(21632 as u32) ) } as u64;
	// 822E48B0: 822E5518  lwz r17, 0x5518(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(21784 as u32) ) } as u64;
	// 822E48B4: 822E5544  lwz r17, 0x5544(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(21828 as u32) ) } as u64;
	// 822E48B8: 822E5568  lwz r17, 0x5568(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(21864 as u32) ) } as u64;
	// 822E48BC: 822E55AC  lwz r17, 0x55ac(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(21932 as u32) ) } as u64;
	// 822E48C0: 822E4970  lwz r17, 0x4970(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(18800 as u32) ) } as u64;
	// 822E48C4: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48C8: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48CC: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48D0: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48D4: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48D8: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48DC: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48E0: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48E4: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48E8: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48EC: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48F0: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48F4: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48F8: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E48FC: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E4900: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E4904: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
	// 822E4908: 822E4AB8  lwz r17, 0x4ab8(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(19128 as u32) ) } as u64;
            }
            0x822E490C => {
    //   block [0x822E490C..0x822E4968)
	// 822E490C: 7CFEEA14  add r7, r30, r29
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4910: 7CDEEA14  add r6, r30, r29
	ctx.r[6].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4914: 88E70001  lbz r7, 1(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E4918: 88C60002  lbz r6, 2(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E491C: 54E7403E  rotlwi r7, r7, 8
	ctx.r[7].u64 = ((ctx.r[7].u32).rotate_left(8)) as u64;
	// 822E4920: 7CFA3378  or r26, r7, r6
	ctx.r[26].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 822E4924: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 822E4928: 40990040  ble cr6, 0x822e4968
	if !ctx.cr[6].gt {
	pc = 0x822E4968; continue 'dispatch;
	}
	// 822E492C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4930: A0FF03CC  lhz r7, 0x3cc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 822E4934: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E4938: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E493C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4940: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E4944: 7D7A5850  subf r11, r26, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 822E4948: 7CE9532E  sthx r7, r9, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u16) };
	// 822E494C: 813F03D0  lwz r9, 0x3d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 822E4950: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4954: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4958: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E495C: B17F03CC  sth r11, 0x3cc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(972 as u32), ctx.r[11].u16 ) };
	// 822E4960: 815F03D4  lwz r10, 0x3d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 822E4964: 80BF03C0  lwz r5, 0x3c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	pc = 0x822E4968; continue 'dispatch;
            }
            0x822E4968 => {
    //   block [0x822E4968..0x822E4970)
	// 822E4968: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E496C: 48000150  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E4970 => {
    //   block [0x822E4970..0x822E4990)
	// 822E4970: 7D1EEA14  add r8, r30, r29
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4974: 7CFEEA14  add r7, r30, r29
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4978: 89080001  lbz r8, 1(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E497C: 88E70002  lbz r7, 2(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E4980: 5508403E  rotlwi r8, r8, 8
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 822E4984: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 822E4988: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 822E498C: 48000130  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E4990 => {
    //   block [0x822E4990..0x822E49B0)
	// 822E4990: 7D1EEA14  add r8, r30, r29
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4994: 7CFEEA14  add r7, r30, r29
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4998: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E499C: 89080001  lbz r8, 1(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E49A0: 88E70002  lbz r7, 2(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E49A4: 5508403E  rotlwi r8, r8, 8
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 822E49A8: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 822E49AC: 48000110  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E49B0 => {
    //   block [0x822E49B0..0x822E49E4)
	// 822E49B0: 7D1EEA14  add r8, r30, r29
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E49B4: 7CFEEA14  add r7, r30, r29
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E49B8: 89080001  lbz r8, 1(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E49BC: 88E70002  lbz r7, 2(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E49C0: 5508403E  rotlwi r8, r8, 8
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 822E49C4: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 822E49C8: 2F0800F0  cmpwi cr6, r8, 0xf0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 240, &mut ctx.xer);
	// 822E49CC: 40980018  bge cr6, 0x822e49e4
	if !ctx.cr[6].lt {
	pc = 0x822E49E4; continue 'dispatch;
	}
	// 822E49D0: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E49D4: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E49D8: 7D082A2E  lhzx r8, r8, r5
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 822E49DC: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E49E0: 480000DC  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E49E4 => {
    //   block [0x822E49E4..0x822E4A04)
	// 822E49E4: 2F080100  cmpwi cr6, r8, 0x100
	ctx.cr[6].compare_i32(ctx.r[8].s32, 256, &mut ctx.xer);
	// 822E49E8: 4098001C  bge cr6, 0x822e4a04
	if !ctx.cr[6].lt {
	pc = 0x822E4A04; continue 'dispatch;
	}
	// 822E49EC: 3908FF10  addi r8, r8, -0xf0
	ctx.r[8].s64 = ctx.r[8].s64 + -240;
	// 822E49F0: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E49F4: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E49F8: 7D08E22E  lhzx r8, r8, r28
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 822E49FC: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4A00: 480000BC  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E4A04 => {
    //   block [0x822E4A04..0x822E4A34)
	// 822E4A04: A0FF03CC  lhz r7, 0x3cc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 822E4A08: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E4A0C: 7CE70734  extsh r7, r7
	ctx.r[7].s64 = ctx.r[7].s16 as i64;
	// 822E4A10: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 822E4A14: 7D270734  extsh r7, r9
	ctx.r[7].s64 = ctx.r[9].s16 as i64;
	// 822E4A18: 3908FF00  addi r8, r8, -0x100
	ctx.r[8].s64 = ctx.r[8].s64 + -256;
	// 822E4A1C: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4A20: 7D083838  and r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 822E4A24: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4A28: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4A2C: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4A30: 4800008C  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E4A34 => {
    //   block [0x822E4A34..0x822E4A78)
	// 822E4A34: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4A38: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4A3C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4A40: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4A44: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4A48: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4A4C: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E4A50: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4A54: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4A58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4A5C: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4A60: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4A64: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4A68: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4A6C: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 822E4A70: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4A74: 48000044  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E4A78 => {
    //   block [0x822E4A78..0x822E4AB4)
	// 822E4A78: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4A7C: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4A80: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4A84: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4A88: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4A8C: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4A90: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E4A94: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4A98: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4A9C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4AA0: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4AA4: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4AA8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4AAC: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4AB0: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	pc = 0x822E4AB4; continue 'dispatch;
            }
            0x822E4AB4 => {
    //   block [0x822E4AB4..0x822E4AB8)
	// 822E4AB4: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E4AB8 => {
    //   block [0x822E4AB8..0x822E4ABC)
	// 822E4AB8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E4ABC => {
    //   block [0x822E4ABC..0x822E4AE8)
	// 822E4ABC: 57670630  rlwinm r7, r27, 0, 0x18, 0x18
	ctx.r[7].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 822E4AC0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822E4AC4: 419AFD2C  beq cr6, 0x822e47f0
	if ctx.cr[6].eq {
	pc = 0x822E47F0; continue 'dispatch;
	}
	// 822E4AC8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4ACC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E4AD0: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4AD4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4AD8: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E4ADC: 7D09532E  sthx r8, r9, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u16) };
	// 822E4AE0: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4AE4: 4BFFFD00  b 0x822e47e4
	pc = 0x822E47E4; continue 'dispatch;
            }
            0x822E4AE8 => {
    //   block [0x822E4AE8..0x822E4B2C)
	// 822E4AE8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4AEC: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4AF0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4AF4: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4AF8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4AFC: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4B00: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E4B04: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4B08: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4B0C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4B10: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4B14: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4B18: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4B1C: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4B20: 7D0839D6  mullw r8, r8, r7
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 822E4B24: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4B28: 4BFFFF90  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E4B2C => {
    //   block [0x822E4B2C..0x822E4B70)
	// 822E4B2C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4B30: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4B34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4B38: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4B3C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4B40: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4B44: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E4B48: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4B4C: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4B50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4B54: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4B58: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4B5C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4B60: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4B64: 7D083BD6  divw r8, r8, r7
	ctx.r[8].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 822E4B68: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4B6C: 4BFFFF4C  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E4B70 => {
    //   block [0x822E4B70..0x822E4BB8)
	// 822E4B70: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4B74: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4B78: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4B7C: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4B80: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4B84: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4B88: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E4B8C: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4B90: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4B94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4B98: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4B9C: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4BA0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4BA4: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4BA8: 7CC83BD6  divw r6, r8, r7
	ctx.r[6].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 822E4BAC: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4BB0: 7CE639D6  mullw r7, r6, r7
	ctx.r[7].s32 = ((ctx.r[6].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 822E4BB4: 4BFFFF00  b 0x822e4ab4
	pc = 0x822E4AB4; continue 'dispatch;
            }
            0x822E4BB8 => {
    //   block [0x822E4BB8..0x822E4BE0)
	// 822E4BB8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4BBC: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4BC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4BC4: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4BC8: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4BCC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4BD0: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4BD4: 7D0800D0  neg r8, r8
	ctx.r[8].s64 = -ctx.r[8].s64;
	// 822E4BD8: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4BDC: 4BFFFEDC  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E4BE0 => {
    //   block [0x822E4BE0..0x822E4C18)
	// 822E4BE0: 7D7EEA14  add r11, r30, r29
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4BE4: 7D1EEA14  add r8, r30, r29
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4BE8: 896B0001  lbz r11, 1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E4BEC: 89080002  lbz r8, 2(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E4BF0: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 822E4BF4: 7D6B4378  or r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[8].u64;
	// 822E4BF8: 2F0B00F0  cmpwi cr6, r11, 0xf0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 240, &mut ctx.xer);
	// 822E4BFC: 4098001C  bge cr6, 0x822e4c18
	if !ctx.cr[6].lt {
	pc = 0x822E4C18; continue 'dispatch;
	}
	// 822E4C00: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E4C04: 7D4B2A2E  lhzx r10, r11, r5
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 822E4C08: 7D480734  extsh r8, r10
	ctx.r[8].s64 = ctx.r[10].s16 as i64;
	// 822E4C0C: 39480001  addi r10, r8, 1
	ctx.r[10].s64 = ctx.r[8].s64 + 1;
	// 822E4C10: 7D4B2B2E  sthx r10, r11, r5
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[5].u32), ctx.r[10].u16) };
	// 822E4C14: 48000054  b 0x822e4c68
	pc = 0x822E4C68; continue 'dispatch;
            }
            0x822E4C18 => {
    //   block [0x822E4C18..0x822E4C3C)
	// 822E4C18: 2F0B0100  cmpwi cr6, r11, 0x100
	ctx.cr[6].compare_i32(ctx.r[11].s32, 256, &mut ctx.xer);
	// 822E4C1C: 40980020  bge cr6, 0x822e4c3c
	if !ctx.cr[6].lt {
	pc = 0x822E4C3C; continue 'dispatch;
	}
	// 822E4C20: 396BFF10  addi r11, r11, -0xf0
	ctx.r[11].s64 = ctx.r[11].s64 + -240;
	// 822E4C24: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E4C28: 7D4BE22E  lhzx r10, r11, r28
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 822E4C2C: 7D480734  extsh r8, r10
	ctx.r[8].s64 = ctx.r[10].s16 as i64;
	// 822E4C30: 39480001  addi r10, r8, 1
	ctx.r[10].s64 = ctx.r[8].s64 + 1;
	// 822E4C34: 7D4BE32E  sthx r10, r11, r28
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u16) };
	// 822E4C38: 48000030  b 0x822e4c68
	pc = 0x822E4C68; continue 'dispatch;
            }
            0x822E4C3C => {
    //   block [0x822E4C3C..0x822E4C68)
	// 822E4C3C: A11F03CC  lhz r8, 0x3cc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 822E4C40: 396BFF00  addi r11, r11, -0x100
	ctx.r[11].s64 = ctx.r[11].s64 + -256;
	// 822E4C44: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E4C48: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 822E4C4C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4C50: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4C54: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E4C58: 7D2B522E  lhzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4C5C: 7D280734  extsh r8, r9
	ctx.r[8].s64 = ctx.r[9].s16 as i64;
	// 822E4C60: 39280001  addi r9, r8, 1
	ctx.r[9].s64 = ctx.r[8].s64 + 1;
	// 822E4C64: 7D2B532E  sthx r9, r11, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u16) };
	pc = 0x822E4C68; continue 'dispatch;
            }
            0x822E4C68 => {
    //   block [0x822E4C68..0x822E4C80)
	// 822E4C68: 815F03D4  lwz r10, 0x3d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 822E4C6C: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E4C70: 813F03D0  lwz r9, 0x3d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 822E4C74: A17F03CE  lhz r11, 0x3ce(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(974 as u32) ) } as u64;
	// 822E4C78: 80BF03C0  lwz r5, 0x3c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 822E4C7C: 4BFFFE40  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E4C80 => {
    //   block [0x822E4C80..0x822E4CB8)
	// 822E4C80: 7D7EEA14  add r11, r30, r29
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4C84: 7D1EEA14  add r8, r30, r29
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4C88: 896B0001  lbz r11, 1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E4C8C: 89080002  lbz r8, 2(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E4C90: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 822E4C94: 7D6B4378  or r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[8].u64;
	// 822E4C98: 2F0B00F0  cmpwi cr6, r11, 0xf0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 240, &mut ctx.xer);
	// 822E4C9C: 4098001C  bge cr6, 0x822e4cb8
	if !ctx.cr[6].lt {
	pc = 0x822E4CB8; continue 'dispatch;
	}
	// 822E4CA0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E4CA4: 7D4B2A2E  lhzx r10, r11, r5
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 822E4CA8: 7D480734  extsh r8, r10
	ctx.r[8].s64 = ctx.r[10].s16 as i64;
	// 822E4CAC: 3948FFFF  addi r10, r8, -1
	ctx.r[10].s64 = ctx.r[8].s64 + -1;
	// 822E4CB0: 7D4B2B2E  sthx r10, r11, r5
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[5].u32), ctx.r[10].u16) };
	// 822E4CB4: 48000054  b 0x822e4d08
	pc = 0x822E4D08; continue 'dispatch;
            }
            0x822E4CB8 => {
    //   block [0x822E4CB8..0x822E4CDC)
	// 822E4CB8: 2F0B0100  cmpwi cr6, r11, 0x100
	ctx.cr[6].compare_i32(ctx.r[11].s32, 256, &mut ctx.xer);
	// 822E4CBC: 40980020  bge cr6, 0x822e4cdc
	if !ctx.cr[6].lt {
	pc = 0x822E4CDC; continue 'dispatch;
	}
	// 822E4CC0: 396BFF10  addi r11, r11, -0xf0
	ctx.r[11].s64 = ctx.r[11].s64 + -240;
	// 822E4CC4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E4CC8: 7D4BE22E  lhzx r10, r11, r28
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 822E4CCC: 7D480734  extsh r8, r10
	ctx.r[8].s64 = ctx.r[10].s16 as i64;
	// 822E4CD0: 3948FFFF  addi r10, r8, -1
	ctx.r[10].s64 = ctx.r[8].s64 + -1;
	// 822E4CD4: 7D4BE32E  sthx r10, r11, r28
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u16) };
	// 822E4CD8: 48000030  b 0x822e4d08
	pc = 0x822E4D08; continue 'dispatch;
            }
            0x822E4CDC => {
    //   block [0x822E4CDC..0x822E4D08)
	// 822E4CDC: A11F03CC  lhz r8, 0x3cc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 822E4CE0: 396BFF00  addi r11, r11, -0x100
	ctx.r[11].s64 = ctx.r[11].s64 + -256;
	// 822E4CE4: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E4CE8: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 822E4CEC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4CF0: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4CF4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E4CF8: 7D2B522E  lhzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4CFC: 7D280734  extsh r8, r9
	ctx.r[8].s64 = ctx.r[9].s16 as i64;
	// 822E4D00: 3928FFFF  addi r9, r8, -1
	ctx.r[9].s64 = ctx.r[8].s64 + -1;
	// 822E4D04: 7D2B532E  sthx r9, r11, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u16) };
	pc = 0x822E4D08; continue 'dispatch;
            }
            0x822E4D08 => {
    //   block [0x822E4D08..0x822E4D20)
	// 822E4D08: 815F03D4  lwz r10, 0x3d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 822E4D0C: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E4D10: 813F03D0  lwz r9, 0x3d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 822E4D14: A17F03CE  lhz r11, 0x3ce(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(974 as u32) ) } as u64;
	// 822E4D18: 80BF03C0  lwz r5, 0x3c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 822E4D1C: 4BFFFDA0  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E4D20 => {
    //   block [0x822E4D20..0x822E4D64)
	// 822E4D20: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4D24: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4D28: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4D2C: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4D30: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4D34: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4D38: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E4D3C: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4D40: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4D44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4D48: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4D4C: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4D50: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4D54: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4D58: 7D083838  and r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 822E4D5C: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4D60: 4BFFFD58  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E4D64 => {
    //   block [0x822E4D64..0x822E4DA8)
	// 822E4D64: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4D68: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4D6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4D70: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4D74: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4D78: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4D7C: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E4D80: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4D84: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4D88: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4D8C: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4D90: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4D94: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4D98: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4D9C: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 822E4DA0: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4DA4: 4BFFFD14  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E4DA8 => {
    //   block [0x822E4DA8..0x822E4DD4)
	// 822E4DA8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4DAC: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4DB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4DB4: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4DB8: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4DBC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4DC0: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4DC4: 7D080034  cntlzw r8, r8
	ctx.r[8].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 822E4DC8: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4DCC: 5508DFFE  rlwinm r8, r8, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 822E4DD0: 4BFFFCE8  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E4DD4 => {
    //   block [0x822E4DD4..0x822E4E18)
	// 822E4DD4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4DD8: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4DDC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4DE0: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4DE4: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4DE8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4DEC: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E4DF0: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4DF4: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4DF8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4DFC: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4E00: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4E04: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4E08: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4E0C: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4E10: 7D083830  slw r8, r8, r7
	if (ctx.r[7].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[8].u32) << ((ctx.r[7].u8 & 0x1F) as u32)) as u64;
	}
	// 822E4E14: 4BFFFCA4  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E4E18 => {
    //   block [0x822E4E18..0x822E4E5C)
	// 822E4E18: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4E1C: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4E20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4E24: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4E28: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4E2C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4E30: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E4E34: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4E38: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4E3C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4E40: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4E44: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4E48: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4E4C: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E4E50: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E4E54: 7D083E30  sraw r8, r8, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> tmp.u32) as i64;
	// 822E4E58: 4BFFFC60  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E4E5C => {
    //   block [0x822E4E5C..0x822E4EA4)
	// 822E4E5C: 7D1EEA14  add r8, r30, r29
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4E60: 7CFEEA14  add r7, r30, r29
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4E64: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4E68: 89080001  lbz r8, 1(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E4E6C: 88E70002  lbz r7, 2(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E4E70: 5508403E  rotlwi r8, r8, 8
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 822E4E74: 7D073B78  or r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 822E4E78: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E4E7C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4E80: 2F0700F0  cmpwi cr6, r7, 0xf0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 240, &mut ctx.xer);
	// 822E4E84: 7D664838  and r6, r11, r9
	ctx.r[6].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4E88: 7D68522E  lhzx r11, r8, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4E8C: 7D680734  extsh r8, r11
	ctx.r[8].s64 = ctx.r[11].s16 as i64;
	// 822E4E90: B0DF03CE  sth r6, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[6].u16 ) };
	// 822E4E94: 40980010  bge cr6, 0x822e4ea4
	if !ctx.cr[6].lt {
	pc = 0x822E4EA4; continue 'dispatch;
	}
	// 822E4E98: 54EA083C  slwi r10, r7, 1
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E4E9C: 7D0A2B2E  sthx r8, r10, r5
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32), ctx.r[8].u16) };
	// 822E4EA0: 48000040  b 0x822e4ee0
	pc = 0x822E4EE0; continue 'dispatch;
            }
            0x822E4EA4 => {
    //   block [0x822E4EA4..0x822E4EBC)
	// 822E4EA4: 2F070100  cmpwi cr6, r7, 0x100
	ctx.cr[6].compare_i32(ctx.r[7].s32, 256, &mut ctx.xer);
	// 822E4EA8: 40980014  bge cr6, 0x822e4ebc
	if !ctx.cr[6].lt {
	pc = 0x822E4EBC; continue 'dispatch;
	}
	// 822E4EAC: 3967FF10  addi r11, r7, -0xf0
	ctx.r[11].s64 = ctx.r[7].s64 + -240;
	// 822E4EB0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E4EB4: 7D0BE32E  sthx r8, r11, r28
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u16) };
	// 822E4EB8: 48000028  b 0x822e4ee0
	pc = 0x822E4EE0; continue 'dispatch;
            }
            0x822E4EBC => {
    //   block [0x822E4EBC..0x822E4EE0)
	// 822E4EBC: A17F03CC  lhz r11, 0x3cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 822E4EC0: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E4EC4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4EC8: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 822E4ECC: 396BFF00  addi r11, r11, -0x100
	ctx.r[11].s64 = ctx.r[11].s64 + -256;
	// 822E4ED0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4ED4: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4ED8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E4EDC: 7D0B532E  sthx r8, r11, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u16) };
	pc = 0x822E4EE0; continue 'dispatch;
            }
            0x822E4EE0 => {
    //   block [0x822E4EE0..0x822E4EF8)
	// 822E4EE0: 815F03D4  lwz r10, 0x3d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 822E4EE4: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E4EE8: 813F03D0  lwz r9, 0x3d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 822E4EEC: A17F03CE  lhz r11, 0x3ce(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(974 as u32) ) } as u64;
	// 822E4EF0: 80BF03C0  lwz r5, 0x3c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 822E4EF4: 4BFFFBC8  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E4EF8 => {
    //   block [0x822E4EF8..0x822E4F48)
	// 822E4EF8: 7CFEEA14  add r7, r30, r29
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4EFC: 7CDEEA14  add r6, r30, r29
	ctx.r[6].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4F00: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4F04: 88E70001  lbz r7, 1(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E4F08: 88C60002  lbz r6, 2(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E4F0C: 54E7403E  rotlwi r7, r7, 8
	ctx.r[7].u64 = ((ctx.r[7].u32).rotate_left(8)) as u64;
	// 822E4F10: 7CE73378  or r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 822E4F14: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 822E4F18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4F1C: 2F0700F0  cmpwi cr6, r7, 0xf0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 240, &mut ctx.xer);
	// 822E4F20: 7D644838  and r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4F24: 7D66522E  lhzx r11, r6, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4F28: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4F2C: B09F03CE  sth r4, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[4].u16 ) };
	// 822E4F30: 40980018  bge cr6, 0x822e4f48
	if !ctx.cr[6].lt {
	pc = 0x822E4F48; continue 'dispatch;
	}
	// 822E4F34: 54EA083C  slwi r10, r7, 1
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E4F38: 7D2A2A2E  lhzx r9, r10, r5
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 822E4F3C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 822E4F40: 7D6A2B2E  sthx r11, r10, r5
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32), ctx.r[11].u16) };
	// 822E4F44: 4800004C  b 0x822e4f90
	pc = 0x822E4F90; continue 'dispatch;
            }
            0x822E4F48 => {
    //   block [0x822E4F48..0x822E4F68)
	// 822E4F48: 2F070100  cmpwi cr6, r7, 0x100
	ctx.cr[6].compare_i32(ctx.r[7].s32, 256, &mut ctx.xer);
	// 822E4F4C: 4098001C  bge cr6, 0x822e4f68
	if !ctx.cr[6].lt {
	pc = 0x822E4F68; continue 'dispatch;
	}
	// 822E4F50: 3947FF10  addi r10, r7, -0xf0
	ctx.r[10].s64 = ctx.r[7].s64 + -240;
	// 822E4F54: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E4F58: 7D2AE22E  lhzx r9, r10, r28
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 822E4F5C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 822E4F60: 7D6AE32E  sthx r11, r10, r28
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u16) };
	// 822E4F64: 4800002C  b 0x822e4f90
	pc = 0x822E4F90; continue 'dispatch;
            }
            0x822E4F68 => {
    //   block [0x822E4F68..0x822E4F90)
	// 822E4F68: A0DF03CC  lhz r6, 0x3cc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 822E4F6C: 38E7FF00  addi r7, r7, -0x100
	ctx.r[7].s64 = ctx.r[7].s64 + -256;
	// 822E4F70: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E4F74: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 822E4F78: 7CE70734  extsh r7, r7
	ctx.r[7].s64 = ctx.r[7].s16 as i64;
	// 822E4F7C: 7CE94838  and r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 822E4F80: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E4F84: 7CE9522E  lhzx r7, r9, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4F88: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 822E4F8C: 7D69532E  sthx r11, r9, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u16) };
	pc = 0x822E4F90; continue 'dispatch;
            }
            0x822E4F90 => {
    //   block [0x822E4F90..0x822E4FA8)
	// 822E4F90: 815F03D4  lwz r10, 0x3d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 822E4F94: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E4F98: 813F03D0  lwz r9, 0x3d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 822E4F9C: A17F03CE  lhz r11, 0x3ce(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(974 as u32) ) } as u64;
	// 822E4FA0: 80BF03C0  lwz r5, 0x3c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 822E4FA4: 4BFFFB18  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E4FA8 => {
    //   block [0x822E4FA8..0x822E4FF8)
	// 822E4FA8: 7CFEEA14  add r7, r30, r29
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4FAC: 7CDEEA14  add r6, r30, r29
	ctx.r[6].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E4FB0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4FB4: 88E70001  lbz r7, 1(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E4FB8: 88C60002  lbz r6, 2(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E4FBC: 54E7403E  rotlwi r7, r7, 8
	ctx.r[7].u64 = ((ctx.r[7].u32).rotate_left(8)) as u64;
	// 822E4FC0: 7CE73378  or r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 822E4FC4: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 822E4FC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E4FCC: 2F0700F0  cmpwi cr6, r7, 0xf0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 240, &mut ctx.xer);
	// 822E4FD0: 7D644838  and r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E4FD4: 7D66522E  lhzx r11, r6, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E4FD8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E4FDC: B09F03CE  sth r4, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[4].u16 ) };
	// 822E4FE0: 40980018  bge cr6, 0x822e4ff8
	if !ctx.cr[6].lt {
	pc = 0x822E4FF8; continue 'dispatch;
	}
	// 822E4FE4: 54EA083C  slwi r10, r7, 1
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E4FE8: 7D2A2A2E  lhzx r9, r10, r5
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 822E4FEC: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 822E4FF0: 7D6A2B2E  sthx r11, r10, r5
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32), ctx.r[11].u16) };
	// 822E4FF4: 4800004C  b 0x822e5040
	pc = 0x822E5040; continue 'dispatch;
            }
            0x822E4FF8 => {
    //   block [0x822E4FF8..0x822E5018)
	// 822E4FF8: 2F070100  cmpwi cr6, r7, 0x100
	ctx.cr[6].compare_i32(ctx.r[7].s32, 256, &mut ctx.xer);
	// 822E4FFC: 4098001C  bge cr6, 0x822e5018
	if !ctx.cr[6].lt {
	pc = 0x822E5018; continue 'dispatch;
	}
	// 822E5000: 3947FF10  addi r10, r7, -0xf0
	ctx.r[10].s64 = ctx.r[7].s64 + -240;
	// 822E5004: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E5008: 7D2AE22E  lhzx r9, r10, r28
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 822E500C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 822E5010: 7D6AE32E  sthx r11, r10, r28
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u16) };
	// 822E5014: 4800002C  b 0x822e5040
	pc = 0x822E5040; continue 'dispatch;
            }
            0x822E5018 => {
    //   block [0x822E5018..0x822E5040)
	// 822E5018: A0DF03CC  lhz r6, 0x3cc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 822E501C: 38E7FF00  addi r7, r7, -0x100
	ctx.r[7].s64 = ctx.r[7].s64 + -256;
	// 822E5020: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E5024: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 822E5028: 7CE70734  extsh r7, r7
	ctx.r[7].s64 = ctx.r[7].s16 as i64;
	// 822E502C: 7CE94838  and r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 822E5030: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E5034: 7CE9522E  lhzx r7, r9, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5038: 7D6B3850  subf r11, r11, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 822E503C: 7D69532E  sthx r11, r9, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u16) };
	pc = 0x822E5040; continue 'dispatch;
            }
            0x822E5040 => {
    //   block [0x822E5040..0x822E5058)
	// 822E5040: 815F03D4  lwz r10, 0x3d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 822E5044: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E5048: 813F03D0  lwz r9, 0x3d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 822E504C: A17F03CE  lhz r11, 0x3ce(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(974 as u32) ) } as u64;
	// 822E5050: 80BF03C0  lwz r5, 0x3c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 822E5054: 4BFFFA68  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E5058 => {
    //   block [0x822E5058..0x822E50AC)
	// 822E5058: 7CFEEA14  add r7, r30, r29
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E505C: 7CDEEA14  add r6, r30, r29
	ctx.r[6].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E5060: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5064: 88E70001  lbz r7, 1(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E5068: 88C60002  lbz r6, 2(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E506C: 54E7403E  rotlwi r7, r7, 8
	ctx.r[7].u64 = ((ctx.r[7].u32).rotate_left(8)) as u64;
	// 822E5070: 7CE73378  or r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 822E5074: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 822E5078: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E507C: 2F0700F0  cmpwi cr6, r7, 0xf0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 240, &mut ctx.xer);
	// 822E5080: 7D644838  and r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E5084: 7D66522E  lhzx r11, r6, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5088: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E508C: B09F03CE  sth r4, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[4].u16 ) };
	// 822E5090: 4098001C  bge cr6, 0x822e50ac
	if !ctx.cr[6].lt {
	pc = 0x822E50AC; continue 'dispatch;
	}
	// 822E5094: 54EA083C  slwi r10, r7, 1
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E5098: 7D2A2A2E  lhzx r9, r10, r5
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 822E509C: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E50A0: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E50A4: 7D6A2B2E  sthx r11, r10, r5
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32), ctx.r[11].u16) };
	// 822E50A8: 48000054  b 0x822e50fc
	pc = 0x822E50FC; continue 'dispatch;
            }
            0x822E50AC => {
    //   block [0x822E50AC..0x822E50D0)
	// 822E50AC: 2F070100  cmpwi cr6, r7, 0x100
	ctx.cr[6].compare_i32(ctx.r[7].s32, 256, &mut ctx.xer);
	// 822E50B0: 40980020  bge cr6, 0x822e50d0
	if !ctx.cr[6].lt {
	pc = 0x822E50D0; continue 'dispatch;
	}
	// 822E50B4: 3947FF10  addi r10, r7, -0xf0
	ctx.r[10].s64 = ctx.r[7].s64 + -240;
	// 822E50B8: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E50BC: 7D2AE22E  lhzx r9, r10, r28
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 822E50C0: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E50C4: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E50C8: 7D6AE32E  sthx r11, r10, r28
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u16) };
	// 822E50CC: 48000030  b 0x822e50fc
	pc = 0x822E50FC; continue 'dispatch;
            }
            0x822E50D0 => {
    //   block [0x822E50D0..0x822E50FC)
	// 822E50D0: A0DF03CC  lhz r6, 0x3cc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 822E50D4: 38E7FF00  addi r7, r7, -0x100
	ctx.r[7].s64 = ctx.r[7].s64 + -256;
	// 822E50D8: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E50DC: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 822E50E0: 7CE70734  extsh r7, r7
	ctx.r[7].s64 = ctx.r[7].s16 as i64;
	// 822E50E4: 7CE94838  and r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 822E50E8: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E50EC: 7CE9522E  lhzx r7, r9, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E50F0: 7CE70734  extsh r7, r7
	ctx.r[7].s64 = ctx.r[7].s16 as i64;
	// 822E50F4: 7D6759D6  mullw r11, r7, r11
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E50F8: 7D69532E  sthx r11, r9, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u16) };
	pc = 0x822E50FC; continue 'dispatch;
            }
            0x822E50FC => {
    //   block [0x822E50FC..0x822E5114)
	// 822E50FC: 815F03D4  lwz r10, 0x3d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 822E5100: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E5104: 813F03D0  lwz r9, 0x3d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 822E5108: A17F03CE  lhz r11, 0x3ce(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(974 as u32) ) } as u64;
	// 822E510C: 80BF03C0  lwz r5, 0x3c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 822E5110: 4BFFF9AC  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E5114 => {
    //   block [0x822E5114..0x822E5168)
	// 822E5114: 7CFEEA14  add r7, r30, r29
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E5118: 7CDEEA14  add r6, r30, r29
	ctx.r[6].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E511C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5120: 88E70001  lbz r7, 1(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E5124: 88C60002  lbz r6, 2(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E5128: 54E7403E  rotlwi r7, r7, 8
	ctx.r[7].u64 = ((ctx.r[7].u32).rotate_left(8)) as u64;
	// 822E512C: 7CE73378  or r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 822E5130: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 822E5134: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E5138: 2F0700F0  cmpwi cr6, r7, 0xf0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 240, &mut ctx.xer);
	// 822E513C: 7D644838  and r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E5140: 7D66522E  lhzx r11, r6, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5144: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5148: B09F03CE  sth r4, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[4].u16 ) };
	// 822E514C: 4098001C  bge cr6, 0x822e5168
	if !ctx.cr[6].lt {
	pc = 0x822E5168; continue 'dispatch;
	}
	// 822E5150: 54EA083C  slwi r10, r7, 1
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E5154: 7D2A2A2E  lhzx r9, r10, r5
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 822E5158: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E515C: 7D695BD6  divw r11, r9, r11
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 822E5160: 7D6A2B2E  sthx r11, r10, r5
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32), ctx.r[11].u16) };
	// 822E5164: 48000054  b 0x822e51b8
	pc = 0x822E51B8; continue 'dispatch;
            }
            0x822E5168 => {
    //   block [0x822E5168..0x822E518C)
	// 822E5168: 2F070100  cmpwi cr6, r7, 0x100
	ctx.cr[6].compare_i32(ctx.r[7].s32, 256, &mut ctx.xer);
	// 822E516C: 40980020  bge cr6, 0x822e518c
	if !ctx.cr[6].lt {
	pc = 0x822E518C; continue 'dispatch;
	}
	// 822E5170: 3947FF10  addi r10, r7, -0xf0
	ctx.r[10].s64 = ctx.r[7].s64 + -240;
	// 822E5174: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E5178: 7D2AE22E  lhzx r9, r10, r28
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 822E517C: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E5180: 7D695BD6  divw r11, r9, r11
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 822E5184: 7D6AE32E  sthx r11, r10, r28
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u16) };
	// 822E5188: 48000030  b 0x822e51b8
	pc = 0x822E51B8; continue 'dispatch;
            }
            0x822E518C => {
    //   block [0x822E518C..0x822E51B8)
	// 822E518C: A0DF03CC  lhz r6, 0x3cc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 822E5190: 38E7FF00  addi r7, r7, -0x100
	ctx.r[7].s64 = ctx.r[7].s64 + -256;
	// 822E5194: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E5198: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 822E519C: 7CE70734  extsh r7, r7
	ctx.r[7].s64 = ctx.r[7].s16 as i64;
	// 822E51A0: 7CE94838  and r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 822E51A4: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E51A8: 7CE9522E  lhzx r7, r9, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E51AC: 7CE70734  extsh r7, r7
	ctx.r[7].s64 = ctx.r[7].s16 as i64;
	// 822E51B0: 7D675BD6  divw r11, r7, r11
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[11].s32;
	// 822E51B4: 7D69532E  sthx r11, r9, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u16) };
	pc = 0x822E51B8; continue 'dispatch;
            }
            0x822E51B8 => {
    //   block [0x822E51B8..0x822E51D0)
	// 822E51B8: 815F03D4  lwz r10, 0x3d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 822E51BC: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E51C0: 813F03D0  lwz r9, 0x3d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 822E51C4: A17F03CE  lhz r11, 0x3ce(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(974 as u32) ) } as u64;
	// 822E51C8: 80BF03C0  lwz r5, 0x3c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 822E51CC: 4BFFF8F0  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E51D0 => {
    //   block [0x822E51D0..0x822E522C)
	// 822E51D0: 7CFEEA14  add r7, r30, r29
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E51D4: 7CDEEA14  add r6, r30, r29
	ctx.r[6].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E51D8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E51DC: 88E70001  lbz r7, 1(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E51E0: 88C60002  lbz r6, 2(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E51E4: 54E7403E  rotlwi r7, r7, 8
	ctx.r[7].u64 = ((ctx.r[7].u32).rotate_left(8)) as u64;
	// 822E51E8: 7CE73378  or r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 822E51EC: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 822E51F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E51F4: 2F0700F0  cmpwi cr6, r7, 0xf0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 240, &mut ctx.xer);
	// 822E51F8: 7D644838  and r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E51FC: 7D66522E  lhzx r11, r6, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5200: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5204: B09F03CE  sth r4, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[4].u16 ) };
	// 822E5208: 40980024  bge cr6, 0x822e522c
	if !ctx.cr[6].lt {
	pc = 0x822E522C; continue 'dispatch;
	}
	// 822E520C: 54EA083C  slwi r10, r7, 1
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E5210: 7D2A2A2E  lhzx r9, r10, r5
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 822E5214: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E5218: 7CE95BD6  divw r7, r9, r11
	ctx.r[7].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 822E521C: 7D6759D6  mullw r11, r7, r11
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E5220: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 822E5224: 7D6A2B2E  sthx r11, r10, r5
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32), ctx.r[11].u16) };
	// 822E5228: 48000064  b 0x822e528c
	pc = 0x822E528C; continue 'dispatch;
            }
            0x822E522C => {
    //   block [0x822E522C..0x822E5258)
	// 822E522C: 2F070100  cmpwi cr6, r7, 0x100
	ctx.cr[6].compare_i32(ctx.r[7].s32, 256, &mut ctx.xer);
	// 822E5230: 40980028  bge cr6, 0x822e5258
	if !ctx.cr[6].lt {
	pc = 0x822E5258; continue 'dispatch;
	}
	// 822E5234: 3947FF10  addi r10, r7, -0xf0
	ctx.r[10].s64 = ctx.r[7].s64 + -240;
	// 822E5238: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E523C: 7D2AE22E  lhzx r9, r10, r28
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 822E5240: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E5244: 7CE95BD6  divw r7, r9, r11
	ctx.r[7].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 822E5248: 7D6759D6  mullw r11, r7, r11
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E524C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 822E5250: 7D6AE32E  sthx r11, r10, r28
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u16) };
	// 822E5254: 48000038  b 0x822e528c
	pc = 0x822E528C; continue 'dispatch;
            }
            0x822E5258 => {
    //   block [0x822E5258..0x822E528C)
	// 822E5258: A0DF03CC  lhz r6, 0x3cc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 822E525C: 38E7FF00  addi r7, r7, -0x100
	ctx.r[7].s64 = ctx.r[7].s64 + -256;
	// 822E5260: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 822E5264: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 822E5268: 7CE70734  extsh r7, r7
	ctx.r[7].s64 = ctx.r[7].s16 as i64;
	// 822E526C: 7CE94838  and r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 822E5270: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E5274: 7CE9522E  lhzx r7, r9, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5278: 7CE70734  extsh r7, r7
	ctx.r[7].s64 = ctx.r[7].s16 as i64;
	// 822E527C: 7CC75BD6  divw r6, r7, r11
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[11].s32;
	// 822E5280: 7D6659D6  mullw r11, r6, r11
	ctx.r[11].s32 = ((ctx.r[6].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E5284: 7D6B3850  subf r11, r11, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 822E5288: 7D69532E  sthx r11, r9, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u16) };
	pc = 0x822E528C; continue 'dispatch;
            }
            0x822E528C => {
    //   block [0x822E528C..0x822E52A4)
	// 822E528C: 815F03D4  lwz r10, 0x3d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 822E5290: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E5294: 813F03D0  lwz r9, 0x3d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 822E5298: A17F03CE  lhz r11, 0x3ce(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(974 as u32) ) } as u64;
	// 822E529C: 80BF03C0  lwz r5, 0x3c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 822E52A0: 4BFFF81C  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E52A4 => {
    //   block [0x822E52A4..0x822E52F0)
	// 822E52A4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E52A8: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E52AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E52B0: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E52B4: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E52B8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E52BC: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E52C0: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E52C4: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E52C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E52CC: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E52D0: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E52D4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E52D8: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E52DC: 7D083850  subf r8, r8, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 822E52E0: 7D080034  cntlzw r8, r8
	ctx.r[8].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 822E52E4: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E52E8: 5508DFFE  rlwinm r8, r8, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 822E52EC: 4BFFF7CC  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E52F0 => {
    //   block [0x822E52F0..0x822E5340)
	// 822E52F0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E52F4: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E52F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E52FC: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E5300: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5304: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5308: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E530C: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E5310: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E5314: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E5318: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E531C: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5320: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5324: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E5328: 7D083850  subf r8, r8, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 822E532C: 7D080034  cntlzw r8, r8
	ctx.r[8].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 822E5330: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E5334: 5508DFFE  rlwinm r8, r8, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 822E5338: 69080001  xori r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u64 ^ 1;
	// 822E533C: 4BFFF77C  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E5340 => {
    //   block [0x822E5340..0x822E5390)
	// 822E5340: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5344: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E5348: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E534C: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E5350: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5354: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5358: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E535C: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E5360: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E5364: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E5368: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E536C: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5370: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5374: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E5378: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 822E537C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822E5380: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E5384: 4198F734  blt cr6, 0x822e4ab8
	if ctx.cr[6].lt {
	pc = 0x822E4AB8; continue 'dispatch;
	}
	// 822E5388: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822E538C: 4BFFF72C  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E5390 => {
    //   block [0x822E5390..0x822E53E0)
	// 822E5390: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5394: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E5398: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E539C: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E53A0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E53A4: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E53A8: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E53AC: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E53B0: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E53B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E53B8: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E53BC: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E53C0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E53C4: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E53C8: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 822E53CC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822E53D0: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E53D4: 4099F6E4  ble cr6, 0x822e4ab8
	if !ctx.cr[6].gt {
	pc = 0x822E4AB8; continue 'dispatch;
	}
	// 822E53D8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822E53DC: 4BFFF6DC  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E53E0 => {
    //   block [0x822E53E0..0x822E5430)
	// 822E53E0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E53E4: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E53E8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E53EC: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E53F0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E53F4: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E53F8: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E53FC: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E5400: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E5404: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E5408: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E540C: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5410: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5414: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E5418: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 822E541C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822E5420: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E5424: 4199F694  bgt cr6, 0x822e4ab8
	if ctx.cr[6].gt {
	pc = 0x822E4AB8; continue 'dispatch;
	}
	// 822E5428: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822E542C: 4BFFF68C  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E5430 => {
    //   block [0x822E5430..0x822E5480)
	// 822E5430: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5434: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E5438: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E543C: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E5440: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5444: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5448: 7D070734  extsh r7, r8
	ctx.r[7].s64 = ctx.r[8].s16 as i64;
	// 822E544C: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E5450: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E5454: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E5458: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E545C: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5460: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5464: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E5468: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 822E546C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822E5470: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E5474: 4098F644  bge cr6, 0x822e4ab8
	if !ctx.cr[6].lt {
	pc = 0x822E4AB8; continue 'dispatch;
	}
	// 822E5478: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822E547C: 4BFFF63C  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E5480 => {
    //   block [0x822E5480..0x822E54A8)
	// 822E5480: 7D1EEA14  add r8, r30, r29
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E5484: 7CFEEA14  add r7, r30, r29
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E5488: 88880002  lbz r4, 2(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E548C: 88A70001  lbz r5, 1(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E5490: 3904FFFF  addi r8, r4, -1
	ctx.r[8].s64 = ctx.r[4].s64 + -1;
	// 822E5494: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822E5498: 41980040  blt cr6, 0x822e54d8
	if ctx.cr[6].lt {
	pc = 0x822E54D8; continue 'dispatch;
	}
	// 822E549C: 5507083C  slwi r7, r8, 1
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822E54A0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822E54A4: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	pc = 0x822E54A8; continue 'dispatch;
            }
            0x822E54A8 => {
    //   block [0x822E54A8..0x822E54D8)
	// 822E54A8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E54AC: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 822E54B0: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 822E54B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E54B8: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822E54BC: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E54C0: 7CC6522E  lhzx r6, r6, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E54C4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E54C8: B0C70000  sth r6, 0(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[6].u16 ) };
	// 822E54CC: 38E7FFFE  addi r7, r7, -2
	ctx.r[7].s64 = ctx.r[7].s64 + -2;
	// 822E54D0: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E54D4: 4098FFD4  bge cr6, 0x822e54a8
	if !ctx.cr[6].lt {
	pc = 0x822E54A8; continue 'dispatch;
	}
	pc = 0x822E54D8; continue 'dispatch;
            }
            0x822E54D8 => {
    //   block [0x822E54D8..0x822E5518)
	// 822E54D8: 54AB15BA  rlwinm r11, r5, 2, 0x16, 0x1d
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x3FFFFFFFu64;
	// 822E54DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822E54E0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 822E54E4: 7D6BC82E  lwzx r11, r11, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 822E54E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E54EC: 4E800421  bctrl
	ctx.lr = 0x822E54F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E54F0: 817F0BD8  lwz r11, 0xbd8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3032 as u32) ) } as u64;
	// 822E54F4: 815F03D4  lwz r10, 0x3d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 822E54F8: 7C680734  extsh r8, r3
	ctx.r[8].s64 = ctx.r[3].s16 as i64;
	// 822E54FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E5500: 813F03D0  lwz r9, 0x3d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 822E5504: A17F03CE  lhz r11, 0x3ce(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(974 as u32) ) } as u64;
	// 822E5508: 409A013C  bne cr6, 0x822e5644
	if !ctx.cr[6].eq {
	pc = 0x822E5644; continue 'dispatch;
	}
	// 822E550C: 80BF03C0  lwz r5, 0x3c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 822E5510: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
	// 822E5514: 4BFFF5A8  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E5518 => {
    //   block [0x822E5518..0x822E5544)
	// 822E5518: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E551C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E5520: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E5524: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5528: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E552C: 7D09532E  sthx r8, r9, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u16) };
	// 822E5530: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E5534: 815F03D4  lwz r10, 0x3d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 822E5538: 813F03D0  lwz r9, 0x3d0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 822E553C: 80BF03C0  lwz r5, 0x3c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 822E5540: 4BFFF578  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E5544 => {
    //   block [0x822E5544..0x822E5568)
	// 822E5544: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5548: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E554C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E5550: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E5554: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5558: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E555C: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 822E5560: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E5564: 4BFFF554  b 0x822e4ab8
	pc = 0x822E4AB8; continue 'dispatch;
            }
            0x822E5568 => {
    //   block [0x822E5568..0x822E55AC)
	// 822E5568: 7D1EEA14  add r8, r30, r29
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E556C: 7CFEEA14  add r7, r30, r29
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E5570: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5574: 89080001  lbz r8, 1(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E5578: 88E70002  lbz r7, 2(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E557C: 5508403E  rotlwi r8, r8, 8
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 822E5580: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 822E5584: 5567083C  slwi r7, r11, 1
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822E5588: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E558C: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E5590: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5594: 7CE7522E  lhzx r7, r7, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5598: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822E559C: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E55A0: 409AF3C8  bne cr6, 0x822e4968
	if !ctx.cr[6].eq {
	pc = 0x822E4968; continue 'dispatch;
	}
	// 822E55A4: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 822E55A8: 4BFFF514  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E55AC => {
    //   block [0x822E55AC..0x822E55F0)
	// 822E55AC: 7D1EEA14  add r8, r30, r29
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E55B0: 7CFEEA14  add r7, r30, r29
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822E55B4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E55B8: 89080001  lbz r8, 1(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E55BC: 88E70002  lbz r7, 2(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E55C0: 5508403E  rotlwi r8, r8, 8
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 822E55C4: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 822E55C8: 5567083C  slwi r7, r11, 1
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822E55CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E55D0: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E55D4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E55D8: 7CE7522E  lhzx r7, r7, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E55DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822E55E0: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E55E4: 419AF384  beq cr6, 0x822e4968
	if ctx.cr[6].eq {
	pc = 0x822E4968; continue 'dispatch;
	}
	// 822E55E8: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 822E55EC: 4BFFF4D0  b 0x822e4abc
	pc = 0x822E4ABC; continue 'dispatch;
            }
            0x822E55F0 => {
    //   block [0x822E55F0..0x822E5610)
	// 822E55F0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E55F4: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E55F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E55FC: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E5600: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5604: 7F08522E  lhzx r24, r8, r10
	ctx.r[24].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5608: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E560C: 4800003C  b 0x822e5648
	pc = 0x822E5648; continue 'dispatch;
            }
            0x822E5610 => {
    //   block [0x822E5610..0x822E5638)
	// 822E5610: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5614: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 822E5618: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E561C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E5620: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E5624: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5628: 7F08522E  lhzx r24, r8, r10
	ctx.r[24].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E562C: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E5630: 90FF0BD8  stw r7, 0xbd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3032 as u32), ctx.r[7].u32 ) };
	// 822E5634: 48000014  b 0x822e5648
	pc = 0x822E5648; continue 'dispatch;
            }
            0x822E5638 => {
    //   block [0x822E5638..0x822E5644)
	// 822E5638: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 822E563C: 911F0BD8  stw r8, 0xbd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3032 as u32), ctx.r[8].u32 ) };
	// 822E5640: 48000008  b 0x822e5648
	pc = 0x822E5648; continue 'dispatch;
            }
            0x822E5644 => {
    //   block [0x822E5644..0x822E5648)
	// 822E5644: 7D180734  extsh r24, r8
	ctx.r[24].s64 = ctx.r[8].s16 as i64;
	pc = 0x822E5648; continue 'dispatch;
            }
            0x822E5648 => {
    //   block [0x822E5648..0x822E5680)
	// 822E5648: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 822E564C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822E5650: 40990030  ble cr6, 0x822e5680
	if !ctx.cr[6].gt {
	pc = 0x822E5680; continue 'dispatch;
	}
	// 822E5654: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5658: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 822E565C: 7D6B4838  and r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E5660: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E5664: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822E5668: B17F03CE  sth r11, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[11].u16 ) };
	// 822E566C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E5670: 7D694838  and r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 822E5674: 7D68522E  lhzx r11, r8, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E5678: B13F03CE  sth r9, 0x3ce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(974 as u32), ctx.r[9].u16 ) };
	// 822E567C: B17F03CC  sth r11, 0x3cc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(972 as u32), ctx.r[11].u16 ) };
	pc = 0x822E5680; continue 'dispatch;
            }
            0x822E5680 => {
    //   block [0x822E5680..0x822E5688)
	// 822E5680: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822E5684: 4824FA70  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E5688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E5688 size=556
    let mut pc: u32 = 0x822E5688;
    'dispatch: loop {
        match pc {
            0x822E5688 => {
    //   block [0x822E5688..0x822E58A8)
	// 822E5688: 2B030012  cmplwi cr6, r3, 0x12
	ctx.cr[6].compare_u32(ctx.r[3].u32, 18 as u32, &mut ctx.xer);
	// 822E568C: 41990228  bgt cr6, 0x822e58b4
	if ctx.cr[6].gt {
		sub_822E58B4(ctx, base);
		return;
	}
	// 822E5690: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 822E5694: 81493F10  lwz r10, 0x3f10(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16144 as u32) ) } as u64;
	// 822E5698: 554B07BC  rlwinm r11, r10, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822E569C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E56A0: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 822E56A4: 396B3DE0  addi r11, r11, 0x3de0
	ctx.r[11].s64 = ctx.r[11].s64 + 15840;
	// 822E56A8: 409A0200  bne cr6, 0x822e58a8
	if !ctx.cr[6].eq {
	pc = 0x822E58A8; continue 'dispatch;
	}
	// 822E56AC: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 822E56B0: 91493F10  stw r10, 0x3f10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16144 as u32), ctx.r[10].u32 ) };
	// 822E56B4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822E56B8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E56BC: C1AABA38  lfs f13, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E56C0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E56C4: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E56C8: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822E56CC: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E56D0: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822E56D4: C00A22EC  lfs f0, 0x22ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8940 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E56D8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E56DC: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822E56E0: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 822E56E4: D1AB0018  stfs f13, 0x18(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 822E56E8: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 822E56EC: C18A230C  lfs f12, 0x230c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8972 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E56F0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E56F4: D18B0020  stfs f12, 0x20(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822E56F8: C1892310  lfs f12, 0x2310(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8976 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E56FC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E5700: D00B0024  stfs f0, 0x24(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822E5704: D00B0028  stfs f0, 0x28(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822E5708: C10A2278  lfs f8, 0x2278(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8824 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822E570C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 822E5710: D00B002C  stfs f0, 0x2c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 822E5714: 394AD218  addi r10, r10, -0x2de8
	ctx.r[10].s64 = ctx.r[10].s64 + -11752;
	// 822E5718: C1292160  lfs f9, 0x2160(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8544 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822E571C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E5720: D10B0030  stfs f8, 0x30(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 822E5724: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 822E5728: C14A0074  lfs f10, 0x74(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(116 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E572C: D14B0038  stfs f10, 0x38(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 822E5730: D18B003C  stfs f12, 0x3c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 822E5734: C189BFFC  lfs f12, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E5738: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 822E573C: D12B0040  stfs f9, 0x40(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E5740: D12B0044  stfs f9, 0x44(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 822E5744: D12B0048  stfs f9, 0x48(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 822E5748: D18B004C  stfs f12, 0x4c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 822E574C: C169D468  lfs f11, -0x2b98(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E5750: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E5754: D16B0050  stfs f11, 0x50(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822E5758: D16B0054  stfs f11, 0x54(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822E575C: D16B0058  stfs f11, 0x58(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822E5760: D16B005C  stfs f11, 0x5c(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822E5764: C189207C  lfs f12, 0x207c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8316 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E5768: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 822E576C: D00B0060  stfs f0, 0x60(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E5770: D18B0064  stfs f12, 0x64(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822E5774: C0E9D478  lfs f7, -0x2b88(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822E5778: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E577C: D0EB0068  stfs f7, 0x68(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822E5780: C0E92308  lfs f7, 0x2308(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8968 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822E5784: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E5788: D0EB006C  stfs f7, 0x6c(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822E578C: D12B0070  stfs f9, 0x70(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822E5790: D00B0074  stfs f0, 0x74(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822E5794: D10B0078  stfs f8, 0x78(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822E5798: D16B007C  stfs f11, 0x7c(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822E579C: D14B0080  stfs f10, 0x80(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 822E57A0: D18B0084  stfs f12, 0x84(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 822E57A4: D18B0088  stfs f12, 0x88(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 822E57A8: D14B008C  stfs f10, 0x8c(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 822E57AC: D14B0090  stfs f10, 0x90(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 822E57B0: C16920C8  lfs f11, 0x20c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8392 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E57B4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E57B8: D16B0094  stfs f11, 0x94(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 822E57BC: D16B0098  stfs f11, 0x98(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 822E57C0: D18B009C  stfs f12, 0x9c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 822E57C4: D16B00A0  stfs f11, 0xa0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 822E57C8: D16B00A4  stfs f11, 0xa4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 822E57CC: C10A04B8  lfs f8, 0x4b8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1208 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822E57D0: D18B00A8  stfs f12, 0xa8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E57D4: D10B00AC  stfs f8, 0xac(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822E57D8: C1092304  lfs f8, 0x2304(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8964 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822E57DC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E57E0: D10B00B0  stfs f8, 0xb0(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822E57E4: D18B00B4  stfs f12, 0xb4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822E57E8: D18B00B8  stfs f12, 0xb8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822E57EC: D16B00BC  stfs f11, 0xbc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 822E57F0: C10A0000  lfs f8, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822E57F4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E57F8: C189203C  lfs f12, 0x203c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E57FC: D18B00C0  stfs f12, 0xc0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 822E5800: D00B00C4  stfs f0, 0xc4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822E5804: D1AB00C8  stfs f13, 0xc8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 822E5808: D10B00CC  stfs f8, 0xcc(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 822E580C: C10A22F0  lfs f8, 0x22f0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8944 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822E5810: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E5814: D00B00D0  stfs f0, 0xd0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 822E5818: D10B00D4  stfs f8, 0xd4(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 822E581C: D10B00D8  stfs f8, 0xd8(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 822E5820: D12B00DC  stfs f9, 0xdc(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 822E5824: C12A22E4  lfs f9, 0x22e4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8932 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822E5828: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E582C: D12B00E0  stfs f9, 0xe0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 822E5830: D12B00E4  stfs f9, 0xe4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 822E5834: C12A2300  lfs f9, 0x2300(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8960 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822E5838: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 822E583C: D12B00E8  stfs f9, 0xe8(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 822E5840: D00B00EC  stfs f0, 0xec(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 822E5844: D1AB00F0  stfs f13, 0xf0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 822E5848: D00B00F4  stfs f0, 0xf4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 822E584C: C1AAD4D0  lfs f13, -0x2b30(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11056 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E5850: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E5854: D00B00F8  stfs f0, 0xf8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 822E5858: D1AB00FC  stfs f13, 0xfc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 822E585C: C1AA22FC  lfs f13, 0x22fc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8956 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E5860: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E5864: D1AB0100  stfs f13, 0x100(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 822E5868: C1AA2178  lfs f13, 0x2178(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E586C: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 822E5870: D1AB0104  stfs f13, 0x104(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 822E5874: D14B0108  stfs f10, 0x108(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 822E5878: D16B010C  stfs f11, 0x10c(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 822E587C: C1AAD47C  lfs f13, -0x2b84(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E5880: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E5884: D1AB0110  stfs f13, 0x110(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 822E5888: D1AB0114  stfs f13, 0x114(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 822E588C: D16B0118  stfs f11, 0x118(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 822E5890: C1AA22F8  lfs f13, 0x22f8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8952 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E5894: D1AB011C  stfs f13, 0x11c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 822E5898: D10B0120  stfs f8, 0x120(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 822E589C: D18B0124  stfs f12, 0x124(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 822E58A0: D18B0128  stfs f12, 0x128(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 822E58A4: D00B012C  stfs f0, 0x12c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(300 as u32), tmp.u32 ) };
	pc = 0x822E58A8; continue 'dispatch;
            }
            0x822E58A8 => {
    //   block [0x822E58A8..0x822E58B4)
	// 822E58A8: 546A2036  slwi r10, r3, 4
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E58AC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E58B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E58B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E58B4 size=64
    let mut pc: u32 = 0x822E58B4;
    'dispatch: loop {
        match pc {
            0x822E58B4 => {
    //   block [0x822E58B4..0x822E58F4)
	// 822E58B4: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 822E58B8: 816A3F10  lwz r11, 0x3f10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16144 as u32) ) } as u64;
	// 822E58BC: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822E58C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822E58C4: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 822E58C8: 38693DD0  addi r3, r9, 0x3dd0
	ctx.r[3].s64 = ctx.r[9].s64 + 15824;
	// 822E58CC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 822E58D0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 822E58D4: 916A3F10  stw r11, 0x3f10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16144 as u32), ctx.r[11].u32 ) };
	// 822E58D8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E58DC: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E58E0: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E58E4: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822E58E8: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E58EC: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822E58F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E58F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E58F8 size=512
    let mut pc: u32 = 0x822E58F8;
    'dispatch: loop {
        match pc {
            0x822E58F8 => {
    //   block [0x822E58F8..0x822E5AEC)
	// 822E58F8: 2B030014  cmplwi cr6, r3, 0x14
	ctx.cr[6].compare_u32(ctx.r[3].u32, 20 as u32, &mut ctx.xer);
	// 822E58FC: 419901FC  bgt cr6, 0x822e5af8
	if ctx.cr[6].gt {
		sub_822E5AF8(ctx, base);
		return;
	}
	// 822E5900: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 822E5904: 81493DC0  lwz r10, 0x3dc0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(15808 as u32) ) } as u64;
	// 822E5908: 554B07BC  rlwinm r11, r10, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822E590C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E5910: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 822E5914: 396B3C70  addi r11, r11, 0x3c70
	ctx.r[11].s64 = ctx.r[11].s64 + 15472;
	// 822E5918: 409A01D4  bne cr6, 0x822e5aec
	if !ctx.cr[6].eq {
	pc = 0x822E5AEC; continue 'dispatch;
	}
	// 822E591C: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 822E5920: 91493DC0  stw r10, 0x3dc0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(15808 as u32), ctx.r[10].u32 ) };
	// 822E5924: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E5928: C1AA2160  lfs f13, 0x2160(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8544 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E592C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 822E5930: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E5934: C18AD28C  lfs f12, -0x2d74(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11636 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E5938: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822E593C: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822E5940: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E5944: C00ABA38  lfs f0, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E5948: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E594C: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822E5950: D18B0010  stfs f12, 0x10(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822E5954: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 822E5958: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 822E595C: C12A22F4  lfs f9, 0x22f4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8948 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822E5960: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E5964: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 822E5968: D12B0020  stfs f9, 0x20(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822E596C: C10A22F0  lfs f8, 0x22f0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8944 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822E5970: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E5974: D10B0024  stfs f8, 0x24(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822E5978: C16A207C  lfs f11, 0x207c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8316 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E597C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E5980: D16B0028  stfs f11, 0x28(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822E5984: D00B002C  stfs f0, 0x2c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 822E5988: D00B0030  stfs f0, 0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 822E598C: D18B0034  stfs f12, 0x34(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 822E5990: C0EA1FF8  lfs f7, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822E5994: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E5998: D1AB0038  stfs f13, 0x38(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 822E599C: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 822E59A0: D00B0040  stfs f0, 0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E59A4: D00B0044  stfs f0, 0x44(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 822E59A8: C14A2278  lfs f10, 0x2278(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8824 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E59AC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E59B0: D00B0048  stfs f0, 0x48(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 822E59B4: D0EB004C  stfs f7, 0x4c(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 822E59B8: D14B0050  stfs f10, 0x50(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822E59BC: C1AA22EC  lfs f13, 0x22ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8940 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E59C0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E59C4: D1AB0054  stfs f13, 0x54(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822E59C8: D18B0058  stfs f12, 0x58(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822E59CC: D00B005C  stfs f0, 0x5c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822E59D0: D1AB0060  stfs f13, 0x60(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E59D4: D1AB0064  stfs f13, 0x64(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822E59D8: D1AB0068  stfs f13, 0x68(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822E59DC: D00B006C  stfs f0, 0x6c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822E59E0: D1AB0070  stfs f13, 0x70(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822E59E4: D1AB0074  stfs f13, 0x74(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822E59E8: D1AB0078  stfs f13, 0x78(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822E59EC: D00B007C  stfs f0, 0x7c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822E59F0: C0CA20C8  lfs f6, 0x20c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8392 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822E59F4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E59F8: D14B0080  stfs f10, 0x80(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 822E59FC: D14B0084  stfs f10, 0x84(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 822E5A00: D14B0088  stfs f10, 0x88(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 822E5A04: D0CB008C  stfs f6, 0x8c(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 822E5A08: D00B0090  stfs f0, 0x90(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 822E5A0C: D10B0094  stfs f8, 0x94(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 822E5A10: C10A22E8  lfs f8, 0x22e8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8936 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822E5A14: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E5A18: D10B0098  stfs f8, 0x98(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 822E5A1C: D00B009C  stfs f0, 0x9c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 822E5A20: C10A2170  lfs f8, 0x2170(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8560 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822E5A24: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 822E5A28: D10B00A0  stfs f8, 0xa0(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 822E5A2C: D18B00A4  stfs f12, 0xa4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 822E5A30: D16B00A8  stfs f11, 0xa8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E5A34: D00B00AC  stfs f0, 0xac(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822E5A38: C10AD478  lfs f8, -0x2b88(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822E5A3C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E5A40: D10B00B0  stfs f8, 0xb0(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822E5A44: D14B00B4  stfs f10, 0xb4(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822E5A48: D16B00B8  stfs f11, 0xb8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822E5A4C: D00B00BC  stfs f0, 0xbc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 822E5A50: D16B00C0  stfs f11, 0xc0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 822E5A54: D16B00C4  stfs f11, 0xc4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822E5A58: D16B00C8  stfs f11, 0xc8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 822E5A5C: D00B00CC  stfs f0, 0xcc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 822E5A60: C16A22E4  lfs f11, 0x22e4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8932 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E5A64: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E5A68: D16B00D0  stfs f11, 0xd0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 822E5A6C: C16A22E0  lfs f11, 0x22e0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8928 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E5A70: D16B00D4  stfs f11, 0xd4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 822E5A74: D16B00D8  stfs f11, 0xd8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 822E5A78: D00B00DC  stfs f0, 0xdc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 822E5A7C: D00B00E0  stfs f0, 0xe0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 822E5A80: D12B00E4  stfs f9, 0xe4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 822E5A84: D12B00E8  stfs f9, 0xe8(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 822E5A88: D1AB00EC  stfs f13, 0xec(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 822E5A8C: D10B00F0  stfs f8, 0xf0(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 822E5A90: D18B00F4  stfs f12, 0xf4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 822E5A94: D18B00F8  stfs f12, 0xf8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 822E5A98: D1AB00FC  stfs f13, 0xfc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 822E5A9C: D00B0100  stfs f0, 0x100(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 822E5AA0: D00B0104  stfs f0, 0x104(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 822E5AA4: D00B0108  stfs f0, 0x108(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 822E5AA8: D0EB010C  stfs f7, 0x10c(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 822E5AAC: D00B0110  stfs f0, 0x110(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 822E5AB0: D00B0114  stfs f0, 0x114(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 822E5AB4: D00B0118  stfs f0, 0x118(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 822E5AB8: D00B011C  stfs f0, 0x11c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 822E5ABC: D00B0120  stfs f0, 0x120(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 822E5AC0: D00B0124  stfs f0, 0x124(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 822E5AC4: D00B0128  stfs f0, 0x128(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 822E5AC8: D00B012C  stfs f0, 0x12c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 822E5ACC: D00B0130  stfs f0, 0x130(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 822E5AD0: D00B0134  stfs f0, 0x134(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 822E5AD4: D00B0138  stfs f0, 0x138(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 822E5AD8: D00B013C  stfs f0, 0x13c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 822E5ADC: D00B0140  stfs f0, 0x140(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 822E5AE0: D00B0144  stfs f0, 0x144(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 822E5AE4: D00B0148  stfs f0, 0x148(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 822E5AE8: D00B014C  stfs f0, 0x14c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(332 as u32), tmp.u32 ) };
	pc = 0x822E5AEC; continue 'dispatch;
            }
            0x822E5AEC => {
    //   block [0x822E5AEC..0x822E5AF8)
	// 822E5AEC: 546A2036  slwi r10, r3, 4
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E5AF0: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822E5AF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E5AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E5AF8 size=64
    let mut pc: u32 = 0x822E5AF8;
    'dispatch: loop {
        match pc {
            0x822E5AF8 => {
    //   block [0x822E5AF8..0x822E5B38)
	// 822E5AF8: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 822E5AFC: 816A3DC0  lwz r11, 0x3dc0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15808 as u32) ) } as u64;
	// 822E5B00: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822E5B04: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822E5B08: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 822E5B0C: 38693C60  addi r3, r9, 0x3c60
	ctx.r[3].s64 = ctx.r[9].s64 + 15456;
	// 822E5B10: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 822E5B14: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 822E5B18: 916A3DC0  stw r11, 0x3dc0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15808 as u32), ctx.r[11].u32 ) };
	// 822E5B1C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E5B20: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E5B24: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E5B28: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822E5B2C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E5B30: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822E5B34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E5B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E5B38 size=280
    let mut pc: u32 = 0x822E5B38;
    'dispatch: loop {
        match pc {
            0x822E5B38 => {
    //   block [0x822E5B38..0x822E5BF0)
	// 822E5B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E5B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E5B40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E5B44: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 822E5B48: 2B040014  cmplwi cr6, r4, 0x14
	ctx.cr[6].compare_u32(ctx.r[4].u32, 20 as u32, &mut ctx.xer);
	// 822E5B4C: 419900A4  bgt cr6, 0x822e5bf0
	if ctx.cr[6].gt {
	pc = 0x822E5BF0; continue 'dispatch;
	}
	// 822E5B50: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 822E5B54: 806BA0CC  lwz r3, -0x5f34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24372 as u32) ) } as u64;
	// 822E5B58: 4BFFFB31  bl 0x822e5688
	ctx.lr = 0x822E5B5C;
	sub_822E5688(ctx, base);
	// 822E5B5C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E5B60: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822E5B64: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 822E5B68: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822E5B6C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 822E5B70: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822E5B74: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822E5B78: 4BFFFD81  bl 0x822e58f8
	ctx.lr = 0x822E5B7C;
	sub_822E58F8(ctx, base);
	// 822E5B7C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822E5B80: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 822E5B84: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 822E5B88: 1160034A  vcfsx v11, v0, 0
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[11].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	pc = 0x822E5BF0; continue 'dispatch;
            }
            0x822E5BF0 => {
    //   block [0x822E5BF0..0x822E5C50)
	// 822E5BF0: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 822E5BF4: 81494210  lwz r10, 0x4210(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16912 as u32) ) } as u64;
	// 822E5BF8: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 822E5BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E5C00: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 822E5C04: 396B4200  addi r11, r11, 0x4200
	ctx.r[11].s64 = ctx.r[11].s64 + 16896;
	// 822E5C08: 409A0024  bne cr6, 0x822e5c2c
	if !ctx.cr[6].eq {
	pc = 0x822E5C2C; continue 'dispatch;
	}
	// 822E5C0C: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 822E5C10: 91494210  stw r10, 0x4210(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16912 as u32), ctx.r[10].u32 ) };
	// 822E5C14: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822E5C18: C00ABA38  lfs f0, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E5C1C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E5C20: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822E5C24: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E5C28: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822E5C2C: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822E5C30: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 822E5C34: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 822E5C38: F9480000  std r10, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 822E5C3C: F9680008  std r11, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822E5C40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E5C44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E5C48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E5C4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E5C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E5C50 size=100
    let mut pc: u32 = 0x822E5C50;
    'dispatch: loop {
        match pc {
            0x822E5C50 => {
    //   block [0x822E5C50..0x822E5CB4)
	// 822E5C50: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822E5C54: 90830080  stw r4, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[4].u32 ) };
	// 822E5C58: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822E5C5C: 396B3D58  addi r11, r11, 0x3d58
	ctx.r[11].s64 = ctx.r[11].s64 + 15704;
	// 822E5C60: 9943001C  stb r10, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 822E5C64: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E5C68: 89650006  lbz r11, 6(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(6 as u32) ) } as u64;
	// 822E5C6C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822E5C70: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822E5C74: 396B16E8  addi r11, r11, 0x16e8
	ctx.r[11].s64 = ctx.r[11].s64 + 5864;
	// 822E5C78: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 822E5C7C: 40980038  bge cr6, 0x822e5cb4
	if !ctx.cr[6].lt {
		sub_822E5CB4(ctx, base);
		return;
	}
	// 822E5C80: 38EB0008  addi r7, r11, 8
	ctx.r[7].s64 = ctx.r[11].s64 + 8;
	// 822E5C84: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E5C88: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 822E5C8C: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 822E5C90: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822E5C94: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E5C98: 7D4B4B2E  sthx r10, r11, r9
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u16) };
	// 822E5C9C: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E5CA0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E5CA4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822E5CA8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E5CAC: 7D0B392E  stwx r8, r11, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[8].u32) };
	// 822E5CB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E5CB4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E5CB4 size=36
    let mut pc: u32 = 0x822E5CB4;
    'dispatch: loop {
        match pc {
            0x822E5CB4 => {
    //   block [0x822E5CB4..0x822E5CD8)
	// 822E5CB4: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 822E5CB8: 81450058  lwz r10, 0x58(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(88 as u32) ) } as u64;
	// 822E5CBC: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E5CC0: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 822E5CC4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E5CC8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E5CCC: 7D4B4B2E  sthx r10, r11, r9
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u16) };
	// 822E5CD0: 7CCB412E  stwx r6, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[6].u32) };
	// 822E5CD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E5CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E5CD8 size=68
    let mut pc: u32 = 0x822E5CD8;
    'dispatch: loop {
        match pc {
            0x822E5CD8 => {
    //   block [0x822E5CD8..0x822E5D1C)
	// 822E5CD8: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 822E5CDC: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E5CE0: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 822E5CE4: 394A16E8  addi r10, r10, 0x16e8
	ctx.r[10].s64 = ctx.r[10].s64 + 5864;
	// 822E5CE8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822E5CEC: 390A0004  addi r8, r10, 4
	ctx.r[8].s64 = ctx.r[10].s64 + 4;
	// 822E5CF0: 38CA0008  addi r6, r10, 8
	ctx.r[6].s64 = ctx.r[10].s64 + 8;
	// 822E5CF4: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E5CF8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822E5CFC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E5D00: 7D2B432E  sthx r9, r11, r8
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u16) };
	// 822E5D04: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E5D08: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E5D0C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822E5D10: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E5D14: 7CEB312E  stwx r7, r11, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32), ctx.r[7].u32) };
	// 822E5D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E5D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E5D20 size=228
    let mut pc: u32 = 0x822E5D20;
    'dispatch: loop {
        match pc {
            0x822E5D20 => {
    //   block [0x822E5D20..0x822E5D78)
	// 822E5D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E5D24: 4824F399  bl 0x825350bc
	ctx.lr = 0x822E5D28;
	sub_82535080(ctx, base);
	// 822E5D28: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E5D2C: 54AB8FFE  rlwinm r11, r5, 0x11, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x00007FFFu64;
	// 822E5D30: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E5D34: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822E5D38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E5D3C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 822E5D40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E5D44: 419A0034  beq cr6, 0x822e5d78
	if ctx.cr[6].eq {
	pc = 0x822E5D78; continue 'dispatch;
	}
	// 822E5D48: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E5D4C: 54A5057E  clrlwi r5, r5, 0x15
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0x000007FFu64;
	// 822E5D50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822E5D54: C02BBA38  lfs f1, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E5D58: 48000221  bl 0x822e5f78
	ctx.lr = 0x822E5D5C;
	sub_822E5F78(ctx, base);
	// 822E5D5C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 822E5D60: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822E5D64: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 822E5D68: F95E0000  std r10, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 822E5D6C: F97E0008  std r11, 8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822E5D70: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822E5D74: 4824F398  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x822E5D78 => {
    //   block [0x822E5D78..0x822E5DA0)
	// 822E5D78: 54AB057E  clrlwi r11, r5, 0x15
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000007FFu64;
	// 822E5D7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E5D80: 55690428  rlwinm r9, r11, 0, 0x10, 0x14
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822E5D84: 2F0B0058  cmpwi cr6, r11, 0x58
	ctx.cr[6].compare_i32(ctx.r[11].s32, 88, &mut ctx.xer);
	// 822E5D88: B1610050  sth r11, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u16 ) };
	// 822E5D8C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 822E5D90: B1210054  sth r9, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u16 ) };
	// 822E5D94: 4198000C  blt cr6, 0x822e5da0
	if ctx.cr[6].lt {
	pc = 0x822E5DA0; continue 'dispatch;
	}
	// 822E5D98: B1410052  sth r10, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u16 ) };
	// 822E5D9C: 4800000C  b 0x822e5da8
	pc = 0x822E5DA8; continue 'dispatch;
            }
            0x822E5DA0 => {
    //   block [0x822E5DA0..0x822E5DA8)
	// 822E5DA0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822E5DA4: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	pc = 0x822E5DA8; continue 'dispatch;
            }
            0x822E5DA8 => {
    //   block [0x822E5DA8..0x822E5DCC)
	// 822E5DA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822E5DAC: 4BEBDC3D  bl 0x821a39e8
	ctx.lr = 0x822E5DB0;
	sub_821A39E8(ctx, base);
	// 822E5DB0: 5464063E  clrlwi r4, r3, 0x18
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822E5DB4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822E5DB8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822E5DBC: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 822E5DC0: 409A000C  bne cr6, 0x822e5dcc
	if !ctx.cr[6].eq {
	pc = 0x822E5DCC; continue 'dispatch;
	}
	// 822E5DC4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E5DC8: 48000008  b 0x822e5dd0
	pc = 0x822E5DD0; continue 'dispatch;
            }
            0x822E5DCC => {
    //   block [0x822E5DCC..0x822E5DD0)
	// 822E5DCC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x822E5DD0; continue 'dispatch;
            }
            0x822E5DD0 => {
    //   block [0x822E5DD0..0x822E5E04)
	// 822E5DD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E5DD4: 4E800421  bctrl
	ctx.lr = 0x822E5DD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E5DD8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E5DDC: C1A30030  lfs f13, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E5DE0: D1BE0000  stfs f13, 0(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E5DE4: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E5DE8: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822E5DEC: C1A30038  lfs f13, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E5DF0: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E5DF4: D1BE0008  stfs f13, 8(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E5DF8: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822E5DFC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822E5E00: 4824F30C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E5E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E5E08 size=156
    let mut pc: u32 = 0x822E5E08;
    'dispatch: loop {
        match pc {
            0x822E5E08 => {
    //   block [0x822E5E08..0x822E5E58)
	// 822E5E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E5E0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E5E10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E5E14: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E5E18: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E5E1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E5E20: 4BFFFF01  bl 0x822e5d20
	ctx.lr = 0x822E5E24;
	sub_822E5D20(ctx, base);
	// 822E5E24: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E5E28: C05F0008  lfs f2, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822E5E2C: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 822E5E30: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E5E34: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E5E38: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 822E5E3C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822E5E40: 40990018  ble cr6, 0x822e5e58
	if !ctx.cr[6].gt {
	pc = 0x822E5E58; continue 'dispatch;
	}
	// 822E5E44: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E5E48: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 822E5E4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E5E50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E5E54: 41990008  bgt cr6, 0x822e5e5c
	if ctx.cr[6].gt {
	pc = 0x822E5E5C; continue 'dispatch;
	}
	pc = 0x822E5E58; continue 'dispatch;
            }
            0x822E5E58 => {
    //   block [0x822E5E58..0x822E5E5C)
	// 822E5E58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822E5E5C; continue 'dispatch;
            }
            0x822E5E5C => {
    //   block [0x822E5E5C..0x822E5E74)
	// 822E5E5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E5E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E5E64: 409A0010  bne cr6, 0x822e5e74
	if !ctx.cr[6].eq {
	pc = 0x822E5E74; continue 'dispatch;
	}
	// 822E5E68: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E5E6C: 4BED165D  bl 0x821b74c8
	ctx.lr = 0x822E5E70;
	sub_821B74C8(ctx, base);
	// 822E5E70: 48000018  b 0x822e5e88
	pc = 0x822E5E88; continue 'dispatch;
            }
            0x822E5E74 => {
    //   block [0x822E5E74..0x822E5E88)
	// 822E5E74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E5E78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E5E7C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822E5E80: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822E5E84: 4BED16AD  bl 0x821b7530
	ctx.lr = 0x822E5E88;
	sub_821B7530(ctx, base);
	pc = 0x822E5E88; continue 'dispatch;
            }
            0x822E5E88 => {
    //   block [0x822E5E88..0x822E5EA4)
	// 822E5E88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E5E8C: D03F0004  stfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822E5E90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E5E94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E5E98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E5E9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E5EA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E5EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E5EA8 size=204
    let mut pc: u32 = 0x822E5EA8;
    'dispatch: loop {
        match pc {
            0x822E5EA8 => {
    //   block [0x822E5EA8..0x822E5F74)
	// 822E5EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E5EAC: 4824F211  bl 0x825350bc
	ctx.lr = 0x822E5EB0;
	sub_82535080(ctx, base);
	// 822E5EB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E5EB4: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 822E5EB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E5EBC: 616AA974  ori r10, r11, 0xa974
	ctx.r[10].u64 = ctx.r[11].u64 | 43380;
	// 822E5EC0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E5EC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E5EC8: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 822E5ECC: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 822E5ED0: 60C39C18  ori r3, r6, 0x9c18
	ctx.r[3].u64 = ctx.r[6].u64 | 39960;
	// 822E5ED4: C00B24CC  lfs f0, 0x24cc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9420 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E5ED8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E5EDC: 60E79CA8  ori r7, r7, 0x9ca8
	ctx.r[7].u64 = ctx.r[7].u64 | 40104;
	// 822E5EE0: 61699CA0  ori r9, r11, 0x9ca0
	ctx.r[9].u64 = ctx.r[11].u64 | 40096;
	// 822E5EE4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E5EE8: 7D1F1C2E  lfsx f8, r31, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822E5EEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E5EF0: 61689C20  ori r8, r11, 0x9c20
	ctx.r[8].u64 = ctx.r[11].u64 | 39968;
	// 822E5EF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E5EF8: 7D9F4C2E  lfsx f12, r31, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E5EFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822E5F00: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822E5F04: 7D7F442E  lfsx f11, r31, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E5F08: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E5F0C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E5F10: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822E5F14: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 822E5F18: 7DBF542E  lfsx f13, r31, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E5F1C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822E5F20: 616B9C10  ori r11, r11, 0x9c10
	ctx.r[11].u64 = ctx.r[11].u64 | 39952;
	// 822E5F24: 7D7F3C2E  lfsx f11, r31, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E5F28: 614A9C28  ori r10, r10, 0x9c28
	ctx.r[10].u64 = ctx.r[10].u64 | 39976;
	// 822E5F2C: 7D5F5C2E  lfsx f10, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E5F30: 7D3F542E  lfsx f9, r31, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822E5F34: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E5F38: ED6B482A  fadds f11, f11, f9
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64;
	// 822E5F3C: EDA80372  fmuls f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E5F40: ED8C503A  fmadds f12, f12, f0, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 822E5F44: D19E0000  stfs f12, 0(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E5F48: EC0B683A  fmadds f0, f11, f0, f13
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 822E5F4C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E5F50: 4BFFFDD1  bl 0x822e5d20
	ctx.lr = 0x822E5F54;
	sub_822E5D20(ctx, base);
	// 822E5F54: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822E5F58: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822E5F5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E5F60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822E5F64: 4BFFFDBD  bl 0x822e5d20
	ctx.lr = 0x822E5F68;
	sub_822E5D20(ctx, base);
	// 822E5F68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E5F6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E5F70: 4824F19C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E5F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E5F78 size=496
    let mut pc: u32 = 0x822E5F78;
    'dispatch: loop {
        match pc {
            0x822E5F78 => {
    //   block [0x822E5F78..0x822E5FE4)
	// 822E5F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E5F7C: 4824F141  bl 0x825350bc
	ctx.lr = 0x822E5F80;
	sub_82535080(ctx, base);
	// 822E5F80: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822E5F84: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E5F88: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822E5F8C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822E5F90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822E5F94: 397DFFE9  addi r11, r29, -0x17
	ctx.r[11].s64 = ctx.r[29].s64 + -23;
	// 822E5F98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E5F9C: 38800017  li r4, 0x17
	ctx.r[4].s64 = 23;
	// 822E5FA0: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 822E5FA4: 41990084  bgt cr6, 0x822e6028
	if ctx.cr[6].gt {
	pc = 0x822E6028; continue 'dispatch;
	}
	// 822E5FA8: 3D80822E  lis r12, -0x7dd2
	ctx.r[12].s64 = -2110914560;
	// 822E5FAC: 398C5FC0  addi r12, r12, 0x5fc0
	ctx.r[12].s64 = ctx.r[12].s64 + 24512;
	// 822E5FB0: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 822E5FB4: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 822E5FB8: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 822E5FBC: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x822E5FE4; continue 'dispatch;
		},
		1 => {
	pc = 0x822E5FEC; continue 'dispatch;
		},
		2 => {
	pc = 0x822E5FF4; continue 'dispatch;
		},
		3 => {
	pc = 0x822E5FFC; continue 'dispatch;
		},
		4 => {
	pc = 0x822E6004; continue 'dispatch;
		},
		5 => {
	pc = 0x822E600C; continue 'dispatch;
		},
		6 => {
	pc = 0x822E6014; continue 'dispatch;
		},
		7 => {
	pc = 0x822E601C; continue 'dispatch;
		},
		8 => {
	pc = 0x822E6024; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 822E5FC0: 822E5FE4  lwz r17, 0x5fe4(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(24548 as u32) ) } as u64;
	// 822E5FC4: 822E5FEC  lwz r17, 0x5fec(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(24556 as u32) ) } as u64;
	// 822E5FC8: 822E5FF4  lwz r17, 0x5ff4(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(24564 as u32) ) } as u64;
	// 822E5FCC: 822E5FFC  lwz r17, 0x5ffc(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(24572 as u32) ) } as u64;
	// 822E5FD0: 822E6004  lwz r17, 0x6004(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(24580 as u32) ) } as u64;
	// 822E5FD4: 822E600C  lwz r17, 0x600c(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(24588 as u32) ) } as u64;
	// 822E5FD8: 822E6014  lwz r17, 0x6014(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(24596 as u32) ) } as u64;
	// 822E5FDC: 822E601C  lwz r17, 0x601c(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(24604 as u32) ) } as u64;
	// 822E5FE0: 822E6024  lwz r17, 0x6024(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(24612 as u32) ) } as u64;
            }
            0x822E5FE4 => {
    //   block [0x822E5FE4..0x822E5FEC)
	// 822E5FE4: 38800017  li r4, 0x17
	ctx.r[4].s64 = 23;
	// 822E5FE8: 48000040  b 0x822e6028
	pc = 0x822E6028; continue 'dispatch;
            }
            0x822E5FEC => {
    //   block [0x822E5FEC..0x822E5FF4)
	// 822E5FEC: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 822E5FF0: 48000038  b 0x822e6028
	pc = 0x822E6028; continue 'dispatch;
            }
            0x822E5FF4 => {
    //   block [0x822E5FF4..0x822E5FFC)
	// 822E5FF4: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 822E5FF8: 48000030  b 0x822e6028
	pc = 0x822E6028; continue 'dispatch;
            }
            0x822E5FFC => {
    //   block [0x822E5FFC..0x822E6004)
	// 822E5FFC: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 822E6000: 48000028  b 0x822e6028
	pc = 0x822E6028; continue 'dispatch;
            }
            0x822E6004 => {
    //   block [0x822E6004..0x822E600C)
	// 822E6004: 3880001B  li r4, 0x1b
	ctx.r[4].s64 = 27;
	// 822E6008: 48000020  b 0x822e6028
	pc = 0x822E6028; continue 'dispatch;
            }
            0x822E600C => {
    //   block [0x822E600C..0x822E6014)
	// 822E600C: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 822E6010: 48000018  b 0x822e6028
	pc = 0x822E6028; continue 'dispatch;
            }
            0x822E6014 => {
    //   block [0x822E6014..0x822E601C)
	// 822E6014: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 822E6018: 48000010  b 0x822e6028
	pc = 0x822E6028; continue 'dispatch;
            }
            0x822E601C => {
    //   block [0x822E601C..0x822E6024)
	// 822E601C: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 822E6020: 48000008  b 0x822e6028
	pc = 0x822E6028; continue 'dispatch;
            }
            0x822E6024 => {
    //   block [0x822E6024..0x822E6028)
	// 822E6024: 3880001F  li r4, 0x1f
	ctx.r[4].s64 = 31;
	pc = 0x822E6028; continue 'dispatch;
            }
            0x822E6028 => {
    //   block [0x822E6028..0x822E6168)
	// 822E6028: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 822E602C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822E6030: 386B14A0  addi r3, r11, 0x14a0
	ctx.r[3].s64 = ctx.r[11].s64 + 5280;
	// 822E6034: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E6038: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822E603C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822E6040: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822E6044: 4BEBDAC5  bl 0x821a3b08
	ctx.lr = 0x822E6048;
	sub_821A3B08(ctx, base);
	// 822E6048: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 822E604C: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 822E6050: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822E6054: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E6058: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E605C: 4E800421  bctrl
	ctx.lr = 0x822E6060;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E6060: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E6064: 39030030  addi r8, r3, 0x30
	ctx.r[8].s64 = ctx.r[3].s64 + 48;
	// 822E6068: 392A0010  addi r9, r10, 0x10
	ctx.r[9].s64 = ctx.r[10].s64 + 16;
	// 822E606C: 38E30010  addi r7, r3, 0x10
	ctx.r[7].s64 = ctx.r[3].s64 + 16;
	// 822E6070: 38C30020  addi r6, r3, 0x20
	ctx.r[6].s64 = ctx.r[3].s64 + 32;
	// 822E6074: E8AA0000  ld r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 822E6078: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E607C: F8BF0000  std r5, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 822E6080: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6084: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 822E6088: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 822E608C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 822E6090: F95F0008  std r10, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E6168 size=456
    let mut pc: u32 = 0x822E6168;
    'dispatch: loop {
        match pc {
            0x822E6168 => {
    //   block [0x822E6168..0x822E61C0)
	// 822E6168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E616C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E6170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E6174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E6178: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E617C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E6180: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 822E6184: 3BDF00C4  addi r30, r31, 0xc4
	ctx.r[30].s64 = ctx.r[31].s64 + 196;
	// 822E6188: 394AC470  addi r10, r10, -0x3b90
	ctx.r[10].s64 = ctx.r[10].s64 + -15248;
	// 822E618C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822E6190: 897F0084  lbz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822E6194: 386A0030  addi r3, r10, 0x30
	ctx.r[3].s64 = ctx.r[10].s64 + 48;
	// 822E6198: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822E619C: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 822E61A0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822E61A4: 55642834  slwi r4, r11, 5
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 822E61A8: 4BEBBA89  bl 0x821a1c30
	ctx.lr = 0x822E61AC;
	sub_821A1C30(ctx, base);
	// 822E61AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E61B0: 409A0010  bne cr6, 0x822e61c0
	if !ctx.cr[6].eq {
	pc = 0x822E61C0; continue 'dispatch;
	}
	// 822E61B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E61B8: 997F0087  stb r11, 0x87(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(135 as u32), ctx.r[11].u8 ) };
	// 822E61BC: 4800015C  b 0x822e6318
	pc = 0x822E6318; continue 'dispatch;
            }
            0x822E61C0 => {
    //   block [0x822E61C0..0x822E620C)
	// 822E61C0: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 822E61C4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822E61C8: 394A8E40  addi r10, r10, -0x71c0
	ctx.r[10].s64 = ctx.r[10].s64 + -29120;
	// 822E61CC: 397F0088  addi r11, r31, 0x88
	ctx.r[11].s64 = ctx.r[31].s64 + 136;
	// 822E61D0: 39200060  li r9, 0x60
	ctx.r[9].s64 = 96;
	// 822E61D4: 911F0040  stw r8, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[8].u32 ) };
	// 822E61D8: 915F00C8  stw r10, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 822E61DC: B11F00CC  sth r8, 0xcc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[8].u16 ) };
	// 822E61E0: B11F00CE  sth r8, 0xce(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(206 as u32), ctx.r[8].u16 ) };
	// 822E61E4: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 822E61E8: 910B0020  stw r8, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 822E61EC: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E61F0: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 822E61F4: 55490030  rlwinm r9, r10, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822E61F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822E61FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822E6200: 419A000C  beq cr6, 0x822e620c
	if ctx.cr[6].eq {
	pc = 0x822E620C; continue 'dispatch;
	}
	// 822E6204: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822E6208: 4800000C  b 0x822e6214
	pc = 0x822E6214; continue 'dispatch;
            }
            0x822E620C => {
    //   block [0x822E620C..0x822E6214)
	// 822E620C: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 822E6210: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x822E6214; continue 'dispatch;
            }
            0x822E6214 => {
    //   block [0x822E6214..0x822E623C)
	// 822E6214: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822E6218: 51493636  rlwimi r9, r10, 6, 0x18, 0x1b
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(6) as u64) & 0x00000000000000F0) | (ctx.r[9].u64 & 0xFFFFFFFFFFFFFF0F);
	// 822E621C: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 822E6220: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E6224: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 822E6228: 55290672  rlwinm r9, r9, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 822E622C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822E6230: 419A000C  beq cr6, 0x822e623c
	if ctx.cr[6].eq {
	pc = 0x822E623C; continue 'dispatch;
	}
	// 822E6234: 39200396  li r9, 0x396
	ctx.r[9].s64 = 918;
	// 822E6238: B13F0014  sth r9, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	pc = 0x822E623C; continue 'dispatch;
            }
            0x822E623C => {
    //   block [0x822E623C..0x822E6270)
	// 822E623C: A0EA0004  lhz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E6240: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E6244: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822E6248: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 822E624C: 5529003C  rlwinm r9, r9, 0, 0, 0x1e
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 822E6250: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822E6254: 552A07FE  clrlwi r10, r9, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 822E6258: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 822E625C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822E6260: 409A0010  bne cr6, 0x822e6270
	if !ctx.cr[6].eq {
	pc = 0x822E6270; continue 'dispatch;
	}
	// 822E6264: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E6268: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E626C: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x822E6270; continue 'dispatch;
            }
            0x822E6270 => {
    //   block [0x822E6270..0x822E62A0)
	// 822E6270: 910B001C  stw r8, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 822E6274: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 822E6278: 897F0084  lbz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822E627C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E6280: 419A0098  beq cr6, 0x822e6318
	if ctx.cr[6].eq {
	pc = 0x822E6318; continue 'dispatch;
	}
	// 822E6284: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 822E6288: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822E628C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6290: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 822E6294: C1A6BA38  lfs f13, -0x45c8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6298: C187BFFC  lfs f12, -0x4004(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E629C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x822E62A0; continue 'dispatch;
            }
            0x822E62A0 => {
    //   block [0x822E62A0..0x822E6318)
	// 822E62A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E62A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E62A8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 822E62AC: 39290060  addi r9, r9, 0x60
	ctx.r[9].s64 = ctx.r[9].s64 + 96;
	// 822E62B0: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822E62B4: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 822E62B8: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 822E62BC: D1AB001C  stfs f13, 0x1c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 822E62C0: D00B0020  stfs f0, 0x20(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822E62C4: D00B0024  stfs f0, 0x24(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822E62C8: D00B0028  stfs f0, 0x28(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822E62CC: D00B002C  stfs f0, 0x2c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 822E62D0: 910B0050  stw r8, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 822E62D4: D18B0040  stfs f12, 0x40(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E62D8: D18B0044  stfs f12, 0x44(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 822E62DC: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822E62E0: D1AB0048  stfs f13, 0x48(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 822E62E4: D1AB004C  stfs f13, 0x4c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 822E62E8: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E62EC: D1AB0030  stfs f13, 0x30(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 822E62F0: D1AB0034  stfs f13, 0x34(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 822E62F4: D1AB0038  stfs f13, 0x38(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 822E62F8: D1AB003C  stfs f13, 0x3c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 822E62FC: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E6300: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 822E6304: 54E700BE  clrlwi r7, r7, 2
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x3FFFFFFFu64;
	// 822E6308: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 822E630C: 897F0084  lbz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822E6310: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822E6314: 4198FF8C  blt cr6, 0x822e62a0
	if ctx.cr[6].lt {
	pc = 0x822E62A0; continue 'dispatch;
	}
	pc = 0x822E6318; continue 'dispatch;
            }
            0x822E6318 => {
    //   block [0x822E6318..0x822E6330)
	// 822E6318: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E631C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E6320: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E6324: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E6328: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E632C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E6330 size=256
    let mut pc: u32 = 0x822E6330;
    'dispatch: loop {
        match pc {
            0x822E6330 => {
    //   block [0x822E6330..0x822E6368)
	// 822E6330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E6334: 4824ED7D  bl 0x825350b0
	ctx.lr = 0x822E6338;
	sub_82535080(ctx, base);
	// 822E6338: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E633C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822E6340: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822E6344: 897D0084  lbz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 822E6348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E634C: 419A00D4  beq cr6, 0x822e6420
	if ctx.cr[6].eq {
	pc = 0x822E6420; continue 'dispatch;
	}
	// 822E6350: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E6354: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6358: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822E635C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 822E6360: C1AABFFC  lfs f13, -0x4004(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6364: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x822E6368; continue 'dispatch;
            }
            0x822E6368 => {
    //   block [0x822E6368..0x822E63C0)
	// 822E6368: 817D00C4  lwz r11, 0xc4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E636C: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 822E6370: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 822E6374: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E6378: 888B0014  lbz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822E637C: 548B0030  rlwinm r11, r4, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 822E6380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E6384: 419A007C  beq cr6, 0x822e6400
	if ctx.cr[6].eq {
	pc = 0x822E6400; continue 'dispatch;
	}
	// 822E6388: 548B07FE  clrlwi r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 822E638C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822E6390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E6394: 419A002C  beq cr6, 0x822e63c0
	if ctx.cr[6].eq {
	pc = 0x822E63C0; continue 'dispatch;
	}
	// 822E6398: 48080DA1  bl 0x82367138
	ctx.lr = 0x822E639C;
	sub_82367138(ctx, base);
	// 822E639C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E63A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822E63A4: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E63A8: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 822E63AC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 822E63B0: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E63B4: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 822E63B8: 40990008  ble cr6, 0x822e63c0
	if !ctx.cr[6].gt {
	pc = 0x822E63C0; continue 'dispatch;
	}
	// 822E63BC: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x822E63C0; continue 'dispatch;
            }
            0x822E63C0 => {
    //   block [0x822E63C0..0x822E63F4)
	// 822E63C0: 548B07BC  rlwinm r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 822E63C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E63C8: 419A002C  beq cr6, 0x822e63f4
	if ctx.cr[6].eq {
	pc = 0x822E63F4; continue 'dispatch;
	}
	// 822E63CC: 48080D6D  bl 0x82367138
	ctx.lr = 0x822E63D0;
	sub_82367138(ctx, base);
	// 822E63D0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E63D4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822E63D8: C9810058  lfd f12, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822E63DC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 822E63E0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 822E63E4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E63E8: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 822E63EC: 40990008  ble cr6, 0x822e63f4
	if !ctx.cr[6].gt {
	pc = 0x822E63F4; continue 'dispatch;
	}
	// 822E63F0: 63DE0002  ori r30, r30, 2
	ctx.r[30].u64 = ctx.r[30].u64 | 2;
	pc = 0x822E63F4; continue 'dispatch;
            }
            0x822E63F4 => {
    //   block [0x822E63F4..0x822E6400)
	// 822E63F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E63F8: 53CBE086  rlwimi r11, r30, 0x1c, 2, 3
	ctx.r[11].u64 = (((ctx.r[30].u32).rotate_left(28) as u64) & 0x0000000030000000) | (ctx.r[11].u64 & 0xFFFFFFFFCFFFFFFF);
	// 822E63FC: 4800000C  b 0x822e6408
	pc = 0x822E6408; continue 'dispatch;
            }
            0x822E6400 => {
    //   block [0x822E6400..0x822E6408)
	// 822E6400: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E6404: 508BE086  rlwimi r11, r4, 0x1c, 2, 3
	ctx.r[11].u64 = (((ctx.r[4].u32).rotate_left(28) as u64) & 0x0000000030000000) | (ctx.r[11].u64 & 0xFFFFFFFFCFFFFFFF);
	pc = 0x822E6408; continue 'dispatch;
            }
            0x822E6408 => {
    //   block [0x822E6408..0x822E6420)
	// 822E6408: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822E640C: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 822E6410: 897D0084  lbz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 822E6414: 3B9C0060  addi r28, r28, 0x60
	ctx.r[28].s64 = ctx.r[28].s64 + 96;
	// 822E6418: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822E641C: 4198FF4C  blt cr6, 0x822e6368
	if ctx.cr[6].lt {
	pc = 0x822E6368; continue 'dispatch;
	}
	pc = 0x822E6420; continue 'dispatch;
            }
            0x822E6420 => {
    //   block [0x822E6420..0x822E6430)
	// 822E6420: 897D0084  lbz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 822E6424: 917D00BC  stw r11, 0xbc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 822E6428: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822E642C: 4824ECD4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E6430 size=84
    let mut pc: u32 = 0x822E6430;
    'dispatch: loop {
        match pc {
            0x822E6430 => {
    //   block [0x822E6430..0x822E6484)
	// 822E6430: 89630087  lbz r11, 0x87(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(135 as u32) ) } as u64;
	// 822E6434: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 822E6438: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 822E643C: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822E6440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E6444: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 822E6448: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E644C: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E6450: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822E6454: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822E6458: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E645C: C02300D4  lfs f1, 0xd4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E6460: 812300D0  lwz r9, 0xd0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E6464: 38C30088  addi r6, r3, 0x88
	ctx.r[6].s64 = ctx.r[3].s64 + 136;
	// 822E6468: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 822E646C: 80E300C4  lwz r7, 0xc4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6470: 808300C0  lwz r4, 0xc0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 822E6474: 38A300C8  addi r5, r3, 0xc8
	ctx.r[5].s64 = ctx.r[3].s64 + 200;
	// 822E6478: 806300BC  lwz r3, 0xbc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(188 as u32) ) } as u64;
	// 822E647C: 390B00A0  addi r8, r11, 0xa0
	ctx.r[8].s64 = ctx.r[11].s64 + 160;
	// 822E6480: 480055C8  b 0x822eba48
	sub_822EBA48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6484(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E6484 size=4
    let mut pc: u32 = 0x822E6484;
    'dispatch: loop {
        match pc {
            0x822E6484 => {
    //   block [0x822E6484..0x822E6488)
	// 822E6484: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E6488 size=304
    let mut pc: u32 = 0x822E6488;
    'dispatch: loop {
        match pc {
            0x822E6488 => {
    //   block [0x822E6488..0x822E65B8)
	// 822E6488: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 822E648C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 822E6490: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6494: 90830080  stw r4, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[4].u32 ) };
	// 822E6498: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 822E649C: 394300E0  addi r10, r3, 0xe0
	ctx.r[10].s64 = ctx.r[3].s64 + 224;
	// 822E64A0: 39230120  addi r9, r3, 0x120
	ctx.r[9].s64 = ctx.r[3].s64 + 288;
	// 822E64A4: 39030130  addi r8, r3, 0x130
	ctx.r[8].s64 = ctx.r[3].s64 + 304;
	// 822E64A8: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E64AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E64B0: 9BE30084  stb r31, 0x84(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[31].u8 ) };
	// 822E64B4: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E64B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E64BC: 3BCBC148  addi r30, r11, -0x3eb8
	ctx.r[30].s64 = ctx.r[11].s64 + -16056;
	// 822E64C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E64C4: 99630087  stb r11, 0x87(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(135 as u32), ctx.r[11].u8 ) };
	// 822E64C8: 916300C8  stw r11, 0xc8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 822E64CC: B16300CC  sth r11, 0xcc(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), ctx.r[11].u16 ) };
	// 822E64D0: B16300CE  sth r11, 0xce(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(206 as u32), ctx.r[11].u16 ) };
	// 822E64D4: D00300D4  stfs f0, 0xd4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 822E64D8: 916300D0  stw r11, 0xd0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 822E64DC: 9BE3001C  stb r31, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[31].u8 ) };
	// 822E64E0: 916300C4  stw r11, 0xc4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 822E64E4: 9BE3001E  stb r31, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[31].u8 ) };
	// 822E64E8: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822E64EC: 80850000  lwz r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E64F0: 908A0000  stw r4, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 822E64F4: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E64F8: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 822E64FC: 80850008  lwz r4, 8(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E6500: 908A0008  stw r4, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 822E6504: 80A5000C  lwz r5, 0xc(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E6508: D02300F0  stfs f1, 0xf0(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 822E650C: D04300F4  stfs f2, 0xf4(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 822E6510: D04300F8  stfs f2, 0xf8(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 822E6514: D0030110  stfs f0, 0x110(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 822E6518: 90AA000C  stw r5, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 822E651C: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E6520: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822E6524: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E6528: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822E652C: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E6530: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822E6534: 8147000C  lwz r10, 0xc(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E6538: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822E653C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E6540: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822E6544: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E6548: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822E654C: 81460008  lwz r10, 8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E6550: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822E6554: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E6558: D1A30150  stfs f13, 0x150(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 822E655C: 91630164  stw r11, 0x164(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 822E6560: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E6564: D0030154  stfs f0, 0x154(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 822E6568: 9BE3001C  stb r31, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[31].u8 ) };
	// 822E656C: D0030158  stfs f0, 0x158(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 822E6570: D003015C  stfs f0, 0x15c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 822E6574: 9148000C  stw r10, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822E6578: D0030160  stfs f0, 0x160(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 822E657C: A14BBAC4  lhz r10, -0x453c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-17724 as u32) ) } as u64;
	// 822E6580: D0030168  stfs f0, 0x168(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 822E6584: D0030140  stfs f0, 0x140(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 822E6588: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E658C: D0030144  stfs f0, 0x144(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 822E6590: D0030148  stfs f0, 0x148(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 822E6594: D1A3014C  stfs f13, 0x14c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 822E6598: D0030100  stfs f0, 0x100(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 822E659C: D0030104  stfs f0, 0x104(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 822E65A0: D0030108  stfs f0, 0x108(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 822E65A4: B14BBAC4  sth r10, -0x453c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(-17724 as u32), ctx.r[10].u16 ) };
	// 822E65A8: D1A3010C  stfs f13, 0x10c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 822E65AC: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E65B0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 822E65B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E65B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E65B8 size=160
    let mut pc: u32 = 0x822E65B8;
    'dispatch: loop {
        match pc {
            0x822E65B8 => {
    //   block [0x822E65B8..0x822E6644)
	// 822E65B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E65BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E65C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E65C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E65C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E65CC: 4BFFFB9D  bl 0x822e6168
	ctx.lr = 0x822E65D0;
	sub_822E6168(ctx, base);
	// 822E65D0: 897F0087  lbz r11, 0x87(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(135 as u32) ) } as u64;
	// 822E65D4: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 822E65D8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 822E65DC: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822E65E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E65E4: 409A0060  bne cr6, 0x822e6644
	if !ctx.cr[6].eq {
	pc = 0x822E6644; continue 'dispatch;
	}
	// 822E65E8: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E65EC: 397F00E0  addi r11, r31, 0xe0
	ctx.r[11].s64 = ctx.r[31].s64 + 224;
	// 822E65F0: 393F0120  addi r9, r31, 0x120
	ctx.r[9].s64 = ctx.r[31].s64 + 288;
	// 822E65F4: 390A0010  addi r8, r10, 0x10
	ctx.r[8].s64 = ctx.r[10].s64 + 16;
	// 822E65F8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 822E65FC: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 822E6600: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822E6604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E6608: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 822E660C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 822E6610: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822E6614: C01F00F0  lfs f0, 0xf0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6618: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E661C: D00B0040  stfs f0, 0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E6620: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6624: D00B0044  stfs f0, 0x44(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 822E6628: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E662C: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 822E6630: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 822E6634: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822E6638: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 822E663C: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 822E6640: 48000019  bl 0x822e6658
	ctx.lr = 0x822E6644;
	sub_822E6658(ctx, base);
	pc = 0x822E6644; continue 'dispatch;
            }
            0x822E6644 => {
    //   block [0x822E6644..0x822E6658)
	// 822E6644: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E6648: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E664C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E6650: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E6654: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E6658 size=292
    let mut pc: u32 = 0x822E6658;
    'dispatch: loop {
        match pc {
            0x822E6658 => {
    //   block [0x822E6658..0x822E6744)
	// 822E6658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E665C: 4824EA61  bl 0x825350bc
	ctx.lr = 0x822E6660;
	sub_82535080(ctx, base);
	// 822E6660: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E6664: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E6668: 4824CBA9  bl 0x82533210
	ctx.lr = 0x822E666C;
	sub_82533210(ctx, base);
	// 822E666C: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 822E6670: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6674: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822E6678: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E667C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E6680: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E6684: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E6688: C00B206C  lfs f0, 0x206c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E668C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E6690: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E6694: 48080AA5  bl 0x82367138
	ctx.lr = 0x822E6698;
	sub_82367138(ctx, base);
	// 822E6698: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E669C: 83DF0080  lwz r30, 0x80(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E66A0: 83BF00C4  lwz r29, 0xc4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E66A4: C00B2068  lfs f0, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E66A8: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E66AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822E66B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E66B4: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E66B8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E66BC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E66C0: C1AB2280  lfs f13, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E66C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E66C8: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E66CC: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E66D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E66D4: EDAC6838  fmsubs f13, f12, f0, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E66D8: C00B23FC  lfs f0, 0x23fc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E66DC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E66E0: D01F0158  stfs f0, 0x158(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 822E66E4: 4824CB2D  bl 0x82533210
	ctx.lr = 0x822E66E8;
	sub_82533210(ctx, base);
	// 822E66E8: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 822E66EC: A15E0010  lhz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822E66F0: 7D235BD6  divw r9, r3, r11
	ctx.r[9].s32 = ctx.r[3].s32 / ctx.r[11].s32;
	// 822E66F4: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822E66F8: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 822E66FC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822E6700: 917D0050  stw r11, 0x50(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822E6704: 4824CB0D  bl 0x82533210
	ctx.lr = 0x822E6708;
	sub_82533210(ctx, base);
	// 822E6708: 7C6B1670  srawi r11, r3, 2
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[3].s32 >> 2) as i64;
	// 822E670C: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 822E6710: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E6714: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 822E6718: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822E671C: 41980044  blt cr6, 0x822e6760
	if ctx.cr[6].lt {
	pc = 0x822E6760; continue 'dispatch;
	}
	// 822E6720: 419A0024  beq cr6, 0x822e6744
	if ctx.cr[6].eq {
	pc = 0x822E6744; continue 'dispatch;
	}
	// 822E6724: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 822E6728: 4098004C  bge cr6, 0x822e6774
	if !ctx.cr[6].lt {
	pc = 0x822E6774; continue 'dispatch;
	}
	// 822E672C: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6730: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E6734: 654A3000  oris r10, r10, 0x3000
	ctx.r[10].u64 = ctx.r[10].u64 | 805306368;
	// 822E6738: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822E673C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E6740: 4824E9CC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x822E6744 => {
    //   block [0x822E6744..0x822E6760)
	// 822E6744: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6748: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822E674C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E6750: 5149E886  rlwimi r9, r10, 0x1d, 2, 3
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(29) as u64) & 0x0000000030000000) | (ctx.r[9].u64 & 0xFFFFFFFFCFFFFFFF);
	// 822E6754: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 822E6758: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E675C: 4824E9B0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x822E6760 => {
    //   block [0x822E6760..0x822E6774)
	// 822E6760: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6764: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822E6768: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E676C: 5149E086  rlwimi r9, r10, 0x1c, 2, 3
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(28) as u64) & 0x0000000030000000) | (ctx.r[9].u64 & 0xFFFFFFFFCFFFFFFF);
	// 822E6770: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x822E6774; continue 'dispatch;
            }
            0x822E6774 => {
    //   block [0x822E6774..0x822E677C)
	// 822E6774: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E6778: 4824E994  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E6780 size=36
    let mut pc: u32 = 0x822E6780;
    'dispatch: loop {
        match pc {
            0x822E6780 => {
    //   block [0x822E6780..0x822E67A4)
	// 822E6780: 816300C4  lwz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6784: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E6788: C1AB003C  lfs f13, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E678C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6790: C00B223C  lfs f0, 0x223c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8764 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6794: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822E6798: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 822E679C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E67A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E67A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E67A8 size=964
    let mut pc: u32 = 0x822E67A8;
    'dispatch: loop {
        match pc {
            0x822E67A8 => {
    //   block [0x822E67A8..0x822E6800)
	// 822E67A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E67AC: 4824E90D  bl 0x825350b8
	ctx.lr = 0x822E67B0;
	sub_82535080(ctx, base);
	// 822E67B0: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 822E67B4: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 822E67B8: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822E67BC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E67C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E67C4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 822E67C8: 897F0087  lbz r11, 0x87(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(135 as u32) ) } as u64;
	// 822E67CC: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 822E67D0: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 822E67D4: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822E67D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E67DC: 419A0024  beq cr6, 0x822e6800
	if ctx.cr[6].eq {
	pc = 0x822E6800; continue 'dispatch;
	}
	// 822E67E0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 822E67E4: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 822E67E8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822E67EC: 409A001C  bne cr6, 0x822e6808
	if !ctx.cr[6].eq {
	pc = 0x822E6808; continue 'dispatch;
	}
	// 822E67F0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 822E67F4: 9B9F0025  stb r28, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[28].u8 ) };
	// 822E67F8: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 822E67FC: 4800000C  b 0x822e6808
	pc = 0x822E6808; continue 'dispatch;
            }
            0x822E6800 => {
    //   block [0x822E6800..0x822E6808)
	// 822E6800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E6804: 4BFFFB2D  bl 0x822e6330
	ctx.lr = 0x822E6808;
	sub_822E6330(ctx, base);
	pc = 0x822E6808; continue 'dispatch;
            }
            0x822E6808 => {
    //   block [0x822E6808..0x822E6840)
	// 822E6808: 897F0087  lbz r11, 0x87(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(135 as u32) ) } as u64;
	// 822E680C: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 822E6810: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 822E6814: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822E6818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E681C: 409A033C  bne cr6, 0x822e6b58
	if !ctx.cr[6].eq {
	pc = 0x822E6B58; continue 'dispatch;
	}
	// 822E6820: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E6824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E6828: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822E682C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E6830: 4E800421  bctrl
	ctx.lr = 0x822E6834;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E6834: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822E6838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E683C: 419A001C  beq cr6, 0x822e6858
	if ctx.cr[6].eq {
	pc = 0x822E6858; continue 'dispatch;
	}
            }
            0x822E6840 => {
    //   block [0x822E6840..0x822E6858)
	// 822E6840: 9B9F0087  stb r28, 0x87(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(135 as u32), ctx.r[28].u8 ) };
	// 822E6844: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822E6848: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822E684C: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822E6850: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822E6854: 4824E8B4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x822E6858 => {
    //   block [0x822E6858..0x822E68B4)
	// 822E6858: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E685C: C15F00F4  lfs f10, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E6860: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E6864: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E6868: FF0AF800  fcmpu cr6, f10, f31
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[31].f64);
	// 822E686C: 3BABBFF0  addi r29, r11, -0x4010
	ctx.r[29].s64 = ctx.r[11].s64 + -16400;
	// 822E6870: 4198004C  blt cr6, 0x822e68bc
	if ctx.cr[6].lt {
	pc = 0x822E68BC; continue 'dispatch;
	}
	// 822E6874: C17F00F8  lfs f11, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E6878: FF0BF800  fcmpu cr6, f11, f31
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[31].f64);
	// 822E687C: 4099FFC4  ble cr6, 0x822e6840
	if !ctx.cr[6].gt {
	pc = 0x822E6840; continue 'dispatch;
	}
	// 822E6880: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E6884: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 822E6888: 7C1D5C2E  lfsx f0, r29, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E688C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 822E6890: 396B2E68  addi r11, r11, 0x2e68
	ctx.r[11].s64 = ctx.r[11].s64 + 11880;
	// 822E6894: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6898: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E689C: C18B2278  lfs f12, 0x2278(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8824 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E68A0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 822E68A4: 40990010  ble cr6, 0x822e68b4
	if !ctx.cr[6].gt {
	pc = 0x822E68B4; continue 'dispatch;
	}
	// 822E68A8: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822E68AC: C1ABD5B0  lfs f13, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E68B0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x822E68B4; continue 'dispatch;
            }
            0x822E68B4 => {
    //   block [0x822E68B4..0x822E68BC)
	// 822E68B4: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E68B8: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	pc = 0x822E68BC; continue 'dispatch;
            }
            0x822E68BC => {
    //   block [0x822E68BC..0x822E68D4)
	// 822E68BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E68C0: FF0AF800  fcmpu cr6, f10, f31
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[31].f64);
	// 822E68C4: C3CBBA38  lfs f30, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822E68C8: 4098000C  bge cr6, 0x822e68d4
	if !ctx.cr[6].lt {
	pc = 0x822E68D4; continue 'dispatch;
	}
	// 822E68CC: D3DF0110  stfs f30, 0x110(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 822E68D0: 48000020  b 0x822e68f0
	pc = 0x822E68F0; continue 'dispatch;
            }
            0x822E68D4 => {
    //   block [0x822E68D4..0x822E68F0)
	// 822E68D4: C01F00F8  lfs f0, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E68D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E68DC: EDA05024  fdivs f13, f0, f10
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 822E68E0: C00B2604  lfs f0, 0x2604(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E68E4: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E68E8: 4BE36BE1  bl 0x8211d4c8
	ctx.lr = 0x822E68EC;
	sub_8211D4C8(ctx, base);
	// 822E68EC: D03F0110  stfs f1, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	pc = 0x822E68F0; continue 'dispatch;
            }
            0x822E68F0 => {
    //   block [0x822E68F0..0x822E6974)
	// 822E68F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E68F4: C01F0160  lfs f0, 0x160(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E68F8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822E68FC: C3ABBFFC  lfs f29, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822E6900: 409900E4  ble cr6, 0x822e69e4
	if !ctx.cr[6].gt {
	pc = 0x822E69E4; continue 'dispatch;
	}
	// 822E6904: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E6908: 806BB9D8  lwz r3, -0x4628(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 822E690C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E6910: 419A00D4  beq cr6, 0x822e69e4
	if ctx.cr[6].eq {
	pc = 0x822E69E4; continue 'dispatch;
	}
	// 822E6914: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6918: 3BDF0100  addi r30, r31, 0x100
	ctx.r[30].s64 = ctx.r[31].s64 + 256;
	// 822E691C: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 822E6920: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822E6924: 4BEB30B5  bl 0x821999d8
	ctx.lr = 0x822E6928;
	sub_821999D8(ctx, base);
	// 822E6928: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822E692C: C01F0104  lfs f0, 0x104(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6930: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 822E6934: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 822E6938: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 822E693C: 7C1D5C2E  lfsx f0, r29, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6940: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822E6944: 419A0030  beq cr6, 0x822e6974
	if ctx.cr[6].eq {
	pc = 0x822E6974; continue 'dispatch;
	}
	// 822E6948: EC1E0024  fdivs f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 822E694C: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6950: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E6954: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E6958: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E695C: D1BE0000  stfs f13, 0(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E6960: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E6964: D19E0004  stfs f12, 4(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822E6968: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E696C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E6970: 48000014  b 0x822e6984
	pc = 0x822E6984; continue 'dispatch;
            }
            0x822E6974 => {
    //   block [0x822E6974..0x822E6984)
	// 822E6974: D3FE0000  stfs f31, 0(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E6978: D3FE0004  stfs f31, 4(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822E697C: D3FE0008  stfs f31, 8(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E6980: D3DE000C  stfs f30, 0xc(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x822E6984; continue 'dispatch;
            }
            0x822E6984 => {
    //   block [0x822E6984..0x822E69E4)
	// 822E6984: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6988: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822E698C: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E6990: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6994: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E6998: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 822E699C: C1ABD5BC  lfs f13, -0x2a44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10820 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E69A0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 822E69A4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 822E69A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822E69AC: 40990038  ble cr6, 0x822e69e4
	if !ctx.cr[6].gt {
	pc = 0x822E69E4; continue 'dispatch;
	}
	// 822E69B0: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 822E69B4: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E69B8: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 822E69BC: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E69C0: C15E000C  lfs f10, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E69C4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E69C8: D19E0004  stfs f12, 4(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822E69CC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E69D0: D1BE0000  stfs f13, 0(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822E69D4: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E69D8: D17E0008  stfs f11, 8(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E69DC: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E69E0: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x822E69E4; continue 'dispatch;
            }
            0x822E69E4 => {
    //   block [0x822E69E4..0x822E6B58)
	// 822E69E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E69E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E69EC: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 822E69F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E69F4: 4E800421  bctrl
	ctx.lr = 0x822E69F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E69F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E69FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E6A00: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 822E6A04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E6A08: 4E800421  bctrl
	ctx.lr = 0x822E6A0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E6A0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E6A10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E6A14: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822E6A18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E6A1C: 4E800421  bctrl
	ctx.lr = 0x822E6A20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E6A20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E6A24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E6A28: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822E6A2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E6A30: 4E800421  bctrl
	ctx.lr = 0x822E6A34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E6A34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E6A38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E6A3C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 822E6A40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E6A44: 4E800421  bctrl
	ctx.lr = 0x822E6A48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E6A48: 395F0130  addi r10, r31, 0x130
	ctx.r[10].s64 = ctx.r[31].s64 + 304;
	// 822E6A4C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 822E6A50: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6A54: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 822E6A58: E8EA0000  ld r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 822E6A5C: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
            }
            0x822E6B58 => {
    //   block [0x822E6B58..0x822E6B6C)
	// 822E6B58: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822E6B5C: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822E6B60: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822E6B64: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822E6B68: 4824E5A0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E6B70 size=52
    let mut pc: u32 = 0x822E6B70;
    'dispatch: loop {
        match pc {
            0x822E6B70 => {
    //   block [0x822E6B70..0x822E6BA4)
	// 822E6B70: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E6B74: 812300C4  lwz r9, 0xc4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6B78: 388300C4  addi r4, r3, 0xc4
	ctx.r[4].s64 = ctx.r[3].s64 + 196;
	// 822E6B7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822E6B80: A14BBAC4  lhz r10, -0x453c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-17724 as u32) ) } as u64;
	// 822E6B84: 3D4A0001  addis r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 65536;
	// 822E6B88: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822E6B8C: B14BBAC4  sth r10, -0x453c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(-17724 as u32), ctx.r[10].u16 ) };
	// 822E6B90: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822E6B94: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E6B98: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 822E6B9C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 822E6BA0: 4BEBB4E0  b 0x821a2080
	sub_821A2080(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6BA4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E6BA4 size=4
    let mut pc: u32 = 0x822E6BA4;
    'dispatch: loop {
        match pc {
            0x822E6BA4 => {
    //   block [0x822E6BA4..0x822E6BA8)
	// 822E6BA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E6BA8 size=60
    let mut pc: u32 = 0x822E6BA8;
    'dispatch: loop {
        match pc {
            0x822E6BA8 => {
    //   block [0x822E6BA8..0x822E6BE4)
	// 822E6BA8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6BAC: C0030158  lfs f0, 0x158(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6BB0: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6BB4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822E6BB8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822E6BBC: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 822E6BC0: 816300C4  lwz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6BC4: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 822E6BC8: 394ABFF0  addi r10, r10, -0x4010
	ctx.r[10].s64 = ctx.r[10].s64 + -16400;
	// 822E6BCC: 612985D8  ori r9, r9, 0x85d8
	ctx.r[9].u64 = ctx.r[9].u64 | 34264;
	// 822E6BD0: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E6BD4: 7DAA4C2E  lfsx f13, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6BD8: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 822E6BDC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822E6BE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E6BE8 size=68
    let mut pc: u32 = 0x822E6BE8;
    'dispatch: loop {
        match pc {
            0x822E6BE8 => {
    //   block [0x822E6BE8..0x822E6C2C)
	// 822E6BE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6BEC: C003015C  lfs f0, 0x15c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6BF0: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6BF4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822E6BF8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822E6BFC: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 822E6C00: 816300C4  lwz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6C04: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 822E6C08: 394ABFF0  addi r10, r10, -0x4010
	ctx.r[10].s64 = ctx.r[10].s64 + -16400;
	// 822E6C0C: 612985D8  ori r9, r9, 0x85d8
	ctx.r[9].u64 = ctx.r[9].u64 | 34264;
	// 822E6C10: C18B0040  lfs f12, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E6C14: 7DAA4C2E  lfsx f13, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6C18: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 822E6C1C: D00B0040  stfs f0, 0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E6C20: 816300C4  lwz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6C24: D00B0044  stfs f0, 0x44(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 822E6C28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E6C30 size=228
    let mut pc: u32 = 0x822E6C30;
    'dispatch: loop {
        match pc {
            0x822E6C30 => {
    //   block [0x822E6C30..0x822E6CFC)
	// 822E6C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E6C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E6C38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E6C3C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822E6C40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E6C44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E6C48: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6C4C: C3FF0160  lfs f31, 0x160(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E6C50: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6C54: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 822E6C58: 419A00A4  beq cr6, 0x822e6cfc
	if ctx.cr[6].eq {
	pc = 0x822E6CFC; continue 'dispatch;
	}
	// 822E6C5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6C60: C1BF00F4  lfs f13, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6C64: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6C68: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E6C6C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E6C70: C1BF00F8  lfs f13, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6C74: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 822E6C78: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6C7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6C80: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E6C84: FDAC036E  fsel f13, f12, f13, f0
	ctx.f[13].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 822E6C88: C00B2604  lfs f0, 0x2604(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6C8C: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E6C90: 4BE36839  bl 0x8211d4c8
	ctx.lr = 0x822E6C94;
	sub_8211D4C8(ctx, base);
	// 822E6C94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6C98: C19F0104  lfs f12, 0x104(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E6C9C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E6CA0: C17F0108  lfs f11, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E6CA4: C15F010C  lfs f10, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E6CA8: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6CAC: 397F0130  addi r11, r31, 0x130
	ctx.r[11].s64 = ctx.r[31].s64 + 304;
	// 822E6CB0: C1AAD6C8  lfs f13, -0x2938(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6CB4: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 822E6CB8: C1BF0100  lfs f13, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x822E6CFC; continue 'dispatch;
            }
            0x822E6CFC => {
    //   block [0x822E6CFC..0x822E6D14)
	// 822E6CFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E6D00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E6D04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E6D08: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E6D0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E6D10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E6D18 size=52
    let mut pc: u32 = 0x822E6D18;
    'dispatch: loop {
        match pc {
            0x822E6D18 => {
    //   block [0x822E6D18..0x822E6D4C)
	// 822E6D18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6D1C: C0030154  lfs f0, 0x154(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6D20: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6D24: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822E6D28: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822E6D2C: C1A30134  lfs f13, 0x134(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6D30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6D34: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 822E6D38: C1AB2124  lfs f13, 0x2124(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8484 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6D3C: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E6D40: FC0C682E  fsel f0, f12, f0, f13
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 822E6D44: D0030134  stfs f0, 0x134(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 822E6D48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E6D50 size=140
    let mut pc: u32 = 0x822E6D50;
    'dispatch: loop {
        match pc {
            0x822E6D50 => {
    //   block [0x822E6D50..0x822E6DDC)
	// 822E6D50: 39630140  addi r11, r3, 0x140
	ctx.r[11].s64 = ctx.r[3].s64 + 320;
	// 822E6D54: 39430130  addi r10, r3, 0x130
	ctx.r[10].s64 = ctx.r[3].s64 + 304;
	// 822E6D58: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E6DE0 size=60
    let mut pc: u32 = 0x822E6DE0;
    'dispatch: loop {
        match pc {
            0x822E6DE0 => {
    //   block [0x822E6DE0..0x822E6E1C)
	// 822E6DE0: C1A30110  lfs f13, 0x110(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6DE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6DE8: C1830168  lfs f12, 0x168(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(360 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E6DEC: 814300C4  lwz r10, 0xc4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6DF0: C003012C  lfs f0, 0x12c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6DF4: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 822E6DF8: C9AB2008  lfd f13, 0x2008(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 822E6DFC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6E00: FC00682E  fsel f0, f0, f0, f13
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 822E6E04: C9AB2000  lfd f13, 0x2000(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 822E6E08: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 822E6E0C: FC0C036E  fsel f0, f12, f13, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 822E6E10: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E6E14: D00A003C  stfs f0, 0x3c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 822E6E18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E6E20 size=44
    let mut pc: u32 = 0x822E6E20;
    'dispatch: loop {
        match pc {
            0x822E6E20 => {
    //   block [0x822E6E20..0x822E6E44)
	// 822E6E20: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E6E24: A16BBAC4  lhz r11, -0x453c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-17724 as u32) ) } as u64;
	// 822E6E28: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 822E6E2C: 40980018  bge cr6, 0x822e6e44
	if !ctx.cr[6].lt {
	pc = 0x822E6E44; continue 'dispatch;
	}
	// 822E6E30: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E6E34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E6E38: 816BBFA0  lwz r11, -0x4060(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16480 as u32) ) } as u64;
	// 822E6E3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E6E40: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x822E6E44; continue 'dispatch;
            }
            0x822E6E44 => {
    //   block [0x822E6E44..0x822E6E4C)
	// 822E6E44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E6E48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E6E50 size=224
    let mut pc: u32 = 0x822E6E50;
    'dispatch: loop {
        match pc {
            0x822E6E50 => {
    //   block [0x822E6E50..0x822E6F30)
	// 822E6E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E6E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E6E58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E6E5C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E6E60: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822E6E64: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 822E6E68: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822E6E6C: 396B16E8  addi r11, r11, 0x16e8
	ctx.r[11].s64 = ctx.r[11].s64 + 5864;
	// 822E6E70: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 822E6E74: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 822E6E78: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822E6E7C: 388B06F0  addi r4, r11, 0x6f0
	ctx.r[4].s64 = ctx.r[11].s64 + 1776;
	// 822E6E80: C06ABA38  lfs f3, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822E6E84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E6E88: 4BFFF601  bl 0x822e6488
	ctx.lr = 0x822E6E8C;
	sub_822E6488(ctx, base);
	// 822E6E8C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E6E90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6E94: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 822E6E98: 396BC1F0  addi r11, r11, -0x3e10
	ctx.r[11].s64 = ctx.r[11].s64 + -15888;
	// 822E6E9C: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6EA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E6EA4: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 822E6EA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E6EAC: 995F0184  stb r10, 0x184(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[10].u8 ) };
	// 822E6EB0: D01F0170  stfs f0, 0x170(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 822E6EB4: D01F0174  stfs f0, 0x174(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 822E6EB8: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 822E6EBC: D07F017C  stfs f3, 0x17c(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 822E6EC0: 913F00D0  stw r9, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[9].u32 ) };
	// 822E6EC4: 48080275  bl 0x82367138
	ctx.lr = 0x822E6EC8;
	sub_82367138(ctx, base);
	// 822E6EC8: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E6ECC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6ED0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822E6ED4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E6ED8: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 822E6EDC: C00B2230  lfs f0, 0x2230(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6EE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6EE4: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 822E6EE8: 913F0164  stw r9, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[9].u32 ) };
	// 822E6EEC: C1AB26E4  lfs f13, 0x26e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9956 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6EF0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822E6EF4: D1BF0154  stfs f13, 0x154(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 822E6EF8: C18BD28C  lfs f12, -0x2d74(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11636 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E6EFC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E6F00: D19F0150  stfs f12, 0x150(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 822E6F04: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822E6F08: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E6F0C: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E6F10: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6F14: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E6F18: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 822E6F1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E6F20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E6F24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E6F28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E6F2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E6F30 size=76
    let mut pc: u32 = 0x822E6F30;
    'dispatch: loop {
        match pc {
            0x822E6F30 => {
    //   block [0x822E6F30..0x822E6F68)
	// 822E6F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E6F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E6F38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E6F3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E6F40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E6F44: 4BFFF675  bl 0x822e65b8
	ctx.lr = 0x822E6F48;
	sub_822E65B8(ctx, base);
	// 822E6F48: 897F0087  lbz r11, 0x87(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(135 as u32) ) } as u64;
	// 822E6F4C: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 822E6F50: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 822E6F54: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822E6F58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E6F5C: 409A000C  bne cr6, 0x822e6f68
	if !ctx.cr[6].eq {
	pc = 0x822E6F68; continue 'dispatch;
	}
	// 822E6F60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E6F64: 4800001D  bl 0x822e6f80
	ctx.lr = 0x822E6F68;
	sub_822E6F80(ctx, base);
	pc = 0x822E6F68; continue 'dispatch;
            }
            0x822E6F68 => {
    //   block [0x822E6F68..0x822E6F7C)
	// 822E6F68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E6F6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E6F70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E6F74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E6F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E6F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E6F80 size=228
    let mut pc: u32 = 0x822E6F80;
    'dispatch: loop {
        match pc {
            0x822E6F80 => {
    //   block [0x822E6F80..0x822E7064)
	// 822E6F80: 814300C4  lwz r10, 0xc4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E6F84: 39630130  addi r11, r3, 0x130
	ctx.r[11].s64 = ctx.r[3].s64 + 304;
	// 822E6F88: C1AA0040  lfs f13, 0x40(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6F8C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E6F90: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E6F94: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 822E6F98: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E6F9C: C00A26E0  lfs f0, 0x26e0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9952 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6FA0: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 822E6FA4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E6FA8: C00AD560  lfs f0, -0x2aa0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E6FAC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E6FB0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E6FB4: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6FB8: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 822E6FBC: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 822E6FC0: ED80682C  fsqrts f12, f13
	ctx.f[12].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 822E6FC4: C1AABFFC  lfs f13, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6FC8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E6FCC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E6FD0: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E6FD4: FC0C682E  fsel f0, f12, f0, f13
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 822E6FD8: C1AA1FF8  lfs f13, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E6FDC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822E6FE0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822E6FE4: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 822E6FE8: D1A30134  stfs f13, 0x134(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(308 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E7068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E7068 size=140
    let mut pc: u32 = 0x822E7068;
    'dispatch: loop {
        match pc {
            0x822E7068 => {
    //   block [0x822E7068..0x822E70F4)
	// 822E7068: 89630184  lbz r11, 0x184(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(388 as u32) ) } as u64;
	// 822E706C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E7070: 816300C4  lwz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E7074: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E7078: 419A007C  beq cr6, 0x822e70f4
	if ctx.cr[6].eq {
		sub_822E70F4(ctx, base);
		return;
	}
	// 822E707C: C00B0040  lfs f0, 0x40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7080: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E7084: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7088: C9AB26D8  lfd f13, 0x26d8(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(9944 as u32) ) };
	// 822E708C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7090: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 822E7094: FDAC682E  fsel f13, f12, f0, f13
	ctx.f[13].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 822E7098: C80B2000  lfd f0, 0x2000(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 822E709C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 822E70A0: FD8D0028  fsub f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 - ctx.f[0].f64;
	// 822E70A4: FDAC682E  fsel f13, f12, f0, f13
	ctx.f[13].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 822E70A8: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E70AC: C1ABD4D0  lfs f13, -0x2b30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11056 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E70B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E70B4: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E70B8: C1AB26D4  lfs f13, 0x26d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9940 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E70BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E70C0: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E70C4: C98B2008  lfd f12, 0x2008(r11)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 822E70C8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 822E70CC: FDAD636E  fsel f13, f13, f13, f12
	ctx.f[13].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[12].f64 };
	// 822E70D0: FD8D0028  fsub f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 - ctx.f[0].f64;
	// 822E70D4: FC0C682E  fsel f0, f12, f0, f13
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 822E70D8: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E70DC: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E70E0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E70E4: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 822E70E8: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 822E70EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E70F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E70F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E70F4 size=28
    let mut pc: u32 = 0x822E70F4;
    'dispatch: loop {
        match pc {
            0x822E70F4 => {
    //   block [0x822E70F4..0x822E7110)
	// 822E70F4: C1AB003C  lfs f13, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E70F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E70FC: C00B223C  lfs f0, 0x223c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8764 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7100: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822E7104: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 822E7108: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E710C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E7110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E7110 size=528
    let mut pc: u32 = 0x822E7110;
    'dispatch: loop {
        match pc {
            0x822E7110 => {
    //   block [0x822E7110..0x822E71E8)
	// 822E7110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E7114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E7118: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E711C: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 822E7120: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822E7124: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E7128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E712C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E7130: C01F0160  lfs f0, 0x160(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7134: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E7138: C18A2874  lfs f12, 0x2874(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E713C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E7140: ED200332  fmuls f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 822E7144: C19F0104  lfs f12, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E7148: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 822E714C: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E7150: C17F0100  lfs f11, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E7154: C10B0040  lfs f8, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822E7158: C14A2098  lfs f10, 0x2098(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8344 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E715C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 822E7160: ED4802B2  fmuls f10, f8, f10
	ctx.f[10].f64 = (((ctx.f[8].f64 * ctx.f[10].f64) as f32) as f64);
	// 822E7164: 390AD218  addi r8, r10, -0x2de8
	ctx.r[8].s64 = ctx.r[10].s64 + -11752;
	// 822E7168: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E716C: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 822E7170: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 822E7174: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 822E7178: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E717C: C0080078  lfs f0, 0x78(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7180: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7184: C9AA2000  lfd f13, 0x2000(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) };
	// 822E7188: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E718C: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 822E7190: FC0C682E  fsel f0, f12, f0, f13
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 822E7194: C9AA22D8  lfd f13, 0x22d8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8920 as u32) ) };
	// 822E7198: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E719C: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E71A0: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 822E71A4: 394ABFF0  addi r10, r10, -0x4010
	ctx.r[10].s64 = ctx.r[10].s64 + -16400;
	// 822E71A8: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 822E71AC: FC0C036E  fsel f0, f12, f13, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 822E71B0: FFC00018  frsp f30, f0
	ctx.f[30].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E71B4: EC0907B2  fmuls f0, f9, f30
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[30].f64) as f32) as f64);
	// 822E71B8: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 822E71BC: D01F015C  stfs f0, 0x15c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 822E71C0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822E71C4: 419A0024  beq cr6, 0x822e71e8
	if ctx.cr[6].eq {
	pc = 0x822E71E8; continue 'dispatch;
	}
	// 822E71C8: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 822E71CC: C18B0040  lfs f12, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E71D0: 612985D8  ori r9, r9, 0x85d8
	ctx.r[9].u64 = ctx.r[9].u64 | 34264;
	// 822E71D4: 7DAA4C2E  lfsx f13, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E71D8: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 822E71DC: D00B0040  stfs f0, 0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E71E0: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E71E4: D00B0044  stfs f0, 0x44(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	pc = 0x822E71E8; continue 'dispatch;
            }
            0x822E71E8 => {
    //   block [0x822E71E8..0x822E7288)
	// 822E71E8: C1BF0174  lfs f13, 0x174(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E71EC: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E71F0: C01F0178  lfs f0, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E71F4: C19F0170  lfs f12, 0x170(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E71F8: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 822E71FC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 822E7200: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 822E7204: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822E7208: 40990080  ble cr6, 0x822e7288
	if !ctx.cr[6].gt {
	pc = 0x822E7288; continue 'dispatch;
	}
	// 822E720C: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 822E7210: C1BF015C  lfs f13, 0x15c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E7214: E8FF0170  ld r7, 0x170(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	// 822E7218: 612985D8  ori r9, r9, 0x85d8
	ctx.r[9].u64 = ctx.r[9].u64 | 34264;
	// 822E721C: E8DF0178  ld r6, 0x178(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	// 822E7220: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E7224: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 822E7228: 7C0A4C2E  lfsx f0, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E722C: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 822E7230: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7234: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	pc = 0x822E7288; continue 'dispatch;
            }
            0x822E7288 => {
    //   block [0x822E7288..0x822E7320)
	// 822E7288: 897F0184  lbz r11, 0x184(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 822E728C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E7290: 409A0010  bne cr6, 0x822e72a0
	if !ctx.cr[6].eq {
	pc = 0x822E72A0; continue 'dispatch;
	}
	// 822E7294: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7298: C1AB207C  lfs f13, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E729C: 48000008  b 0x822e72a4
	pc = 0x822E72A4; continue 'dispatch;
	// 822E72A0: C1A80000  lfs f13, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E72A4: C01F00F4  lfs f0, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E72A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E72AC: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E72B0: C19F00F8  lfs f12, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E72B4: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E72B8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E72BC: FDACFB2E  fsel f13, f12, f12, f31
	ctx.f[13].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[31].f64 };
	// 822E72C0: EDAD0024  fdivs f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 822E72C4: C00B2604  lfs f0, 0x2604(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E72C8: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E72CC: 4BE361FD  bl 0x8211d4c8
	ctx.lr = 0x822E72D0;
	sub_8211D4C8(ctx, base);
	// 822E72D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E72D4: C19F0168  lfs f12, 0x168(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E72D8: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E72DC: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E72E0: EDBE0028  fsubs f13, f30, f0
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E72E4: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E72E8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 822E72EC: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E72F0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E72F4: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E72F8: FC00F82E  fsel f0, f0, f0, f31
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[31].f64 };
	// 822E72FC: EC0062FC  fnmsubs f0, f0, f11, f12
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 822E7300: D01F0168  stfs f0, 0x168(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 822E7304: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E7308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E730C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E7310: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822E7314: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E7318: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E731C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E7320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E7320 size=164
    let mut pc: u32 = 0x822E7320;
    'dispatch: loop {
        match pc {
            0x822E7320 => {
    //   block [0x822E7320..0x822E73C4)
	// 822E7320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E7324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E7328: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E732C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E7330: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 822E7334: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E7338: 806BA0CC  lwz r3, -0x5f34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24372 as u32) ) } as u64;
	// 822E733C: 4BFFE34D  bl 0x822e5688
	ctx.lr = 0x822E7340;
	sub_822E5688(ctx, base);
	// 822E7340: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E73C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E73C8 size=520
    let mut pc: u32 = 0x822E73C8;
    'dispatch: loop {
        match pc {
            0x822E73C8 => {
    //   block [0x822E73C8..0x822E7430)
	// 822E73C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E73CC: 4824DCE1  bl 0x825350ac
	ctx.lr = 0x822E73D0;
	sub_82535080(ctx, base);
	// 822E73D0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 822E73D4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 822E73D8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E73DC: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 822E73E0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822E73E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822E73E8: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 822E73EC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822E73F0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822E73F4: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 822E73F8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 822E73FC: 2F0A003C  cmpwi cr6, r10, 0x3c
	ctx.cr[6].compare_i32(ctx.r[10].s32, 60, &mut ctx.xer);
	// 822E7400: 419A01B0  beq cr6, 0x822e75b0
	if ctx.cr[6].eq {
	pc = 0x822E75B0; continue 'dispatch;
	}
	// 822E7404: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 822E7408: 419A01A8  beq cr6, 0x822e75b0
	if ctx.cr[6].eq {
	pc = 0x822E75B0; continue 'dispatch;
	}
	// 822E740C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E7410: A16BBAC4  lhz r11, -0x453c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-17724 as u32) ) } as u64;
	// 822E7414: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 822E7418: 40980018  bge cr6, 0x822e7430
	if !ctx.cr[6].lt {
	pc = 0x822E7430; continue 'dispatch;
	}
	// 822E741C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E7420: 816BBFA0  lwz r11, -0x4060(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16480 as u32) ) } as u64;
	// 822E7424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E7428: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E742C: 409A0008  bne cr6, 0x822e7434
	if !ctx.cr[6].eq {
	pc = 0x822E7434; continue 'dispatch;
	}
	pc = 0x822E7430; continue 'dispatch;
            }
            0x822E7430 => {
    //   block [0x822E7430..0x822E7434)
	// 822E7430: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822E7434; continue 'dispatch;
            }
            0x822E7434 => {
    //   block [0x822E7434..0x822E745C)
	// 822E7434: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E7438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E743C: 419A0174  beq cr6, 0x822e75b0
	if ctx.cr[6].eq {
	pc = 0x822E75B0; continue 'dispatch;
	}
	// 822E7440: 8961010F  lbz r11, 0x10f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(271 as u32) ) } as u64;
	// 822E7444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E7448: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E744C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 822E7450: 409A000C  bne cr6, 0x822e745c
	if !ctx.cr[6].eq {
	pc = 0x822E745C; continue 'dispatch;
	}
	// 822E7454: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822E7458: 48000008  b 0x822e7460
	pc = 0x822E7460; continue 'dispatch;
            }
            0x822E745C => {
    //   block [0x822E745C..0x822E7460)
	// 822E745C: 83EB0018  lwz r31, 0x18(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x822E7460; continue 'dispatch;
            }
            0x822E7460 => {
    //   block [0x822E7460..0x822E74B8)
	// 822E7460: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E7464: 419A014C  beq cr6, 0x822e75b0
	if ctx.cr[6].eq {
	pc = 0x822E75B0; continue 'dispatch;
	}
	// 822E7468: 2F0A0010  cmpwi cr6, r10, 0x10
	ctx.cr[6].compare_i32(ctx.r[10].s32, 16, &mut ctx.xer);
	// 822E746C: 409A008C  bne cr6, 0x822e74f8
	if !ctx.cr[6].eq {
	pc = 0x822E74F8; continue 'dispatch;
	}
	// 822E7470: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7474: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 822E7478: 38EBC188  addi r7, r11, -0x3e78
	ctx.r[7].s64 = ctx.r[11].s64 + -15992;
	// 822E747C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7480: 38A01385  li r5, 0x1385
	ctx.r[5].s64 = 4997;
	// 822E7484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E7488: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 822E748C: C00B2C28  lfs f0, 0x2c28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7490: EFFF0032  fmuls f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7494: 48082FFD  bl 0x8236a490
	ctx.lr = 0x822E7498;
	sub_8236A490(ctx, base);
	// 822E7498: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E749C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E74A0: 419A0050  beq cr6, 0x822e74f0
	if ctx.cr[6].eq {
	pc = 0x822E74F0; continue 'dispatch;
	}
	// 822E74A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822E74A8: 83DF0030  lwz r30, 0x30(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822E74AC: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 822E74B0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822E74B4: 48003D75  bl 0x822eb228
	ctx.lr = 0x822E74B8;
	sub_822EB228(ctx, base);
	pc = 0x822E74B8; continue 'dispatch;
            }
            0x822E74B8 => {
    //   block [0x822E74B8..0x822E74D0)
	// 822E74B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E74BC: FB3D0000  std r25, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[25].u64 ) };
	// 822E74C0: 419A0010  beq cr6, 0x822e74d0
	if ctx.cr[6].eq {
	pc = 0x822E74D0; continue 'dispatch;
	}
	// 822E74C4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822E74C8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822E74CC: 419A0008  beq cr6, 0x822e74d4
	if ctx.cr[6].eq {
	pc = 0x822E74D4; continue 'dispatch;
	}
	pc = 0x822E74D0; continue 'dispatch;
            }
            0x822E74D0 => {
    //   block [0x822E74D0..0x822E74D4)
	// 822E74D0: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	pc = 0x822E74D4; continue 'dispatch;
            }
            0x822E74D4 => {
    //   block [0x822E74D4..0x822E74F0)
	// 822E74D4: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822E74D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E74DC: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822E74E0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822E74E4: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 822E74E8: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 822E74EC: 4824DC10  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x822E74F0 => {
    //   block [0x822E74F0..0x822E74F8)
	// 822E74F0: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 822E74F4: 4BFFFFC4  b 0x822e74b8
	pc = 0x822E74B8; continue 'dispatch;
            }
            0x822E74F8 => {
    //   block [0x822E74F8..0x822E7570)
	// 822E74F8: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 822E74FC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822E7500: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 822E7504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822E7508: 4BFFFE19  bl 0x822e7320
	ctx.lr = 0x822E750C;
	sub_822E7320(ctx, base);
	// 822E750C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7510: C1A1005C  lfs f13, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E7514: C00B2238  lfs f0, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7518: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822E751C: 41980094  blt cr6, 0x822e75b0
	if ctx.cr[6].lt {
	pc = 0x822E75B0; continue 'dispatch;
	}
	// 822E7520: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7524: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 822E7528: 38EBC190  addi r7, r11, -0x3e70
	ctx.r[7].s64 = ctx.r[11].s64 + -15984;
	// 822E752C: 38A00385  li r5, 0x385
	ctx.r[5].s64 = 901;
	// 822E7530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E7534: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 822E7538: 48082F59  bl 0x8236a490
	ctx.lr = 0x822E753C;
	sub_8236A490(ctx, base);
	// 822E753C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E7540: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E7544: 419A0064  beq cr6, 0x822e75a8
	if ctx.cr[6].eq {
	pc = 0x822E75A8; continue 'dispatch;
	}
	// 822E7548: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E754C: 83DF0030  lwz r30, 0x30(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822E7550: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 822E7554: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 822E7558: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822E755C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822E7560: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822E7564: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822E7568: C06BBA38  lfs f3, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822E756C: 4BFFF8E5  bl 0x822e6e50
	ctx.lr = 0x822E7570;
	sub_822E6E50(ctx, base);
	pc = 0x822E7570; continue 'dispatch;
            }
            0x822E7570 => {
    //   block [0x822E7570..0x822E7588)
	// 822E7570: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E7574: FB3D0000  std r25, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[25].u64 ) };
	// 822E7578: 419A0010  beq cr6, 0x822e7588
	if ctx.cr[6].eq {
	pc = 0x822E7588; continue 'dispatch;
	}
	// 822E757C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822E7580: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822E7584: 419A0008  beq cr6, 0x822e758c
	if ctx.cr[6].eq {
	pc = 0x822E758C; continue 'dispatch;
	}
	pc = 0x822E7588; continue 'dispatch;
            }
            0x822E7588 => {
    //   block [0x822E7588..0x822E758C)
	// 822E7588: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	pc = 0x822E758C; continue 'dispatch;
            }
            0x822E758C => {
    //   block [0x822E758C..0x822E75A8)
	// 822E758C: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822E7590: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E7594: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822E7598: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822E759C: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 822E75A0: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 822E75A4: 4824DB58  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x822E75A8 => {
    //   block [0x822E75A8..0x822E75B0)
	// 822E75A8: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 822E75AC: 4BFFFFC4  b 0x822e7570
	pc = 0x822E7570; continue 'dispatch;
            }
            0x822E75B0 => {
    //   block [0x822E75B0..0x822E75D0)
	// 822E75B0: FB3D0000  std r25, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[25].u64 ) };
	// 822E75B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E75B8: 933D0004  stw r25, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822E75BC: 933D0000  stw r25, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822E75C0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822E75C4: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 822E75C8: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 822E75CC: 4824DB30  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E75D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E75D0 size=988
    let mut pc: u32 = 0x822E75D0;
    'dispatch: loop {
        match pc {
            0x822E75D0 => {
    //   block [0x822E75D0..0x822E799C)
	// 822E75D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E75D4: 4824DAC9  bl 0x8253509c
	ctx.lr = 0x822E75D8;
	sub_82535080(ctx, base);
	// 822E75D8: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 822E75DC: 4824E9F9  bl 0x82535fd4
	ctx.lr = 0x822E75E0;
	sub_82535FB0(ctx, base);
	// 822E75E0: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E75E4: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 822E75E8: FF200890  fmr f25, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[25].f64 = ctx.f[1].f64;
	// 822E75EC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 822E75F0: FEE01090  fmr f23, f2
	ctx.f[23].f64 = ctx.f[2].f64;
	// 822E75F4: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 822E75F8: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 822E75FC: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 822E7600: 2F17003C  cmpwi cr6, r23, 0x3c
	ctx.cr[6].compare_i32(ctx.r[23].s32, 60, &mut ctx.xer);
	// 822E7604: 419A0398  beq cr6, 0x822e799c
	if ctx.cr[6].eq {
	pc = 0x822E799C; continue 'dispatch;
	}
	// 822E7608: 2F170004  cmpwi cr6, r23, 4
	ctx.cr[6].compare_i32(ctx.r[23].s32, 4, &mut ctx.xer);
	// 822E760C: 419A0390  beq cr6, 0x822e799c
	if ctx.cr[6].eq {
	pc = 0x822E799C; continue 'dispatch;
	}
	// 822E7610: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E7614: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 822E7618: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 822E761C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 822E7620: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 822E7624: 830B0014  lwz r24, 0x14(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822E7628: 4BFFFCF9  bl 0x822e7320
	ctx.lr = 0x822E762C;
	sub_822E7320(ctx, base);
	// 822E762C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7630: C1A100AC  lfs f13, 0xac(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E7634: C00B2238  lfs f0, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7638: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822E763C: 41980360  blt cr6, 0x822e799c
	if ctx.cr[6].lt {
	pc = 0x822E799C; continue 'dispatch;
	}
	// 822E7640: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7644: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7648: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822E764C: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822E7650: 396BD6D0  addi r11, r11, -0x2930
	ctx.r[11].s64 = ctx.r[11].s64 + -10544;
	// 822E7654: C00BFB48  lfs f0, -0x4b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7658: C38B0000  lfs f28, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 822E765C: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822E7660: D38100B8  stfs f28, 0xb8(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822E7664: 4807FAD5  bl 0x82367138
	ctx.lr = 0x822E7668;
	sub_82367138(ctx, base);
	// 822E7668: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E766C: C00B2C2C  lfs f0, 0x2c2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7670: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E7674: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822E7678: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E767C: C3EB2280  lfs f31, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E7680: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822E7684: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E7688: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E768C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E7690: ED8D07F2  fmuls f12, f13, f31
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 822E7694: C1ABD468  lfs f13, -0x2b98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E7698: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 822E769C: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 822E76A0: 4807FA99  bl 0x82367138
	ctx.lr = 0x822E76A4;
	sub_82367138(ctx, base);
	// 822E76A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E76A8: C00B235C  lfs f0, 0x235c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E76AC: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822E76B0: C1ABD478  lfs f13, -0x2b88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E76B4: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E76B8: D1A100C4  stfs f13, 0xc4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822E76BC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822E76C0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E76C4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E76C8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E76CC: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 822E76D0: EC0DE03A  fmadds f0, f13, f0, f28
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64);
	// 822E76D4: D00100C0  stfs f0, 0xc0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 822E76D8: 4807FA61  bl 0x82367138
	ctx.lr = 0x822E76DC;
	sub_82367138(ctx, base);
	// 822E76DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E76E0: C00B2B94  lfs f0, 0x2b94(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E76E4: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E76E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822E76EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E76F0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E76F4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E76F8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E76FC: ED8D07F2  fmuls f12, f13, f31
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 822E7700: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E7704: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 822E7708: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 822E770C: 4807FA2D  bl 0x82367138
	ctx.lr = 0x822E7710;
	sub_82367138(ctx, base);
	// 822E7710: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7714: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 822E7718: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E771C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E7720: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822E7724: C00B2278  lfs f0, 0x2278(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7728: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E772C: D00100D0  stfs f0, 0xd0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 822E7730: 3BA100B8  addi r29, r1, 0xb8
	ctx.r[29].s64 = ctx.r[1].s64 + 184;
	// 822E7734: C36920C8  lfs f27, 0x20c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8392 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 822E7738: C34A1FF8  lfs f26, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 822E773C: C3082C28  lfs f24, 0x2c28(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(11304 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 822E7740: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822E7744: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E7748: C3ABBA38  lfs f29, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822E774C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7750: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E7754: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E7758: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E775C: EDA0EFFA  fmadds f13, f0, f31, f29
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64);
	// 822E7760: C00BD6C8  lfs f0, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7764: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7768: 3B6BC198  addi r27, r11, -0x3e68
	ctx.r[27].s64 = ctx.r[11].s64 + -15976;
	// 822E776C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7770: 3B4BC188  addi r26, r11, -0x3e78
	ctx.r[26].s64 = ctx.r[11].s64 + -15992;
	// 822E7774: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7778: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 822E777C: 4BFFF6A5  bl 0x822e6e20
	ctx.lr = 0x822E7780;
	sub_822E6E20(ctx, base);
	// 822E7780: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822E7784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E7788: 419A0214  beq cr6, 0x822e799c
	if ctx.cr[6].eq {
	pc = 0x822E799C; continue 'dispatch;
	}
	// 822E778C: C1BD0000  lfs f13, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E7790: FC006850  fneg f0, f13
	ctx.f[0].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 822E7794: 4807F9A5  bl 0x82367138
	ctx.lr = 0x822E7798;
	sub_82367138(ctx, base);
	// 822E7798: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E779C: ED8D0028  fsubs f12, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E77A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822E77A4: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E77A8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 822E77AC: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 822E77B0: ED6B07F2  fmuls f11, f11, f31
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 822E77B4: ED8B033A  fmadds f12, f11, f12, f0
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 822E77B8: D1810090  stfs f12, 0x90(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 822E77BC: 4807F97D  bl 0x82367138
	ctx.lr = 0x822E77C0;
	sub_82367138(ctx, base);
	// 822E77C0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E77C4: ED6D0028  fsubs f11, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E77C8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822E77CC: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822E77D0: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 822E77D4: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 822E77D8: ED4A07F2  fmuls f10, f10, f31
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[31].f64) as f32) as f64);
	// 822E77DC: ED6A02FA  fmadds f11, f10, f11, f0
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 822E77E0: ED6B0732  fmuls f11, f11, f28
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[28].f64) as f32) as f64);
	// 822E77E4: D1610094  stfs f11, 0x94(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 822E77E8: 4807F951  bl 0x82367138
	ctx.lr = 0x822E77EC;
	sub_82367138(ctx, base);
	// 822E77EC: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E77F0: D1810080  stfs f12, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 822E77F4: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E77F8: C19DFFF8  lfs f12, -8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E77FC: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 822E7800: EFCC0672  fmuls f30, f12, f25
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[25].f64) as f32) as f64);
	// 822E7804: D3410084  stfs f26, 0x84(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 822E7808: D3A1008C  stfs f29, 0x8c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 822E780C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822E7810: 11A1034A  vcfsx v13, v0, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[13].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 822E7814: 1180034A  vcfsx v12, v0, 0
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[12].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 822E7818: C9810060  lfd f12, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822E781C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 822E7820: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 822E7824: ED8C07F2  fmuls f12, f12, f31
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 822E7828: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 822E782C: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 822E7830: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 822E7834: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	pc = 0x822E799C; continue 'dispatch;
            }
            0x822E799C => {
    //   block [0x822E799C..0x822E79AC)
	// 822E799C: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 822E79A0: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 822E79A4: 4824E67D  bl 0x82536020
	ctx.lr = 0x822E79A8;
	sub_82535FFC(ctx, base);
	// 822E79A8: 4824D744  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E79B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E79B0 size=892
    let mut pc: u32 = 0x822E79B0;
    'dispatch: loop {
        match pc {
            0x822E79B0 => {
    //   block [0x822E79B0..0x822E7A94)
	// 822E79B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E79B4: 4824D709  bl 0x825350bc
	ctx.lr = 0x822E79B8;
	sub_82535080(ctx, base);
	// 822E79B8: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 822E79BC: 4824E60D  bl 0x82535fc8
	ctx.lr = 0x822E79C0;
	sub_82535FB0(ctx, base);
	// 822E79C0: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E79C4: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 822E79C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E79CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E79D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822E79D4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822E79D8: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E79DC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822E79E0: 4099033C  ble cr6, 0x822e7d1c
	if !ctx.cr[6].gt {
	pc = 0x822E7D1C; continue 'dispatch;
	}
	// 822E79E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E79E8: 2F1D003C  cmpwi cr6, r29, 0x3c
	ctx.cr[6].compare_i32(ctx.r[29].s32, 60, &mut ctx.xer);
	// 822E79EC: C9AB2008  lfd f13, 0x2008(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 822E79F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E79F4: FC00682E  fsel f0, f0, f0, f13
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 822E79F8: C9AB2000  lfd f13, 0x2000(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 822E79FC: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 822E7A00: FC0C036E  fsel f0, f12, f13, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 822E7A04: FFA00018  frsp f29, f0
	ctx.f[29].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E7A08: 419A0314  beq cr6, 0x822e7d1c
	if ctx.cr[6].eq {
	pc = 0x822E7D1C; continue 'dispatch;
	}
	// 822E7A0C: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 822E7A10: 419A030C  beq cr6, 0x822e7d1c
	if ctx.cr[6].eq {
	pc = 0x822E7D1C; continue 'dispatch;
	}
	// 822E7A14: 2F1D0010  cmpwi cr6, r29, 0x10
	ctx.cr[6].compare_i32(ctx.r[29].s32, 16, &mut ctx.xer);
	// 822E7A18: 419A0304  beq cr6, 0x822e7d1c
	if ctx.cr[6].eq {
	pc = 0x822E7D1C; continue 'dispatch;
	}
	// 822E7A1C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E7A20: 616B9C00  ori r11, r11, 0x9c00
	ctx.r[11].u64 = ctx.r[11].u64 | 39936;
	// 822E7A24: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E7A28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E7A2C: 419A02F0  beq cr6, 0x822e7d1c
	if ctx.cr[6].eq {
	pc = 0x822E7D1C; continue 'dispatch;
	}
	// 822E7A30: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822E7A34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E7A38: 419A02E4  beq cr6, 0x822e7d1c
	if ctx.cr[6].eq {
	pc = 0x822E7D1C; continue 'dispatch;
	}
	// 822E7A3C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E7A40: 616BEB2B  ori r11, r11, 0xeb2b
	ctx.r[11].u64 = ctx.r[11].u64 | 60203;
	// 822E7A44: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E7A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E7A4C: 409A02D0  bne cr6, 0x822e7d1c
	if !ctx.cr[6].eq {
	pc = 0x822E7D1C; continue 'dispatch;
	}
	// 822E7A50: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E7A54: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E7A58: A16BBAC4  lhz r11, -0x453c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-17724 as u32) ) } as u64;
	// 822E7A5C: C28ABFFC  lfs f20, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 822E7A60: 2B0B001E  cmplwi cr6, r11, 0x1e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 30 as u32, &mut ctx.xer);
	// 822E7A64: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7A68: C2AB206C  lfs f21, 0x206c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8300 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 822E7A6C: 41980028  blt cr6, 0x822e7a94
	if ctx.cr[6].lt {
	pc = 0x822E7A94; continue 'dispatch;
	}
	// 822E7A70: 4824B7A1  bl 0x82533210
	ctx.lr = 0x822E7A74;
	sub_82533210(ctx, base);
	// 822E7A74: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 822E7A78: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822E7A7C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E7A80: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E7A84: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E7A88: EC000572  fmuls f0, f0, f21
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[21].f64) as f32) as f64);
	// 822E7A8C: FF00A000  fcmpu cr6, f0, f20
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[20].f64);
	// 822E7A90: 4098028C  bge cr6, 0x822e7d1c
	if !ctx.cr[6].lt {
	pc = 0x822E7D1C; continue 'dispatch;
	}
	pc = 0x822E7A94; continue 'dispatch;
            }
            0x822E7A94 => {
    //   block [0x822E7A94..0x822E7BBC)
	// 822E7A94: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822E7A98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E7A9C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822E7AA0: 4BFFE369  bl 0x822e5e08
	ctx.lr = 0x822E7AA4;
	sub_822E5E08(ctx, base);
	// 822E7AA4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E7AA8: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 822E7AAC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822E7AB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E7AB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822E7AB8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822E7ABC: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 822E7AC0: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822E7AC4: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822E7AC8: 4BFFE3E1  bl 0x822e5ea8
	ctx.lr = 0x822E7ACC;
	sub_822E5EA8(ctx, base);
	// 822E7ACC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E7AD0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E7AD4: 6168BED4  ori r8, r11, 0xbed4
	ctx.r[8].u64 = ctx.r[11].u64 | 48852;
	// 822E7AD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7ADC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822E7AE0: C38A203C  lfs f28, 0x203c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8252 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 822E7AE4: 7D5F402E  lwzx r10, r31, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 822E7AE8: FD80E090  fmr f12, f28
	ctx.f[12].f64 = ctx.f[28].f64;
	// 822E7AEC: C16B2630  lfs f11, 0x2630(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9776 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E7AF0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E7AF4: E9030008  ld r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 822E7AF8: A14A0004  lhz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E7AFC: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E7B00: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 822E7B04: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822E7B08: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822E7B0C: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822E7B10: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 822E7B14: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822E7B18: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 822E7B1C: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 822E7B20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7B24: C1A10088  lfs f13, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E7B28: ED2D0372  fmuls f9, f13, f13
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E7B2C: C1410084  lfs f10, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E7B30: C2E10080  lfs f23, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 822E7B34: C9AB20B8  lfd f13, 0x20b8(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8376 as u32) ) };
	// 822E7B38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7B3C: C34B2470  lfs f26, 0x2470(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9328 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 822E7B40: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7B44: ED4A4ABA  fmadds f10, f10, f10, f9
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[9].f64) as f32) as f64);
	// 822E7B48: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E7B4C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E7B50: FD006828  fsub f8, f0, f13
	ctx.f[8].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 822E7B54: FC08036E  fsel f0, f8, f13, f0
	ctx.f[0].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 822E7B58: EDB755FA  fmadds f13, f23, f23, f10
	ctx.f[13].f64 = (((ctx.f[23].f64 * ctx.f[23].f64 + ctx.f[10].f64) as f32) as f64);
	// 822E7B5C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E7B60: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 822E7B64: EFC0D2FA  fmadds f30, f0, f11, f26
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[26].f64) as f32) as f64);
	// 822E7B68: C00B2CA0  lfs f0, 0x2ca0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11424 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7B6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7B70: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 822E7B74: EF1E0032  fmuls f24, f30, f0
	ctx.f[24].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7B78: C00B2C84  lfs f0, 0x2c84(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7B7C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7B80: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 822E7B84: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 822E7B88: 89610057  lbz r11, 0x57(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 822E7B8C: 216B0001  subfic r11, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[11].s64 = (1 as i64) - ctx.r[11].s64;
	// 822E7B90: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E7B94: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 822E7B98: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 822E7B9C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7BA0: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7BA4: 41980044  blt cr6, 0x822e7be8
	if ctx.cr[6].lt {
	pc = 0x822E7BE8; continue 'dispatch;
	}
	// 822E7BA8: 397FFFF7  addi r11, r31, -9
	ctx.r[11].s64 = ctx.r[31].s64 + -9;
	// 822E7BAC: 556BE8FE  srwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E7BB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822E7BB4: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E7BB8: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	pc = 0x822E7BBC; continue 'dispatch;
            }
            0x822E7BBC => {
    //   block [0x822E7BBC..0x822E7BE8)
	// 822E7BBC: EDAC0032  fmuls f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7BC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E7BC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E7BC8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7BCC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7BD0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7BD4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7BD8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7BDC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7BE0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7BE4: 409AFFD8  bne cr6, 0x822e7bbc
	if !ctx.cr[6].eq {
	pc = 0x822E7BBC; continue 'dispatch;
	}
	pc = 0x822E7BE8; continue 'dispatch;
            }
            0x822E7BE8 => {
    //   block [0x822E7BE8..0x822E7BF4)
	// 822E7BE8: 7F09F800  cmpw cr6, r9, r31
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[31].s32, &mut ctx.xer);
	// 822E7BEC: 40980018  bge cr6, 0x822e7c04
	if !ctx.cr[6].lt {
	pc = 0x822E7C04; continue 'dispatch;
	}
	// 822E7BF0: 7D69F850  subf r11, r9, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	pc = 0x822E7BF4; continue 'dispatch;
            }
            0x822E7BF4 => {
    //   block [0x822E7BF4..0x822E7C04)
	// 822E7BF4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E7BF8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E7C00: 409AFFF4  bne cr6, 0x822e7bf4
	if !ctx.cr[6].eq {
	pc = 0x822E7BF4; continue 'dispatch;
	}
	pc = 0x822E7C04; continue 'dispatch;
            }
            0x822E7C04 => {
    //   block [0x822E7C04..0x822E7CDC)
	// 822E7C04: EF6C0772  fmuls f27, f12, f29
	ctx.f[27].f64 = (((ctx.f[12].f64 * ctx.f[29].f64) as f32) as f64);
	// 822E7C08: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822E7C0C: D361007C  stfs f27, 0x7c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822E7C10: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 822E7C14: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822E7C18: 40990104  ble cr6, 0x822e7d1c
	if !ctx.cr[6].gt {
	pc = 0x822E7D1C; continue 'dispatch;
	}
	// 822E7C1C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E7C20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7C24: C32A2054  lfs f25, 0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8276 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 822E7C28: C2CB2144  lfs f22, 0x2144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8516 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 822E7C2C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 822E7C30: EC1707B2  fmuls f0, f23, f30
	ctx.f[0].f64 = (((ctx.f[23].f64 * ctx.f[30].f64) as f32) as f64);
	// 822E7C34: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 822E7C38: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822E7C3C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822E7C40: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 822E7C44: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822E7C48: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822E7C4C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E7C50: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7C54: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 822E7C58: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822E7C5C: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7C60: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 822E7C64: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822E7C68: 419A0074  beq cr6, 0x822e7cdc
	if ctx.cr[6].eq {
	pc = 0x822E7CDC; continue 'dispatch;
	}
	// 822E7C6C: 4824B5A5  bl 0x82533210
	ctx.lr = 0x822E7C70;
	sub_82533210(ctx, base);
	// 822E7C70: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 822E7C74: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 822E7C78: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822E7C7C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E7C80: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E7C84: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E7C88: EC00A578  fmsubs f0, f0, f21, f20
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[21].f64 - ctx.f[20].f64) as f32) as f64);
	// 822E7C8C: EC2005B2  fmuls f1, f0, f22
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[22].f64) as f32) as f64);
	// 822E7C90: 48080329  bl 0x82367fb8
	ctx.lr = 0x822E7C94;
	sub_82367FB8(ctx, base);
	// 822E7C94: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 822E7C98: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x822E7CDC; continue 'dispatch;
            }
            0x822E7CDC => {
    //   block [0x822E7CDC..0x822E7D1C)
	// 822E7CDC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822E7CE0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 822E7CE4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 822E7CE8: FC40C890  fmr f2, f25
	ctx.f[2].f64 = ctx.f[25].f64;
	// 822E7CEC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822E7CF0: EC3D0632  fmuls f1, f29, f24
	ctx.f[1].f64 = (((ctx.f[29].f64 * ctx.f[24].f64) as f32) as f64);
	// 822E7CF4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 822E7CF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E7CFC: 4BFFF8D5  bl 0x822e75d0
	ctx.lr = 0x822E7D00;
	sub_822E75D0(ctx, base);
	// 822E7D00: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822E7D04: EF7B0732  fmuls f27, f27, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = (((ctx.f[27].f64 * ctx.f[28].f64) as f32) as f64);
	// 822E7D08: D361007C  stfs f27, 0x7c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822E7D0C: EFDE06B2  fmuls f30, f30, f26
	ctx.f[30].f64 = (((ctx.f[30].f64 * ctx.f[26].f64) as f32) as f64);
	// 822E7D10: 7F1EF800  cmpw cr6, r30, r31
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[31].s32, &mut ctx.xer);
	// 822E7D14: EFBD0732  fmuls f29, f29, f28
	ctx.f[29].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 822E7D18: 4198FF14  blt cr6, 0x822e7c2c
	if ctx.cr[6].lt {
	pc = 0x822E7C2C; continue 'dispatch;
	}
	pc = 0x822E7D1C; continue 'dispatch;
            }
            0x822E7D1C => {
    //   block [0x822E7D1C..0x822E7D2C)
	// 822E7D1C: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 822E7D20: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 822E7D24: 4824E2F1  bl 0x82536014
	ctx.lr = 0x822E7D28;
	sub_82535FFC(ctx, base);
	// 822E7D28: 4824D3E4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E7D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E7D30 size=1552
    let mut pc: u32 = 0x822E7D30;
    'dispatch: loop {
        match pc {
            0x822E7D30 => {
    //   block [0x822E7D30..0x822E8044)
	// 822E7D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E7D34: 4824D34D  bl 0x82535080
	ctx.lr = 0x822E7D38;
	sub_82535080(ctx, base);
	// 822E7D38: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 822E7D3C: 4824E275  bl 0x82535fb0
	ctx.lr = 0x822E7D40;
	sub_82535FB0(ctx, base);
	// 822E7D40: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E7D44: D0210294  stfs f1, 0x294(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(660 as u32), tmp.u32 ) };
	// 822E7D48: 90610284  stw r3, 0x284(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(644 as u32), ctx.r[3].u32 ) };
	// 822E7D4C: D04102AC  stfs f2, 0x2ac(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(684 as u32), tmp.u32 ) };
	// 822E7D50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E7D54: D06102B4  stfs f3, 0x2b4(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(692 as u32), tmp.u32 ) };
	// 822E7D58: 7CCF3378  mr r15, r6
	ctx.r[15].u64 = ctx.r[6].u64;
	// 822E7D5C: F8E102A0  std r7, 0x2a0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(672 as u32), ctx.r[7].u64 ) };
	// 822E7D60: 4BECFA01  bl 0x821b7760
	ctx.lr = 0x822E7D64;
	sub_821B7760(ctx, base);
	// 822E7D64: 906100B4  stw r3, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 822E7D68: 4824B4A9  bl 0x82533210
	ctx.lr = 0x822E7D6C;
	sub_82533210(ctx, base);
	// 822E7D6C: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 822E7D70: 7FEA07B4  extsw r10, r31
	ctx.r[10].s64 = ctx.r[31].s32 as i64;
	// 822E7D74: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822E7D78: F96100A8  std r11, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 822E7D7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E7D80: F9410090  std r10, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 822E7D84: C8010090  lfd f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 822E7D88: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E7D8C: C38BBA38  lfs f28, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 822E7D90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7D94: C26B206C  lfs f19, 0x206c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8300 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 822E7D98: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E7D9C: EC1C0024  fdivs f0, f28, f0
	ctx.f[0].f64 = ((ctx.f[28].f64 / ctx.f[0].f64) as f32) as f64;
	// 822E7DA0: C9A100A8  lfd f13, 0xa8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 822E7DA4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E7DA8: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E7DAC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E7DB0: EC0D04F2  fmuls f0, f13, f19
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[19].f64) as f32) as f64);
	// 822E7DB4: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822E7DB8: 40990578  ble cr6, 0x822e8330
	if !ctx.cr[6].gt {
	pc = 0x822E8330; continue 'dispatch;
	}
	// 822E7DBC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E7DC0: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 822E7DC4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E7DC8: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 822E7DCC: 3F808286  lis r28, -0x7d7a
	ctx.r[28].s64 = -2105147392;
	// 822E7DD0: 3F40820D  lis r26, -0x7df3
	ctx.r[26].s64 = -2113077248;
	// 822E7DD4: C00A2038  lfs f0, 0x2038(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7DD8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E7DDC: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822E7DE0: 3F20820D  lis r25, -0x7df3
	ctx.r[25].s64 = -2113077248;
	// 822E7DE4: C009203C  lfs f0, 0x203c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7DE8: 3EC0820D  lis r22, -0x7df3
	ctx.r[22].s64 = -2113077248;
	// 822E7DEC: D00100C0  stfs f0, 0xc0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 822E7DF0: 3A2BC470  addi r17, r11, -0x3b90
	ctx.r[17].s64 = ctx.r[11].s64 + -15248;
	// 822E7DF4: C0082B70  lfs f0, 0x2b70(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(11120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7DF8: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 822E7DFC: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 822E7E00: 3EA0820D  lis r21, -0x7df3
	ctx.r[21].s64 = -2113077248;
	// 822E7E04: C01CD478  lfs f0, -0x2b88(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7E08: 3E60820B  lis r19, -0x7df5
	ctx.r[19].s64 = -2113208320;
	// 822E7E0C: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 822E7E10: 3E80820C  lis r20, -0x7df4
	ctx.r[20].s64 = -2113142784;
	// 822E7E14: C01A2144  lfs f0, 0x2144(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7E18: 3EE0820D  lis r23, -0x7df3
	ctx.r[23].s64 = -2113077248;
	// 822E7E1C: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822E7E20: 3F00820D  lis r24, -0x7df3
	ctx.r[24].s64 = -2113077248;
	// 822E7E24: 3F60820D  lis r27, -0x7df3
	ctx.r[27].s64 = -2113077248;
	// 822E7E28: C0192048  lfs f0, 0x2048(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7E2C: 3FA0820D  lis r29, -0x7df3
	ctx.r[29].s64 = -2113077248;
	// 822E7E30: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822E7E34: 3FC0820D  lis r30, -0x7df3
	ctx.r[30].s64 = -2113077248;
	// 822E7E38: C01620CC  lfs f0, 0x20cc(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7E3C: 3FE0820D  lis r31, -0x7df3
	ctx.r[31].s64 = -2113077248;
	// 822E7E40: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 822E7E44: 3C60820D  lis r3, -0x7df3
	ctx.r[3].s64 = -2113077248;
	// 822E7E48: C01520B0  lfs f0, 0x20b0(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7E4C: 3C80820D  lis r4, -0x7df3
	ctx.r[4].s64 = -2113077248;
	// 822E7E50: C2339F78  lfs f17, -0x6088(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 822E7E54: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 822E7E58: C33DBFFC  lfs f25, -0x4004(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 822E7E5C: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 822E7E60: CA9E21E0  lfd f20, 0x21e0(r30)
	ctx.f[20].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8672 as u32) ) };
	// 822E7E64: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822E7E68: CABF2C98  lfd f21, 0x2c98(r31)
	ctx.f[21].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(11416 as u32) ) };
	// 822E7E6C: 3A4B0C40  addi r18, r11, 0xc40
	ctx.r[18].s64 = ctx.r[11].s64 + 3136;
	// 822E7E70: CAC32020  lfd f22, 0x2020(r3)
	ctx.f[22].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8224 as u32) ) };
	// 822E7E74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E7E78: CAE42C90  lfd f23, 0x2c90(r4)
	ctx.f[23].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(11408 as u32) ) };
	// 822E7E7C: C30520C8  lfs f24, 0x20c8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8392 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 822E7E80: 39C00000  li r14, 0
	ctx.r[14].s64 = 0;
	// 822E7E84: C2462C28  lfs f18, 0x2c28(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(11304 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 822E7E88: 3A0BC188  addi r16, r11, -0x3e78
	ctx.r[16].s64 = ctx.r[11].s64 + -15992;
	// 822E7E8C: C3672280  lfs f27, 0x2280(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8832 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 822E7E90: C35B1FF8  lfs f26, 0x1ff8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8184 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 822E7E94: C2182490  lfs f16, 0x2490(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(9360 as u32) ) };
	ctx.f[16].f64 = (tmp.f32 as f64);
	// 822E7E98: C1F4CFEC  lfs f15, -0x3014(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[15].f64 = (tmp.f32 as f64);
	// 822E7E9C: C1D72170  lfs f14, 0x2170(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8560 as u32) ) };
	ctx.f[14].f64 = (tmp.f32 as f64);
	// 822E7EA0: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 822E7EA4: 4824B36D  bl 0x82533210
	ctx.lr = 0x822E7EA8;
	sub_82533210(ctx, base);
	// 822E7EA8: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 822E7EAC: C1A100C4  lfs f13, 0xc4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E7EB0: 83E100B4  lwz r31, 0xb4(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 822E7EB4: C1810294  lfs f12, 0x294(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(660 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E7EB8: 2F1F0010  cmpwi cr6, r31, 0x10
	ctx.cr[6].compare_i32(ctx.r[31].s32, 16, &mut ctx.xer);
	// 822E7EBC: F96100F8  std r11, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u64 ) };
	// 822E7EC0: C80100F8  lfd f0, 0xf8(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 822E7EC4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E7EC8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E7ECC: EC0004F2  fmuls f0, f0, f19
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[19].f64) as f32) as f64);
	// 822E7ED0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E7ED4: C1A100C0  lfs f13, 0xc0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E7ED8: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 822E7EDC: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E7EE0: EFCD0332  fmuls f30, f13, f12
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 822E7EE4: C1A102AC  lfs f13, 0x2ac(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E7EE8: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E7EEC: 409A0158  bne cr6, 0x822e8044
	if !ctx.cr[6].eq {
	pc = 0x822E8044; continue 'dispatch;
	}
	// 822E7EF0: 4BFFEF31  bl 0x822e6e20
	ctx.lr = 0x822E7EF4;
	sub_822E6E20(ctx, base);
	// 822E7EF4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822E7EF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E7EFC: 419A0420  beq cr6, 0x822e831c
	if ctx.cr[6].eq {
	pc = 0x822E831C; continue 'dispatch;
	}
	// 822E7F00: C00100BC  lfs f0, 0xbc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E7F04: 81410284  lwz r10, 0x284(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(644 as u32) ) } as u64;
	// 822E7F08: EDBE0032  fmuls f13, f30, f0
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E7F0C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 822E7F10: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 822E7F14: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 822E7F18: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822E7F1C: FC006850  fneg f0, f13
	ctx.f[0].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 822E7F20: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 822E7F24: 4807F215  bl 0x82367138
	ctx.lr = 0x822E7F28;
	sub_82367138(ctx, base);
	// 822E7F28: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E7F2C: ED8D0028  fsubs f12, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E7F30: F96100E8  std r11, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[11].u64 ) };
	// 822E7F34: C96100E8  lfd f11, 0xe8(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	// 822E7F38: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 822E7F3C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 822E7F40: ED6B06F2  fmuls f11, f11, f27
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[27].f64) as f32) as f64);
	// 822E7F44: ED8B033A  fmadds f12, f11, f12, f0
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 822E7F48: C1610080  lfs f11, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E7F4C: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 822E7F50: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 822E7F54: 4807F1E5  bl 0x82367138
	ctx.lr = 0x822E7F58;
	sub_82367138(ctx, base);
	// 822E7F58: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E7F5C: EDAD0028  fsubs f13, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E7F60: 80910014  lwz r4, 0x14(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(20 as u32) ) } as u64;
	// 822E7F64: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822E7F68: F96100C8  std r11, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u64 ) };
	// 822E7F6C: C98100C8  lfd f12, 0xc8(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 822E7F70: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 822E7F74: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 822E7F78: ED8C06F2  fmuls f12, f12, f27
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 822E7F7C: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 822E7F80: C1A10088  lfs f13, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E7F84: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 822E7F88: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 822E7F8C: 419A0390  beq cr6, 0x822e831c
	if ctx.cr[6].eq {
	pc = 0x822E831C; continue 'dispatch;
	}
	// 822E7F90: EC1F04B2  fmuls f0, f31, f18
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[18].f64) as f32) as f64);
	// 822E7F94: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 822E7F98: 7E078378  mr r7, r16
	ctx.r[7].u64 = ctx.r[16].u64;
	// 822E7F9C: 38A00385  li r5, 0x385
	ctx.r[5].s64 = 901;
	// 822E7FA0: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 822E7FA4: EDA00632  fmuls f13, f0, f24
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[24].f64) as f32) as f64);
	// 822E7FA8: EC000472  fmuls f0, f0, f17
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[17].f64) as f32) as f64);
	// 822E7FAC: FD8DB828  fsub f12, f13, f23
	ctx.f[12].f64 = ctx.f[13].f64 - ctx.f[23].f64;
	// 822E7FB0: FD60A828  fsub f11, f0, f21
	ctx.f[11].f64 = ctx.f[0].f64 - ctx.f[21].f64;
	// 822E7FB4: FDACBB6E  fsel f13, f12, f13, f23
	ctx.f[13].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[23].f64 };
	// 822E7FB8: FC0BA82E  fsel f0, f11, f0, f21
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[21].f64 };
	// 822E7FBC: FD8DB028  fsub f12, f13, f22
	ctx.f[12].f64 = ctx.f[13].f64 - ctx.f[22].f64;
	// 822E7FC0: FD60A028  fsub f11, f0, f20
	ctx.f[11].f64 = ctx.f[0].f64 - ctx.f[20].f64;
	// 822E7FC4: FDAC6DAE  fsel f13, f12, f22, f13
	ctx.f[13].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[22].f64 } else { ctx.f[13].f64 };
	// 822E7FC8: FC0B052E  fsel f0, f11, f20, f0
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[20].f64 } else { ctx.f[0].f64 };
	// 822E7FCC: FFE06818  frsp f31, f13
	ctx.f[31].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E7FD0: FFC00018  frsp f30, f0
	ctx.f[30].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E7FD4: 480824BD  bl 0x8236a490
	ctx.lr = 0x822E7FD8;
	sub_8236A490(ctx, base);
	// 822E7FD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E7FDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E7FE0: 419A033C  beq cr6, 0x822e831c
	if ctx.cr[6].eq {
	pc = 0x822E831C; continue 'dispatch;
	}
	// 822E7FE4: EC1E0672  fmuls f0, f30, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[25].f64) as f32) as f64);
	// 822E7FE8: 4807F151  bl 0x82367138
	ctx.lr = 0x822E7FEC;
	sub_82367138(ctx, base);
	// 822E7FEC: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E7FF0: ED9E0028  fsubs f12, f30, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E7FF4: EDBF0632  fmuls f13, f31, f24
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[24].f64) as f32) as f64);
	// 822E7FF8: F9610120  std r11, 0x120(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[11].u64 ) };
	// 822E7FFC: C9610120  lfd f11, 0x120(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(288 as u32) ) };
	// 822E8000: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 822E8004: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 822E8008: ED6B06F2  fmuls f11, f11, f27
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[27].f64) as f32) as f64);
	// 822E800C: EC4B033A  fmadds f2, f11, f12, f0
	ctx.f[2].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 822E8010: 4807F129  bl 0x82367138
	ctx.lr = 0x822E8014;
	sub_82367138(ctx, base);
	// 822E8014: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E8018: EC1F6828  fsubs f0, f31, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E801C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 822E8020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E8024: F96100E0  std r11, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 822E8028: C98100E0  lfd f12, 0xe0(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 822E802C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 822E8030: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 822E8034: ED8C06F2  fmuls f12, f12, f27
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 822E8038: EC2C683A  fmadds f1, f12, f0, f13
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 822E803C: 480031ED  bl 0x822eb228
	ctx.lr = 0x822E8040;
	sub_822EB228(ctx, base);
	// 822E8040: 480002DC  b 0x822e831c
	pc = 0x822E831C; continue 'dispatch;
            }
            0x822E8044 => {
    //   block [0x822E8044..0x822E8130)
	// 822E8044: C00100A0  lfs f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E8048: 81410284  lwz r10, 0x284(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(644 as u32) ) } as u64;
	// 822E804C: EDBE0032  fmuls f13, f30, f0
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E8050: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 822E8054: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 822E8058: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 822E805C: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822E8060: FC006850  fneg f0, f13
	ctx.f[0].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 822E8064: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 822E8068: 4807F0D1  bl 0x82367138
	ctx.lr = 0x822E806C;
	sub_82367138(ctx, base);
	// 822E806C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E8070: ED8D0028  fsubs f12, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E8074: F9610100  std r11, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[11].u64 ) };
	// 822E8078: C9610100  lfd f11, 0x100(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 822E807C: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 822E8080: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 822E8084: ED6B06F2  fmuls f11, f11, f27
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[27].f64) as f32) as f64);
	// 822E8088: ED8B033A  fmadds f12, f11, f12, f0
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 822E808C: C1610080  lfs f11, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E8090: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 822E8094: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 822E8098: 4807F0A1  bl 0x82367138
	ctx.lr = 0x822E809C;
	sub_82367138(ctx, base);
	// 822E809C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E80A0: EDAD0028  fsubs f13, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E80A4: D3410060  stfs f26, 0x60(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E80A8: D3410064  stfs f26, 0x64(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822E80AC: D3410068  stfs f26, 0x68(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822E80B0: D381006C  stfs f28, 0x6c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822E80B4: F96100F0  std r11, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u64 ) };
	// 822E80B8: C98100F0  lfd f12, 0xf0(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) };
	// 822E80BC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 822E80C0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 822E80C4: ED8C06F2  fmuls f12, f12, f27
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 822E80C8: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 822E80CC: C1A10088  lfs f13, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E80D0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 822E80D4: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 822E80D8: 4824B139  bl 0x82533210
	ctx.lr = 0x822E80DC;
	sub_82533210(ctx, base);
	// 822E80DC: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 822E80E0: C1A100B8  lfs f13, 0xb8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E80E4: C1810070  lfs f12, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E80E8: F96100D0  std r11, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	// 822E80EC: C80100D0  lfd f0, 0xd0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 822E80F0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E80F4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E80F8: EC00CCF8  fmsubs f0, f0, f19, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[19].f64 - ctx.f[25].f64) as f32) as f64);
	// 822E80FC: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 822E8100: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 822E8104: FF0DC800  fcmpu cr6, f13, f25
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[25].f64);
	// 822E8108: 41980068  blt cr6, 0x822e8170
	if ctx.cr[6].lt {
	pc = 0x822E8170; continue 'dispatch;
	}
	// 822E810C: C1A100B0  lfs f13, 0xb0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E8110: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E8114: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 822E8118: 4098003C  bge cr6, 0x822e8154
	if !ctx.cr[6].lt {
	pc = 0x822E8154; continue 'dispatch;
	}
	// 822E811C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 822E8120: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 822E8124: 4098000C  bge cr6, 0x822e8130
	if !ctx.cr[6].lt {
	pc = 0x822E8130; continue 'dispatch;
	}
	// 822E8128: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E812C: 48000040  b 0x822e816c
	pc = 0x822E816C; continue 'dispatch;
            }
            0x822E8130 => {
    //   block [0x822E8130..0x822E8154)
	// 822E8130: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 822E8134: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E8138: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E813C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E8140: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 822E8144: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 822E8148: 41980024  blt cr6, 0x822e816c
	if ctx.cr[6].lt {
	pc = 0x822E816C; continue 'dispatch;
	}
	// 822E814C: FC00D090  fmr f0, f26
	ctx.f[0].f64 = ctx.f[26].f64;
	// 822E8150: 4800001C  b 0x822e816c
	pc = 0x822E816C; continue 'dispatch;
            }
            0x822E8154 => {
    //   block [0x822E8154..0x822E816C)
	// 822E8154: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 822E8158: 41980014  blt cr6, 0x822e816c
	if ctx.cr[6].lt {
	pc = 0x822E816C; continue 'dispatch;
	}
	// 822E815C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 822E8160: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822E8164: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822E8168: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x822E816C; continue 'dispatch;
            }
            0x822E816C => {
    //   block [0x822E816C..0x822E8170)
	// 822E816C: EC00C828  fsubs f0, f0, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[25].f64) as f32) as f64);
	pc = 0x822E8170; continue 'dispatch;
            }
            0x822E8170 => {
    //   block [0x822E8170..0x822E831C)
	// 822E8170: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 822E8174: EC200432  fmuls f1, f0, f16
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[16].f64) as f32) as f64);
	// 822E8178: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822E817C: 4BE29C55  bl 0x82111dd0
	ctx.lr = 0x822E8180;
	sub_82111DD0(ctx, base);
	// 822E8180: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 822E8184: 1181038C  vspltisw v12, 1
	for i in 0..4 {
		ctx.v[12].u32[i] = 1;
	}
	// 822E8188: E92F0000  ld r9, 0(r15)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) };
	// 822E818C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E8190: EBEF0008  ld r31, 8(r15)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[15].u32.wrapping_add(8 as u32) ) };
	// 822E8194: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822E8198: EC3F03B2  fmuls f1, f31, f14
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[14].f64) as f32) as f64);
	// 822E819C: C1AF000C  lfs f13, 0xc(r15)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E81A0: 38E10130  addi r7, r1, 0x130
	ctx.r[7].s64 = ctx.r[1].s64 + 304;
	pc = 0x822E831C; continue 'dispatch;
            }
            0x822E831C => {
    //   block [0x822E831C..0x822E8330)
	// 822E831C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822E8320: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822E8324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E8328: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 822E832C: 409AFB78  bne cr6, 0x822e7ea4
	if !ctx.cr[6].eq {
	pc = 0x822E7EA4; continue 'dispatch;
	}
	pc = 0x822E8330; continue 'dispatch;
            }
            0x822E8330 => {
    //   block [0x822E8330..0x822E8340)
	// 822E8330: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 822E8334: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 822E8338: 4824DCC5  bl 0x82535ffc
	ctx.lr = 0x822E833C;
	sub_82535FFC(ctx, base);
	// 822E833C: 4824CD94  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E8340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E8340 size=1052
    let mut pc: u32 = 0x822E8340;
    'dispatch: loop {
        match pc {
            0x822E8340 => {
    //   block [0x822E8340..0x822E85D0)
	// 822E8340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E8344: 4824CD51  bl 0x82535094
	ctx.lr = 0x822E8348;
	sub_82535080(ctx, base);
	// 822E8348: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 822E834C: 4824DC65  bl 0x82535fb0
	ctx.lr = 0x822E8350;
	sub_82535FB0(ctx, base);
	// 822E8350: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E8354: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 822E8358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E835C: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 822E8360: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 822E8364: 2F15003C  cmpwi cr6, r21, 0x3c
	ctx.cr[6].compare_i32(ctx.r[21].s32, 60, &mut ctx.xer);
	// 822E8368: 419A03E4  beq cr6, 0x822e874c
	if ctx.cr[6].eq {
	pc = 0x822E874C; continue 'dispatch;
	}
	// 822E836C: 2F150004  cmpwi cr6, r21, 4
	ctx.cr[6].compare_i32(ctx.r[21].s32, 4, &mut ctx.xer);
	// 822E8370: 419A03DC  beq cr6, 0x822e874c
	if ctx.cr[6].eq {
	pc = 0x822E874C; continue 'dispatch;
	}
	// 822E8374: 2F150010  cmpwi cr6, r21, 0x10
	ctx.cr[6].compare_i32(ctx.r[21].s32, 16, &mut ctx.xer);
	// 822E8378: 419A03D4  beq cr6, 0x822e874c
	if ctx.cr[6].eq {
	pc = 0x822E874C; continue 'dispatch;
	}
	// 822E837C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E8380: 616B9C00  ori r11, r11, 0x9c00
	ctx.r[11].u64 = ctx.r[11].u64 | 39936;
	// 822E8384: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E8388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E838C: 419A03C0  beq cr6, 0x822e874c
	if ctx.cr[6].eq {
	pc = 0x822E874C; continue 'dispatch;
	}
	// 822E8390: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822E8394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E8398: 419A03B4  beq cr6, 0x822e874c
	if ctx.cr[6].eq {
	pc = 0x822E874C; continue 'dispatch;
	}
	// 822E839C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E83A0: 616BEB2B  ori r11, r11, 0xeb2b
	ctx.r[11].u64 = ctx.r[11].u64 | 60203;
	// 822E83A4: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822E83A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E83AC: 409A03A0  bne cr6, 0x822e874c
	if !ctx.cr[6].eq {
	pc = 0x822E874C; continue 'dispatch;
	}
	// 822E83B0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822E83B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E83B8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822E83BC: 4BFFDAED  bl 0x822e5ea8
	ctx.lr = 0x822E83C0;
	sub_822E5EA8(ctx, base);
	// 822E83C0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822E83C4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822E83C8: 6169BED4  ori r9, r11, 0xbed4
	ctx.r[9].u64 = ctx.r[11].u64 | 48852;
	// 822E83CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E83D0: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 822E83D4: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 822E83D8: C3EABA38  lfs f31, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E83DC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E83E0: 7D3F482E  lwzx r9, r31, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E83E4: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 822E83E8: C18B2630  lfs f12, 0x2630(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9776 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E83EC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 822E83F0: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 822E83F4: FF80F890  fmr f28, f31
	ctx.f[28].f64 = ctx.f[31].f64;
	// 822E83F8: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 822E83FC: C30A2160  lfs f24, 0x2160(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8544 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 822E8400: A1490004  lhz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E8404: D301008C  stfs f24, 0x8c(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 822E8408: E9230008  ld r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 822E840C: F9410078  std r10, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u64 ) };
	// 822E8410: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822E8414: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 822E8418: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 822E841C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E8420: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E8424: ED2D0372  fmuls f9, f13, f13
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E8428: C1610064  lfs f11, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822E842C: C1410060  lfs f10, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822E8430: C9AB20B8  lfd f13, 0x20b8(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8376 as u32) ) };
	// 822E8434: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E8438: C36B2470  lfs f27, 0x2470(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9328 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 822E843C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E8440: ED6B4AFA  fmadds f11, f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 822E8444: C8010078  lfd f0, 0x78(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 822E8448: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E844C: FD006828  fsub f8, f0, f13
	ctx.f[8].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 822E8450: FC08036E  fsel f0, f8, f13, f0
	ctx.f[0].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 822E8454: EDAA5ABA  fmadds f13, f10, f10, f11
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64);
	// 822E8458: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E845C: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 822E8460: EC00DB3A  fmadds f0, f0, f12, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[27].f64) as f32) as f64);
	// 822E8464: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E8468: C1AB2C88  lfs f13, 0x2c88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11400 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E846C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E8470: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822E8474: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 822E8478: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822E847C: C00B2C84  lfs f0, 0x2c84(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E8480: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E8484: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822E8488: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 822E848C: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 822E8490: 216B0001  subfic r11, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[11].s64 = (1 as i64) - ctx.r[11].s64;
	// 822E8494: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E8498: 7EEB5214  add r23, r11, r10
	ctx.r[23].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822E849C: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 822E84A0: 409902AC  ble cr6, 0x822e874c
	if !ctx.cr[6].gt {
	pc = 0x822E874C; continue 'dispatch;
	}
	// 822E84A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822E84A8: 3F80820B  lis r28, -0x7df5
	ctx.r[28].s64 = -2113208320;
	// 822E84AC: 396BD28C  addi r11, r11, -0x2d74
	ctx.r[11].s64 = ctx.r[11].s64 + -11636;
	// 822E84B0: 3FA0820D  lis r29, -0x7df3
	ctx.r[29].s64 = -2113077248;
	// 822E84B4: 3FC0820D  lis r30, -0x7df3
	ctx.r[30].s64 = -2113077248;
	// 822E84B8: 3FE0820D  lis r31, -0x7df3
	ctx.r[31].s64 = -2113077248;
	// 822E84BC: 3C60820D  lis r3, -0x7df3
	ctx.r[3].s64 = -2113077248;
	// 822E84C0: C2BC9F78  lfs f21, -0x6088(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 822E84C4: 3C80820D  lis r4, -0x7df3
	ctx.r[4].s64 = -2113077248;
	// 822E84C8: C22B0444  lfs f17, 0x444(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1092 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 822E84CC: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 822E84D0: C2EB0000  lfs f23, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 822E84D4: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 822E84D8: C25E20C8  lfs f18, 0x20c8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8392 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 822E84DC: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822E84E0: C27F21B8  lfs f19, 0x21b8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8632 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 822E84E4: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 822E84E8: C2832140  lfs f20, 0x2140(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8512 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 822E84EC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E84F0: C1C42144  lfs f14, 0x2144(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8516 as u32) ) };
	ctx.f[14].f64 = (tmp.f32 as f64);
	// 822E84F4: 3D4082B5  lis r10, -0x7d4b
	ctx.r[10].s64 = -2102067200;
	// 822E84F8: C1E5BFFC  lfs f15, -0x4004(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[15].f64 = (tmp.f32 as f64);
	// 822E84FC: C206206C  lfs f16, 0x206c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8300 as u32) ) };
	ctx.f[16].f64 = (tmp.f32 as f64);
	// 822E8500: 3B340020  addi r25, r20, 0x20
	ctx.r[25].s64 = ctx.r[20].s64 + 32;
	// 822E8504: C3271FF8  lfs f25, 0x1ff8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8184 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 822E8508: 3B140010  addi r24, r20, 0x10
	ctx.r[24].s64 = ctx.r[20].s64 + 16;
	// 822E850C: C3482370  lfs f26, 0x2370(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(9072 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 822E8510: 3B4A0C40  addi r26, r10, 0xc40
	ctx.r[26].s64 = ctx.r[10].s64 + 3136;
	// 822E8514: C3A92280  lfs f29, 0x2280(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8832 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822E8518: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 822E851C: C2DD203C  lfs f22, 0x203c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8252 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 822E8520: 4807EC19  bl 0x82367138
	ctx.lr = 0x822E8524;
	sub_82367138(ctx, base);
	// 822E8524: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E8528: EC1E0672  fmuls f0, f30, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[25].f64) as f32) as f64);
	// 822E852C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E8530: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822E8534: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 822E8538: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822E853C: F96100A8  std r11, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 822E8540: C80100A8  lfd f0, 0xa8(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 822E8544: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E8548: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E854C: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 822E8550: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 822E8554: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 822E8558: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822E855C: 419A0074  beq cr6, 0x822e85d0
	if ctx.cr[6].eq {
	pc = 0x822E85D0; continue 'dispatch;
	}
	// 822E8560: 4824ACB1  bl 0x82533210
	ctx.lr = 0x822E8564;
	sub_82533210(ctx, base);
	// 822E8564: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 822E8568: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 822E856C: F96100B8  std r11, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u64 ) };
	// 822E8570: C80100B8  lfd f0, 0xb8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 822E8574: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E8578: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E857C: EC007C38  fmsubs f0, f0, f16, f15
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[16].f64 - ctx.f[15].f64) as f32) as f64);
	// 822E8580: EC2003B2  fmuls f1, f0, f14
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[14].f64) as f32) as f64);
	// 822E8584: 4807FA35  bl 0x82367fb8
	ctx.lr = 0x822E8588;
	sub_82367FB8(ctx, base);
	// 822E8588: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 822E858C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x822E85D0; continue 'dispatch;
            }
            0x822E85D0 => {
    //   block [0x822E85D0..0x822E874C)
	// 822E85D0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	pc = 0x822E874C; continue 'dispatch;
            }
            0x822E874C => {
    //   block [0x822E874C..0x822E875C)
	// 822E874C: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 822E8750: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 822E8754: 4824D8A9  bl 0x82535ffc
	ctx.lr = 0x822E8758;
	sub_82535FFC(ctx, base);
	// 822E8758: 4824C98C  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E8760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E8760 size=56
    let mut pc: u32 = 0x822E8760;
    'dispatch: loop {
        match pc {
            0x822E8760 => {
    //   block [0x822E8760..0x822E8798)
	// 822E8760: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E8764: C00300B4  lfs f0, 0xb4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E8768: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E876C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822E8770: 40990028  ble cr6, 0x822e8798
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x822E8798);
		return;
	}
	// 822E8774: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E8778: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 822E877C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 822E8780: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 822E8784: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E8788: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822E878C: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822E8790: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E8794: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E87C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E87C0 size=156
    let mut pc: u32 = 0x822E87C0;
    'dispatch: loop {
        match pc {
            0x822E87C0 => {
    //   block [0x822E87C0..0x822E8808)
	// 822E87C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E87C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E87C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E87CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E87D0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E87D4: C0440008  lfs f2, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822E87D8: C0240000  lfs f1, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E87DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E87E0: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 822E87E4: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E87E8: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 822E87EC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822E87F0: 40990018  ble cr6, 0x822e8808
	if !ctx.cr[6].gt {
	pc = 0x822E8808; continue 'dispatch;
	}
	// 822E87F4: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E87F8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 822E87FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E8800: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E8804: 41990008  bgt cr6, 0x822e880c
	if ctx.cr[6].gt {
	pc = 0x822E880C; continue 'dispatch;
	}
	pc = 0x822E8808; continue 'dispatch;
            }
            0x822E8808 => {
    //   block [0x822E8808..0x822E880C)
	// 822E8808: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822E880C; continue 'dispatch;
            }
            0x822E880C => {
    //   block [0x822E880C..0x822E8824)
	// 822E880C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E8810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E8814: 409A0010  bne cr6, 0x822e8824
	if !ctx.cr[6].eq {
	pc = 0x822E8824; continue 'dispatch;
	}
	// 822E8818: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E881C: 4BECECAD  bl 0x821b74c8
	ctx.lr = 0x822E8820;
	sub_821B74C8(ctx, base);
	// 822E8820: 48000018  b 0x822e8838
	pc = 0x822E8838; continue 'dispatch;
            }
            0x822E8824 => {
    //   block [0x822E8824..0x822E8838)
	// 822E8824: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E8828: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E882C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822E8830: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822E8834: 4BECECFD  bl 0x821b7530
	ctx.lr = 0x822E8838;
	sub_821B7530(ctx, base);
	pc = 0x822E8838; continue 'dispatch;
            }
            0x822E8838 => {
    //   block [0x822E8838..0x822E885C)
	// 822E8838: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E883C: C1BF00A8  lfs f13, 0xa8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E8840: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E8844: EC2D083A  fmadds f1, f13, f0, f1
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64);
	// 822E8848: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E884C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E8850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E8854: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E8858: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E8860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E8860 size=152
    let mut pc: u32 = 0x822E8860;
    'dispatch: loop {
        match pc {
            0x822E8860 => {
    //   block [0x822E8860..0x822E88A0)
	// 822E8860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E8864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E8868: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E886C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E8870: C0440008  lfs f2, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822E8874: C0240000  lfs f1, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E8878: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 822E887C: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E8880: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 822E8884: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822E8888: 40990018  ble cr6, 0x822e88a0
	if !ctx.cr[6].gt {
	pc = 0x822E88A0; continue 'dispatch;
	}
	// 822E888C: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E8890: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 822E8894: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E8898: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E889C: 41990008  bgt cr6, 0x822e88a4
	if ctx.cr[6].gt {
	pc = 0x822E88A4; continue 'dispatch;
	}
	pc = 0x822E88A0; continue 'dispatch;
            }
            0x822E88A0 => {
    //   block [0x822E88A0..0x822E88A4)
	// 822E88A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822E88A4; continue 'dispatch;
            }
            0x822E88A4 => {
    //   block [0x822E88A4..0x822E88BC)
	// 822E88A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E88A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E88AC: 409A0010  bne cr6, 0x822e88bc
	if !ctx.cr[6].eq {
	pc = 0x822E88BC; continue 'dispatch;
	}
	// 822E88B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E88B4: 4BECEC15  bl 0x821b74c8
	ctx.lr = 0x822E88B8;
	sub_821B74C8(ctx, base);
	// 822E88B8: 48000018  b 0x822e88d0
	pc = 0x822E88D0; continue 'dispatch;
            }
            0x822E88BC => {
    //   block [0x822E88BC..0x822E88D0)
	// 822E88BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E88C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E88C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822E88C8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822E88CC: 4BECEC65  bl 0x821b7530
	ctx.lr = 0x822E88D0;
	sub_821B7530(ctx, base);
	pc = 0x822E88D0; continue 'dispatch;
            }
            0x822E88D0 => {
    //   block [0x822E88D0..0x822E88E8)
	// 822E88D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E88D4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E88D8: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E88DC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 822E88E0: 40980008  bge cr6, 0x822e88e8
	if !ctx.cr[6].lt {
	pc = 0x822E88E8; continue 'dispatch;
	}
	// 822E88E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822E88E8; continue 'dispatch;
            }
            0x822E88E8 => {
    //   block [0x822E88E8..0x822E88F8)
	// 822E88E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E88EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E88F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E88F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E88F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E88F8 size=252
    let mut pc: u32 = 0x822E88F8;
    'dispatch: loop {
        match pc {
            0x822E88F8 => {
    //   block [0x822E88F8..0x822E8954)
	// 822E88F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E88FC: 4824C7BD  bl 0x825350b8
	ctx.lr = 0x822E8900;
	sub_82535080(ctx, base);
	// 822E8900: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E8904: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E8908: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822E890C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822E8910: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822E8914: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E8918: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822E891C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E8920: 4E800421  bctrl
	ctx.lr = 0x822E8924;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E8924: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822E8928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E892C: A0BE0088  lhz r5, 0x88(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 822E8930: 809E0084  lwz r4, 0x84(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 822E8934: 4BFFD3ED  bl 0x822e5d20
	ctx.lr = 0x822E8938;
	sub_822E5D20(ctx, base);
	// 822E8938: 817E0080  lwz r11, 0x80(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E893C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822E8940: 409A0014  bne cr6, 0x822e8954
	if !ctx.cr[6].eq {
	pc = 0x822E8954; continue 'dispatch;
	}
	// 822E8944: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E8948: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E894C: 4BFFFE75  bl 0x822e87c0
	ctx.lr = 0x822E8950;
	sub_822E87C0(ctx, base);
	// 822E8950: D03F0004  stfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
            }
            0x822E8954 => {
    //   block [0x822E8954..0x822E89F4)
	// 822E8954: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822E8958: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822E895C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E8960: 48000099  bl 0x822e89f8
	ctx.lr = 0x822E8964;
	sub_822E89F8(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E89F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E89F8 size=312
    let mut pc: u32 = 0x822E89F8;
    'dispatch: loop {
        match pc {
            0x822E89F8 => {
    //   block [0x822E89F8..0x822E8A48)
	// 822E89F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E89FC: 4824C6BD  bl 0x825350b8
	ctx.lr = 0x822E8A00;
	sub_82535080(ctx, base);
	// 822E8A00: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822E8A04: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E8A08: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E8A0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822E8A10: 3BEBDBD0  addi r31, r11, -0x2430
	ctx.r[31].s64 = ctx.r[11].s64 + -9264;
	// 822E8A14: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822E8A18: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822E8A1C: C05E0008  lfs f2, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822E8A20: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E8A24: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E8A28: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 822E8A2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E8A30: 40990018  ble cr6, 0x822e8a48
	if !ctx.cr[6].gt {
	pc = 0x822E8A48; continue 'dispatch;
	}
	// 822E8A34: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E8A38: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 822E8A3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E8A40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E8A44: 41990008  bgt cr6, 0x822e8a4c
	if ctx.cr[6].gt {
	pc = 0x822E8A4C; continue 'dispatch;
	}
	pc = 0x822E8A48; continue 'dispatch;
            }
            0x822E8A48 => {
    //   block [0x822E8A48..0x822E8A4C)
	// 822E8A48: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822E8A4C; continue 'dispatch;
            }
            0x822E8A4C => {
    //   block [0x822E8A4C..0x822E8A64)
	// 822E8A4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E8A50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E8A54: 409A0010  bne cr6, 0x822e8a64
	if !ctx.cr[6].eq {
	pc = 0x822E8A64; continue 'dispatch;
	}
	// 822E8A58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E8A5C: 4BECEA6D  bl 0x821b74c8
	ctx.lr = 0x822E8A60;
	sub_821B74C8(ctx, base);
	// 822E8A60: 48000014  b 0x822e8a74
	pc = 0x822E8A74; continue 'dispatch;
            }
            0x822E8A64 => {
    //   block [0x822E8A64..0x822E8A74)
	// 822E8A64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E8A68: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 822E8A6C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822E8A70: 4BECEAC1  bl 0x821b7530
	ctx.lr = 0x822E8A74;
	sub_821B7530(ctx, base);
	pc = 0x822E8A74; continue 'dispatch;
            }
            0x822E8A74 => {
    //   block [0x822E8A74..0x822E8AA4)
	// 822E8A74: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 822E8A78: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822E8A7C: C05D0008  lfs f2, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822E8A80: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 822E8A84: C03D0000  lfs f1, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E8A88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E8A8C: 40990018  ble cr6, 0x822e8aa4
	if !ctx.cr[6].gt {
	pc = 0x822E8AA4; continue 'dispatch;
	}
	// 822E8A90: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E8A94: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 822E8A98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E8A9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E8AA0: 41990008  bgt cr6, 0x822e8aa8
	if ctx.cr[6].gt {
	pc = 0x822E8AA8; continue 'dispatch;
	}
	pc = 0x822E8AA4; continue 'dispatch;
            }
            0x822E8AA4 => {
    //   block [0x822E8AA4..0x822E8AA8)
	// 822E8AA4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822E8AA8; continue 'dispatch;
            }
            0x822E8AA8 => {
    //   block [0x822E8AA8..0x822E8AC0)
	// 822E8AA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E8AAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E8AB0: 409A0010  bne cr6, 0x822e8ac0
	if !ctx.cr[6].eq {
	pc = 0x822E8AC0; continue 'dispatch;
	}
	// 822E8AB4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E8AB8: 4BECEA11  bl 0x821b74c8
	ctx.lr = 0x822E8ABC;
	sub_821B74C8(ctx, base);
	// 822E8ABC: 48000014  b 0x822e8ad0
	pc = 0x822E8AD0; continue 'dispatch;
            }
            0x822E8AC0 => {
    //   block [0x822E8AC0..0x822E8AD0)
	// 822E8AC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E8AC4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 822E8AC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822E8ACC: 4BECEA65  bl 0x821b7530
	ctx.lr = 0x822E8AD0;
	sub_821B7530(ctx, base);
	pc = 0x822E8AD0; continue 'dispatch;
            }
            0x822E8AD0 => {
    //   block [0x822E8AD0..0x822E8AF8)
	// 822E8AD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E8AD4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E8AD8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 822E8ADC: 40980034  bge cr6, 0x822e8b10
	if !ctx.cr[6].lt {
	pc = 0x822E8B10; continue 'dispatch;
	}
	// 822E8AE0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 822E8AE4: 40980014  bge cr6, 0x822e8af8
	if !ctx.cr[6].lt {
	pc = 0x822E8AF8; continue 'dispatch;
	}
	// 822E8AE8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E8AEC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822E8AF0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822E8AF4: 4824C614  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x822E8AF8 => {
    //   block [0x822E8AF8..0x822E8B10)
	// 822E8AF8: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E8AFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E8B00: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822E8B04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822E8B08: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822E8B0C: 4824C5FC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x822E8B10 => {
    //   block [0x822E8B10..0x822E8B20)
	// 822E8B10: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 822E8B14: 4098000C  bge cr6, 0x822e8b20
	if !ctx.cr[6].lt {
	pc = 0x822E8B20; continue 'dispatch;
	}
	// 822E8B18: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E8B1C: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x822E8B20; continue 'dispatch;
            }
            0x822E8B20 => {
    //   block [0x822E8B20..0x822E8B30)
	// 822E8B20: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E8B24: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822E8B28: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822E8B2C: 4824C5DC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E8B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E8B30 size=100
    let mut pc: u32 = 0x822E8B30;
    'dispatch: loop {
        match pc {
            0x822E8B30 => {
    //   block [0x822E8B30..0x822E8B7C)
	// 822E8B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E8B34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E8B38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E8B3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E8B40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E8B44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E8B48: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822E8B4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E8B50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E8B54: A0BF0088  lhz r5, 0x88(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 822E8B58: 809F0084  lwz r4, 0x84(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822E8B5C: 4BFFD1C5  bl 0x822e5d20
	ctx.lr = 0x822E8B60;
	sub_822E5D20(ctx, base);
	// 822E8B60: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E8B64: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822E8B68: 409A0014  bne cr6, 0x822e8b7c
	if !ctx.cr[6].eq {
	pc = 0x822E8B7C; continue 'dispatch;
	}
	// 822E8B6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E8B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E8B74: 4BFFFC4D  bl 0x822e87c0
	ctx.lr = 0x822E8B78;
	sub_822E87C0(ctx, base);
	// 822E8B78: D03E0004  stfs f1, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x822E8B7C; continue 'dispatch;
            }
            0x822E8B7C => {
    //   block [0x822E8B7C..0x822E8B94)
	// 822E8B7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E8B80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E8B84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E8B88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E8B8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E8B90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E8B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E8B98 size=896
    let mut pc: u32 = 0x822E8B98;
    'dispatch: loop {
        match pc {
            0x822E8B98 => {
    //   block [0x822E8B98..0x822E8F18)
	// 822E8B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E8B9C: 4824C521  bl 0x825350bc
	ctx.lr = 0x822E8BA0;
	sub_82535080(ctx, base);
	// 822E8BA0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 822E8BA4: 4824D431  bl 0x82535fd4
	ctx.lr = 0x822E8BA8;
	sub_82535FB0(ctx, base);
	// 822E8BA8: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E8F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E8F18 size=548
    let mut pc: u32 = 0x822E8F18;
    'dispatch: loop {
        match pc {
            0x822E8F18 => {
    //   block [0x822E8F18..0x822E8F54)
	// 822E8F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E8F1C: 4824C18D  bl 0x825350a8
	ctx.lr = 0x822E8F20;
	sub_82535080(ctx, base);
	// 822E8F20: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 822E8F24: 4824D0C1  bl 0x82535fe4
	ctx.lr = 0x822E8F28;
	sub_82535FB0(ctx, base);
	// 822E8F28: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E8F2C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822E8F30: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 822E8F34: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 822E8F38: A17F0002  lhz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E8F3C: 556A057E  clrlwi r10, r11, 0x15
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 822E8F40: 7D7D0734  extsh r29, r11
	ctx.r[29].s64 = ctx.r[11].s16 as i64;
	// 822E8F44: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 822E8F48: 2B0A0070  cmplwi cr6, r10, 0x70
	ctx.cr[6].compare_u32(ctx.r[10].u32, 112 as u32, &mut ctx.xer);
	// 822E8F4C: 40990008  ble cr6, 0x822e8f54
	if !ctx.cr[6].gt {
	pc = 0x822E8F54; continue 'dispatch;
	}
	// 822E8F50: 3BA00015  li r29, 0x15
	ctx.r[29].s64 = 21;
	pc = 0x822E8F54; continue 'dispatch;
            }
            0x822E8F54 => {
    //   block [0x822E8F54..0x822E8F6C)
	// 822E8F54: 3BC5FFFF  addi r30, r5, -1
	ctx.r[30].s64 = ctx.r[5].s64 + -1;
	// 822E8F58: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 822E8F5C: 40980010  bge cr6, 0x822e8f6c
	if !ctx.cr[6].lt {
	pc = 0x822E8F6C; continue 'dispatch;
	}
	// 822E8F60: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 822E8F64: C36BD4DC  lfs f27, -0x2b24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 822E8F68: 48000010  b 0x822e8f78
	pc = 0x822E8F78; continue 'dispatch;
            }
            0x822E8F6C => {
    //   block [0x822E8F6C..0x822E8F78)
	// 822E8F6C: A07F0004  lhz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E8F70: 4BE2D601  bl 0x82116570
	ctx.lr = 0x822E8F74;
	sub_82116570(ctx, base);
	// 822E8F74: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	pc = 0x822E8F78; continue 'dispatch;
            }
            0x822E8F78 => {
    //   block [0x822E8F78..0x822E8F8C)
	// 822E8F78: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 822E8F7C: 40980010  bge cr6, 0x822e8f8c
	if !ctx.cr[6].lt {
	pc = 0x822E8F8C; continue 'dispatch;
	}
	// 822E8F80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E8F84: C38B2054  lfs f28, 0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8276 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 822E8F88: 48000010  b 0x822e8f98
	pc = 0x822E8F98; continue 'dispatch;
            }
            0x822E8F8C => {
    //   block [0x822E8F8C..0x822E8F98)
	// 822E8F8C: A07F0006  lhz r3, 6(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 822E8F90: 4BE2D5E1  bl 0x82116570
	ctx.lr = 0x822E8F94;
	sub_82116570(ctx, base);
	// 822E8F94: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	pc = 0x822E8F98; continue 'dispatch;
            }
            0x822E8F98 => {
    //   block [0x822E8F98..0x822E8FB0)
	// 822E8F98: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E8F9C: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 822E8FA0: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E8FA4: 4098000C  bge cr6, 0x822e8fb0
	if !ctx.cr[6].lt {
	pc = 0x822E8FB0; continue 'dispatch;
	}
	// 822E8FA8: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 822E8FAC: 48000010  b 0x822e8fbc
	pc = 0x822E8FBC; continue 'dispatch;
            }
            0x822E8FB0 => {
    //   block [0x822E8FB0..0x822E8FBC)
	// 822E8FB0: A07F0008  lhz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E8FB4: 4BE2D5BD  bl 0x82116570
	ctx.lr = 0x822E8FB8;
	sub_82116570(ctx, base);
	// 822E8FB8: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	pc = 0x822E8FBC; continue 'dispatch;
            }
            0x822E8FBC => {
    //   block [0x822E8FBC..0x822E8FCC)
	// 822E8FBC: 2F1E0005  cmpwi cr6, r30, 5
	ctx.cr[6].compare_i32(ctx.r[30].s32, 5, &mut ctx.xer);
	// 822E8FC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E8FC4: 41980008  blt cr6, 0x822e8fcc
	if ctx.cr[6].lt {
	pc = 0x822E8FCC; continue 'dispatch;
	}
	// 822E8FC8: A15F000A  lhz r10, 0xa(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	pc = 0x822E8FCC; continue 'dispatch;
            }
            0x822E8FCC => {
    //   block [0x822E8FCC..0x822E9000)
	// 822E8FCC: 7D440734  extsh r4, r10
	ctx.r[4].s64 = ctx.r[10].s16 as i64;
	// 822E8FD0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E8FD4: 7FAB0734  extsh r11, r29
	ctx.r[11].s64 = ctx.r[29].s16 as i64;
	// 822E8FD8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 822E8FDC: 556A0428  rlwinm r10, r11, 0, 0x10, 0x14
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822E8FE0: 556B057E  clrlwi r11, r11, 0x15
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 822E8FE4: 2F0B0058  cmpwi cr6, r11, 0x58
	ctx.cr[6].compare_i32(ctx.r[11].s32, 88, &mut ctx.xer);
	// 822E8FE8: B1410054  sth r10, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u16 ) };
	// 822E8FEC: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 822E8FF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E8FF4: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 822E8FF8: 40980008  bge cr6, 0x822e9000
	if !ctx.cr[6].lt {
	pc = 0x822E9000; continue 'dispatch;
	}
	// 822E8FFC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x822E9000; continue 'dispatch;
            }
            0x822E9000 => {
    //   block [0x822E9000..0x822E903C)
	// 822E9000: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 822E9004: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E9008: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 822E900C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E9010: 4198002C  blt cr6, 0x822e903c
	if ctx.cr[6].lt {
	pc = 0x822E903C; continue 'dispatch;
	}
	// 822E9014: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 822E9018: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 822E901C: 396BFFA8  addi r11, r11, -0x58
	ctx.r[11].s64 = ctx.r[11].s64 + -88;
	// 822E9020: 394A47D0  addi r10, r10, 0x47d0
	ctx.r[10].s64 = ctx.r[10].s64 + 18384;
	// 822E9024: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E9028: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822E902C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E9030: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E9034: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E9038: 48000008  b 0x822e9040
	pc = 0x822E9040; continue 'dispatch;
            }
            0x822E903C => {
    //   block [0x822E903C..0x822E9040)
	// 822E903C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x822E9040; continue 'dispatch;
            }
            0x822E9040 => {
    //   block [0x822E9040..0x822E9068)
	// 822E9040: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E9044: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E9048: 419A00E4  beq cr6, 0x822e912c
	if ctx.cr[6].eq {
	pc = 0x822E912C; continue 'dispatch;
	}
	// 822E904C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 822E9050: 419A0018  beq cr6, 0x822e9068
	if ctx.cr[6].eq {
	pc = 0x822E9068; continue 'dispatch;
	}
	// 822E9054: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E9058: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822E905C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E9060: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822E9064: 480780A5  bl 0x82361108
	ctx.lr = 0x822E9068;
	sub_82361108(ctx, base);
	pc = 0x822E9068; continue 'dispatch;
            }
            0x822E9068 => {
    //   block [0x822E9068..0x822E9094)
	// 822E9068: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822E906C: 409900C0  ble cr6, 0x822e912c
	if !ctx.cr[6].gt {
	pc = 0x822E912C; continue 'dispatch;
	}
	// 822E9070: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E9074: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E9078: 3BCBC270  addi r30, r11, -0x3d90
	ctx.r[30].s64 = ctx.r[11].s64 + -15760;
	// 822E907C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E9080: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 822E9084: 3BABC470  addi r29, r11, -0x3b90
	ctx.r[29].s64 = ctx.r[11].s64 + -15248;
	// 822E9088: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E908C: C3AA203C  lfs f29, 0x203c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8252 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822E9090: 3B8BC1A4  addi r28, r11, -0x3e5c
	ctx.r[28].s64 = ctx.r[11].s64 + -15964;
	pc = 0x822E9094; continue 'dispatch;
            }
            0x822E9094 => {
    //   block [0x822E9094..0x822E9120)
	// 822E9094: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822E9098: 4BEBA951  bl 0x821a39e8
	ctx.lr = 0x822E909C;
	sub_821A39E8(ctx, base);
	// 822E909C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E90A0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 822E90A4: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E90A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E90AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E90B0: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 822E90B4: 7D7F0734  extsh r31, r11
	ctx.r[31].s64 = ctx.r[11].s16 as i64;
	// 822E90B8: 480813D9  bl 0x8236a490
	ctx.lr = 0x822E90BC;
	sub_8236A490(ctx, base);
	// 822E90BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E90C0: 419A0060  beq cr6, 0x822e9120
	if ctx.cr[6].eq {
	pc = 0x822E9120; continue 'dispatch;
	}
	// 822E90C4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 822E90C8: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E90CC: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822E90D0: 39430090  addi r10, r3, 0x90
	ctx.r[10].s64 = ctx.r[3].s64 + 144;
	// 822E90D4: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822E90D8: 93030080  stw r24, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[24].u32 ) };
	// 822E90DC: D3A1006C  stfs f29, 0x6c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822E90E0: 93230084  stw r25, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[25].u32 ) };
	// 822E90E4: D36300A8  stfs f27, 0xa8(r3)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E90E8: B3E30088  sth r31, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[31].u16 ) };
	// 822E90EC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E90F0: D38300AC  stfs f28, 0xac(r3)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822E90F4: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E90F8: D3C300B0  stfs f30, 0xb0(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822E90FC: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E9100: D3C300B4  stfs f30, 0xb4(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822E9104: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E9108: FB6300A0  std r27, 0xa0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[27].u64 ) };
	// 822E910C: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822E9110: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822E9114: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 822E9118: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 822E911C: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x822E9120; continue 'dispatch;
            }
            0x822E9120 => {
    //   block [0x822E9120..0x822E912C)
	// 822E9120: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 822E9124: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 822E9128: 409AFF6C  bne cr6, 0x822e9094
	if !ctx.cr[6].eq {
	pc = 0x822E9094; continue 'dispatch;
	}
	pc = 0x822E912C; continue 'dispatch;
            }
            0x822E912C => {
    //   block [0x822E912C..0x822E913C)
	// 822E912C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822E9130: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 822E9134: 4824CEFD  bl 0x82536030
	ctx.lr = 0x822E9138;
	sub_82535FFC(ctx, base);
	// 822E9138: 4824BFC0  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E9140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E9140 size=100
    let mut pc: u32 = 0x822E9140;
    'dispatch: loop {
        match pc {
            0x822E9140 => {
    //   block [0x822E9140..0x822E918C)
	// 822E9140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E9144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E9148: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E914C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E9150: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E9154: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E9158: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822E915C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E9160: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E9164: A0BF00C0  lhz r5, 0xc0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 822E9168: 809F0084  lwz r4, 0x84(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822E916C: 4BFFCBB5  bl 0x822e5d20
	ctx.lr = 0x822E9170;
	sub_822E5D20(ctx, base);
	// 822E9170: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822E9174: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822E9178: 409A0014  bne cr6, 0x822e918c
	if !ctx.cr[6].eq {
	pc = 0x822E918C; continue 'dispatch;
	}
	// 822E917C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E9180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E9184: 4BFFF63D  bl 0x822e87c0
	ctx.lr = 0x822E9188;
	sub_822E87C0(ctx, base);
	// 822E9188: D03E0004  stfs f1, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x822E918C; continue 'dispatch;
            }
            0x822E918C => {
    //   block [0x822E918C..0x822E91A4)
	// 822E918C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E9190: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E9194: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E9198: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E919C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E91A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E91A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E91A8 size=560
    let mut pc: u32 = 0x822E91A8;
    'dispatch: loop {
        match pc {
            0x822E91A8 => {
    //   block [0x822E91A8..0x822E93B8)
	// 822E91A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E91AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E91B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E91B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E91B8: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 822E91BC: 4824CE0D  bl 0x82535fc8
	ctx.lr = 0x822E91C0;
	sub_82535FB0(ctx, base);
	// 822E91C0: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E91C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E91C8: 4BFFF599  bl 0x822e8760
	ctx.lr = 0x822E91CC;
	sub_822E8760(ctx, base);
	// 822E91CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822E91D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E91D4: 409A01E4  bne cr6, 0x822e93b8
	if !ctx.cr[6].eq {
	pc = 0x822E93B8; continue 'dispatch;
	}
	// 822E91D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E91DC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822E91E0: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 822E91E4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 822E91E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E91EC: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E91F0: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822E91F4: 4BFFF705  bl 0x822e88f8
	ctx.lr = 0x822E91F8;
	sub_822E88F8(ctx, base);
	// 822E91F8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822E91FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E9200: 419A01B8  beq cr6, 0x822e93b8
	if ctx.cr[6].eq {
	pc = 0x822E93B8; continue 'dispatch;
	}
	// 822E9204: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E9208: C1BF00AC  lfs f13, 0xac(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E920C: C00B2098  lfs f0, 0x2098(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E9210: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 822E9214: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E9218: C2CB9F78  lfs f22, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 822E921C: EEA005B2  fmuls f21, f0, f22
	ctx.f[21].f64 = (((ctx.f[0].f64 * ctx.f[22].f64) as f32) as f64);
	// 822E9220: FF15F800  fcmpu cr6, f21, f31
	ctx.cr[6].compare_f64(ctx.f[21].f64, ctx.f[31].f64);
	// 822E9224: 40990194  ble cr6, 0x822e93b8
	if !ctx.cr[6].gt {
	pc = 0x822E93B8; continue 'dispatch;
	}
	// 822E9228: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E922C: C2810050  lfs f20, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 822E9230: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 822E9234: C3010090  lfs f24, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 822E9238: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 822E923C: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 822E9240: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E9244: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 822E9248: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E924C: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 822E9250: C2EBBA38  lfs f23, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 822E9254: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E9258: C327D218  lfs f25, -0x2de8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 822E925C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822E9260: C3A82280  lfs f29, 0x2280(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8832 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822E9264: C3492470  lfs f26, 0x2470(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9328 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 822E9268: C36A203C  lfs f27, 0x203c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8252 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 822E926C: C38B206C  lfs f28, 0x206c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8300 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 822E9270: D2E1008C  stfs f23, 0x8c(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 822E9274: FF1FA000  fcmpu cr6, f31, f20
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[20].f64);
	// 822E9278: 40980140  bge cr6, 0x822e93b8
	if !ctx.cr[6].lt {
	pc = 0x822E93B8; continue 'dispatch;
	}
	// 822E927C: C3DF00A8  lfs f30, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822E9280: 48249F91  bl 0x82533210
	ctx.lr = 0x822E9284;
	sub_82533210(ctx, base);
	// 822E9284: 5469047E  clrlwi r9, r3, 0x11
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 822E9288: EDB807F2  fmuls f13, f24, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[24].f64 * ctx.f[31].f64) as f32) as f64);
	// 822E928C: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 822E9290: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 822E9294: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 822E9298: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822E929C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	pc = 0x822E93B8; continue 'dispatch;
            }
            0x822E93B8 => {
    //   block [0x822E93B8..0x822E93D8)
	// 822E93B8: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 822E93BC: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 822E93C0: 4824CC55  bl 0x82536014
	ctx.lr = 0x822E93C4;
	sub_82535FFC(ctx, base);
	// 822E93C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E93C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E93CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E93D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E93D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E93D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E93D8 size=728
    let mut pc: u32 = 0x822E93D8;
    'dispatch: loop {
        match pc {
            0x822E93D8 => {
    //   block [0x822E93D8..0x822E9410)
	// 822E93D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E93DC: 4824BCC5  bl 0x825350a0
	ctx.lr = 0x822E93E0;
	sub_82535080(ctx, base);
	// 822E93E0: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 822E93E4: 4824CC01  bl 0x82535fe4
	ctx.lr = 0x822E93E8;
	sub_82535FB0(ctx, base);
	// 822E93E8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E93EC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822E93F0: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 822E93F4: A17E0002  lhz r11, 2(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E93F8: 556A057E  clrlwi r10, r11, 0x15
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 822E93FC: 7D7D0734  extsh r29, r11
	ctx.r[29].s64 = ctx.r[11].s16 as i64;
	// 822E9400: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 822E9404: 2B0A0070  cmplwi cr6, r10, 0x70
	ctx.cr[6].compare_u32(ctx.r[10].u32, 112 as u32, &mut ctx.xer);
	// 822E9408: 40990008  ble cr6, 0x822e9410
	if !ctx.cr[6].gt {
	pc = 0x822E9410; continue 'dispatch;
	}
	// 822E940C: 3BA00015  li r29, 0x15
	ctx.r[29].s64 = 21;
	pc = 0x822E9410; continue 'dispatch;
            }
            0x822E9410 => {
    //   block [0x822E9410..0x822E942C)
	// 822E9410: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E9414: 556A057E  clrlwi r10, r11, 0x15
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 822E9418: 7D7C0734  extsh r28, r11
	ctx.r[28].s64 = ctx.r[11].s16 as i64;
	// 822E941C: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 822E9420: 2B0A0070  cmplwi cr6, r10, 0x70
	ctx.cr[6].compare_u32(ctx.r[10].u32, 112 as u32, &mut ctx.xer);
	// 822E9424: 40990008  ble cr6, 0x822e942c
	if !ctx.cr[6].gt {
	pc = 0x822E942C; continue 'dispatch;
	}
	// 822E9428: 3B800015  li r28, 0x15
	ctx.r[28].s64 = 21;
	pc = 0x822E942C; continue 'dispatch;
            }
            0x822E942C => {
    //   block [0x822E942C..0x822E9444)
	// 822E942C: 3BE4FFFF  addi r31, r4, -1
	ctx.r[31].s64 = ctx.r[4].s64 + -1;
	// 822E9430: 2F1F0003  cmpwi cr6, r31, 3
	ctx.cr[6].compare_i32(ctx.r[31].s32, 3, &mut ctx.xer);
	// 822E9434: 40980010  bge cr6, 0x822e9444
	if !ctx.cr[6].lt {
	pc = 0x822E9444; continue 'dispatch;
	}
	// 822E9438: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 822E943C: C36BD4DC  lfs f27, -0x2b24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 822E9440: 48000010  b 0x822e9450
	pc = 0x822E9450; continue 'dispatch;
            }
            0x822E9444 => {
    //   block [0x822E9444..0x822E9450)
	// 822E9444: A07E0006  lhz r3, 6(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 822E9448: 4BE2D129  bl 0x82116570
	ctx.lr = 0x822E944C;
	sub_82116570(ctx, base);
	// 822E944C: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	pc = 0x822E9450; continue 'dispatch;
            }
            0x822E9450 => {
    //   block [0x822E9450..0x822E9464)
	// 822E9450: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 822E9454: 40980010  bge cr6, 0x822e9464
	if !ctx.cr[6].lt {
	pc = 0x822E9464; continue 'dispatch;
	}
	// 822E9458: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E945C: C38B2054  lfs f28, 0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8276 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 822E9460: 48000010  b 0x822e9470
	pc = 0x822E9470; continue 'dispatch;
            }
            0x822E9464 => {
    //   block [0x822E9464..0x822E9470)
	// 822E9464: A07E0008  lhz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E9468: 4BE2D109  bl 0x82116570
	ctx.lr = 0x822E946C;
	sub_82116570(ctx, base);
	// 822E946C: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	pc = 0x822E9470; continue 'dispatch;
            }
            0x822E9470 => {
    //   block [0x822E9470..0x822E9488)
	// 822E9470: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E9474: 2F1F0005  cmpwi cr6, r31, 5
	ctx.cr[6].compare_i32(ctx.r[31].s32, 5, &mut ctx.xer);
	// 822E9478: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E947C: 4098000C  bge cr6, 0x822e9488
	if !ctx.cr[6].lt {
	pc = 0x822E9488; continue 'dispatch;
	}
	// 822E9480: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 822E9484: 48000010  b 0x822e9494
	pc = 0x822E9494; continue 'dispatch;
            }
            0x822E9488 => {
    //   block [0x822E9488..0x822E9494)
	// 822E9488: A07E000A  lhz r3, 0xa(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(10 as u32) ) } as u64;
	// 822E948C: 4BE2D0E5  bl 0x82116570
	ctx.lr = 0x822E9490;
	sub_82116570(ctx, base);
	// 822E9490: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	pc = 0x822E9494; continue 'dispatch;
            }
            0x822E9494 => {
    //   block [0x822E9494..0x822E94A8)
	// 822E9494: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822E9498: 2F1F0006  cmpwi cr6, r31, 6
	ctx.cr[6].compare_i32(ctx.r[31].s32, 6, &mut ctx.xer);
	// 822E949C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 822E94A0: 41980008  blt cr6, 0x822e94a8
	if ctx.cr[6].lt {
	pc = 0x822E94A8; continue 'dispatch;
	}
	// 822E94A4: A15E000C  lhz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x822E94A8; continue 'dispatch;
            }
            0x822E94A8 => {
    //   block [0x822E94A8..0x822E94D8)
	// 822E94A8: 7FAB0734  extsh r11, r29
	ctx.r[11].s64 = ctx.r[29].s16 as i64;
	// 822E94AC: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 822E94B0: 7D440734  extsh r4, r10
	ctx.r[4].s64 = ctx.r[10].s16 as i64;
	// 822E94B4: 556A0428  rlwinm r10, r11, 0, 0x10, 0x14
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822E94B8: 556B057E  clrlwi r11, r11, 0x15
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 822E94BC: 7D680734  extsh r8, r11
	ctx.r[8].s64 = ctx.r[11].s16 as i64;
	// 822E94C0: 2F0B0058  cmpwi cr6, r11, 0x58
	ctx.cr[6].compare_i32(ctx.r[11].s32, 88, &mut ctx.xer);
	// 822E94C4: B1410054  sth r10, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u16 ) };
	// 822E94C8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 822E94CC: B1010050  sth r8, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u16 ) };
	// 822E94D0: 40980008  bge cr6, 0x822e94d8
	if !ctx.cr[6].lt {
	pc = 0x822E94D8; continue 'dispatch;
	}
	// 822E94D4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	pc = 0x822E94D8; continue 'dispatch;
            }
            0x822E94D8 => {
    //   block [0x822E94D8..0x822E9508)
	// 822E94D8: 7F8B0734  extsh r11, r28
	ctx.r[11].s64 = ctx.r[28].s16 as i64;
	// 822E94DC: B1410052  sth r10, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u16 ) };
	// 822E94E0: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 822E94E4: 55670428  rlwinm r7, r11, 0, 0x10, 0x14
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822E94E8: 556B057E  clrlwi r11, r11, 0x15
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 822E94EC: 7D660734  extsh r6, r11
	ctx.r[6].s64 = ctx.r[11].s16 as i64;
	// 822E94F0: 2F0B0058  cmpwi cr6, r11, 0x58
	ctx.cr[6].compare_i32(ctx.r[11].s32, 88, &mut ctx.xer);
	// 822E94F4: B0E10064  sth r7, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u16 ) };
	// 822E94F8: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 822E94FC: B0C10060  sth r6, 0x60(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u16 ) };
	// 822E9500: 40980008  bge cr6, 0x822e9508
	if !ctx.cr[6].lt {
	pc = 0x822E9508; continue 'dispatch;
	}
	// 822E9504: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	pc = 0x822E9508; continue 'dispatch;
            }
            0x822E9508 => {
    //   block [0x822E9508..0x822E9544)
	// 822E9508: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 822E950C: B0E10062  sth r7, 0x62(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[7].u16 ) };
	// 822E9510: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 822E9514: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E9518: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822E951C: 392B47D0  addi r9, r11, 0x47d0
	ctx.r[9].s64 = ctx.r[11].s64 + 18384;
	// 822E9520: 41980024  blt cr6, 0x822e9544
	if ctx.cr[6].lt {
	pc = 0x822E9544; continue 'dispatch;
	}
	// 822E9524: 7D0B0734  extsh r11, r8
	ctx.r[11].s64 = ctx.r[8].s16 as i64;
	// 822E9528: 396BFFA8  addi r11, r11, -0x58
	ctx.r[11].s64 = ctx.r[11].s64 + -88;
	// 822E952C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E9530: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822E9534: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E9538: 7D6B4A2E  lhzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E953C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E9540: 48000008  b 0x822e9548
	pc = 0x822E9548; continue 'dispatch;
            }
            0x822E9544 => {
    //   block [0x822E9544..0x822E9548)
	// 822E9544: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822E9548; continue 'dispatch;
            }
            0x822E9548 => {
    //   block [0x822E9548..0x822E9578)
	// 822E9548: 7CEA0734  extsh r10, r7
	ctx.r[10].s64 = ctx.r[7].s16 as i64;
	// 822E954C: 5568063E  clrlwi r8, r11, 0x18
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E9550: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822E9554: 41980024  blt cr6, 0x822e9578
	if ctx.cr[6].lt {
	pc = 0x822E9578; continue 'dispatch;
	}
	// 822E9558: 7CCB0734  extsh r11, r6
	ctx.r[11].s64 = ctx.r[6].s16 as i64;
	// 822E955C: 396BFFA8  addi r11, r11, -0x58
	ctx.r[11].s64 = ctx.r[11].s64 + -88;
	// 822E9560: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822E9564: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822E9568: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E956C: 7D6B4A2E  lhzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822E9570: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E9574: 48000008  b 0x822e957c
	pc = 0x822E957C; continue 'dispatch;
            }
            0x822E9578 => {
    //   block [0x822E9578..0x822E957C)
	// 822E9578: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822E957C; continue 'dispatch;
            }
            0x822E957C => {
    //   block [0x822E957C..0x822E95B4)
	// 822E957C: 551F063E  clrlwi r31, r8, 0x18
	ctx.r[31].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 822E9580: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E9584: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E9588: 419A0118  beq cr6, 0x822e96a0
	if ctx.cr[6].eq {
	pc = 0x822E96A0; continue 'dispatch;
	}
	// 822E958C: 5578063E  clrlwi r24, r11, 0x18
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E9590: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 822E9594: 419A010C  beq cr6, 0x822e96a0
	if ctx.cr[6].eq {
	pc = 0x822E96A0; continue 'dispatch;
	}
	// 822E9598: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 822E959C: 419A0018  beq cr6, 0x822e95b4
	if ctx.cr[6].eq {
	pc = 0x822E95B4; continue 'dispatch;
	}
	// 822E95A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E95A4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822E95A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E95AC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822E95B0: 48077B59  bl 0x82361108
	ctx.lr = 0x822E95B4;
	sub_82361108(ctx, base);
	pc = 0x822E95B4; continue 'dispatch;
            }
            0x822E95B4 => {
    //   block [0x822E95B4..0x822E95E0)
	// 822E95B4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822E95B8: 409900E8  ble cr6, 0x822e96a0
	if !ctx.cr[6].gt {
	pc = 0x822E96A0; continue 'dispatch;
	}
	// 822E95BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E95C0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E95C4: 3BABC294  addi r29, r11, -0x3d6c
	ctx.r[29].s64 = ctx.r[11].s64 + -15724;
	// 822E95C8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E95CC: 7FF7FB78  mr r23, r31
	ctx.r[23].u64 = ctx.r[31].u64;
	// 822E95D0: 3B6BC470  addi r27, r11, -0x3b90
	ctx.r[27].s64 = ctx.r[11].s64 + -15248;
	// 822E95D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E95D8: C3AA203C  lfs f29, 0x203c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8252 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822E95DC: 3B4BC1B0  addi r26, r11, -0x3e50
	ctx.r[26].s64 = ctx.r[11].s64 + -15952;
	pc = 0x822E95E0; continue 'dispatch;
            }
            0x822E95E0 => {
    //   block [0x822E95E0..0x822E95F8)
	// 822E95E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822E95E4: 4BEBA405  bl 0x821a39e8
	ctx.lr = 0x822E95E8;
	sub_821A39E8(ctx, base);
	// 822E95E8: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 822E95EC: 7C7E0734  extsh r30, r3
	ctx.r[30].s64 = ctx.r[3].s16 as i64;
	// 822E95F0: 409900A4  ble cr6, 0x822e9694
	if !ctx.cr[6].gt {
	pc = 0x822E9694; continue 'dispatch;
	}
	// 822E95F4: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	pc = 0x822E95F8; continue 'dispatch;
            }
            0x822E95F8 => {
    //   block [0x822E95F8..0x822E9688)
	// 822E95F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822E95FC: 4BEBA3ED  bl 0x821a39e8
	ctx.lr = 0x822E9600;
	sub_821A39E8(ctx, base);
	// 822E9600: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E9604: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 822E9608: 809B000C  lwz r4, 0xc(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E960C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E9610: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E9614: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 822E9618: 7D7F0734  extsh r31, r11
	ctx.r[31].s64 = ctx.r[11].s16 as i64;
	// 822E961C: 48080E75  bl 0x8236a490
	ctx.lr = 0x822E9620;
	sub_8236A490(ctx, base);
	// 822E9620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E9624: 419A0064  beq cr6, 0x822e9688
	if ctx.cr[6].eq {
	pc = 0x822E9688; continue 'dispatch;
	}
	// 822E9628: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 822E962C: D3E10070  stfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822E9630: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822E9634: 39430090  addi r10, r3, 0x90
	ctx.r[10].s64 = ctx.r[3].s64 + 144;
	// 822E9638: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822E963C: 93830080  stw r28, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 822E9640: D3A1007C  stfs f29, 0x7c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822E9644: 92C30084  stw r22, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[22].u32 ) };
	// 822E9648: D36300A8  stfs f27, 0xa8(r3)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E964C: B3C30088  sth r30, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[30].u16 ) };
	// 822E9650: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E9654: D38300AC  stfs f28, 0xac(r3)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822E9658: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E965C: D3C300B0  stfs f30, 0xb0(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822E9660: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E9664: D3C300B4  stfs f30, 0xb4(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822E9668: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E966C: FB8300A0  std r28, 0xa0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[28].u64 ) };
	// 822E9670: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822E9674: B3E300C0  sth r31, 0xc0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[31].u16 ) };
	// 822E9678: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822E967C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 822E9680: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 822E9684: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x822E9688; continue 'dispatch;
            }
            0x822E9688 => {
    //   block [0x822E9688..0x822E9694)
	// 822E9688: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 822E968C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822E9690: 409AFF68  bne cr6, 0x822e95f8
	if !ctx.cr[6].eq {
	pc = 0x822E95F8; continue 'dispatch;
	}
	pc = 0x822E9694; continue 'dispatch;
            }
            0x822E9694 => {
    //   block [0x822E9694..0x822E96A0)
	// 822E9694: 3AF7FFFF  addi r23, r23, -1
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	// 822E9698: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 822E969C: 409AFF44  bne cr6, 0x822e95e0
	if !ctx.cr[6].eq {
	pc = 0x822E95E0; continue 'dispatch;
	}
	pc = 0x822E96A0; continue 'dispatch;
            }
            0x822E96A0 => {
    //   block [0x822E96A0..0x822E96B0)
	// 822E96A0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 822E96A4: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 822E96A8: 4824C989  bl 0x82536030
	ctx.lr = 0x822E96AC;
	sub_82535FFC(ctx, base);
	// 822E96AC: 4824BA44  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E96B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E96B0 size=144
    let mut pc: u32 = 0x822E96B0;
    'dispatch: loop {
        match pc {
            0x822E96B0 => {
    //   block [0x822E96B0..0x822E972C)
	// 822E96B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E96B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E96B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E96BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E96C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E96C4: 4BFFF09D  bl 0x822e8760
	ctx.lr = 0x822E96C8;
	sub_822E8760(ctx, base);
	// 822E96C8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822E96CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E96D0: 409A005C  bne cr6, 0x822e972c
	if !ctx.cr[6].eq {
	pc = 0x822E972C; continue 'dispatch;
	}
	// 822E96D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E96D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822E96DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E96E0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822E96E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E96E8: 4E800421  bctrl
	ctx.lr = 0x822E96EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E96EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E96F0: C1BF00AC  lfs f13, 0xac(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E96F4: 38DF0090  addi r6, r31, 0x90
	ctx.r[6].s64 = ctx.r[31].s64 + 144;
	// 822E96F8: C19F00A8  lfs f12, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E96FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822E9700: E8FF00A0  ld r7, 0xa0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	// 822E9704: C03F00C4  lfs f1, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E9708: 889F00C0  lbz r4, 0xc0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 822E970C: C08BBA38  lfs f4, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 822E9710: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822E9714: C00BD478  lfs f0, -0x2b88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E9718: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E971C: EC6D0032  fmuls f3, f13, f0
	ctx.f[3].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E9720: C00B2374  lfs f0, 0x2374(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9076 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E9724: EC4C0032  fmuls f2, f12, f0
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E9728: 4BFFE609  bl 0x822e7d30
	ctx.lr = 0x822E972C;
	sub_822E7D30(ctx, base);
            }
            0x822E972C => {
    //   block [0x822E972C..0x822E9740)
	// 822E972C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E9730: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E9734: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E9738: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E973C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E9740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E9740 size=744
    let mut pc: u32 = 0x822E9740;
    'dispatch: loop {
        match pc {
            0x822E9740 => {
    //   block [0x822E9740..0x822E977C)
	// 822E9740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E9744: 4824B959  bl 0x8253509c
	ctx.lr = 0x822E9748;
	sub_82535080(ctx, base);
	// 822E9748: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 822E974C: 4824C895  bl 0x82535fe0
	ctx.lr = 0x822E9750;
	sub_82535FB0(ctx, base);
	// 822E9750: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E9754: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822E9758: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 822E975C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 822E9760: A17F0002  lhz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 822E9764: 556A057E  clrlwi r10, r11, 0x15
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 822E9768: 7D7D0734  extsh r29, r11
	ctx.r[29].s64 = ctx.r[11].s16 as i64;
	// 822E976C: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 822E9770: 2B0A0070  cmplwi cr6, r10, 0x70
	ctx.cr[6].compare_u32(ctx.r[10].u32, 112 as u32, &mut ctx.xer);
	// 822E9774: 40990008  ble cr6, 0x822e977c
	if !ctx.cr[6].gt {
	pc = 0x822E977C; continue 'dispatch;
	}
	// 822E9778: 3BA00015  li r29, 0x15
	ctx.r[29].s64 = 21;
	pc = 0x822E977C; continue 'dispatch;
            }
            0x822E977C => {
    //   block [0x822E977C..0x822E9794)
	// 822E977C: 3BC5FFFF  addi r30, r5, -1
	ctx.r[30].s64 = ctx.r[5].s64 + -1;
	// 822E9780: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 822E9784: 40980010  bge cr6, 0x822e9794
	if !ctx.cr[6].lt {
	pc = 0x822E9794; continue 'dispatch;
	}
	// 822E9788: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 822E978C: C36BD4DC  lfs f27, -0x2b24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 822E9790: 48000010  b 0x822e97a0
	pc = 0x822E97A0; continue 'dispatch;
            }
            0x822E9794 => {
    //   block [0x822E9794..0x822E97A0)
	// 822E9794: A07F0004  lhz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E9798: 4BE2CDD9  bl 0x82116570
	ctx.lr = 0x822E979C;
	sub_82116570(ctx, base);
	// 822E979C: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	pc = 0x822E97A0; continue 'dispatch;
            }
            0x822E97A0 => {
    //   block [0x822E97A0..0x822E97B4)
	// 822E97A0: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 822E97A4: 40980010  bge cr6, 0x822e97b4
	if !ctx.cr[6].lt {
	pc = 0x822E97B4; continue 'dispatch;
	}
	// 822E97A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E97AC: C38B1FF8  lfs f28, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 822E97B0: 48000010  b 0x822e97c0
	pc = 0x822E97C0; continue 'dispatch;
            }
            0x822E97B4 => {
    //   block [0x822E97B4..0x822E97C0)
	// 822E97B4: A07F0006  lhz r3, 6(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 822E97B8: 4BE2CDB9  bl 0x82116570
	ctx.lr = 0x822E97BC;
	sub_82116570(ctx, base);
	// 822E97BC: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	pc = 0x822E97C0; continue 'dispatch;
            }
            0x822E97C0 => {
    //   block [0x822E97C0..0x822E97D4)
	// 822E97C0: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 822E97C4: 40980010  bge cr6, 0x822e97d4
	if !ctx.cr[6].lt {
	pc = 0x822E97D4; continue 'dispatch;
	}
	// 822E97C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E97CC: C3AB2054  lfs f29, 0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8276 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822E97D0: 48000010  b 0x822e97e0
	pc = 0x822E97E0; continue 'dispatch;
            }
            0x822E97D4 => {
    //   block [0x822E97D4..0x822E97E0)
	// 822E97D4: A07F0008  lhz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E97D8: 4BE2CD99  bl 0x82116570
	ctx.lr = 0x822E97DC;
	sub_82116570(ctx, base);
	// 822E97DC: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	pc = 0x822E97E0; continue 'dispatch;
            }
            0x822E97E0 => {
    //   block [0x822E97E0..0x822E97F4)
	// 822E97E0: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 822E97E4: 2F1E0005  cmpwi cr6, r30, 5
	ctx.cr[6].compare_i32(ctx.r[30].s32, 5, &mut ctx.xer);
	// 822E97E8: 7F35CB78  mr r21, r25
	ctx.r[21].u64 = ctx.r[25].u64;
	// 822E97EC: 41980008  blt cr6, 0x822e97f4
	if ctx.cr[6].lt {
	pc = 0x822E97F4; continue 'dispatch;
	}
	// 822E97F0: A2BF000A  lhz r21, 0xa(r31)
	ctx.r[21].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	pc = 0x822E97F4; continue 'dispatch;
            }
            0x822E97F4 => {
    //   block [0x822E97F4..0x822E9804)
	// 822E97F4: 2F1E0006  cmpwi cr6, r30, 6
	ctx.cr[6].compare_i32(ctx.r[30].s32, 6, &mut ctx.xer);
	// 822E97F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E97FC: 41980008  blt cr6, 0x822e9804
	if ctx.cr[6].lt {
	pc = 0x822E9804; continue 'dispatch;
	}
	// 822E9800: A15F000C  lhz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x822E9804; continue 'dispatch;
            }
            0x822E9804 => {
    //   block [0x822E9804..0x822E9838)
	// 822E9804: 7D440734  extsh r4, r10
	ctx.r[4].s64 = ctx.r[10].s16 as i64;
	// 822E9808: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822E980C: 7FAB0734  extsh r11, r29
	ctx.r[11].s64 = ctx.r[29].s16 as i64;
	// 822E9810: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 822E9814: 556A0428  rlwinm r10, r11, 0, 0x10, 0x14
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822E9818: 556B057E  clrlwi r11, r11, 0x15
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 822E981C: 2F0B0058  cmpwi cr6, r11, 0x58
	ctx.cr[6].compare_i32(ctx.r[11].s32, 88, &mut ctx.xer);
	// 822E9820: B1410054  sth r10, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u16 ) };
	// 822E9824: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 822E9828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E982C: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 822E9830: 40980008  bge cr6, 0x822e9838
	if !ctx.cr[6].lt {
	pc = 0x822E9838; continue 'dispatch;
	}
	// 822E9834: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x822E9838; continue 'dispatch;
            }
            0x822E9838 => {
    //   block [0x822E9838..0x822E9870)
	// 822E9838: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 822E983C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E9840: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E9844: 4198002C  blt cr6, 0x822e9870
	if ctx.cr[6].lt {
	pc = 0x822E9870; continue 'dispatch;
	}
	// 822E9848: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 822E984C: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 822E9850: 396BFFA8  addi r11, r11, -0x58
	ctx.r[11].s64 = ctx.r[11].s64 + -88;
	// 822E9854: 394A47D0  addi r10, r10, 0x47d0
	ctx.r[10].s64 = ctx.r[10].s64 + 18384;
	// 822E9858: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E985C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822E9860: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E9864: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E9868: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E986C: 48000008  b 0x822e9874
	pc = 0x822E9874; continue 'dispatch;
            }
            0x822E9870 => {
    //   block [0x822E9870..0x822E9874)
	// 822E9870: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822E9874; continue 'dispatch;
            }
            0x822E9874 => {
    //   block [0x822E9874..0x822E98A4)
	// 822E9874: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E9878: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E987C: 419A019C  beq cr6, 0x822e9a18
	if ctx.cr[6].eq {
	pc = 0x822E9A18; continue 'dispatch;
	}
	// 822E9880: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822E9884: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 822E9888: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E988C: 419A0018  beq cr6, 0x822e98a4
	if ctx.cr[6].eq {
	pc = 0x822E98A4; continue 'dispatch;
	}
	// 822E9890: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E9894: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822E9898: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E989C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822E98A0: 48077869  bl 0x82361108
	ctx.lr = 0x822E98A4;
	sub_82361108(ctx, base);
	pc = 0x822E98A4; continue 'dispatch;
            }
            0x822E98A4 => {
    //   block [0x822E98A4..0x822E98EC)
	// 822E98A4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822E98A8: 40990170  ble cr6, 0x822e9a18
	if !ctx.cr[6].gt {
	pc = 0x822E9A18; continue 'dispatch;
	}
	// 822E98AC: 7EAB0734  extsh r11, r21
	ctx.r[11].s64 = ctx.r[21].s16 as i64;
	// 822E98B0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E98B4: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822E98B8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E98BC: 7F8B0194  addze r28, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[28].s64 = tmp.s64;
	// 822E98C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E98C4: C349BFFC  lfs f26, -0x4004(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 822E98C8: 7FF6FB78  mr r22, r31
	ctx.r[22].u64 = ctx.r[31].u64;
	// 822E98CC: 3BCBC2B8  addi r30, r11, -0x3d48
	ctx.r[30].s64 = ctx.r[11].s64 + -15688;
	// 822E98D0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E98D4: C3CA203C  lfs f30, 0x203c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8252 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822E98D8: 3BABC470  addi r29, r11, -0x3b90
	ctx.r[29].s64 = ctx.r[11].s64 + -15248;
	// 822E98DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E98E0: 3B6BC1C8  addi r27, r11, -0x3e38
	ctx.r[27].s64 = ctx.r[11].s64 + -15928;
	// 822E98E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E98E8: 3B4BC1BC  addi r26, r11, -0x3e44
	ctx.r[26].s64 = ctx.r[11].s64 + -15940;
	pc = 0x822E98EC; continue 'dispatch;
            }
            0x822E98EC => {
    //   block [0x822E98EC..0x822E9988)
	// 822E98EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822E98F0: 4BEBA0F9  bl 0x821a39e8
	ctx.lr = 0x822E98F4;
	sub_821A39E8(ctx, base);
	// 822E98F4: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822E98F8: 7C7F0734  extsh r31, r3
	ctx.r[31].s64 = ctx.r[3].s16 as i64;
	// 822E98FC: 4099008C  ble cr6, 0x822e9988
	if !ctx.cr[6].gt {
	pc = 0x822E9988; continue 'dispatch;
	}
	// 822E9900: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E9904: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E9908: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 822E990C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E9910: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 822E9914: 48080B7D  bl 0x8236a490
	ctx.lr = 0x822E9918;
	sub_8236A490(ctx, base);
	// 822E9918: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E991C: 419A006C  beq cr6, 0x822e9988
	if ctx.cr[6].eq {
	pc = 0x822E9988; continue 'dispatch;
	}
	// 822E9920: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 822E9924: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E9928: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822E992C: 39430090  addi r10, r3, 0x90
	ctx.r[10].s64 = ctx.r[3].s64 + 144;
	// 822E9930: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822E9934: EC1C06B2  fmuls f0, f28, f26
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[26].f64) as f32) as f64);
	// 822E9938: D3C1006C  stfs f30, 0x6c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822E993C: 92E30080  stw r23, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[23].u32 ) };
	// 822E9940: D36300A8  stfs f27, 0xa8(r3)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E9944: 93030084  stw r24, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[24].u32 ) };
	// 822E9948: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E994C: D3A300AC  stfs f29, 0xac(r3)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822E9950: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E9954: D3E300B0  stfs f31, 0xb0(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822E9958: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E995C: D3E300B4  stfs f31, 0xb4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822E9960: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E9964: D00300C4  stfs f0, 0xc4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822E9968: B3E30088  sth r31, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[31].u16 ) };
	// 822E996C: FB2300A0  std r25, 0xa0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[25].u64 ) };
	// 822E9970: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822E9974: 9B8300C0  stb r28, 0xc0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[28].u8 ) };
	// 822E9978: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822E997C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 822E9980: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 822E9984: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x822E9988; continue 'dispatch;
            }
            0x822E9988 => {
    //   block [0x822E9988..0x822E9A0C)
	// 822E9988: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E998C: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E9990: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 822E9994: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E9998: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 822E999C: 48080AF5  bl 0x8236a490
	ctx.lr = 0x822E99A0;
	sub_8236A490(ctx, base);
	// 822E99A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E99A4: 419A0068  beq cr6, 0x822e9a0c
	if ctx.cr[6].eq {
	pc = 0x822E9A0C; continue 'dispatch;
	}
	// 822E99A8: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 822E99AC: D3E10070  stfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822E99B0: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822E99B4: 39430090  addi r10, r3, 0x90
	ctx.r[10].s64 = ctx.r[3].s64 + 144;
	// 822E99B8: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822E99BC: 92E30080  stw r23, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[23].u32 ) };
	// 822E99C0: D3C1007C  stfs f30, 0x7c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822E99C4: 93030084  stw r24, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[24].u32 ) };
	// 822E99C8: D36300A8  stfs f27, 0xa8(r3)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E99CC: B3E30088  sth r31, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[31].u16 ) };
	// 822E99D0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E99D4: D3A300AC  stfs f29, 0xac(r3)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822E99D8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E99DC: D3E300B0  stfs f31, 0xb0(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822E99E0: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E99E4: D3E300B4  stfs f31, 0xb4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822E99E8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E99EC: D38300C4  stfs f28, 0xc4(r3)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822E99F0: FB2300A0  std r25, 0xa0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[25].u64 ) };
	// 822E99F4: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822E99F8: 9AA300C0  stb r21, 0xc0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[21].u8 ) };
	// 822E99FC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822E9A00: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 822E9A04: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 822E9A08: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x822E9A0C; continue 'dispatch;
            }
            0x822E9A0C => {
    //   block [0x822E9A0C..0x822E9A18)
	// 822E9A0C: 3AD6FFFF  addi r22, r22, -1
	ctx.r[22].s64 = ctx.r[22].s64 + -1;
	// 822E9A10: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 822E9A14: 409AFED8  bne cr6, 0x822e98ec
	if !ctx.cr[6].eq {
	pc = 0x822E98EC; continue 'dispatch;
	}
	pc = 0x822E9A18; continue 'dispatch;
            }
            0x822E9A18 => {
    //   block [0x822E9A18..0x822E9A28)
	// 822E9A18: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 822E9A1C: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 822E9A20: 4824C60D  bl 0x8253602c
	ctx.lr = 0x822E9A24;
	sub_82535FFC(ctx, base);
	// 822E9A24: 4824B6C8  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E9A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E9A28 size=520
    let mut pc: u32 = 0x822E9A28;
    'dispatch: loop {
        match pc {
            0x822E9A28 => {
    //   block [0x822E9A28..0x822E9A60)
	// 822E9A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E9A2C: 4824B675  bl 0x825350a0
	ctx.lr = 0x822E9A30;
	sub_82535080(ctx, base);
	// 822E9A30: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 822E9A34: 4824C5AD  bl 0x82535fe0
	ctx.lr = 0x822E9A38;
	sub_82535FB0(ctx, base);
	// 822E9A38: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E9A3C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822E9A40: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 822E9A44: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822E9A48: 578B057E  clrlwi r11, r28, 0x15
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000007FFu64;
	// 822E9A4C: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 822E9A50: 2F0B0058  cmpwi cr6, r11, 0x58
	ctx.cr[6].compare_i32(ctx.r[11].s32, 88, &mut ctx.xer);
	// 822E9A54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E9A58: 40980008  bge cr6, 0x822e9a60
	if !ctx.cr[6].lt {
	pc = 0x822E9A60; continue 'dispatch;
	}
	// 822E9A5C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x822E9A60; continue 'dispatch;
            }
            0x822E9A60 => {
    //   block [0x822E9A60..0x822E9A98)
	// 822E9A60: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E9A64: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 822E9A68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E9A6C: 4198002C  blt cr6, 0x822e9a98
	if ctx.cr[6].lt {
	pc = 0x822E9A98; continue 'dispatch;
	}
	// 822E9A70: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 822E9A74: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 822E9A78: 396BFFA8  addi r11, r11, -0x58
	ctx.r[11].s64 = ctx.r[11].s64 + -88;
	// 822E9A7C: 394A47D0  addi r10, r10, 0x47d0
	ctx.r[10].s64 = ctx.r[10].s64 + 18384;
	// 822E9A80: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822E9A84: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822E9A88: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E9A8C: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822E9A90: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822E9A94: 48000008  b 0x822e9a9c
	pc = 0x822E9A9C; continue 'dispatch;
            }
            0x822E9A98 => {
    //   block [0x822E9A98..0x822E9A9C)
	// 822E9A98: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822E9A9C; continue 'dispatch;
            }
            0x822E9A9C => {
    //   block [0x822E9A9C..0x822E9B04)
	// 822E9A9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E9AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E9AA4: 419A017C  beq cr6, 0x822e9c20
	if ctx.cr[6].eq {
	pc = 0x822E9C20; continue 'dispatch;
	}
	// 822E9AA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E9AAC: 40990174  ble cr6, 0x822e9c20
	if !ctx.cr[6].gt {
	pc = 0x822E9C20; continue 'dispatch;
	}
	// 822E9AB0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E9AB4: 7D765B78  mr r22, r11
	ctx.r[22].u64 = ctx.r[11].u64;
	// 822E9AB8: 3BEAC2B8  addi r31, r10, -0x3d48
	ctx.r[31].s64 = ctx.r[10].s64 + -15688;
	// 822E9ABC: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 822E9AC0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822E9AC4: 3BAAC470  addi r29, r10, -0x3b90
	ctx.r[29].s64 = ctx.r[10].s64 + -15248;
	// 822E9AC8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E9ACC: 396BD6E8  addi r11, r11, -0x2918
	ctx.r[11].s64 = ctx.r[11].s64 + -10520;
	// 822E9AD0: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 822E9AD4: 3D008286  lis r8, -0x7d7a
	ctx.r[8].s64 = -2105147392;
	// 822E9AD8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E9ADC: 3B0AC1C8  addi r24, r10, -0x3e38
	ctx.r[24].s64 = ctx.r[10].s64 + -15928;
	// 822E9AE0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E9AE4: C3ABFBA4  lfs f29, -0x45c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1116 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822E9AE8: C3E7BA38  lfs f31, -0x45c8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E9AEC: 3B200004  li r25, 4
	ctx.r[25].s64 = 4;
	// 822E9AF0: C38B0000  lfs f28, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 822E9AF4: 3AEAC1BC  addi r23, r10, -0x3e44
	ctx.r[23].s64 = ctx.r[10].s64 + -15940;
	// 822E9AF8: C369207C  lfs f27, 0x207c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8316 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 822E9AFC: 3B400008  li r26, 8
	ctx.r[26].s64 = 8;
	// 822E9B00: C348D478  lfs f26, -0x2b88(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	pc = 0x822E9B04; continue 'dispatch;
            }
            0x822E9B04 => {
    //   block [0x822E9B04..0x822E9B8C)
	// 822E9B04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E9B08: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E9B0C: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 822E9B10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E9B14: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 822E9B18: 48080979  bl 0x8236a490
	ctx.lr = 0x822E9B1C;
	sub_8236A490(ctx, base);
	// 822E9B1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E9B20: 419A006C  beq cr6, 0x822e9b8c
	if ctx.cr[6].eq {
	pc = 0x822E9B8C; continue 'dispatch;
	}
	// 822E9B24: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822E9B28: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822E9B2C: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822E9B30: 39430090  addi r10, r3, 0x90
	ctx.r[10].s64 = ctx.r[3].s64 + 144;
	// 822E9B34: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822E9B38: EC1E06F2  fmuls f0, f30, f27
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[27].f64) as f32) as f64);
	// 822E9B3C: D3A1005C  stfs f29, 0x5c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822E9B40: 93C30080  stw r30, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 822E9B44: D3C300A8  stfs f30, 0xa8(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E9B48: 93630084  stw r27, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 822E9B4C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E9B50: D38300AC  stfs f28, 0xac(r3)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822E9B54: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E9B58: D3E300B0  stfs f31, 0xb0(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822E9B5C: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E9B60: D3E300B4  stfs f31, 0xb4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822E9B64: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E9B68: D00300C4  stfs f0, 0xc4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822E9B6C: B3830088  sth r28, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[28].u16 ) };
	// 822E9B70: FBC300A0  std r30, 0xa0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[30].u64 ) };
	// 822E9B74: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822E9B78: 9B2300C0  stb r25, 0xc0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[25].u8 ) };
	// 822E9B7C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822E9B80: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 822E9B84: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 822E9B88: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x822E9B8C; continue 'dispatch;
            }
            0x822E9B8C => {
    //   block [0x822E9B8C..0x822E9C14)
	// 822E9B8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E9B90: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E9B94: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 822E9B98: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E9B9C: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 822E9BA0: 480808F1  bl 0x8236a490
	ctx.lr = 0x822E9BA4;
	sub_8236A490(ctx, base);
	// 822E9BA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E9BA8: 419A006C  beq cr6, 0x822e9c14
	if ctx.cr[6].eq {
	pc = 0x822E9C14; continue 'dispatch;
	}
	// 822E9BAC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 822E9BB0: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822E9BB4: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822E9BB8: 39430090  addi r10, r3, 0x90
	ctx.r[10].s64 = ctx.r[3].s64 + 144;
	// 822E9BBC: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822E9BC0: EC1E06B2  fmuls f0, f30, f26
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[26].f64) as f32) as f64);
	// 822E9BC4: D3A1006C  stfs f29, 0x6c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822E9BC8: 93C30080  stw r30, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 822E9BCC: D3C300A8  stfs f30, 0xa8(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E9BD0: 93630084  stw r27, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 822E9BD4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E9BD8: D38300AC  stfs f28, 0xac(r3)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822E9BDC: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E9BE0: D3E300B0  stfs f31, 0xb0(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822E9BE4: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E9BE8: D3E300B4  stfs f31, 0xb4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822E9BEC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822E9BF0: D00300C4  stfs f0, 0xc4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822E9BF4: B3830088  sth r28, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[28].u16 ) };
	// 822E9BF8: FBC300A0  std r30, 0xa0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[30].u64 ) };
	// 822E9BFC: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822E9C00: 9B4300C0  stb r26, 0xc0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[26].u8 ) };
	// 822E9C04: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822E9C08: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 822E9C0C: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 822E9C10: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x822E9C14; continue 'dispatch;
            }
            0x822E9C14 => {
    //   block [0x822E9C14..0x822E9C20)
	// 822E9C14: 3AD6FFFF  addi r22, r22, -1
	ctx.r[22].s64 = ctx.r[22].s64 + -1;
	// 822E9C18: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 822E9C1C: 409AFEE8  bne cr6, 0x822e9b04
	if !ctx.cr[6].eq {
	pc = 0x822E9B04; continue 'dispatch;
	}
	pc = 0x822E9C20; continue 'dispatch;
            }
            0x822E9C20 => {
    //   block [0x822E9C20..0x822E9C30)
	// 822E9C20: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 822E9C24: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 822E9C28: 4824C405  bl 0x8253602c
	ctx.lr = 0x822E9C2C;
	sub_82535FFC(ctx, base);
	// 822E9C2C: 4824B4C4  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E9C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E9C30 size=124
    let mut pc: u32 = 0x822E9C30;
    'dispatch: loop {
        match pc {
            0x822E9C30 => {
    //   block [0x822E9C30..0x822E9C98)
	// 822E9C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E9C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E9C38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E9C3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E9C40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E9C44: 4BFFC975  bl 0x822e65b8
	ctx.lr = 0x822E9C48;
	sub_822E65B8(ctx, base);
	// 822E9C48: 897F0087  lbz r11, 0x87(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(135 as u32) ) } as u64;
	// 822E9C4C: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 822E9C50: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 822E9C54: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822E9C58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E9C5C: 409A003C  bne cr6, 0x822e9c98
	if !ctx.cr[6].eq {
	pc = 0x822E9C98; continue 'dispatch;
	}
	// 822E9C60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E9C64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822E9C68: C00B2230  lfs f0, 0x2230(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E9C6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E9C70: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 822E9C74: 915F0164  stw r10, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[10].u32 ) };
	// 822E9C78: C00B2B90  lfs f0, 0x2b90(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E9C7C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822E9C80: D01F0154  stfs f0, 0x154(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 822E9C84: 396BD218  addi r11, r11, -0x2de8
	ctx.r[11].s64 = ctx.r[11].s64 + -11752;
	// 822E9C88: C00B0074  lfs f0, 0x74(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E9C8C: D01F0150  stfs f0, 0x150(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 822E9C90: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E9C94: D01F015C  stfs f0, 0x15c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), tmp.u32 ) };
	pc = 0x822E9C98; continue 'dispatch;
            }
            0x822E9C98 => {
    //   block [0x822E9C98..0x822E9CAC)
	// 822E9C98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E9C9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E9CA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E9CA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E9CA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E9CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E9CB0 size=64
    let mut pc: u32 = 0x822E9CB0;
    'dispatch: loop {
        match pc {
            0x822E9CB0 => {
    //   block [0x822E9CB0..0x822E9CF0)
	// 822E9CB0: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 822E9CB4: C1A3015C  lfs f13, 0x15c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(348 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E9CB8: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 822E9CBC: 816300C4  lwz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E9CC0: 394ABFF0  addi r10, r10, -0x4010
	ctx.r[10].s64 = ctx.r[10].s64 + -16400;
	// 822E9CC4: 612985D8  ori r9, r9, 0x85d8
	ctx.r[9].u64 = ctx.r[9].u64 | 34264;
	// 822E9CC8: C18B0040  lfs f12, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E9CCC: 7C0A4C2E  lfsx f0, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E9CD0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E9CD4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E9CD8: C00A2198  lfs f0, 0x2198(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E9CDC: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 822E9CE0: D00B0040  stfs f0, 0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822E9CE4: 816300C4  lwz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E9CE8: D00B0044  stfs f0, 0x44(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 822E9CEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E9CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E9CF0 size=112
    let mut pc: u32 = 0x822E9CF0;
    'dispatch: loop {
        match pc {
            0x822E9CF0 => {
    //   block [0x822E9CF0..0x822E9D60)
	// 822E9CF0: E9230130  ld r9, 0x130(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(304 as u32) ) };
	// 822E9CF4: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 822E9CF8: E9030138  ld r8, 0x138(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(312 as u32) ) };
	// 822E9CFC: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 822E9D00: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822E9D04: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 822E9D08: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E9D0C: C181FFF0  lfs f12, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E9D10: C1A1FFF4  lfs f13, -0xc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E9D14: C00B22D0  lfs f0, 0x22d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E9D18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E9D1C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E9D20: D181FFF0  stfs f12, -0x10(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 822E9D24: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E9D28: C181FFF8  lfs f12, -8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E9D2C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E9D30: D181FFF8  stfs f12, -8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 822E9D34: C181FFFC  lfs f12, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E9D38: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E9D3C: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 822E9D40: C00B22CC  lfs f0, 0x22cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E9D44: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 822E9D48: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 822E9D4C: E96A0000  ld r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 822E9D50: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 822E9D54: F9630130  std r11, 0x130(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(304 as u32), ctx.r[11].u64 ) };
	// 822E9D58: F9430138  std r10, 0x138(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(312 as u32), ctx.r[10].u64 ) };
	// 822E9D5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E9D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E9D60 size=328
    let mut pc: u32 = 0x822E9D60;
    'dispatch: loop {
        match pc {
            0x822E9D60 => {
    //   block [0x822E9D60..0x822E9DBC)
	// 822E9D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E9D64: 4824B34D  bl 0x825350b0
	ctx.lr = 0x822E9D68;
	sub_82535080(ctx, base);
	// 822E9D68: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 822E9D6C: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 822E9D70: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E9D74: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E9D78: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822E9D7C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822E9D80: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 822E9D84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822E9D88: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822E9D8C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822E9D90: A16BBAC4  lhz r11, -0x453c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-17724 as u32) ) } as u64;
	// 822E9D94: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 822E9D98: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 822E9D9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E9DA0: F97A0000  std r11, 0(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 822E9DA4: 40980018  bge cr6, 0x822e9dbc
	if !ctx.cr[6].lt {
	pc = 0x822E9DBC; continue 'dispatch;
	}
	// 822E9DA8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822E9DAC: 816BBFA0  lwz r11, -0x4060(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16480 as u32) ) } as u64;
	// 822E9DB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E9DB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822E9DB8: 409A0008  bne cr6, 0x822e9dc0
	if !ctx.cr[6].eq {
	pc = 0x822E9DC0; continue 'dispatch;
	}
	pc = 0x822E9DBC; continue 'dispatch;
            }
            0x822E9DBC => {
    //   block [0x822E9DBC..0x822E9DC0)
	// 822E9DBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822E9DC0; continue 'dispatch;
            }
            0x822E9DC0 => {
    //   block [0x822E9DC0..0x822E9E04)
	// 822E9DC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822E9DC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E9DC8: 419A00CC  beq cr6, 0x822e9e94
	if ctx.cr[6].eq {
	pc = 0x822E9E94; continue 'dispatch;
	}
	// 822E9DCC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822E9DD0: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 822E9DD4: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 822E9DD8: 38A00385  li r5, 0x385
	ctx.r[5].s64 = 901;
	// 822E9DDC: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 822E9DE0: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822E9DE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E9DE8: 38EBC1D4  addi r7, r11, -0x3e2c
	ctx.r[7].s64 = ctx.r[11].s64 + -15916;
	// 822E9DEC: 480806A5  bl 0x8236a490
	ctx.lr = 0x822E9DF0;
	sub_8236A490(ctx, base);
	// 822E9DF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E9DF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E9DF8: 419A000C  beq cr6, 0x822e9e04
	if ctx.cr[6].eq {
	pc = 0x822E9E04; continue 'dispatch;
	}
	// 822E9DFC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822E9E00: 48000008  b 0x822e9e08
	pc = 0x822E9E08; continue 'dispatch;
            }
            0x822E9E04 => {
    //   block [0x822E9E04..0x822E9E08)
	// 822E9E04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822E9E08; continue 'dispatch;
            }
            0x822E9E08 => {
    //   block [0x822E9E08..0x822E9E94)
	// 822E9E08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E9E0C: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E9E10: 93FA0004  stw r31, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822E9E14: 419A0080  beq cr6, 0x822e9e94
	if ctx.cr[6].eq {
	pc = 0x822E9E94; continue 'dispatch;
	}
	// 822E9E18: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822E9E1C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 822E9E20: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E9E24: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822E9E28: 396B16E8  addi r11, r11, 0x16e8
	ctx.r[11].s64 = ctx.r[11].s64 + 5864;
	// 822E9E2C: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 822E9E30: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 822E9E34: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 822E9E38: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822E9E3C: C06A26E8  lfs f3, 0x26e8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9960 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822E9E40: 388B0750  addi r4, r11, 0x750
	ctx.r[4].s64 = ctx.r[11].s64 + 1872;
	// 822E9E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E9E48: 4BFFC641  bl 0x822e6488
	ctx.lr = 0x822E9E4C;
	sub_822E6488(ctx, base);
	// 822E9E4C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E9E50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E9E54: 396BC230  addi r11, r11, -0x3dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -15824;
	// 822E9E58: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E9E5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822E9E60: D01F0170  stfs f0, 0x170(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 822E9E64: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E9E68: 915F00D0  stw r10, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 822E9E6C: 4807D2CD  bl 0x82367138
	ctx.lr = 0x822E9E70;
	sub_82367138(ctx, base);
	// 822E9E70: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822E9E74: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822E9E78: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E9E7C: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822E9E80: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822E9E84: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822E9E88: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E9E8C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E9E90: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	pc = 0x822E9E94; continue 'dispatch;
            }
            0x822E9E94 => {
    //   block [0x822E9E94..0x822E9EA8)
	// 822E9E94: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822E9E98: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822E9E9C: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 822E9EA0: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822E9EA4: 4824B25C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E9EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E9EA8 size=1240
    let mut pc: u32 = 0x822E9EA8;
    'dispatch: loop {
        match pc {
            0x822E9EA8 => {
    //   block [0x822E9EA8..0x822E9F20)
	// 822E9EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E9EAC: 4824B1E9  bl 0x82535094
	ctx.lr = 0x822E9EB0;
	sub_82535080(ctx, base);
	// 822E9EB0: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 822E9EB4: 4824C12D  bl 0x82535fe0
	ctx.lr = 0x822E9EB8;
	sub_82535FB0(ctx, base);
	// 822E9EB8: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E9EBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E9EC0: 4BFFE8A1  bl 0x822e8760
	ctx.lr = 0x822E9EC4;
	sub_822E8760(ctx, base);
	// 822E9EC4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822E9EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E9ECC: 409A04A4  bne cr6, 0x822ea370
	if !ctx.cr[6].eq {
	pc = 0x822EA370; continue 'dispatch;
	}
	// 822E9ED0: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822E9ED4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 822E9ED8: 3FCB0002  addis r30, r11, 2
	ctx.r[30].s64 = ctx.r[11].s64 + 131072;
	// 822E9EDC: 3BDEBED8  addi r30, r30, -0x4128
	ctx.r[30].s64 = ctx.r[30].s64 + -16680;
	// 822E9EE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E9EE4: 4BE7996D  bl 0x82163850
	ctx.lr = 0x822E9EE8;
	sub_82163850(ctx, base);
	// 822E9EE8: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 822E9EEC: A2BE003A  lhz r21, 0x3a(r30)
	ctx.r[21].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(58 as u32) ) } as u64;
	// 822E9EF0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 822E9EF4: 6167FFFF  ori r7, r11, 0xffff
	ctx.r[7].u64 = ctx.r[11].u64 | 65535;
	// 822E9EF8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E9EFC: 3D608285  lis r11, -0x7d7b
	ctx.r[11].s64 = -2105212928;
	// 822E9F00: 7CF53850  subf r7, r21, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[21].s64;
	// 822E9F04: 394B6630  addi r10, r11, 0x6630
	ctx.r[10].s64 = ctx.r[11].s64 + 26160;
	// 822E9F08: 7CE70034  cntlzw r7, r7
	ctx.r[7].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 822E9F0C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822E9F10: 54E7DFFE  rlwinm r7, r7, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 822E9F14: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 822E9F18: 68F30001  xori r19, r7, 1
	ctx.r[19].u64 = ctx.r[7].u64 ^ 1;
	// 822E9F1C: 5516063E  clrlwi r22, r8, 0x18
	ctx.r[22].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	pc = 0x822E9F20; continue 'dispatch;
            }
            0x822E9F20 => {
    //   block [0x822E9F20..0x822E9F44)
	// 822E9F20: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E9F24: 7F08B000  cmpw cr6, r8, r22
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[22].s32, &mut ctx.xer);
	// 822E9F28: 419A001C  beq cr6, 0x822e9f44
	if ctx.cr[6].eq {
	pc = 0x822E9F44; continue 'dispatch;
	}
	// 822E9F2C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 822E9F30: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 822E9F34: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822E9F38: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 822E9F3C: 4198FFE4  blt cr6, 0x822e9f20
	if ctx.cr[6].lt {
	pc = 0x822E9F20; continue 'dispatch;
	}
	// 822E9F40: 48000014  b 0x822e9f54
	pc = 0x822E9F54; continue 'dispatch;
            }
            0x822E9F44 => {
    //   block [0x822E9F44..0x822E9F54)
	// 822E9F44: 552B083C  slwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E9F48: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 822E9F4C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E9F50: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x822E9F54; continue 'dispatch;
            }
            0x822E9F54 => {
    //   block [0x822E9F54..0x822E9F70)
	// 822E9F54: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 822E9F58: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822E9F5C: 7E97A378  mr r23, r20
	ctx.r[23].u64 = ctx.r[20].u64;
	// 822E9F60: 419A0010  beq cr6, 0x822e9f70
	if ctx.cr[6].eq {
	pc = 0x822E9F70; continue 'dispatch;
	}
	// 822E9F64: 82F90004  lwz r23, 4(r25)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E9F68: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 822E9F6C: 419A0404  beq cr6, 0x822ea370
	if ctx.cr[6].eq {
	pc = 0x822EA370; continue 'dispatch;
	}
	pc = 0x822E9F70; continue 'dispatch;
            }
            0x822E9F70 => {
    //   block [0x822E9F70..0x822EA0A8)
	// 822E9F70: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822E9F74: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 822E9F78: 7D775A14  add r11, r23, r11
	ctx.r[11].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 822E9F7C: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822E9F80: 557A2036  slwi r26, r11, 4
	ctx.r[26].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 822E9F84: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 822E9F88: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822E9F8C: C34626E8  lfs f26, 0x26e8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(9960 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 822E9F90: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822E9F94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822E9F98: C387BFFC  lfs f28, -0x4004(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 822E9F9C: 3B600020  li r27, 0x20
	ctx.r[27].s64 = 32;
	// 822E9FA0: C3A820CC  lfs f29, 0x20cc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8396 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822E9FA4: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 822E9FA8: C3C9212C  lfs f30, 0x212c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8492 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822E9FAC: 3B000030  li r24, 0x30
	ctx.r[24].s64 = 48;
	// 822E9FB0: C3EA2128  lfs f31, 0x2128(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8488 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E9FB4: C36B21B0  lfs f27, 0x21b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8624 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 822E9FB8: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822E9FBC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822E9FC0: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 822E9FC4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822E9FC8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E9FCC: 419A00DC  beq cr6, 0x822ea0a8
	if ctx.cr[6].eq {
	pc = 0x822EA0A8; continue 'dispatch;
	}
	// 822E9FD0: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 822E9FD4: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 822E9FD8: 3BCAFFD0  addi r30, r10, -0x30
	ctx.r[30].s64 = ctx.r[10].s64 + -48;
	// 822E9FDC: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 822E9FE0: 809E0024  lwz r4, 0x24(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 822E9FE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E9FE8: 4E800421  bctrl
	ctx.lr = 0x822E9FEC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EA0A8 => {
    //   block [0x822EA0A8..0x822EA370)
	// 822EA0A8: 38800053  li r4, 0x53
	ctx.r[4].s64 = 83;
	// 822EA0AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EA0B0: 4E800421  bctrl
	ctx.lr = 0x822EA0B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EA0B4: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822EA0B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EA0BC: 386A0030  addi r3, r10, 0x30
	ctx.r[3].s64 = ctx.r[10].s64 + 48;
	// 822EA0C0: 38800047  li r4, 0x47
	ctx.r[4].s64 = 71;
	// 822EA0C4: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 822EA0C8: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA0CC: D00100D0  stfs f0, 0xd0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 822EA0D0: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA0D4: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 822EA0D8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA0DC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EA0E0: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 822EA0E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EA0E8: 4E800421  bctrl
	ctx.lr = 0x822EA0EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EA0EC: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822EA0F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EA0F4: 386A0030  addi r3, r10, 0x30
	ctx.r[3].s64 = ctx.r[10].s64 + 48;
	// 822EA0F8: 38800059  li r4, 0x59
	ctx.r[4].s64 = 89;
	// 822EA0FC: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 822EA100: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA104: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822EA108: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA10C: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822EA110: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA114: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EA118: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822EA11C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EA120: 4E800421  bctrl
	ctx.lr = 0x822EA124;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EA124: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 822EA128: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EA12C: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822EA130: 38800056  li r4, 0x56
	ctx.r[4].s64 = 86;
	// 822EA134: 386A0030  addi r3, r10, 0x30
	ctx.r[3].s64 = ctx.r[10].s64 + 48;
            }
            0x822EA370 => {
    //   block [0x822EA370..0x822EA380)
	// 822EA370: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 822EA374: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 822EA378: 4824BCB5  bl 0x8253602c
	ctx.lr = 0x822EA37C;
	sub_82535FFC(ctx, base);
	// 822EA37C: 4824AD68  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EA380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EA380 size=240
    let mut pc: u32 = 0x822EA380;
    'dispatch: loop {
        match pc {
            0x822EA380 => {
    //   block [0x822EA380..0x822EA45C)
	// 822EA380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EA384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EA388: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EA38C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EA390: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EA394: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EA398: 38EBC1E0  addi r7, r11, -0x3e20
	ctx.r[7].s64 = ctx.r[11].s64 + -15904;
	// 822EA39C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822EA3A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822EA3A4: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 822EA3A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822EA3AC: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 822EA3B0: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822EA3B4: 480800DD  bl 0x8236a490
	ctx.lr = 0x822EA3B8;
	sub_8236A490(ctx, base);
	// 822EA3B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EA3BC: 419A00A0  beq cr6, 0x822ea45c
	if ctx.cr[6].eq {
	pc = 0x822EA45C; continue 'dispatch;
	}
	// 822EA3C0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822EA3C4: 93E30084  stw r31, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 822EA3C8: 39030090  addi r8, r3, 0x90
	ctx.r[8].s64 = ctx.r[3].s64 + 144;
	// 822EA3CC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822EA3D0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822EA3D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822EA3D8: C00ABA38  lfs f0, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA3DC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822EA3E0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822EA3E4: 392AC2DC  addi r9, r10, -0x3d24
	ctx.r[9].s64 = ctx.r[10].s64 + -15652;
	// 822EA3E8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822EA3EC: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 822EA3F0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822EA3F4: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 822EA3F8: F8E300A0  std r7, 0xa0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[7].u64 ) };
	// 822EA3FC: 90E300C0  stw r7, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[7].u32 ) };
	// 822EA400: 90C30080  stw r6, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[6].u32 ) };
	// 822EA404: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822EA408: B0C30088  sth r6, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[6].u16 ) };
	// 822EA40C: C0082038  lfs f0, 0x2038(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA410: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 822EA414: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822EA418: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EA41C: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EA420: C1A820CC  lfs f13, 0x20cc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8396 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EA424: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 822EA428: D1A300A8  stfs f13, 0xa8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822EA42C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822EA430: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 822EA434: C1887580  lfs f12, 0x7580(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(30080 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822EA438: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 822EA43C: D18300AC  stfs f12, 0xac(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822EA440: C0082938  lfs f0, 0x2938(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA444: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EA448: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822EA44C: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822EA450: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822EA454: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 822EA458: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x822EA45C; continue 'dispatch;
            }
            0x822EA45C => {
    //   block [0x822EA45C..0x822EA470)
	// 822EA45C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822EA460: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EA464: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EA468: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EA46C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EA470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EA470 size=352
    let mut pc: u32 = 0x822EA470;
    'dispatch: loop {
        match pc {
            0x822EA470 => {
    //   block [0x822EA470..0x822EA4B0)
	// 822EA470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EA474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EA478: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EA47C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822EA480: 3CC50002  addis r6, r5, 2
	ctx.r[6].s64 = ctx.r[5].s64 + 131072;
	// 822EA484: 38C6BED8  addi r6, r6, -0x4128
	ctx.r[6].s64 = ctx.r[6].s64 + -16680;
	// 822EA488: 88E60004  lbz r7, 4(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EA48C: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 822EA490: 419A0020  beq cr6, 0x822ea4b0
	if ctx.cr[6].eq {
	pc = 0x822EA4B0; continue 'dispatch;
	}
	// 822EA494: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 822EA498: 4BED1921  bl 0x821bbdb8
	ctx.lr = 0x822EA49C;
	sub_821BBDB8(ctx, base);
	// 822EA49C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822EA4A0: 396BF9C0  addi r11, r11, -0x640
	ctx.r[11].s64 = ctx.r[11].s64 + -1600;
	// 822EA4A4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EA4A8: 409A0008  bne cr6, 0x822ea4b0
	if !ctx.cr[6].eq {
	pc = 0x822EA4B0; continue 'dispatch;
	}
	// 822EA4AC: 38E00021  li r7, 0x21
	ctx.r[7].s64 = 33;
	pc = 0x822EA4B0; continue 'dispatch;
            }
            0x822EA4B0 => {
    //   block [0x822EA4B0..0x822EA534)
	// 822EA4B0: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 822EA4B4: A146003A  lhz r10, 0x3a(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(58 as u32) ) } as u64;
	// 822EA4B8: 54E9063E  clrlwi r9, r7, 0x18
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822EA4BC: 6164FFFF  ori r4, r11, 0xffff
	ctx.r[4].u64 = ctx.r[11].u64 | 65535;
	// 822EA4C0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822EA4C4: 61639C00  ori r3, r11, 0x9c00
	ctx.r[3].u64 = ctx.r[11].u64 | 39936;
	// 822EA4C8: 81660FEC  lwz r11, 0xfec(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4076 as u32) ) } as u64;
	// 822EA4CC: 5568063E  clrlwi r8, r11, 0x18
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822EA4D0: 7D65182E  lwzx r11, r5, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 822EA4D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EA4D8: 7D6A2050  subf r11, r10, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 822EA4DC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822EA4E0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822EA4E4: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 822EA4E8: 419A00D4  beq cr6, 0x822ea5bc
	if ctx.cr[6].eq {
	pc = 0x822EA5BC; continue 'dispatch;
	}
	// 822EA4EC: 80E50010  lwz r7, 0x10(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 822EA4F0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822EA4F4: 419A00C8  beq cr6, 0x822ea5bc
	if ctx.cr[6].eq {
	pc = 0x822EA5BC; continue 'dispatch;
	}
	// 822EA4F8: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 822EA4FC: 60E7EB2B  ori r7, r7, 0xeb2b
	ctx.r[7].u64 = ctx.r[7].u64 | 60203;
	// 822EA500: 7CE538AE  lbzx r7, r5, r7
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 822EA504: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822EA508: 409A00B4  bne cr6, 0x822ea5bc
	if !ctx.cr[6].eq {
	pc = 0x822EA5BC; continue 'dispatch;
	}
	// 822EA50C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EA510: 419A0080  beq cr6, 0x822ea590
	if ctx.cr[6].eq {
	pc = 0x822EA590; continue 'dispatch;
	}
	// 822EA514: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 822EA518: 2B0B0019  cmplwi cr6, r11, 0x19
	ctx.cr[6].compare_u32(ctx.r[11].u32, 25 as u32, &mut ctx.xer);
	// 822EA51C: 419A00A0  beq cr6, 0x822ea5bc
	if ctx.cr[6].eq {
	pc = 0x822EA5BC; continue 'dispatch;
	}
	// 822EA520: 2B0B001D  cmplwi cr6, r11, 0x1d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 29 as u32, &mut ctx.xer);
	// 822EA524: 409A0010  bne cr6, 0x822ea534
	if !ctx.cr[6].eq {
	pc = 0x822EA534; continue 'dispatch;
	}
	// 822EA528: 5509063E  clrlwi r9, r8, 0x18
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 822EA52C: 2B090020  cmplwi cr6, r9, 0x20
	ctx.cr[6].compare_u32(ctx.r[9].u32, 32 as u32, &mut ctx.xer);
	// 822EA530: 419A008C  beq cr6, 0x822ea5bc
	if ctx.cr[6].eq {
	pc = 0x822EA5BC; continue 'dispatch;
	}
	pc = 0x822EA534; continue 'dispatch;
            }
            0x822EA534 => {
    //   block [0x822EA534..0x822EA580)
	// 822EA534: 2B0B0012  cmplwi cr6, r11, 0x12
	ctx.cr[6].compare_u32(ctx.r[11].u32, 18 as u32, &mut ctx.xer);
	// 822EA538: 419A0084  beq cr6, 0x822ea5bc
	if ctx.cr[6].eq {
	pc = 0x822EA5BC; continue 'dispatch;
	}
	// 822EA53C: 2B0B0014  cmplwi cr6, r11, 0x14
	ctx.cr[6].compare_u32(ctx.r[11].u32, 20 as u32, &mut ctx.xer);
	// 822EA540: 409A0050  bne cr6, 0x822ea590
	if !ctx.cr[6].eq {
	pc = 0x822EA590; continue 'dispatch;
	}
	// 822EA544: 554B043E  clrlwi r11, r10, 0x10
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 822EA548: 2B0B0752  cmplwi cr6, r11, 0x752
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1874 as u32, &mut ctx.xer);
	// 822EA54C: 409A0044  bne cr6, 0x822ea590
	if !ctx.cr[6].eq {
	pc = 0x822EA590; continue 'dispatch;
	}
	// 822EA550: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822EA554: 616BCEF0  ori r11, r11, 0xcef0
	ctx.r[11].u64 = ctx.r[11].u64 | 52976;
	// 822EA558: 7D65582E  lwzx r11, r5, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EA55C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822EA560: 419A0020  beq cr6, 0x822ea580
	if ctx.cr[6].eq {
	pc = 0x822EA580; continue 'dispatch;
	}
	// 822EA564: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 822EA568: 419A0018  beq cr6, 0x822ea580
	if ctx.cr[6].eq {
	pc = 0x822EA580; continue 'dispatch;
	}
	// 822EA56C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 822EA570: 419A0010  beq cr6, 0x822ea580
	if ctx.cr[6].eq {
	pc = 0x822EA580; continue 'dispatch;
	}
	// 822EA574: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 822EA578: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822EA57C: 409A0008  bne cr6, 0x822ea584
	if !ctx.cr[6].eq {
	pc = 0x822EA584; continue 'dispatch;
	}
	pc = 0x822EA580; continue 'dispatch;
            }
            0x822EA580 => {
    //   block [0x822EA580..0x822EA584)
	// 822EA580: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x822EA584; continue 'dispatch;
            }
            0x822EA584 => {
    //   block [0x822EA584..0x822EA590)
	// 822EA584: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822EA588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EA58C: 409A0030  bne cr6, 0x822ea5bc
	if !ctx.cr[6].eq {
	pc = 0x822EA5BC; continue 'dispatch;
	}
	pc = 0x822EA590; continue 'dispatch;
            }
            0x822EA590 => {
    //   block [0x822EA590..0x822EA5A8)
	// 822EA590: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 822EA594: 816BA0CC  lwz r11, -0x5f34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24372 as u32) ) } as u64;
	// 822EA598: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 822EA59C: 419A000C  beq cr6, 0x822ea5a8
	if ctx.cr[6].eq {
	pc = 0x822EA5A8; continue 'dispatch;
	}
	// 822EA5A0: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 822EA5A4: 409A0018  bne cr6, 0x822ea5bc
	if !ctx.cr[6].eq {
	pc = 0x822EA5BC; continue 'dispatch;
	}
	pc = 0x822EA5A8; continue 'dispatch;
            }
            0x822EA5A8 => {
    //   block [0x822EA5A8..0x822EA5BC)
	// 822EA5A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822EA5AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822EA5B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EA5B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EA5B8: 4E800020  blr
	return;
            }
            0x822EA5BC => {
    //   block [0x822EA5BC..0x822EA5D0)
	// 822EA5BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822EA5C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822EA5C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EA5C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EA5CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EA5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EA5D0 size=344
    let mut pc: u32 = 0x822EA5D0;
    'dispatch: loop {
        match pc {
            0x822EA5D0 => {
    //   block [0x822EA5D0..0x822EA688)
	// 822EA5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EA5D4: 4824AAE9  bl 0x825350bc
	ctx.lr = 0x822EA5D8;
	sub_82535080(ctx, base);
	// 822EA5D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EA5DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EA5E0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822EA5E4: 2F050005  cmpwi cr6, r5, 5
	ctx.cr[6].compare_i32(ctx.r[5].s32, 5, &mut ctx.xer);
	// 822EA5E8: 419A00F0  beq cr6, 0x822ea6d8
	if ctx.cr[6].eq {
	pc = 0x822EA6D8; continue 'dispatch;
	}
	// 822EA5EC: 2F050009  cmpwi cr6, r5, 9
	ctx.cr[6].compare_i32(ctx.r[5].s32, 9, &mut ctx.xer);
	// 822EA5F0: 419A0098  beq cr6, 0x822ea688
	if ctx.cr[6].eq {
	pc = 0x822EA688; continue 'dispatch;
	}
	// 822EA5F4: 2F050010  cmpwi cr6, r5, 0x10
	ctx.cr[6].compare_i32(ctx.r[5].s32, 16, &mut ctx.xer);
	// 822EA5F8: 409A0128  bne cr6, 0x822ea720
	if !ctx.cr[6].eq {
	pc = 0x822EA720; continue 'dispatch;
	}
	// 822EA5FC: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822EA600: 396B16E8  addi r11, r11, 0x16e8
	ctx.r[11].s64 = ctx.r[11].s64 + 5864;
	// 822EA604: A16B073C  lhz r11, 0x73c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(1852 as u32) ) } as u64;
	// 822EA608: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822EA60C: 419A0114  beq cr6, 0x822ea720
	if ctx.cr[6].eq {
	pc = 0x822EA720; continue 'dispatch;
	}
	// 822EA610: 4807CB29  bl 0x82367138
	ctx.lr = 0x822EA614;
	sub_82367138(ctx, base);
	// 822EA614: 3D40CCCC  lis r10, -0x3334
	ctx.r[10].s64 = -859045888;
	// 822EA618: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EA61C: 614ACCCD  ori r10, r10, 0xcccd
	ctx.r[10].u64 = ctx.r[10].u64 | 52429;
	// 822EA620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EA624: 7D4B5016  mulhwu r10, r11, r10
	ctx.r[10].u64 = ((ctx.r[11].u32 as u64 * ctx.r[10].u32 as u64) >> 32);
	// 822EA628: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EA62C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822EA630: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822EA634: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822EA638: 38AB0003  addi r5, r11, 3
	ctx.r[5].s64 = ctx.r[11].s64 + 3;
	// 822EA63C: 480012BD  bl 0x822eb8f8
	ctx.lr = 0x822EA640;
	sub_822EB8F8(ctx, base);
	// 822EA640: 3FC082C0  lis r30, -0x7d40
	ctx.r[30].s64 = -2101346304;
	// 822EA644: 817EBC14  lwz r11, -0x43ec(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17388 as u32) ) } as u64;
	// 822EA648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EA64C: 419A00D4  beq cr6, 0x822ea720
	if ctx.cr[6].eq {
	pc = 0x822EA720; continue 'dispatch;
	}
	// 822EA650: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822EA654: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 822EA658: 7FA40734  extsh r4, r29
	ctx.r[4].s64 = ctx.r[29].s16 as i64;
	// 822EA65C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EA660: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EA664: 4E800421  bctrl
	ctx.lr = 0x822EA668;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EA668: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822EA66C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822EA670: 807EBC14  lwz r3, -0x43ec(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17388 as u32) ) } as u64;
	// 822EA674: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 822EA678: 7CBF58AE  lbzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EA67C: 4803CA35  bl 0x823270b0
	ctx.lr = 0x822EA680;
	sub_823270B0(ctx, base);
	// 822EA680: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822EA684: 4824AA88  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x822EA688 => {
    //   block [0x822EA688..0x822EA6D8)
	// 822EA688: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822EA68C: 396B16E8  addi r11, r11, 0x16e8
	ctx.r[11].s64 = ctx.r[11].s64 + 5864;
	// 822EA690: A16B0724  lhz r11, 0x724(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(1828 as u32) ) } as u64;
	// 822EA694: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822EA698: 419A0088  beq cr6, 0x822ea720
	if ctx.cr[6].eq {
	pc = 0x822EA720; continue 'dispatch;
	}
	// 822EA69C: 4807CA9D  bl 0x82367138
	ctx.lr = 0x822EA6A0;
	sub_82367138(ctx, base);
	// 822EA6A0: 3D40CCCC  lis r10, -0x3334
	ctx.r[10].s64 = -859045888;
	// 822EA6A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EA6A8: 614ACCCD  ori r10, r10, 0xcccd
	ctx.r[10].u64 = ctx.r[10].u64 | 52429;
	// 822EA6AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822EA6B0: 7D4B5016  mulhwu r10, r11, r10
	ctx.r[10].u64 = ((ctx.r[11].u32 as u64 * ctx.r[10].u32 as u64) >> 32);
	// 822EA6B4: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EA6B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EA6BC: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822EA6C0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822EA6C4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822EA6C8: 38AB0002  addi r5, r11, 2
	ctx.r[5].s64 = ctx.r[11].s64 + 2;
	// 822EA6CC: 4800114D  bl 0x822eb818
	ctx.lr = 0x822EA6D0;
	sub_822EB818(ctx, base);
	// 822EA6D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822EA6D4: 4824AA38  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x822EA6D8 => {
    //   block [0x822EA6D8..0x822EA720)
	// 822EA6D8: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822EA6DC: 396B16E8  addi r11, r11, 0x16e8
	ctx.r[11].s64 = ctx.r[11].s64 + 5864;
	// 822EA6E0: A16B070C  lhz r11, 0x70c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(1804 as u32) ) } as u64;
	// 822EA6E4: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 822EA6E8: 419A0038  beq cr6, 0x822ea720
	if ctx.cr[6].eq {
	pc = 0x822EA720; continue 'dispatch;
	}
	// 822EA6EC: 4807CA4D  bl 0x82367138
	ctx.lr = 0x822EA6F0;
	sub_82367138(ctx, base);
	// 822EA6F0: 3D40CCCC  lis r10, -0x3334
	ctx.r[10].s64 = -859045888;
	// 822EA6F4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EA6F8: 614ACCCD  ori r10, r10, 0xcccd
	ctx.r[10].u64 = ctx.r[10].u64 | 52429;
	// 822EA6FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822EA700: 7D4B5016  mulhwu r10, r11, r10
	ctx.r[10].u64 = ((ctx.r[11].u32 as u64 * ctx.r[10].u32 as u64) >> 32);
	// 822EA704: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EA708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EA70C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822EA710: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822EA714: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822EA718: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 822EA71C: 4800101D  bl 0x822eb738
	ctx.lr = 0x822EA720;
	sub_822EB738(ctx, base);
	pc = 0x822EA720; continue 'dispatch;
            }
            0x822EA720 => {
    //   block [0x822EA720..0x822EA728)
	// 822EA720: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822EA724: 4824A9E8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EA728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EA728 size=300
    let mut pc: u32 = 0x822EA728;
    'dispatch: loop {
        match pc {
            0x822EA728 => {
    //   block [0x822EA728..0x822EA854)
	// 822EA728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EA72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EA730: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EA734: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EA738: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EA73C: 4807C9FD  bl 0x82367138
	ctx.lr = 0x822EA740;
	sub_82367138(ctx, base);
	// 822EA740: 78690260  clrldi r9, r3, 0x29
	ctx.r[9].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EA744: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EA748: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 822EA74C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822EA750: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822EA754: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 822EA758: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 822EA75C: C1AB26D0  lfs f13, 0x26d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9936 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EA760: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822EA764: C00AD4D4  lfs f0, -0x2b2c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA768: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 822EA76C: 396B16E8  addi r11, r11, 0x16e8
	ctx.r[11].s64 = ctx.r[11].s64 + 5864;
	// 822EA770: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822EA774: 38CA3C50  addi r6, r10, 0x3c50
	ctx.r[6].s64 = ctx.r[10].s64 + 15440;
	// 822EA778: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822EA77C: 388B0708  addi r4, r11, 0x708
	ctx.r[4].s64 = ctx.r[11].s64 + 1800;
	// 822EA780: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822EA784: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822EA788: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822EA78C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EA790: C06BBA38  lfs f3, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822EA794: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 822EA798: C00A20C8  lfs f0, 0x20c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA79C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822EA7A0: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 822EA7A4: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822EA7A8: C18A1FF8  lfs f12, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822EA7AC: C00B06B0  lfs f0, 0x6b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA7B0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822EA7B4: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822EA7B8: D1860004  stfs f12, 4(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822EA7BC: D1860008  stfs f12, 8(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822EA7C0: D066000C  stfs f3, 0xc(r6)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822EA7C4: C16BCFEC  lfs f11, -0x3014(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822EA7C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EA7CC: EC4002F2  fmuls f2, f0, f11
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 822EA7D0: C16B2280  lfs f11, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822EA7D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EA7D8: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822EA7DC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822EA7E0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822EA7E4: ED4002F2  fmuls f10, f0, f11
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 822EA7E8: C00B26CC  lfs f0, 0x26cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9932 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA7EC: EC2A037A  fmadds f1, f10, f13, f0
	ctx.f[1].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 822EA7F0: 4BFFBC99  bl 0x822e6488
	ctx.lr = 0x822EA7F4;
	sub_822E6488(ctx, base);
	// 822EA7F4: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 822EA7F8: D19F0174  stfs f12, 0x174(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 822EA7FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EA800: 396BC300  addi r11, r11, -0x3d00
	ctx.r[11].s64 = ctx.r[11].s64 + -15616;
	// 822EA804: C00AD560  lfs f0, -0x2aa0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA808: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822EA80C: D01F0170  stfs f0, 0x170(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 822EA810: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822EA814: 915F00D0  stw r10, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 822EA818: 4807C921  bl 0x82367138
	ctx.lr = 0x822EA81C;
	sub_82367138(ctx, base);
	// 822EA81C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EA820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EA824: 796B0260  clrldi r11, r11, 0x29
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000007FFFFFu64;
	// 822EA828: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822EA82C: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822EA830: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822EA834: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822EA838: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 822EA83C: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 822EA840: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EA844: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EA848: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EA84C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EA850: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EA858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EA858 size=712
    let mut pc: u32 = 0x822EA858;
    'dispatch: loop {
        match pc {
            0x822EA858 => {
    //   block [0x822EA858..0x822EAB0C)
	// 822EA858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EA85C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EA860: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EA864: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EA868: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EA86C: 4BFFBD4D  bl 0x822e65b8
	ctx.lr = 0x822EA870;
	sub_822E65B8(ctx, base);
	// 822EA870: 897F0087  lbz r11, 0x87(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(135 as u32) ) } as u64;
	// 822EA874: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 822EA878: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 822EA87C: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822EA880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EA884: 409A0288  bne cr6, 0x822eab0c
	if !ctx.cr[6].eq {
	pc = 0x822EAB0C; continue 'dispatch;
	}
	// 822EA888: 4807C8B1  bl 0x82367138
	ctx.lr = 0x822EA88C;
	sub_82367138(ctx, base);
	// 822EA88C: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EA890: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EA894: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 822EA898: C00B2280  lfs f0, 0x2280(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EA89C: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822EA8A0: C18B0040  lfs f12, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822EA8A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EA8A8: C1AB2048  lfs f13, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EA8AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EA8B0: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 822EA8B4: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822EA8B8: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822EA8BC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822EA8C0: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822EA8C4: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EA8C8: ED8C6838  fmsubs f12, f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822EA8CC: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822EA8D0: 4807C869  bl 0x82367138
	ctx.lr = 0x822EA8D4;
	sub_82367138(ctx, base);
	// 822EA8D4: 78680260  clrldi r8, r3, 0x29
	ctx.r[8].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EA8D8: 11A1038C  vspltisw v13, 1
	for i in 0..4 {
		ctx.v[13].u32[i] = 1;
	}
	// 822EA8DC: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822EA8E0: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822EA8E4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822EA8E8: 389F0130  addi r4, r31, 0x130
	ctx.r[4].s64 = ctx.r[31].s64 + 304;
	// 822EA8EC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 822EA8F0: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 822EA8F4: 10016B4A  vcfsx v0, v13, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[0].f32[i] = (ctx.v[13].s32[i] as f32) * scale;
	}
	// 822EA8F8: 11A06B4A  vcfsx v13, v13, 0
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[13].f32[i] = (ctx.v[13].s32[i] as f32) * scale;
	}
	// 822EA8FC: C1891FF8  lfs f12, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822EA900: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	pc = 0x822EAB0C; continue 'dispatch;
            }
            0x822EAB0C => {
    //   block [0x822EAB0C..0x822EAB20)
	// 822EAB0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EAB10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EAB14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EAB18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EAB1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EAB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EAB20 size=444
    let mut pc: u32 = 0x822EAB20;
    'dispatch: loop {
        match pc {
            0x822EAB20 => {
    //   block [0x822EAB20..0x822EAB88)
	// 822EAB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EAB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EAB28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EAB2C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EAB30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EAB34: 4BFFBC75  bl 0x822e67a8
	ctx.lr = 0x822EAB38;
	sub_822E67A8(ctx, base);
	// 822EAB38: 897F0087  lbz r11, 0x87(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(135 as u32) ) } as u64;
	// 822EAB3C: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 822EAB40: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 822EAB44: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822EAB48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EAB4C: 409A017C  bne cr6, 0x822eacc8
	if !ctx.cr[6].eq {
	pc = 0x822EACC8; continue 'dispatch;
	}
	// 822EAB50: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 822EAB54: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822EAB58: 394ADBD0  addi r10, r10, -0x2430
	ctx.r[10].s64 = ctx.r[10].s64 + -9264;
	// 822EAB5C: C04B0018  lfs f2, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822EAB60: C02B0010  lfs f1, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822EAB64: 892A0001  lbz r9, 1(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 822EAB68: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 822EAB6C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822EAB70: 40990018  ble cr6, 0x822eab88
	if !ctx.cr[6].gt {
	pc = 0x822EAB88; continue 'dispatch;
	}
	// 822EAB74: 896A0002  lbz r11, 2(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 822EAB78: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 822EAB7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822EAB80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822EAB84: 41990008  bgt cr6, 0x822eab8c
	if ctx.cr[6].gt {
	pc = 0x822EAB8C; continue 'dispatch;
	}
	pc = 0x822EAB88; continue 'dispatch;
            }
            0x822EAB88 => {
    //   block [0x822EAB88..0x822EAB8C)
	// 822EAB88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822EAB8C; continue 'dispatch;
            }
            0x822EAB8C => {
    //   block [0x822EAB8C..0x822EABA4)
	// 822EAB8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822EAB90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EAB94: 409A0010  bne cr6, 0x822eaba4
	if !ctx.cr[6].eq {
	pc = 0x822EABA4; continue 'dispatch;
	}
	// 822EAB98: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822EAB9C: 4BECC92D  bl 0x821b74c8
	ctx.lr = 0x822EABA0;
	sub_821B74C8(ctx, base);
	// 822EABA0: 48000018  b 0x822eabb8
	pc = 0x822EABB8; continue 'dispatch;
            }
            0x822EABA4 => {
    //   block [0x822EABA4..0x822EABB8)
	// 822EABA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822EABA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822EABAC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822EABB0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822EABB4: 4BECC97D  bl 0x821b7530
	ctx.lr = 0x822EABB8;
	sub_821B7530(ctx, base);
	pc = 0x822EABB8; continue 'dispatch;
            }
            0x822EABB8 => {
    //   block [0x822EABB8..0x822EACA8)
	// 822EABB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EABBC: C00B2190  lfs f0, 0x2190(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EABC0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 822EABC4: 409900E4  ble cr6, 0x822eaca8
	if !ctx.cr[6].gt {
	pc = 0x822EACA8; continue 'dispatch;
	}
	// 822EABC8: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822EABCC: C00B0040  lfs f0, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EABD0: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 822EABD4: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EABD8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822EABDC: 419800CC  blt cr6, 0x822eaca8
	if ctx.cr[6].lt {
	pc = 0x822EACA8; continue 'dispatch;
	}
	// 822EABE0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822EABE4: C01F0160  lfs f0, 0x160(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EABE8: C19F0108  lfs f12, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822EABEC: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 822EABF0: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EABF4: C15F0170  lfs f10, 0x170(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822EABF8: C0FF010C  lfs f7, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822EABFC: 612985D8  ori r9, r9, 0x85d8
	ctx.r[9].u64 = ctx.r[9].u64 | 34264;
	// 822EAC00: C1BF0104  lfs f13, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EAC04: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 822EAC08: C12A2178  lfs f9, 0x2178(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8568 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822EAC0C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822EAC10: C17F0100  lfs f11, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822EAC14: ED2A0272  fmuls f9, f10, f9
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[9].f64) as f32) as f64);
	// 822EAC18: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EAC1C: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 822EAC20: C10A22E4  lfs f8, 0x22e4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8932 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822EAC24: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 822EAC28: ED4A0232  fmuls f10, f10, f8
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[8].f64) as f32) as f64);
	// 822EAC2C: ED070032  fmuls f8, f7, f0
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EAC30: 394ABFF0  addi r10, r10, -0x4010
	ctx.r[10].s64 = ctx.r[10].s64 + -16400;
	// 822EAC34: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 822EAC38: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 822EAC3C: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 822EAC40: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 822EAC44: FCE04828  fsub f7, f0, f9
	ctx.f[7].f64 = ctx.f[0].f64 - ctx.f[9].f64;
	// 822EAC48: FC07482E  fsel f0, f7, f0, f9
	ctx.f[0].f64 = if ctx.f[7].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[9].f64 };
	// 822EAC4C: FD205028  fsub f9, f0, f10
	ctx.f[9].f64 = ctx.f[0].f64 - ctx.f[10].f64;
	// 822EAC50: FC0902AE  fsel f0, f9, f10, f0
	ctx.f[0].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[10].f64 } else { ctx.f[0].f64 };
	// 822EAC54: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822EAC58: D01F0170  stfs f0, 0x170(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 822EAC5C: 7C0A4C2E  lfsx f0, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EAC60: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822EAC64: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822EAC68: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 822EAC6C: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822EAC70: EDA00332  fmuls f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 822EAC74: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822EAC78: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EAC7C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822EAC80: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	pc = 0x822EACA8; continue 'dispatch;
            }
            0x822EACA8 => {
    //   block [0x822EACA8..0x822EACC8)
	// 822EACA8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 822EACAC: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 822EACB0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822EACB4: 409A0014  bne cr6, 0x822eacc8
	if !ctx.cr[6].eq {
	pc = 0x822EACC8; continue 'dispatch;
	}
	// 822EACB8: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 822EACBC: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 822EACC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822EACC4: 997F0025  stb r11, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	pc = 0x822EACC8; continue 'dispatch;
            }
            0x822EACC8 => {
    //   block [0x822EACC8..0x822EACDC)
	// 822EACC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822EACCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EACD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EACD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EACD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EACE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EACE0 size=96
    let mut pc: u32 = 0x822EACE0;
    'dispatch: loop {
        match pc {
            0x822EACE0 => {
    //   block [0x822EACE0..0x822EAD40)
	// 822EACE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EACE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EACE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EACEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EACF0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822EACF4: C1A30170  lfs f13, 0x170(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EACF8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 822EACFC: 83E300C4  lwz r31, 0xc4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 822EAD00: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 822EAD04: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 822EAD08: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EAD0C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EAD10: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EAD14: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EAD18: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EAD1C: 4BE6859D  bl 0x821532b8
	ctx.lr = 0x822EAD20;
	sub_821532B8(ctx, base);
	// 822EAD20: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EAD24: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 822EAD28: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822EAD2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822EAD30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EAD34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EAD38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EAD3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EAD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EAD40 size=104
    let mut pc: u32 = 0x822EAD40;
    'dispatch: loop {
        match pc {
            0x822EAD40 => {
    //   block [0x822EAD40..0x822EADA8)
	// 822EAD40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EAD44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EAD48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EAD4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EAD50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EAD54: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EAD58: C1BF0174  lfs f13, 0x174(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EAD5C: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EAD60: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EAD64: 4BE68555  bl 0x821532b8
	ctx.lr = 0x822EAD68;
	sub_821532B8(ctx, base);
	// 822EAD68: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822EAD6C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 822EAD70: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 822EAD74: D02B004C  stfs f1, 0x4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 822EAD78: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822EAD7C: C1BF0174  lfs f13, 0x174(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EAD80: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 822EAD84: C19F0170  lfs f12, 0x170(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822EAD88: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EAD8C: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 822EAD90: D01F0174  stfs f0, 0x174(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 822EAD94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822EAD98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EAD9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EADA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EADA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EADA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EADA8 size=92
    let mut pc: u32 = 0x822EADA8;
    'dispatch: loop {
        match pc {
            0x822EADA8 => {
    //   block [0x822EADA8..0x822EADF0)
	// 822EADA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EADAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EADB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EADB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EADB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EADBC: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 822EADC0: C01F00F8  lfs f0, 0xf8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EADC4: C1ABD564  lfs f13, -0x2a9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EADC8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822EADCC: 40980024  bge cr6, 0x822eadf0
	if !ctx.cr[6].lt {
	pc = 0x822EADF0; continue 'dispatch;
	}
	// 822EADD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EADD4: C1AB26C8  lfs f13, 0x26c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9928 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EADD8: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822EADDC: 4BE326ED  bl 0x8211d4c8
	ctx.lr = 0x822EADE0;
	sub_8211D4C8(ctx, base);
	// 822EADE0: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822EADE4: C01F012C  lfs f0, 0x12c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EADE8: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EADEC: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x822EADF0; continue 'dispatch;
            }
            0x822EADF0 => {
    //   block [0x822EADF0..0x822EAE04)
	// 822EADF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822EADF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EADF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EADFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EAE00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EAE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EAE08 size=312
    let mut pc: u32 = 0x822EAE08;
    'dispatch: loop {
        match pc {
            0x822EAE08 => {
    //   block [0x822EAE08..0x822EAF40)
	// 822EAE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EAE0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EAE10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822EAE14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EAE18: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EAE1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EAE20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822EAE24: 4807C315  bl 0x82367138
	ctx.lr = 0x822EAE28;
	sub_82367138(ctx, base);
	// 822EAE28: 78690260  clrldi r9, r3, 0x29
	ctx.r[9].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EAE2C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822EAE30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EAE34: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 822EAE38: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 822EAE3C: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 822EAE40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822EAE44: C06ABA38  lfs f3, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822EAE48: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 822EAE4C: C1AB21B4  lfs f13, 0x21b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8628 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EAE50: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822EAE54: 38CA3C50  addi r6, r10, 0x3c50
	ctx.r[6].s64 = ctx.r[10].s64 + 15440;
	// 822EAE58: D0610070  stfs f3, 0x70(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822EAE5C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822EAE60: D0610074  stfs f3, 0x74(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822EAE64: 396B16E8  addi r11, r11, 0x16e8
	ctx.r[11].s64 = ctx.r[11].s64 + 5864;
	// 822EAE68: D0610078  stfs f3, 0x78(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822EAE6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EAE70: 388B0720  addi r4, r11, 0x720
	ctx.r[4].s64 = ctx.r[11].s64 + 1824;
	// 822EAE74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EAE78: C00A25C4  lfs f0, 0x25c4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9668 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EAE7C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822EAE80: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822EAE84: C04B20F0  lfs f2, 0x20f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8432 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822EAE88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EAE8C: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EAE90: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822EAE94: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822EAE98: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822EAE9C: C18B2280  lfs f12, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822EAEA0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EAEA4: D066000C  stfs f3, 0xc(r6)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822EAEA8: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822EAEAC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822EAEB0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822EAEB4: ED600332  fmuls f11, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 822EAEB8: C00B24CC  lfs f0, 0x24cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9420 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EAEBC: EC2B037A  fmadds f1, f11, f13, f0
	ctx.f[1].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 822EAEC0: 4BFFB5C9  bl 0x822e6488
	ctx.lr = 0x822EAEC4;
	sub_822E6488(ctx, base);
	// 822EAEC4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EAEC8: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 822EAECC: 396BC340  addi r11, r11, -0x3cc0
	ctx.r[11].s64 = ctx.r[11].s64 + -15552;
	// 822EAED0: 915F00D0  stw r10, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 822EAED4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822EAED8: 4807C261  bl 0x82367138
	ctx.lr = 0x822EAEDC;
	sub_82367138(ctx, base);
	// 822EAEDC: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EAEE0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822EAEE4: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822EAEE8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822EAEEC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822EAEF0: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 822EAEF4: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 822EAEF8: C05E0008  lfs f2, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822EAEFC: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822EAF00: 4BECC961  bl 0x821b7860
	ctx.lr = 0x822EAF04;
	sub_821B7860(ctx, base);
	// 822EAF04: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822EAF08: C19F012C  lfs f12, 0x12c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822EAF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EAF10: C00BD468  lfs f0, -0x2b98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EAF14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EAF18: C1AB2B88  lfs f13, 0x2b88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EAF1C: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 822EAF20: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EAF24: D01F012C  stfs f0, 0x12c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 822EAF28: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822EAF2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EAF30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EAF34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822EAF38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EAF3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EAF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EAF40 size=744
    let mut pc: u32 = 0x822EAF40;
    'dispatch: loop {
        match pc {
            0x822EAF40 => {
    //   block [0x822EAF40..0x822EB214)
	// 822EAF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EAF44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EAF48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EAF4C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EAF50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EAF54: 4BFFB665  bl 0x822e65b8
	ctx.lr = 0x822EAF58;
	sub_822E65B8(ctx, base);
	// 822EAF58: 897F0087  lbz r11, 0x87(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(135 as u32) ) } as u64;
	// 822EAF5C: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 822EAF60: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 822EAF64: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822EAF68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EAF6C: 409A02A8  bne cr6, 0x822eb214
	if !ctx.cr[6].eq {
	pc = 0x822EB214; continue 'dispatch;
	}
	// 822EAF70: 4807C1C9  bl 0x82367138
	ctx.lr = 0x822EAF74;
	sub_82367138(ctx, base);
	// 822EAF74: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EAF78: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EAF7C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 822EAF80: C00B2280  lfs f0, 0x2280(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EAF84: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822EAF88: C18B0040  lfs f12, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822EAF8C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EAF90: C1AB2048  lfs f13, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EAF94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EAF98: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 822EAF9C: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822EAFA0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822EAFA4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822EAFA8: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822EAFAC: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EAFB0: ED8C6838  fmsubs f12, f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822EAFB4: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822EAFB8: 4807C181  bl 0x82367138
	ctx.lr = 0x822EAFBC;
	sub_82367138(ctx, base);
	// 822EAFBC: 78680260  clrldi r8, r3, 0x29
	ctx.r[8].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EAFC0: 11A1038C  vspltisw v13, 1
	for i in 0..4 {
		ctx.v[13].u32[i] = 1;
	}
	// 822EAFC4: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822EAFC8: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822EAFCC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822EAFD0: 389F0130  addi r4, r31, 0x130
	ctx.r[4].s64 = ctx.r[31].s64 + 304;
	// 822EAFD4: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 822EAFD8: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 822EAFDC: 10016B4A  vcfsx v0, v13, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[0].f32[i] = (ctx.v[13].s32[i] as f32) * scale;
	}
	// 822EAFE0: 11A06B4A  vcfsx v13, v13, 0
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[13].f32[i] = (ctx.v[13].s32[i] as f32) * scale;
	}
	// 822EAFE4: C1891FF8  lfs f12, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822EAFE8: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	pc = 0x822EB214; continue 'dispatch;
            }
            0x822EB214 => {
    //   block [0x822EB214..0x822EB228)
	// 822EB214: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EB218: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EB21C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EB220: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EB224: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EB228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EB228 size=608
    let mut pc: u32 = 0x822EB228;
    'dispatch: loop {
        match pc {
            0x822EB228 => {
    //   block [0x822EB228..0x822EB488)
	// 822EB228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EB22C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EB230: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EB234: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EB238: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EB23C: FD401090  fmr f10, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = ctx.f[2].f64;
	// 822EB240: 4807BEF9  bl 0x82367138
	ctx.lr = 0x822EB244;
	sub_82367138(ctx, base);
	// 822EB244: 78690260  clrldi r9, r3, 0x29
	ctx.r[9].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EB248: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822EB24C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB250: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822EB254: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 822EB258: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 822EB25C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 822EB260: C1AA20B4  lfs f13, 0x20b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8372 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EB264: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 822EB268: C12B26C4  lfs f9, 0x26c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9924 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822EB26C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822EB270: 38CA3C50  addi r6, r10, 0x3c50
	ctx.r[6].s64 = ctx.r[10].s64 + 15440;
	// 822EB274: ED616828  fsubs f11, f1, f13
	ctx.f[11].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 822EB278: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822EB27C: 396B16E8  addi r11, r11, 0x16e8
	ctx.r[11].s64 = ctx.r[11].s64 + 5864;
	// 822EB280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EB284: 388B0738  addi r4, r11, 0x738
	ctx.r[4].s64 = ctx.r[11].s64 + 1848;
	// 822EB288: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822EB28C: C00A207C  lfs f0, 0x207c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EB290: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 822EB294: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822EB298: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822EB29C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822EB2A0: C06BBA38  lfs f3, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822EB2A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB2A8: C00A9F78  lfs f0, -0x6088(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EB2AC: FDAB0B6E  fsel f13, f11, f13, f1
	ctx.f[13].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[1].f64 };
	// 822EB2B0: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822EB2B4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822EB2B8: C04B2108  lfs f2, 0x2108(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8456 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822EB2BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB2C0: C18A1FF8  lfs f12, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822EB2C4: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822EB2C8: D1860004  stfs f12, 4(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822EB2CC: C16B2280  lfs f11, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822EB2D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB2D4: D1860008  stfs f12, 8(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822EB2D8: D066000C  stfs f3, 0xc(r6)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822EB2DC: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822EB2E0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822EB2E4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822EB2E8: ED0002F2  fmuls f8, f0, f11
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 822EB2EC: C00B24CC  lfs f0, 0x24cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9420 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EB2F0: EC08027A  fmadds f0, f8, f9, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 822EB2F4: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EB2F8: 4BFFB191  bl 0x822e6488
	ctx.lr = 0x822EB2FC;
	sub_822E6488(ctx, base);
	// 822EB2FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB300: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 822EB304: 396BC380  addi r11, r11, -0x3c80
	ctx.r[11].s64 = ctx.r[11].s64 + -15488;
	// 822EB308: 915F00D0  stw r10, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 822EB30C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822EB310: 4807BE29  bl 0x82367138
	ctx.lr = 0x822EB314;
	sub_82367138(ctx, base);
	// 822EB314: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB318: D1810070  stfs f12, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822EB31C: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822EB320: 389F0130  addi r4, r31, 0x130
	ctx.r[4].s64 = ctx.r[31].s64 + 304;
	// 822EB324: D181007C  stfs f12, 0x7c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822EB328: C00BD6C8  lfs f0, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EB32C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EB330: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822EB334: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822EB338: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822EB33C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822EB340: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822EB344: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 822EB348: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 822EB34C: 4807BDED  bl 0x82367138
	ctx.lr = 0x822EB350;
	sub_82367138(ctx, base);
	// 822EB350: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EB354: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822EB358: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB35C: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822EB360: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822EB364: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822EB368: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EB36C: EDAD02F8  fmsubs f13, f13, f11, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 822EB370: D1BF0130  stfs f13, 0x130(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 822EB374: 4807BDC5  bl 0x82367138
	ctx.lr = 0x822EB378;
	sub_82367138(ctx, base);
	// 822EB378: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EB37C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822EB380: C9A10060  lfd f13, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822EB384: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822EB388: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822EB38C: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 822EB390: D1BF0134  stfs f13, 0x134(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 822EB394: 4807BDA5  bl 0x82367138
	ctx.lr = 0x822EB398;
	sub_82367138(ctx, base);
	// 822EB398: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EB39C: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 822EB3A0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822EB3A4: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 822EB3A8: 1160034A  vcfsx v11, v0, 0
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[11].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EB488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EB488 size=428
    let mut pc: u32 = 0x822EB488;
    'dispatch: loop {
        match pc {
            0x822EB488 => {
    //   block [0x822EB488..0x822EB620)
	// 822EB488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EB48C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EB490: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EB494: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EB498: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EB49C: 4BFFB11D  bl 0x822e65b8
	ctx.lr = 0x822EB4A0;
	sub_822E65B8(ctx, base);
	// 822EB4A0: 897F0087  lbz r11, 0x87(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(135 as u32) ) } as u64;
	// 822EB4A4: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 822EB4A8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 822EB4AC: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822EB4B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EB4B4: 409A016C  bne cr6, 0x822eb620
	if !ctx.cr[6].eq {
	pc = 0x822EB620; continue 'dispatch;
	}
	// 822EB4B8: 4807BC81  bl 0x82367138
	ctx.lr = 0x822EB4BC;
	sub_82367138(ctx, base);
	// 822EB4BC: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EB4C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB4C4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 822EB4C8: C00B2280  lfs f0, 0x2280(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EB4CC: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822EB4D0: C18B0040  lfs f12, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822EB4D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB4D8: C1AB2048  lfs f13, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EB4DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB4E0: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 822EB4E4: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822EB4E8: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822EB4EC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822EB4F0: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822EB4F4: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EB4F8: ED8C6838  fmsubs f12, f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822EB4FC: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822EB500: 4807BC39  bl 0x82367138
	ctx.lr = 0x822EB504;
	sub_82367138(ctx, base);
	// 822EB504: 78690260  clrldi r9, r3, 0x29
	ctx.r[9].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EB508: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 822EB50C: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822EB510: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822EB514: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 822EB518: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 822EB51C: 11A1034A  vcfsx v13, v0, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[13].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 822EB520: 1180034A  vcfsx v12, v0, 0
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[12].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	pc = 0x822EB620; continue 'dispatch;
            }
            0x822EB620 => {
    //   block [0x822EB620..0x822EB634)
	// 822EB620: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822EB624: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EB628: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EB62C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EB630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EB638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EB638 size=124
    let mut pc: u32 = 0x822EB638;
    'dispatch: loop {
        match pc {
            0x822EB638 => {
    //   block [0x822EB638..0x822EB668)
	// 822EB638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EB63C: 48249A79  bl 0x825350b4
	ctx.lr = 0x822EB640;
	sub_82535080(ctx, base);
	// 822EB640: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EB644: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822EB648: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822EB64C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822EB650: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822EB654: 40990058  ble cr6, 0x822eb6ac
	if !ctx.cr[6].gt {
	pc = 0x822EB6AC; continue 'dispatch;
	}
	// 822EB658: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822EB65C: 3BEBC470  addi r31, r11, -0x3b90
	ctx.r[31].s64 = ctx.r[11].s64 + -15248;
	// 822EB660: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB664: 3BCBC188  addi r30, r11, -0x3e78
	ctx.r[30].s64 = ctx.r[11].s64 + -15992;
	pc = 0x822EB668; continue 'dispatch;
            }
            0x822EB668 => {
    //   block [0x822EB668..0x822EB6A0)
	// 822EB668: 4BFFB7B9  bl 0x822e6e20
	ctx.lr = 0x822EB66C;
	sub_822E6E20(ctx, base);
	// 822EB66C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822EB670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EB674: 419A0038  beq cr6, 0x822eb6ac
	if ctx.cr[6].eq {
	pc = 0x822EB6AC; continue 'dispatch;
	}
	// 822EB678: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 822EB67C: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822EB680: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 822EB684: 38A01385  li r5, 0x1385
	ctx.r[5].s64 = 4997;
	// 822EB688: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 822EB68C: 4807EE05  bl 0x8236a490
	ctx.lr = 0x822EB690;
	sub_8236A490(ctx, base);
	// 822EB690: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EB694: 419A000C  beq cr6, 0x822eb6a0
	if ctx.cr[6].eq {
	pc = 0x822EB6A0; continue 'dispatch;
	}
	// 822EB698: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822EB69C: 4BFFF08D  bl 0x822ea728
	ctx.lr = 0x822EB6A0;
	sub_822EA728(ctx, base);
	pc = 0x822EB6A0; continue 'dispatch;
            }
            0x822EB6A0 => {
    //   block [0x822EB6A0..0x822EB6AC)
	// 822EB6A0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822EB6A4: 7F1DE000  cmpw cr6, r29, r28
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[28].s32, &mut ctx.xer);
	// 822EB6A8: 4198FFC0  blt cr6, 0x822eb668
	if ctx.cr[6].lt {
	pc = 0x822EB668; continue 'dispatch;
	}
	pc = 0x822EB6AC; continue 'dispatch;
            }
            0x822EB6AC => {
    //   block [0x822EB6AC..0x822EB6B4)
	// 822EB6AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822EB6B0: 48249A54  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EB6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EB6B8 size=124
    let mut pc: u32 = 0x822EB6B8;
    'dispatch: loop {
        match pc {
            0x822EB6B8 => {
    //   block [0x822EB6B8..0x822EB6E8)
	// 822EB6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EB6BC: 482499F9  bl 0x825350b4
	ctx.lr = 0x822EB6C0;
	sub_82535080(ctx, base);
	// 822EB6C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EB6C4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822EB6C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822EB6CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822EB6D0: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822EB6D4: 40990058  ble cr6, 0x822eb72c
	if !ctx.cr[6].gt {
	pc = 0x822EB72C; continue 'dispatch;
	}
	// 822EB6D8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822EB6DC: 3BEBC470  addi r31, r11, -0x3b90
	ctx.r[31].s64 = ctx.r[11].s64 + -15248;
	// 822EB6E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB6E4: 3BCBC188  addi r30, r11, -0x3e78
	ctx.r[30].s64 = ctx.r[11].s64 + -15992;
	pc = 0x822EB6E8; continue 'dispatch;
            }
            0x822EB6E8 => {
    //   block [0x822EB6E8..0x822EB720)
	// 822EB6E8: 4BFFB739  bl 0x822e6e20
	ctx.lr = 0x822EB6EC;
	sub_822E6E20(ctx, base);
	// 822EB6EC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822EB6F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EB6F4: 419A0038  beq cr6, 0x822eb72c
	if ctx.cr[6].eq {
	pc = 0x822EB72C; continue 'dispatch;
	}
	// 822EB6F8: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 822EB6FC: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822EB700: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 822EB704: 38A01385  li r5, 0x1385
	ctx.r[5].s64 = 4997;
	// 822EB708: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 822EB70C: 4807ED85  bl 0x8236a490
	ctx.lr = 0x822EB710;
	sub_8236A490(ctx, base);
	// 822EB710: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EB714: 419A000C  beq cr6, 0x822eb720
	if ctx.cr[6].eq {
	pc = 0x822EB720; continue 'dispatch;
	}
	// 822EB718: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822EB71C: 4BFFF6ED  bl 0x822eae08
	ctx.lr = 0x822EB720;
	sub_822EAE08(ctx, base);
	pc = 0x822EB720; continue 'dispatch;
            }
            0x822EB720 => {
    //   block [0x822EB720..0x822EB72C)
	// 822EB720: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822EB724: 7F1DE000  cmpw cr6, r29, r28
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[28].s32, &mut ctx.xer);
	// 822EB728: 4198FFC0  blt cr6, 0x822eb6e8
	if ctx.cr[6].lt {
	pc = 0x822EB6E8; continue 'dispatch;
	}
	pc = 0x822EB72C; continue 'dispatch;
            }
            0x822EB72C => {
    //   block [0x822EB72C..0x822EB734)
	// 822EB72C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822EB730: 482499D4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EB738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EB738 size=224
    let mut pc: u32 = 0x822EB738;
    'dispatch: loop {
        match pc {
            0x822EB738 => {
    //   block [0x822EB738..0x822EB7CC)
	// 822EB738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EB73C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EB740: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822EB744: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EB748: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EB74C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822EB750: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EB754: 616B9C00  ori r11, r11, 0x9c00
	ctx.r[11].u64 = ctx.r[11].u64 | 39936;
	// 822EB758: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822EB75C: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EB760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EB764: 419A009C  beq cr6, 0x822eb800
	if ctx.cr[6].eq {
	pc = 0x822EB800; continue 'dispatch;
	}
	// 822EB768: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822EB76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EB770: 419A0090  beq cr6, 0x822eb800
	if ctx.cr[6].eq {
	pc = 0x822EB800; continue 'dispatch;
	}
	// 822EB774: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822EB778: 616BEB2B  ori r11, r11, 0xeb2b
	ctx.r[11].u64 = ctx.r[11].u64 | 60203;
	// 822EB77C: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EB780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EB784: 409A007C  bne cr6, 0x822eb800
	if !ctx.cr[6].eq {
	pc = 0x822EB800; continue 'dispatch;
	}
	// 822EB788: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822EB78C: A16BBAC4  lhz r11, -0x453c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-17724 as u32) ) } as u64;
	// 822EB790: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 822EB794: 41980038  blt cr6, 0x822eb7cc
	if ctx.cr[6].lt {
	pc = 0x822EB7CC; continue 'dispatch;
	}
	// 822EB798: 4807B9A1  bl 0x82367138
	ctx.lr = 0x822EB79C;
	sub_82367138(ctx, base);
	// 822EB79C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EB7A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822EB7A4: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822EB7A8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822EB7AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB7B0: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822EB7B4: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EB7B8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822EB7BC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EB7C0: C00BD218  lfs f0, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EB7C4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822EB7C8: 40980038  bge cr6, 0x822eb800
	if !ctx.cr[6].lt {
	pc = 0x822EB800; continue 'dispatch;
	}
	pc = 0x822EB7CC; continue 'dispatch;
            }
            0x822EB7CC => {
    //   block [0x822EB7CC..0x822EB800)
	// 822EB7CC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822EB7D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EB7D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822EB7D8: 4BFFA631  bl 0x822e5e08
	ctx.lr = 0x822EB7DC;
	sub_822E5E08(ctx, base);
	// 822EB7DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EB7E0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822EB7E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822EB7E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822EB7EC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822EB7F0: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 822EB7F4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822EB7F8: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822EB7FC: 4BFFFE3D  bl 0x822eb638
	ctx.lr = 0x822EB800;
	sub_822EB638(ctx, base);
	pc = 0x822EB800; continue 'dispatch;
            }
            0x822EB800 => {
    //   block [0x822EB800..0x822EB818)
	// 822EB800: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EB804: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EB808: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EB80C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822EB810: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EB814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EB818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EB818 size=224
    let mut pc: u32 = 0x822EB818;
    'dispatch: loop {
        match pc {
            0x822EB818 => {
    //   block [0x822EB818..0x822EB8AC)
	// 822EB818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EB81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EB820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822EB824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EB828: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EB82C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822EB830: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EB834: 616B9C00  ori r11, r11, 0x9c00
	ctx.r[11].u64 = ctx.r[11].u64 | 39936;
	// 822EB838: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822EB83C: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EB840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EB844: 419A009C  beq cr6, 0x822eb8e0
	if ctx.cr[6].eq {
	pc = 0x822EB8E0; continue 'dispatch;
	}
	// 822EB848: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822EB84C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EB850: 419A0090  beq cr6, 0x822eb8e0
	if ctx.cr[6].eq {
	pc = 0x822EB8E0; continue 'dispatch;
	}
	// 822EB854: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822EB858: 616BEB2B  ori r11, r11, 0xeb2b
	ctx.r[11].u64 = ctx.r[11].u64 | 60203;
	// 822EB85C: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EB860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EB864: 409A007C  bne cr6, 0x822eb8e0
	if !ctx.cr[6].eq {
	pc = 0x822EB8E0; continue 'dispatch;
	}
	// 822EB868: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822EB86C: A16BBAC4  lhz r11, -0x453c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-17724 as u32) ) } as u64;
	// 822EB870: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 822EB874: 41980038  blt cr6, 0x822eb8ac
	if ctx.cr[6].lt {
	pc = 0x822EB8AC; continue 'dispatch;
	}
	// 822EB878: 4807B8C1  bl 0x82367138
	ctx.lr = 0x822EB87C;
	sub_82367138(ctx, base);
	// 822EB87C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EB880: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822EB884: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822EB888: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822EB88C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB890: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822EB894: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EB898: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822EB89C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EB8A0: C00BD218  lfs f0, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EB8A4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822EB8A8: 40980038  bge cr6, 0x822eb8e0
	if !ctx.cr[6].lt {
	pc = 0x822EB8E0; continue 'dispatch;
	}
	pc = 0x822EB8AC; continue 'dispatch;
            }
            0x822EB8AC => {
    //   block [0x822EB8AC..0x822EB8E0)
	// 822EB8AC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822EB8B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EB8B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822EB8B8: 4BFFA551  bl 0x822e5e08
	ctx.lr = 0x822EB8BC;
	sub_822E5E08(ctx, base);
	// 822EB8BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EB8C0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822EB8C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822EB8C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822EB8CC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822EB8D0: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 822EB8D4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822EB8D8: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822EB8DC: 4BFFFDDD  bl 0x822eb6b8
	ctx.lr = 0x822EB8E0;
	sub_822EB6B8(ctx, base);
	pc = 0x822EB8E0; continue 'dispatch;
            }
            0x822EB8E0 => {
    //   block [0x822EB8E0..0x822EB8F8)
	// 822EB8E0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EB8E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EB8E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EB8EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822EB8F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EB8F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EB8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EB8F8 size=304
    let mut pc: u32 = 0x822EB8F8;
    'dispatch: loop {
        match pc {
            0x822EB8F8 => {
    //   block [0x822EB8F8..0x822EB988)
	// 822EB8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EB8FC: 482497BD  bl 0x825350b8
	ctx.lr = 0x822EB900;
	sub_82535080(ctx, base);
	// 822EB900: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822EB904: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EB908: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822EB90C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EB910: 616B9C00  ori r11, r11, 0x9c00
	ctx.r[11].u64 = ctx.r[11].u64 | 39936;
	// 822EB914: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822EB918: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EB91C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EB920: 419A00FC  beq cr6, 0x822eba1c
	if ctx.cr[6].eq {
	pc = 0x822EBA1C; continue 'dispatch;
	}
	// 822EB924: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822EB928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EB92C: 419A00F0  beq cr6, 0x822eba1c
	if ctx.cr[6].eq {
	pc = 0x822EBA1C; continue 'dispatch;
	}
	// 822EB930: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822EB934: 616BEB2B  ori r11, r11, 0xeb2b
	ctx.r[11].u64 = ctx.r[11].u64 | 60203;
	// 822EB938: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EB93C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EB940: 409A00DC  bne cr6, 0x822eba1c
	if !ctx.cr[6].eq {
	pc = 0x822EBA1C; continue 'dispatch;
	}
	// 822EB944: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822EB948: A16BBAC4  lhz r11, -0x453c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-17724 as u32) ) } as u64;
	// 822EB94C: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 822EB950: 41980038  blt cr6, 0x822eb988
	if ctx.cr[6].lt {
	pc = 0x822EB988; continue 'dispatch;
	}
	// 822EB954: 4807B7E5  bl 0x82367138
	ctx.lr = 0x822EB958;
	sub_82367138(ctx, base);
	// 822EB958: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 822EB95C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822EB960: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822EB964: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822EB968: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB96C: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822EB970: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EB974: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822EB978: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EB97C: C00BD218  lfs f0, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EB980: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822EB984: 40980098  bge cr6, 0x822eba1c
	if !ctx.cr[6].lt {
	pc = 0x822EBA1C; continue 'dispatch;
	}
	pc = 0x822EB988; continue 'dispatch;
            }
            0x822EB988 => {
    //   block [0x822EB988..0x822EB9D0)
	// 822EB988: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822EB98C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EB990: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822EB994: 4BFFA475  bl 0x822e5e08
	ctx.lr = 0x822EB998;
	sub_822E5E08(ctx, base);
	// 822EB998: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822EB99C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822EB9A0: E9230008  ld r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 822EB9A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822EB9A8: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822EB9AC: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 822EB9B0: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 822EB9B4: 40990068  ble cr6, 0x822eba1c
	if !ctx.cr[6].gt {
	pc = 0x822EBA1C; continue 'dispatch;
	}
	// 822EB9B8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822EB9BC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822EB9C0: 3BEBC470  addi r31, r11, -0x3b90
	ctx.r[31].s64 = ctx.r[11].s64 + -15248;
	// 822EB9C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EB9C8: 3BCBC188  addi r30, r11, -0x3e78
	ctx.r[30].s64 = ctx.r[11].s64 + -15992;
	// 822EB9CC: C3EABA38  lfs f31, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x822EB9D0; continue 'dispatch;
            }
            0x822EB9D0 => {
    //   block [0x822EB9D0..0x822EBA10)
	// 822EB9D0: 4BFFB451  bl 0x822e6e20
	ctx.lr = 0x822EB9D4;
	sub_822E6E20(ctx, base);
	// 822EB9D4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822EB9D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EB9DC: 419A0040  beq cr6, 0x822eba1c
	if ctx.cr[6].eq {
	pc = 0x822EBA1C; continue 'dispatch;
	}
	// 822EB9E0: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 822EB9E4: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822EB9E8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 822EB9EC: 38A01385  li r5, 0x1385
	ctx.r[5].s64 = 4997;
	// 822EB9F0: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 822EB9F4: 4807EA9D  bl 0x8236a490
	ctx.lr = 0x822EB9F8;
	sub_8236A490(ctx, base);
	// 822EB9F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EB9FC: 419A0014  beq cr6, 0x822eba10
	if ctx.cr[6].eq {
	pc = 0x822EBA10; continue 'dispatch;
	}
	// 822EBA00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822EBA04: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 822EBA08: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822EBA0C: 4BFFF81D  bl 0x822eb228
	ctx.lr = 0x822EBA10;
	sub_822EB228(ctx, base);
	pc = 0x822EBA10; continue 'dispatch;
            }
            0x822EBA10 => {
    //   block [0x822EBA10..0x822EBA1C)
	// 822EBA10: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822EBA14: 7F1DE000  cmpw cr6, r29, r28
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[28].s32, &mut ctx.xer);
	// 822EBA18: 4198FFB8  blt cr6, 0x822eb9d0
	if ctx.cr[6].lt {
	pc = 0x822EB9D0; continue 'dispatch;
	}
	pc = 0x822EBA1C; continue 'dispatch;
            }
            0x822EBA1C => {
    //   block [0x822EBA1C..0x822EBA28)
	// 822EBA1C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822EBA20: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822EBA24: 482496E4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EBA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822EBA28 size=24
    let mut pc: u32 = 0x822EBA28;
    'dispatch: loop {
        match pc {
            0x822EBA28 => {
    //   block [0x822EBA28..0x822EBA40)
	// 822EBA28: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822EBA2C: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822EBA30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EBA34: 409A000C  bne cr6, 0x822eba40
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x822EBA40);
		return;
	}
	// 822EBA38: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 822EBA3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EBA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EBA48 size=1024
    let mut pc: u32 = 0x822EBA48;
    'dispatch: loop {
        match pc {
            0x822EBA48 => {
    //   block [0x822EBA48..0x822EBA94)
	// 822EBA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EBA4C: 48249635  bl 0x82535080
	ctx.lr = 0x822EBA50;
	sub_82535080(ctx, base);
	// 822EBA50: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 822EBA54: 4824A589  bl 0x82535fdc
	ctx.lr = 0x822EBA58;
	sub_82535FB0(ctx, base);
	// 822EBA58: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EBA5C: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EBA60: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 822EBA64: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 822EBA68: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 822EBA6C: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 822EBA70: 7D2F4B78  mr r15, r9
	ctx.r[15].u64 = ctx.r[9].u64;
	// 822EBA74: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822EBA78: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EBA7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EBA80: 419A0014  beq cr6, 0x822eba94
	if ctx.cr[6].eq {
	pc = 0x822EBA94; continue 'dispatch;
	}
	// 822EBA84: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822EBA88: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EBA8C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822EBA90: 419A000C  beq cr6, 0x822eba9c
	if ctx.cr[6].eq {
	pc = 0x822EBA9C; continue 'dispatch;
	}
	pc = 0x822EBA94; continue 'dispatch;
            }
            0x822EBA94 => {
    //   block [0x822EBA94..0x822EBA9C)
	// 822EBA94: 7F6EDB78  mr r14, r27
	ctx.r[14].u64 = ctx.r[27].u64;
	// 822EBA98: 48000008  b 0x822ebaa0
	pc = 0x822EBAA0; continue 'dispatch;
            }
            0x822EBA9C => {
    //   block [0x822EBA9C..0x822EBAA0)
	// 822EBA9C: 7D6E5B78  mr r14, r11
	ctx.r[14].u64 = ctx.r[11].u64;
	pc = 0x822EBAA0; continue 'dispatch;
            }
            0x822EBAA0 => {
    //   block [0x822EBAA0..0x822EBB04)
	// 822EBAA0: A1650004  lhz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EBAA4: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 822EBAA8: A3450006  lhz r26, 6(r5)
	ctx.r[26].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(6 as u32) ) } as u64;
	// 822EBAAC: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 822EBAB0: 419A0380  beq cr6, 0x822ebe30
	if ctx.cr[6].eq {
	pc = 0x822EBE30; continue 'dispatch;
	}
	// 822EBAB4: 7F841850  subf r28, r4, r3
	ctx.r[28].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	// 822EBAB8: 806E000C  lwz r3, 0xc(r14)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(12 as u32) ) } as u64;
	// 822EBABC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 822EBAC0: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822EBAC4: 4099036C  ble cr6, 0x822ebe30
	if !ctx.cr[6].gt {
	pc = 0x822EBE30; continue 'dispatch;
	}
	// 822EBAC8: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EBACC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822EBAD0: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 822EBAD4: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EBAD8: 38AB0080  addi r5, r11, 0x80
	ctx.r[5].s64 = ctx.r[11].s64 + 128;
	// 822EBADC: 48091E65  bl 0x8237d940
	ctx.lr = 0x822EBAE0;
	sub_8237D940(ctx, base);
	// 822EBAE0: 7C701B78  mr r16, r3
	ctx.r[16].u64 = ctx.r[3].u64;
	// 822EBAE4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822EBAE8: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 822EBAEC: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 822EBAF0: 3BEB0080  addi r31, r11, 0x80
	ctx.r[31].s64 = ctx.r[11].s64 + 128;
	// 822EBAF4: FB700000  std r27, 0(r16)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 822EBAF8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822EBAFC: FB700008  std r27, 8(r16)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[16].u32.wrapping_add(8 as u32), ctx.r[27].u64 ) };
	// 822EBB00: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x822EBB04; continue 'dispatch;
            }
            0x822EBB04 => {
    //   block [0x822EBB04..0x822EBB54)
	// 822EBB04: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 822EBB08: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822EBB0C: 4200FFF8  bdnz 0x822ebb04
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822EBB04; continue 'dispatch;
	}
	// 822EBB10: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822EBB14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EBB18: C38A1FF8  lfs f28, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 822EBB1C: 419A0038  beq cr6, 0x822ebb54
	if ctx.cr[6].eq {
	pc = 0x822EBB54; continue 'dispatch;
	}
	// 822EBB20: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822EBB24: 81560004  lwz r10, 4(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EBB28: D38B0070  stfs f28, 0x70(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822EBB2C: 936B001C  stw r27, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 822EBB30: 3929C3C0  addi r9, r9, -0x3c40
	ctx.r[9].s64 = ctx.r[9].s64 + -15424;
	// 822EBB34: D38B0074  stfs f28, 0x74(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822EBB38: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 822EBB3C: 936B0020  stw r27, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[27].u32 ) };
	// 822EBB40: 93EB0024  stw r31, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 822EBB44: 936B0078  stw r27, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 822EBB48: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822EBB4C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822EBB50: 48000008  b 0x822ebb58
	pc = 0x822EBB58; continue 'dispatch;
            }
            0x822EBB54 => {
    //   block [0x822EBB54..0x822EBB58)
	// 822EBB54: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	pc = 0x822EBB58; continue 'dispatch;
            }
            0x822EBB58 => {
    //   block [0x822EBB58..0x822EBBAC)
	// 822EBB58: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822EBB5C: B3500002  sth r26, 2(r16)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[16].u32.wrapping_add(2 as u32), ctx.r[26].u16 ) };
	// 822EBB60: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822EBB64: 93B00004  stw r29, 4(r16)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822EBB68: 3A800010  li r20, 0x10
	ctx.r[20].s64 = 16;
	// 822EBB6C: B1500000  sth r10, 0(r16)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 822EBB70: 409A003C  bne cr6, 0x822ebbac
	if !ctx.cr[6].eq {
	pc = 0x822EBBAC; continue 'dispatch;
	}
	// 822EBB74: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 822EBB78: 397D0030  addi r11, r29, 0x30
	ctx.r[11].s64 = ctx.r[29].s64 + 48;
	// 822EBB7C: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 822EBB80: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 822EBB84: 3D403F80  lis r10, 0x3f80
	ctx.r[10].s64 = 1065353216;
	pc = 0x822EBBAC; continue 'dispatch;
            }
            0x822EBBAC => {
    //   block [0x822EBBAC..0x822EBE30)
	// 822EBBAC: 395D0030  addi r10, r29, 0x30
	ctx.r[10].s64 = ctx.r[29].s64 + 48;
	// 822EBBB0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822EBBB4: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 822EBBB8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822EBBBC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822EBBC0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822EBBC4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822EBBC8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822EBBCC: 4200FFF0  bdnz 0x822ebbbc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822EBBBC; continue 'dispatch;
	}
	// 822EBBD0: 83360000  lwz r25, 0(r22)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EBBD4: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 822EBBD8: 81760010  lwz r11, 0x10(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 822EBBDC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822EBBE0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822EBBE4: 83D6001C  lwz r30, 0x1c(r22)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28 as u32) ) } as u64;
	// 822EBBE8: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 822EBBEC: 5571E73E  rlwinm r17, r11, 0x1c, 0x1c, 0x1f
	ctx.r[17].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 822EBBF0: 480AEDF9  bl 0x8239a9e8
	ctx.lr = 0x822EBBF4;
	sub_8239A9E8(ctx, base);
	// 822EBBF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EBBF8: 419A0238  beq cr6, 0x822ebe30
	if ctx.cr[6].eq {
	pc = 0x822EBE30; continue 'dispatch;
	}
	// 822EBBFC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822EBC00: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822EBC04: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822EBC08: 81160020  lwz r8, 0x20(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(32 as u32) ) } as u64;
	// 822EBC0C: 8156000C  lwz r10, 0xc(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) } as u64;
	// 822EBC10: 61080020  ori r8, r8, 0x20
	ctx.r[8].u64 = ctx.r[8].u64 | 32;
	// 822EBC14: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822EBC18: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822EBC1C: F9210070  std r9, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u64 ) };
	// 822EBC20: C9A10070  lfd f13, 0x70(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 822EBC24: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822EBC28: 69170200  xori r23, r8, 0x200
	ctx.r[23].u64 = ctx.r[8].u64 ^ 512;
	// 822EBC2C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822EBC30: FFC00018  frsp f30, f0
	ctx.f[30].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822EBC34: FFA06818  frsp f29, f13
	ctx.f[29].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822EBC38: 419A0008  beq cr6, 0x822ebc40
	if ctx.cr[6].eq {
	pc = 0x822EBC40; continue 'dispatch;
	}
	// 822EBC3C: 62F74000  ori r23, r23, 0x4000
	ctx.r[23].u64 = ctx.r[23].u64 | 16384;
	// 822EBC40: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EBC44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822EBC48: 419A0008  beq cr6, 0x822ebc50
	if ctx.cr[6].eq {
	pc = 0x822EBC50; continue 'dispatch;
	}
	// 822EBC4C: 7D77BB78  or r23, r11, r23
	ctx.r[23].u64 = ctx.r[11].u64 | ctx.r[23].u64;
	// 822EBC50: 7F9307B4  extsw r19, r28
	ctx.r[19].s64 = ctx.r[28].s32 as i64;
	// 822EBC54: 2B330000  cmpldi cr6, r19, 0
	ctx.cr[6].compare_u64(ctx.r[19].u64, 0, &mut ctx.xer);
	// 822EBC58: 409901D8  ble cr6, 0x822ebe30
	if !ctx.cr[6].gt {
	pc = 0x822EBE30; continue 'dispatch;
	}
	// 822EBC5C: 5552003E  slwi r18, r10, 0
	ctx.r[18].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[18].u64 = ctx.r[18].u32 as u64;
	// 822EBC60: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822EBC64: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 822EBC68: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822EBC6C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822EBC70: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822EBC74: 3BD80010  addi r30, r24, 0x10
	ctx.r[30].s64 = ctx.r[24].s64 + 16;
	// 822EBC78: C3E8BA38  lfs f31, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822EBC7C: 3B000040  li r24, 0x40
	ctx.r[24].s64 = 64;
	// 822EBC80: C3492034  lfs f26, 0x2034(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8244 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 822EBC84: C32A2030  lfs f25, 0x2030(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8240 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 822EBC88: 82ABB9B4  lwz r21, -0x464c(r11)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17996 as u32) ) } as u64;
	// 822EBC8C: 817EFFF0  lwz r11, -0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16 as u32) ) } as u64;
	// 822EBC90: 389EFFF0  addi r4, r30, -0x10
	ctx.r[4].s64 = ctx.r[30].s64 + -16;
	// 822EBC94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EBC98: 419A0168  beq cr6, 0x822ebe00
	if ctx.cr[6].eq {
	pc = 0x822EBE00; continue 'dispatch;
	}
	// 822EBC9C: 933F0094  stw r25, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[25].u32 ) };
	// 822EBCA0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822EBCA4: 933D0078  stw r25, 0x78(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), ctx.r[25].u32 ) };
	pc = 0x822EBE30; continue 'dispatch;
            }
            0x822EBE30 => {
    //   block [0x822EBE30..0x822EBE48)
	// 822EBE30: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822EBE34: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 822EBE38: 4824A1F1  bl 0x82536028
	ctx.lr = 0x822EBE3C;
	sub_82535FFC(ctx, base);
	// 822EBE3C: 48249294  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
	// 822EBE40: FDA06850  fneg f13, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 822EBE44: 4BFFFF70  b 0x822ebdb4
	pc = 0x822EBDB4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EBE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EBE48 size=1120
    let mut pc: u32 = 0x822EBE48;
    'dispatch: loop {
        match pc {
            0x822EBE48 => {
    //   block [0x822EBE48..0x822EBEE4)
	// 822EBE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EBE4C: 48249241  bl 0x8253508c
	ctx.lr = 0x822EBE50;
	sub_82535080(ctx, base);
	// 822EBE50: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 822EBE54: 4824A15D  bl 0x82535fb0
	ctx.lr = 0x822EBE58;
	sub_82535FB0(ctx, base);
	// 822EBE58: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EBE5C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822EBE60: 7CB12B78  mr r17, r5
	ctx.r[17].u64 = ctx.r[5].u64;
	// 822EBE64: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 822EBE68: 2F110000  cmpwi cr6, r17, 0
	ctx.cr[6].compare_i32(ctx.r[17].s32, 0, &mut ctx.xer);
	// 822EBE6C: C2ABBA38  lfs f21, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 822EBE70: D2A3004C  stfs f21, 0x4c(r3)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 822EBE74: D2A30040  stfs f21, 0x40(r3)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822EBE78: D2A30044  stfs f21, 0x44(r3)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 822EBE7C: D2A30048  stfs f21, 0x48(r3)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 822EBE80: 409A0064  bne cr6, 0x822ebee4
	if !ctx.cr[6].eq {
	pc = 0x822EBEE4; continue 'dispatch;
	}
	// 822EBE84: E8F50030  ld r7, 0x30(r21)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(48 as u32) ) };
	// 822EBE88: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 822EBE8C: 39430060  addi r10, r3, 0x60
	ctx.r[10].s64 = ctx.r[3].s64 + 96;
	// 822EBE90: 39230070  addi r9, r3, 0x70
	ctx.r[9].s64 = ctx.r[3].s64 + 112;
	// 822EBE94: 39030080  addi r8, r3, 0x80
	ctx.r[8].s64 = ctx.r[3].s64 + 128;
	// 822EBE98: F8EB0000  std r7, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 822EBE9C: E8F50038  ld r7, 0x38(r21)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(56 as u32) ) };
	// 822EBEA0: F8EB0008  std r7, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 822EBEA4: E9750030  ld r11, 0x30(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(48 as u32) ) };
	// 822EBEA8: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 822EBEAC: E9750038  ld r11, 0x38(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(56 as u32) ) };
	// 822EBEB0: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822EBEB4: E9750030  ld r11, 0x30(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(48 as u32) ) };
	// 822EBEB8: F9690000  std r11, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 822EBEBC: E9750038  ld r11, 0x38(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(56 as u32) ) };
	// 822EBEC0: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822EBEC4: E9750030  ld r11, 0x30(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(48 as u32) ) };
	// 822EBEC8: F9680000  std r11, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 822EBECC: E9750038  ld r11, 0x38(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(56 as u32) ) };
	// 822EBED0: F9680008  std r11, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822EBED4: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 822EBED8: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 822EBEDC: 4824A121  bl 0x82535ffc
	ctx.lr = 0x822EBEE0;
	sub_82535FFC(ctx, base);
	// 822EBEE0: 482491FC  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            0x822EBEE4 => {
    //   block [0x822EBEE4..0x822EBEFC)
	// 822EBEE4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 822EBEE8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822EBEEC: 212B001F  subfic r9, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[9].s64 = (31 as i64) - ctx.r[11].s64;
	// 822EBEF0: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 822EBEF4: 41980008  blt cr6, 0x822ebefc
	if ctx.cr[6].lt {
	pc = 0x822EBEFC; continue 'dispatch;
	}
	// 822EBEF8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x822EBEFC; continue 'dispatch;
            }
            0x822EBEFC => {
    //   block [0x822EBEFC..0x822EC2A8)
	// 822EBEFC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 822EBF00: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 822EBF04: 5529482C  slwi r9, r9, 9
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(9);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822EBF08: 394BFE00  addi r10, r11, -0x200
	ctx.r[10].s64 = ctx.r[11].s64 + -512;
	// 822EBF0C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EBF10: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 822EBF14: 11A1034A  vcfsx v13, v0, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[13].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 822EBF18: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822EBF1C: 1180034A  vcfsx v12, v0, 0
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[12].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 822EBF20: 394A00D0  addi r10, r10, 0xd0
	ctx.r[10].s64 = ctx.r[10].s64 + 208;
	// 822EBF24: 3A430050  addi r18, r3, 0x50
	ctx.r[18].s64 = ctx.r[3].s64 + 80;
	// 822EBF28: C00B2450  lfs f0, 0x2450(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EBF2C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 822EBF30: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 822EBF34: C1A92380  lfs f13, 0x2380(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9088 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EBF38: 3EC0820C  lis r22, -0x7df4
	ctx.r[22].s64 = -2113142784;
	// 822EBF3C: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 822EBF40: 3EE08286  lis r23, -0x7d7a
	ctx.r[23].s64 = -2105147392;
	// 822EBF44: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 822EBF48: 3F00820D  lis r24, -0x7df3
	ctx.r[24].s64 = -2113077248;
	// 822EBF4C: 3F20820D  lis r25, -0x7df3
	ctx.r[25].s64 = -2113077248;
	// 822EBF50: EC01683E  fnmadds f0, f1, f0, f13
	ctx.f[0].f64 = -(ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64);
	// 822EBF54: 3F40820D  lis r26, -0x7df3
	ctx.r[26].s64 = -2113077248;
	// 822EBF58: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822EBF5C: 3F60820D  lis r27, -0x7df3
	ctx.r[27].s64 = -2113077248;
	// 822EBF60: C0082144  lfs f0, 0x2144(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EBF64: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822EBF68: 3F80820D  lis r28, -0x7df3
	ctx.r[28].s64 = -2113077248;
	// 822EBF6C: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 822EBF70: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 822EBF74: 3FA0820D  lis r29, -0x7df3
	ctx.r[29].s64 = -2113077248;
	// 822EBF78: C2F92870  lfs f23, 0x2870(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(10352 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 822EBF7C: 3FC0820D  lis r30, -0x7df3
	ctx.r[30].s64 = -2113077248;
	// 822EBF80: C31A286C  lfs f24, 0x286c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(10348 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 822EBF84: 3FE0820D  lis r31, -0x7df3
	ctx.r[31].s64 = -2113077248;
	// 822EBF88: C33B2868  lfs f25, 0x2868(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(10344 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 822EBF8C: 3C60820D  lis r3, -0x7df3
	ctx.r[3].s64 = -2113077248;
	// 822EBF90: CBFC2000  lfd f31, 0x2000(r28)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8192 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EC2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EC2A8 size=200
    let mut pc: u32 = 0x822EC2A8;
    'dispatch: loop {
        match pc {
            0x822EC2A8 => {
    //   block [0x822EC2A8..0x822EC370)
	// 822EC2A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EC2AC: 48248E05  bl 0x825350b0
	ctx.lr = 0x822EC2B0;
	sub_82535080(ctx, base);
	// 822EC2B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EC2B4: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 822EC2B8: 83ED0000  lwz r31, 0(r13)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC2BC: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EC370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EC370 size=184
    let mut pc: u32 = 0x822EC370;
    'dispatch: loop {
        match pc {
            0x822EC370 => {
    //   block [0x822EC370..0x822EC3C0)
	// 822EC370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EC374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EC378: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822EC37C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EC380: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EC384: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EC388: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822EC38C: 38EBC3EC  addi r7, r11, -0x3c14
	ctx.r[7].s64 = ctx.r[11].s64 + -15380;
	// 822EC390: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 822EC394: 38C00028  li r6, 0x28
	ctx.r[6].s64 = 40;
	// 822EC398: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822EC39C: 38600260  li r3, 0x260
	ctx.r[3].s64 = 608;
	// 822EC3A0: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 822EC3A4: 4807E0ED  bl 0x8236a490
	ctx.lr = 0x822EC3A8;
	sub_8236A490(ctx, base);
	// 822EC3A8: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 822EC3AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EC3B0: 3BEBE540  addi r31, r11, -0x1ac0
	ctx.r[31].s64 = ctx.r[11].s64 + -6848;
	// 822EC3B4: 419A000C  beq cr6, 0x822ec3c0
	if ctx.cr[6].eq {
	pc = 0x822EC3C0; continue 'dispatch;
	}
	// 822EC3B8: 81430030  lwz r10, 0x30(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822EC3BC: 48000008  b 0x822ec3c4
	pc = 0x822EC3C4; continue 'dispatch;
            }
            0x822EC3C0 => {
    //   block [0x822EC3C0..0x822EC3C4)
	// 822EC3C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x822EC3C4; continue 'dispatch;
            }
            0x822EC3C4 => {
    //   block [0x822EC3C4..0x822EC3E4)
	// 822EC3C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EC3C8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822EC3CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EC3D0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822EC3D4: 419A0010  beq cr6, 0x822ec3e4
	if ctx.cr[6].eq {
	pc = 0x822EC3E4; continue 'dispatch;
	}
	// 822EC3D8: 48000B01  bl 0x822eced8
	ctx.lr = 0x822EC3DC;
	sub_822ECED8(ctx, base);
	// 822EC3DC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EC3E0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822EC3E4; continue 'dispatch;
            }
            0x822EC3E4 => {
    //   block [0x822EC3E4..0x822EC400)
	// 822EC3E4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822EC3E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EC3EC: F93E0000  std r9, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822EC3F0: 419A0010  beq cr6, 0x822ec400
	if ctx.cr[6].eq {
	pc = 0x822EC400; continue 'dispatch;
	}
	// 822EC3F4: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822EC3F8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822EC3FC: 419A0008  beq cr6, 0x822ec404
	if ctx.cr[6].eq {
	pc = 0x822EC404; continue 'dispatch;
	}
	pc = 0x822EC400; continue 'dispatch;
            }
            0x822EC400 => {
    //   block [0x822EC400..0x822EC404)
	// 822EC400: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822EC404; continue 'dispatch;
            }
            0x822EC404 => {
    //   block [0x822EC404..0x822EC428)
	// 822EC404: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EC408: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822EC40C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822EC410: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822EC414: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EC418: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EC41C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822EC420: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EC424: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EC428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EC428 size=144
    let mut pc: u32 = 0x822EC428;
    'dispatch: loop {
        match pc {
            0x822EC428 => {
    //   block [0x822EC428..0x822EC46C)
	// 822EC428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EC42C: 48248C7D  bl 0x825350a8
	ctx.lr = 0x822EC430;
	sub_82535080(ctx, base);
	// 822EC430: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EC434: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EC438: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822EC43C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822EC440: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822EC444: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 822EC448: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 822EC44C: 48000CE5  bl 0x822ed130
	ctx.lr = 0x822EC450;
	sub_822ED130(ctx, base);
	// 822EC450: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 822EC454: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822EC458: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EC45C: 48001BFD  bl 0x822ee058
	ctx.lr = 0x822EC460;
	sub_822EE058(ctx, base);
	// 822EC460: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 822EC464: 3B0B49D8  addi r24, r11, 0x49d8
	ctx.r[24].s64 = ctx.r[11].s64 + 18904;
	// 822EC468: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	pc = 0x822EC46C; continue 'dispatch;
            }
            0x822EC46C => {
    //   block [0x822EC46C..0x822EC4A0)
	// 822EC46C: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC470: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EC474: 419A002C  beq cr6, 0x822ec4a0
	if ctx.cr[6].eq {
	pc = 0x822EC4A0; continue 'dispatch;
	}
	// 822EC478: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC47C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 822EC480: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 822EC484: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 822EC488: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822EC48C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822EC490: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC494: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EC498: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EC49C: 4E800421  bctrl
	ctx.lr = 0x822EC4A0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EC4A0 => {
    //   block [0x822EC4A0..0x822EC4B8)
	// 822EC4A0: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 822EC4A4: 39780100  addi r11, r24, 0x100
	ctx.r[11].s64 = ctx.r[24].s64 + 256;
	// 822EC4A8: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EC4AC: 4198FFC0  blt cr6, 0x822ec46c
	if ctx.cr[6].lt {
	pc = 0x822EC46C; continue 'dispatch;
	}
	// 822EC4B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822EC4B4: 48248C44  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EC4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EC4B8 size=168
    let mut pc: u32 = 0x822EC4B8;
    'dispatch: loop {
        match pc {
            0x822EC4B8 => {
    //   block [0x822EC4B8..0x822EC518)
	// 822EC4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EC4BC: 48248BF1  bl 0x825350ac
	ctx.lr = 0x822EC4C0;
	sub_82535080(ctx, base);
	// 822EC4C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EC4C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EC4C8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 822EC4CC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822EC4D0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 822EC4D4: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 822EC4D8: 48000C59  bl 0x822ed130
	ctx.lr = 0x822EC4DC;
	sub_822ED130(ctx, base);
	// 822EC4DC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 822EC4E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822EC4E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EC4E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822EC4EC: 48001B6D  bl 0x822ee058
	ctx.lr = 0x822EC4F0;
	sub_822EE058(ctx, base);
	// 822EC4F0: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 822EC4F4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 822EC4F8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822EC4FC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822EC500: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EC504: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822EC508: 48001BF1  bl 0x822ee0f8
	ctx.lr = 0x822EC50C;
	sub_822EE0F8(ctx, base);
	// 822EC50C: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 822EC510: 3B2B49D8  addi r25, r11, 0x49d8
	ctx.r[25].s64 = ctx.r[11].s64 + 18904;
	// 822EC514: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	pc = 0x822EC518; continue 'dispatch;
            }
            0x822EC518 => {
    //   block [0x822EC518..0x822EC548)
	// 822EC518: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC51C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EC520: 419A0028  beq cr6, 0x822ec548
	if ctx.cr[6].eq {
	pc = 0x822EC548; continue 'dispatch;
	}
	// 822EC524: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC528: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 822EC52C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 822EC530: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822EC534: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822EC538: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EC53C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EC540: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EC544: 4E800421  bctrl
	ctx.lr = 0x822EC548;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EC548 => {
    //   block [0x822EC548..0x822EC560)
	// 822EC548: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 822EC54C: 39790100  addi r11, r25, 0x100
	ctx.r[11].s64 = ctx.r[25].s64 + 256;
	// 822EC550: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EC554: 4198FFC4  blt cr6, 0x822ec518
	if ctx.cr[6].lt {
	pc = 0x822EC518; continue 'dispatch;
	}
	// 822EC558: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EC55C: 48248BA0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EC560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EC560 size=200
    let mut pc: u32 = 0x822EC560;
    'dispatch: loop {
        match pc {
            0x822EC560 => {
    //   block [0x822EC560..0x822EC594)
	// 822EC560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EC564: 48248B55  bl 0x825350b8
	ctx.lr = 0x822EC568;
	sub_82535080(ctx, base);
	// 822EC568: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EC56C: 48000BC5  bl 0x822ed130
	ctx.lr = 0x822EC570;
	sub_822ED130(ctx, base);
	// 822EC570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EC574: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822EC578: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822EC57C: 815F01A4  lwz r10, 0x1a4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EC580: 917F0144  stw r11, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[11].u32 ) };
	// 822EC584: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822EC588: 4099003C  ble cr6, 0x822ec5c4
	if !ctx.cr[6].gt {
	pc = 0x822EC5C4; continue 'dispatch;
	}
	// 822EC58C: 3B9F0080  addi r28, r31, 0x80
	ctx.r[28].s64 = ctx.r[31].s64 + 128;
	// 822EC590: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x822EC594; continue 'dispatch;
            }
            0x822EC594 => {
    //   block [0x822EC594..0x822EC5C4)
	// 822EC594: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EC598: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822EC59C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 822EC5A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC5A4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822EC5A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EC5AC: 4E800421  bctrl
	ctx.lr = 0x822EC5B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EC5B0: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EC5B4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822EC5B8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EC5BC: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EC5C0: 4198FFD4  blt cr6, 0x822ec594
	if ctx.cr[6].lt {
	pc = 0x822EC594; continue 'dispatch;
	}
            }
            0x822EC5C4 => {
    //   block [0x822EC5C4..0x822EC5D8)
	// 822EC5C4: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 822EC5C8: 3BAB49D8  addi r29, r11, 0x49d8
	ctx.r[29].s64 = ctx.r[11].s64 + 18904;
	// 822EC5CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822EC5D0: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 822EC5D4: 917F0144  stw r11, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[11].u32 ) };
	pc = 0x822EC5D8; continue 'dispatch;
            }
            0x822EC5D8 => {
    //   block [0x822EC5D8..0x822EC610)
	// 822EC5D8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC5DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EC5E0: 419A0030  beq cr6, 0x822ec610
	if ctx.cr[6].eq {
	pc = 0x822EC610; continue 'dispatch;
	}
	// 822EC5E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC5E8: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 822EC5EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EC5F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EC5F4: 4E800421  bctrl
	ctx.lr = 0x822EC5F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EC5F8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC5FC: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 822EC600: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC604: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822EC608: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EC60C: 4E800421  bctrl
	ctx.lr = 0x822EC610;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EC610 => {
    //   block [0x822EC610..0x822EC628)
	// 822EC610: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EC614: 397D0100  addi r11, r29, 0x100
	ctx.r[11].s64 = ctx.r[29].s64 + 256;
	// 822EC618: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EC61C: 4198FFBC  blt cr6, 0x822ec5d8
	if ctx.cr[6].lt {
	pc = 0x822EC5D8; continue 'dispatch;
	}
	// 822EC620: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822EC624: 48248AE4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EC628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EC628 size=116
    let mut pc: u32 = 0x822EC628;
    'dispatch: loop {
        match pc {
            0x822EC628 => {
    //   block [0x822EC628..0x822EC690)
	// 822EC628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EC62C: 48248A85  bl 0x825350b0
	ctx.lr = 0x822EC630;
	sub_82535080(ctx, base);
	// 822EC630: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 822EC634: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EC638: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EC63C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822EC640: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 822EC644: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822EC648: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 822EC64C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 822EC650: 48000AE1  bl 0x822ed130
	ctx.lr = 0x822EC654;
	sub_822ED130(ctx, base);
	// 822EC654: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 822EC658: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822EC65C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 822EC660: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822EC664: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822EC668: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EC66C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822EC670: 48001BF1  bl 0x822ee260
	ctx.lr = 0x822EC674;
	sub_822EE260(ctx, base);
	// 822EC674: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822EC678: 40990018  ble cr6, 0x822ec690
	if !ctx.cr[6].gt {
	pc = 0x822EC690; continue 'dispatch;
	}
	// 822EC67C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 822EC680: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822EC684: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EC688: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822EC68C: 480019CD  bl 0x822ee058
	ctx.lr = 0x822EC690;
	sub_822EE058(ctx, base);
	pc = 0x822EC690; continue 'dispatch;
            }
            0x822EC690 => {
    //   block [0x822EC690..0x822EC69C)
	// 822EC690: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EC694: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822EC698: 48248A68  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EC6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EC6A0 size=244
    let mut pc: u32 = 0x822EC6A0;
    'dispatch: loop {
        match pc {
            0x822EC6A0 => {
    //   block [0x822EC6A0..0x822EC754)
	// 822EC6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EC6A4: 48248A05  bl 0x825350a8
	ctx.lr = 0x822EC6A8;
	sub_82535080(ctx, base);
	// 822EC6A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EC6AC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 822EC6B0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822EC6B4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822EC6B8: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 822EC6BC: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 822EC6C0: 48000A71  bl 0x822ed130
	ctx.lr = 0x822EC6C4;
	sub_822ED130(ctx, base);
	// 822EC6C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EC6C8: E8DC0008  ld r6, 8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	// 822EC6CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822EC6D0: 812100F4  lwz r9, 0xf4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 822EC6D4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 822EC6D8: 391F00A0  addi r8, r31, 0xa0
	ctx.r[8].s64 = ctx.r[31].s64 + 160;
	// 822EC6DC: 38FF00C0  addi r7, r31, 0xc0
	ctx.r[7].s64 = ctx.r[31].s64 + 192;
	// 822EC6E0: 933F0094  stw r25, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[25].u32 ) };
	// 822EC6E4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 822EC6E8: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 822EC6EC: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 822EC6F0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 822EC6F4: 915F009C  stw r10, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 822EC6F8: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 822EC6FC: E91D0000  ld r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 822EC700: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 822EC704: E8FC0000  ld r7, 0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 822EC708: 80BF01A4  lwz r5, 0x1a4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EC70C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 822EC710: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 822EC714: E91D0008  ld r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 822EC718: F8EA0000  std r7, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 822EC71C: F8CA0008  std r6, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u64 ) };
	// 822EC720: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 822EC724: E97B0000  ld r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 822EC728: F97F00E0  std r11, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 822EC72C: E97B0008  ld r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	// 822EC730: F97F00E8  std r11, 0xe8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u64 ) };
	// 822EC734: E97A0000  ld r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 822EC738: F97F00E0  std r11, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 822EC73C: E97A0008  ld r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	// 822EC740: 913F0140  stw r9, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[9].u32 ) };
	// 822EC744: F97F00E8  std r11, 0xe8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u64 ) };
	// 822EC748: 4099003C  ble cr6, 0x822ec784
	if !ctx.cr[6].gt {
	pc = 0x822EC784; continue 'dispatch;
	}
	// 822EC74C: 3B9F0080  addi r28, r31, 0x80
	ctx.r[28].s64 = ctx.r[31].s64 + 128;
	// 822EC750: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	pc = 0x822EC754; continue 'dispatch;
            }
            0x822EC754 => {
    //   block [0x822EC754..0x822EC784)
	// 822EC754: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EC758: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822EC75C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 822EC760: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC764: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822EC768: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EC76C: 4E800421  bctrl
	ctx.lr = 0x822EC770;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EC770: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EC774: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822EC778: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822EC77C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EC780: 4198FFD4  blt cr6, 0x822ec754
	if ctx.cr[6].lt {
	pc = 0x822EC754; continue 'dispatch;
	}
            }
            0x822EC784 => {
    //   block [0x822EC784..0x822EC794)
	// 822EC784: 931F0084  stw r24, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[24].u32 ) };
	// 822EC788: 931F0090  stw r24, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[24].u32 ) };
	// 822EC78C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822EC790: 48248968  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EC798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EC798 size=132
    let mut pc: u32 = 0x822EC798;
    'dispatch: loop {
        match pc {
            0x822EC798 => {
    //   block [0x822EC798..0x822EC7D0)
	// 822EC798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EC79C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EC7A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822EC7A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EC7A8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822EC7AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EC7B0: 48000981  bl 0x822ed130
	ctx.lr = 0x822EC7B4;
	sub_822ED130(ctx, base);
	// 822EC7B4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822EC7B8: C3EBD5B0  lfs f31, -0x2a50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822EC7BC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822EC7C0: 48001E19  bl 0x822ee5d8
	ctx.lr = 0x822EC7C4;
	sub_822EE5D8(ctx, base);
	// 822EC7C4: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 822EC7C8: 3BCB49D8  addi r30, r11, 0x49d8
	ctx.r[30].s64 = ctx.r[11].s64 + 18904;
	// 822EC7CC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x822EC7D0; continue 'dispatch;
            }
            0x822EC7D0 => {
    //   block [0x822EC7D0..0x822EC7F0)
	// 822EC7D0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC7D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EC7D8: 419A0018  beq cr6, 0x822ec7f0
	if ctx.cr[6].eq {
	pc = 0x822EC7F0; continue 'dispatch;
	}
	// 822EC7DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC7E0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822EC7E4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822EC7E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EC7EC: 4E800421  bctrl
	ctx.lr = 0x822EC7F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EC7F0 => {
    //   block [0x822EC7F0..0x822EC81C)
	// 822EC7F0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822EC7F4: 397E0100  addi r11, r30, 0x100
	ctx.r[11].s64 = ctx.r[30].s64 + 256;
	// 822EC7F8: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EC7FC: 4198FFD4  blt cr6, 0x822ec7d0
	if ctx.cr[6].lt {
	pc = 0x822EC7D0; continue 'dispatch;
	}
	// 822EC800: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822EC804: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EC808: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EC80C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822EC810: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822EC814: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EC818: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EC820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EC820 size=252
    let mut pc: u32 = 0x822EC820;
    'dispatch: loop {
        match pc {
            0x822EC820 => {
    //   block [0x822EC820..0x822EC8EC)
	// 822EC820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EC824: 48248895  bl 0x825350b8
	ctx.lr = 0x822EC828;
	sub_82535080(ctx, base);
	// 822EC828: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EC82C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EC830: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822EC834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822EC838: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822EC83C: 995F001C  stb r10, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 822EC840: 616B0300  ori r11, r11, 0x300
	ctx.r[11].u64 = ctx.r[11].u64 | 768;
	// 822EC844: B17F0014  sth r11, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 822EC848: 480A1079  bl 0x8238d8c0
	ctx.lr = 0x822EC84C;
	sub_8238D8C0(ctx, base);
	// 822EC84C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822EC850: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 822EC854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822EC858: 3BBF0084  addi r29, r31, 0x84
	ctx.r[29].s64 = ctx.r[31].s64 + 132;
	// 822EC85C: C00B2938  lfs f0, 0x2938(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EC860: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822EC864: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 822EC868: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 822EC86C: C00BD5BC  lfs f0, -0x2a44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10820 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EC870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822EC874: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822EC878: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822EC87C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822EC880: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 822EC884: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 822EC888: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 822EC88C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822EC890: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EC894: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822EC898: 480A05E1  bl 0x8238ce78
	ctx.lr = 0x822EC89C;
	sub_8238CE78(ctx, base);
	// 822EC89C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EC8A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822EC8A4: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 822EC8A8: 480A05D1  bl 0x8238ce78
	ctx.lr = 0x822EC8AC;
	sub_8238CE78(ctx, base);
	// 822EC8AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EC8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822EC8B4: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 822EC8B8: 480A05C1  bl 0x8238ce78
	ctx.lr = 0x822EC8BC;
	sub_8238CE78(ctx, base);
	// 822EC8BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EC8C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822EC8C4: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 822EC8C8: 480A05B1  bl 0x8238ce78
	ctx.lr = 0x822EC8CC;
	sub_8238CE78(ctx, base);
	// 822EC8CC: 907F0090  stw r3, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 822EC8D0: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 822EC8D4: 4800085D  bl 0x822ed130
	ctx.lr = 0x822EC8D8;
	sub_822ED130(ctx, base);
	// 822EC8D8: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822EC8DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822EC8E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822EC8E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822EC8E8: 4099002C  ble cr6, 0x822ec914
	if !ctx.cr[6].gt {
	pc = 0x822EC914; continue 'dispatch;
	}
	pc = 0x822EC8EC; continue 'dispatch;
            }
            0x822EC8EC => {
    //   block [0x822EC8EC..0x822EC900)
	// 822EC8EC: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC8F0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822EC8F4: 419A000C  beq cr6, 0x822ec900
	if ctx.cr[6].eq {
	pc = 0x822EC900; continue 'dispatch;
	}
	// 822EC8F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822EC8FC: 4800143D  bl 0x822edd38
	ctx.lr = 0x822EC900;
	sub_822EDD38(ctx, base);
	pc = 0x822EC900; continue 'dispatch;
            }
            0x822EC900 => {
    //   block [0x822EC900..0x822EC914)
	// 822EC900: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822EC904: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822EC908: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822EC90C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EC910: 4198FFDC  blt cr6, 0x822ec8ec
	if ctx.cr[6].lt {
	pc = 0x822EC8EC; continue 'dispatch;
	}
	pc = 0x822EC914; continue 'dispatch;
            }
            0x822EC914 => {
    //   block [0x822EC914..0x822EC91C)
	// 822EC914: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822EC918: 482487F0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EC920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EC920 size=920
    let mut pc: u32 = 0x822EC920;
    'dispatch: loop {
        match pc {
            0x822EC920 => {
    //   block [0x822EC920..0x822ECCB8)
	// 822EC920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EC924: 4824877D  bl 0x825350a0
	ctx.lr = 0x822EC928;
	sub_82535080(ctx, base);
	// 822EC928: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 822EC92C: 482496BD  bl 0x82535fe8
	ctx.lr = 0x822EC930;
	sub_82535FB0(ctx, base);
	// 822EC930: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EC934: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822EC938: C38100DC  lfs f28, 0xdc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 822EC93C: 3AE10070  addi r23, r1, 0x70
	ctx.r[23].s64 = ctx.r[1].s64 + 112;
	// 822EC940: 3B030084  addi r24, r3, 0x84
	ctx.r[24].s64 = ctx.r[3].s64 + 132;
	// 822EC944: 3AC00002  li r22, 2
	ctx.r[22].s64 = 2;
	// 822EC948: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822EC94C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822EC950: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 822EC954: 39600015  li r11, 0x15
	ctx.r[11].s64 = 21;
	// 822EC958: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822EC95C: 39600011  li r11, 0x11
	ctx.r[11].s64 = 17;
	// 822EC960: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822EC964: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822EC968: 3B4B76FC  addi r26, r11, 0x76fc
	ctx.r[26].s64 = ctx.r[11].s64 + 30460;
	// 822EC96C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC970: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 822EC974: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 822EC978: 557C103A  slwi r28, r11, 2
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 822EC97C: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 822EC980: 3B180008  addi r24, r24, 8
	ctx.r[24].s64 = ctx.r[24].s64 + 8;
	// 822EC984: 7D7CD02E  lwzx r11, r28, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 822EC988: 83DB0000  lwz r30, 0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EC98C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 822EC990: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822EC994: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822EC998: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EC99C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EC9A0: 4E800421  bctrl
	ctx.lr = 0x822EC9A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EC9A4: 7D7CD02E  lwzx r11, r28, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 822EC9A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EC9AC: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 822EC9B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822EC9B4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822EC9B8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822EC9BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EC9C0: 4E800421  bctrl
	ctx.lr = 0x822EC9C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EC9C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EC9C8: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 822EC9CC: C3FF0030  lfs f31, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822EC9D0: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 822EC9D4: C3DF0034  lfs f30, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822EC9D8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822EC9DC: C3BF0038  lfs f29, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822EC9E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EC9E4: D3E100D0  stfs f31, 0xd0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 822EC9E8: C00B0030  lfs f0, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EC9EC: D0010120  stfs f0, 0x120(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 822EC9F0: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EC9F4: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 822EC9F8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EC9FC: D3C100D4  stfs f30, 0xd4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 822ECA00: D3A100D8  stfs f29, 0xd8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 822ECA04: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 822ECA08: 4807BC09  bl 0x82368610
	ctx.lr = 0x822ECA0C;
	sub_82368610(ctx, base);
	// 822ECA0C: 39610120  addi r11, r1, 0x120
	ctx.r[11].s64 = ctx.r[1].s64 + 288;
	// 822ECA10: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ECA14: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ECCB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ECCB8 size=200
    let mut pc: u32 = 0x822ECCB8;
    'dispatch: loop {
        match pc {
            0x822ECCB8 => {
    //   block [0x822ECCB8..0x822ECD24)
	// 822ECCB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ECCBC: 482483F5  bl 0x825350b0
	ctx.lr = 0x822ECCC0;
	sub_82535080(ctx, base);
	// 822ECCC0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ECCC4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822ECCC8: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 822ECCCC: 617F9CF0  ori r31, r11, 0x9cf0
	ctx.r[31].u64 = ctx.r[11].u64 | 40176;
	// 822ECCD0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822ECCD4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822ECCD8: 3BCB76FC  addi r30, r11, 0x76fc
	ctx.r[30].s64 = ctx.r[11].s64 + 30460;
	// 822ECCDC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822ECCE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822ECCE4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ECCE8: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 822ECCEC: 4BF252A5  bl 0x82211f90
	ctx.lr = 0x822ECCF0;
	sub_82211F90(ctx, base);
	// 822ECCF0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ECCF4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822ECCF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822ECCFC: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 822ECD00: 4BF25291  bl 0x82211f90
	ctx.lr = 0x822ECD04;
	sub_82211F90(ctx, base);
	// 822ECD04: 4800042D  bl 0x822ed130
	ctx.lr = 0x822ECD08;
	sub_822ED130(ctx, base);
	// 822ECD08: 817C0080  lwz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 822ECD0C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822ECD10: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822ECD14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822ECD18: 40990060  ble cr6, 0x822ecd78
	if !ctx.cr[6].gt {
	pc = 0x822ECD78; continue 'dispatch;
	}
	// 822ECD1C: 3BDC0084  addi r30, r28, 0x84
	ctx.r[30].s64 = ctx.r[28].s64 + 132;
	// 822ECD20: 3F408273  lis r26, -0x7d8d
	ctx.r[26].s64 = -2106392576;
	pc = 0x822ECD24; continue 'dispatch;
            }
            0x822ECD24 => {
    //   block [0x822ECD24..0x822ECD64)
	// 822ECD24: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ECD28: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822ECD2C: 419A0038  beq cr6, 0x822ecd64
	if ctx.cr[6].eq {
	pc = 0x822ECD64; continue 'dispatch;
	}
	// 822ECD30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822ECD34: 480010C5  bl 0x822eddf8
	ctx.lr = 0x822ECD38;
	sub_822EDDF8(ctx, base);
	// 822ECD38: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ECD3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822ECD40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ECD44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ECD48: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ECD4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ECD50: 4E800421  bctrl
	ctx.lr = 0x822ECD54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ECD54: 817A49B0  lwz r11, 0x49b0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822ECD58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ECD5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ECD60: 4E800421  bctrl
	ctx.lr = 0x822ECD64;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822ECD64 => {
    //   block [0x822ECD64..0x822ECD78)
	// 822ECD64: 817C0080  lwz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 822ECD68: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822ECD6C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822ECD70: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822ECD74: 4198FFB0  blt cr6, 0x822ecd24
	if ctx.cr[6].lt {
	pc = 0x822ECD24; continue 'dispatch;
	}
	pc = 0x822ECD78; continue 'dispatch;
            }
            0x822ECD78 => {
    //   block [0x822ECD78..0x822ECD80)
	// 822ECD78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822ECD7C: 48248384  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ECD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822ECD80 size=20
    let mut pc: u32 = 0x822ECD80;
    'dispatch: loop {
        match pc {
            0x822ECD80 => {
    //   block [0x822ECD80..0x822ECD94)
	// 822ECD80: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ECD84: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ECD88: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ECD8C: 7D635378  or r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 822ECD90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ECD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822ECD98 size=12
    let mut pc: u32 = 0x822ECD98;
    'dispatch: loop {
        match pc {
            0x822ECD98 => {
    //   block [0x822ECD98..0x822ECDA4)
	// 822ECD98: 548B2834  slwi r11, r4, 5
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ECD9C: 7C6B1A14  add r3, r11, r3
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822ECDA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ECDA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822ECDA8 size=32
    let mut pc: u32 = 0x822ECDA8;
    'dispatch: loop {
        match pc {
            0x822ECDA8 => {
    //   block [0x822ECDA8..0x822ECDC8)
	// 822ECDA8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ECDAC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ECDB0: 556B801E  slwi r11, r11, 0x10
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(16);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ECDB4: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ECDB8: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 822ECDBC: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ECDC0: 7D634B78  or r3, r11, r9
	ctx.r[3].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 822ECDC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ECDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822ECDC8 size=20
    let mut pc: u32 = 0x822ECDC8;
    'dispatch: loop {
        match pc {
            0x822ECDC8 => {
    //   block [0x822ECDC8..0x822ECDDC)
	// 822ECDC8: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ECDCC: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 822ECDD0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ECDD4: 7C6B1A14  add r3, r11, r3
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822ECDD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ECDE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822ECDE0 size=20
    let mut pc: u32 = 0x822ECDE0;
    'dispatch: loop {
        match pc {
            0x822ECDE0 => {
    //   block [0x822ECDE0..0x822ECDF4)
	// 822ECDE0: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ECDE4: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 822ECDE8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ECDEC: 7C6B1A14  add r3, r11, r3
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822ECDF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ECDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822ECDF8 size=20
    let mut pc: u32 = 0x822ECDF8;
    'dispatch: loop {
        match pc {
            0x822ECDF8 => {
    //   block [0x822ECDF8..0x822ECE0C)
	// 822ECDF8: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ECDFC: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 822ECE00: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ECE04: 7C6B1A14  add r3, r11, r3
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822ECE08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ECE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822ECE10 size=20
    let mut pc: u32 = 0x822ECE10;
    'dispatch: loop {
        match pc {
            0x822ECE10 => {
    //   block [0x822ECE10..0x822ECE24)
	// 822ECE10: 7D632214  add r11, r3, r4
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 822ECE14: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822ECE18: 7D6B23D6  divw r11, r11, r4
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[4].s32;
	// 822ECE1C: 7C6B21D6  mullw r3, r11, r4
	ctx.r[3].s32 = ((ctx.r[11].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 822ECE20: 48003CB0  b 0x822f0ad0
	sub_822F0AD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ECE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822ECE28 size=4
    let mut pc: u32 = 0x822ECE28;
    'dispatch: loop {
        match pc {
            0x822ECE28 => {
    //   block [0x822ECE28..0x822ECE2C)
	// 822ECE28: 48003E80  b 0x822f0ca8
	sub_822F0CA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ECE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ECE30 size=48
    let mut pc: u32 = 0x822ECE30;
    'dispatch: loop {
        match pc {
            0x822ECE30 => {
    //   block [0x822ECE30..0x822ECE60)
	// 822ECE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ECE34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822ECE38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822ECE3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ECE40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822ECE44: 480002ED  bl 0x822ed130
	ctx.lr = 0x822ECE48;
	sub_822ED130(ctx, base);
	// 822ECE48: 93E30254  stw r31, 0x254(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(596 as u32), ctx.r[31].u32 ) };
	// 822ECE4C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822ECE50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ECE54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ECE58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822ECE5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ECE60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ECE60 size=120
    let mut pc: u32 = 0x822ECE60;
    'dispatch: loop {
        match pc {
            0x822ECE60 => {
    //   block [0x822ECE60..0x822ECE9C)
	// 822ECE60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ECE64: 48248251  bl 0x825350b4
	ctx.lr = 0x822ECE68;
	sub_82535080(ctx, base);
	// 822ECE68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ECE6C: 480002C5  bl 0x822ed130
	ctx.lr = 0x822ECE70;
	sub_822ED130(ctx, base);
	// 822ECE70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822ECE74: 4800156D  bl 0x822ee3e0
	ctx.lr = 0x822ECE78;
	sub_822EE3E0(ctx, base);
	// 822ECE78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ECE7C: 815F01A4  lwz r10, 0x1a4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822ECE80: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822ECE84: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 822ECE88: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822ECE8C: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 822ECE90: 4099003C  ble cr6, 0x822ececc
	if !ctx.cr[6].gt {
	pc = 0x822ECECC; continue 'dispatch;
	}
	// 822ECE94: 3B9F0080  addi r28, r31, 0x80
	ctx.r[28].s64 = ctx.r[31].s64 + 128;
	// 822ECE98: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x822ECE9C; continue 'dispatch;
            }
            0x822ECE9C => {
    //   block [0x822ECE9C..0x822ECECC)
	// 822ECE9C: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822ECEA0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822ECEA4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 822ECEA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ECEAC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822ECEB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ECEB4: 4E800421  bctrl
	ctx.lr = 0x822ECEB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ECEB8: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822ECEBC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822ECEC0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822ECEC4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822ECEC8: 4198FFD4  blt cr6, 0x822ece9c
	if ctx.cr[6].lt {
	pc = 0x822ECE9C; continue 'dispatch;
	}
            }
            0x822ECECC => {
    //   block [0x822ECECC..0x822ECED8)
	// 822ECECC: 937F0148  stw r27, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[27].u32 ) };
	// 822ECED0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822ECED4: 48248230  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ECED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ECED8 size=396
    let mut pc: u32 = 0x822ECED8;
    'dispatch: loop {
        match pc {
            0x822ECED8 => {
    //   block [0x822ECED8..0x822ECF60)
	// 822ECED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ECEDC: 482481DD  bl 0x825350b8
	ctx.lr = 0x822ECEE0;
	sub_82535080(ctx, base);
	// 822ECEE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ECEE4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822ECEE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822ECEEC: 394AC5F0  addi r10, r10, -0x3a10
	ctx.r[10].s64 = ctx.r[10].s64 + -14864;
	// 822ECEF0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822ECEF4: 397E0180  addi r11, r30, 0x180
	ctx.r[11].s64 = ctx.r[30].s64 + 384;
	// 822ECEF8: 3BFE018C  addi r31, r30, 0x18c
	ctx.r[31].s64 = ctx.r[30].s64 + 396;
	// 822ECEFC: 38FE0250  addi r7, r30, 0x250
	ctx.r[7].s64 = ctx.r[30].s64 + 592;
	// 822ECF00: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822ECF04: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 822ECF08: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822ECF0C: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822ECF10: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822ECF14: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822ECF18: 48048639  bl 0x82335550
	ctx.lr = 0x822ECF1C;
	sub_82335550(ctx, base);
	// 822ECF1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822ECF20: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822ECF24: 396BC5D0  addi r11, r11, -0x3a30
	ctx.r[11].s64 = ctx.r[11].s64 + -14896;
	// 822ECF28: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822ECF2C: 38CAC3E4  addi r6, r10, -0x3c1c
	ctx.r[6].s64 = ctx.r[10].s64 + -15388;
	// 822ECF30: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 822ECF34: 3CA00080  lis r5, 0x80
	ctx.r[5].s64 = 8388608;
	// 822ECF38: 386ADBE0  addi r3, r10, -0x2420
	ctx.r[3].s64 = ctx.r[10].s64 + -9248;
	// 822ECF3C: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822ECF40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822ECF44: 993E001C  stb r9, 0x1c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[9].u8 ) };
	// 822ECF48: 4BF083A1  bl 0x821f52e8
	ctx.lr = 0x822ECF4C;
	sub_821F52E8(ctx, base);
	// 822ECF4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ECF50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ECF54: 419A000C  beq cr6, 0x822ecf60
	if ctx.cr[6].eq {
	pc = 0x822ECF60; continue 'dispatch;
	}
	// 822ECF58: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ECF5C: 48000008  b 0x822ecf64
	pc = 0x822ECF64; continue 'dispatch;
            }
            0x822ECF60 => {
    //   block [0x822ECF60..0x822ECF64)
	// 822ECF60: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	pc = 0x822ECF64; continue 'dispatch;
            }
            0x822ECF64 => {
    //   block [0x822ECF64..0x822ECF78)
	// 822ECF64: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ECF68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ECF6C: 409A000C  bne cr6, 0x822ecf78
	if !ctx.cr[6].eq {
	pc = 0x822ECF78; continue 'dispatch;
	}
	// 822ECF70: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822ECF74: 4800002C  b 0x822ecfa0
	pc = 0x822ECFA0; continue 'dispatch;
            }
            0x822ECF78 => {
    //   block [0x822ECF78..0x822ECF90)
	// 822ECF78: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ECF7C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ECF80: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822ECF84: 419A000C  beq cr6, 0x822ecf90
	if ctx.cr[6].eq {
	pc = 0x822ECF90; continue 'dispatch;
	}
	// 822ECF88: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822ECF8C: 48000014  b 0x822ecfa0
	pc = 0x822ECFA0; continue 'dispatch;
            }
            0x822ECF90 => {
    //   block [0x822ECF90..0x822ECFA0)
	// 822ECF90: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ECF94: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822ECF98: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822ECF9C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822ECFA0; continue 'dispatch;
            }
            0x822ECFA0 => {
    //   block [0x822ECFA0..0x822ECFB4)
	// 822ECFA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ECFA4: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 822ECFA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ECFAC: 419A0008  beq cr6, 0x822ecfb4
	if ctx.cr[6].eq {
	pc = 0x822ECFB4; continue 'dispatch;
	}
	// 822ECFB0: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822ECFB4; continue 'dispatch;
            }
            0x822ECFB4 => {
    //   block [0x822ECFB4..0x822ED064)
	// 822ECFB4: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 822ECFB8: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 822ECFBC: 38A000A0  li r5, 0xa0
	ctx.r[5].s64 = 160;
	// 822ECFC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822ECFC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ECFC8: 93EB3BCC  stw r31, 0x3bcc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(15308 as u32), ctx.r[31].u32 ) };
	// 822ECFCC: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 822ECFD0: 938B3BB8  stw r28, 0x3bb8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(15288 as u32), ctx.r[28].u32 ) };
	// 822ECFD4: 3960000A  li r11, 0xa
	ctx.r[11].s64 = 10;
	// 822ECFD8: 916A3BD0  stw r11, 0x3bd0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15312 as u32), ctx.r[11].u32 ) };
	// 822ECFDC: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 822ECFE0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 822ECFE4: 916A3BD4  stw r11, 0x3bd4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15316 as u32), ctx.r[11].u32 ) };
	// 822ECFE8: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 822ECFEC: 93EB3BC8  stw r31, 0x3bc8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(15304 as u32), ctx.r[31].u32 ) };
	// 822ECFF0: 482481E1  bl 0x825351d0
	ctx.lr = 0x822ECFF4;
	sub_825351D0(ctx, base);
	// 822ECFF4: 3D60829F  lis r11, -0x7d61
	ctx.r[11].s64 = -2103508992;
	// 822ECFF8: 393F00AF  addi r9, r31, 0xaf
	ctx.r[9].s64 = ctx.r[31].s64 + 175;
	// 822ECFFC: 386BB50C  addi r3, r11, -0x4af4
	ctx.r[3].s64 = ctx.r[11].s64 + -19188;
	// 822ED000: 552B0036  rlwinm r11, r9, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 822ED004: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 822ED008: 3CE08311  lis r7, -0x7cef
	ctx.r[7].s64 = -2096037888;
	// 822ED00C: 3D00822F  lis r8, -0x7dd1
	ctx.r[8].s64 = -2110849024;
	// 822ED010: 3D20822F  lis r9, -0x7dd1
	ctx.r[9].s64 = -2110849024;
	// 822ED014: 916A3BC0  stw r11, 0x3bc0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15296 as u32), ctx.r[11].u32 ) };
	// 822ED018: 7D6BE050  subf r11, r11, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 822ED01C: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 822ED020: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 822ED024: 916A3BB4  stw r11, 0x3bb4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15284 as u32), ctx.r[11].u32 ) };
	// 822ED028: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 822ED02C: 91473BC4  stw r10, 0x3bc4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(15300 as u32), ctx.r[10].u32 ) };
	// 822ED030: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 822ED034: 916A3BB0  stw r11, 0x3bb0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15280 as u32), ctx.r[11].u32 ) };
	// 822ED038: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 822ED03C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822ED040: 916A3BBC  stw r11, 0x3bbc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15292 as u32), ctx.r[11].u32 ) };
	// 822ED044: 3968CE10  addi r11, r8, -0x31f0
	ctx.r[11].s64 = ctx.r[8].s64 + -12784;
	// 822ED048: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822ED04C: 3969CE28  addi r11, r9, -0x31d8
	ctx.r[11].s64 = ctx.r[9].s64 + -12760;
	// 822ED050: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822ED054: 4809FAE5  bl 0x8238cb38
	ctx.lr = 0x822ED058;
	sub_8238CB38(ctx, base);
	// 822ED058: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822ED05C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822ED060: 482480A8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ED068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ED068 size=200
    let mut pc: u32 = 0x822ED068;
    'dispatch: loop {
        match pc {
            0x822ED068 => {
    //   block [0x822ED068..0x822ED0B4)
	// 822ED068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ED06C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822ED070: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822ED074: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822ED078: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ED07C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822ED080: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822ED084: 396BC5F0  addi r11, r11, -0x3a10
	ctx.r[11].s64 = ctx.r[11].s64 + -14864;
	// 822ED088: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822ED08C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822ED090: 4809FBF1  bl 0x8238cc80
	ctx.lr = 0x822ED094;
	sub_8238CC80(ctx, base);
	// 822ED094: 397F018C  addi r11, r31, 0x18c
	ctx.r[11].s64 = ctx.r[31].s64 + 396;
	// 822ED098: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822ED09C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822ED0A0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ED0A4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822ED0A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822ED0AC: 419A0008  beq cr6, 0x822ed0b4
	if ctx.cr[6].eq {
	pc = 0x822ED0B4; continue 'dispatch;
	}
	// 822ED0B0: 4BE2FFA9  bl 0x8211d058
	ctx.lr = 0x822ED0B4;
	sub_8211D058(ctx, base);
	pc = 0x822ED0B4; continue 'dispatch;
            }
            0x822ED0B4 => {
    //   block [0x822ED0B4..0x822ED0CC)
	// 822ED0B4: 387F0250  addi r3, r31, 0x250
	ctx.r[3].s64 = ctx.r[31].s64 + 592;
	// 822ED0B8: 480484E9  bl 0x823355a0
	ctx.lr = 0x822ED0BC;
	sub_823355A0(ctx, base);
	// 822ED0BC: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 822ED0C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822ED0C4: 419A0008  beq cr6, 0x822ed0cc
	if ctx.cr[6].eq {
	pc = 0x822ED0CC; continue 'dispatch;
	}
	// 822ED0C8: 4BE2FF91  bl 0x8211d058
	ctx.lr = 0x822ED0CC;
	sub_8211D058(ctx, base);
	pc = 0x822ED0CC; continue 'dispatch;
            }
            0x822ED0CC => {
    //   block [0x822ED0CC..0x822ED0DC)
	// 822ED0CC: 807F0184  lwz r3, 0x184(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 822ED0D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822ED0D4: 419A0008  beq cr6, 0x822ed0dc
	if ctx.cr[6].eq {
	pc = 0x822ED0DC; continue 'dispatch;
	}
	// 822ED0D8: 4BE2FF81  bl 0x8211d058
	ctx.lr = 0x822ED0DC;
	sub_8211D058(ctx, base);
	pc = 0x822ED0DC; continue 'dispatch;
            }
            0x822ED0DC => {
    //   block [0x822ED0DC..0x822ED118)
	// 822ED0DC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822ED0E0: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 822ED0E4: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 822ED0E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ED0EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED0F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822ED0F4: 419A0024  beq cr6, 0x822ed118
	if ctx.cr[6].eq {
	pc = 0x822ED118; continue 'dispatch;
	}
	// 822ED0F8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 822ED0FC: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 822ED100: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822ED104: 409A0014  bne cr6, 0x822ed118
	if !ctx.cr[6].eq {
	pc = 0x822ED118; continue 'dispatch;
	}
	// 822ED108: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 822ED10C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822ED110: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 822ED114: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x822ED118; continue 'dispatch;
            }
            0x822ED118 => {
    //   block [0x822ED118..0x822ED130)
	// 822ED118: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822ED11C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ED120: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ED124: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822ED128: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822ED12C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ED130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ED130 size=188
    let mut pc: u32 = 0x822ED130;
    'dispatch: loop {
        match pc {
            0x822ED130 => {
    //   block [0x822ED130..0x822ED164)
	// 822ED130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ED134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822ED138: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822ED13C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ED140: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 822ED144: 3BEBE540  addi r31, r11, -0x1ac0
	ctx.r[31].s64 = ctx.r[11].s64 + -6848;
	// 822ED148: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ED14C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822ED150: 419A0014  beq cr6, 0x822ed164
	if ctx.cr[6].eq {
	pc = 0x822ED164; continue 'dispatch;
	}
	// 822ED154: 81430030  lwz r10, 0x30(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822ED158: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED15C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822ED160: 419A0060  beq cr6, 0x822ed1c0
	if ctx.cr[6].eq {
	pc = 0x822ED1C0; continue 'dispatch;
	}
	pc = 0x822ED164; continue 'dispatch;
            }
            0x822ED164 => {
    //   block [0x822ED164..0x822ED194)
	// 822ED164: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822ED168: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822ED16C: 38EBC3EC  addi r7, r11, -0x3c14
	ctx.r[7].s64 = ctx.r[11].s64 + -15380;
	// 822ED170: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 822ED174: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822ED178: 38600260  li r3, 0x260
	ctx.r[3].s64 = 608;
	// 822ED17C: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 822ED180: 4807D311  bl 0x8236a490
	ctx.lr = 0x822ED184;
	sub_8236A490(ctx, base);
	// 822ED184: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822ED188: 419A000C  beq cr6, 0x822ed194
	if ctx.cr[6].eq {
	pc = 0x822ED194; continue 'dispatch;
	}
	// 822ED18C: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822ED190: 48000008  b 0x822ed198
	pc = 0x822ED198; continue 'dispatch;
            }
            0x822ED194 => {
    //   block [0x822ED194..0x822ED198)
	// 822ED194: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822ED198; continue 'dispatch;
            }
            0x822ED198 => {
    //   block [0x822ED198..0x822ED1B0)
	// 822ED198: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822ED19C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822ED1A0: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 822ED1A4: 419A000C  beq cr6, 0x822ed1b0
	if ctx.cr[6].eq {
	pc = 0x822ED1B0; continue 'dispatch;
	}
	// 822ED1A8: 4BFFFD31  bl 0x822eced8
	ctx.lr = 0x822ED1AC;
	sub_822ECED8(ctx, base);
	// 822ED1AC: 48000008  b 0x822ed1b4
	pc = 0x822ED1B4; continue 'dispatch;
            }
            0x822ED1B0 => {
    //   block [0x822ED1B0..0x822ED1B4)
	// 822ED1B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822ED1B4; continue 'dispatch;
            }
            0x822ED1B4 => {
    //   block [0x822ED1B4..0x822ED1C0)
	// 822ED1B4: 48002095  bl 0x822ef248
	ctx.lr = 0x822ED1B8;
	sub_822EF248(ctx, base);
	// 822ED1B8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ED1BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822ED1C0; continue 'dispatch;
            }
            0x822ED1C0 => {
    //   block [0x822ED1C0..0x822ED1D4)
	// 822ED1C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822ED1C4: 419A0010  beq cr6, 0x822ed1d4
	if ctx.cr[6].eq {
	pc = 0x822ED1D4; continue 'dispatch;
	}
	// 822ED1C8: 81430030  lwz r10, 0x30(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822ED1CC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822ED1D0: 419A0008  beq cr6, 0x822ed1d8
	if ctx.cr[6].eq {
	pc = 0x822ED1D8; continue 'dispatch;
	}
	pc = 0x822ED1D4; continue 'dispatch;
            }
            0x822ED1D4 => {
    //   block [0x822ED1D4..0x822ED1D8)
	// 822ED1D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822ED1D8; continue 'dispatch;
            }
            0x822ED1D8 => {
    //   block [0x822ED1D8..0x822ED1EC)
	// 822ED1D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822ED1DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ED1E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ED1E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822ED1E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ED1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ED1F0 size=120
    let mut pc: u32 = 0x822ED1F0;
    'dispatch: loop {
        match pc {
            0x822ED1F0 => {
    //   block [0x822ED1F0..0x822ED218)
	// 822ED1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ED1F4: 48247EC1  bl 0x825350b4
	ctx.lr = 0x822ED1F8;
	sub_82535080(ctx, base);
	// 822ED1F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ED1FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822ED200: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 822ED204: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822ED208: 839D01A4  lwz r28, 0x1a4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(420 as u32) ) } as u64;
	// 822ED20C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822ED210: 40990038  ble cr6, 0x822ed248
	if !ctx.cr[6].gt {
	pc = 0x822ED248; continue 'dispatch;
	}
	// 822ED214: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x822ED218; continue 'dispatch;
            }
            0x822ED218 => {
    //   block [0x822ED218..0x822ED248)
	// 822ED218: 817D01A0  lwz r11, 0x1a0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(416 as u32) ) } as u64;
	// 822ED21C: 7C7F582E  lwzx r3, r31, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822ED220: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED224: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822ED228: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED22C: 4E800421  bctrl
	ctx.lr = 0x822ED230;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED230: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822ED234: 419A0020  beq cr6, 0x822ed254
	if ctx.cr[6].eq {
	pc = 0x822ED254; continue 'dispatch;
	}
	// 822ED238: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822ED23C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822ED240: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 822ED244: 4198FFD4  blt cr6, 0x822ed218
	if ctx.cr[6].lt {
	pc = 0x822ED218; continue 'dispatch;
	}
            }
            0x822ED248 => {
    //   block [0x822ED248..0x822ED254)
	// 822ED248: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822ED24C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822ED250: 48247EB4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x822ED254 => {
    //   block [0x822ED254..0x822ED268)
	// 822ED254: 817D01A0  lwz r11, 0x1a0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(416 as u32) ) } as u64;
	// 822ED258: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822ED25C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822ED260: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822ED264: 48247EA0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ED268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ED268 size=488
    let mut pc: u32 = 0x822ED268;
    'dispatch: loop {
        match pc {
            0x822ED268 => {
    //   block [0x822ED268..0x822ED3C4)
	// 822ED268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ED26C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822ED270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822ED274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822ED278: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ED27C: 816301DC  lwz r11, 0x1dc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(476 as u32) ) } as u64;
	// 822ED280: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822ED284: 814301F4  lwz r10, 0x1f4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(500 as u32) ) } as u64;
	// 822ED288: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822ED28C: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 822ED290: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822ED294: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 822ED298: 81430200  lwz r10, 0x200(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(512 as u32) ) } as u64;
	// 822ED29C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 822ED2A0: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 822ED2A4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822ED2A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822ED2AC: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 822ED2B0: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 822ED2B4: 8163023C  lwz r11, 0x23c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(572 as u32) ) } as u64;
	// 822ED2B8: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 822ED2BC: 81430218  lwz r10, 0x218(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(536 as u32) ) } as u64;
	// 822ED2C0: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 822ED2C4: 81630248  lwz r11, 0x248(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(584 as u32) ) } as u64;
	// 822ED2C8: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 822ED2CC: 81430224  lwz r10, 0x224(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(548 as u32) ) } as u64;
	// 822ED2D0: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 822ED2D4: 816301E0  lwz r11, 0x1e0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(480 as u32) ) } as u64;
	// 822ED2D8: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 822ED2DC: 81430230  lwz r10, 0x230(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(560 as u32) ) } as u64;
	// 822ED2E0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 822ED2E4: 816301F8  lwz r11, 0x1f8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(504 as u32) ) } as u64;
	// 822ED2E8: 9141009C  stw r10, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 822ED2EC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 822ED2F0: 81630204  lwz r11, 0x204(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(516 as u32) ) } as u64;
	// 822ED2F4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 822ED2F8: 8163021C  lwz r11, 0x21c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(540 as u32) ) } as u64;
	// 822ED2FC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 822ED300: 81630228  lwz r11, 0x228(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(552 as u32) ) } as u64;
	// 822ED304: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 822ED308: 81630234  lwz r11, 0x234(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(564 as u32) ) } as u64;
	// 822ED30C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 822ED310: 81630240  lwz r11, 0x240(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(576 as u32) ) } as u64;
	// 822ED314: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822ED318: 8163024C  lwz r11, 0x24c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(588 as u32) ) } as u64;
	// 822ED31C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 822ED320: 816301D8  lwz r11, 0x1d8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(472 as u32) ) } as u64;
	// 822ED324: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 822ED328: 816301F0  lwz r11, 0x1f0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(496 as u32) ) } as u64;
	// 822ED32C: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 822ED330: 816301FC  lwz r11, 0x1fc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 822ED334: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 822ED338: 81630214  lwz r11, 0x214(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(532 as u32) ) } as u64;
	// 822ED33C: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 822ED340: 81630220  lwz r11, 0x220(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(544 as u32) ) } as u64;
	// 822ED344: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 822ED348: 8163022C  lwz r11, 0x22c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(556 as u32) ) } as u64;
	// 822ED34C: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 822ED350: 81630238  lwz r11, 0x238(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(568 as u32) ) } as u64;
	// 822ED354: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 822ED358: 81630244  lwz r11, 0x244(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(580 as u32) ) } as u64;
	// 822ED35C: 916100D4  stw r11, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 822ED360: 419A00D4  beq cr6, 0x822ed434
	if ctx.cr[6].eq {
	pc = 0x822ED434; continue 'dispatch;
	}
	// 822ED364: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED36C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ED370: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED374: 4E800421  bctrl
	ctx.lr = 0x822ED378;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED378: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED37C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822ED380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED384: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ED388: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED38C: 4E800421  bctrl
	ctx.lr = 0x822ED390;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED390: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 822ED394: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED39C: 41980028  blt cr6, 0x822ed3c4
	if ctx.cr[6].lt {
	pc = 0x822ED3C4; continue 'dispatch;
	}
	// 822ED3A0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ED3A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED3A8: 4E800421  bctrl
	ctx.lr = 0x822ED3AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED3AC: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ED3B0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822ED3B4: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822ED3B8: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822ED3BC: 7C69582E  lwzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822ED3C0: 48000078  b 0x822ed438
	pc = 0x822ED438; continue 'dispatch;
            }
            0x822ED3C4 => {
    //   block [0x822ED3C4..0x822ED434)
	// 822ED3C4: 57DE103A  slwi r30, r30, 2
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 822ED3C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED3CC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 822ED3D0: 7FFE502E  lwzx r31, r30, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822ED3D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED3D8: 4E800421  bctrl
	ctx.lr = 0x822ED3DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED3DC: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 822ED3E0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822ED3E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED3E8: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822ED3EC: 480039F5  bl 0x822f0de0
	ctx.lr = 0x822ED3F0;
	sub_822F0DE0(ctx, base);
	// 822ED3F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822ED3F4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 822ED3F8: 4198003C  blt cr6, 0x822ed434
	if ctx.cr[6].lt {
	pc = 0x822ED434; continue 'dispatch;
	}
	// 822ED3FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED400: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED404: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ED408: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED40C: 4E800421  bctrl
	ctx.lr = 0x822ED410;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED410: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED414: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ED418: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED41C: 4E800421  bctrl
	ctx.lr = 0x822ED420;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED420: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822ED424: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822ED428: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822ED42C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822ED430: 48000008  b 0x822ed438
	pc = 0x822ED438; continue 'dispatch;
            }
            0x822ED434 => {
    //   block [0x822ED434..0x822ED438)
	// 822ED434: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822ED438; continue 'dispatch;
            }
            0x822ED438 => {
    //   block [0x822ED438..0x822ED450)
	// 822ED438: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 822ED43C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ED440: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ED444: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822ED448: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822ED44C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ED450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ED450 size=316
    let mut pc: u32 = 0x822ED450;
    'dispatch: loop {
        match pc {
            0x822ED450 => {
    //   block [0x822ED450..0x822ED570)
	// 822ED450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ED454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822ED458: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822ED45C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822ED460: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ED464: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822ED468: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822ED46C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822ED470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED474: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822ED478: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822ED47C: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 822ED480: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 822ED484: 814B0218  lwz r10, 0x218(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(536 as u32) ) } as u64;
	// 822ED488: 810B01DC  lwz r8, 0x1dc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(476 as u32) ) } as u64;
	// 822ED48C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED490: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822ED494: 814B0224  lwz r10, 0x224(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(548 as u32) ) } as u64;
	// 822ED498: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 822ED49C: 810B01F4  lwz r8, 0x1f4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(500 as u32) ) } as u64;
	// 822ED4A0: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 822ED4A4: 814B0230  lwz r10, 0x230(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(560 as u32) ) } as u64;
	// 822ED4A8: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 822ED4AC: 810B0200  lwz r8, 0x200(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(512 as u32) ) } as u64;
	// 822ED4B0: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 822ED4B4: 814B023C  lwz r10, 0x23c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(572 as u32) ) } as u64;
	// 822ED4B8: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 822ED4BC: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 822ED4C0: 814B0248  lwz r10, 0x248(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(584 as u32) ) } as u64;
	// 822ED4C4: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 822ED4C8: 814B01D8  lwz r10, 0x1d8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(472 as u32) ) } as u64;
	// 822ED4CC: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 822ED4D0: 814B01F0  lwz r10, 0x1f0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(496 as u32) ) } as u64;
	// 822ED4D4: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 822ED4D8: 814B01FC  lwz r10, 0x1fc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(508 as u32) ) } as u64;
	// 822ED4DC: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 822ED4E0: 814B0214  lwz r10, 0x214(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(532 as u32) ) } as u64;
	// 822ED4E4: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 822ED4E8: 814B0220  lwz r10, 0x220(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(544 as u32) ) } as u64;
	// 822ED4EC: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 822ED4F0: 814B022C  lwz r10, 0x22c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(556 as u32) ) } as u64;
	// 822ED4F4: 9141009C  stw r10, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 822ED4F8: 814B0238  lwz r10, 0x238(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(568 as u32) ) } as u64;
	// 822ED4FC: 816B0244  lwz r11, 0x244(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(580 as u32) ) } as u64;
	// 822ED500: 914100A0  stw r10, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 822ED504: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 822ED508: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ED50C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED510: 4E800421  bctrl
	ctx.lr = 0x822ED514;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED514: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822ED518: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED51C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED520: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 822ED524: 557F103A  slwi r31, r11, 2
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822ED528: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED52C: 7FDF482E  lwzx r30, r31, r9
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822ED530: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822ED534: 4E800421  bctrl
	ctx.lr = 0x822ED538;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED538: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 822ED53C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822ED540: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822ED544: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822ED548: 48003899  bl 0x822f0de0
	ctx.lr = 0x822ED54C;
	sub_822F0DE0(ctx, base);
	// 822ED54C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822ED550: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 822ED554: 4198001C  blt cr6, 0x822ed570
	if ctx.cr[6].lt {
	pc = 0x822ED570; continue 'dispatch;
	}
	// 822ED558: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED55C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822ED560: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ED564: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED568: 4E800421  bctrl
	ctx.lr = 0x822ED56C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED56C: 48000008  b 0x822ed574
	pc = 0x822ED574; continue 'dispatch;
            }
            0x822ED570 => {
    //   block [0x822ED570..0x822ED574)
	// 822ED570: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822ED574; continue 'dispatch;
            }
            0x822ED574 => {
    //   block [0x822ED574..0x822ED58C)
	// 822ED574: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822ED578: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ED57C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ED580: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822ED584: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822ED588: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ED590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ED590 size=524
    let mut pc: u32 = 0x822ED590;
    'dispatch: loop {
        match pc {
            0x822ED590 => {
    //   block [0x822ED590..0x822ED610)
	// 822ED590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ED594: 48247B1D  bl 0x825350b0
	ctx.lr = 0x822ED598;
	sub_82535080(ctx, base);
	// 822ED598: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ED59C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822ED5A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822ED5A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822ED5A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822ED5AC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED5B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ED5B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED5B8: 4E800421  bctrl
	ctx.lr = 0x822ED5BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED5BC: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 822ED5C0: 419A0134  beq cr6, 0x822ed6f4
	if ctx.cr[6].eq {
	pc = 0x822ED6F4; continue 'dispatch;
	}
	// 822ED5C4: 2F030006  cmpwi cr6, r3, 6
	ctx.cr[6].compare_i32(ctx.r[3].s32, 6, &mut ctx.xer);
	// 822ED5C8: 419A009C  beq cr6, 0x822ed664
	if ctx.cr[6].eq {
	pc = 0x822ED664; continue 'dispatch;
	}
	// 822ED5CC: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 822ED5D0: 409A01C0  bne cr6, 0x822ed790
	if !ctx.cr[6].eq {
	pc = 0x822ED790; continue 'dispatch;
	}
	// 822ED5D4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED5D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822ED5DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED5E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED5E4: 4E800421  bctrl
	ctx.lr = 0x822ED5E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED5E8: 83BF023C  lwz r29, 0x23c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 822ED5EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822ED5F0: 419A0124  beq cr6, 0x822ed714
	if ctx.cr[6].eq {
	pc = 0x822ED714; continue 'dispatch;
	}
	// 822ED5F4: 839F0238  lwz r28, 0x238(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 822ED5F8: 547E002E  rlwinm r30, r3, 0, 0, 0x17
	ctx.r[30].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 822ED5FC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822ED600: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822ED604: 3B7E00FF  addi r27, r30, 0xff
	ctx.r[27].s64 = ctx.r[30].s64 + 255;
	// 822ED608: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822ED60C: 4099004C  ble cr6, 0x822ed658
	if !ctx.cr[6].gt {
	pc = 0x822ED658; continue 'dispatch;
	}
            }
            0x822ED610 => {
    //   block [0x822ED610..0x822ED64C)
	// 822ED610: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED614: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822ED618: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822ED61C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ED620: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED624: 4E800421  bctrl
	ctx.lr = 0x822ED628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED628: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED62C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED630: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED634: 4E800421  bctrl
	ctx.lr = 0x822ED638;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED638: 7F03F000  cmpw cr6, r3, r30
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822ED63C: 41980010  blt cr6, 0x822ed64c
	if ctx.cr[6].lt {
	pc = 0x822ED64C; continue 'dispatch;
	}
	// 822ED640: 7F03D800  cmpw cr6, r3, r27
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[27].s32, &mut ctx.xer);
	// 822ED644: 40980008  bge cr6, 0x822ed64c
	if !ctx.cr[6].lt {
	pc = 0x822ED64C; continue 'dispatch;
	}
	// 822ED648: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
            }
            0x822ED64C => {
    //   block [0x822ED64C..0x822ED658)
	// 822ED64C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822ED650: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 822ED654: 4198FFBC  blt cr6, 0x822ed610
	if ctx.cr[6].lt {
	pc = 0x822ED610; continue 'dispatch;
	}
	pc = 0x822ED658; continue 'dispatch;
            }
            0x822ED658 => {
    //   block [0x822ED658..0x822ED664)
	// 822ED658: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822ED65C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822ED660: 48247AA0  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822ED664 => {
    //   block [0x822ED664..0x822ED6A0)
	// 822ED664: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED668: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822ED66C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED670: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED674: 4E800421  bctrl
	ctx.lr = 0x822ED678;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED678: 83BF0224  lwz r29, 0x224(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 822ED67C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822ED680: 419A0094  beq cr6, 0x822ed714
	if ctx.cr[6].eq {
	pc = 0x822ED714; continue 'dispatch;
	}
	// 822ED684: 839F0220  lwz r28, 0x220(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 822ED688: 547E002E  rlwinm r30, r3, 0, 0, 0x17
	ctx.r[30].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 822ED68C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822ED690: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822ED694: 3B7E00FF  addi r27, r30, 0xff
	ctx.r[27].s64 = ctx.r[30].s64 + 255;
	// 822ED698: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822ED69C: 4099004C  ble cr6, 0x822ed6e8
	if !ctx.cr[6].gt {
	pc = 0x822ED6E8; continue 'dispatch;
	}
            }
            0x822ED6A0 => {
    //   block [0x822ED6A0..0x822ED6DC)
	// 822ED6A0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED6A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822ED6A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822ED6AC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ED6B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED6B4: 4E800421  bctrl
	ctx.lr = 0x822ED6B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED6B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED6BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED6C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED6C4: 4E800421  bctrl
	ctx.lr = 0x822ED6C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED6C8: 7F03F000  cmpw cr6, r3, r30
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822ED6CC: 41980010  blt cr6, 0x822ed6dc
	if ctx.cr[6].lt {
	pc = 0x822ED6DC; continue 'dispatch;
	}
	// 822ED6D0: 7F03D800  cmpw cr6, r3, r27
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[27].s32, &mut ctx.xer);
	// 822ED6D4: 40980008  bge cr6, 0x822ed6dc
	if !ctx.cr[6].lt {
	pc = 0x822ED6DC; continue 'dispatch;
	}
	// 822ED6D8: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
            }
            0x822ED6DC => {
    //   block [0x822ED6DC..0x822ED6E8)
	// 822ED6DC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822ED6E0: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 822ED6E4: 4198FFBC  blt cr6, 0x822ed6a0
	if ctx.cr[6].lt {
	pc = 0x822ED6A0; continue 'dispatch;
	}
	pc = 0x822ED6E8; continue 'dispatch;
            }
            0x822ED6E8 => {
    //   block [0x822ED6E8..0x822ED6F4)
	// 822ED6E8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822ED6EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822ED6F0: 48247A10  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822ED6F4 => {
    //   block [0x822ED6F4..0x822ED714)
	// 822ED6F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED6F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822ED6FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED700: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED704: 4E800421  bctrl
	ctx.lr = 0x822ED708;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED708: 83BF0200  lwz r29, 0x200(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 822ED70C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822ED710: 409A0010  bne cr6, 0x822ed720
	if !ctx.cr[6].eq {
	pc = 0x822ED720; continue 'dispatch;
	}
            }
            0x822ED714 => {
    //   block [0x822ED714..0x822ED720)
	// 822ED714: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822ED718: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822ED71C: 482479E4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822ED720 => {
    //   block [0x822ED720..0x822ED73C)
	// 822ED720: 839F01FC  lwz r28, 0x1fc(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 822ED724: 547E002E  rlwinm r30, r3, 0, 0, 0x17
	ctx.r[30].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 822ED728: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822ED72C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822ED730: 3B7E00FF  addi r27, r30, 0xff
	ctx.r[27].s64 = ctx.r[30].s64 + 255;
	// 822ED734: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822ED738: 4099004C  ble cr6, 0x822ed784
	if !ctx.cr[6].gt {
	pc = 0x822ED784; continue 'dispatch;
	}
	pc = 0x822ED73C; continue 'dispatch;
            }
            0x822ED73C => {
    //   block [0x822ED73C..0x822ED778)
	// 822ED73C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED740: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822ED744: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822ED748: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ED74C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED750: 4E800421  bctrl
	ctx.lr = 0x822ED754;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED754: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED758: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED75C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED760: 4E800421  bctrl
	ctx.lr = 0x822ED764;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED764: 7F03F000  cmpw cr6, r3, r30
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822ED768: 41980010  blt cr6, 0x822ed778
	if ctx.cr[6].lt {
	pc = 0x822ED778; continue 'dispatch;
	}
	// 822ED76C: 7F03D800  cmpw cr6, r3, r27
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[27].s32, &mut ctx.xer);
	// 822ED770: 40980008  bge cr6, 0x822ed778
	if !ctx.cr[6].lt {
	pc = 0x822ED778; continue 'dispatch;
	}
	// 822ED774: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
            }
            0x822ED778 => {
    //   block [0x822ED778..0x822ED784)
	// 822ED778: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822ED77C: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 822ED780: 4198FFBC  blt cr6, 0x822ed73c
	if ctx.cr[6].lt {
	pc = 0x822ED73C; continue 'dispatch;
	}
	pc = 0x822ED784; continue 'dispatch;
            }
            0x822ED784 => {
    //   block [0x822ED784..0x822ED790)
	// 822ED784: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822ED788: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822ED78C: 48247974  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822ED790 => {
    //   block [0x822ED790..0x822ED79C)
	// 822ED790: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822ED794: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822ED798: 48247968  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ED7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ED7A0 size=332
    let mut pc: u32 = 0x822ED7A0;
    'dispatch: loop {
        match pc {
            0x822ED7A0 => {
    //   block [0x822ED7A0..0x822ED860)
	// 822ED7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ED7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822ED7A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822ED7AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822ED7B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ED7B4: 816301E8  lwz r11, 0x1e8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(488 as u32) ) } as u64;
	// 822ED7B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822ED7BC: 8143020C  lwz r10, 0x20c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(524 as u32) ) } as u64;
	// 822ED7C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822ED7C4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 822ED7C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822ED7CC: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 822ED7D0: 814301EC  lwz r10, 0x1ec(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(492 as u32) ) } as u64;
	// 822ED7D4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 822ED7D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822ED7DC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822ED7E0: 81630210  lwz r11, 0x210(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(528 as u32) ) } as u64;
	// 822ED7E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822ED7E8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 822ED7EC: 816301E4  lwz r11, 0x1e4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(484 as u32) ) } as u64;
	// 822ED7F0: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 822ED7F4: 81630208  lwz r11, 0x208(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(520 as u32) ) } as u64;
	// 822ED7F8: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 822ED7FC: 419A00D4  beq cr6, 0x822ed8d0
	if ctx.cr[6].eq {
	pc = 0x822ED8D0; continue 'dispatch;
	}
	// 822ED800: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED808: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ED80C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED810: 4E800421  bctrl
	ctx.lr = 0x822ED814;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED814: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED818: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822ED81C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED820: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ED824: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED828: 4E800421  bctrl
	ctx.lr = 0x822ED82C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED82C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 822ED830: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED838: 41980028  blt cr6, 0x822ed860
	if ctx.cr[6].lt {
	pc = 0x822ED860; continue 'dispatch;
	}
	// 822ED83C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ED840: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED844: 4E800421  bctrl
	ctx.lr = 0x822ED848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED848: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ED84C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822ED850: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822ED854: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822ED858: 7C69582E  lwzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822ED85C: 48000078  b 0x822ed8d4
	pc = 0x822ED8D4; continue 'dispatch;
            }
            0x822ED860 => {
    //   block [0x822ED860..0x822ED8D0)
	// 822ED860: 57DE103A  slwi r30, r30, 2
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 822ED864: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED868: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 822ED86C: 7FFE502E  lwzx r31, r30, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822ED870: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED874: 4E800421  bctrl
	ctx.lr = 0x822ED878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED878: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 822ED87C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822ED880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED884: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822ED888: 48003559  bl 0x822f0de0
	ctx.lr = 0x822ED88C;
	sub_822F0DE0(ctx, base);
	// 822ED88C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822ED890: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 822ED894: 4198003C  blt cr6, 0x822ed8d0
	if ctx.cr[6].lt {
	pc = 0x822ED8D0; continue 'dispatch;
	}
	// 822ED898: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED89C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED8A0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ED8A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED8A8: 4E800421  bctrl
	ctx.lr = 0x822ED8AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED8AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED8B0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ED8B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED8B8: 4E800421  bctrl
	ctx.lr = 0x822ED8BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED8BC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822ED8C0: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822ED8C4: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822ED8C8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822ED8CC: 48000008  b 0x822ed8d4
	pc = 0x822ED8D4; continue 'dispatch;
            }
            0x822ED8D0 => {
    //   block [0x822ED8D0..0x822ED8D4)
	// 822ED8D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822ED8D4; continue 'dispatch;
            }
            0x822ED8D4 => {
    //   block [0x822ED8D4..0x822ED8EC)
	// 822ED8D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822ED8D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ED8DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ED8E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822ED8E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822ED8E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ED8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ED8F0 size=212
    let mut pc: u32 = 0x822ED8F0;
    'dispatch: loop {
        match pc {
            0x822ED8F0 => {
    //   block [0x822ED8F0..0x822ED9A8)
	// 822ED8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ED8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822ED8F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822ED8FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822ED900: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ED904: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822ED908: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822ED90C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822ED910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED914: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822ED918: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 822ED91C: 814B020C  lwz r10, 0x20c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(524 as u32) ) } as u64;
	// 822ED920: 810B01E8  lwz r8, 0x1e8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(488 as u32) ) } as u64;
	// 822ED924: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED928: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 822ED92C: 814B01E4  lwz r10, 0x1e4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(484 as u32) ) } as u64;
	// 822ED930: 816B0208  lwz r11, 0x208(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(520 as u32) ) } as u64;
	// 822ED934: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 822ED938: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822ED93C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 822ED940: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ED944: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED948: 4E800421  bctrl
	ctx.lr = 0x822ED94C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED94C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822ED950: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED958: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 822ED95C: 557F103A  slwi r31, r11, 2
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822ED960: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED964: 7FDF482E  lwzx r30, r31, r9
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822ED968: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822ED96C: 4E800421  bctrl
	ctx.lr = 0x822ED970;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED970: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 822ED974: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822ED978: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822ED97C: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822ED980: 48003461  bl 0x822f0de0
	ctx.lr = 0x822ED984;
	sub_822F0DE0(ctx, base);
	// 822ED984: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822ED988: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 822ED98C: 4198001C  blt cr6, 0x822ed9a8
	if ctx.cr[6].lt {
	pc = 0x822ED9A8; continue 'dispatch;
	}
	// 822ED990: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED994: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822ED998: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ED99C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED9A0: 4E800421  bctrl
	ctx.lr = 0x822ED9A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED9A4: 48000008  b 0x822ed9ac
	pc = 0x822ED9AC; continue 'dispatch;
            }
            0x822ED9A8 => {
    //   block [0x822ED9A8..0x822ED9AC)
	// 822ED9A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822ED9AC; continue 'dispatch;
            }
            0x822ED9AC => {
    //   block [0x822ED9AC..0x822ED9C4)
	// 822ED9AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822ED9B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ED9B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ED9B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822ED9BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822ED9C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ED9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ED9C8 size=372
    let mut pc: u32 = 0x822ED9C8;
    'dispatch: loop {
        match pc {
            0x822ED9C8 => {
    //   block [0x822ED9C8..0x822EDA40)
	// 822ED9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ED9CC: 482476E5  bl 0x825350b0
	ctx.lr = 0x822ED9D0;
	sub_82535080(ctx, base);
	// 822ED9D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ED9D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822ED9D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822ED9DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822ED9E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ED9E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ED9E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ED9EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ED9F0: 4E800421  bctrl
	ctx.lr = 0x822ED9F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ED9F4: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 822ED9F8: 419A009C  beq cr6, 0x822eda94
	if ctx.cr[6].eq {
	pc = 0x822EDA94; continue 'dispatch;
	}
	// 822ED9FC: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 822EDA00: 409A0130  bne cr6, 0x822edb30
	if !ctx.cr[6].eq {
	pc = 0x822EDB30; continue 'dispatch;
	}
	// 822EDA04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDA08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EDA0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDA10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EDA14: 4E800421  bctrl
	ctx.lr = 0x822EDA18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EDA18: 83BE020C  lwz r29, 0x20c(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(524 as u32) ) } as u64;
	// 822EDA1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822EDA20: 419A0094  beq cr6, 0x822edab4
	if ctx.cr[6].eq {
	pc = 0x822EDAB4; continue 'dispatch;
	}
	// 822EDA24: 839E0208  lwz r28, 0x208(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(520 as u32) ) } as u64;
	// 822EDA28: 547E002E  rlwinm r30, r3, 0, 0, 0x17
	ctx.r[30].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 822EDA2C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822EDA30: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822EDA34: 3B7E00FF  addi r27, r30, 0xff
	ctx.r[27].s64 = ctx.r[30].s64 + 255;
	// 822EDA38: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822EDA3C: 4099004C  ble cr6, 0x822eda88
	if !ctx.cr[6].gt {
	pc = 0x822EDA88; continue 'dispatch;
	}
            }
            0x822EDA40 => {
    //   block [0x822EDA40..0x822EDA7C)
	// 822EDA40: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDA44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EDA48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822EDA4C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EDA50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EDA54: 4E800421  bctrl
	ctx.lr = 0x822EDA58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EDA58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDA5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDA60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EDA64: 4E800421  bctrl
	ctx.lr = 0x822EDA68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EDA68: 7F03F000  cmpw cr6, r3, r30
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822EDA6C: 41980010  blt cr6, 0x822eda7c
	if ctx.cr[6].lt {
	pc = 0x822EDA7C; continue 'dispatch;
	}
	// 822EDA70: 7F03D800  cmpw cr6, r3, r27
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[27].s32, &mut ctx.xer);
	// 822EDA74: 40980008  bge cr6, 0x822eda7c
	if !ctx.cr[6].lt {
	pc = 0x822EDA7C; continue 'dispatch;
	}
	// 822EDA78: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
            }
            0x822EDA7C => {
    //   block [0x822EDA7C..0x822EDA88)
	// 822EDA7C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822EDA80: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 822EDA84: 4198FFBC  blt cr6, 0x822eda40
	if ctx.cr[6].lt {
	pc = 0x822EDA40; continue 'dispatch;
	}
	pc = 0x822EDA88; continue 'dispatch;
            }
            0x822EDA88 => {
    //   block [0x822EDA88..0x822EDA94)
	// 822EDA88: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822EDA8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EDA90: 48247670  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822EDA94 => {
    //   block [0x822EDA94..0x822EDAB4)
	// 822EDA94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDA98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EDA9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDAA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EDAA4: 4E800421  bctrl
	ctx.lr = 0x822EDAA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EDAA8: 83BE01E8  lwz r29, 0x1e8(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(488 as u32) ) } as u64;
	// 822EDAAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822EDAB0: 409A0010  bne cr6, 0x822edac0
	if !ctx.cr[6].eq {
	pc = 0x822EDAC0; continue 'dispatch;
	}
            }
            0x822EDAB4 => {
    //   block [0x822EDAB4..0x822EDAC0)
	// 822EDAB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822EDAB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EDABC: 48247644  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822EDAC0 => {
    //   block [0x822EDAC0..0x822EDADC)
	// 822EDAC0: 839E01E4  lwz r28, 0x1e4(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(484 as u32) ) } as u64;
	// 822EDAC4: 547E002E  rlwinm r30, r3, 0, 0, 0x17
	ctx.r[30].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 822EDAC8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822EDACC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822EDAD0: 3B7E00FF  addi r27, r30, 0xff
	ctx.r[27].s64 = ctx.r[30].s64 + 255;
	// 822EDAD4: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822EDAD8: 4099004C  ble cr6, 0x822edb24
	if !ctx.cr[6].gt {
	pc = 0x822EDB24; continue 'dispatch;
	}
	pc = 0x822EDADC; continue 'dispatch;
            }
            0x822EDADC => {
    //   block [0x822EDADC..0x822EDB18)
	// 822EDADC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDAE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EDAE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822EDAE8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EDAEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EDAF0: 4E800421  bctrl
	ctx.lr = 0x822EDAF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EDAF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDAF8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDAFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EDB00: 4E800421  bctrl
	ctx.lr = 0x822EDB04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EDB04: 7F03F000  cmpw cr6, r3, r30
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822EDB08: 41980010  blt cr6, 0x822edb18
	if ctx.cr[6].lt {
	pc = 0x822EDB18; continue 'dispatch;
	}
	// 822EDB0C: 7F03D800  cmpw cr6, r3, r27
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[27].s32, &mut ctx.xer);
	// 822EDB10: 40980008  bge cr6, 0x822edb18
	if !ctx.cr[6].lt {
	pc = 0x822EDB18; continue 'dispatch;
	}
	// 822EDB14: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
            }
            0x822EDB18 => {
    //   block [0x822EDB18..0x822EDB24)
	// 822EDB18: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822EDB1C: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 822EDB20: 4198FFBC  blt cr6, 0x822edadc
	if ctx.cr[6].lt {
	pc = 0x822EDADC; continue 'dispatch;
	}
	pc = 0x822EDB24; continue 'dispatch;
            }
            0x822EDB24 => {
    //   block [0x822EDB24..0x822EDB30)
	// 822EDB24: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822EDB28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EDB2C: 482475D4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822EDB30 => {
    //   block [0x822EDB30..0x822EDB3C)
	// 822EDB30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822EDB34: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EDB38: 482475C8  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EDB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EDB40 size=248
    let mut pc: u32 = 0x822EDB40;
    'dispatch: loop {
        match pc {
            0x822EDB40 => {
    //   block [0x822EDB40..0x822EDB7C)
	// 822EDB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EDB44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EDB48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822EDB4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EDB50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EDB54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EDB58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822EDB5C: 811F01A0  lwz r8, 0x1a0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EDB60: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822EDB64: 419A00BC  beq cr6, 0x822edc20
	if ctx.cr[6].eq {
	pc = 0x822EDC20; continue 'dispatch;
	}
	// 822EDB68: 813F01A4  lwz r9, 0x1a4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EDB6C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822EDB70: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822EDB74: 40990024  ble cr6, 0x822edb98
	if !ctx.cr[6].gt {
	pc = 0x822EDB98; continue 'dispatch;
	}
	// 822EDB78: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x822EDB7C; continue 'dispatch;
            }
            0x822EDB7C => {
    //   block [0x822EDB7C..0x822EDB98)
	// 822EDB7C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDB80: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822EDB84: 419A009C  beq cr6, 0x822edc20
	if ctx.cr[6].eq {
	pc = 0x822EDC20; continue 'dispatch;
	}
	// 822EDB88: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822EDB8C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822EDB90: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 822EDB94: 4198FFE8  blt cr6, 0x822edb7c
	if ctx.cr[6].lt {
	pc = 0x822EDB7C; continue 'dispatch;
	}
	pc = 0x822EDB98; continue 'dispatch;
            }
            0x822EDB98 => {
    //   block [0x822EDB98..0x822EDC08)
	// 822EDB98: 2F09001F  cmpwi cr6, r9, 0x1f
	ctx.cr[6].compare_i32(ctx.r[9].s32, 31, &mut ctx.xer);
	// 822EDB9C: 40980084  bge cr6, 0x822edc20
	if !ctx.cr[6].lt {
	pc = 0x822EDC20; continue 'dispatch;
	}
	// 822EDBA0: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EDBA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EDBA8: 7FCB412E  stwx r30, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[30].u32) };
	// 822EDBAC: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EDBB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822EDBB4: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 822EDBB8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDBBC: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 822EDBC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EDBC4: 4E800421  bctrl
	ctx.lr = 0x822EDBC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EDBC8: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 822EDBCC: 409A0054  bne cr6, 0x822edc20
	if !ctx.cr[6].eq {
	pc = 0x822EDC20; continue 'dispatch;
	}
	// 822EDBD0: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 822EDBD4: 396B006A  addi r11, r11, 0x6a
	ctx.r[11].s64 = ctx.r[11].s64 + 106;
	// 822EDBD8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EDBDC: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822EDBE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EDBE4: 419A0024  beq cr6, 0x822edc08
	if ctx.cr[6].eq {
	pc = 0x822EDC08; continue 'dispatch;
	}
	// 822EDBE8: 815F01C0  lwz r10, 0x1c0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 822EDBEC: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822EDBF0: 394A006C  addi r10, r10, 0x6c
	ctx.r[10].s64 = ctx.r[10].s64 + 108;
	// 822EDBF4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EDBF8: 7D6AF92E  stwx r11, r10, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	// 822EDBFC: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 822EDC00: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822EDC04: 917F01C0  stw r11, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
            }
            0x822EDC08 => {
    //   block [0x822EDC08..0x822EDC20)
	// 822EDC08: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 822EDC0C: 396B006A  addi r11, r11, 0x6a
	ctx.r[11].s64 = ctx.r[11].s64 + 106;
	// 822EDC10: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EDC14: 7FCBF92E  stwx r30, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	// 822EDC18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822EDC1C: 917F01AC  stw r11, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	pc = 0x822EDC20; continue 'dispatch;
            }
            0x822EDC20 => {
    //   block [0x822EDC20..0x822EDC38)
	// 822EDC20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822EDC24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EDC28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EDC2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822EDC30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EDC34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EDC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EDC38 size=252
    let mut pc: u32 = 0x822EDC38;
    'dispatch: loop {
        match pc {
            0x822EDC38 => {
    //   block [0x822EDC38..0x822EDC6C)
	// 822EDC38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EDC3C: 48247481  bl 0x825350bc
	ctx.lr = 0x822EDC40;
	sub_82535080(ctx, base);
	// 822EDC40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EDC44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EDC48: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822EDC4C: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EDC50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EDC54: 419A00D8  beq cr6, 0x822edd2c
	if ctx.cr[6].eq {
	pc = 0x822EDD2C; continue 'dispatch;
	}
	// 822EDC58: 80FF01A4  lwz r7, 0x1a4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EDC5C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822EDC60: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 822EDC64: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 822EDC68: 40990070  ble cr6, 0x822edcd8
	if !ctx.cr[6].gt {
	pc = 0x822EDCD8; continue 'dispatch;
	}
	pc = 0x822EDC6C; continue 'dispatch;
            }
            0x822EDC6C => {
    //   block [0x822EDC6C..0x822EDC94)
	// 822EDC6C: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EDC70: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EDC74: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EDC78: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EDC7C: 409A0050  bne cr6, 0x822edccc
	if !ctx.cr[6].eq {
	pc = 0x822EDCCC; continue 'dispatch;
	}
	// 822EDC80: 3967FFFF  addi r11, r7, -1
	ctx.r[11].s64 = ctx.r[7].s64 + -1;
	// 822EDC84: 7F085800  cmpw cr6, r8, r11
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EDC88: 4098002C  bge cr6, 0x822edcb4
	if !ctx.cr[6].lt {
	pc = 0x822EDCB4; continue 'dispatch;
	}
	// 822EDC8C: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 822EDC90: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	pc = 0x822EDC94; continue 'dispatch;
            }
            0x822EDC94 => {
    //   block [0x822EDC94..0x822EDCB4)
	// 822EDC94: 813F01A0  lwz r9, 0x1a0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EDC98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822EDC9C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822EDCA0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822EDCA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EDCA8: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EDCAC: 90C90000  stw r6, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 822EDCB0: 409AFFE4  bne cr6, 0x822edc94
	if !ctx.cr[6].eq {
	pc = 0x822EDC94; continue 'dispatch;
	}
	pc = 0x822EDCB4; continue 'dispatch;
            }
            0x822EDCB4 => {
    //   block [0x822EDCB4..0x822EDCCC)
	// 822EDCB4: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EDCB8: 54EA103A  slwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EDCBC: 7FAA592E  stwx r29, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[29].u32) };
	// 822EDCC0: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EDCC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822EDCC8: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	pc = 0x822EDCCC; continue 'dispatch;
            }
            0x822EDCCC => {
    //   block [0x822EDCCC..0x822EDCD8)
	// 822EDCCC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 822EDCD0: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 822EDCD4: 4198FF98  blt cr6, 0x822edc6c
	if ctx.cr[6].lt {
	pc = 0x822EDC6C; continue 'dispatch;
	}
	pc = 0x822EDCD8; continue 'dispatch;
            }
            0x822EDCD8 => {
    //   block [0x822EDCD8..0x822EDCFC)
	// 822EDCD8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDCDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EDCE0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 822EDCE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EDCE8: 4E800421  bctrl
	ctx.lr = 0x822EDCEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EDCEC: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 822EDCF0: 409A003C  bne cr6, 0x822edd2c
	if !ctx.cr[6].eq {
	pc = 0x822EDD2C; continue 'dispatch;
	}
	// 822EDCF4: 397F01B0  addi r11, r31, 0x1b0
	ctx.r[11].s64 = ctx.r[31].s64 + 432;
	// 822EDCF8: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
            }
            0x822EDCFC => {
    //   block [0x822EDCFC..0x822EDD0C)
	// 822EDCFC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDD00: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822EDD04: 409A0008  bne cr6, 0x822edd0c
	if !ctx.cr[6].eq {
	pc = 0x822EDD0C; continue 'dispatch;
	}
	// 822EDD08: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x822EDD0C; continue 'dispatch;
            }
            0x822EDD0C => {
    //   block [0x822EDD0C..0x822EDD2C)
	// 822EDD0C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822EDD10: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822EDD14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EDD18: 409AFFE4  bne cr6, 0x822edcfc
	if !ctx.cr[6].eq {
	pc = 0x822EDCFC; continue 'dispatch;
	}
	// 822EDD1C: 817F01A8  lwz r11, 0x1a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 822EDD20: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822EDD24: 409A0008  bne cr6, 0x822edd2c
	if !ctx.cr[6].eq {
	pc = 0x822EDD2C; continue 'dispatch;
	}
	// 822EDD28: 93BF01A8  stw r29, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[29].u32 ) };
	pc = 0x822EDD2C; continue 'dispatch;
            }
            0x822EDD2C => {
    //   block [0x822EDD2C..0x822EDD34)
	// 822EDD2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822EDD30: 482473DC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EDD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EDD38 size=192
    let mut pc: u32 = 0x822EDD38;
    'dispatch: loop {
        match pc {
            0x822EDD38 => {
    //   block [0x822EDD38..0x822EDD6C)
	// 822EDD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EDD3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EDD40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822EDD44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EDD48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EDD4C: 810301C4  lwz r8, 0x1c4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(452 as u32) ) } as u64;
	// 822EDD50: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822EDD54: 419A008C  beq cr6, 0x822edde0
	if ctx.cr[6].eq {
	pc = 0x822EDDE0; continue 'dispatch;
	}
	// 822EDD58: 816301C8  lwz r11, 0x1c8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(456 as u32) ) } as u64;
	// 822EDD5C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822EDD60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822EDD64: 40990024  ble cr6, 0x822edd88
	if !ctx.cr[6].gt {
	pc = 0x822EDD88; continue 'dispatch;
	}
	// 822EDD68: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	pc = 0x822EDD6C; continue 'dispatch;
            }
            0x822EDD6C => {
    //   block [0x822EDD6C..0x822EDD88)
	// 822EDD6C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDD70: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 822EDD74: 419A0028  beq cr6, 0x822edd9c
	if ctx.cr[6].eq {
	pc = 0x822EDD9C; continue 'dispatch;
	}
	// 822EDD78: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822EDD7C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822EDD80: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EDD84: 4198FFE8  blt cr6, 0x822edd6c
	if ctx.cr[6].lt {
	pc = 0x822EDD6C; continue 'dispatch;
	}
	pc = 0x822EDD88; continue 'dispatch;
            }
            0x822EDD88 => {
    //   block [0x822EDD88..0x822EDD9C)
	// 822EDD88: 2F0B0200  cmpwi cr6, r11, 0x200
	ctx.cr[6].compare_i32(ctx.r[11].s32, 512, &mut ctx.xer);
	// 822EDD8C: 40980010  bge cr6, 0x822edd9c
	if !ctx.cr[6].lt {
	pc = 0x822EDD9C; continue 'dispatch;
	}
	// 822EDD90: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EDD94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822EDD98: 7C8A412E  stwx r4, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[4].u32) };
	pc = 0x822EDD9C; continue 'dispatch;
            }
            0x822EDD9C => {
    //   block [0x822EDD9C..0x822EDDD8)
	// 822EDD9C: 814301C8  lwz r10, 0x1c8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(456 as u32) ) } as u64;
	// 822EDDA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822EDDA4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822EDDA8: 409A0038  bne cr6, 0x822edde0
	if !ctx.cr[6].eq {
	pc = 0x822EDDE0; continue 'dispatch;
	}
	// 822EDDAC: 83E30198  lwz r31, 0x198(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(408 as u32) ) } as u64;
	// 822EDDB0: 916301C8  stw r11, 0x1c8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(456 as u32), ctx.r[11].u32 ) };
	// 822EDDB4: 83C40004  lwz r30, 4(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EDDB8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EDDBC: 481A6BF5  bl 0x824949b0
	ctx.lr = 0x822EDDC0;
	sub_824949B0(ctx, base);
	// 822EDDC0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822EDDC4: 419A0014  beq cr6, 0x822eddd8
	if ctx.cr[6].eq {
	pc = 0x822EDDD8; continue 'dispatch;
	}
	// 822EDDC8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822EDDCC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EDDD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822EDDD4: 481A568D  bl 0x82493460
	ctx.lr = 0x822EDDD8;
	sub_82493460(ctx, base);
	pc = 0x822EDDD8; continue 'dispatch;
            }
            0x822EDDD8 => {
    //   block [0x822EDDD8..0x822EDDE0)
	// 822EDDD8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EDDDC: 481A5405  bl 0x824931e0
	ctx.lr = 0x822EDDE0;
	sub_824931E0(ctx, base);
	pc = 0x822EDDE0; continue 'dispatch;
            }
            0x822EDDE0 => {
    //   block [0x822EDDE0..0x822EDDF8)
	// 822EDDE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822EDDE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EDDE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EDDEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822EDDF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EDDF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EDDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EDDF8 size=216
    let mut pc: u32 = 0x822EDDF8;
    'dispatch: loop {
        match pc {
            0x822EDDF8 => {
    //   block [0x822EDDF8..0x822EDE38)
	// 822EDDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EDDFC: 482472A9  bl 0x825350a4
	ctx.lr = 0x822EDE00;
	sub_82535080(ctx, base);
	// 822EDE00: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EDE04: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 822EDE08: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 822EDE0C: 837901C4  lwz r27, 0x1c4(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(452 as u32) ) } as u64;
	// 822EDE10: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822EDE14: 419A00B4  beq cr6, 0x822edec8
	if ctx.cr[6].eq {
	pc = 0x822EDEC8; continue 'dispatch;
	}
	// 822EDE18: 83B901C8  lwz r29, 0x1c8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(456 as u32) ) } as u64;
	// 822EDE1C: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 822EDE20: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822EDE24: 40990060  ble cr6, 0x822ede84
	if !ctx.cr[6].gt {
	pc = 0x822EDE84; continue 'dispatch;
	}
	// 822EDE28: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 822EDE2C: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EDE30: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 822EDE34: 7F8BDA14  add r28, r11, r27
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	pc = 0x822EDE38; continue 'dispatch;
            }
            0x822EDE38 => {
    //   block [0x822EDE38..0x822EDE6C)
	// 822EDE38: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EDE3C: 7C6BDA14  add r3, r11, r27
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822EDE40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDE44: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EDE48: 409A0030  bne cr6, 0x822ede78
	if !ctx.cr[6].eq {
	pc = 0x822EDE78; continue 'dispatch;
	}
	// 822EDE4C: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 822EDE50: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EDE54: 40980018  bge cr6, 0x822ede6c
	if !ctx.cr[6].lt {
	pc = 0x822EDE6C; continue 'dispatch;
	}
	// 822EDE58: 7FDF5850  subf r30, r31, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 822EDE5C: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 822EDE60: 57C5103A  slwi r5, r30, 2
	ctx.r[5].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 822EDE64: 48247175  bl 0x82534fd8
	ctx.lr = 0x822EDE68;
	sub_82534FD8(ctx, base);
	// 822EDE68: 7FFEFA14  add r31, r30, r31
	ctx.r[31].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	pc = 0x822EDE6C; continue 'dispatch;
            }
            0x822EDE6C => {
    //   block [0x822EDE6C..0x822EDE78)
	// 822EDE6C: 3B9CFFFC  addi r28, r28, -4
	ctx.r[28].s64 = ctx.r[28].s64 + -4;
	// 822EDE70: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 822EDE74: 92FC0000  stw r23, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	pc = 0x822EDE78; continue 'dispatch;
            }
            0x822EDE78 => {
    //   block [0x822EDE78..0x822EDE84)
	// 822EDE78: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822EDE7C: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 822EDE80: 4198FFB8  blt cr6, 0x822ede38
	if ctx.cr[6].lt {
	pc = 0x822EDE38; continue 'dispatch;
	}
	pc = 0x822EDE84; continue 'dispatch;
            }
            0x822EDE84 => {
    //   block [0x822EDE84..0x822EDEC0)
	// 822EDE84: 817901C8  lwz r11, 0x1c8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(456 as u32) ) } as u64;
	// 822EDE88: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822EDE8C: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EDE90: 409A0038  bne cr6, 0x822edec8
	if !ctx.cr[6].eq {
	pc = 0x822EDEC8; continue 'dispatch;
	}
	// 822EDE94: 83F90198  lwz r31, 0x198(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(408 as u32) ) } as u64;
	// 822EDE98: 935901C8  stw r26, 0x1c8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(456 as u32), ctx.r[26].u32 ) };
	// 822EDE9C: 83D80004  lwz r30, 4(r24)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EDEA0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EDEA4: 481A6B0D  bl 0x824949b0
	ctx.lr = 0x822EDEA8;
	sub_824949B0(ctx, base);
	// 822EDEA8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822EDEAC: 419A0014  beq cr6, 0x822edec0
	if ctx.cr[6].eq {
	pc = 0x822EDEC0; continue 'dispatch;
	}
	// 822EDEB0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822EDEB4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EDEB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822EDEBC: 481A5745  bl 0x82493600
	ctx.lr = 0x822EDEC0;
	sub_82493600(ctx, base);
	pc = 0x822EDEC0; continue 'dispatch;
            }
            0x822EDEC0 => {
    //   block [0x822EDEC0..0x822EDEC8)
	// 822EDEC0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EDEC4: 481A531D  bl 0x824931e0
	ctx.lr = 0x822EDEC8;
	sub_824931E0(ctx, base);
	pc = 0x822EDEC8; continue 'dispatch;
            }
            0x822EDEC8 => {
    //   block [0x822EDEC8..0x822EDED0)
	// 822EDEC8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822EDECC: 48247228  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EDED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EDED0 size=180
    let mut pc: u32 = 0x822EDED0;
    'dispatch: loop {
        match pc {
            0x822EDED0 => {
    //   block [0x822EDED0..0x822EDF08)
	// 822EDED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EDED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822EDED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822EDEDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822EDEE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EDEE4: 810301CC  lwz r8, 0x1cc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(460 as u32) ) } as u64;
	// 822EDEE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822EDEEC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822EDEF0: 419A007C  beq cr6, 0x822edf6c
	if ctx.cr[6].eq {
	pc = 0x822EDF6C; continue 'dispatch;
	}
	// 822EDEF4: 816301D0  lwz r11, 0x1d0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(464 as u32) ) } as u64;
	// 822EDEF8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822EDEFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822EDF00: 40990024  ble cr6, 0x822edf24
	if !ctx.cr[6].gt {
	pc = 0x822EDF24; continue 'dispatch;
	}
	// 822EDF04: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	pc = 0x822EDF08; continue 'dispatch;
            }
            0x822EDF08 => {
    //   block [0x822EDF08..0x822EDF24)
	// 822EDF08: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDF0C: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822EDF10: 419A0028  beq cr6, 0x822edf38
	if ctx.cr[6].eq {
	pc = 0x822EDF38; continue 'dispatch;
	}
	// 822EDF14: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822EDF18: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822EDF1C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EDF20: 4198FFE8  blt cr6, 0x822edf08
	if ctx.cr[6].lt {
	pc = 0x822EDF08; continue 'dispatch;
	}
	pc = 0x822EDF24; continue 'dispatch;
            }
            0x822EDF24 => {
    //   block [0x822EDF24..0x822EDF38)
	// 822EDF24: 2F0B0080  cmpwi cr6, r11, 0x80
	ctx.cr[6].compare_i32(ctx.r[11].s32, 128, &mut ctx.xer);
	// 822EDF28: 40980010  bge cr6, 0x822edf38
	if !ctx.cr[6].lt {
	pc = 0x822EDF38; continue 'dispatch;
	}
	// 822EDF2C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EDF30: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822EDF34: 7FCA412E  stwx r30, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[30].u32) };
	pc = 0x822EDF38; continue 'dispatch;
            }
            0x822EDF38 => {
    //   block [0x822EDF38..0x822EDF6C)
	// 822EDF38: 814301D0  lwz r10, 0x1d0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(464 as u32) ) } as u64;
	// 822EDF3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822EDF40: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822EDF44: 409A0028  bne cr6, 0x822edf6c
	if !ctx.cr[6].eq {
	pc = 0x822EDF6C; continue 'dispatch;
	}
	// 822EDF48: 83E30198  lwz r31, 0x198(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(408 as u32) ) } as u64;
	// 822EDF4C: 916301D0  stw r11, 0x1d0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 822EDF50: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EDF54: 481A6A5D  bl 0x824949b0
	ctx.lr = 0x822EDF58;
	sub_824949B0(ctx, base);
	// 822EDF58: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EDF5C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EDF60: 481ABC61  bl 0x82499bc0
	ctx.lr = 0x822EDF64;
	sub_82499BC0(ctx, base);
	// 822EDF64: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EDF68: 481A5279  bl 0x824931e0
	ctx.lr = 0x822EDF6C;
	sub_824931E0(ctx, base);
	pc = 0x822EDF6C; continue 'dispatch;
            }
            0x822EDF6C => {
    //   block [0x822EDF6C..0x822EDF84)
	// 822EDF6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822EDF70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822EDF74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822EDF78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822EDF7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822EDF80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EDF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EDF88 size=204
    let mut pc: u32 = 0x822EDF88;
    'dispatch: loop {
        match pc {
            0x822EDF88 => {
    //   block [0x822EDF88..0x822EDFC8)
	// 822EDF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EDF8C: 48247119  bl 0x825350a4
	ctx.lr = 0x822EDF90;
	sub_82535080(ctx, base);
	// 822EDF90: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EDF94: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 822EDF98: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 822EDF9C: 837801CC  lwz r27, 0x1cc(r24)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(460 as u32) ) } as u64;
	// 822EDFA0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822EDFA4: 419A00A8  beq cr6, 0x822ee04c
	if ctx.cr[6].eq {
	pc = 0x822EE04C; continue 'dispatch;
	}
	// 822EDFA8: 83B801D0  lwz r29, 0x1d0(r24)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(464 as u32) ) } as u64;
	// 822EDFAC: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 822EDFB0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822EDFB4: 40990060  ble cr6, 0x822ee014
	if !ctx.cr[6].gt {
	pc = 0x822EE014; continue 'dispatch;
	}
	// 822EDFB8: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 822EDFBC: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EDFC0: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 822EDFC4: 7F8BDA14  add r28, r11, r27
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	pc = 0x822EDFC8; continue 'dispatch;
            }
            0x822EDFC8 => {
    //   block [0x822EDFC8..0x822EDFFC)
	// 822EDFC8: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EDFCC: 7C6BDA14  add r3, r11, r27
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822EDFD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EDFD4: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EDFD8: 409A0030  bne cr6, 0x822ee008
	if !ctx.cr[6].eq {
	pc = 0x822EE008; continue 'dispatch;
	}
	// 822EDFDC: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 822EDFE0: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EDFE4: 40980018  bge cr6, 0x822edffc
	if !ctx.cr[6].lt {
	pc = 0x822EDFFC; continue 'dispatch;
	}
	// 822EDFE8: 7FDF5850  subf r30, r31, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 822EDFEC: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 822EDFF0: 57C5103A  slwi r5, r30, 2
	ctx.r[5].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 822EDFF4: 48246FE5  bl 0x82534fd8
	ctx.lr = 0x822EDFF8;
	sub_82534FD8(ctx, base);
	// 822EDFF8: 7FFEFA14  add r31, r30, r31
	ctx.r[31].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	pc = 0x822EDFFC; continue 'dispatch;
            }
            0x822EDFFC => {
    //   block [0x822EDFFC..0x822EE008)
	// 822EDFFC: 3B9CFFFC  addi r28, r28, -4
	ctx.r[28].s64 = ctx.r[28].s64 + -4;
	// 822EE000: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 822EE004: 92FC0000  stw r23, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	pc = 0x822EE008; continue 'dispatch;
            }
            0x822EE008 => {
    //   block [0x822EE008..0x822EE014)
	// 822EE008: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822EE00C: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 822EE010: 4198FFB8  blt cr6, 0x822edfc8
	if ctx.cr[6].lt {
	pc = 0x822EDFC8; continue 'dispatch;
	}
	pc = 0x822EE014; continue 'dispatch;
            }
            0x822EE014 => {
    //   block [0x822EE014..0x822EE04C)
	// 822EE014: 817801D0  lwz r11, 0x1d0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(464 as u32) ) } as u64;
	// 822EE018: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822EE01C: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EE020: 409A002C  bne cr6, 0x822ee04c
	if !ctx.cr[6].eq {
	pc = 0x822EE04C; continue 'dispatch;
	}
	// 822EE024: 83F80198  lwz r31, 0x198(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(408 as u32) ) } as u64;
	// 822EE028: 935801D0  stw r26, 0x1d0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(464 as u32), ctx.r[26].u32 ) };
	// 822EE02C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EE030: 481A6981  bl 0x824949b0
	ctx.lr = 0x822EE034;
	sub_824949B0(ctx, base);
	// 822EE034: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822EE038: 80B90004  lwz r5, 4(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EE03C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EE040: 481ABD41  bl 0x82499d80
	ctx.lr = 0x822EE044;
	sub_82499D80(ctx, base);
	// 822EE044: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EE048: 481A5199  bl 0x824931e0
	ctx.lr = 0x822EE04C;
	sub_824931E0(ctx, base);
	pc = 0x822EE04C; continue 'dispatch;
            }
            0x822EE04C => {
    //   block [0x822EE04C..0x822EE054)
	// 822EE04C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822EE050: 482470A4  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EE058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EE058 size=156
    let mut pc: u32 = 0x822EE058;
    'dispatch: loop {
        match pc {
            0x822EE058 => {
    //   block [0x822EE058..0x822EE0B8)
	// 822EE058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EE05C: 48247059  bl 0x825350b4
	ctx.lr = 0x822EE060;
	sub_82535080(ctx, base);
	// 822EE060: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EE064: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EE068: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822EE06C: 397F00D0  addi r11, r31, 0xd0
	ctx.r[11].s64 = ctx.r[31].s64 + 208;
	// 822EE070: 395F00A0  addi r10, r31, 0xa0
	ctx.r[10].s64 = ctx.r[31].s64 + 160;
	// 822EE074: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822EE078: 813F01A4  lwz r9, 0x1a4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE07C: 911F0084  stw r8, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 822EE080: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 822EE084: 909F0094  stw r4, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[4].u32 ) };
	// 822EE088: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822EE08C: E9260000  ld r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 822EE090: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822EE094: E9260008  ld r9, 8(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	// 822EE098: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 822EE09C: E9650000  ld r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	// 822EE0A0: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 822EE0A4: E9650008  ld r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	// 822EE0A8: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822EE0AC: 4099003C  ble cr6, 0x822ee0e8
	if !ctx.cr[6].gt {
	pc = 0x822EE0E8; continue 'dispatch;
	}
	// 822EE0B0: 3B9F0080  addi r28, r31, 0x80
	ctx.r[28].s64 = ctx.r[31].s64 + 128;
	// 822EE0B4: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	pc = 0x822EE0B8; continue 'dispatch;
            }
            0x822EE0B8 => {
    //   block [0x822EE0B8..0x822EE0E8)
	// 822EE0B8: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EE0BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822EE0C0: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EE0C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EE0C8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822EE0CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EE0D0: 4E800421  bctrl
	ctx.lr = 0x822EE0D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EE0D4: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE0D8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822EE0DC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822EE0E0: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EE0E4: 4198FFD4  blt cr6, 0x822ee0b8
	if ctx.cr[6].lt {
	pc = 0x822EE0B8; continue 'dispatch;
	}
            }
            0x822EE0E8 => {
    //   block [0x822EE0E8..0x822EE0F4)
	// 822EE0E8: 937F0084  stw r27, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 822EE0EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822EE0F0: 48247014  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EE0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EE0F8 size=356
    let mut pc: u32 = 0x822EE0F8;
    'dispatch: loop {
        match pc {
            0x822EE0F8 => {
    //   block [0x822EE0F8..0x822EE138)
	// 822EE0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EE0FC: 48246FA9  bl 0x825350a4
	ctx.lr = 0x822EE100;
	sub_82535080(ctx, base);
	// 822EE100: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EE104: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822EE108: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EE10C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 822EE110: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822EE114: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 822EE118: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 822EE11C: 2F1D0010  cmpwi cr6, r29, 0x10
	ctx.cr[6].compare_i32(ctx.r[29].s32, 16, &mut ctx.xer);
	// 822EE120: 41990134  bgt cr6, 0x822ee254
	if ctx.cr[6].gt {
	pc = 0x822EE254; continue 'dispatch;
	}
	// 822EE124: 395D0011  addi r10, r29, 0x11
	ctx.r[10].s64 = ctx.r[29].s64 + 17;
	// 822EE128: 2F0A0022  cmpwi cr6, r10, 0x22
	ctx.cr[6].compare_i32(ctx.r[10].s32, 34, &mut ctx.xer);
	// 822EE12C: 4198000C  blt cr6, 0x822ee138
	if ctx.cr[6].lt {
	pc = 0x822EE138; continue 'dispatch;
	}
	// 822EE130: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822EE134: 48000018  b 0x822ee14c
	pc = 0x822EE14C; continue 'dispatch;
            }
            0x822EE138 => {
    //   block [0x822EE138..0x822EE14C)
	// 822EE138: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 822EE13C: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EE140: 396BA0CC  addi r11, r11, -0x5f34
	ctx.r[11].s64 = ctx.r[11].s64 + -24372;
	// 822EE144: 396B002C  addi r11, r11, 0x2c
	ctx.r[11].s64 = ctx.r[11].s64 + 44;
	// 822EE148: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x822EE14C; continue 'dispatch;
            }
            0x822EE14C => {
    //   block [0x822EE14C..0x822EE208)
	// 822EE14C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EE150: 907F0160  stw r3, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[3].u32 ) };
	// 822EE154: 419A0100  beq cr6, 0x822ee254
	if ctx.cr[6].eq {
	pc = 0x822EE254; continue 'dispatch;
	}
	// 822EE158: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EE15C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822EE160: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EE164: 4E800421  bctrl
	ctx.lr = 0x822EE168;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EE168: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EE16C: 419A00E8  beq cr6, 0x822ee254
	if ctx.cr[6].eq {
	pc = 0x822EE254; continue 'dispatch;
	}
	// 822EE170: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 822EE174: 82FF01D4  lwz r23, 0x1d4(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 822EE178: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 822EE17C: 397F00D0  addi r11, r31, 0xd0
	ctx.r[11].s64 = ctx.r[31].s64 + 208;
	// 822EE180: 38E8C3F4  addi r7, r8, -0x3c0c
	ctx.r[7].s64 = ctx.r[8].s64 + -15372;
	// 822EE184: 395F00B0  addi r10, r31, 0xb0
	ctx.r[10].s64 = ctx.r[31].s64 + 176;
	// 822EE188: 93DF0088  stw r30, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 822EE18C: 393F00A0  addi r9, r31, 0xa0
	ctx.r[9].s64 = ctx.r[31].s64 + 160;
	// 822EE190: E91A0000  ld r8, 0(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 822EE194: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822EE198: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822EE19C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EE1A0: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 822EE1A4: 3B3F0080  addi r25, r31, 0x80
	ctx.r[25].s64 = ctx.r[31].s64 + 128;
	// 822EE1A8: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 822EE1AC: E91A0008  ld r8, 8(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	// 822EE1B0: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 822EE1B4: E97B0000  ld r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 822EE1B8: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 822EE1BC: E97B0008  ld r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	// 822EE1C0: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822EE1C4: E97C0000  ld r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 822EE1C8: F9690000  std r11, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 822EE1CC: E97C0008  ld r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	// 822EE1D0: 93BF009C  stw r29, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[29].u32 ) };
	// 822EE1D4: 931F0094  stw r24, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[24].u32 ) };
	// 822EE1D8: 92FF0080  stw r23, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[23].u32 ) };
	// 822EE1DC: 93DF0088  stw r30, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 822EE1E0: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822EE1E4: 4807C2AD  bl 0x8236a490
	ctx.lr = 0x822EE1E8;
	sub_8236A490(ctx, base);
	// 822EE1E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EE1EC: 419A001C  beq cr6, 0x822ee208
	if ctx.cr[6].eq {
	pc = 0x822EE208; continue 'dispatch;
	}
	// 822EE1F0: 80DF01D4  lwz r6, 0x1d4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 822EE1F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822EE1F8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 822EE1FC: 39660001  addi r11, r6, 1
	ctx.r[11].s64 = ctx.r[6].s64 + 1;
	// 822EE200: 917F01D4  stw r11, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 822EE204: 48008DD5  bl 0x822f6fd8
	ctx.lr = 0x822EE208;
	sub_822F6FD8(ctx, base);
            }
            0x822EE208 => {
    //   block [0x822EE208..0x822EE21C)
	// 822EE208: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE20C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822EE210: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822EE214: 40990038  ble cr6, 0x822ee24c
	if !ctx.cr[6].gt {
	pc = 0x822EE24C; continue 'dispatch;
	}
	// 822EE218: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x822EE21C; continue 'dispatch;
            }
            0x822EE21C => {
    //   block [0x822EE21C..0x822EE24C)
	// 822EE21C: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EE220: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 822EE224: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EE228: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EE22C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822EE230: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EE234: 4E800421  bctrl
	ctx.lr = 0x822EE238;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EE238: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE23C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822EE240: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EE244: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EE248: 4198FFD4  blt cr6, 0x822ee21c
	if ctx.cr[6].lt {
	pc = 0x822EE21C; continue 'dispatch;
	}
            }
            0x822EE24C => {
    //   block [0x822EE24C..0x822EE254)
	// 822EE24C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822EE250: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	pc = 0x822EE254; continue 'dispatch;
            }
            0x822EE254 => {
    //   block [0x822EE254..0x822EE25C)
	// 822EE254: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822EE258: 48246E9C  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EE260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EE260 size=384
    let mut pc: u32 = 0x822EE260;
    'dispatch: loop {
        match pc {
            0x822EE260 => {
    //   block [0x822EE260..0x822EE2A4)
	// 822EE260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EE264: 48246E4D  bl 0x825350b0
	ctx.lr = 0x822EE268;
	sub_82535080(ctx, base);
	// 822EE268: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 822EE26C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EE270: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822EE274: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822EE278: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EE27C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822EE280: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 822EE284: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 822EE288: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 822EE28C: 2F1E0010  cmpwi cr6, r30, 0x10
	ctx.cr[6].compare_i32(ctx.r[30].s32, 16, &mut ctx.xer);
	// 822EE290: 41990144  bgt cr6, 0x822ee3d4
	if ctx.cr[6].gt {
	pc = 0x822EE3D4; continue 'dispatch;
	}
	// 822EE294: 2F1E0022  cmpwi cr6, r30, 0x22
	ctx.cr[6].compare_i32(ctx.r[30].s32, 34, &mut ctx.xer);
	// 822EE298: 4198000C  blt cr6, 0x822ee2a4
	if ctx.cr[6].lt {
	pc = 0x822EE2A4; continue 'dispatch;
	}
	// 822EE29C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822EE2A0: 48000018  b 0x822ee2b8
	pc = 0x822EE2B8; continue 'dispatch;
            }
            0x822EE2A4 => {
    //   block [0x822EE2A4..0x822EE2B8)
	// 822EE2A4: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 822EE2A8: 57CA2036  slwi r10, r30, 4
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EE2AC: 396BA0CC  addi r11, r11, -0x5f34
	ctx.r[11].s64 = ctx.r[11].s64 + -24372;
	// 822EE2B0: 396B002C  addi r11, r11, 0x2c
	ctx.r[11].s64 = ctx.r[11].s64 + 44;
	// 822EE2B4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x822EE2B8; continue 'dispatch;
            }
            0x822EE2B8 => {
    //   block [0x822EE2B8..0x822EE388)
	// 822EE2B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EE2BC: 907F0160  stw r3, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[3].u32 ) };
	// 822EE2C0: 419A0114  beq cr6, 0x822ee3d4
	if ctx.cr[6].eq {
	pc = 0x822EE3D4; continue 'dispatch;
	}
	// 822EE2C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EE2C8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822EE2CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EE2D0: 4E800421  bctrl
	ctx.lr = 0x822EE2D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EE2D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EE2D8: 419A00FC  beq cr6, 0x822ee3d4
	if ctx.cr[6].eq {
	pc = 0x822EE3D4; continue 'dispatch;
	}
	// 822EE2DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EE2E0: 811F01D4  lwz r8, 0x1d4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 822EE2E4: 395F00D0  addi r10, r31, 0xd0
	ctx.r[10].s64 = ctx.r[31].s64 + 208;
	// 822EE2E8: 937F0158  stw r27, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[27].u32 ) };
	// 822EE2EC: 393F00A0  addi r9, r31, 0xa0
	ctx.r[9].s64 = ctx.r[31].s64 + 160;
	// 822EE2F0: 93DF0154  stw r30, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[30].u32 ) };
	// 822EE2F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822EE2F8: 935F0150  stw r26, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[26].u32 ) };
	// 822EE2FC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822EE300: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EE304: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 822EE308: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 822EE30C: 911F0080  stw r8, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 822EE310: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822EE314: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822EE318: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822EE31C: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 822EE320: 3B7F0080  addi r27, r31, 0x80
	ctx.r[27].s64 = ctx.r[31].s64 + 128;
	// 822EE324: C1A9BA38  lfs f13, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822EE328: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822EE32C: 911F014C  stw r8, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[8].u32 ) };
	// 822EE330: 38E9C3FC  addi r7, r9, -0x3c04
	ctx.r[7].s64 = ctx.r[9].s64 + -15364;
	// 822EE334: E91C0008  ld r8, 8(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	// 822EE338: E93C0000  ld r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 822EE33C: EB9D0000  ld r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 822EE340: EBBD0008  ld r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 822EE344: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 822EE348: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822EE34C: FB8A0000  std r28, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 822EE350: FBAA0008  std r29, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 822EE354: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 822EE358: D3FF00C4  stfs f31, 0xc4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822EE35C: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 822EE360: D1BF00CC  stfs f13, 0xcc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 822EE364: 4807C12D  bl 0x8236a490
	ctx.lr = 0x822EE368;
	sub_8236A490(ctx, base);
	// 822EE368: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EE36C: 419A001C  beq cr6, 0x822ee388
	if ctx.cr[6].eq {
	pc = 0x822EE388; continue 'dispatch;
	}
	// 822EE370: 80DF01D4  lwz r6, 0x1d4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 822EE374: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822EE378: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822EE37C: 39660001  addi r11, r6, 1
	ctx.r[11].s64 = ctx.r[6].s64 + 1;
	// 822EE380: 917F01D4  stw r11, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 822EE384: 48004775  bl 0x822f2af8
	ctx.lr = 0x822EE388;
	sub_822F2AF8(ctx, base);
            }
            0x822EE388 => {
    //   block [0x822EE388..0x822EE39C)
	// 822EE388: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE38C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822EE390: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822EE394: 40990038  ble cr6, 0x822ee3cc
	if !ctx.cr[6].gt {
	pc = 0x822EE3CC; continue 'dispatch;
	}
	// 822EE398: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x822EE39C; continue 'dispatch;
            }
            0x822EE39C => {
    //   block [0x822EE39C..0x822EE3CC)
	// 822EE39C: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EE3A0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822EE3A4: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EE3A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EE3AC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822EE3B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EE3B4: 4E800421  bctrl
	ctx.lr = 0x822EE3B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EE3B8: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE3BC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822EE3C0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EE3C4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EE3C8: 4198FFD4  blt cr6, 0x822ee39c
	if ctx.cr[6].lt {
	pc = 0x822EE39C; continue 'dispatch;
	}
            }
            0x822EE3CC => {
    //   block [0x822EE3CC..0x822EE3D4)
	// 822EE3CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822EE3D0: 917F014C  stw r11, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	pc = 0x822EE3D4; continue 'dispatch;
            }
            0x822EE3D4 => {
    //   block [0x822EE3D4..0x822EE3E0)
	// 822EE3D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EE3D8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822EE3DC: 48246D24  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EE3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EE3E0 size=152
    let mut pc: u32 = 0x822EE3E0;
    'dispatch: loop {
        match pc {
            0x822EE3E0 => {
    //   block [0x822EE3E0..0x822EE414)
	// 822EE3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EE3E4: 48246CD1  bl 0x825350b4
	ctx.lr = 0x822EE3E8;
	sub_82535080(ctx, base);
	// 822EE3E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EE3EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EE3F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822EE3F4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822EE3F8: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 822EE3FC: 815F01A4  lwz r10, 0x1a4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE400: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 822EE404: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822EE408: 4099003C  ble cr6, 0x822ee444
	if !ctx.cr[6].gt {
	pc = 0x822EE444; continue 'dispatch;
	}
	// 822EE40C: 3B9F0080  addi r28, r31, 0x80
	ctx.r[28].s64 = ctx.r[31].s64 + 128;
	// 822EE410: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x822EE414; continue 'dispatch;
            }
            0x822EE414 => {
    //   block [0x822EE414..0x822EE444)
	// 822EE414: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EE418: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822EE41C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 822EE420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EE424: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822EE428: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EE42C: 4E800421  bctrl
	ctx.lr = 0x822EE430;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EE430: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE434: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822EE438: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EE43C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EE440: 4198FFD4  blt cr6, 0x822ee414
	if ctx.cr[6].lt {
	pc = 0x822EE414; continue 'dispatch;
	}
            }
            0x822EE444 => {
    //   block [0x822EE444..0x822EE478)
	// 822EE444: 937F01A8  stw r27, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[27].u32 ) };
	// 822EE448: 937F01AC  stw r27, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[27].u32 ) };
	// 822EE44C: 937F01B0  stw r27, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[27].u32 ) };
	// 822EE450: 937F01B4  stw r27, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[27].u32 ) };
	// 822EE454: 937F01AC  stw r27, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[27].u32 ) };
	// 822EE458: 937F01B0  stw r27, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[27].u32 ) };
	// 822EE45C: 937F01B4  stw r27, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[27].u32 ) };
	// 822EE460: 937F01B8  stw r27, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[27].u32 ) };
	// 822EE464: 937F01BC  stw r27, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[27].u32 ) };
	// 822EE468: 937F01C0  stw r27, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[27].u32 ) };
	// 822EE46C: 937F0164  stw r27, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[27].u32 ) };
	// 822EE470: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822EE474: 48246C90  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EE478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EE478 size=112
    let mut pc: u32 = 0x822EE478;
    'dispatch: loop {
        match pc {
            0x822EE478 => {
    //   block [0x822EE478..0x822EE4AC)
	// 822EE478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EE47C: 48246C39  bl 0x825350b4
	ctx.lr = 0x822EE480;
	sub_82535080(ctx, base);
	// 822EE480: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EE484: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EE488: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822EE48C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822EE490: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 822EE494: 815F01A4  lwz r10, 0x1a4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE498: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 822EE49C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822EE4A0: 4099003C  ble cr6, 0x822ee4dc
	if !ctx.cr[6].gt {
	pc = 0x822EE4DC; continue 'dispatch;
	}
	// 822EE4A4: 3B9F0080  addi r28, r31, 0x80
	ctx.r[28].s64 = ctx.r[31].s64 + 128;
	// 822EE4A8: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x822EE4AC; continue 'dispatch;
            }
            0x822EE4AC => {
    //   block [0x822EE4AC..0x822EE4DC)
	// 822EE4AC: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EE4B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822EE4B4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 822EE4B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EE4BC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822EE4C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EE4C4: 4E800421  bctrl
	ctx.lr = 0x822EE4C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EE4C8: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE4CC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822EE4D0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EE4D4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EE4D8: 4198FFD4  blt cr6, 0x822ee4ac
	if ctx.cr[6].lt {
	pc = 0x822EE4AC; continue 'dispatch;
	}
            }
            0x822EE4DC => {
    //   block [0x822EE4DC..0x822EE4E8)
	// 822EE4DC: 937F0168  stw r27, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[27].u32 ) };
	// 822EE4E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822EE4E4: 48246C20  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EE4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EE4E8 size=240
    let mut pc: u32 = 0x822EE4E8;
    'dispatch: loop {
        match pc {
            0x822EE4E8 => {
    //   block [0x822EE4E8..0x822EE514)
	// 822EE4E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EE4EC: 48246BC5  bl 0x825350b0
	ctx.lr = 0x822EE4F0;
	sub_82535080(ctx, base);
	// 822EE4F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EE4F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822EE4F8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822EE4FC: 3F608273  lis r27, -0x7d8d
	ctx.r[27].s64 = -2106392576;
	// 822EE500: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 822EE504: 817D0244  lwz r11, 0x244(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(580 as u32) ) } as u64;
	// 822EE508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EE50C: 40990068  ble cr6, 0x822ee574
	if !ctx.cr[6].gt {
	pc = 0x822EE574; continue 'dispatch;
	}
	// 822EE510: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x822EE514; continue 'dispatch;
            }
            0x822EE514 => {
    //   block [0x822EE514..0x822EE560)
	// 822EE514: 817D024C  lwz r11, 0x24c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(588 as u32) ) } as u64;
	// 822EE518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EE51C: 419A0044  beq cr6, 0x822ee560
	if ctx.cr[6].eq {
	pc = 0x822EE560; continue 'dispatch;
	}
	// 822EE520: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EE524: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EE528: 419A0038  beq cr6, 0x822ee560
	if ctx.cr[6].eq {
	pc = 0x822EE560; continue 'dispatch;
	}
	// 822EE52C: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822EE530: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822EE534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EE538: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EE53C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EE540: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EE544: 4E800421  bctrl
	ctx.lr = 0x822EE548;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EE548: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822EE54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EE550: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EE554: 4E800421  bctrl
	ctx.lr = 0x822EE558;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EE558: 817D024C  lwz r11, 0x24c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(588 as u32) ) } as u64;
	// 822EE55C: 7F5E592E  stwx r26, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[26].u32) };
            }
            0x822EE560 => {
    //   block [0x822EE560..0x822EE574)
	// 822EE560: 817D0244  lwz r11, 0x244(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(580 as u32) ) } as u64;
	// 822EE564: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822EE568: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EE56C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EE570: 4198FFA4  blt cr6, 0x822ee514
	if ctx.cr[6].lt {
	pc = 0x822EE514; continue 'dispatch;
	}
	pc = 0x822EE574; continue 'dispatch;
            }
            0x822EE574 => {
    //   block [0x822EE574..0x822EE578)
	// 822EE574: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x822EE578; continue 'dispatch;
            }
            0x822EE578 => {
    //   block [0x822EE578..0x822EE5C4)
	// 822EE578: 817D019C  lwz r11, 0x19c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EE57C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EE580: 419A0044  beq cr6, 0x822ee5c4
	if ctx.cr[6].eq {
	pc = 0x822EE5C4; continue 'dispatch;
	}
	// 822EE584: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EE588: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EE58C: 419A0038  beq cr6, 0x822ee5c4
	if ctx.cr[6].eq {
	pc = 0x822EE5C4; continue 'dispatch;
	}
	// 822EE590: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822EE594: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822EE598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EE59C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EE5A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EE5A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EE5A8: 4E800421  bctrl
	ctx.lr = 0x822EE5AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EE5AC: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822EE5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EE5B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EE5B8: 4E800421  bctrl
	ctx.lr = 0x822EE5BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EE5BC: 817D019C  lwz r11, 0x19c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EE5C0: 7F4BF12E  stwx r26, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[26].u32) };
            }
            0x822EE5C4 => {
    //   block [0x822EE5C4..0x822EE5D8)
	// 822EE5C4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EE5C8: 2B1E0020  cmplwi cr6, r30, 0x20
	ctx.cr[6].compare_u32(ctx.r[30].u32, 32 as u32, &mut ctx.xer);
	// 822EE5CC: 4198FFAC  blt cr6, 0x822ee578
	if ctx.cr[6].lt {
	pc = 0x822EE578; continue 'dispatch;
	}
	// 822EE5D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EE5D4: 48246B2C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EE5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EE5D8 size=312
    let mut pc: u32 = 0x822EE5D8;
    'dispatch: loop {
        match pc {
            0x822EE5D8 => {
    //   block [0x822EE5D8..0x822EE61C)
	// 822EE5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EE5DC: 48246AD5  bl 0x825350b0
	ctx.lr = 0x822EE5E0;
	sub_82535080(ctx, base);
	// 822EE5E0: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 822EE5E4: 48247A05  bl 0x82535fe8
	ctx.lr = 0x822EE5E8;
	sub_82535FB0(ctx, base);
	// 822EE5E8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EE5EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EE5F0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822EE5F4: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 822EE5F8: 935F0258  stw r26, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[26].u32 ) };
	// 822EE5FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EE600: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 822EE604: C3ABD5B0  lfs f29, -0x2a50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822EE608: 419A0094  beq cr6, 0x822ee69c
	if ctx.cr[6].eq {
	pc = 0x822EE69C; continue 'dispatch;
	}
	// 822EE60C: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 822EE610: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	// 822EE614: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 822EE618: C3EB06B4  lfs f31, 0x6b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1716 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x822EE61C; continue 'dispatch;
            }
            0x822EE61C => {
    //   block [0x822EE61C..0x822EE648)
	// 822EE61C: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 822EE620: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822EE624: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EE628: 481A55E1  bl 0x82493c08
	ctx.lr = 0x822EE62C;
	sub_82493C08(ctx, base);
	// 822EE62C: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 822EE630: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822EE634: 409AFFE8  bne cr6, 0x822ee61c
	if !ctx.cr[6].eq {
	pc = 0x822EE61C; continue 'dispatch;
	}
	// 822EE638: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EE63C: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	// 822EE640: C00B2068  lfs f0, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EE644: EF9F0032  fmuls f28, f31, f0
	ctx.f[28].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x822EE648; continue 'dispatch;
            }
            0x822EE648 => {
    //   block [0x822EE648..0x822EE680)
	// 822EE648: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 822EE64C: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 822EE650: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EE654: 481A55B5  bl 0x82493c08
	ctx.lr = 0x822EE658;
	sub_82493C08(ctx, base);
	// 822EE658: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 822EE65C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822EE660: 409AFFE8  bne cr6, 0x822ee648
	if !ctx.cr[6].eq {
	pc = 0x822EE648; continue 'dispatch;
	}
	// 822EE664: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 822EE668: EFDF0772  fmuls f30, f31, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (((ctx.f[31].f64 * ctx.f[29].f64) as f32) as f64);
	// 822EE66C: C00BD564  lfs f0, -0x2a9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822EE670: EDBF0032  fmuls f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 822EE674: EFFC683A  fmadds f31, f28, f0, f13
	ctx.f[31].f64 = (((ctx.f[28].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 822EE678: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 822EE67C: 40980020  bge cr6, 0x822ee69c
	if !ctx.cr[6].lt {
	pc = 0x822EE69C; continue 'dispatch;
	}
	pc = 0x822EE680; continue 'dispatch;
            }
            0x822EE680 => {
    //   block [0x822EE680..0x822EE69C)
	// 822EE680: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 822EE684: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822EE688: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EE68C: 481A557D  bl 0x82493c08
	ctx.lr = 0x822EE690;
	sub_82493C08(ctx, base);
	// 822EE690: EFFEF82A  fadds f31, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64;
	// 822EE694: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 822EE698: 4198FFE8  blt cr6, 0x822ee680
	if ctx.cr[6].lt {
	pc = 0x822EE680; continue 'dispatch;
	}
	pc = 0x822EE69C; continue 'dispatch;
            }
            0x822EE69C => {
    //   block [0x822EE69C..0x822EE6C8)
	// 822EE69C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EE6A0: 4BFFFDD9  bl 0x822ee478
	ctx.lr = 0x822EE6A4;
	sub_822EE478(ctx, base);
	// 822EE6A4: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 822EE6A8: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE6AC: D3BF0170  stfs f29, 0x170(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 822EE6B0: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 822EE6B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822EE6B8: 937F016C  stw r27, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[27].u32 ) };
	// 822EE6BC: 4099003C  ble cr6, 0x822ee6f8
	if !ctx.cr[6].gt {
	pc = 0x822EE6F8; continue 'dispatch;
	}
	// 822EE6C0: 3B9F0080  addi r28, r31, 0x80
	ctx.r[28].s64 = ctx.r[31].s64 + 128;
	// 822EE6C4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x822EE6C8; continue 'dispatch;
            }
            0x822EE6C8 => {
    //   block [0x822EE6C8..0x822EE6F8)
	// 822EE6C8: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EE6CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822EE6D0: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EE6D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EE6D8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822EE6DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EE6E0: 4E800421  bctrl
	ctx.lr = 0x822EE6E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EE6E4: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE6E8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822EE6EC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EE6F0: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EE6F4: 4198FFD4  blt cr6, 0x822ee6c8
	if ctx.cr[6].lt {
	pc = 0x822EE6C8; continue 'dispatch;
	}
            }
            0x822EE6F8 => {
    //   block [0x822EE6F8..0x822EE710)
	// 822EE6F8: 935F016C  stw r26, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[26].u32 ) };
	// 822EE6FC: 937F0258  stw r27, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[27].u32 ) };
	// 822EE700: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822EE704: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 822EE708: 4824792D  bl 0x82536034
	ctx.lr = 0x822EE70C;
	sub_82535FFC(ctx, base);
	// 822EE70C: 482469F4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EE710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EE710 size=232
    let mut pc: u32 = 0x822EE710;
    'dispatch: loop {
        match pc {
            0x822EE710 => {
    //   block [0x822EE710..0x822EE750)
	// 822EE710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EE714: 4824699D  bl 0x825350b0
	ctx.lr = 0x822EE718;
	sub_82535080(ctx, base);
	// 822EE718: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EE71C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EE720: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822EE724: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 822EE728: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822EE72C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EE730: 909F0094  stw r4, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[4].u32 ) };
	// 822EE734: 937F0084  stw r27, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 822EE738: 935F008C  stw r26, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[26].u32 ) };
	// 822EE73C: 90BF0098  stw r5, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[5].u32 ) };
	// 822EE740: 419A0028  beq cr6, 0x822ee768
	if ctx.cr[6].eq {
	pc = 0x822EE768; continue 'dispatch;
	}
	// 822EE744: 395F0100  addi r10, r31, 0x100
	ctx.r[10].s64 = ctx.r[31].s64 + 256;
	// 822EE748: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 822EE74C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x822EE750; continue 'dispatch;
            }
            0x822EE750 => {
    //   block [0x822EE750..0x822EE768)
	// 822EE750: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822EE754: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822EE758: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822EE75C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822EE760: 4200FFF0  bdnz 0x822ee750
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822EE750; continue 'dispatch;
	}
	// 822EE764: 4800003C  b 0x822ee7a0
	pc = 0x822EE7A0; continue 'dispatch;
            }
            0x822EE768 => {
    //   block [0x822EE768..0x822EE7A0)
	// 822EE768: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 822EE76C: 397F0100  addi r11, r31, 0x100
	ctx.r[11].s64 = ctx.r[31].s64 + 256;
	// 822EE770: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 822EE774: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 822EE778: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 822EE77C: 3D403F80  lis r10, 0x3f80
	ctx.r[10].s64 = 1065353216;
	pc = 0x822EE7A0; continue 'dispatch;
            }
            0x822EE7A0 => {
    //   block [0x822EE7A0..0x822EE7F8)
	// 822EE7A0: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE7A4: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 822EE7A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822EE7AC: 4099003C  ble cr6, 0x822ee7e8
	if !ctx.cr[6].gt {
	pc = 0x822EE7E8; continue 'dispatch;
	}
	// 822EE7B0: 3B9F0080  addi r28, r31, 0x80
	ctx.r[28].s64 = ctx.r[31].s64 + 128;
	// 822EE7B4: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 822EE7B8: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 822EE7BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822EE7C0: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 822EE7C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EE7C8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822EE7CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EE7D0: 4E800421  bctrl
	ctx.lr = 0x822EE7D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EE7D4: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 822EE7D8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822EE7DC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EE7E0: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822EE7E4: 4198FFD4  blt cr6, 0x822ee7b8
	if ctx.cr[6].lt {
	pc = 0x822EE7B8; continue 'dispatch;
	}
	// 822EE7E8: 937F008C  stw r27, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[27].u32 ) };
	// 822EE7EC: 935F0084  stw r26, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[26].u32 ) };
	// 822EE7F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EE7F4: 4824690C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EE7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EE7F8 size=1008
    let mut pc: u32 = 0x822EE7F8;
    'dispatch: loop {
        match pc {
            0x822EE7F8 => {
    //   block [0x822EE7F8..0x822EE82C)
	// 822EE7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EE7FC: 482468B1  bl 0x825350ac
	ctx.lr = 0x822EE800;
	sub_82535080(ctx, base);
	// 822EE800: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EE804: 3FA0830F  lis r29, -0x7cf1
	ctx.r[29].s64 = -2096168960;
	// 822EE808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EE80C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822EE810: 3D4082D0  lis r10, -0x7d30
	ctx.r[10].s64 = -2100297728;
	// 822EE814: 817DFAC0  lwz r11, -0x540(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 822EE818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EE81C: 409A0010  bne cr6, 0x822ee82c
	if !ctx.cr[6].eq {
	pc = 0x822EE82C; continue 'dispatch;
	}
	// 822EE820: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 822EE824: F96AE540  std r11, -0x1ac0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-6848 as u32), ctx.r[11].u64 ) };
	// 822EE828: 48000014  b 0x822ee83c
	pc = 0x822EE83C; continue 'dispatch;
            }
            0x822EE82C => {
    //   block [0x822EE82C..0x822EE83C)
	// 822EE82C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822EE830: 394AE540  addi r10, r10, -0x1ac0
	ctx.r[10].s64 = ctx.r[10].s64 + -6848;
	// 822EE834: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822EE838: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x822EE83C; continue 'dispatch;
            }
            0x822EE83C => {
    //   block [0x822EE83C..0x822EE898)
	// 822EE83C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822EE840: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 822EE844: 816BBB10  lwz r11, -0x44f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17648 as u32) ) } as u64;
	// 822EE848: 814ABB14  lwz r10, -0x44ec(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17644 as u32) ) } as u64;
	// 822EE84C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EE850: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822EE854: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822EE858: 419A0388  beq cr6, 0x822eebe0
	if ctx.cr[6].eq {
	pc = 0x822EEBE0; continue 'dispatch;
	}
	// 822EE85C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822EE860: 4809E9F9  bl 0x8238d258
	ctx.lr = 0x822EE864;
	sub_8238D258(ctx, base);
	// 822EE864: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EE868: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822EE86C: 809DFAC0  lwz r4, -0x540(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 822EE870: 38EBC404  addi r7, r11, -0x3bfc
	ctx.r[7].s64 = ctx.r[11].s64 + -15356;
	// 822EE874: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822EE878: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822EE87C: 38600108  li r3, 0x108
	ctx.r[3].s64 = 264;
	// 822EE880: 4807BC11  bl 0x8236a490
	ctx.lr = 0x822EE884;
	sub_8236A490(ctx, base);
	// 822EE884: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EE888: 419A0010  beq cr6, 0x822ee898
	if ctx.cr[6].eq {
	pc = 0x822EE898; continue 'dispatch;
	}
	// 822EE88C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EE890: 396BC3C4  addi r11, r11, -0x3c3c
	ctx.r[11].s64 = ctx.r[11].s64 + -15420;
	// 822EE894: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x822EE898; continue 'dispatch;
            }
            0x822EE898 => {
    //   block [0x822EE898..0x822EE8AC)
	// 822EE898: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 822EE89C: 39610064  addi r11, r1, 0x64
	ctx.r[11].s64 = ctx.r[1].s64 + 100;
	// 822EE8A0: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 822EE8A4: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 822EE8A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x822EE8AC; continue 'dispatch;
            }
            0x822EE8AC => {
    //   block [0x822EE8AC..0x822EE8CC)
	// 822EE8AC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822EE8B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822EE8B4: 4200FFF8  bdnz 0x822ee8ac
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822EE8AC; continue 'dispatch;
	}
	// 822EE8B8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822EE8BC: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 822EE8C0: 3B8BBAEC  addi r28, r11, -0x4514
	ctx.r[28].s64 = ctx.r[11].s64 + -17684;
	// 822EE8C4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822EE8C8: 3B4BBACC  addi r26, r11, -0x4534
	ctx.r[26].s64 = ctx.r[11].s64 + -17716;
	pc = 0x822EE8CC; continue 'dispatch;
            }
            0x822EE8CC => {
    //   block [0x822EE8CC..0x822EE8F4)
	// 822EE8CC: 7D7DD02E  lwzx r11, r29, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 822EE8D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EE8D4: 419A0020  beq cr6, 0x822ee8f4
	if ctx.cr[6].eq {
	pc = 0x822EE8F4; continue 'dispatch;
	}
	// 822EE8D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822EE8DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822EE8E0: 7D7DE02E  lwzx r11, r29, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 822EE8E4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822EE8E8: 4809E971  bl 0x8238d258
	ctx.lr = 0x822EE8EC;
	sub_8238D258(ctx, base);
	// 822EE8EC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 822EE8F0: 7C7D592E  stwx r3, r29, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	pc = 0x822EE8F4; continue 'dispatch;
            }
            0x822EE8F4 => {
    //   block [0x822EE8F4..0x822EEA9C)
	// 822EE8F4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822EE8F8: 2B1D0020  cmplwi cr6, r29, 0x20
	ctx.cr[6].compare_u32(ctx.r[29].u32, 32 as u32, &mut ctx.xer);
	// 822EE8FC: 4198FFD0  blt cr6, 0x822ee8cc
	if ctx.cr[6].lt {
	pc = 0x822EE8CC; continue 'dispatch;
	}
	// 822EE900: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EE904: 4809E465  bl 0x8238cd68
	ctx.lr = 0x822EE908;
	sub_8238CD68(ctx, base);
	// 822EE908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EE90C: 907F0198  stw r3, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[3].u32 ) };
	// 822EE910: 419A02D0  beq cr6, 0x822eebe0
	if ctx.cr[6].eq {
	pc = 0x822EEBE0; continue 'dispatch;
	}
	// 822EE914: 3D60FFFF  lis r11, -1
	ctx.r[11].s64 = -65536;
	// 822EE918: 93610088  stw r27, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[27].u32 ) };
	// 822EE91C: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 822EE920: 9361008C  stw r27, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[27].u32 ) };
	// 822EE924: 616BFFFE  ori r11, r11, 0xfffe
	ctx.r[11].u64 = ctx.r[11].u64 | 65534;
	// 822EE928: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	// 822EE92C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 822EE930: 93610094  stw r27, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[27].u32 ) };
	// 822EE934: 796B000E  rldimi r11, r11, 0x20, 0
	ctx.r[11].u64 = ((ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFF00000000) | (ctx.r[11].u64 & 0x00000000FFFFFFFF);
	// 822EE938: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 822EE93C: 93810084  stw r28, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[28].u32 ) };
	// 822EE940: F96100C8  std r11, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u64 ) };
	// 822EE944: 396002AC  li r11, 0x2ac
	ctx.r[11].s64 = 684;
	// 822EE948: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 822EE94C: 794B000E  rldimi r11, r10, 0x20, 0
	ctx.r[11].u64 = ((ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFF00000000) | (ctx.r[11].u64 & 0x00000000FFFFFFFF);
	// 822EE950: 9381009C  stw r28, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[28].u32 ) };
	// 822EE954: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 822EE958: F96100D0  std r11, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	// 822EE95C: 39600210  li r11, 0x210
	ctx.r[11].s64 = 528;
	// 822EE960: 794B000E  rldimi r11, r10, 0x20, 0
	ctx.r[11].u64 = ((ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFF00000000) | (ctx.r[11].u64 & 0x00000000FFFFFFFF);
	// 822EE964: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 822EE968: F96100D8  std r11, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u64 ) };
	// 822EE96C: 39600240  li r11, 0x240
	ctx.r[11].s64 = 576;
	// 822EE970: 794B000E  rldimi r11, r10, 0x20, 0
	ctx.r[11].u64 = ((ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFF00000000) | (ctx.r[11].u64 & 0x00000000FFFFFFFF);
	// 822EE974: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 822EE978: F96100E0  std r11, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 822EE97C: 39600300  li r11, 0x300
	ctx.r[11].s64 = 768;
	// 822EE980: 794B000E  rldimi r11, r10, 0x20, 0
	ctx.r[11].u64 = ((ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFF00000000) | (ctx.r[11].u64 & 0x00000000FFFFFFFF);
	// 822EE984: F96100E8  std r11, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[11].u64 ) };
	// 822EE988: 3D604000  lis r11, 0x4000
	ctx.r[11].s64 = 1073741824;
	// 822EE98C: 616B0015  ori r11, r11, 0x15
	ctx.r[11].u64 = ctx.r[11].u64 | 21;
	// 822EE990: 796B26E4  sldi r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64.wrapping_shl(4);
	ctx.r[11].u32 = ctx.r[11].u64 as u32;
	// 822EE994: F96100F0  std r11, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u64 ) };
	// 822EE998: 3D6007F8  lis r11, 0x7f8
	ctx.r[11].s64 = 133693440;
	// 822EE99C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 822EE9A0: 796B7FE6  rldicr r11, r11, 0x2f, 0x3f
	ctx.r[11].u64 = (ctx.r[11].u64).rotate_left(47) & 0xFFFFFFFFFFFFFFFF;
	// 822EE9A4: F96100F8  std r11, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u64 ) };
	// 822EE9A8: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 822EE9AC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 822EE9B0: 4809EDF1  bl 0x8238d7a0
	ctx.lr = 0x822EE9B4;
	sub_8238D7A0(ctx, base);
	// 822EE9B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EE9B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EE9BC: 3BABC40C  addi r29, r11, -0x3bf4
	ctx.r[29].s64 = ctx.r[11].s64 + -15348;
	// 822EE9C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822EE9C4: 4809FBF5  bl 0x8238e5b8
	ctx.lr = 0x822EE9C8;
	sub_8238E5B8(ctx, base);
	// 822EE9C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EE9CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EE9D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822EE9D4: 917F01D8  stw r11, 0x1d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 822EE9D8: 4809FE61  bl 0x8238e838
	ctx.lr = 0x822EE9DC;
	sub_8238E838(ctx, base);
	// 822EE9DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EE9E0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 822EE9E4: 3BABC414  addi r29, r11, -0x3bec
	ctx.r[29].s64 = ctx.r[11].s64 + -15340;
	// 822EE9E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EE9EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822EE9F0: 915F01E4  stw r10, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[10].u32 ) };
	// 822EE9F4: 4809FBC5  bl 0x8238e5b8
	ctx.lr = 0x822EE9F8;
	sub_8238E5B8(ctx, base);
	// 822EE9F8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 822EE9FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EEA00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EEA04: 388BC420  addi r4, r11, -0x3be0
	ctx.r[4].s64 = ctx.r[11].s64 + -15328;
	// 822EEA08: 915F01F0  stw r10, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[10].u32 ) };
	// 822EEA0C: 4809FBAD  bl 0x8238e5b8
	ctx.lr = 0x822EEA10;
	sub_8238E5B8(ctx, base);
	// 822EEA10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822EEA14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EEA18: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822EEA1C: 917F01FC  stw r11, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[11].u32 ) };
	// 822EEA20: 4809FE19  bl 0x8238e838
	ctx.lr = 0x822EEA24;
	sub_8238E838(ctx, base);
	// 822EEA24: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 822EEA28: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EEA2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EEA30: 388BC430  addi r4, r11, -0x3bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -15312;
	// 822EEA34: 915F0208  stw r10, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[10].u32 ) };
	// 822EEA38: 4809FB81  bl 0x8238e5b8
	ctx.lr = 0x822EEA3C;
	sub_8238E5B8(ctx, base);
	// 822EEA3C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 822EEA40: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EEA44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EEA48: 388BC43C  addi r4, r11, -0x3bc4
	ctx.r[4].s64 = ctx.r[11].s64 + -15300;
	// 822EEA4C: 915F0214  stw r10, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[10].u32 ) };
	// 822EEA50: 4809FB69  bl 0x8238e5b8
	ctx.lr = 0x822EEA54;
	sub_8238E5B8(ctx, base);
	// 822EEA54: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 822EEA58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EEA5C: 915F0220  stw r10, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[10].u32 ) };
	// 822EEA60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EEA64: 388BC44C  addi r4, r11, -0x3bb4
	ctx.r[4].s64 = ctx.r[11].s64 + -15284;
	// 822EEA68: 4809FB51  bl 0x8238e5b8
	ctx.lr = 0x822EEA6C;
	sub_8238E5B8(ctx, base);
	// 822EEA6C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 822EEA70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EEA74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EEA78: 388BC454  addi r4, r11, -0x3bac
	ctx.r[4].s64 = ctx.r[11].s64 + -15276;
	// 822EEA7C: 915F022C  stw r10, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[10].u32 ) };
	// 822EEA80: 4809FB39  bl 0x8238e5b8
	ctx.lr = 0x822EEA84;
	sub_8238E5B8(ctx, base);
	// 822EEA84: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EEA88: 907F0238  stw r3, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[3].u32 ) };
	// 822EEA8C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 822EEA90: 937F0244  stw r27, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[27].u32 ) };
	// 822EEA94: 3B400008  li r26, 8
	ctx.r[26].s64 = 8;
	// 822EEA98: 3B2BC460  addi r25, r11, -0x3ba0
	ctx.r[25].s64 = ctx.r[11].s64 + -15264;
	pc = 0x822EEA9C; continue 'dispatch;
            }
            0x822EEA9C => {
    //   block [0x822EEA9C..0x822EEABC)
	// 822EEA9C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEAA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EEAA4: 419A0018  beq cr6, 0x822eeabc
	if ctx.cr[6].eq {
	pc = 0x822EEABC; continue 'dispatch;
	}
	// 822EEAA8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 822EEAAC: 4809FB0D  bl 0x8238e5b8
	ctx.lr = 0x822EEAB0;
	sub_8238E5B8(ctx, base);
	// 822EEAB0: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 822EEAB4: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 822EEAB8: 917F0244  stw r11, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[11].u32 ) };
	pc = 0x822EEABC; continue 'dispatch;
            }
            0x822EEABC => {
    //   block [0x822EEABC..0x822EEB04)
	// 822EEABC: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 822EEAC0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822EEAC4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 822EEAC8: 409AFFD4  bne cr6, 0x822eea9c
	if !ctx.cr[6].eq {
	pc = 0x822EEA9C; continue 'dispatch;
	}
	// 822EEACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEAD0: 939F0258  stw r28, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[28].u32 ) };
	// 822EEAD4: 48000775  bl 0x822ef248
	ctx.lr = 0x822EEAD8;
	sub_822EF248(ctx, base);
	// 822EEAD8: 817F0180  lwz r11, 0x180(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 822EEADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEAE0: 419A0024  beq cr6, 0x822eeb04
	if ctx.cr[6].eq {
	pc = 0x822EEB04; continue 'dispatch;
	}
	// 822EEAE4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EEAE8: 813F0188  lwz r9, 0x188(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 822EEAEC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822EEAF0: 409A0014  bne cr6, 0x822eeb04
	if !ctx.cr[6].eq {
	pc = 0x822EEB04; continue 'dispatch;
	}
	// 822EEAF4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEAF8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822EEAFC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822EEB00: 697B0001  xori r27, r11, 1
	ctx.r[27].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822EEB04; continue 'dispatch;
            }
            0x822EEB04 => {
    //   block [0x822EEB04..0x822EEB2C)
	// 822EEB04: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 822EEB08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEB0C: 419A00D4  beq cr6, 0x822eebe0
	if ctx.cr[6].eq {
	pc = 0x822EEBE0; continue 'dispatch;
	}
	// 822EEB10: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EEB14: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822EEB18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEB1C: 93CA0020  stw r30, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 822EEB20: 419A000C  beq cr6, 0x822eeb2c
	if ctx.cr[6].eq {
	pc = 0x822EEB2C; continue 'dispatch;
	}
	// 822EEB24: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EEB28: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x822EEB2C; continue 'dispatch;
            }
            0x822EEB2C => {
    //   block [0x822EEB2C..0x822EEB40)
	// 822EEB2C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822EEB30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEB34: 419A000C  beq cr6, 0x822eeb40
	if ctx.cr[6].eq {
	pc = 0x822EEB40; continue 'dispatch;
	}
	// 822EEB38: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EEB3C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x822EEB40; continue 'dispatch;
            }
            0x822EEB40 => {
    //   block [0x822EEB40..0x822EEB54)
	// 822EEB40: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 822EEB44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEB48: 419A000C  beq cr6, 0x822eeb54
	if ctx.cr[6].eq {
	pc = 0x822EEB54; continue 'dispatch;
	}
	// 822EEB4C: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EEB50: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x822EEB54; continue 'dispatch;
            }
            0x822EEB54 => {
    //   block [0x822EEB54..0x822EEB68)
	// 822EEB54: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822EEB58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEB5C: 419A000C  beq cr6, 0x822eeb68
	if ctx.cr[6].eq {
	pc = 0x822EEB68; continue 'dispatch;
	}
	// 822EEB60: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EEB64: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x822EEB68; continue 'dispatch;
            }
            0x822EEB68 => {
    //   block [0x822EEB68..0x822EEB7C)
	// 822EEB68: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 822EEB6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEB70: 419A000C  beq cr6, 0x822eeb7c
	if ctx.cr[6].eq {
	pc = 0x822EEB7C; continue 'dispatch;
	}
	// 822EEB74: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EEB78: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x822EEB7C; continue 'dispatch;
            }
            0x822EEB7C => {
    //   block [0x822EEB7C..0x822EEB90)
	// 822EEB7C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822EEB80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEB84: 419A000C  beq cr6, 0x822eeb90
	if ctx.cr[6].eq {
	pc = 0x822EEB90; continue 'dispatch;
	}
	// 822EEB88: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EEB8C: 916A0014  stw r11, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	pc = 0x822EEB90; continue 'dispatch;
            }
            0x822EEB90 => {
    //   block [0x822EEB90..0x822EEBA4)
	// 822EEB90: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 822EEB94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEB98: 419A000C  beq cr6, 0x822eeba4
	if ctx.cr[6].eq {
	pc = 0x822EEBA4; continue 'dispatch;
	}
	// 822EEB9C: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EEBA0: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x822EEBA4; continue 'dispatch;
            }
            0x822EEBA4 => {
    //   block [0x822EEBA4..0x822EEBB8)
	// 822EEBA4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 822EEBA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEBAC: 419A000C  beq cr6, 0x822eebb8
	if ctx.cr[6].eq {
	pc = 0x822EEBB8; continue 'dispatch;
	}
	// 822EEBB0: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EEBB4: 916A001C  stw r11, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	pc = 0x822EEBB8; continue 'dispatch;
            }
            0x822EEBB8 => {
    //   block [0x822EEBB8..0x822EEBE0)
	// 822EEBB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEBBC: 48000D5D  bl 0x822ef918
	ctx.lr = 0x822EEBC0;
	sub_822EF918(ctx, base);
	// 822EEBC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEBC4: 48001165  bl 0x822efd28
	ctx.lr = 0x822EEBC8;
	sub_822EFD28(ctx, base);
	// 822EEBC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEBCC: 4800177D  bl 0x822f0348
	ctx.lr = 0x822EEBD0;
	sub_822F0348(ctx, base);
	// 822EEBD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEBD4: 48001A5D  bl 0x822f0630
	ctx.lr = 0x822EEBD8;
	sub_822F0630(ctx, base);
	// 822EEBD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEBDC: 48001D75  bl 0x822f0950
	ctx.lr = 0x822EEBE0;
	sub_822F0950(ctx, base);
	pc = 0x822EEBE0; continue 'dispatch;
            }
            0x822EEBE0 => {
    //   block [0x822EEBE0..0x822EEBE8)
	// 822EEBE0: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 822EEBE4: 48246518  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EEBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EEBE8 size=280
    let mut pc: u32 = 0x822EEBE8;
    'dispatch: loop {
        match pc {
            0x822EEBE8 => {
    //   block [0x822EEBE8..0x822EEC50)
	// 822EEBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EEBEC: 482464C5  bl 0x825350b0
	ctx.lr = 0x822EEBF0;
	sub_82535080(ctx, base);
	// 822EEBF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EEBF4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822EEBF8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 822EEBFC: 3B4BBFF0  addi r26, r11, -0x4010
	ctx.r[26].s64 = ctx.r[11].s64 + -16400;
	// 822EEC00: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822EEC04: 614A8608  ori r10, r10, 0x8608
	ctx.r[10].u64 = ctx.r[10].u64 | 34312;
	// 822EEC08: 616B8600  ori r11, r11, 0x8600
	ctx.r[11].u64 = ctx.r[11].u64 | 34304;
	// 822EEC0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EEC10: 7D5A502E  lwzx r10, r26, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822EEC14: 7D7A582E  lwzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EEC18: 7D6A5378  or r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 822EEC1C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822EEC20: 616B860C  ori r11, r11, 0x860c
	ctx.r[11].u64 = ctx.r[11].u64 | 34316;
	// 822EEC24: 7D7A582E  lwzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EEC28: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 822EEC2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822EEC30: 419A0020  beq cr6, 0x822eec50
	if ctx.cr[6].eq {
	pc = 0x822EEC50; continue 'dispatch;
	}
	// 822EEC34: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822EEC38: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822EEC3C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 822EEC40: 514B552A  rlwimi r11, r10, 0xa, 0x14, 0x15
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(10) as u64) & 0x0000000000000C00) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFF3FF);
	// 822EEC44: B17F0014  sth r11, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 822EEC48: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EEC4C: 482464B4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822EEC50 => {
    //   block [0x822EEC50..0x822EEC70)
	// 822EEC50: 815F0254  lwz r10, 0x254(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 822EEC54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822EEC58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EEC5C: 419A0014  beq cr6, 0x822eec70
	if ctx.cr[6].eq {
	pc = 0x822EEC70; continue 'dispatch;
	}
	// 822EEC60: A15F0014  lhz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822EEC64: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 822EEC68: 516A5D2A  rlwimi r10, r11, 0xb, 0x14, 0x15
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(11) as u64) & 0x0000000000000C00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFF3FF);
	// 822EEC6C: B15F0014  sth r10, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x822EEC70; continue 'dispatch;
            }
            0x822EEC70 => {
    //   block [0x822EEC70..0x822EEC80)
	// 822EEC70: 3BDF01B0  addi r30, r31, 0x1b0
	ctx.r[30].s64 = ctx.r[31].s64 + 432;
	// 822EEC74: 917F015C  stw r11, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 822EEC78: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 822EEC7C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x822EEC80; continue 'dispatch;
            }
            0x822EEC80 => {
    //   block [0x822EEC80..0x822EECC0)
	// 822EEC80: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEC84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EEC88: 419A0038  beq cr6, 0x822eecc0
	if ctx.cr[6].eq {
	pc = 0x822EECC0; continue 'dispatch;
	}
	// 822EEC8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEC90: 3BBF0080  addi r29, r31, 0x80
	ctx.r[29].s64 = ctx.r[31].s64 + 128;
	// 822EEC94: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822EEC98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EEC9C: 4E800421  bctrl
	ctx.lr = 0x822EECA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EECA0: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 822EECA4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EECA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822EECAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EECB0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822EECB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EECB8: 4E800421  bctrl
	ctx.lr = 0x822EECBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EECBC: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
            }
            0x822EECC0 => {
    //   block [0x822EECC0..0x822EECF8)
	// 822EECC0: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 822EECC4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EECC8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822EECCC: 409AFFB4  bne cr6, 0x822eec80
	if !ctx.cr[6].eq {
	pc = 0x822EEC80; continue 'dispatch;
	}
	// 822EECD0: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 822EECD4: 939F01C0  stw r28, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[28].u32 ) };
	// 822EECD8: 939F015C  stw r28, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[28].u32 ) };
	// 822EECDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EECE0: 419A0018  beq cr6, 0x822eecf8
	if ctx.cr[6].eq {
	pc = 0x822EECF8; continue 'dispatch;
	}
	// 822EECE4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EECE8: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 822EECEC: 616B85E0  ori r11, r11, 0x85e0
	ctx.r[11].u64 = ctx.r[11].u64 | 34272;
	// 822EECF0: 7C3A5C2E  lfsx f1, r26, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822EECF4: 481A4F15  bl 0x82493c08
	ctx.lr = 0x822EECF8;
	sub_82493C08(ctx, base);
	pc = 0x822EECF8; continue 'dispatch;
            }
            0x822EECF8 => {
    //   block [0x822EECF8..0x822EED00)
	// 822EECF8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EECFC: 48246404  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EED00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EED00 size=1348
    let mut pc: u32 = 0x822EED00;
    'dispatch: loop {
        match pc {
            0x822EED00 => {
    //   block [0x822EED00..0x822EED28)
	// 822EED00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EED04: 482463AD  bl 0x825350b0
	ctx.lr = 0x822EED08;
	sub_82535080(ctx, base);
	// 822EED08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EED0C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822EED10: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822EED14: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 822EED18: 817D01D8  lwz r11, 0x1d8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) } as u64;
	// 822EED1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EED20: 40990078  ble cr6, 0x822eed98
	if !ctx.cr[6].gt {
	pc = 0x822EED98; continue 'dispatch;
	}
	// 822EED24: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	pc = 0x822EED28; continue 'dispatch;
            }
            0x822EED28 => {
    //   block [0x822EED28..0x822EED7C)
	// 822EED28: 817D01DC  lwz r11, 0x1dc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(476 as u32) ) } as u64;
	// 822EED2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EED30: 419A0054  beq cr6, 0x822eed84
	if ctx.cr[6].eq {
	pc = 0x822EED84; continue 'dispatch;
	}
	// 822EED34: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 822EED38: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EED3C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822EED40: 409A0044  bne cr6, 0x822eed84
	if !ctx.cr[6].eq {
	pc = 0x822EED84; continue 'dispatch;
	}
	// 822EED44: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822EED48: 815D01E0  lwz r10, 0x1e0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(480 as u32) ) } as u64;
	// 822EED4C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EED50: 83FD0198  lwz r31, 0x198(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(408 as u32) ) } as u64;
	// 822EED54: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822EED58: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EED5C: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EED60: 481A5C51  bl 0x824949b0
	ctx.lr = 0x822EED64;
	sub_824949B0(ctx, base);
	// 822EED64: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822EED68: 419A0014  beq cr6, 0x822eed7c
	if ctx.cr[6].eq {
	pc = 0x822EED7C; continue 'dispatch;
	}
	// 822EED6C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822EED70: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EED74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822EED78: 481A4889  bl 0x82493600
	ctx.lr = 0x822EED7C;
	sub_82493600(ctx, base);
	pc = 0x822EED7C; continue 'dispatch;
            }
            0x822EED7C => {
    //   block [0x822EED7C..0x822EED84)
	// 822EED7C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EED80: 481A4461  bl 0x824931e0
	ctx.lr = 0x822EED84;
	sub_824931E0(ctx, base);
	pc = 0x822EED84; continue 'dispatch;
            }
            0x822EED84 => {
    //   block [0x822EED84..0x822EED98)
	// 822EED84: 817D01D8  lwz r11, 0x1d8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) } as u64;
	// 822EED88: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 822EED8C: 3B9C0018  addi r28, r28, 0x18
	ctx.r[28].s64 = ctx.r[28].s64 + 24;
	// 822EED90: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EED94: 4198FF94  blt cr6, 0x822eed28
	if ctx.cr[6].lt {
	pc = 0x822EED28; continue 'dispatch;
	}
	pc = 0x822EED98; continue 'dispatch;
            }
            0x822EED98 => {
    //   block [0x822EED98..0x822EEDD0)
	// 822EED98: 83FD0198  lwz r31, 0x198(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(408 as u32) ) } as u64;
	// 822EED9C: 3F608273  lis r27, -0x7d8d
	ctx.r[27].s64 = -2106392576;
	// 822EEDA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822EEDA4: 419A002C  beq cr6, 0x822eedd0
	if ctx.cr[6].eq {
	pc = 0x822EEDD0; continue 'dispatch;
	}
	// 822EEDA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEDAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822EEDB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEDB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEDB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EEDBC: 4E800421  bctrl
	ctx.lr = 0x822EEDC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EEDC0: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822EEDC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEDC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EEDCC: 4E800421  bctrl
	ctx.lr = 0x822EEDD0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EEDD0 => {
    //   block [0x822EEDD0..0x822EEDE4)
	// 822EEDD0: 817D01D8  lwz r11, 0x1d8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) } as u64;
	// 822EEDD4: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 822EEDD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEDDC: 40990060  ble cr6, 0x822eee3c
	if !ctx.cr[6].gt {
	pc = 0x822EEE3C; continue 'dispatch;
	}
	// 822EEDE0: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x822EEDE4; continue 'dispatch;
            }
            0x822EEDE4 => {
    //   block [0x822EEDE4..0x822EEE28)
	// 822EEDE4: 817D01E0  lwz r11, 0x1e0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(480 as u32) ) } as u64;
	// 822EEDE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEDEC: 419A003C  beq cr6, 0x822eee28
	if ctx.cr[6].eq {
	pc = 0x822EEE28; continue 'dispatch;
	}
	// 822EEDF0: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EEDF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EEDF8: 419A0030  beq cr6, 0x822eee28
	if ctx.cr[6].eq {
	pc = 0x822EEE28; continue 'dispatch;
	}
	// 822EEDFC: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822EEE00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822EEE04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEE08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEE0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEE10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EEE14: 4E800421  bctrl
	ctx.lr = 0x822EEE18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EEE18: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822EEE1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEE20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EEE24: 4E800421  bctrl
	ctx.lr = 0x822EEE28;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EEE28 => {
    //   block [0x822EEE28..0x822EEE3C)
	// 822EEE28: 817D01D8  lwz r11, 0x1d8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) } as u64;
	// 822EEE2C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822EEE30: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EEE34: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EEE38: 4198FFAC  blt cr6, 0x822eede4
	if ctx.cr[6].lt {
	pc = 0x822EEDE4; continue 'dispatch;
	}
	pc = 0x822EEE3C; continue 'dispatch;
            }
            0x822EEE3C => {
    //   block [0x822EEE3C..0x822EEE50)
	// 822EEE3C: 817D01F0  lwz r11, 0x1f0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(496 as u32) ) } as u64;
	// 822EEE40: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 822EEE44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEE48: 40990060  ble cr6, 0x822eeea8
	if !ctx.cr[6].gt {
	pc = 0x822EEEA8; continue 'dispatch;
	}
	// 822EEE4C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x822EEE50; continue 'dispatch;
            }
            0x822EEE50 => {
    //   block [0x822EEE50..0x822EEE94)
	// 822EEE50: 817D01F8  lwz r11, 0x1f8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(504 as u32) ) } as u64;
	// 822EEE54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEE58: 419A003C  beq cr6, 0x822eee94
	if ctx.cr[6].eq {
	pc = 0x822EEE94; continue 'dispatch;
	}
	// 822EEE5C: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EEE60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EEE64: 419A0030  beq cr6, 0x822eee94
	if ctx.cr[6].eq {
	pc = 0x822EEE94; continue 'dispatch;
	}
	// 822EEE68: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822EEE6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822EEE70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEE74: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEE78: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEE7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EEE80: 4E800421  bctrl
	ctx.lr = 0x822EEE84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EEE84: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822EEE88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEE8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EEE90: 4E800421  bctrl
	ctx.lr = 0x822EEE94;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EEE94 => {
    //   block [0x822EEE94..0x822EEEA8)
	// 822EEE94: 817D01F0  lwz r11, 0x1f0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(496 as u32) ) } as u64;
	// 822EEE98: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822EEE9C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EEEA0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EEEA4: 4198FFAC  blt cr6, 0x822eee50
	if ctx.cr[6].lt {
	pc = 0x822EEE50; continue 'dispatch;
	}
	pc = 0x822EEEA8; continue 'dispatch;
            }
            0x822EEEA8 => {
    //   block [0x822EEEA8..0x822EEEBC)
	// 822EEEA8: 817D01FC  lwz r11, 0x1fc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(508 as u32) ) } as u64;
	// 822EEEAC: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 822EEEB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEEB4: 40990060  ble cr6, 0x822eef14
	if !ctx.cr[6].gt {
	pc = 0x822EEF14; continue 'dispatch;
	}
	// 822EEEB8: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x822EEEBC; continue 'dispatch;
            }
            0x822EEEBC => {
    //   block [0x822EEEBC..0x822EEF00)
	// 822EEEBC: 817D0204  lwz r11, 0x204(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(516 as u32) ) } as u64;
	// 822EEEC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEEC4: 419A003C  beq cr6, 0x822eef00
	if ctx.cr[6].eq {
	pc = 0x822EEF00; continue 'dispatch;
	}
	// 822EEEC8: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EEECC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EEED0: 419A0030  beq cr6, 0x822eef00
	if ctx.cr[6].eq {
	pc = 0x822EEF00; continue 'dispatch;
	}
	// 822EEED4: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822EEED8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822EEEDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEEE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEEE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEEE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EEEEC: 4E800421  bctrl
	ctx.lr = 0x822EEEF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EEEF0: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822EEEF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEEF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EEEFC: 4E800421  bctrl
	ctx.lr = 0x822EEF00;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EEF00 => {
    //   block [0x822EEF00..0x822EEF14)
	// 822EEF00: 817D01FC  lwz r11, 0x1fc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(508 as u32) ) } as u64;
	// 822EEF04: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822EEF08: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EEF0C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EEF10: 4198FFAC  blt cr6, 0x822eeebc
	if ctx.cr[6].lt {
	pc = 0x822EEEBC; continue 'dispatch;
	}
	pc = 0x822EEF14; continue 'dispatch;
            }
            0x822EEF14 => {
    //   block [0x822EEF14..0x822EEF28)
	// 822EEF14: 817D0214  lwz r11, 0x214(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(532 as u32) ) } as u64;
	// 822EEF18: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 822EEF1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEF20: 40990060  ble cr6, 0x822eef80
	if !ctx.cr[6].gt {
	pc = 0x822EEF80; continue 'dispatch;
	}
	// 822EEF24: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x822EEF28; continue 'dispatch;
            }
            0x822EEF28 => {
    //   block [0x822EEF28..0x822EEF6C)
	// 822EEF28: 817D021C  lwz r11, 0x21c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(540 as u32) ) } as u64;
	// 822EEF2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEF30: 419A003C  beq cr6, 0x822eef6c
	if ctx.cr[6].eq {
	pc = 0x822EEF6C; continue 'dispatch;
	}
	// 822EEF34: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EEF38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EEF3C: 419A0030  beq cr6, 0x822eef6c
	if ctx.cr[6].eq {
	pc = 0x822EEF6C; continue 'dispatch;
	}
	// 822EEF40: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822EEF44: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822EEF48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEF4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEF50: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEF54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EEF58: 4E800421  bctrl
	ctx.lr = 0x822EEF5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EEF5C: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822EEF60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEF64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EEF68: 4E800421  bctrl
	ctx.lr = 0x822EEF6C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EEF6C => {
    //   block [0x822EEF6C..0x822EEF80)
	// 822EEF6C: 817D0214  lwz r11, 0x214(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(532 as u32) ) } as u64;
	// 822EEF70: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822EEF74: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EEF78: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EEF7C: 4198FFAC  blt cr6, 0x822eef28
	if ctx.cr[6].lt {
	pc = 0x822EEF28; continue 'dispatch;
	}
	pc = 0x822EEF80; continue 'dispatch;
            }
            0x822EEF80 => {
    //   block [0x822EEF80..0x822EEF94)
	// 822EEF80: 817D0220  lwz r11, 0x220(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(544 as u32) ) } as u64;
	// 822EEF84: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 822EEF88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEF8C: 40990060  ble cr6, 0x822eefec
	if !ctx.cr[6].gt {
	pc = 0x822EEFEC; continue 'dispatch;
	}
	// 822EEF90: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x822EEF94; continue 'dispatch;
            }
            0x822EEF94 => {
    //   block [0x822EEF94..0x822EEFD8)
	// 822EEF94: 817D0228  lwz r11, 0x228(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(552 as u32) ) } as u64;
	// 822EEF98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEF9C: 419A003C  beq cr6, 0x822eefd8
	if ctx.cr[6].eq {
	pc = 0x822EEFD8; continue 'dispatch;
	}
	// 822EEFA0: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EEFA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EEFA8: 419A0030  beq cr6, 0x822eefd8
	if ctx.cr[6].eq {
	pc = 0x822EEFD8; continue 'dispatch;
	}
	// 822EEFAC: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822EEFB0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822EEFB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEFB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEFBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EEFC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EEFC4: 4E800421  bctrl
	ctx.lr = 0x822EEFC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EEFC8: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822EEFCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EEFD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EEFD4: 4E800421  bctrl
	ctx.lr = 0x822EEFD8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EEFD8 => {
    //   block [0x822EEFD8..0x822EEFEC)
	// 822EEFD8: 817D0220  lwz r11, 0x220(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(544 as u32) ) } as u64;
	// 822EEFDC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822EEFE0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EEFE4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EEFE8: 4198FFAC  blt cr6, 0x822eef94
	if ctx.cr[6].lt {
	pc = 0x822EEF94; continue 'dispatch;
	}
	pc = 0x822EEFEC; continue 'dispatch;
            }
            0x822EEFEC => {
    //   block [0x822EEFEC..0x822EF000)
	// 822EEFEC: 817D022C  lwz r11, 0x22c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(556 as u32) ) } as u64;
	// 822EEFF0: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 822EEFF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EEFF8: 40990060  ble cr6, 0x822ef058
	if !ctx.cr[6].gt {
	pc = 0x822EF058; continue 'dispatch;
	}
	// 822EEFFC: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x822EF000; continue 'dispatch;
            }
            0x822EF000 => {
    //   block [0x822EF000..0x822EF044)
	// 822EF000: 817D0234  lwz r11, 0x234(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(564 as u32) ) } as u64;
	// 822EF004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EF008: 419A003C  beq cr6, 0x822ef044
	if ctx.cr[6].eq {
	pc = 0x822EF044; continue 'dispatch;
	}
	// 822EF00C: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EF010: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF014: 419A0030  beq cr6, 0x822ef044
	if ctx.cr[6].eq {
	pc = 0x822EF044; continue 'dispatch;
	}
	// 822EF018: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822EF01C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822EF020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EF024: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EF028: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EF02C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EF030: 4E800421  bctrl
	ctx.lr = 0x822EF034;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EF034: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822EF038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EF03C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EF040: 4E800421  bctrl
	ctx.lr = 0x822EF044;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EF044 => {
    //   block [0x822EF044..0x822EF058)
	// 822EF044: 817D022C  lwz r11, 0x22c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(556 as u32) ) } as u64;
	// 822EF048: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822EF04C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EF050: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EF054: 4198FFAC  blt cr6, 0x822ef000
	if ctx.cr[6].lt {
	pc = 0x822EF000; continue 'dispatch;
	}
	pc = 0x822EF058; continue 'dispatch;
            }
            0x822EF058 => {
    //   block [0x822EF058..0x822EF06C)
	// 822EF058: 817D0238  lwz r11, 0x238(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(568 as u32) ) } as u64;
	// 822EF05C: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 822EF060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EF064: 40990060  ble cr6, 0x822ef0c4
	if !ctx.cr[6].gt {
	pc = 0x822EF0C4; continue 'dispatch;
	}
	// 822EF068: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x822EF06C; continue 'dispatch;
            }
            0x822EF06C => {
    //   block [0x822EF06C..0x822EF0B0)
	// 822EF06C: 817D0240  lwz r11, 0x240(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(576 as u32) ) } as u64;
	// 822EF070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EF074: 419A003C  beq cr6, 0x822ef0b0
	if ctx.cr[6].eq {
	pc = 0x822EF0B0; continue 'dispatch;
	}
	// 822EF078: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EF07C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF080: 419A0030  beq cr6, 0x822ef0b0
	if ctx.cr[6].eq {
	pc = 0x822EF0B0; continue 'dispatch;
	}
	// 822EF084: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822EF088: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822EF08C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EF090: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EF094: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EF098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EF09C: 4E800421  bctrl
	ctx.lr = 0x822EF0A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EF0A0: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822EF0A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EF0A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EF0AC: 4E800421  bctrl
	ctx.lr = 0x822EF0B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EF0B0 => {
    //   block [0x822EF0B0..0x822EF0C4)
	// 822EF0B0: 817D0238  lwz r11, 0x238(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(568 as u32) ) } as u64;
	// 822EF0B4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822EF0B8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EF0BC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EF0C0: 4198FFAC  blt cr6, 0x822ef06c
	if ctx.cr[6].lt {
	pc = 0x822EF06C; continue 'dispatch;
	}
	pc = 0x822EF0C4; continue 'dispatch;
            }
            0x822EF0C4 => {
    //   block [0x822EF0C4..0x822EF0D8)
	// 822EF0C4: 817D0244  lwz r11, 0x244(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(580 as u32) ) } as u64;
	// 822EF0C8: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 822EF0CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EF0D0: 40990060  ble cr6, 0x822ef130
	if !ctx.cr[6].gt {
	pc = 0x822EF130; continue 'dispatch;
	}
	// 822EF0D4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x822EF0D8; continue 'dispatch;
            }
            0x822EF0D8 => {
    //   block [0x822EF0D8..0x822EF11C)
	// 822EF0D8: 817D024C  lwz r11, 0x24c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(588 as u32) ) } as u64;
	// 822EF0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EF0E0: 419A003C  beq cr6, 0x822ef11c
	if ctx.cr[6].eq {
	pc = 0x822EF11C; continue 'dispatch;
	}
	// 822EF0E4: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EF0E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF0EC: 419A0030  beq cr6, 0x822ef11c
	if ctx.cr[6].eq {
	pc = 0x822EF11C; continue 'dispatch;
	}
	// 822EF0F0: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822EF0F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822EF0F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EF0FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EF100: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EF104: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EF108: 4E800421  bctrl
	ctx.lr = 0x822EF10C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EF10C: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822EF110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EF114: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EF118: 4E800421  bctrl
	ctx.lr = 0x822EF11C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822EF11C => {
    //   block [0x822EF11C..0x822EF130)
	// 822EF11C: 817D0244  lwz r11, 0x244(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(580 as u32) ) } as u64;
	// 822EF120: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822EF124: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EF128: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822EF12C: 4198FFAC  blt cr6, 0x822ef0d8
	if ctx.cr[6].lt {
	pc = 0x822EF0D8; continue 'dispatch;
	}
	pc = 0x822EF130; continue 'dispatch;
            }
            0x822EF130 => {
    //   block [0x822EF130..0x822EF134)
	// 822EF130: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x822EF134; continue 'dispatch;
            }
            0x822EF134 => {
    //   block [0x822EF134..0x822EF180)
	// 822EF134: 817D019C  lwz r11, 0x19c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EF138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EF13C: 419A0044  beq cr6, 0x822ef180
	if ctx.cr[6].eq {
	pc = 0x822EF180; continue 'dispatch;
	}
	// 822EF140: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 822EF144: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF148: 419A0038  beq cr6, 0x822ef180
	if ctx.cr[6].eq {
	pc = 0x822EF180; continue 'dispatch;
	}
	// 822EF14C: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822EF150: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822EF154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EF158: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EF15C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EF160: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EF164: 4E800421  bctrl
	ctx.lr = 0x822EF168;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EF168: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822EF16C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822EF170: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822EF174: 4E800421  bctrl
	ctx.lr = 0x822EF178;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822EF178: 817D019C  lwz r11, 0x19c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EF17C: 7F5E592E  stwx r26, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[26].u32) };
            }
            0x822EF180 => {
    //   block [0x822EF180..0x822EF1A8)
	// 822EF180: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822EF184: 2B1E0020  cmplwi cr6, r30, 0x20
	ctx.cr[6].compare_u32(ctx.r[30].u32, 32 as u32, &mut ctx.xer);
	// 822EF188: 4198FFAC  blt cr6, 0x822ef134
	if ctx.cr[6].lt {
	pc = 0x822EF134; continue 'dispatch;
	}
	// 822EF18C: 397D0180  addi r11, r29, 0x180
	ctx.r[11].s64 = ctx.r[29].s64 + 384;
	// 822EF190: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 822EF194: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EF198: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 822EF19C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EF1A0: 419A0008  beq cr6, 0x822ef1a8
	if ctx.cr[6].eq {
	pc = 0x822EF1A8; continue 'dispatch;
	}
	// 822EF1A4: 4BE2DEB5  bl 0x8211d058
	ctx.lr = 0x822EF1A8;
	sub_8211D058(ctx, base);
	pc = 0x822EF1A8; continue 'dispatch;
            }
            0x822EF1A8 => {
    //   block [0x822EF1A8..0x822EF1CC)
	// 822EF1A8: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 822EF1AC: 392BE540  addi r9, r11, -0x1ac0
	ctx.r[9].s64 = ctx.r[11].s64 + -6848;
	// 822EF1B0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EF1B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EF1B8: 419A0014  beq cr6, 0x822ef1cc
	if ctx.cr[6].eq {
	pc = 0x822EF1CC; continue 'dispatch;
	}
	// 822EF1BC: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822EF1C0: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EF1C4: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822EF1C8: 419A0008  beq cr6, 0x822ef1d0
	if ctx.cr[6].eq {
	pc = 0x822EF1D0; continue 'dispatch;
	}
	pc = 0x822EF1CC; continue 'dispatch;
            }
            0x822EF1CC => {
    //   block [0x822EF1CC..0x822EF1D0)
	// 822EF1CC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822EF1D0; continue 'dispatch;
            }
            0x822EF1D0 => {
    //   block [0x822EF1D0..0x822EF1E0)
	// 822EF1D0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822EF1D4: 409A000C  bne cr6, 0x822ef1e0
	if !ctx.cr[6].eq {
	pc = 0x822EF1E0; continue 'dispatch;
	}
	// 822EF1D8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 822EF1DC: F9690000  std r11, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	pc = 0x822EF1E0; continue 'dispatch;
            }
            0x822EF1E0 => {
    //   block [0x822EF1E0..0x822EF1F4)
	// 822EF1E0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822EF1E4: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 822EF1E8: 396BBAEC  addi r11, r11, -0x4514
	ctx.r[11].s64 = ctx.r[11].s64 + -17684;
	// 822EF1EC: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 822EF1F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x822EF1F4; continue 'dispatch;
            }
            0x822EF1F4 => {
    //   block [0x822EF1F4..0x822EF214)
	// 822EF1F4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822EF1F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822EF1FC: 4200FFF8  bdnz 0x822ef1f4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822EF1F4; continue 'dispatch;
	}
	// 822EF200: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822EF204: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 822EF208: 396BBACC  addi r11, r11, -0x4534
	ctx.r[11].s64 = ctx.r[11].s64 + -17716;
	// 822EF20C: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 822EF210: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x822EF214; continue 'dispatch;
            }
            0x822EF214 => {
    //   block [0x822EF214..0x822EF244)
	// 822EF214: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822EF218: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822EF21C: 4200FFF8  bdnz 0x822ef214
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822EF214; continue 'dispatch;
	}
	// 822EF220: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 822EF224: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 822EF228: 916ABB0C  stw r11, -0x44f4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17652 as u32), ctx.r[11].u32 ) };
	// 822EF22C: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 822EF230: 916ABB10  stw r11, -0x44f0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17648 as u32), ctx.r[11].u32 ) };
	// 822EF234: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 822EF238: 916ABB14  stw r11, -0x44ec(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17644 as u32), ctx.r[11].u32 ) };
	// 822EF23C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822EF240: 48245EC0  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EF248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EF248 size=1740
    let mut pc: u32 = 0x822EF248;
    'dispatch: loop {
        match pc {
            0x822EF248 => {
    //   block [0x822EF248..0x822EF308)
	// 822EF248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EF24C: 48245E5D  bl 0x825350a8
	ctx.lr = 0x822EF250;
	sub_82535080(ctx, base);
	// 822EF250: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EF254: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822EF258: 3B9F0180  addi r28, r31, 0x180
	ctx.r[28].s64 = ctx.r[31].s64 + 384;
	// 822EF25C: 807F0208  lwz r3, 0x208(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 822EF260: 817F0214  lwz r11, 0x214(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 822EF264: 547E083C  slwi r30, r3, 1
	ctx.r[30].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 822EF268: 815F0220  lwz r10, 0x220(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 822EF26C: 813F01FC  lwz r9, 0x1fc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 822EF270: 7FDE5A14  add r30, r30, r11
	ctx.r[30].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 822EF274: 811F01D8  lwz r8, 0x1d8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 822EF278: 80FF0238  lwz r7, 0x238(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 822EF27C: 7FBE5214  add r29, r30, r10
	ctx.r[29].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 822EF280: 80DF022C  lwz r6, 0x22c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 822EF284: 7FC84A14  add r30, r8, r9
	ctx.r[30].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 822EF288: 80BF0244  lwz r5, 0x244(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 822EF28C: 7FBD3A14  add r29, r29, r7
	ctx.r[29].u64 = ctx.r[29].u64 + ctx.r[7].u64;
	// 822EF290: 809F01F0  lwz r4, 0x1f0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(496 as u32) ) } as u64;
	// 822EF294: 7FDE3214  add r30, r30, r6
	ctx.r[30].u64 = ctx.r[30].u64 + ctx.r[6].u64;
	// 822EF298: 807F01E4  lwz r3, 0x1e4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 822EF29C: 7FBD2A14  add r29, r29, r5
	ctx.r[29].u64 = ctx.r[29].u64 + ctx.r[5].u64;
	// 822EF2A0: 57D8083C  slwi r24, r30, 1
	ctx.r[24].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 822EF2A4: 57B9103A  slwi r25, r29, 2
	ctx.r[25].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 822EF2A8: 7F1EC214  add r24, r30, r24
	ctx.r[24].u64 = ctx.r[30].u64 + ctx.r[24].u64;
	// 822EF2AC: 7FDDCA14  add r30, r29, r25
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[25].u64;
	// 822EF2B0: 7F632214  add r27, r3, r4
	ctx.r[27].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 822EF2B4: 571D083C  slwi r29, r24, 1
	ctx.r[29].u32 = ctx.r[24].u32.wrapping_shl(1);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 822EF2B8: 577A1838  slwi r26, r27, 3
	ctx.r[26].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 822EF2BC: 837C0000  lwz r27, 0(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EF2C0: 7FDEEA14  add r30, r30, r29
	ctx.r[30].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 822EF2C4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822EF2C8: 7FDED214  add r30, r30, r26
	ctx.r[30].u64 = ctx.r[30].u64 + ctx.r[26].u64;
	// 822EF2CC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822EF2D0: 7C7E1A14  add r3, r30, r3
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[3].u64;
	// 822EF2D4: 7C832214  add r4, r3, r4
	ctx.r[4].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 822EF2D8: 7D044214  add r8, r4, r8
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[8].u64;
	// 822EF2DC: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 822EF2E0: 7D293214  add r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	// 822EF2E4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 822EF2E8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822EF2EC: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 822EF2F0: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 822EF2F4: 396B02A9  addi r11, r11, 0x2a9
	ctx.r[11].s64 = ctx.r[11].s64 + 681;
	// 822EF2F8: 557D103A  slwi r29, r11, 2
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 822EF2FC: 409A000C  bne cr6, 0x822ef308
	if !ctx.cr[6].eq {
	pc = 0x822EF308; continue 'dispatch;
	}
	// 822EF300: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 822EF304: 4800002C  b 0x822ef330
	pc = 0x822EF330; continue 'dispatch;
            }
            0x822EF308 => {
    //   block [0x822EF308..0x822EF320)
	// 822EF308: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EF30C: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EF310: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822EF314: 419A000C  beq cr6, 0x822ef320
	if ctx.cr[6].eq {
	pc = 0x822EF320; continue 'dispatch;
	}
	// 822EF318: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 822EF31C: 48000014  b 0x822ef330
	pc = 0x822EF330; continue 'dispatch;
            }
            0x822EF320 => {
    //   block [0x822EF320..0x822EF330)
	// 822EF320: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EF324: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822EF328: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822EF32C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822EF330; continue 'dispatch;
            }
            0x822EF330 => {
    //   block [0x822EF330..0x822EF354)
	// 822EF330: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822EF334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EF338: 419A001C  beq cr6, 0x822ef354
	if ctx.cr[6].eq {
	pc = 0x822EF354; continue 'dispatch;
	}
	// 822EF33C: 935C0000  stw r26, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 822EF340: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EF344: 935C0004  stw r26, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 822EF348: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EF34C: 419A0008  beq cr6, 0x822ef354
	if ctx.cr[6].eq {
	pc = 0x822EF354; continue 'dispatch;
	}
	// 822EF350: 4BE2DD09  bl 0x8211d058
	ctx.lr = 0x822EF354;
	sub_8211D058(ctx, base);
	pc = 0x822EF354; continue 'dispatch;
            }
            0x822EF354 => {
    //   block [0x822EF354..0x822EF384)
	// 822EF354: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EF358: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822EF35C: 38CBC46C  addi r6, r11, -0x3b94
	ctx.r[6].s64 = ctx.r[11].s64 + -15252;
	// 822EF360: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 822EF364: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822EF368: 386BDBE0  addi r3, r11, -0x2420
	ctx.r[3].s64 = ctx.r[11].s64 + -9248;
	// 822EF36C: 4BF05F7D  bl 0x821f52e8
	ctx.lr = 0x822EF370;
	sub_821F52E8(ctx, base);
	// 822EF370: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EF374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EF378: 409A000C  bne cr6, 0x822ef384
	if !ctx.cr[6].eq {
	pc = 0x822EF384; continue 'dispatch;
	}
	// 822EF37C: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 822EF380: 4800002C  b 0x822ef3ac
	pc = 0x822EF3AC; continue 'dispatch;
            }
            0x822EF384 => {
    //   block [0x822EF384..0x822EF39C)
	// 822EF384: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EF388: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EF38C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822EF390: 419A000C  beq cr6, 0x822ef39c
	if ctx.cr[6].eq {
	pc = 0x822EF39C; continue 'dispatch;
	}
	// 822EF394: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 822EF398: 48000014  b 0x822ef3ac
	pc = 0x822EF3AC; continue 'dispatch;
            }
            0x822EF39C => {
    //   block [0x822EF39C..0x822EF3AC)
	// 822EF39C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EF3A0: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 822EF3A4: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822EF3A8: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	pc = 0x822EF3AC; continue 'dispatch;
            }
            0x822EF3AC => {
    //   block [0x822EF3AC..0x822EF3C0)
	// 822EF3AC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822EF3B0: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 822EF3B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF3B8: 419A0008  beq cr6, 0x822ef3c0
	if ctx.cr[6].eq {
	pc = 0x822EF3C0; continue 'dispatch;
	}
	// 822EF3BC: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822EF3C0; continue 'dispatch;
            }
            0x822EF3C0 => {
    //   block [0x822EF3C0..0x822EF420)
	// 822EF3C0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822EF3C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822EF3C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822EF3CC: 48245E05  bl 0x825351d0
	ctx.lr = 0x822EF3D0;
	sub_825351D0(ctx, base);
	// 822EF3D0: 397E0024  addi r11, r30, 0x24
	ctx.r[11].s64 = ctx.r[30].s64 + 36;
	// 822EF3D4: 815F01D8  lwz r10, 0x1d8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 822EF3D8: 93DF019C  stw r30, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[30].u32 ) };
	// 822EF3DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF3E0: 917F01A0  stw r11, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 822EF3E4: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 822EF3E8: 917F01C4  stw r11, 0x1c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[11].u32 ) };
	// 822EF3EC: 396B0800  addi r11, r11, 0x800
	ctx.r[11].s64 = ctx.r[11].s64 + 2048;
	// 822EF3F0: 392B0200  addi r9, r11, 0x200
	ctx.r[9].s64 = ctx.r[11].s64 + 512;
	// 822EF3F4: 917F01CC  stw r11, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 822EF3F8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822EF3FC: 419A007C  beq cr6, 0x822ef478
	if ctx.cr[6].eq {
	pc = 0x822EF478; continue 'dispatch;
	}
	// 822EF400: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822EF404: 419A004C  beq cr6, 0x822ef450
	if ctx.cr[6].eq {
	pc = 0x822EF450; continue 'dispatch;
	}
	// 822EF408: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 822EF40C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF410: 41980038  blt cr6, 0x822ef448
	if ctx.cr[6].lt {
	pc = 0x822EF448; continue 'dispatch;
	}
	// 822EF414: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822EF418: 39490008  addi r10, r9, 8
	ctx.r[10].s64 = ctx.r[9].s64 + 8;
	// 822EF41C: 38E7C508  addi r7, r7, -0x3af8
	ctx.r[7].s64 = ctx.r[7].s64 + -15096;
	pc = 0x822EF420; continue 'dispatch;
            }
            0x822EF420 => {
    //   block [0x822EF420..0x822EF448)
	// 822EF420: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 822EF424: 916AFFFC  stw r11, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 822EF428: 90EAFFF8  stw r7, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 822EF42C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822EF430: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF434: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822EF438: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822EF43C: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822EF440: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 822EF444: 4098FFDC  bge cr6, 0x822ef420
	if !ctx.cr[6].lt {
	pc = 0x822EF420; continue 'dispatch;
	}
	pc = 0x822EF448; continue 'dispatch;
            }
            0x822EF448 => {
    //   block [0x822EF448..0x822EF450)
	// 822EF448: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 822EF44C: 48000008  b 0x822ef454
	pc = 0x822EF454; continue 'dispatch;
            }
            0x822EF450 => {
    //   block [0x822EF450..0x822EF454)
	// 822EF450: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x822EF454; continue 'dispatch;
            }
            0x822EF454 => {
    //   block [0x822EF454..0x822EF478)
	// 822EF454: 815F01D8  lwz r10, 0x1d8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 822EF458: 911F01DC  stw r8, 0x1dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[8].u32 ) };
	// 822EF45C: 5547083C  slwi r7, r10, 1
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822EF460: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822EF464: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 822EF468: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EF46C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822EF470: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822EF474: 915F01E0  stw r10, 0x1e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[10].u32 ) };
	pc = 0x822EF478; continue 'dispatch;
            }
            0x822EF478 => {
    //   block [0x822EF478..0x822EF4A4)
	// 822EF478: 815F01E4  lwz r10, 0x1e4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 822EF47C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF480: 419A007C  beq cr6, 0x822ef4fc
	if ctx.cr[6].eq {
	pc = 0x822EF4FC; continue 'dispatch;
	}
	// 822EF484: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822EF488: 419A0054  beq cr6, 0x822ef4dc
	if ctx.cr[6].eq {
	pc = 0x822EF4DC; continue 'dispatch;
	}
	// 822EF48C: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 822EF490: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF494: 41980040  blt cr6, 0x822ef4d4
	if ctx.cr[6].lt {
	pc = 0x822EF4D4; continue 'dispatch;
	}
	// 822EF498: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822EF49C: 39490008  addi r10, r9, 8
	ctx.r[10].s64 = ctx.r[9].s64 + 8;
	// 822EF4A0: 38E7C520  addi r7, r7, -0x3ae0
	ctx.r[7].s64 = ctx.r[7].s64 + -15072;
	pc = 0x822EF4A4; continue 'dispatch;
            }
            0x822EF4A4 => {
    //   block [0x822EF4A4..0x822EF4D4)
	// 822EF4A4: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 822EF4A8: 916AFFFC  stw r11, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 822EF4AC: 90EAFFF8  stw r7, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 822EF4B0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822EF4B4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF4B8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822EF4BC: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822EF4C0: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822EF4C4: 934A0014  stw r26, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 822EF4C8: 934A0010  stw r26, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 822EF4CC: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 822EF4D0: 4098FFD4  bge cr6, 0x822ef4a4
	if !ctx.cr[6].lt {
	pc = 0x822EF4A4; continue 'dispatch;
	}
	pc = 0x822EF4D4; continue 'dispatch;
            }
            0x822EF4D4 => {
    //   block [0x822EF4D4..0x822EF4DC)
	// 822EF4D4: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 822EF4D8: 48000008  b 0x822ef4e0
	pc = 0x822EF4E0; continue 'dispatch;
            }
            0x822EF4DC => {
    //   block [0x822EF4DC..0x822EF4E0)
	// 822EF4DC: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x822EF4E0; continue 'dispatch;
            }
            0x822EF4E0 => {
    //   block [0x822EF4E0..0x822EF4FC)
	// 822EF4E0: 815F01E4  lwz r10, 0x1e4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 822EF4E4: 911F01E8  stw r8, 0x1e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), ctx.r[8].u32 ) };
	// 822EF4E8: 55472834  slwi r7, r10, 5
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822EF4EC: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822EF4F0: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 822EF4F4: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822EF4F8: 915F01EC  stw r10, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[10].u32 ) };
	pc = 0x822EF4FC; continue 'dispatch;
            }
            0x822EF4FC => {
    //   block [0x822EF4FC..0x822EF528)
	// 822EF4FC: 815F01F0  lwz r10, 0x1f0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(496 as u32) ) } as u64;
	// 822EF500: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF504: 419A007C  beq cr6, 0x822ef580
	if ctx.cr[6].eq {
	pc = 0x822EF580; continue 'dispatch;
	}
	// 822EF508: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822EF50C: 419A0054  beq cr6, 0x822ef560
	if ctx.cr[6].eq {
	pc = 0x822EF560; continue 'dispatch;
	}
	// 822EF510: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 822EF514: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF518: 41980040  blt cr6, 0x822ef558
	if ctx.cr[6].lt {
	pc = 0x822EF558; continue 'dispatch;
	}
	// 822EF51C: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822EF520: 39490008  addi r10, r9, 8
	ctx.r[10].s64 = ctx.r[9].s64 + 8;
	// 822EF524: 38E7C530  addi r7, r7, -0x3ad0
	ctx.r[7].s64 = ctx.r[7].s64 + -15056;
	pc = 0x822EF528; continue 'dispatch;
            }
            0x822EF528 => {
    //   block [0x822EF528..0x822EF558)
	// 822EF528: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 822EF52C: 916AFFFC  stw r11, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 822EF530: 90EAFFF8  stw r7, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 822EF534: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822EF538: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF53C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822EF540: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822EF544: 934A000C  stw r26, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 822EF548: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 822EF54C: 916A0014  stw r11, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 822EF550: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 822EF554: 4098FFD4  bge cr6, 0x822ef528
	if !ctx.cr[6].lt {
	pc = 0x822EF528; continue 'dispatch;
	}
	pc = 0x822EF558; continue 'dispatch;
            }
            0x822EF558 => {
    //   block [0x822EF558..0x822EF560)
	// 822EF558: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 822EF55C: 48000008  b 0x822ef564
	pc = 0x822EF564; continue 'dispatch;
            }
            0x822EF560 => {
    //   block [0x822EF560..0x822EF564)
	// 822EF560: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x822EF564; continue 'dispatch;
            }
            0x822EF564 => {
    //   block [0x822EF564..0x822EF580)
	// 822EF564: 815F01F0  lwz r10, 0x1f0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(496 as u32) ) } as u64;
	// 822EF568: 911F01F4  stw r8, 0x1f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), ctx.r[8].u32 ) };
	// 822EF56C: 55472834  slwi r7, r10, 5
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822EF570: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822EF574: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 822EF578: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822EF57C: 915F01F8  stw r10, 0x1f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[10].u32 ) };
	pc = 0x822EF580; continue 'dispatch;
            }
            0x822EF580 => {
    //   block [0x822EF580..0x822EF5AC)
	// 822EF580: 815F01FC  lwz r10, 0x1fc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 822EF584: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF588: 419A007C  beq cr6, 0x822ef604
	if ctx.cr[6].eq {
	pc = 0x822EF604; continue 'dispatch;
	}
	// 822EF58C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822EF590: 419A004C  beq cr6, 0x822ef5dc
	if ctx.cr[6].eq {
	pc = 0x822EF5DC; continue 'dispatch;
	}
	// 822EF594: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 822EF598: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF59C: 41980038  blt cr6, 0x822ef5d4
	if ctx.cr[6].lt {
	pc = 0x822EF5D4; continue 'dispatch;
	}
	// 822EF5A0: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822EF5A4: 39490008  addi r10, r9, 8
	ctx.r[10].s64 = ctx.r[9].s64 + 8;
	// 822EF5A8: 38E7C548  addi r7, r7, -0x3ab8
	ctx.r[7].s64 = ctx.r[7].s64 + -15032;
	pc = 0x822EF5AC; continue 'dispatch;
            }
            0x822EF5AC => {
    //   block [0x822EF5AC..0x822EF5D4)
	// 822EF5AC: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 822EF5B0: 916AFFFC  stw r11, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 822EF5B4: 90EAFFF8  stw r7, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 822EF5B8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822EF5BC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF5C0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822EF5C4: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822EF5C8: 934A000C  stw r26, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 822EF5CC: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 822EF5D0: 4098FFDC  bge cr6, 0x822ef5ac
	if !ctx.cr[6].lt {
	pc = 0x822EF5AC; continue 'dispatch;
	}
	pc = 0x822EF5D4; continue 'dispatch;
            }
            0x822EF5D4 => {
    //   block [0x822EF5D4..0x822EF5DC)
	// 822EF5D4: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 822EF5D8: 48000008  b 0x822ef5e0
	pc = 0x822EF5E0; continue 'dispatch;
            }
            0x822EF5DC => {
    //   block [0x822EF5DC..0x822EF5E0)
	// 822EF5DC: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x822EF5E0; continue 'dispatch;
            }
            0x822EF5E0 => {
    //   block [0x822EF5E0..0x822EF604)
	// 822EF5E0: 815F01FC  lwz r10, 0x1fc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 822EF5E4: 911F0200  stw r8, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[8].u32 ) };
	// 822EF5E8: 5547083C  slwi r7, r10, 1
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822EF5EC: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822EF5F0: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 822EF5F4: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EF5F8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822EF5FC: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822EF600: 915F0204  stw r10, 0x204(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), ctx.r[10].u32 ) };
	pc = 0x822EF604; continue 'dispatch;
            }
            0x822EF604 => {
    //   block [0x822EF604..0x822EF630)
	// 822EF604: 815F0208  lwz r10, 0x208(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 822EF608: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF60C: 419A0088  beq cr6, 0x822ef694
	if ctx.cr[6].eq {
	pc = 0x822EF694; continue 'dispatch;
	}
	// 822EF610: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822EF614: 419A0058  beq cr6, 0x822ef66c
	if ctx.cr[6].eq {
	pc = 0x822EF66C; continue 'dispatch;
	}
	// 822EF618: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 822EF61C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF620: 41980044  blt cr6, 0x822ef664
	if ctx.cr[6].lt {
	pc = 0x822EF664; continue 'dispatch;
	}
	// 822EF624: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822EF628: 39490008  addi r10, r9, 8
	ctx.r[10].s64 = ctx.r[9].s64 + 8;
	// 822EF62C: 38E7C560  addi r7, r7, -0x3aa0
	ctx.r[7].s64 = ctx.r[7].s64 + -15008;
	pc = 0x822EF630; continue 'dispatch;
            }
            0x822EF630 => {
    //   block [0x822EF630..0x822EF664)
	// 822EF630: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 822EF634: 916AFFFC  stw r11, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 822EF638: 90EAFFF8  stw r7, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 822EF63C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822EF640: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF644: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822EF648: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822EF64C: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 822EF650: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822EF654: 934A0018  stw r26, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 822EF658: 934A0014  stw r26, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 822EF65C: 394A0024  addi r10, r10, 0x24
	ctx.r[10].s64 = ctx.r[10].s64 + 36;
	// 822EF660: 4098FFD0  bge cr6, 0x822ef630
	if !ctx.cr[6].lt {
	pc = 0x822EF630; continue 'dispatch;
	}
	pc = 0x822EF664; continue 'dispatch;
            }
            0x822EF664 => {
    //   block [0x822EF664..0x822EF66C)
	// 822EF664: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 822EF668: 48000008  b 0x822ef670
	pc = 0x822EF670; continue 'dispatch;
            }
            0x822EF66C => {
    //   block [0x822EF66C..0x822EF670)
	// 822EF66C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x822EF670; continue 'dispatch;
            }
            0x822EF670 => {
    //   block [0x822EF670..0x822EF694)
	// 822EF670: 815F0208  lwz r10, 0x208(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 822EF674: 911F020C  stw r8, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[8].u32 ) };
	// 822EF678: 55471838  slwi r7, r10, 3
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822EF67C: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822EF680: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 822EF684: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EF688: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822EF68C: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822EF690: 915F0210  stw r10, 0x210(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[10].u32 ) };
	pc = 0x822EF694; continue 'dispatch;
            }
            0x822EF694 => {
    //   block [0x822EF694..0x822EF6C0)
	// 822EF694: 815F0214  lwz r10, 0x214(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 822EF698: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF69C: 419A0078  beq cr6, 0x822ef714
	if ctx.cr[6].eq {
	pc = 0x822EF714; continue 'dispatch;
	}
	// 822EF6A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822EF6A4: 419A0048  beq cr6, 0x822ef6ec
	if ctx.cr[6].eq {
	pc = 0x822EF6EC; continue 'dispatch;
	}
	// 822EF6A8: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 822EF6AC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF6B0: 41980034  blt cr6, 0x822ef6e4
	if ctx.cr[6].lt {
	pc = 0x822EF6E4; continue 'dispatch;
	}
	// 822EF6B4: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822EF6B8: 39490008  addi r10, r9, 8
	ctx.r[10].s64 = ctx.r[9].s64 + 8;
	// 822EF6BC: 38E7C570  addi r7, r7, -0x3a90
	ctx.r[7].s64 = ctx.r[7].s64 + -14992;
	pc = 0x822EF6C0; continue 'dispatch;
            }
            0x822EF6C0 => {
    //   block [0x822EF6C0..0x822EF6E4)
	// 822EF6C0: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 822EF6C4: 916AFFFC  stw r11, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 822EF6C8: 90EAFFF8  stw r7, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 822EF6CC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822EF6D0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF6D4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822EF6D8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822EF6DC: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 822EF6E0: 4098FFE0  bge cr6, 0x822ef6c0
	if !ctx.cr[6].lt {
	pc = 0x822EF6C0; continue 'dispatch;
	}
	pc = 0x822EF6E4; continue 'dispatch;
            }
            0x822EF6E4 => {
    //   block [0x822EF6E4..0x822EF6EC)
	// 822EF6E4: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 822EF6E8: 48000008  b 0x822ef6f0
	pc = 0x822EF6F0; continue 'dispatch;
            }
            0x822EF6EC => {
    //   block [0x822EF6EC..0x822EF6F0)
	// 822EF6EC: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x822EF6F0; continue 'dispatch;
            }
            0x822EF6F0 => {
    //   block [0x822EF6F0..0x822EF714)
	// 822EF6F0: 815F0214  lwz r10, 0x214(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 822EF6F4: 911F0218  stw r8, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[8].u32 ) };
	// 822EF6F8: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822EF6FC: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822EF700: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 822EF704: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EF708: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822EF70C: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822EF710: 915F021C  stw r10, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[10].u32 ) };
	pc = 0x822EF714; continue 'dispatch;
            }
            0x822EF714 => {
    //   block [0x822EF714..0x822EF740)
	// 822EF714: 815F0220  lwz r10, 0x220(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 822EF718: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF71C: 419A0078  beq cr6, 0x822ef794
	if ctx.cr[6].eq {
	pc = 0x822EF794; continue 'dispatch;
	}
	// 822EF720: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822EF724: 419A0048  beq cr6, 0x822ef76c
	if ctx.cr[6].eq {
	pc = 0x822EF76C; continue 'dispatch;
	}
	// 822EF728: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 822EF72C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF730: 41980034  blt cr6, 0x822ef764
	if ctx.cr[6].lt {
	pc = 0x822EF764; continue 'dispatch;
	}
	// 822EF734: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822EF738: 39490008  addi r10, r9, 8
	ctx.r[10].s64 = ctx.r[9].s64 + 8;
	// 822EF73C: 38E7C588  addi r7, r7, -0x3a78
	ctx.r[7].s64 = ctx.r[7].s64 + -14968;
	pc = 0x822EF740; continue 'dispatch;
            }
            0x822EF740 => {
    //   block [0x822EF740..0x822EF764)
	// 822EF740: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 822EF744: 916AFFFC  stw r11, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 822EF748: 90EAFFF8  stw r7, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 822EF74C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822EF750: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF754: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822EF758: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822EF75C: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 822EF760: 4098FFE0  bge cr6, 0x822ef740
	if !ctx.cr[6].lt {
	pc = 0x822EF740; continue 'dispatch;
	}
	pc = 0x822EF764; continue 'dispatch;
            }
            0x822EF764 => {
    //   block [0x822EF764..0x822EF76C)
	// 822EF764: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 822EF768: 48000008  b 0x822ef770
	pc = 0x822EF770; continue 'dispatch;
            }
            0x822EF76C => {
    //   block [0x822EF76C..0x822EF770)
	// 822EF76C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x822EF770; continue 'dispatch;
            }
            0x822EF770 => {
    //   block [0x822EF770..0x822EF794)
	// 822EF770: 815F0220  lwz r10, 0x220(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 822EF774: 911F0224  stw r8, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[8].u32 ) };
	// 822EF778: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822EF77C: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822EF780: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 822EF784: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EF788: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822EF78C: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822EF790: 915F0228  stw r10, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[10].u32 ) };
	pc = 0x822EF794; continue 'dispatch;
            }
            0x822EF794 => {
    //   block [0x822EF794..0x822EF7C0)
	// 822EF794: 815F022C  lwz r10, 0x22c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 822EF798: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF79C: 419A0078  beq cr6, 0x822ef814
	if ctx.cr[6].eq {
	pc = 0x822EF814; continue 'dispatch;
	}
	// 822EF7A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822EF7A4: 419A0048  beq cr6, 0x822ef7ec
	if ctx.cr[6].eq {
	pc = 0x822EF7EC; continue 'dispatch;
	}
	// 822EF7A8: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 822EF7AC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF7B0: 41980034  blt cr6, 0x822ef7e4
	if ctx.cr[6].lt {
	pc = 0x822EF7E4; continue 'dispatch;
	}
	// 822EF7B4: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822EF7B8: 39490008  addi r10, r9, 8
	ctx.r[10].s64 = ctx.r[9].s64 + 8;
	// 822EF7BC: 38E7C5A0  addi r7, r7, -0x3a60
	ctx.r[7].s64 = ctx.r[7].s64 + -14944;
	pc = 0x822EF7C0; continue 'dispatch;
            }
            0x822EF7C0 => {
    //   block [0x822EF7C0..0x822EF7E4)
	// 822EF7C0: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 822EF7C4: 916AFFFC  stw r11, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 822EF7C8: 90EAFFF8  stw r7, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 822EF7CC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822EF7D0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF7D4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822EF7D8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822EF7DC: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 822EF7E0: 4098FFE0  bge cr6, 0x822ef7c0
	if !ctx.cr[6].lt {
	pc = 0x822EF7C0; continue 'dispatch;
	}
	pc = 0x822EF7E4; continue 'dispatch;
            }
            0x822EF7E4 => {
    //   block [0x822EF7E4..0x822EF7EC)
	// 822EF7E4: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 822EF7E8: 48000008  b 0x822ef7f0
	pc = 0x822EF7F0; continue 'dispatch;
            }
            0x822EF7EC => {
    //   block [0x822EF7EC..0x822EF7F0)
	// 822EF7EC: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x822EF7F0; continue 'dispatch;
            }
            0x822EF7F0 => {
    //   block [0x822EF7F0..0x822EF814)
	// 822EF7F0: 815F022C  lwz r10, 0x22c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 822EF7F4: 911F0230  stw r8, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[8].u32 ) };
	// 822EF7F8: 5547083C  slwi r7, r10, 1
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822EF7FC: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822EF800: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 822EF804: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EF808: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822EF80C: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822EF810: 915F0234  stw r10, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[10].u32 ) };
	pc = 0x822EF814; continue 'dispatch;
            }
            0x822EF814 => {
    //   block [0x822EF814..0x822EF840)
	// 822EF814: 815F0238  lwz r10, 0x238(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 822EF818: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF81C: 419A0078  beq cr6, 0x822ef894
	if ctx.cr[6].eq {
	pc = 0x822EF894; continue 'dispatch;
	}
	// 822EF820: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822EF824: 419A0048  beq cr6, 0x822ef86c
	if ctx.cr[6].eq {
	pc = 0x822EF86C; continue 'dispatch;
	}
	// 822EF828: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 822EF82C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF830: 41980034  blt cr6, 0x822ef864
	if ctx.cr[6].lt {
	pc = 0x822EF864; continue 'dispatch;
	}
	// 822EF834: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822EF838: 39490008  addi r10, r9, 8
	ctx.r[10].s64 = ctx.r[9].s64 + 8;
	// 822EF83C: 38E7C5B8  addi r7, r7, -0x3a48
	ctx.r[7].s64 = ctx.r[7].s64 + -14920;
	pc = 0x822EF840; continue 'dispatch;
            }
            0x822EF840 => {
    //   block [0x822EF840..0x822EF864)
	// 822EF840: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 822EF844: 916AFFFC  stw r11, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 822EF848: 90EAFFF8  stw r7, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 822EF84C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822EF850: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF854: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822EF858: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822EF85C: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 822EF860: 4098FFE0  bge cr6, 0x822ef840
	if !ctx.cr[6].lt {
	pc = 0x822EF840; continue 'dispatch;
	}
	pc = 0x822EF864; continue 'dispatch;
            }
            0x822EF864 => {
    //   block [0x822EF864..0x822EF86C)
	// 822EF864: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 822EF868: 48000008  b 0x822ef870
	pc = 0x822EF870; continue 'dispatch;
            }
            0x822EF86C => {
    //   block [0x822EF86C..0x822EF870)
	// 822EF86C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x822EF870; continue 'dispatch;
            }
            0x822EF870 => {
    //   block [0x822EF870..0x822EF894)
	// 822EF870: 815F0238  lwz r10, 0x238(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 822EF874: 911F023C  stw r8, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[8].u32 ) };
	// 822EF878: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822EF87C: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822EF880: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 822EF884: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EF888: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822EF88C: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822EF890: 915F0240  stw r10, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[10].u32 ) };
	pc = 0x822EF894; continue 'dispatch;
            }
            0x822EF894 => {
    //   block [0x822EF894..0x822EF8C0)
	// 822EF894: 815F0244  lwz r10, 0x244(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 822EF898: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822EF89C: 419A0070  beq cr6, 0x822ef90c
	if ctx.cr[6].eq {
	pc = 0x822EF90C; continue 'dispatch;
	}
	// 822EF8A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822EF8A4: 419A0048  beq cr6, 0x822ef8ec
	if ctx.cr[6].eq {
	pc = 0x822EF8EC; continue 'dispatch;
	}
	// 822EF8A8: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 822EF8AC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF8B0: 41980034  blt cr6, 0x822ef8e4
	if ctx.cr[6].lt {
	pc = 0x822EF8E4; continue 'dispatch;
	}
	// 822EF8B4: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 822EF8B8: 39490008  addi r10, r9, 8
	ctx.r[10].s64 = ctx.r[9].s64 + 8;
	// 822EF8BC: 38E745DC  addi r7, r7, 0x45dc
	ctx.r[7].s64 = ctx.r[7].s64 + 17884;
	pc = 0x822EF8C0; continue 'dispatch;
            }
            0x822EF8C0 => {
    //   block [0x822EF8C0..0x822EF8E4)
	// 822EF8C0: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 822EF8C4: 916AFFFC  stw r11, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 822EF8C8: 90EAFFF8  stw r7, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 822EF8CC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822EF8D0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EF8D4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822EF8D8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822EF8DC: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 822EF8E0: 4098FFE0  bge cr6, 0x822ef8c0
	if !ctx.cr[6].lt {
	pc = 0x822EF8C0; continue 'dispatch;
	}
	pc = 0x822EF8E4; continue 'dispatch;
            }
            0x822EF8E4 => {
    //   block [0x822EF8E4..0x822EF8EC)
	// 822EF8E4: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 822EF8E8: 48000008  b 0x822ef8f0
	pc = 0x822EF8F0; continue 'dispatch;
            }
            0x822EF8EC => {
    //   block [0x822EF8EC..0x822EF8F0)
	// 822EF8EC: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x822EF8F0; continue 'dispatch;
            }
            0x822EF8F0 => {
    //   block [0x822EF8F0..0x822EF90C)
	// 822EF8F0: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 822EF8F4: 915F0248  stw r10, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[10].u32 ) };
	// 822EF8F8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822EF8FC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822EF900: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EF904: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822EF908: 917F024C  stw r11, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[11].u32 ) };
	pc = 0x822EF90C; continue 'dispatch;
            }
            0x822EF90C => {
    //   block [0x822EF90C..0x822EF914)
	// 822EF90C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822EF910: 482457E8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EF918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822EF918 size=1036
    let mut pc: u32 = 0x822EF918;
    'dispatch: loop {
        match pc {
            0x822EF918 => {
    //   block [0x822EF918..0x822EF990)
	// 822EF918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EF91C: 48245765  bl 0x82535080
	ctx.lr = 0x822EF920;
	sub_82535080(ctx, base);
	// 822EF920: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EF924: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822EF928: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EF92C: 3AEBC40C  addi r23, r11, -0x3bf4
	ctx.r[23].s64 = ctx.r[11].s64 + -15348;
	// 822EF930: 815A019C  lwz r10, 0x19c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EF934: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 822EF938: 80BA01E0  lwz r5, 0x1e0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 822EF93C: 82CA0020  lwz r22, 0x20(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822EF940: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EF944: 4809ED55  bl 0x8238e698
	ctx.lr = 0x822EF948;
	sub_8238E698(ctx, base);
	// 822EF948: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EF94C: 81FA01D8  lwz r15, 0x1d8(r26)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(472 as u32) ) } as u64;
	// 822EF950: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 822EF954: 3A2BC508  addi r17, r11, -0x3af8
	ctx.r[17].s64 = ctx.r[11].s64 + -15096;
	// 822EF958: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EF95C: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 822EF960: 39CBC488  addi r14, r11, -0x3b78
	ctx.r[14].s64 = ctx.r[11].s64 + -15224;
	// 822EF964: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EF968: 3B00FFFF  li r24, -1
	ctx.r[24].s64 = -1;
	// 822EF96C: 3B2BC47C  addi r25, r11, -0x3b84
	ctx.r[25].s64 = ctx.r[11].s64 + -15236;
	// 822EF970: 2F0F0000  cmpwi cr6, r15, 0
	ctx.cr[6].compare_i32(ctx.r[15].s32, 0, &mut ctx.xer);
	// 822EF974: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 822EF978: 40990188  ble cr6, 0x822efb00
	if !ctx.cr[6].gt {
	pc = 0x822EFB00; continue 'dispatch;
	}
	// 822EF97C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EF980: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	// 822EF984: 3BABC49C  addi r29, r11, -0x3b64
	ctx.r[29].s64 = ctx.r[11].s64 + -15204;
	// 822EF988: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EF98C: 3B8BC490  addi r28, r11, -0x3b70
	ctx.r[28].s64 = ctx.r[11].s64 + -15216;
	pc = 0x822EF990; continue 'dispatch;
            }
            0x822EF990 => {
    //   block [0x822EF990..0x822EFA54)
	// 822EF990: 817A01E0  lwz r11, 0x1e0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 822EF994: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
	// 822EF998: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 822EF99C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 822EF9A0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EF9A4: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EF9A8: 4809F121  bl 0x8238eac8
	ctx.lr = 0x822EF9AC;
	sub_8238EAC8(ctx, base);
	// 822EF9AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EF9B0: 419A00A4  beq cr6, 0x822efa54
	if ctx.cr[6].eq {
	pc = 0x822EFA54; continue 'dispatch;
	}
	// 822EF9B4: 817A01E0  lwz r11, 0x1e0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 822EF9B8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822EF9BC: 7DC67378  mr r6, r14
	ctx.r[6].u64 = ctx.r[14].u64;
	// 822EF9C0: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 822EF9C4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 822EF9C8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EF9CC: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EF9D0: 4809F0F9  bl 0x8238eac8
	ctx.lr = 0x822EF9D4;
	sub_8238EAC8(ctx, base);
	// 822EF9D4: 817A01E0  lwz r11, 0x1e0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 822EF9D8: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 822EF9DC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822EF9E0: 92A10054  stw r21, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[21].u32 ) };
	// 822EF9E4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 822EF9E8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EF9EC: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EF9F0: 4809F0D9  bl 0x8238eac8
	ctx.lr = 0x822EF9F4;
	sub_8238EAC8(ctx, base);
	// 822EF9F4: 817A01E0  lwz r11, 0x1e0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 822EF9F8: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822EF9FC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 822EFA00: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 822EFA04: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 822EFA08: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFA0C: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFA10: 4809F0B9  bl 0x8238eac8
	ctx.lr = 0x822EFA14;
	sub_8238EAC8(ctx, base);
	// 822EFA14: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822EFA18: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822EFA1C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822EFA20: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 822EFA24: 5569402E  slwi r9, r11, 8
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822EFA28: 807A01DC  lwz r3, 0x1dc(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(476 as u32) ) } as u64;
	// 822EFA2C: 92210090  stw r17, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[17].u32 ) };
	// 822EFA30: 7D265378  or r6, r9, r10
	ctx.r[6].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 822EFA34: 93C1009C  stw r30, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 822EFA38: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 822EFA3C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822EFA40: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 822EFA44: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 822EFA48: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822EFA4C: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 822EFA50: 48001439  bl 0x822f0e88
	ctx.lr = 0x822EFA54;
	sub_822F0E88(ctx, base);
	pc = 0x822EFA54; continue 'dispatch;
            }
            0x822EFA54 => {
    //   block [0x822EFA54..0x822EFA74)
	// 822EFA54: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822EFA58: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822EFA5C: 7F1E7800  cmpw cr6, r30, r15
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[15].s32, &mut ctx.xer);
	// 822EFA60: 4198FF30  blt cr6, 0x822ef990
	if ctx.cr[6].lt {
	pc = 0x822EF990; continue 'dispatch;
	}
	// 822EFA64: 2F0F0000  cmpwi cr6, r15, 0
	ctx.cr[6].compare_i32(ctx.r[15].s32, 0, &mut ctx.xer);
	// 822EFA68: 40990098  ble cr6, 0x822efb00
	if !ctx.cr[6].gt {
	pc = 0x822EFB00; continue 'dispatch;
	}
	// 822EFA6C: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 822EFA70: 7DFB7B78  mr r27, r15
	ctx.r[27].u64 = ctx.r[15].u64;
	pc = 0x822EFA74; continue 'dispatch;
            }
            0x822EFA74 => {
    //   block [0x822EFA74..0x822EFAC0)
	// 822EFA74: 817A01DC  lwz r11, 0x1dc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(476 as u32) ) } as u64;
	// 822EFA78: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 822EFA7C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EFA80: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822EFA84: 409A006C  bne cr6, 0x822efaf0
	if !ctx.cr[6].eq {
	pc = 0x822EFAF0; continue 'dispatch;
	}
	// 822EFA88: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822EFA8C: 815A01E0  lwz r10, 0x1e0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 822EFA90: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EFA94: 83FA0198  lwz r31, 0x198(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(408 as u32) ) } as u64;
	// 822EFA98: 7FCB502E  lwzx r30, r11, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822EFA9C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EFAA0: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EFAA4: 481A4F0D  bl 0x824949b0
	ctx.lr = 0x822EFAA8;
	sub_824949B0(ctx, base);
	// 822EFAA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822EFAAC: 419A0014  beq cr6, 0x822efac0
	if ctx.cr[6].eq {
	pc = 0x822EFAC0; continue 'dispatch;
	}
	// 822EFAB0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822EFAB4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EFAB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822EFABC: 481A39A5  bl 0x82493460
	ctx.lr = 0x822EFAC0;
	sub_82493460(ctx, base);
	pc = 0x822EFAC0; continue 'dispatch;
            }
            0x822EFAC0 => {
    //   block [0x822EFAC0..0x822EFAE0)
	// 822EFAC0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EFAC4: 481A371D  bl 0x824931e0
	ctx.lr = 0x822EFAC8;
	sub_824931E0(ctx, base);
	// 822EFAC8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EFACC: 815A01DC  lwz r10, 0x1dc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(476 as u32) ) } as u64;
	// 822EFAD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EFAD4: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 822EFAD8: 419A0008  beq cr6, 0x822efae0
	if ctx.cr[6].eq {
	pc = 0x822EFAE0; continue 'dispatch;
	}
	// 822EFADC: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x822EFAE0; continue 'dispatch;
            }
            0x822EFAE0 => {
    //   block [0x822EFAE0..0x822EFAF0)
	// 822EFAE0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822EFAE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EFAE8: 419A0008  beq cr6, 0x822efaf0
	if ctx.cr[6].eq {
	pc = 0x822EFAF0; continue 'dispatch;
	}
	// 822EFAEC: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x822EFAF0; continue 'dispatch;
            }
            0x822EFAF0 => {
    //   block [0x822EFAF0..0x822EFB00)
	// 822EFAF0: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 822EFAF4: 3B9C0018  addi r28, r28, 0x18
	ctx.r[28].s64 = ctx.r[28].s64 + 24;
	// 822EFAF8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822EFAFC: 409AFF78  bne cr6, 0x822efa74
	if !ctx.cr[6].eq {
	pc = 0x822EFA74; continue 'dispatch;
	}
	pc = 0x822EFB00; continue 'dispatch;
            }
            0x822EFB00 => {
    //   block [0x822EFB00..0x822EFB2C)
	// 822EFB00: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFB04: 80BA01EC  lwz r5, 0x1ec(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(492 as u32) ) } as u64;
	// 822EFB08: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 822EFB0C: 4809EE0D  bl 0x8238e918
	ctx.lr = 0x822EFB10;
	sub_8238E918(ctx, base);
	// 822EFB10: 821A01E4  lwz r16, 0x1e4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(484 as u32) ) } as u64;
	// 822EFB14: 7EB3AB78  mr r19, r21
	ctx.r[19].u64 = ctx.r[21].u64;
	// 822EFB18: 2F100000  cmpwi cr6, r16, 0
	ctx.cr[6].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 822EFB1C: 40990200  ble cr6, 0x822efd1c
	if !ctx.cr[6].gt {
	pc = 0x822EFD1C; continue 'dispatch;
	}
	// 822EFB20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EFB24: 7EB4AB78  mr r20, r21
	ctx.r[20].u64 = ctx.r[21].u64;
	// 822EFB28: 3A4BC520  addi r18, r11, -0x3ae0
	ctx.r[18].s64 = ctx.r[11].s64 + -15072;
	pc = 0x822EFB2C; continue 'dispatch;
            }
            0x822EFB2C => {
    //   block [0x822EFB2C..0x822EFBA0)
	// 822EFB2C: 817A01EC  lwz r11, 0x1ec(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(492 as u32) ) } as u64;
	// 822EFB30: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822EFB34: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 822EFB38: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 822EFB3C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFB40: 7C94582E  lwzx r4, r20, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFB44: 4809F045  bl 0x8238eb88
	ctx.lr = 0x822EFB48;
	sub_8238EB88(ctx, base);
	// 822EFB48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EFB4C: 419A01C0  beq cr6, 0x822efd0c
	if ctx.cr[6].eq {
	pc = 0x822EFD0C; continue 'dispatch;
	}
	// 822EFB50: 817A01EC  lwz r11, 0x1ec(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(492 as u32) ) } as u64;
	// 822EFB54: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
	// 822EFB58: 7DC67378  mr r6, r14
	ctx.r[6].u64 = ctx.r[14].u64;
	// 822EFB5C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 822EFB60: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFB64: 7C94582E  lwzx r4, r20, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFB68: 4809F021  bl 0x8238eb88
	ctx.lr = 0x822EFB6C;
	sub_8238EB88(ctx, base);
	// 822EFB6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EFB70: 419A019C  beq cr6, 0x822efd0c
	if ctx.cr[6].eq {
	pc = 0x822EFD0C; continue 'dispatch;
	}
	// 822EFB74: 817A01EC  lwz r11, 0x1ec(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(492 as u32) ) } as u64;
	// 822EFB78: 7EB9AB78  mr r25, r21
	ctx.r[25].u64 = ctx.r[21].u64;
	// 822EFB7C: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 822EFB80: 7D74582E  lwzx r11, r20, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFB84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EFB88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EFB8C: 419A0024  beq cr6, 0x822efbb0
	if ctx.cr[6].eq {
	pc = 0x822EFBB0; continue 'dispatch;
	}
	// 822EFB90: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822EFB94: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822EFB98: 419A0008  beq cr6, 0x822efba0
	if ctx.cr[6].eq {
	pc = 0x822EFBA0; continue 'dispatch;
	}
	// 822EFB9C: 83CA0070  lwz r30, 0x70(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(112 as u32) ) } as u64;
	pc = 0x822EFBA0; continue 'dispatch;
            }
            0x822EFBA0 => {
    //   block [0x822EFBA0..0x822EFBB0)
	// 822EFBA0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822EFBA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822EFBA8: 419A0008  beq cr6, 0x822efbb0
	if ctx.cr[6].eq {
	pc = 0x822EFBB0; continue 'dispatch;
	}
	// 822EFBAC: 832B0070  lwz r25, 0x70(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	pc = 0x822EFBB0; continue 'dispatch;
            }
            0x822EFBB0 => {
    //   block [0x822EFBB0..0x822EFBF8)
	// 822EFBB0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822EFBB4: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 822EFBB8: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822EFBBC: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 822EFBC0: 5569402E  slwi r9, r11, 8
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822EFBC4: 92410090  stw r18, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[18].u32 ) };
	// 822EFBC8: 9261009C  stw r19, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[19].u32 ) };
	// 822EFBCC: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	// 822EFBD0: 92A100AC  stw r21, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[21].u32 ) };
	// 822EFBD4: 7D3B5378  or r27, r9, r10
	ctx.r[27].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 822EFBD8: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 822EFBDC: 2F0F0000  cmpwi cr6, r15, 0
	ctx.cr[6].compare_i32(ctx.r[15].s32, 0, &mut ctx.xer);
	// 822EFBE0: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 822EFBE4: 93A100A4  stw r29, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[29].u32 ) };
	// 822EFBE8: 938100A0  stw r28, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[28].u32 ) };
	// 822EFBEC: 92A100A8  stw r21, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[21].u32 ) };
	// 822EFBF0: 40990104  ble cr6, 0x822efcf4
	if !ctx.cr[6].gt {
	pc = 0x822EFCF4; continue 'dispatch;
	}
	// 822EFBF4: 48000008  b 0x822efbfc
	pc = 0x822EFBFC; continue 'dispatch;
            }
            0x822EFBF8 => {
    //   block [0x822EFBF8..0x822EFBFC)
	// 822EFBF8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x822EFBFC; continue 'dispatch;
            }
            0x822EFBFC => {
    //   block [0x822EFBFC..0x822EFC4C)
	// 822EFBFC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822EFC00: 92210070  stw r17, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[17].u32 ) };
	// 822EFC04: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822EFC08: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 822EFC0C: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 822EFC10: 9301007C  stw r24, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[24].u32 ) };
	// 822EFC14: 93010080  stw r24, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[24].u32 ) };
	// 822EFC18: 93010084  stw r24, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[24].u32 ) };
	// 822EFC1C: 4BFFD64D  bl 0x822ed268
	ctx.lr = 0x822EFC20;
	sub_822ED268(ctx, base);
	// 822EFC20: 80E10078  lwz r7, 0x78(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 822EFC24: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822EFC28: 80C10074  lwz r6, 0x74(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822EFC2C: 419A0058  beq cr6, 0x822efc84
	if ctx.cr[6].eq {
	pc = 0x822EFC84; continue 'dispatch;
	}
	// 822EFC30: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822EFC34: 40980050  bge cr6, 0x822efc84
	if !ctx.cr[6].lt {
	pc = 0x822EFC84; continue 'dispatch;
	}
	// 822EFC38: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EFC3C: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 822EFC40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EFC44: 419A0008  beq cr6, 0x822efc4c
	if ctx.cr[6].eq {
	pc = 0x822EFC4C; continue 'dispatch;
	}
	// 822EFC48: 814B0070  lwz r10, 0x70(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	pc = 0x822EFC4C; continue 'dispatch;
            }
            0x822EFC4C => {
    //   block [0x822EFC4C..0x822EFC50)
	// 822EFC4C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822EFC50; continue 'dispatch;
            }
            0x822EFC50 => {
    //   block [0x822EFC50..0x822EFC74)
	// 822EFC50: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EFC54: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EFC58: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822EFC5C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822EFC60: 419A0014  beq cr6, 0x822efc74
	if ctx.cr[6].eq {
	pc = 0x822EFC74; continue 'dispatch;
	}
	// 822EFC64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822EFC68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822EFC6C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EFC70: 419AFFE0  beq cr6, 0x822efc50
	if ctx.cr[6].eq {
	pc = 0x822EFC50; continue 'dispatch;
	}
	pc = 0x822EFC74; continue 'dispatch;
            }
            0x822EFC74 => {
    //   block [0x822EFC74..0x822EFC84)
	// 822EFC74: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EFC78: 409A000C  bne cr6, 0x822efc84
	if !ctx.cr[6].eq {
	pc = 0x822EFC84; continue 'dispatch;
	}
	// 822EFC7C: 54CB402E  slwi r11, r6, 8
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EFC80: 7D7C3B78  or r28, r11, r7
	ctx.r[28].u64 = ctx.r[11].u64 | ctx.r[7].u64;
	pc = 0x822EFC84; continue 'dispatch;
            }
            0x822EFC84 => {
    //   block [0x822EFC84..0x822EFCA8)
	// 822EFC84: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822EFC88: 419A0058  beq cr6, 0x822efce0
	if ctx.cr[6].eq {
	pc = 0x822EFCE0; continue 'dispatch;
	}
	// 822EFC8C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822EFC90: 40980050  bge cr6, 0x822efce0
	if !ctx.cr[6].lt {
	pc = 0x822EFCE0; continue 'dispatch;
	}
	// 822EFC94: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822EFC98: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 822EFC9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822EFCA0: 419A0008  beq cr6, 0x822efca8
	if ctx.cr[6].eq {
	pc = 0x822EFCA8; continue 'dispatch;
	}
	// 822EFCA4: 814B0070  lwz r10, 0x70(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	pc = 0x822EFCA8; continue 'dispatch;
            }
            0x822EFCA8 => {
    //   block [0x822EFCA8..0x822EFCAC)
	// 822EFCA8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822EFCAC; continue 'dispatch;
            }
            0x822EFCAC => {
    //   block [0x822EFCAC..0x822EFCD0)
	// 822EFCAC: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EFCB0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822EFCB4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822EFCB8: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822EFCBC: 419A0014  beq cr6, 0x822efcd0
	if ctx.cr[6].eq {
	pc = 0x822EFCD0; continue 'dispatch;
	}
	// 822EFCC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822EFCC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822EFCC8: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EFCCC: 419AFFE0  beq cr6, 0x822efcac
	if ctx.cr[6].eq {
	pc = 0x822EFCAC; continue 'dispatch;
	}
	pc = 0x822EFCD0; continue 'dispatch;
            }
            0x822EFCD0 => {
    //   block [0x822EFCD0..0x822EFCE0)
	// 822EFCD0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822EFCD4: 409A000C  bne cr6, 0x822efce0
	if !ctx.cr[6].eq {
	pc = 0x822EFCE0; continue 'dispatch;
	}
	// 822EFCD8: 54CB402E  slwi r11, r6, 8
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822EFCDC: 7D7D3B78  or r29, r11, r7
	ctx.r[29].u64 = ctx.r[11].u64 | ctx.r[7].u64;
	pc = 0x822EFCE0; continue 'dispatch;
            }
            0x822EFCE0 => {
    //   block [0x822EFCE0..0x822EFCF4)
	// 822EFCE0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822EFCE4: 7F1F7800  cmpw cr6, r31, r15
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[15].s32, &mut ctx.xer);
	// 822EFCE8: 4198FF10  blt cr6, 0x822efbf8
	if ctx.cr[6].lt {
	pc = 0x822EFBF8; continue 'dispatch;
	}
	// 822EFCEC: 93A100A4  stw r29, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[29].u32 ) };
	// 822EFCF0: 938100A0  stw r28, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[28].u32 ) };
	pc = 0x822EFCF4; continue 'dispatch;
            }
            0x822EFCF4 => {
    //   block [0x822EFCF4..0x822EFD0C)
	// 822EFCF4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822EFCF8: 807A01E8  lwz r3, 0x1e8(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(488 as u32) ) } as u64;
	// 822EFCFC: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 822EFD00: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 822EFD04: 480012C5  bl 0x822f0fc8
	ctx.lr = 0x822EFD08;
	sub_822F0FC8(ctx, base);
	// 822EFD08: 83210060  lwz r25, 0x60(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	pc = 0x822EFD0C; continue 'dispatch;
            }
            0x822EFD0C => {
    //   block [0x822EFD0C..0x822EFD1C)
	// 822EFD0C: 3A730001  addi r19, r19, 1
	ctx.r[19].s64 = ctx.r[19].s64 + 1;
	// 822EFD10: 3A940004  addi r20, r20, 4
	ctx.r[20].s64 = ctx.r[20].s64 + 4;
	// 822EFD14: 7F138000  cmpw cr6, r19, r16
	ctx.cr[6].compare_i32(ctx.r[19].s32, ctx.r[16].s32, &mut ctx.xer);
	// 822EFD18: 4198FE14  blt cr6, 0x822efb2c
	if ctx.cr[6].lt {
	pc = 0x822EFB2C; continue 'dispatch;
	}
	pc = 0x822EFD1C; continue 'dispatch;
            }
            0x822EFD1C => {
    //   block [0x822EFD1C..0x822EFD24)
	// 822EFD1C: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822EFD20: 482453B0  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822EFD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822EFD28 size=1564
    let mut pc: u32 = 0x822EFD28;
    'dispatch: loop {
        match pc {
            0x822EFD28 => {
    //   block [0x822EFD28..0x822EFDBC)
	// 822EFD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822EFD2C: 48245355  bl 0x82535080
	ctx.lr = 0x822EFD30;
	sub_82535080(ctx, base);
	// 822EFD30: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 822EFD34: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 822EFD38: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822EFD3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822EFD40: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EFD44: 3A6BC414  addi r19, r11, -0x3bec
	ctx.r[19].s64 = ctx.r[11].s64 + -15340;
	// 822EFD48: 815E019C  lwz r10, 0x19c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(412 as u32) ) } as u64;
	// 822EFD4C: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 822EFD50: 80BE01F8  lwz r5, 0x1f8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(504 as u32) ) } as u64;
	// 822EFD54: 82CA0020  lwz r22, 0x20(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822EFD58: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFD5C: 4809E93D  bl 0x8238e698
	ctx.lr = 0x822EFD60;
	sub_8238E698(ctx, base);
	// 822EFD60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EFD64: 81FE01F0  lwz r15, 0x1f0(r30)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(496 as u32) ) } as u64;
	// 822EFD68: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 822EFD6C: 3A0BC530  addi r16, r11, -0x3ad0
	ctx.r[16].s64 = ctx.r[11].s64 + -15056;
	// 822EFD70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EFD74: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	// 822EFD78: 3B4BC4B0  addi r26, r11, -0x3b50
	ctx.r[26].s64 = ctx.r[11].s64 + -15184;
	// 822EFD7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EFD80: 3A80FFFF  li r20, -1
	ctx.r[20].s64 = -1;
	// 822EFD84: 3B2BC488  addi r25, r11, -0x3b78
	ctx.r[25].s64 = ctx.r[11].s64 + -15224;
	// 822EFD88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EFD8C: 2F0F0000  cmpwi cr6, r15, 0
	ctx.cr[6].compare_i32(ctx.r[15].s32, 0, &mut ctx.xer);
	// 822EFD90: 39CBC47C  addi r14, r11, -0x3b84
	ctx.r[14].s64 = ctx.r[11].s64 + -15236;
	// 822EFD94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EFD98: 932100B0  stw r25, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[25].u32 ) };
	// 822EFD9C: 3A4BC4A8  addi r18, r11, -0x3b58
	ctx.r[18].s64 = ctx.r[11].s64 + -15192;
	// 822EFDA0: 924100B4  stw r18, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[18].u32 ) };
	// 822EFDA4: 4099014C  ble cr6, 0x822efef0
	if !ctx.cr[6].gt {
	pc = 0x822EFEF0; continue 'dispatch;
	}
	// 822EFDA8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EFDAC: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	// 822EFDB0: 3B8BC4C0  addi r28, r11, -0x3b40
	ctx.r[28].s64 = ctx.r[11].s64 + -15168;
	// 822EFDB4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EFDB8: 3B6BC4B8  addi r27, r11, -0x3b48
	ctx.r[27].s64 = ctx.r[11].s64 + -15176;
	pc = 0x822EFDBC; continue 'dispatch;
            }
            0x822EFDBC => {
    //   block [0x822EFDBC..0x822EFEE0)
	// 822EFDBC: 817E01F8  lwz r11, 0x1f8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(504 as u32) ) } as u64;
	// 822EFDC0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 822EFDC4: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 822EFDC8: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 822EFDCC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFDD0: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFDD4: 4809ECF5  bl 0x8238eac8
	ctx.lr = 0x822EFDD8;
	sub_8238EAC8(ctx, base);
	// 822EFDD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EFDDC: 419A0104  beq cr6, 0x822efee0
	if ctx.cr[6].eq {
	pc = 0x822EFEE0; continue 'dispatch;
	}
	// 822EFDE0: 817E01F8  lwz r11, 0x1f8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(504 as u32) ) } as u64;
	// 822EFDE4: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
	// 822EFDE8: 7DC67378  mr r6, r14
	ctx.r[6].u64 = ctx.r[14].u64;
	// 822EFDEC: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 822EFDF0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFDF4: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFDF8: 4809ECD1  bl 0x8238eac8
	ctx.lr = 0x822EFDFC;
	sub_8238EAC8(ctx, base);
	// 822EFDFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EFE00: 419A00E0  beq cr6, 0x822efee0
	if ctx.cr[6].eq {
	pc = 0x822EFEE0; continue 'dispatch;
	}
	// 822EFE04: 817E01F8  lwz r11, 0x1f8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(504 as u32) ) } as u64;
	// 822EFE08: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822EFE0C: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 822EFE10: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 822EFE14: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFE18: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFE1C: 4809ECAD  bl 0x8238eac8
	ctx.lr = 0x822EFE20;
	sub_8238EAC8(ctx, base);
	// 822EFE20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EFE24: 419A00BC  beq cr6, 0x822efee0
	if ctx.cr[6].eq {
	pc = 0x822EFEE0; continue 'dispatch;
	}
	// 822EFE28: 817E01F8  lwz r11, 0x1f8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(504 as u32) ) } as u64;
	// 822EFE2C: 38E10094  addi r7, r1, 0x94
	ctx.r[7].s64 = ctx.r[1].s64 + 148;
	// 822EFE30: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 822EFE34: 92A10094  stw r21, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[21].u32 ) };
	// 822EFE38: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 822EFE3C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFE40: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFE44: 4809EC85  bl 0x8238eac8
	ctx.lr = 0x822EFE48;
	sub_8238EAC8(ctx, base);
	// 822EFE48: 817E01F8  lwz r11, 0x1f8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(504 as u32) ) } as u64;
	// 822EFE4C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 822EFE50: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822EFE54: 92810054  stw r20, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[20].u32 ) };
	// 822EFE58: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 822EFE5C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFE60: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFE64: 4809EC65  bl 0x8238eac8
	ctx.lr = 0x822EFE68;
	sub_8238EAC8(ctx, base);
	// 822EFE68: 817E01F8  lwz r11, 0x1f8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(504 as u32) ) } as u64;
	// 822EFE6C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822EFE70: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822EFE74: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 822EFE78: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 822EFE7C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFE80: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFE84: 4809EC45  bl 0x8238eac8
	ctx.lr = 0x822EFE88;
	sub_8238EAC8(ctx, base);
	// 822EFE88: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822EFE8C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822EFE90: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822EFE94: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822EFE98: 5569801E  slwi r9, r11, 0x10
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(16);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822EFE9C: 807E01F4  lwz r3, 0x1f4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) } as u64;
	// 822EFEA0: 92010070  stw r16, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[16].u32 ) };
	// 822EFEA4: 7D295378  or r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 822EFEA8: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 822EFEAC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 822EFEB0: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 822EFEB4: 5528402E  slwi r8, r9, 8
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822EFEB8: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822EFEBC: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 822EFEC0: 7D064B78  or r6, r8, r9
	ctx.r[6].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 822EFEC4: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 822EFEC8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822EFECC: 9121007C  stw r9, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 822EFED0: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 822EFED4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822EFED8: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 822EFEDC: 480010ED  bl 0x822f0fc8
	ctx.lr = 0x822EFEE0;
	sub_822F0FC8(ctx, base);
	pc = 0x822EFEE0; continue 'dispatch;
            }
            0x822EFEE0 => {
    //   block [0x822EFEE0..0x822EFEF0)
	// 822EFEE0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822EFEE4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822EFEE8: 7F1D7800  cmpw cr6, r29, r15
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[15].s32, &mut ctx.xer);
	// 822EFEEC: 4198FED0  blt cr6, 0x822efdbc
	if ctx.cr[6].lt {
	pc = 0x822EFDBC; continue 'dispatch;
	}
	pc = 0x822EFEF0; continue 'dispatch;
            }
            0x822EFEF0 => {
    //   block [0x822EFEF0..0x822F00B8)
	// 822EFEF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EFEF4: 80BE0204  lwz r5, 0x204(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(516 as u32) ) } as u64;
	// 822EFEF8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFEFC: 3BABC420  addi r29, r11, -0x3be0
	ctx.r[29].s64 = ctx.r[11].s64 + -15328;
	// 822EFF00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822EFF04: 4809E795  bl 0x8238e698
	ctx.lr = 0x822EFF08;
	sub_8238E698(ctx, base);
	// 822EFF08: 82FE01FC  lwz r23, 0x1fc(r30)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 822EFF0C: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 822EFF10: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 822EFF14: 409901B4  ble cr6, 0x822f00c8
	if !ctx.cr[6].gt {
	pc = 0x822F00C8; continue 'dispatch;
	}
	// 822EFF18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EFF1C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822EFF20: 3B6BC548  addi r27, r11, -0x3ab8
	ctx.r[27].s64 = ctx.r[11].s64 + -15032;
	// 822EFF24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EFF28: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822EFF2C: 3B2BC4D4  addi r25, r11, -0x3b2c
	ctx.r[25].s64 = ctx.r[11].s64 + -15148;
	// 822EFF30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822EFF34: C3C9BA38  lfs f30, -0x45c8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822EFF38: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	// 822EFF3C: 3B0BC4CC  addi r24, r11, -0x3b34
	ctx.r[24].s64 = ctx.r[11].s64 + -15156;
	// 822EFF40: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822EFF44: 817E0204  lwz r11, 0x204(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(516 as u32) ) } as u64;
	// 822EFF48: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
	// 822EFF4C: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 822EFF50: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822EFF54: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFF58: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFF5C: 4809EB6D  bl 0x8238eac8
	ctx.lr = 0x822EFF60;
	sub_8238EAC8(ctx, base);
	// 822EFF60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EFF64: 419A0154  beq cr6, 0x822f00b8
	if ctx.cr[6].eq {
	pc = 0x822F00B8; continue 'dispatch;
	}
	// 822EFF68: 817E0204  lwz r11, 0x204(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(516 as u32) ) } as u64;
	// 822EFF6C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 822EFF70: 7DC67378  mr r6, r14
	ctx.r[6].u64 = ctx.r[14].u64;
	// 822EFF74: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822EFF78: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFF7C: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFF80: 4809EB49  bl 0x8238eac8
	ctx.lr = 0x822EFF84;
	sub_8238EAC8(ctx, base);
	// 822EFF84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EFF88: 419A0130  beq cr6, 0x822f00b8
	if ctx.cr[6].eq {
	pc = 0x822F00B8; continue 'dispatch;
	}
	// 822EFF8C: 817E0204  lwz r11, 0x204(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(516 as u32) ) } as u64;
	// 822EFF90: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 822EFF94: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 822EFF98: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822EFF9C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFFA0: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFFA4: 4809EB25  bl 0x8238eac8
	ctx.lr = 0x822EFFA8;
	sub_8238EAC8(ctx, base);
	// 822EFFA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EFFAC: 419A010C  beq cr6, 0x822f00b8
	if ctx.cr[6].eq {
	pc = 0x822F00B8; continue 'dispatch;
	}
	// 822EFFB0: 817E0204  lwz r11, 0x204(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(516 as u32) ) } as u64;
	// 822EFFB4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822EFFB8: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 822EFFBC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822EFFC0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFFC4: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFFC8: 4809EC81  bl 0x8238ec48
	ctx.lr = 0x822EFFCC;
	sub_8238EC48(ctx, base);
	// 822EFFCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822EFFD0: 419A00E8  beq cr6, 0x822f00b8
	if ctx.cr[6].eq {
	pc = 0x822F00B8; continue 'dispatch;
	}
	// 822EFFD4: 817E0204  lwz r11, 0x204(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(516 as u32) ) } as u64;
	// 822EFFD8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822EFFDC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 822EFFE0: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 822EFFE4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822EFFE8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822EFFEC: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822EFFF0: 4809EAD9  bl 0x8238eac8
	ctx.lr = 0x822EFFF4;
	sub_8238EAC8(ctx, base);
	// 822EFFF4: 817E0204  lwz r11, 0x204(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(516 as u32) ) } as u64;
	// 822EFFF8: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 822EFFFC: 7D3F582E  lwzx r9, r31, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F0000: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 822F0004: 4809DC8D  bl 0x8238dc90
	ctx.lr = 0x822F0008;
	sub_8238DC90(ctx, base);
	// 822F0008: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 822F000C: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F0010: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 822F0014: D3C100AC  stfs f30, 0xac(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822F0018: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 822F001C: D3E100A0  stfs f31, 0xa0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 822F0020: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 822F0024: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	pc = 0x822F00B8; continue 'dispatch;
            }
            0x822F00B8 => {
    //   block [0x822F00B8..0x822F00C8)
	// 822F00B8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822F00BC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822F00C0: 7F1CB800  cmpw cr6, r28, r23
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[23].s32, &mut ctx.xer);
	// 822F00C4: 4198FE80  blt cr6, 0x822eff44
	if ctx.cr[6].lt {
	pc = 0x822EFF44; continue 'dispatch;
	}
	pc = 0x822F00C8; continue 'dispatch;
            }
            0x822F00C8 => {
    //   block [0x822F00C8..0x822F0344)
	// 822F00C8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822F00CC: 80BE0210  lwz r5, 0x210(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(528 as u32) ) } as u64;
	// 822F00D0: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 822F00D4: 4809E845  bl 0x8238e918
	ctx.lr = 0x822F00D8;
	sub_8238E918(ctx, base);
	// 822F00D8: 823E0208  lwz r17, 0x208(r30)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(520 as u32) ) } as u64;
	// 822F00DC: 7EB7AB78  mr r23, r21
	ctx.r[23].u64 = ctx.r[21].u64;
	// 822F00E0: 2F110000  cmpwi cr6, r17, 0
	ctx.cr[6].compare_i32(ctx.r[17].s32, 0, &mut ctx.xer);
	// 822F00E4: 40990250  ble cr6, 0x822f0334
	if !ctx.cr[6].gt {
	pc = 0x822F0334; continue 'dispatch;
	}
	// 822F00E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F00EC: 7EB8AB78  mr r24, r21
	ctx.r[24].u64 = ctx.r[21].u64;
	// 822F00F0: 3A4BC560  addi r18, r11, -0x3aa0
	ctx.r[18].s64 = ctx.r[11].s64 + -15008;
	// 822F00F4: 817E0210  lwz r11, 0x210(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(528 as u32) ) } as u64;
	// 822F00F8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822F00FC: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 822F0100: 80C100B4  lwz r6, 0xb4(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 822F0104: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822F0108: 7C98582E  lwzx r4, r24, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F010C: 4809EA7D  bl 0x8238eb88
	ctx.lr = 0x822F0110;
	sub_8238EB88(ctx, base);
	// 822F0110: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F0114: 419A0210  beq cr6, 0x822f0324
	if ctx.cr[6].eq {
	pc = 0x822F0324; continue 'dispatch;
	}
	// 822F0118: 817E0210  lwz r11, 0x210(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(528 as u32) ) } as u64;
	// 822F011C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 822F0120: 7DC67378  mr r6, r14
	ctx.r[6].u64 = ctx.r[14].u64;
	// 822F0124: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 822F0128: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822F012C: 7C98582E  lwzx r4, r24, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F0130: 4809EA59  bl 0x8238eb88
	ctx.lr = 0x822F0134;
	sub_8238EB88(ctx, base);
	// 822F0134: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F0138: 419A01EC  beq cr6, 0x822f0324
	if ctx.cr[6].eq {
	pc = 0x822F0324; continue 'dispatch;
	}
	// 822F013C: 817E0210  lwz r11, 0x210(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(528 as u32) ) } as u64;
	// 822F0140: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822F0144: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 822F0148: 80C100B0  lwz r6, 0xb0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 822F014C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822F0150: 7C98582E  lwzx r4, r24, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F0154: 4809EA35  bl 0x8238eb88
	ctx.lr = 0x822F0158;
	sub_8238EB88(ctx, base);
	// 822F0158: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F015C: 419A01C8  beq cr6, 0x822f0324
	if ctx.cr[6].eq {
	pc = 0x822F0324; continue 'dispatch;
	}
	// 822F0160: 817E0210  lwz r11, 0x210(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(528 as u32) ) } as u64;
	// 822F0164: 7EB9AB78  mr r25, r21
	ctx.r[25].u64 = ctx.r[21].u64;
	// 822F0168: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	// 822F016C: 7D78582E  lwzx r11, r24, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F0170: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F0174: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F0178: 419A0024  beq cr6, 0x822f019c
	if ctx.cr[6].eq {
	pc = 0x822F019C; continue 'dispatch;
	}
	// 822F017C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F0180: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F0184: 419A0008  beq cr6, 0x822f018c
	if ctx.cr[6].eq {
	pc = 0x822F018C; continue 'dispatch;
	}
	// 822F0188: 83AA0070  lwz r29, 0x70(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(112 as u32) ) } as u64;
	// 822F018C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F0190: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F0194: 419A0008  beq cr6, 0x822f019c
	if ctx.cr[6].eq {
	pc = 0x822F019C; continue 'dispatch;
	}
	// 822F0198: 832B0070  lwz r25, 0x70(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 822F019C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F01A0: 7E9CA378  mr r28, r20
	ctx.r[28].u64 = ctx.r[20].u64;
	// 822F01A4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F01A8: 7E9BA378  mr r27, r20
	ctx.r[27].u64 = ctx.r[20].u64;
	// 822F01AC: 5569801E  slwi r9, r11, 0x10
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(16);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822F01B0: 92410070  stw r18, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[18].u32 ) };
	// 822F01B4: 92E10080  stw r23, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[23].u32 ) };
	// 822F01B8: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	// 822F01BC: 7D295378  or r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 822F01C0: 92A10090  stw r21, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[21].u32 ) };
	// 822F01C4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 822F01C8: 2F0F0000  cmpwi cr6, r15, 0
	ctx.cr[6].compare_i32(ctx.r[15].s32, 0, &mut ctx.xer);
	// 822F01CC: 5528402E  slwi r8, r9, 8
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822F01D0: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822F01D4: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 822F01D8: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 822F01DC: 7D1A4B78  or r26, r8, r9
	ctx.r[26].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 822F01E0: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 822F01E4: 92A1008C  stw r21, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[21].u32 ) };
	// 822F01E8: 9121007C  stw r9, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 822F01EC: 40990124  ble cr6, 0x822f0310
	if !ctx.cr[6].gt {
	pc = 0x822F0310; continue 'dispatch;
	}
	// 822F01F0: 4800000C  b 0x822f01fc
	pc = 0x822F01FC; continue 'dispatch;
	// 822F01F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F01F8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F01FC: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 822F0200: 920100C0  stw r16, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[16].u32 ) };
	// 822F0204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F0208: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 822F020C: 914100C8  stw r10, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 822F0210: 93E100CC  stw r31, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[31].u32 ) };
	// 822F0214: 928100D0  stw r20, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[20].u32 ) };
	// 822F0218: 92A100D4  stw r21, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[21].u32 ) };
	// 822F021C: 928100D8  stw r20, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[20].u32 ) };
	// 822F0220: 928100DC  stw r20, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[20].u32 ) };
	// 822F0224: 4BFFD045  bl 0x822ed268
	ctx.lr = 0x822F0228;
	sub_822ED268(ctx, base);
	// 822F0228: 80E100CC  lwz r7, 0xcc(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 822F022C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822F0230: 80C100C8  lwz r6, 0xc8(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 822F0234: 80A100C4  lwz r5, 0xc4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 822F0238: 419A0060  beq cr6, 0x822f0298
	if ctx.cr[6].eq {
	pc = 0x822F0298; continue 'dispatch;
	}
	// 822F023C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 822F0240: 40980058  bge cr6, 0x822f0298
	if !ctx.cr[6].lt {
	pc = 0x822F0298; continue 'dispatch;
	}
	// 822F0244: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F0248: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 822F024C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F0250: 419A0008  beq cr6, 0x822f0258
	if ctx.cr[6].eq {
	pc = 0x822F0258; continue 'dispatch;
	}
	// 822F0254: 814B0070  lwz r10, 0x70(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 822F0258: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822F025C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F0260: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F0264: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822F0268: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822F026C: 419A0014  beq cr6, 0x822f0280
	if ctx.cr[6].eq {
	pc = 0x822F0280; continue 'dispatch;
	}
	// 822F0270: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822F0274: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F0278: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822F027C: 419AFFE0  beq cr6, 0x822f025c
	if ctx.cr[6].eq {
	pc = 0x822F025C; continue 'dispatch;
	}
	// 822F0280: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822F0284: 409A0014  bne cr6, 0x822f0298
	if !ctx.cr[6].eq {
	pc = 0x822F0298; continue 'dispatch;
	}
	// 822F0288: 54AB801E  slwi r11, r5, 0x10
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(16);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F028C: 7D6B3378  or r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[6].u64;
	// 822F0290: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F0294: 7D7B3B78  or r27, r11, r7
	ctx.r[27].u64 = ctx.r[11].u64 | ctx.r[7].u64;
	// 822F0298: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822F029C: 419A0060  beq cr6, 0x822f02fc
	if ctx.cr[6].eq {
	pc = 0x822F02FC; continue 'dispatch;
	}
	// 822F02A0: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822F02A4: 40980058  bge cr6, 0x822f02fc
	if !ctx.cr[6].lt {
	pc = 0x822F02FC; continue 'dispatch;
	}
	// 822F02A8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F02AC: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 822F02B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F02B4: 419A0008  beq cr6, 0x822f02bc
	if ctx.cr[6].eq {
	pc = 0x822F02BC; continue 'dispatch;
	}
	// 822F02B8: 814B0070  lwz r10, 0x70(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 822F02BC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822F02C0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F02C4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F02C8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822F02CC: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822F02D0: 419A0014  beq cr6, 0x822f02e4
	if ctx.cr[6].eq {
	pc = 0x822F02E4; continue 'dispatch;
	}
	// 822F02D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822F02D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F02DC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822F02E0: 419AFFE0  beq cr6, 0x822f02c0
	if ctx.cr[6].eq {
	pc = 0x822F02C0; continue 'dispatch;
	}
	// 822F02E4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822F02E8: 409A0014  bne cr6, 0x822f02fc
	if !ctx.cr[6].eq {
	pc = 0x822F02FC; continue 'dispatch;
	}
	// 822F02EC: 54AB801E  slwi r11, r5, 0x10
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(16);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F02F0: 7D6B3378  or r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[6].u64;
	// 822F02F4: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F02F8: 7D7C3B78  or r28, r11, r7
	ctx.r[28].u64 = ctx.r[11].u64 | ctx.r[7].u64;
	// 822F02FC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822F0300: 7F1F7800  cmpw cr6, r31, r15
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[15].s32, &mut ctx.xer);
	// 822F0304: 4198FEF0  blt cr6, 0x822f01f4
	if ctx.cr[6].lt {
	pc = 0x822F01F4; continue 'dispatch;
	}
	// 822F0308: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 822F030C: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 822F0310: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 822F0314: 807E020C  lwz r3, 0x20c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(524 as u32) ) } as u64;
	// 822F0318: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 822F031C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822F0320: 48000E01  bl 0x822f1120
	ctx.lr = 0x822F0324;
	sub_822F1120(ctx, base);
	// 822F0324: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 822F0328: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 822F032C: 7F178800  cmpw cr6, r23, r17
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[17].s32, &mut ctx.xer);
	// 822F0330: 4198FDC4  blt cr6, 0x822f00f4
	if ctx.cr[6].lt {
	pc = 0x822F00F4; continue 'dispatch;
	}
	// 822F0334: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 822F0338: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 822F033C: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 822F0340: 48244D90  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F0348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F0348 size=744
    let mut pc: u32 = 0x822F0348;
    'dispatch: loop {
        match pc {
            0x822F0348 => {
    //   block [0x822F0348..0x822F03B4)
	// 822F0348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F034C: 48244D51  bl 0x8253509c
	ctx.lr = 0x822F0350;
	sub_82535080(ctx, base);
	// 822F0350: DBC1FF90  stfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 822F0354: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 822F0358: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F035C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F0360: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F0364: 3B8BC430  addi r28, r11, -0x3bd0
	ctx.r[28].s64 = ctx.r[11].s64 + -15312;
	// 822F0368: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 822F036C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822F0370: 80BF021C  lwz r5, 0x21c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 822F0374: 83AA0020  lwz r29, 0x20(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F0378: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F037C: 4809E31D  bl 0x8238e698
	ctx.lr = 0x822F0380;
	sub_8238E698(ctx, base);
	// 822F0380: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F0384: 833F0214  lwz r25, 0x214(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 822F0388: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822F038C: 3ACBC47C  addi r22, r11, -0x3b84
	ctx.r[22].s64 = ctx.r[11].s64 + -15236;
	// 822F0390: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F0394: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 822F0398: 3AABC4DC  addi r21, r11, -0x3b24
	ctx.r[21].s64 = ctx.r[11].s64 + -15140;
	// 822F039C: 409900D4  ble cr6, 0x822f0470
	if !ctx.cr[6].gt {
	pc = 0x822F0470; continue 'dispatch;
	}
	// 822F03A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F03A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F03A8: 3B4BC570  addi r26, r11, -0x3a90
	ctx.r[26].s64 = ctx.r[11].s64 + -14992;
	// 822F03AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F03B0: 3B0BC488  addi r24, r11, -0x3b78
	ctx.r[24].s64 = ctx.r[11].s64 + -15224;
	pc = 0x822F03B4; continue 'dispatch;
            }
            0x822F03B4 => {
    //   block [0x822F03B4..0x822F0460)
	// 822F03B4: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 822F03B8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822F03BC: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 822F03C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F03C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F03C8: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 822F03CC: 4809E6FD  bl 0x8238eac8
	ctx.lr = 0x822F03D0;
	sub_8238EAC8(ctx, base);
	// 822F03D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F03D4: 419A008C  beq cr6, 0x822f0460
	if ctx.cr[6].eq {
	pc = 0x822F0460; continue 'dispatch;
	}
	// 822F03D8: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 822F03DC: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 822F03E0: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 822F03E4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F03E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F03EC: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 822F03F0: 4809E6D9  bl 0x8238eac8
	ctx.lr = 0x822F03F4;
	sub_8238EAC8(ctx, base);
	// 822F03F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F03F8: 419A0068  beq cr6, 0x822f0460
	if ctx.cr[6].eq {
	pc = 0x822F0460; continue 'dispatch;
	}
	// 822F03FC: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 822F0400: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822F0404: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 822F0408: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F040C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F0410: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 822F0414: 4809E6B5  bl 0x8238eac8
	ctx.lr = 0x822F0418;
	sub_8238EAC8(ctx, base);
	// 822F0418: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F041C: 419A0044  beq cr6, 0x822f0460
	if ctx.cr[6].eq {
	pc = 0x822F0460; continue 'dispatch;
	}
	// 822F0420: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F0424: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822F0428: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F042C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822F0430: 5569801E  slwi r9, r11, 0x10
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(16);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822F0434: 807F0218  lwz r3, 0x218(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) } as u64;
	// 822F0438: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 822F043C: 7D295378  or r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 822F0440: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 822F0444: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 822F0448: 5528402E  slwi r8, r9, 8
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822F044C: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822F0450: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 822F0454: 7D064B78  or r6, r8, r9
	ctx.r[6].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 822F0458: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 822F045C: 48000E4D  bl 0x822f12a8
	ctx.lr = 0x822F0460;
	sub_822F12A8(ctx, base);
	pc = 0x822F0460; continue 'dispatch;
            }
            0x822F0460 => {
    //   block [0x822F0460..0x822F0470)
	// 822F0460: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 822F0464: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F0468: 7F1BC800  cmpw cr6, r27, r25
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[25].s32, &mut ctx.xer);
	// 822F046C: 4198FF48  blt cr6, 0x822f03b4
	if ctx.cr[6].lt {
	pc = 0x822F03B4; continue 'dispatch;
	}
	pc = 0x822F0470; continue 'dispatch;
            }
            0x822F0470 => {
    //   block [0x822F0470..0x822F0610)
	// 822F0470: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F0474: 80BF0228  lwz r5, 0x228(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 822F0478: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F047C: 3B8BC43C  addi r28, r11, -0x3bc4
	ctx.r[28].s64 = ctx.r[11].s64 + -15300;
	// 822F0480: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822F0484: 4809E215  bl 0x8238e698
	ctx.lr = 0x822F0488;
	sub_8238E698(ctx, base);
	// 822F0488: 82FF0220  lwz r23, 0x220(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 822F048C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822F0490: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 822F0494: 4099018C  ble cr6, 0x822f0620
	if !ctx.cr[6].gt {
	pc = 0x822F0620; continue 'dispatch;
	}
	// 822F0498: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F049C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822F04A0: 3B4BC588  addi r26, r11, -0x3a78
	ctx.r[26].s64 = ctx.r[11].s64 + -14968;
	// 822F04A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F04A8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822F04AC: 3B2BC4D4  addi r25, r11, -0x3b2c
	ctx.r[25].s64 = ctx.r[11].s64 + -15148;
	// 822F04B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F04B4: C3C9BA38  lfs f30, -0x45c8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822F04B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F04BC: 3B0BC4CC  addi r24, r11, -0x3b34
	ctx.r[24].s64 = ctx.r[11].s64 + -15156;
	// 822F04C0: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822F04C4: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 822F04C8: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 822F04CC: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 822F04D0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F04D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F04D8: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F04DC: 4809E5ED  bl 0x8238eac8
	ctx.lr = 0x822F04E0;
	sub_8238EAC8(ctx, base);
	// 822F04E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F04E4: 419A012C  beq cr6, 0x822f0610
	if ctx.cr[6].eq {
	pc = 0x822F0610; continue 'dispatch;
	}
	// 822F04E8: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 822F04EC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822F04F0: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 822F04F4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F04F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F04FC: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F0500: 4809E5C9  bl 0x8238eac8
	ctx.lr = 0x822F0504;
	sub_8238EAC8(ctx, base);
	// 822F0504: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F0508: 419A0108  beq cr6, 0x822f0610
	if ctx.cr[6].eq {
	pc = 0x822F0610; continue 'dispatch;
	}
	// 822F050C: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 822F0510: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
	// 822F0514: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 822F0518: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F051C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F0520: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F0524: 4809E5A5  bl 0x8238eac8
	ctx.lr = 0x822F0528;
	sub_8238EAC8(ctx, base);
	// 822F0528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F052C: 419A00E4  beq cr6, 0x822f0610
	if ctx.cr[6].eq {
	pc = 0x822F0610; continue 'dispatch;
	}
	// 822F0530: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 822F0534: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822F0538: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 822F053C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F0540: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F0544: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F0548: 4809E701  bl 0x8238ec48
	ctx.lr = 0x822F054C;
	sub_8238EC48(ctx, base);
	// 822F054C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F0550: 419A00C0  beq cr6, 0x822f0610
	if ctx.cr[6].eq {
	pc = 0x822F0610; continue 'dispatch;
	}
	// 822F0554: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 822F0558: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 822F055C: 7D3E582E  lwzx r9, r30, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F0560: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 822F0564: 4809D72D  bl 0x8238dc90
	ctx.lr = 0x822F0568;
	sub_8238DC90(ctx, base);
	// 822F0568: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 822F056C: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F0570: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822F0574: D3C1006C  stfs f30, 0x6c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822F0578: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822F057C: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822F0580: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 822F0584: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	pc = 0x822F0610; continue 'dispatch;
            }
            0x822F0610 => {
    //   block [0x822F0610..0x822F0620)
	// 822F0610: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 822F0614: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F0618: 7F1BB800  cmpw cr6, r27, r23
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[23].s32, &mut ctx.xer);
	// 822F061C: 4198FEA8  blt cr6, 0x822f04c4
	if ctx.cr[6].lt {
	pc = 0x822F04C4; continue 'dispatch;
	}
	pc = 0x822F0620; continue 'dispatch;
            }
            0x822F0620 => {
    //   block [0x822F0620..0x822F0630)
	// 822F0620: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822F0624: CBC1FF90  lfd f30, -0x70(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 822F0628: CBE1FF98  lfd f31, -0x68(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 822F062C: 48244AC0  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F0630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F0630 size=796
    let mut pc: u32 = 0x822F0630;
    'dispatch: loop {
        match pc {
            0x822F0630 => {
    //   block [0x822F0630..0x822F06A8)
	// 822F0630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F0634: 48244A65  bl 0x82535098
	ctx.lr = 0x822F0638;
	sub_82535080(ctx, base);
	// 822F0638: DBC1FF88  stfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 822F063C: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 822F0640: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F0644: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F0648: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F064C: 3B8BC44C  addi r28, r11, -0x3bb4
	ctx.r[28].s64 = ctx.r[11].s64 + -15284;
	// 822F0650: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 822F0654: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822F0658: 80BF0234  lwz r5, 0x234(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 822F065C: 83CA0020  lwz r30, 0x20(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F0660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F0664: 4809E035  bl 0x8238e698
	ctx.lr = 0x822F0668;
	sub_8238E698(ctx, base);
	// 822F0668: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F066C: 82DF022C  lwz r22, 0x22c(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 822F0670: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822F0674: 3AABC47C  addi r21, r11, -0x3b84
	ctx.r[21].s64 = ctx.r[11].s64 + -15236;
	// 822F0678: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F067C: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 822F0680: 3A8BC4EC  addi r20, r11, -0x3b14
	ctx.r[20].s64 = ctx.r[11].s64 + -15124;
	// 822F0684: 40990108  ble cr6, 0x822f078c
	if !ctx.cr[6].gt {
	pc = 0x822F078C; continue 'dispatch;
	}
	// 822F0688: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F068C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822F0690: 3B4BC5A0  addi r26, r11, -0x3a60
	ctx.r[26].s64 = ctx.r[11].s64 + -14944;
	// 822F0694: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F0698: 3B00FFFF  li r24, -1
	ctx.r[24].s64 = -1;
	// 822F069C: 3B2BC490  addi r25, r11, -0x3b70
	ctx.r[25].s64 = ctx.r[11].s64 + -15216;
	// 822F06A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F06A4: 3AEBC488  addi r23, r11, -0x3b78
	ctx.r[23].s64 = ctx.r[11].s64 + -15224;
	pc = 0x822F06A8; continue 'dispatch;
            }
            0x822F06A8 => {
    //   block [0x822F06A8..0x822F077C)
	// 822F06A8: 817F0234  lwz r11, 0x234(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 822F06AC: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 822F06B0: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 822F06B4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F06B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F06BC: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 822F06C0: 4809E409  bl 0x8238eac8
	ctx.lr = 0x822F06C4;
	sub_8238EAC8(ctx, base);
	// 822F06C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F06C8: 419A00B4  beq cr6, 0x822f077c
	if ctx.cr[6].eq {
	pc = 0x822F077C; continue 'dispatch;
	}
	// 822F06CC: 817F0234  lwz r11, 0x234(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 822F06D0: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822F06D4: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 822F06D8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F06DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F06E0: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 822F06E4: 4809E3E5  bl 0x8238eac8
	ctx.lr = 0x822F06E8;
	sub_8238EAC8(ctx, base);
	// 822F06E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F06EC: 419A0090  beq cr6, 0x822f077c
	if ctx.cr[6].eq {
	pc = 0x822F077C; continue 'dispatch;
	}
	// 822F06F0: 817F0234  lwz r11, 0x234(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 822F06F4: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
	// 822F06F8: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 822F06FC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F0700: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F0704: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 822F0708: 4809E3C1  bl 0x8238eac8
	ctx.lr = 0x822F070C;
	sub_8238EAC8(ctx, base);
	// 822F070C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F0710: 419A006C  beq cr6, 0x822f077c
	if ctx.cr[6].eq {
	pc = 0x822F077C; continue 'dispatch;
	}
	// 822F0714: 817F0234  lwz r11, 0x234(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 822F0718: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822F071C: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 822F0720: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 822F0724: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F0728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F072C: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 822F0730: 4809E399  bl 0x8238eac8
	ctx.lr = 0x822F0734;
	sub_8238EAC8(ctx, base);
	// 822F0734: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F0738: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822F073C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822F0740: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822F0744: 5569801E  slwi r9, r11, 0x10
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(16);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822F0748: 807F0230  lwz r3, 0x230(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 822F074C: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 822F0750: 7D295378  or r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 822F0754: 93610080  stw r27, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 822F0758: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 822F075C: 5528402E  slwi r8, r9, 8
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822F0760: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822F0764: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F0768: 7D064B78  or r6, r8, r9
	ctx.r[6].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 822F076C: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 822F0770: 9121007C  stw r9, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 822F0774: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 822F0778: 48000711  bl 0x822f0e88
	ctx.lr = 0x822F077C;
	sub_822F0E88(ctx, base);
	pc = 0x822F077C; continue 'dispatch;
            }
            0x822F077C => {
    //   block [0x822F077C..0x822F078C)
	// 822F077C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 822F0780: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822F0784: 7F1BB000  cmpw cr6, r27, r22
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[22].s32, &mut ctx.xer);
	// 822F0788: 4198FF20  blt cr6, 0x822f06a8
	if ctx.cr[6].lt {
	pc = 0x822F06A8; continue 'dispatch;
	}
	pc = 0x822F078C; continue 'dispatch;
            }
            0x822F078C => {
    //   block [0x822F078C..0x822F092C)
	// 822F078C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F0790: 80BF0240  lwz r5, 0x240(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 822F0794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F0798: 3B8BC454  addi r28, r11, -0x3bac
	ctx.r[28].s64 = ctx.r[11].s64 + -15276;
	// 822F079C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822F07A0: 4809DEF9  bl 0x8238e698
	ctx.lr = 0x822F07A4;
	sub_8238E698(ctx, base);
	// 822F07A4: 82FF0238  lwz r23, 0x238(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 822F07A8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822F07AC: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 822F07B0: 4099018C  ble cr6, 0x822f093c
	if !ctx.cr[6].gt {
	pc = 0x822F093C; continue 'dispatch;
	}
	// 822F07B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F07B8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822F07BC: 3B4BC5B8  addi r26, r11, -0x3a48
	ctx.r[26].s64 = ctx.r[11].s64 + -14920;
	// 822F07C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F07C4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822F07C8: 3B2BC4D4  addi r25, r11, -0x3b2c
	ctx.r[25].s64 = ctx.r[11].s64 + -15148;
	// 822F07CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F07D0: C3C9BA38  lfs f30, -0x45c8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822F07D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822F07D8: 3B0BC4CC  addi r24, r11, -0x3b34
	ctx.r[24].s64 = ctx.r[11].s64 + -15156;
	// 822F07DC: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822F07E0: 817F0240  lwz r11, 0x240(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 822F07E4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822F07E8: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 822F07EC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F07F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F07F4: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F07F8: 4809E2D1  bl 0x8238eac8
	ctx.lr = 0x822F07FC;
	sub_8238EAC8(ctx, base);
	// 822F07FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F0800: 419A012C  beq cr6, 0x822f092c
	if ctx.cr[6].eq {
	pc = 0x822F092C; continue 'dispatch;
	}
	// 822F0804: 817F0240  lwz r11, 0x240(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 822F0808: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 822F080C: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 822F0810: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F0814: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F0818: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F081C: 4809E2AD  bl 0x8238eac8
	ctx.lr = 0x822F0820;
	sub_8238EAC8(ctx, base);
	// 822F0820: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F0824: 419A0108  beq cr6, 0x822f092c
	if ctx.cr[6].eq {
	pc = 0x822F092C; continue 'dispatch;
	}
	// 822F0828: 817F0240  lwz r11, 0x240(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 822F082C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822F0830: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 822F0834: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F0838: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F083C: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F0840: 4809E289  bl 0x8238eac8
	ctx.lr = 0x822F0844;
	sub_8238EAC8(ctx, base);
	// 822F0844: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F0848: 419A00E4  beq cr6, 0x822f092c
	if ctx.cr[6].eq {
	pc = 0x822F092C; continue 'dispatch;
	}
	// 822F084C: 817F0240  lwz r11, 0x240(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 822F0850: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
	// 822F0854: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 822F0858: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F085C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F0860: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F0864: 4809E3E5  bl 0x8238ec48
	ctx.lr = 0x822F0868;
	sub_8238EC48(ctx, base);
	// 822F0868: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F086C: 419A00C0  beq cr6, 0x822f092c
	if ctx.cr[6].eq {
	pc = 0x822F092C; continue 'dispatch;
	}
	// 822F0870: 817F0240  lwz r11, 0x240(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 822F0874: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 822F0878: 7D3D582E  lwzx r9, r29, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F087C: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 822F0880: 4809D411  bl 0x8238dc90
	ctx.lr = 0x822F0884;
	sub_8238DC90(ctx, base);
	// 822F0884: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 822F0888: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F088C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822F0890: D3C1006C  stfs f30, 0x6c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822F0894: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822F0898: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822F089C: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 822F08A0: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	pc = 0x822F092C; continue 'dispatch;
            }
            0x822F092C => {
    //   block [0x822F092C..0x822F093C)
	// 822F092C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 822F0930: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822F0934: 7F1BB800  cmpw cr6, r27, r23
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[23].s32, &mut ctx.xer);
	// 822F0938: 4198FEA8  blt cr6, 0x822f07e0
	if ctx.cr[6].lt {
	pc = 0x822F07E0; continue 'dispatch;
	}
	pc = 0x822F093C; continue 'dispatch;
            }
            0x822F093C => {
    //   block [0x822F093C..0x822F094C)
	// 822F093C: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822F0940: CBC1FF88  lfd f30, -0x78(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 822F0944: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 822F0948: 482447A0  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F0950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F0950 size=380
    let mut pc: u32 = 0x822F0950;
    'dispatch: loop {
        match pc {
            0x822F0950 => {
    //   block [0x822F0950..0x822F0998)
	// 822F0950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F0954: 48244731  bl 0x82535084
	ctx.lr = 0x822F0958;
	sub_82535080(ctx, base);
	// 822F0958: 9421FCF0  stwu r1, -0x310(r1)
	ea = ctx.r[1].u32.wrapping_add(-784 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F095C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822F0960: 39E00000  li r15, 0
	ctx.r[15].s64 = 0;
	// 822F0964: 3AEB45DC  addi r23, r11, 0x45dc
	ctx.r[23].s64 = ctx.r[11].s64 + 17884;
	// 822F0968: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F096C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822F0970: 3ACBC49C  addi r22, r11, -0x3b64
	ctx.r[22].s64 = ctx.r[11].s64 + -15204;
	// 822F0974: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F0978: 7DF17B78  mr r17, r15
	ctx.r[17].u64 = ctx.r[15].u64;
	// 822F097C: 3A4BC47C  addi r18, r11, -0x3b84
	ctx.r[18].s64 = ctx.r[11].s64 + -15236;
	// 822F0980: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F0984: 7DF07B78  mr r16, r15
	ctx.r[16].u64 = ctx.r[15].u64;
	// 822F0988: 3A6BC4FC  addi r19, r11, -0x3b04
	ctx.r[19].s64 = ctx.r[11].s64 + -15108;
	// 822F098C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F0990: 3AA0FFFF  li r21, -1
	ctx.r[21].s64 = -1;
	// 822F0994: 3B8BC460  addi r28, r11, -0x3ba0
	ctx.r[28].s64 = ctx.r[11].s64 + -15264;
	pc = 0x822F0998; continue 'dispatch;
            }
            0x822F0998 => {
    //   block [0x822F0998..0x822F09F4)
	// 822F0998: 817A019C  lwz r11, 0x19c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(412 as u32) ) } as u64;
	// 822F099C: 7FB0582E  lwzx r29, r16, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[16].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F09A0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822F09A4: 419A0114  beq cr6, 0x822f0ab8
	if ctx.cr[6].eq {
	pc = 0x822F0AB8; continue 'dispatch;
	}
	// 822F09A8: 38A001FC  li r5, 0x1fc
	ctx.r[5].s64 = 508;
	// 822F09AC: 91E10080  stw r15, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[15].u32 ) };
	// 822F09B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822F09B4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 822F09B8: 48244819  bl 0x825351d0
	ctx.lr = 0x822F09BC;
	sub_825351D0(ctx, base);
	// 822F09BC: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 822F09C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822F09C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F09C8: 4809DCD1  bl 0x8238e698
	ctx.lr = 0x822F09CC;
	sub_8238E698(ctx, base);
	// 822F09CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F09D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822F09D4: 4809DBE5  bl 0x8238e5b8
	ctx.lr = 0x822F09D8;
	sub_8238E5B8(ctx, base);
	// 822F09D8: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 822F09DC: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 822F09E0: 409900D4  ble cr6, 0x822f0ab4
	if !ctx.cr[6].gt {
	pc = 0x822F0AB4; continue 'dispatch;
	}
	// 822F09E4: 7E3E8B78  mr r30, r17
	ctx.r[30].u64 = ctx.r[17].u64;
	// 822F09E8: 563B103A  slwi r27, r17, 2
	ctx.r[27].u32 = ctx.r[17].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 822F09EC: 3B210080  addi r25, r1, 0x80
	ctx.r[25].s64 = ctx.r[1].s64 + 128;
	// 822F09F0: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	pc = 0x822F09F4; continue 'dispatch;
            }
            0x822F09F4 => {
    //   block [0x822F09F4..0x822F0A9C)
	// 822F09F4: 83F90000  lwz r31, 0(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F09F8: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822F09FC: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 822F0A00: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F0A04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F0A08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F0A0C: 4809E0BD  bl 0x8238eac8
	ctx.lr = 0x822F0A10;
	sub_8238EAC8(ctx, base);
	// 822F0A10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F0A14: 419A0088  beq cr6, 0x822f0a9c
	if ctx.cr[6].eq {
	pc = 0x822F0A9C; continue 'dispatch;
	}
	// 822F0A18: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 822F0A1C: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 822F0A20: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F0A24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F0A28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F0A2C: 4809E09D  bl 0x8238eac8
	ctx.lr = 0x822F0A30;
	sub_8238EAC8(ctx, base);
	// 822F0A30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F0A34: 419A0068  beq cr6, 0x822f0a9c
	if ctx.cr[6].eq {
	pc = 0x822F0A9C; continue 'dispatch;
	}
	// 822F0A38: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822F0A3C: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 822F0A40: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 822F0A44: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F0A48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F0A4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F0A50: 4809E079  bl 0x8238eac8
	ctx.lr = 0x822F0A54;
	sub_8238EAC8(ctx, base);
	// 822F0A54: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822F0A58: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F0A5C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822F0A60: 55696026  slwi r9, r11, 0xc
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(12);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822F0A64: 807A0248  lwz r3, 0x248(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(584 as u32) ) } as u64;
	// 822F0A68: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822F0A6C: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 822F0A70: 7D295378  or r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 822F0A74: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 822F0A78: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 822F0A7C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F0A80: 5526402E  slwi r6, r9, 8
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(8);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 822F0A84: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 822F0A88: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F0A8C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822F0A90: 48000819  bl 0x822f12a8
	ctx.lr = 0x822F0A94;
	sub_822F12A8(ctx, base);
	// 822F0A94: 817A024C  lwz r11, 0x24c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(588 as u32) ) } as u64;
	// 822F0A98: 7FEBD92E  stwx r31, r11, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[31].u32) };
	pc = 0x822F0A9C; continue 'dispatch;
            }
            0x822F0A9C => {
    //   block [0x822F0A9C..0x822F0AB4)
	// 822F0A9C: 3B18FFFF  addi r24, r24, -1
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	// 822F0AA0: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 822F0AA4: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 822F0AA8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822F0AAC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 822F0AB0: 409AFF44  bne cr6, 0x822f09f4
	if !ctx.cr[6].eq {
	pc = 0x822F09F4; continue 'dispatch;
	}
	pc = 0x822F0AB4; continue 'dispatch;
            }
            0x822F0AB4 => {
    //   block [0x822F0AB4..0x822F0AB8)
	// 822F0AB4: 7E348A14  add r17, r20, r17
	ctx.r[17].u64 = ctx.r[20].u64 + ctx.r[17].u64;
	pc = 0x822F0AB8; continue 'dispatch;
            }
            0x822F0AB8 => {
    //   block [0x822F0AB8..0x822F0ACC)
	// 822F0AB8: 3A100004  addi r16, r16, 4
	ctx.r[16].s64 = ctx.r[16].s64 + 4;
	// 822F0ABC: 2B100020  cmplwi cr6, r16, 0x20
	ctx.cr[6].compare_u32(ctx.r[16].u32, 32 as u32, &mut ctx.xer);
	// 822F0AC0: 4198FED8  blt cr6, 0x822f0998
	if ctx.cr[6].lt {
	pc = 0x822F0998; continue 'dispatch;
	}
	// 822F0AC4: 38210310  addi r1, r1, 0x310
	ctx.r[1].s64 = ctx.r[1].s64 + 784;
	// 822F0AC8: 4824460C  b 0x825350d4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F0AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F0AD0 size=468
    let mut pc: u32 = 0x822F0AD0;
    'dispatch: loop {
        match pc {
            0x822F0AD0 => {
    //   block [0x822F0AD0..0x822F0AF4)
	// 822F0AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F0AD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F0AD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F0ADC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F0AE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F0AE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F0AE8: 2B1E0010  cmplwi cr6, r30, 0x10
	ctx.cr[6].compare_u32(ctx.r[30].u32, 16 as u32, &mut ctx.xer);
	// 822F0AEC: 40980008  bge cr6, 0x822f0af4
	if !ctx.cr[6].lt {
	pc = 0x822F0AF4; continue 'dispatch;
	}
	// 822F0AF0: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	pc = 0x822F0AF4; continue 'dispatch;
            }
            0x822F0AF4 => {
    //   block [0x822F0AF4..0x822F0B5C)
	// 822F0AF4: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 822F0AF8: 395EFFFF  addi r10, r30, -1
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	// 822F0AFC: 83EB3BD4  lwz r31, 0x3bd4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15316 as u32) ) } as u64;
	// 822F0B00: 7D43FC30  srw r3, r10, r31
	if (ctx.r[31].u8 & 0x20) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = ((ctx.r[10].u32) >> ((ctx.r[31].u8 & 0x1F) as u32)) as u64;
	}
	// 822F0B04: 48000275  bl 0x822f0d78
	ctx.lr = 0x822F0B08;
	sub_822F0D78(ctx, base);
	// 822F0B08: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 822F0B0C: 419A0050  beq cr6, 0x822f0b5c
	if ctx.cr[6].eq {
	pc = 0x822F0B5C; continue 'dispatch;
	}
	// 822F0B10: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 822F0B14: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822F0B18: 814B3BC8  lwz r10, 0x3bc8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15304 as u32) ) } as u64;
	// 822F0B1C: 7D69502E  lwzx r11, r9, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F0B20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F0B24: 419A0038  beq cr6, 0x822f0b5c
	if ctx.cr[6].eq {
	pc = 0x822F0B5C; continue 'dispatch;
	}
	// 822F0B28: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F0B2C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822F0B30: 7CE9512E  stwx r7, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 822F0B34: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F0B38: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 822F0B3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F0B40: 7D085030  slw r8, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 822F0B44: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 822F0B48: 812A3BC4  lwz r9, 0x3bc4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15300 as u32) ) } as u64;
	// 822F0B4C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822F0B50: 3929FFF0  addi r9, r9, -0x10
	ctx.r[9].s64 = ctx.r[9].s64 + -16;
	// 822F0B54: 912A3BC4  stw r9, 0x3bc4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15300 as u32), ctx.r[9].u32 ) };
	// 822F0B58: 48000108  b 0x822f0c60
	pc = 0x822F0C60; continue 'dispatch;
            }
            0x822F0B5C => {
    //   block [0x822F0B5C..0x822F0B78)
	// 822F0B5C: 3CE08311  lis r7, -0x7cef
	ctx.r[7].s64 = -2096037888;
	// 822F0B60: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 822F0B64: 81673BC0  lwz r11, 0x3bc0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(15296 as u32) ) } as u64;
	// 822F0B68: 409A0010  bne cr6, 0x822f0b78
	if !ctx.cr[6].eq {
	pc = 0x822F0B78; continue 'dispatch;
	}
	// 822F0B6C: 395E000F  addi r10, r30, 0xf
	ctx.r[10].s64 = ctx.r[30].s64 + 15;
	// 822F0B70: 554A0036  rlwinm r10, r10, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822F0B74: 48000014  b 0x822f0b88
	pc = 0x822F0B88; continue 'dispatch;
            }
            0x822F0B78 => {
    //   block [0x822F0B78..0x822F0B88)
	// 822F0B78: 7D5F1A14  add r10, r31, r3
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[3].u64;
	// 822F0B7C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822F0B80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F0B84: 7D2A5030  slw r10, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	pc = 0x822F0B88; continue 'dispatch;
            }
            0x822F0B88 => {
    //   block [0x822F0B88..0x822F0BB0)
	// 822F0B88: 3D008311  lis r8, -0x7cef
	ctx.r[8].s64 = -2096037888;
	// 822F0B8C: 392A0010  addi r9, r10, 0x10
	ctx.r[9].s64 = ctx.r[10].s64 + 16;
	// 822F0B90: 81483BB4  lwz r10, 0x3bb4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(15284 as u32) ) } as u64;
	// 822F0B94: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822F0B98: 409900A4  ble cr6, 0x822f0c3c
	if !ctx.cr[6].gt {
	pc = 0x822F0C3C; continue 'dispatch;
	}
	// 822F0B9C: 3CE08311  lis r7, -0x7cef
	ctx.r[7].s64 = -2096037888;
	// 822F0BA0: 81073BBC  lwz r8, 0x3bbc(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(15292 as u32) ) } as u64;
	// 822F0BA4: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 822F0BA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F0BAC: 419A0034  beq cr6, 0x822f0be0
	if ctx.cr[6].eq {
	pc = 0x822F0BE0; continue 'dispatch;
	}
	pc = 0x822F0BB0; continue 'dispatch;
            }
            0x822F0BB0 => {
    //   block [0x822F0BB0..0x822F0BE0)
	// 822F0BB0: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F0BB4: 396B000F  addi r11, r11, 0xf
	ctx.r[11].s64 = ctx.r[11].s64 + 15;
	// 822F0BB8: 556B0036  rlwinm r11, r11, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822F0BBC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822F0BC0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 822F0BC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F0BC8: 419A0020  beq cr6, 0x822f0be8
	if ctx.cr[6].eq {
	pc = 0x822F0BE8; continue 'dispatch;
	}
	// 822F0BCC: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 822F0BD0: 41990058  bgt cr6, 0x822f0c28
	if ctx.cr[6].gt {
	pc = 0x822F0C28; continue 'dispatch;
	}
	// 822F0BD4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F0BD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F0BDC: 409AFFD4  bne cr6, 0x822f0bb0
	if !ctx.cr[6].eq {
	pc = 0x822F0BB0; continue 'dispatch;
	}
	pc = 0x822F0BE0; continue 'dispatch;
            }
            0x822F0BE0 => {
    //   block [0x822F0BE0..0x822F0BE8)
	// 822F0BE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822F0BE4: 480000A8  b 0x822f0c8c
	pc = 0x822F0C8C; continue 'dispatch;
            }
            0x822F0BE8 => {
    //   block [0x822F0BE8..0x822F0BFC)
	// 822F0BE8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F0BEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F0BF0: 419A000C  beq cr6, 0x822f0bfc
	if ctx.cr[6].eq {
	pc = 0x822F0BFC; continue 'dispatch;
	}
	// 822F0BF4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F0BF8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x822F0BFC; continue 'dispatch;
            }
            0x822F0BFC => {
    //   block [0x822F0BFC..0x822F0C10)
	// 822F0BFC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F0C00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F0C04: 419A000C  beq cr6, 0x822f0c10
	if ctx.cr[6].eq {
	pc = 0x822F0C10; continue 'dispatch;
	}
	// 822F0C08: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F0C0C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x822F0C10; continue 'dispatch;
            }
            0x822F0C10 => {
    //   block [0x822F0C10..0x822F0C20)
	// 822F0C10: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822F0C14: 409A000C  bne cr6, 0x822f0c20
	if !ctx.cr[6].eq {
	pc = 0x822F0C20; continue 'dispatch;
	}
	// 822F0C18: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F0C1C: 91673BBC  stw r11, 0x3bbc(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(15292 as u32), ctx.r[11].u32 ) };
	pc = 0x822F0C20; continue 'dispatch;
            }
            0x822F0C20 => {
    //   block [0x822F0C20..0x822F0C28)
	// 822F0C20: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 822F0C24: 4800003C  b 0x822f0c60
	pc = 0x822F0C60; continue 'dispatch;
            }
            0x822F0C28 => {
    //   block [0x822F0C28..0x822F0C3C)
	// 822F0C28: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F0C2C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822F0C30: 7D294050  subf r9, r9, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 822F0C34: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822F0C38: 48000028  b 0x822f0c60
	pc = 0x822F0C60; continue 'dispatch;
            }
            0x822F0C3C => {
    //   block [0x822F0C3C..0x822F0C60)
	// 822F0C3C: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 822F0C40: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822F0C44: 91483BB4  stw r10, 0x3bb4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(15284 as u32), ctx.r[10].u32 ) };
	// 822F0C48: 91273BC0  stw r9, 0x3bc0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(15296 as u32), ctx.r[9].u32 ) };
	// 822F0C4C: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 822F0C50: 81093BB0  lwz r8, 0x3bb0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(15280 as u32) ) } as u64;
	// 822F0C54: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822F0C58: 40980008  bge cr6, 0x822f0c60
	if !ctx.cr[6].lt {
	pc = 0x822F0C60; continue 'dispatch;
	}
	// 822F0C5C: 91493BB0  stw r10, 0x3bb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(15280 as u32), ctx.r[10].u32 ) };
	pc = 0x822F0C60; continue 'dispatch;
            }
            0x822F0C60 => {
    //   block [0x822F0C60..0x822F0C70)
	// 822F0C60: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 822F0C64: 409A000C  bne cr6, 0x822f0c70
	if !ctx.cr[6].eq {
	pc = 0x822F0C70; continue 'dispatch;
	}
	// 822F0C68: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 822F0C6C: 48000008  b 0x822f0c74
	pc = 0x822F0C74; continue 'dispatch;
            }
            0x822F0C70 => {
    //   block [0x822F0C70..0x822F0C74)
	// 822F0C70: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x822F0C74; continue 'dispatch;
            }
            0x822F0C74 => {
    //   block [0x822F0C74..0x822F0C8C)
	// 822F0C74: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822F0C78: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 822F0C7C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 822F0C80: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F0C84: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F0C88: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	pc = 0x822F0C8C; continue 'dispatch;
            }
            0x822F0C8C => {
    //   block [0x822F0C8C..0x822F0CA4)
	// 822F0C8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F0C90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F0C94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F0C98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F0C9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F0CA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F0CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F0CA8 size=116
    let mut pc: u32 = 0x822F0CA8;
    'dispatch: loop {
        match pc {
            0x822F0CA8 => {
    //   block [0x822F0CA8..0x822F0CD4)
	// 822F0CA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F0CAC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822F0CB0: 3963FFF0  addi r11, r3, -0x10
	ctx.r[11].s64 = ctx.r[3].s64 + -16;
	// 822F0CB4: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 822F0CB8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F0CBC: 80C93BD0  lwz r6, 0x3bd0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(15312 as u32) ) } as u64;
	// 822F0CC0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822F0CC4: 41980010  blt cr6, 0x822f0cd4
	if ctx.cr[6].lt {
	pc = 0x822F0CD4; continue 'dispatch;
	}
	// 822F0CC8: 392A000F  addi r9, r10, 0xf
	ctx.r[9].s64 = ctx.r[10].s64 + 15;
	// 822F0CCC: 55290036  rlwinm r9, r9, 0, 0, 0x1b
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 822F0CD0: 4800001C  b 0x822f0cec
	pc = 0x822F0CEC; continue 'dispatch;
            }
            0x822F0CD4 => {
    //   block [0x822F0CD4..0x822F0CEC)
	// 822F0CD4: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 822F0CD8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822F0CDC: 81293BD4  lwz r9, 0x3bd4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(15316 as u32) ) } as u64;
	// 822F0CE0: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822F0CE4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822F0CE8: 7D094830  slw r9, r8, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[8].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	pc = 0x822F0CEC; continue 'dispatch;
            }
            0x822F0CEC => {
    //   block [0x822F0CEC..0x822F0D1C)
	// 822F0CEC: 38E90010  addi r7, r9, 0x10
	ctx.r[7].s64 = ctx.r[9].s64 + 16;
	// 822F0CF0: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 822F0CF4: 7CA75A14  add r5, r7, r11
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 822F0CF8: 81093BC0  lwz r8, 0x3bc0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(15296 as u32) ) } as u64;
	// 822F0CFC: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 822F0D00: 409A001C  bne cr6, 0x822f0d1c
	if !ctx.cr[6].eq {
		sub_822F0D1C(ctx, base);
		return;
	}
	// 822F0D04: 91693BC0  stw r11, 0x3bc0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(15296 as u32), ctx.r[11].u32 ) };
	// 822F0D08: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 822F0D0C: 814B3BB4  lwz r10, 0x3bb4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15284 as u32) ) } as u64;
	// 822F0D10: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 822F0D14: 914B3BB4  stw r10, 0x3bb4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(15284 as u32), ctx.r[10].u32 ) };
	// 822F0D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F0D1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F0D1C size=48
    let mut pc: u32 = 0x822F0D1C;
    'dispatch: loop {
        match pc {
            0x822F0D1C => {
    //   block [0x822F0D1C..0x822F0D38)
	// 822F0D1C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822F0D20: 4198002C  blt cr6, 0x822f0d4c
	if ctx.cr[6].lt {
		sub_822F0D4C(ctx, base);
		return;
	}
	// 822F0D24: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 822F0D28: 81493BBC  lwz r10, 0x3bbc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(15292 as u32) ) } as u64;
	// 822F0D2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F0D30: 419A0008  beq cr6, 0x822f0d38
	if ctx.cr[6].eq {
	pc = 0x822F0D38; continue 'dispatch;
	}
	// 822F0D34: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x822F0D38; continue 'dispatch;
            }
            0x822F0D38 => {
    //   block [0x822F0D38..0x822F0D4C)
	// 822F0D38: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822F0D3C: 91693BBC  stw r11, 0x3bbc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(15292 as u32), ctx.r[11].u32 ) };
	// 822F0D40: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F0D44: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 822F0D48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F0D4C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F0D4C size=44
    let mut pc: u32 = 0x822F0D4C;
    'dispatch: loop {
        match pc {
            0x822F0D4C => {
    //   block [0x822F0D4C..0x822F0D78)
	// 822F0D4C: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 822F0D50: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822F0D54: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 822F0D58: 80C93BC4  lwz r6, 0x3bc4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(15300 as u32) ) } as u64;
	// 822F0D5C: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 822F0D60: 814A3BC8  lwz r10, 0x3bc8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15304 as u32) ) } as u64;
	// 822F0D64: 90E93BC4  stw r7, 0x3bc4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(15300 as u32), ctx.r[7].u32 ) };
	// 822F0D68: 7D28502E  lwzx r9, r8, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F0D6C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822F0D70: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 822F0D74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F0D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F0D78 size=12
    let mut pc: u32 = 0x822F0D78;
    'dispatch: loop {
        match pc {
            0x822F0D78 => {
    //   block [0x822F0D78..0x822F0D84)
	// 822F0D78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F0D7C: 409A0008  bne cr6, 0x822f0d84
	if !ctx.cr[6].eq {
		sub_822F0D84(ctx, base);
		return;
	}
	// 822F0D80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F0D84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F0D84 size=88
    let mut pc: u32 = 0x822F0D84;
    'dispatch: loop {
        match pc {
            0x822F0D84 => {
    //   block [0x822F0D84..0x822F0DDC)
	// 822F0D84: 3963FF00  addi r11, r3, -0x100
	ctx.r[11].s64 = ctx.r[3].s64 + -256;
	// 822F0D88: 556B8738  rlwinm r11, r11, 0x10, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 822F0D8C: 7C6A5830  slw r10, r3, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[3].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 822F0D90: 392AF000  addi r9, r10, -0x1000
	ctx.r[9].s64 = ctx.r[10].s64 + -4096;
	// 822F0D94: 5529877A  rlwinm r9, r9, 0x10, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 822F0D98: 7D4A4830  slw r10, r10, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 822F0D9C: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822F0DA0: 396AC000  addi r11, r10, -0x4000
	ctx.r[11].s64 = ctx.r[10].s64 + -16384;
	// 822F0DA4: 556B87BC  rlwinm r11, r11, 0x10, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 822F0DA8: 7D4A5830  slw r10, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 822F0DAC: 554A93BE  srwi r10, r10, 0xe
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(14);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F0DB0: 5548F87E  srwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822F0DB4: 7D4A4078  andc r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 & !ctx.r[8].u64;
	// 822F0DB8: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 822F0DBC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822F0DC0: 386B000D  addi r3, r11, 0xd
	ctx.r[3].s64 = ctx.r[11].s64 + 13;
	// 822F0DC4: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 822F0DC8: 816B3BD0  lwz r11, 0x3bd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15312 as u32) ) } as u64;
	// 822F0DCC: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F0DD0: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 822F0DD4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 822F0DD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F0DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F0DE0 size=164
    let mut pc: u32 = 0x822F0DE0;
    'dispatch: loop {
        match pc {
            0x822F0DE0 => {
    //   block [0x822F0DE0..0x822F0E08)
	// 822F0DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F0DE4: 482442CD  bl 0x825350b0
	ctx.lr = 0x822F0DE8;
	sub_82535080(ctx, base);
	// 822F0DE8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F0DEC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822F0DF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F0DF4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822F0DF8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822F0DFC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 822F0E00: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 822F0E04: 41980068  blt cr6, 0x822f0e6c
	if ctx.cr[6].lt {
	pc = 0x822F0E6C; continue 'dispatch;
	}
	pc = 0x822F0E08; continue 'dispatch;
            }
            0x822F0E08 => {
    //   block [0x822F0E08..0x822F0E60)
	// 822F0E08: 7D7DE214  add r11, r29, r28
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[28].u64;
	// 822F0E0C: 7D7F0E70  srawi r31, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822F0E10: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822F0E14: 41980058  blt cr6, 0x822f0e6c
	if ctx.cr[6].lt {
	pc = 0x822F0E6C; continue 'dispatch;
	}
	// 822F0E18: 7F1FD000  cmpw cr6, r31, r26
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[26].s32, &mut ctx.xer);
	// 822F0E1C: 40980050  bge cr6, 0x822f0e6c
	if !ctx.cr[6].lt {
	pc = 0x822F0E6C; continue 'dispatch;
	}
	// 822F0E20: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F0E24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F0E28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F0E2C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F0E30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F0E34: 4E800421  bctrl
	ctx.lr = 0x822F0E38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F0E38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F0E3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F0E40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F0E44: 4E800421  bctrl
	ctx.lr = 0x822F0E48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F0E48: 7F1B1800  cmpw cr6, r27, r3
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[3].s32, &mut ctx.xer);
	// 822F0E4C: 419A002C  beq cr6, 0x822f0e78
	if ctx.cr[6].eq {
	pc = 0x822F0E78; continue 'dispatch;
	}
	// 822F0E50: 7D63D851  subf. r11, r3, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[3].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F0E54: 4081000C  ble 0x822f0e60
	if !ctx.cr[0].gt {
	pc = 0x822F0E60; continue 'dispatch;
	}
	// 822F0E58: 3B9F0001  addi r28, r31, 1
	ctx.r[28].s64 = ctx.r[31].s64 + 1;
	// 822F0E5C: 48000008  b 0x822f0e64
	pc = 0x822F0E64; continue 'dispatch;
            }
            0x822F0E60 => {
    //   block [0x822F0E60..0x822F0E64)
	// 822F0E60: 3BBFFFFF  addi r29, r31, -1
	ctx.r[29].s64 = ctx.r[31].s64 + -1;
	pc = 0x822F0E64; continue 'dispatch;
            }
            0x822F0E64 => {
    //   block [0x822F0E64..0x822F0E6C)
	// 822F0E64: 7D7CE851  subf. r11, r28, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F0E68: 4080FFA0  bge 0x822f0e08
	if !ctx.cr[0].lt {
	pc = 0x822F0E08; continue 'dispatch;
	}
	pc = 0x822F0E6C; continue 'dispatch;
            }
            0x822F0E6C => {
    //   block [0x822F0E6C..0x822F0E78)
	// 822F0E6C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 822F0E70: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F0E74: 4824428C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822F0E78 => {
    //   block [0x822F0E78..0x822F0E84)
	// 822F0E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F0E7C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F0E80: 48244280  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F0E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F0E88 size=320
    let mut pc: u32 = 0x822F0E88;
    'dispatch: loop {
        match pc {
            0x822F0E88 => {
    //   block [0x822F0E88..0x822F0EEC)
	// 822F0E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F0E8C: 48244225  bl 0x825350b0
	ctx.lr = 0x822F0E90;
	sub_82535080(ctx, base);
	// 822F0E90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F0E94: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822F0E98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F0E9C: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F0EA0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822F0EA4: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 822F0EA8: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 822F0EAC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F0EB0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F0EB4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F0EB8: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822F0EBC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822F0EC0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F0EC4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F0EC8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822F0ECC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F0ED0: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822F0ED4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F0ED8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 822F0EDC: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F0EE0: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 822F0EE4: 409900D8  ble cr6, 0x822f0fbc
	if !ctx.cr[6].gt {
	pc = 0x822F0FBC; continue 'dispatch;
	}
	// 822F0EE8: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	pc = 0x822F0EEC; continue 'dispatch;
            }
            0x822F0EEC => {
    //   block [0x822F0EEC..0x822F0F24)
	// 822F0EEC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F0EF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822F0EF4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F0EF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F0EFC: 4E800421  bctrl
	ctx.lr = 0x822F0F00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F0F00: 7F03D000  cmpw cr6, r3, r26
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[26].s32, &mut ctx.xer);
	// 822F0F04: 40980020  bge cr6, 0x822f0f24
	if !ctx.cr[6].lt {
	pc = 0x822F0F24; continue 'dispatch;
	}
	// 822F0F08: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822F0F0C: 3B9C0018  addi r28, r28, 0x18
	ctx.r[28].s64 = ctx.r[28].s64 + 24;
	// 822F0F10: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 822F0F14: 4198FFD8  blt cr6, 0x822f0eec
	if ctx.cr[6].lt {
	pc = 0x822F0EEC; continue 'dispatch;
	}
	// 822F0F18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F0F1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F0F20: 482441E0  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822F0F24 => {
    //   block [0x822F0F24..0x822F0F4C)
	// 822F0F24: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 822F0F28: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822F0F2C: 41980058  blt cr6, 0x822f0f84
	if ctx.cr[6].lt {
	pc = 0x822F0F84; continue 'dispatch;
	}
	// 822F0F30: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822F0F34: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 822F0F38: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822F0F3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F0F40: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F0F44: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822F0F48: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	pc = 0x822F0F4C; continue 'dispatch;
            }
            0x822F0F4C => {
    //   block [0x822F0F4C..0x822F0F84)
	// 822F0F4C: 812BFFE4  lwz r9, -0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) } as u64;
	// 822F0F50: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822F0F54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F0F58: 912BFFFC  stw r9, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 822F0F5C: 812BFFE8  lwz r9, -0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 822F0F60: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822F0F64: 812BFFEC  lwz r9, -0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) } as u64;
	// 822F0F68: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 822F0F6C: 812BFFF0  lwz r9, -0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 822F0F70: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822F0F74: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 822F0F78: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 822F0F7C: 396BFFE8  addi r11, r11, -0x18
	ctx.r[11].s64 = ctx.r[11].s64 + -24;
	// 822F0F80: 409AFFCC  bne cr6, 0x822f0f4c
	if !ctx.cr[6].eq {
	pc = 0x822F0F4C; continue 'dispatch;
	}
	pc = 0x822F0F84; continue 'dispatch;
            }
            0x822F0F84 => {
    //   block [0x822F0F84..0x822F0FBC)
	// 822F0F84: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F0F88: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F0F8C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 822F0F90: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F0F94: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822F0F98: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F0F9C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F0FA0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822F0FA4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F0FA8: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822F0FAC: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F0FB0: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 822F0FB4: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F0FB8: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x822F0FBC; continue 'dispatch;
            }
            0x822F0FBC => {
    //   block [0x822F0FBC..0x822F0FC8)
	// 822F0FBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F0FC0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F0FC4: 4824413C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F0FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F0FC8 size=344
    let mut pc: u32 = 0x822F0FC8;
    'dispatch: loop {
        match pc {
            0x822F0FC8 => {
    //   block [0x822F0FC8..0x822F1034)
	// 822F0FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F0FCC: 482440E5  bl 0x825350b0
	ctx.lr = 0x822F0FD0;
	sub_82535080(ctx, base);
	// 822F0FD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F0FD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F0FD8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822F0FDC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822F0FE0: 57AB2834  slwi r11, r29, 5
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F0FE4: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 822F0FE8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F0FEC: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822F0FF0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F0FF4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822F0FF8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F0FFC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1000: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822F1004: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F1008: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822F100C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F1010: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 822F1014: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F1018: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 822F101C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F1020: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 822F1024: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 822F1028: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 822F102C: 409900E8  ble cr6, 0x822f1114
	if !ctx.cr[6].gt {
	pc = 0x822F1114; continue 'dispatch;
	}
	// 822F1030: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	pc = 0x822F1034; continue 'dispatch;
            }
            0x822F1034 => {
    //   block [0x822F1034..0x822F106C)
	// 822F1034: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1038: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822F103C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1040: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F1044: 4E800421  bctrl
	ctx.lr = 0x822F1048;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F1048: 7F03D000  cmpw cr6, r3, r26
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[26].s32, &mut ctx.xer);
	// 822F104C: 40980020  bge cr6, 0x822f106c
	if !ctx.cr[6].lt {
	pc = 0x822F106C; continue 'dispatch;
	}
	// 822F1050: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822F1054: 3B9C0020  addi r28, r28, 0x20
	ctx.r[28].s64 = ctx.r[28].s64 + 32;
	// 822F1058: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 822F105C: 4198FFD8  blt cr6, 0x822f1034
	if ctx.cr[6].lt {
	pc = 0x822F1034; continue 'dispatch;
	}
	// 822F1060: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F1064: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F1068: 48244098  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822F106C => {
    //   block [0x822F106C..0x822F108C)
	// 822F106C: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 822F1070: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822F1074: 41980060  blt cr6, 0x822f10d4
	if ctx.cr[6].lt {
	pc = 0x822F10D4; continue 'dispatch;
	}
	// 822F1078: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F107C: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 822F1080: 7D2ADA14  add r9, r10, r27
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 822F1084: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 822F1088: 39690028  addi r11, r9, 0x28
	ctx.r[11].s64 = ctx.r[9].s64 + 40;
	pc = 0x822F108C; continue 'dispatch;
            }
            0x822F108C => {
    //   block [0x822F108C..0x822F10D4)
	// 822F108C: 812BFFDC  lwz r9, -0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) } as u64;
	// 822F1090: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822F1094: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F1098: 912BFFFC  stw r9, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 822F109C: 812BFFE0  lwz r9, -0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) } as u64;
	// 822F10A0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822F10A4: 812BFFE4  lwz r9, -0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) } as u64;
	// 822F10A8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 822F10AC: 812BFFE8  lwz r9, -0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 822F10B0: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822F10B4: 812BFFEC  lwz r9, -0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) } as u64;
	// 822F10B8: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 822F10BC: 812BFFF0  lwz r9, -0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 822F10C0: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 822F10C4: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 822F10C8: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 822F10CC: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 822F10D0: 409AFFBC  bne cr6, 0x822f108c
	if !ctx.cr[6].eq {
	pc = 0x822F108C; continue 'dispatch;
	}
	pc = 0x822F10D4; continue 'dispatch;
            }
            0x822F10D4 => {
    //   block [0x822F10D4..0x822F1114)
	// 822F10D4: 57CB2834  slwi r11, r30, 5
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F10D8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F10DC: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822F10E0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F10E4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F10E8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822F10EC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F10F0: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822F10F4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F10F8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 822F10FC: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F1100: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 822F1104: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F1108: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 822F110C: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 822F1110: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	pc = 0x822F1114; continue 'dispatch;
            }
            0x822F1114 => {
    //   block [0x822F1114..0x822F1120)
	// 822F1114: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F1118: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F111C: 48243FE4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F1120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F1120 size=392
    let mut pc: u32 = 0x822F1120;
    'dispatch: loop {
        match pc {
            0x822F1120 => {
    //   block [0x822F1120..0x822F119C)
	// 822F1120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F1124: 48243F8D  bl 0x825350b0
	ctx.lr = 0x822F1128;
	sub_82535080(ctx, base);
	// 822F1128: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F112C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822F1130: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F1134: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F1138: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822F113C: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 822F1140: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 822F1144: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F1148: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F114C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F1150: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822F1154: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822F1158: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F115C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1160: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822F1164: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F1168: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822F116C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F1170: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 822F1174: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F1178: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 822F117C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F1180: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 822F1184: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 822F1188: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 822F118C: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F1190: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 822F1194: 40990108  ble cr6, 0x822f129c
	if !ctx.cr[6].gt {
	pc = 0x822F129C; continue 'dispatch;
	}
	// 822F1198: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	pc = 0x822F119C; continue 'dispatch;
            }
            0x822F119C => {
    //   block [0x822F119C..0x822F11D4)
	// 822F119C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F11A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822F11A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F11A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F11AC: 4E800421  bctrl
	ctx.lr = 0x822F11B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F11B0: 7F03D000  cmpw cr6, r3, r26
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[26].s32, &mut ctx.xer);
	// 822F11B4: 40980020  bge cr6, 0x822f11d4
	if !ctx.cr[6].lt {
	pc = 0x822F11D4; continue 'dispatch;
	}
	// 822F11B8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822F11BC: 3B9C0024  addi r28, r28, 0x24
	ctx.r[28].s64 = ctx.r[28].s64 + 36;
	// 822F11C0: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 822F11C4: 4198FFD8  blt cr6, 0x822f119c
	if ctx.cr[6].lt {
	pc = 0x822F119C; continue 'dispatch;
	}
	// 822F11C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F11CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F11D0: 48243F30  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822F11D4 => {
    //   block [0x822F11D4..0x822F11FC)
	// 822F11D4: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 822F11D8: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822F11DC: 41980070  blt cr6, 0x822f124c
	if ctx.cr[6].lt {
	pc = 0x822F124C; continue 'dispatch;
	}
	// 822F11E0: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822F11E4: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 822F11E8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822F11EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F11F0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F11F4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822F11F8: 396B002C  addi r11, r11, 0x2c
	ctx.r[11].s64 = ctx.r[11].s64 + 44;
	pc = 0x822F11FC; continue 'dispatch;
            }
            0x822F11FC => {
    //   block [0x822F11FC..0x822F124C)
	// 822F11FC: 812BFFD8  lwz r9, -0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-40 as u32) ) } as u64;
	// 822F1200: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822F1204: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F1208: 912BFFFC  stw r9, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 822F120C: 812BFFDC  lwz r9, -0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) } as u64;
	// 822F1210: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822F1214: 812BFFE0  lwz r9, -0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) } as u64;
	// 822F1218: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 822F121C: 812BFFE4  lwz r9, -0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) } as u64;
	// 822F1220: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822F1224: 812BFFE8  lwz r9, -0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 822F1228: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 822F122C: 812BFFEC  lwz r9, -0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) } as u64;
	// 822F1230: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 822F1234: 812BFFF0  lwz r9, -0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 822F1238: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 822F123C: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 822F1240: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 822F1244: 396BFFDC  addi r11, r11, -0x24
	ctx.r[11].s64 = ctx.r[11].s64 + -36;
	// 822F1248: 409AFFB4  bne cr6, 0x822f11fc
	if !ctx.cr[6].eq {
	pc = 0x822F11FC; continue 'dispatch;
	}
	pc = 0x822F124C; continue 'dispatch;
            }
            0x822F124C => {
    //   block [0x822F124C..0x822F129C)
	// 822F124C: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F1250: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F1254: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 822F1258: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F125C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822F1260: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F1264: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1268: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822F126C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F1270: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822F1274: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F1278: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 822F127C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F1280: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 822F1284: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F1288: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 822F128C: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 822F1290: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 822F1294: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F1298: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	pc = 0x822F129C; continue 'dispatch;
            }
            0x822F129C => {
    //   block [0x822F129C..0x822F12A8)
	// 822F129C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F12A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F12A4: 48243E5C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F12A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F12A8 size=296
    let mut pc: u32 = 0x822F12A8;
    'dispatch: loop {
        match pc {
            0x822F12A8 => {
    //   block [0x822F12A8..0x822F1304)
	// 822F12A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F12AC: 48243E05  bl 0x825350b0
	ctx.lr = 0x822F12B0;
	sub_82535080(ctx, base);
	// 822F12B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F12B4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822F12B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822F12BC: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F12C0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822F12C4: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 822F12C8: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 822F12CC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F12D0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F12D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F12D8: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822F12DC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822F12E0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F12E4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F12E8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822F12EC: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F12F0: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822F12F4: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F12F8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 822F12FC: 409900C8  ble cr6, 0x822f13c4
	if !ctx.cr[6].gt {
	pc = 0x822F13C4; continue 'dispatch;
	}
	// 822F1300: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	pc = 0x822F1304; continue 'dispatch;
            }
            0x822F1304 => {
    //   block [0x822F1304..0x822F133C)
	// 822F1304: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1308: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822F130C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1310: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F1314: 4E800421  bctrl
	ctx.lr = 0x822F1318;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F1318: 7F03D000  cmpw cr6, r3, r26
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[26].s32, &mut ctx.xer);
	// 822F131C: 40980020  bge cr6, 0x822f133c
	if !ctx.cr[6].lt {
	pc = 0x822F133C; continue 'dispatch;
	}
	// 822F1320: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822F1324: 3B9C0014  addi r28, r28, 0x14
	ctx.r[28].s64 = ctx.r[28].s64 + 20;
	// 822F1328: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 822F132C: 4198FFD8  blt cr6, 0x822f1304
	if ctx.cr[6].lt {
	pc = 0x822F1304; continue 'dispatch;
	}
	// 822F1330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F1334: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F1338: 48243DC8  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x822F133C => {
    //   block [0x822F133C..0x822F1364)
	// 822F133C: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 822F1340: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 822F1344: 41980050  blt cr6, 0x822f1394
	if ctx.cr[6].lt {
	pc = 0x822F1394; continue 'dispatch;
	}
	// 822F1348: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822F134C: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 822F1350: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822F1354: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F1358: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F135C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822F1360: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	pc = 0x822F1364; continue 'dispatch;
            }
            0x822F1364 => {
    //   block [0x822F1364..0x822F1394)
	// 822F1364: 812BFFE8  lwz r9, -0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 822F1368: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822F136C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F1370: 912BFFFC  stw r9, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 822F1374: 812BFFEC  lwz r9, -0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) } as u64;
	// 822F1378: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822F137C: 812BFFF0  lwz r9, -0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 822F1380: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 822F1384: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 822F1388: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822F138C: 396BFFEC  addi r11, r11, -0x14
	ctx.r[11].s64 = ctx.r[11].s64 + -20;
	// 822F1390: 409AFFD4  bne cr6, 0x822f1364
	if !ctx.cr[6].eq {
	pc = 0x822F1364; continue 'dispatch;
	}
	pc = 0x822F1394; continue 'dispatch;
            }
            0x822F1394 => {
    //   block [0x822F1394..0x822F13C4)
	// 822F1394: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F1398: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F139C: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 822F13A0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F13A4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822F13A8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F13AC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F13B0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822F13B4: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F13B8: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822F13BC: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F13C0: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x822F13C4; continue 'dispatch;
            }
            0x822F13C4 => {
    //   block [0x822F13C4..0x822F13D0)
	// 822F13C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F13C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F13CC: 48243D34  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F13D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F13D0 size=8
    let mut pc: u32 = 0x822F13D0;
    'dispatch: loop {
        match pc {
            0x822F13D0 => {
    //   block [0x822F13D0..0x822F13D8)
	// 822F13D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822F13D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F13D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F13D8 size=8
    let mut pc: u32 = 0x822F13D8;
    'dispatch: loop {
        match pc {
            0x822F13D8 => {
    //   block [0x822F13D8..0x822F13E0)
	// 822F13D8: 806300E0  lwz r3, 0xe0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) } as u64;
	// 822F13DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F13E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F13E0 size=380
    let mut pc: u32 = 0x822F13E0;
    'dispatch: loop {
        match pc {
            0x822F13E0 => {
    //   block [0x822F13E0..0x822F142C)
	// 822F13E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F13E4: 48243CC5  bl 0x825350a8
	ctx.lr = 0x822F13E8;
	sub_82535080(ctx, base);
	// 822F13E8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F13EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822F13F0: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 822F13F4: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 822F13F8: 4BFFBD39  bl 0x822ed130
	ctx.lr = 0x822F13FC;
	sub_822ED130(ctx, base);
	// 822F13FC: 80830080  lwz r4, 0x80(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 822F1400: 4BFFBDF1  bl 0x822ed1f0
	ctx.lr = 0x822F1404;
	sub_822ED1F0(ctx, base);
	// 822F1404: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F1408: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822F140C: 419A0148  beq cr6, 0x822f1554
	if ctx.cr[6].eq {
	pc = 0x822F1554; continue 'dispatch;
	}
	// 822F1410: 3B040080  addi r24, r4, 0x80
	ctx.r[24].s64 = ctx.r[4].s64 + 128;
	// 822F1414: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822F1418: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F141C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1420: 409A000C  bne cr6, 0x822f142c
	if !ctx.cr[6].eq {
	pc = 0x822F142C; continue 'dispatch;
	}
	// 822F1424: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 822F1428: 4800002C  b 0x822f1454
	pc = 0x822F1454; continue 'dispatch;
            }
            0x822F142C => {
    //   block [0x822F142C..0x822F1444)
	// 822F142C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1430: 81380008  lwz r9, 8(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1434: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F1438: 419A000C  beq cr6, 0x822f1444
	if ctx.cr[6].eq {
	pc = 0x822F1444; continue 'dispatch;
	}
	// 822F143C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 822F1440: 48000014  b 0x822f1454
	pc = 0x822F1454; continue 'dispatch;
            }
            0x822F1444 => {
    //   block [0x822F1444..0x822F1454)
	// 822F1444: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1448: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F144C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F1450: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F1454; continue 'dispatch;
            }
            0x822F1454 => {
    //   block [0x822F1454..0x822F14AC)
	// 822F1454: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F1458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F145C: 419A00F8  beq cr6, 0x822f1554
	if ctx.cr[6].eq {
	pc = 0x822F1554; continue 'dispatch;
	}
	// 822F1460: 897C0004  lbz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F1464: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 822F1468: 409A00EC  bne cr6, 0x822f1554
	if !ctx.cr[6].eq {
	pc = 0x822F1554; continue 'dispatch;
	}
	// 822F146C: 817C0050  lwz r11, 0x50(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F1470: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822F1474: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822F1478: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 822F147C: 38EAC610  addi r7, r10, -0x39f0
	ctx.r[7].s64 = ctx.r[10].s64 + -14832;
	// 822F1480: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F1484: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 822F1488: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F148C: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F1490: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1494: 48078FFD  bl 0x8236a490
	ctx.lr = 0x822F1498;
	sub_8236A490(ctx, base);
	// 822F1498: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F149C: 419A0010  beq cr6, 0x822f14ac
	if ctx.cr[6].eq {
	pc = 0x822F14AC; continue 'dispatch;
	}
	// 822F14A0: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822F14A4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822F14A8: 48000008  b 0x822f14b0
	pc = 0x822F14B0; continue 'dispatch;
            }
            0x822F14AC => {
    //   block [0x822F14AC..0x822F14B0)
	// 822F14AC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	pc = 0x822F14B0; continue 'dispatch;
            }
            0x822F14B0 => {
    //   block [0x822F14B0..0x822F14DC)
	// 822F14B0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 822F14B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F14B8: 419A0024  beq cr6, 0x822f14dc
	if ctx.cr[6].eq {
	pc = 0x822F14DC; continue 'dispatch;
	}
	// 822F14BC: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 822F14C0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 822F14C4: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 822F14C8: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 822F14CC: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 822F14D0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 822F14D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822F14D8: 480001F9  bl 0x822f16d0
	ctx.lr = 0x822F14DC;
	sub_822F16D0(ctx, base);
	pc = 0x822F14DC; continue 'dispatch;
            }
            0x822F14DC => {
    //   block [0x822F14DC..0x822F14F0)
	// 822F14DC: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F14E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F14E4: 409A000C  bne cr6, 0x822f14f0
	if !ctx.cr[6].eq {
	pc = 0x822F14F0; continue 'dispatch;
	}
	// 822F14E8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 822F14EC: 4800002C  b 0x822f1518
	pc = 0x822F1518; continue 'dispatch;
            }
            0x822F14F0 => {
    //   block [0x822F14F0..0x822F1508)
	// 822F14F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F14F4: 81380008  lwz r9, 8(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F14F8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F14FC: 419A000C  beq cr6, 0x822f1508
	if ctx.cr[6].eq {
	pc = 0x822F1508; continue 'dispatch;
	}
	// 822F1500: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 822F1504: 48000014  b 0x822f1518
	pc = 0x822F1518; continue 'dispatch;
            }
            0x822F1508 => {
    //   block [0x822F1508..0x822F1518)
	// 822F1508: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F150C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F1510: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F1514: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F1518; continue 'dispatch;
            }
            0x822F1518 => {
    //   block [0x822F1518..0x822F1554)
	// 822F1518: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F151C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1520: 419A0034  beq cr6, 0x822f1554
	if ctx.cr[6].eq {
	pc = 0x822F1554; continue 'dispatch;
	}
	// 822F1524: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822F1528: 4BF3BEC1  bl 0x8222d3e8
	ctx.lr = 0x822F152C;
	sub_8222D3E8(ctx, base);
	// 822F152C: 81630054  lwz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F1530: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 822F1534: 40980020  bge cr6, 0x822f1554
	if !ctx.cr[6].lt {
	pc = 0x822F1554; continue 'dispatch;
	}
	// 822F1538: 396B000B  addi r11, r11, 0xb
	ctx.r[11].s64 = ctx.r[11].s64 + 11;
	// 822F153C: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822F1540: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F1544: 7D4B192A  stdx r10, r11, r3
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u64) };
	// 822F1548: 81630054  lwz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F154C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822F1550: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x822F1554; continue 'dispatch;
            }
            0x822F1554 => {
    //   block [0x822F1554..0x822F155C)
	// 822F1554: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822F1558: 48243BA0  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F1560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F1560 size=364
    let mut pc: u32 = 0x822F1560;
    'dispatch: loop {
        match pc {
            0x822F1560 => {
    //   block [0x822F1560..0x822F1600)
	// 822F1560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F1564: 48243B55  bl 0x825350b8
	ctx.lr = 0x822F1568;
	sub_82535080(ctx, base);
	// 822F1568: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F156C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822F1570: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822F1574: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822F1578: 419A014C  beq cr6, 0x822f16c4
	if ctx.cr[6].eq {
	pc = 0x822F16C4; continue 'dispatch;
	}
	// 822F157C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F1580: 419A0144  beq cr6, 0x822f16c4
	if ctx.cr[6].eq {
	pc = 0x822F16C4; continue 'dispatch;
	}
	// 822F1584: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F1588: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F158C: C1AB01A4  lfs f13, 0x1a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F1590: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F1594: C00B24DC  lfs f0, 0x24dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9436 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F1598: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822F159C: 41990128  bgt cr6, 0x822f16c4
	if ctx.cr[6].gt {
	pc = 0x822F16C4; continue 'dispatch;
	}
	// 822F15A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F15A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F15A8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F15AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F15B0: 4E800421  bctrl
	ctx.lr = 0x822F15B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F15B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F15B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F15BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F15C0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F15C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F15C8: 4E800421  bctrl
	ctx.lr = 0x822F15CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F15CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F15D0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822F15D4: 419800F0  blt cr6, 0x822f16c4
	if ctx.cr[6].lt {
	pc = 0x822F16C4; continue 'dispatch;
	}
	// 822F15D8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822F15DC: 419800E8  blt cr6, 0x822f16c4
	if ctx.cr[6].lt {
	pc = 0x822F16C4; continue 'dispatch;
	}
	// 822F15E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F15E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F15E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F15EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F15F0: 4E800421  bctrl
	ctx.lr = 0x822F15F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F15F4: 2F030005  cmpwi cr6, r3, 5
	ctx.cr[6].compare_i32(ctx.r[3].s32, 5, &mut ctx.xer);
	// 822F15F8: 419A0008  beq cr6, 0x822f1600
	if ctx.cr[6].eq {
	pc = 0x822F1600; continue 'dispatch;
	}
	// 822F15FC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
            }
            0x822F1600 => {
    //   block [0x822F1600..0x822F164C)
	// 822F1600: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822F1604: 2B1E0009  cmplwi cr6, r30, 9
	ctx.cr[6].compare_u32(ctx.r[30].u32, 9 as u32, &mut ctx.xer);
	// 822F1608: 41990068  bgt cr6, 0x822f1670
	if ctx.cr[6].gt {
	pc = 0x822F1670; continue 'dispatch;
	}
	// 822F160C: 3D80822F  lis r12, -0x7dd1
	ctx.r[12].s64 = -2110849024;
	// 822F1610: 398C1624  addi r12, r12, 0x1624
	ctx.r[12].s64 = ctx.r[12].s64 + 5668;
	// 822F1614: 57C0103A  slwi r0, r30, 2
	ctx.r[0].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 822F1618: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 822F161C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 822F1620: 4E800420  bctr
	match ctx.r[30].u64 {
		0 => {
	pc = 0x822F164C; continue 'dispatch;
		},
		1 => {
	pc = 0x822F164C; continue 'dispatch;
		},
		2 => {
	pc = 0x822F1654; continue 'dispatch;
		},
		3 => {
	pc = 0x822F165C; continue 'dispatch;
		},
		4 => {
	pc = 0x822F1670; continue 'dispatch;
		},
		5 => {
	pc = 0x822F1664; continue 'dispatch;
		},
		6 => {
	pc = 0x822F1670; continue 'dispatch;
		},
		7 => {
	pc = 0x822F1670; continue 'dispatch;
		},
		8 => {
	pc = 0x822F1670; continue 'dispatch;
		},
		9 => {
	pc = 0x822F166C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 822F1624: 822F164C  lwz r17, 0x164c(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5708 as u32) ) } as u64;
	// 822F1628: 822F164C  lwz r17, 0x164c(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5708 as u32) ) } as u64;
	// 822F162C: 822F1654  lwz r17, 0x1654(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5716 as u32) ) } as u64;
	// 822F1630: 822F165C  lwz r17, 0x165c(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5724 as u32) ) } as u64;
	// 822F1634: 822F1670  lwz r17, 0x1670(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5744 as u32) ) } as u64;
	// 822F1638: 822F1664  lwz r17, 0x1664(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5732 as u32) ) } as u64;
	// 822F163C: 822F1670  lwz r17, 0x1670(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5744 as u32) ) } as u64;
	// 822F1640: 822F1670  lwz r17, 0x1670(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5744 as u32) ) } as u64;
	// 822F1644: 822F1670  lwz r17, 0x1670(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5744 as u32) ) } as u64;
	// 822F1648: 822F166C  lwz r17, 0x166c(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5740 as u32) ) } as u64;
            }
            0x822F164C => {
    //   block [0x822F164C..0x822F1654)
	// 822F164C: 38600234  li r3, 0x234
	ctx.r[3].s64 = 564;
	// 822F1650: 48000020  b 0x822f1670
	pc = 0x822F1670; continue 'dispatch;
            }
            0x822F1654 => {
    //   block [0x822F1654..0x822F165C)
	// 822F1654: 38600237  li r3, 0x237
	ctx.r[3].s64 = 567;
	// 822F1658: 48000018  b 0x822f1670
	pc = 0x822F1670; continue 'dispatch;
            }
            0x822F165C => {
    //   block [0x822F165C..0x822F1664)
	// 822F165C: 3860023A  li r3, 0x23a
	ctx.r[3].s64 = 570;
	// 822F1660: 48000010  b 0x822f1670
	pc = 0x822F1670; continue 'dispatch;
            }
            0x822F1664 => {
    //   block [0x822F1664..0x822F166C)
	// 822F1664: 3860023D  li r3, 0x23d
	ctx.r[3].s64 = 573;
	// 822F1668: 48000008  b 0x822f1670
	pc = 0x822F1670; continue 'dispatch;
            }
            0x822F166C => {
    //   block [0x822F166C..0x822F1670)
	// 822F166C: 38600240  li r3, 0x240
	ctx.r[3].s64 = 576;
	pc = 0x822F1670; continue 'dispatch;
            }
            0x822F1670 => {
    //   block [0x822F1670..0x822F16C4)
	// 822F1670: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F1674: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822F1678: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822F167C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F1680: C00B011C  lfs f0, 0x11c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F1684: C1AB0118  lfs f13, 0x118(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F1688: C18B0114  lfs f12, 0x114(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822F168C: C16B0110  lfs f11, 0x110(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822F1690: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822F1694: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822F1698: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822F169C: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822F16A0: 480712B9  bl 0x82362958
	ctx.lr = 0x822F16A4;
	sub_82362958(ctx, base);
	// 822F16A4: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F16A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F16AC: 419A0018  beq cr6, 0x822f16c4
	if ctx.cr[6].eq {
	pc = 0x822F16C4; continue 'dispatch;
	}
	// 822F16B0: 389C0008  addi r4, r28, 8
	ctx.r[4].s64 = ctx.r[28].s64 + 8;
	// 822F16B4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F16B8: 4819CAB1  bl 0x8248e168
	ctx.lr = 0x822F16BC;
	sub_8248E168(ctx, base);
	// 822F16BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F16C0: 917C000C  stw r11, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x822F16C4; continue 'dispatch;
            }
            0x822F16C4 => {
    //   block [0x822F16C4..0x822F16CC)
	// 822F16C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822F16C8: 48243A40  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F16D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F16D0 size=732
    let mut pc: u32 = 0x822F16D0;
    'dispatch: loop {
        match pc {
            0x822F16D0 => {
    //   block [0x822F16D0..0x822F1754)
	// 822F16D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F16D4: 482439CD  bl 0x825350a0
	ctx.lr = 0x822F16D8;
	sub_82535080(ctx, base);
	// 822F16D8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F16DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F16E0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822F16E4: 396BC648  addi r11, r11, -0x39b8
	ctx.r[11].s64 = ctx.r[11].s64 + -14776;
	// 822F16E8: 3BFB0080  addi r31, r27, 0x80
	ctx.r[31].s64 = ctx.r[27].s64 + 128;
	// 822F16EC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822F16F0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822F16F4: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 822F16F8: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F16FC: 39600280  li r11, 0x280
	ctx.r[11].s64 = 640;
	// 822F1700: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822F1704: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822F1708: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 822F170C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822F1710: 38CAC618  addi r6, r10, -0x39e8
	ctx.r[6].s64 = ctx.r[10].s64 + -14824;
	// 822F1714: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 822F1718: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 822F171C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 822F1720: A17D0008  lhz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1724: 386ADBE0  addi r3, r10, -0x2420
	ctx.r[3].s64 = ctx.r[10].s64 + -9248;
	// 822F1728: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F172C: 556B203E  rotlwi r11, r11, 4
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 822F1730: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 822F1734: 38AB0280  addi r5, r11, 0x280
	ctx.r[5].s64 = ctx.r[11].s64 + 640;
	// 822F1738: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 822F173C: 4BF03BAD  bl 0x821f52e8
	ctx.lr = 0x822F1740;
	sub_821F52E8(ctx, base);
	// 822F1740: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1748: 409A000C  bne cr6, 0x822f1754
	if !ctx.cr[6].eq {
	pc = 0x822F1754; continue 'dispatch;
	}
	// 822F174C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 822F1750: 4800002C  b 0x822f177c
	pc = 0x822F177C; continue 'dispatch;
            }
            0x822F1754 => {
    //   block [0x822F1754..0x822F176C)
	// 822F1754: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1758: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F175C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F1760: 419A000C  beq cr6, 0x822f176c
	if ctx.cr[6].eq {
	pc = 0x822F176C; continue 'dispatch;
	}
	// 822F1764: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 822F1768: 48000014  b 0x822f177c
	pc = 0x822F177C; continue 'dispatch;
            }
            0x822F176C => {
    //   block [0x822F176C..0x822F177C)
	// 822F176C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1770: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F1774: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F1778: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F177C; continue 'dispatch;
            }
            0x822F177C => {
    //   block [0x822F177C..0x822F17BC)
	// 822F177C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F1780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1784: 419A021C  beq cr6, 0x822f19a0
	if ctx.cr[6].eq {
	pc = 0x822F19A0; continue 'dispatch;
	}
	// 822F1788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F178C: 4BF3BC5D  bl 0x8222d3e8
	ctx.lr = 0x822F1790;
	sub_8222D3E8(ctx, base);
	// 822F1790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F1794: 397F007F  addi r11, r31, 0x7f
	ctx.r[11].s64 = ctx.r[31].s64 + 127;
	// 822F1798: 395F0280  addi r10, r31, 0x280
	ctx.r[10].s64 = ctx.r[31].s64 + 640;
	// 822F179C: 55690030  rlwinm r9, r11, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822F17A0: 554B0030  rlwinm r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822F17A4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 822F17A8: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822F17AC: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822F17B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822F17B4: 419A0008  beq cr6, 0x822f17bc
	if ctx.cr[6].eq {
	pc = 0x822F17BC; continue 'dispatch;
	}
	// 822F17B8: 7C00FA2C  dcbt 0, r31
	pc = 0x822F17BC; continue 'dispatch;
            }
            0x822F17BC => {
    //   block [0x822F17BC..0x822F17C8)
	// 822F17BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822F17C0: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 822F17C4: 41980084  blt cr6, 0x822f1848
	if ctx.cr[6].lt {
	pc = 0x822F1848; continue 'dispatch;
	}
	pc = 0x822F17C8; continue 'dispatch;
            }
            0x822F17C8 => {
    //   block [0x822F17C8..0x822F1848)
	// 822F17C8: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 822F17CC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F17D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F17D4: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 822F17D8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F17DC: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 822F17E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F17E4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F17E8: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 822F17EC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F17F0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F17F4: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 822F17F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F17FC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F1800: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 822F1804: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F1808: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F180C: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 822F1810: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F1814: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F1818: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 822F181C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F1820: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F1824: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F1828: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 822F182C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F1830: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 822F1834: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 822F1838: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822F183C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822F1840: 4098FF88  bge cr6, 0x822f17c8
	if !ctx.cr[6].lt {
	pc = 0x822F17C8; continue 'dispatch;
	}
	// 822F1844: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x822F1848; continue 'dispatch;
            }
            0x822F1848 => {
    //   block [0x822F1848..0x822F188C)
	// 822F1848: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 822F184C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822F1850: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 822F1854: 4199008C  bgt cr6, 0x822f18e0
	if ctx.cr[6].gt {
	pc = 0x822F18E0; continue 'dispatch;
	}
	// 822F1858: 3D80822F  lis r12, -0x7dd1
	ctx.r[12].s64 = -2110849024;
	// 822F185C: 398C1870  addi r12, r12, 0x1870
	ctx.r[12].s64 = ctx.r[12].s64 + 6256;
	// 822F1860: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 822F1864: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 822F1868: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 822F186C: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x822F18D4; continue 'dispatch;
		},
		1 => {
	pc = 0x822F18C8; continue 'dispatch;
		},
		2 => {
	pc = 0x822F18BC; continue 'dispatch;
		},
		3 => {
	pc = 0x822F18B0; continue 'dispatch;
		},
		4 => {
	pc = 0x822F18A4; continue 'dispatch;
		},
		5 => {
	pc = 0x822F1898; continue 'dispatch;
		},
		6 => {
	pc = 0x822F188C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 822F1870: 822F18D4  lwz r17, 0x18d4(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(6356 as u32) ) } as u64;
	// 822F1874: 822F18C8  lwz r17, 0x18c8(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(6344 as u32) ) } as u64;
	// 822F1878: 822F18BC  lwz r17, 0x18bc(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(6332 as u32) ) } as u64;
	// 822F187C: 822F18B0  lwz r17, 0x18b0(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(6320 as u32) ) } as u64;
	// 822F1880: 822F18A4  lwz r17, 0x18a4(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(6308 as u32) ) } as u64;
	// 822F1884: 822F1898  lwz r17, 0x1898(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(6296 as u32) ) } as u64;
	// 822F1888: 822F188C  lwz r17, 0x188c(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(6284 as u32) ) } as u64;
            }
            0x822F188C => {
    //   block [0x822F188C..0x822F1898)
	// 822F188C: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 822F1890: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F1894: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F1898; continue 'dispatch;
            }
            0x822F1898 => {
    //   block [0x822F1898..0x822F18A4)
	// 822F1898: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 822F189C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F18A0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F18A4; continue 'dispatch;
            }
            0x822F18A4 => {
    //   block [0x822F18A4..0x822F18B0)
	// 822F18A4: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 822F18A8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F18AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F18B0; continue 'dispatch;
            }
            0x822F18B0 => {
    //   block [0x822F18B0..0x822F18BC)
	// 822F18B0: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 822F18B4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F18B8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F18BC; continue 'dispatch;
            }
            0x822F18BC => {
    //   block [0x822F18BC..0x822F18C8)
	// 822F18BC: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 822F18C0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F18C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F18C8; continue 'dispatch;
            }
            0x822F18C8 => {
    //   block [0x822F18C8..0x822F18D4)
	// 822F18C8: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 822F18CC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F18D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F18D4; continue 'dispatch;
            }
            0x822F18D4 => {
    //   block [0x822F18D4..0x822F18E0)
	// 822F18D4: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 822F18D8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F18DC: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x822F18E0; continue 'dispatch;
            }
            0x822F18E0 => {
    //   block [0x822F18E0..0x822F1918)
	// 822F18E0: A17D0008  lhz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F18E4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822F18E8: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822F18EC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 822F18F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F18F4: 7CBF5214  add r5, r31, r10
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 822F18F8: 419A0060  beq cr6, 0x822f1958
	if ctx.cr[6].eq {
	pc = 0x822F1958; continue 'dispatch;
	}
	// 822F18FC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822F1900: 395F01C4  addi r10, r31, 0x1c4
	ctx.r[10].s64 = ctx.r[31].s64 + 452;
	// 822F1904: 392B45C8  addi r9, r11, 0x45c8
	ctx.r[9].s64 = ctx.r[11].s64 + 17864;
	// 822F1908: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F190C: 390BC798  addi r8, r11, -0x3868
	ctx.r[8].s64 = ctx.r[11].s64 + -14440;
	// 822F1910: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F1914: 38EBC694  addi r7, r11, -0x396c
	ctx.r[7].s64 = ctx.r[11].s64 + -14700;
	pc = 0x822F1918; continue 'dispatch;
            }
            0x822F1918 => {
    //   block [0x822F1918..0x822F1944)
	// 822F1918: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 822F191C: 38A50010  addi r5, r5, 0x10
	ctx.r[5].s64 = ctx.r[5].s64 + 16;
	// 822F1920: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F1924: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F1928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F192C: 419A0018  beq cr6, 0x822f1944
	if ctx.cr[6].eq {
	pc = 0x822F1944; continue 'dispatch;
	}
	// 822F1930: B3CB0006  sth r30, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[30].u16 ) };
	// 822F1934: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822F1938: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 822F193C: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 822F1940: 938B000C  stw r28, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	pc = 0x822F1944; continue 'dispatch;
            }
            0x822F1944 => {
    //   block [0x822F1944..0x822F1958)
	// 822F1944: A17D0008  lhz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1948: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 822F194C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822F1950: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822F1954: 4198FFC4  blt cr6, 0x822f1918
	if ctx.cr[6].lt {
	pc = 0x822F1918; continue 'dispatch;
	}
	pc = 0x822F1958; continue 'dispatch;
            }
            0x822F1958 => {
    //   block [0x822F1958..0x822F19A0)
	// 822F1958: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822F195C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822F1960: A15D0008  lhz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1964: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822F1968: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 822F196C: 933F0010  stw r25, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[25].u32 ) };
	// 822F1970: 931F00A4  stw r24, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[24].u32 ) };
	// 822F1974: 917F009C  stw r11, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 822F1978: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822F197C: 92FF00A0  stw r23, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[23].u32 ) };
	// 822F1980: 92DF00A8  stw r22, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[22].u32 ) };
	// 822F1984: 48000375  bl 0x822f1cf8
	ctx.lr = 0x822F1988;
	sub_822F1CF8(ctx, base);
	// 822F1988: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F198C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822F1990: 409A0014  bne cr6, 0x822f19a4
	if !ctx.cr[6].eq {
	pc = 0x822F19A4; continue 'dispatch;
	}
	// 822F1994: 93DF0130  stw r30, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[30].u32 ) };
	// 822F1998: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822F199C: 48243754  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x822F19A0 => {
    //   block [0x822F19A0..0x822F19A4)
	// 822F19A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	pc = 0x822F19A4; continue 'dispatch;
            }
            0x822F19A4 => {
    //   block [0x822F19A4..0x822F19AC)
	// 822F19A4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822F19A8: 48243748  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F19B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F19B0 size=684
    let mut pc: u32 = 0x822F19B0;
    'dispatch: loop {
        match pc {
            0x822F19B0 => {
    //   block [0x822F19B0..0x822F19F0)
	// 822F19B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F19B4: 482436F9  bl 0x825350ac
	ctx.lr = 0x822F19B8;
	sub_82535080(ctx, base);
	// 822F19B8: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 822F19BC: 4824462D  bl 0x82535fe8
	ctx.lr = 0x822F19C0;
	sub_82535FB0(ctx, base);
	// 822F19C0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F19C4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 822F19C8: 38680080  addi r3, r8, 0x80
	ctx.r[3].s64 = ctx.r[8].s64 + 128;
	// 822F19CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F19D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F19D4: 419A002C  beq cr6, 0x822f1a00
	if ctx.cr[6].eq {
	pc = 0x822F1A00; continue 'dispatch;
	}
	// 822F19D8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F19DC: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F19E0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F19E4: 419A000C  beq cr6, 0x822f19f0
	if ctx.cr[6].eq {
	pc = 0x822F19F0; continue 'dispatch;
	}
	// 822F19E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F19EC: 48000014  b 0x822f1a00
	pc = 0x822F1A00; continue 'dispatch;
            }
            0x822F19F0 => {
    //   block [0x822F19F0..0x822F1A00)
	// 822F19F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F19F4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F19F8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F19FC: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F1A00; continue 'dispatch;
            }
            0x822F1A00 => {
    //   block [0x822F1A00..0x822F1A3C)
	// 822F1A00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F1A04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1A08: 419A0244  beq cr6, 0x822f1c4c
	if ctx.cr[6].eq {
	pc = 0x822F1C4C; continue 'dispatch;
	}
	// 822F1A0C: 4BF3B9DD  bl 0x8222d3e8
	ctx.lr = 0x822F1A10;
	sub_8222D3E8(ctx, base);
	// 822F1A10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F1A14: 817E0134  lwz r11, 0x134(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(308 as u32) ) } as u64;
	// 822F1A18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1A1C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822F1A20: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822F1A24: 419A0038  beq cr6, 0x822f1a5c
	if ctx.cr[6].eq {
	pc = 0x822F1A5C; continue 'dispatch;
	}
	// 822F1A28: C01E0138  lfs f0, 0x138(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F1A2C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822F1A30: 4098000C  bge cr6, 0x822f1a3c
	if !ctx.cr[6].lt {
	pc = 0x822F1A3C; continue 'dispatch;
	}
	// 822F1A34: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 822F1A38: D01E0138  stfs f0, 0x138(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(312 as u32), tmp.u32 ) };
	pc = 0x822F1A3C; continue 'dispatch;
            }
            0x822F1A3C => {
    //   block [0x822F1A3C..0x822F1A5C)
	// 822F1A3C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822F1A40: C1BE0138  lfs f13, 0x138(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(312 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F1A44: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 822F1A48: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 822F1A4C: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 822F1A50: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F1A54: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 822F1A58: D01E0138  stfs f0, 0x138(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(312 as u32), tmp.u32 ) };
	pc = 0x822F1A5C; continue 'dispatch;
            }
            0x822F1A5C => {
    //   block [0x822F1A5C..0x822F1A84)
	// 822F1A5C: C1BE00AC  lfs f13, 0xac(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F1A60: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 822F1A64: C01E0138  lfs f0, 0x138(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F1A68: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822F1A6C: 40990018  ble cr6, 0x822f1a84
	if !ctx.cr[6].gt {
	pc = 0x822F1A84; continue 'dispatch;
	}
	// 822F1A70: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822F1A74: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F1A78: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F1A7C: EC0DF83C  fnmsubs f0, f13, f0, f31
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 822F1A80: D01E0094  stfs f0, 0x94(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), tmp.u32 ) };
	pc = 0x822F1A84; continue 'dispatch;
            }
            0x822F1A84 => {
    //   block [0x822F1A84..0x822F1AA0)
	// 822F1A84: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F1A88: C01E0094  lfs f0, 0x94(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F1A8C: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 822F1A90: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F1A94: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822F1A98: 40980008  bge cr6, 0x822f1aa0
	if !ctx.cr[6].lt {
	pc = 0x822F1AA0; continue 'dispatch;
	}
	// 822F1A9C: 933E0130  stw r25, 0x130(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(304 as u32), ctx.r[25].u32 ) };
	pc = 0x822F1AA0; continue 'dispatch;
            }
            0x822F1AA0 => {
    //   block [0x822F1AA0..0x822F1AD8)
	// 822F1AA0: 817E0130  lwz r11, 0x130(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(304 as u32) ) } as u64;
	// 822F1AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1AA8: 419A0030  beq cr6, 0x822f1ad8
	if ctx.cr[6].eq {
	pc = 0x822F1AD8; continue 'dispatch;
	}
	// 822F1AAC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 822F1AB0: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 822F1AB4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822F1AB8: 409A0194  bne cr6, 0x822f1c4c
	if !ctx.cr[6].eq {
	pc = 0x822F1C4C; continue 'dispatch;
	}
	// 822F1ABC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 822F1AC0: 9B280025  stb r25, 0x25(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(37 as u32), ctx.r[25].u8 ) };
	// 822F1AC4: 99680019  stb r11, 0x19(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 822F1AC8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822F1ACC: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 822F1AD0: 48244565  bl 0x82536034
	ctx.lr = 0x822F1AD4;
	sub_82535FFC(ctx, base);
	// 822F1AD4: 48243628  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x822F1AD8 => {
    //   block [0x822F1AD8..0x822F1B08)
	// 822F1AD8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F1ADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1AE0: 419A0028  beq cr6, 0x822f1b08
	if ctx.cr[6].eq {
	pc = 0x822F1B08; continue 'dispatch;
	}
	// 822F1AE4: FC000050  fneg f0, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 822F1AE8: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822F1AEC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F1AF0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822F1AF4: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F1AF8: C00A2074  lfs f0, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F1AFC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822F1B00: 409A0008  bne cr6, 0x822f1b08
	if !ctx.cr[6].eq {
	pc = 0x822F1B08; continue 'dispatch;
	}
	// 822F1B04: D3EB0000  stfs f31, 0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x822F1B08; continue 'dispatch;
            }
            0x822F1B08 => {
    //   block [0x822F1B08..0x822F1B20)
	// 822F1B08: 80DE0008  lwz r6, 8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1B0C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 822F1B10: 4099003C  ble cr6, 0x822f1b4c
	if !ctx.cr[6].gt {
	pc = 0x822F1B4C; continue 'dispatch;
	}
	// 822F1B14: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822F1B18: 391E0014  addi r8, r30, 0x14
	ctx.r[8].s64 = ctx.r[30].s64 + 20;
	// 822F1B1C: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	pc = 0x822F1B20; continue 'dispatch;
            }
            0x822F1B20 => {
    //   block [0x822F1B20..0x822F1B38)
	// 822F1B20: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1B24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F1B28: 419A0010  beq cr6, 0x822f1b38
	if ctx.cr[6].eq {
	pc = 0x822F1B38; continue 'dispatch;
	}
	// 822F1B2C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F1B30: 7C8B4A14  add r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822F1B34: 4809C15D  bl 0x8238dc90
	ctx.lr = 0x822F1B38;
	sub_8238DC90(ctx, base);
	pc = 0x822F1B38; continue 'dispatch;
            }
            0x822F1B38 => {
    //   block [0x822F1B38..0x822F1B4C)
	// 822F1B38: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 822F1B3C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 822F1B40: 39290040  addi r9, r9, 0x40
	ctx.r[9].s64 = ctx.r[9].s64 + 64;
	// 822F1B44: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822F1B48: 409AFFD8  bne cr6, 0x822f1b20
	if !ctx.cr[6].eq {
	pc = 0x822F1B20; continue 'dispatch;
	}
	pc = 0x822F1B4C; continue 'dispatch;
            }
            0x822F1B4C => {
    //   block [0x822F1B4C..0x822F1B90)
	// 822F1B4C: 4BEC5DBD  bl 0x821b7908
	ctx.lr = 0x822F1B50;
	sub_821B7908(ctx, base);
	// 822F1B50: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 822F1B54: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F1B58: C00B2190  lfs f0, 0x2190(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F1B5C: FF1C0000  fcmpu cr6, f28, f0
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[0].f64);
	// 822F1B60: 419A00EC  beq cr6, 0x822f1c4c
	if ctx.cr[6].eq {
	pc = 0x822F1C4C; continue 'dispatch;
	}
	// 822F1B64: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 822F1B68: 409900E4  ble cr6, 0x822f1c4c
	if !ctx.cr[6].gt {
	pc = 0x822F1C4C; continue 'dispatch;
	}
	// 822F1B6C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822F1B70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F1B74: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822F1B78: 3BFE0014  addi r31, r30, 0x14
	ctx.r[31].s64 = ctx.r[30].s64 + 20;
	// 822F1B7C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822F1B80: C3AABFFC  lfs f29, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822F1B84: 3F40829F  lis r26, -0x7d61
	ctx.r[26].s64 = -2103508992;
	// 822F1B88: C3CB206C  lfs f30, 0x206c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8300 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822F1B8C: 3F608288  lis r27, -0x7d78
	ctx.r[27].s64 = -2105016320;
	pc = 0x822F1B90; continue 'dispatch;
            }
            0x822F1B90 => {
    //   block [0x822F1B90..0x822F1C24)
	// 822F1B90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1B94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1B98: 419A00A0  beq cr6, 0x822f1c38
	if ctx.cr[6].eq {
	pc = 0x822F1C38; continue 'dispatch;
	}
	// 822F1B9C: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 822F1BA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1BA4: 409A0094  bne cr6, 0x822f1c38
	if !ctx.cr[6].eq {
	pc = 0x822F1C38; continue 'dispatch;
	}
	// 822F1BA8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F1BAC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 822F1BB0: C00B0030  lfs f0, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F1BB4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822F1BB8: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F1BBC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822F1BC0: FF1C0000  fcmpu cr6, f28, f0
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[0].f64);
	// 822F1BC4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F1BC8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822F1BCC: 4099006C  ble cr6, 0x822f1c38
	if !ctx.cr[6].gt {
	pc = 0x822F1C38; continue 'dispatch;
	}
	// 822F1BD0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1BD4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822F1BD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1BDC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F1BE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F1BE4: 4E800421  bctrl
	ctx.lr = 0x822F1BE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F1BE8: 48241629  bl 0x82533210
	ctx.lr = 0x822F1BEC;
	sub_82533210(ctx, base);
	// 822F1BEC: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 822F1BF0: 807AB514  lwz r3, -0x4aec(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19180 as u32) ) } as u64;
	// 822F1BF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F1BF8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822F1BFC: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822F1C00: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822F1C04: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822F1C08: EC00FFBA  fmadds f0, f0, f30, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64);
	// 822F1C0C: EDA0E828  fsubs f13, f0, f29
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 822F1C10: C01BD560  lfs f0, -0x2aa0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F1C14: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F1C18: 419A000C  beq cr6, 0x822f1c24
	if ctx.cr[6].eq {
	pc = 0x822F1C24; continue 'dispatch;
	}
	// 822F1C1C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822F1C20: 4802F339  bl 0x82320f58
	ctx.lr = 0x822F1C24;
	sub_82320F58(ctx, base);
            }
            0x822F1C24 => {
    //   block [0x822F1C24..0x822F1C38)
	// 822F1C24: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822F1C28: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822F1C2C: 38600009  li r3, 9
	ctx.r[3].s64 = 9;
	// 822F1C30: 48070A51  bl 0x82362680
	ctx.lr = 0x822F1C34;
	sub_82362680(ctx, base);
	// 822F1C34: 933F009C  stw r25, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[25].u32 ) };
	pc = 0x822F1C38; continue 'dispatch;
            }
            0x822F1C38 => {
    //   block [0x822F1C38..0x822F1C4C)
	// 822F1C38: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 822F1C3C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822F1C40: 3BBD0040  addi r29, r29, 0x40
	ctx.r[29].s64 = ctx.r[29].s64 + 64;
	// 822F1C44: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 822F1C48: 409AFF48  bne cr6, 0x822f1b90
	if !ctx.cr[6].eq {
	pc = 0x822F1B90; continue 'dispatch;
	}
	pc = 0x822F1C4C; continue 'dispatch;
            }
            0x822F1C4C => {
    //   block [0x822F1C4C..0x822F1C5C)
	// 822F1C4C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822F1C50: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 822F1C54: 482443E1  bl 0x82536034
	ctx.lr = 0x822F1C58;
	sub_82535FFC(ctx, base);
	// 822F1C58: 482434A4  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F1C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F1C60 size=152
    let mut pc: u32 = 0x822F1C60;
    'dispatch: loop {
        match pc {
            0x822F1C60 => {
    //   block [0x822F1C60..0x822F1C90)
	// 822F1C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F1C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F1C68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F1C6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F1C70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F1C74: 3BE30080  addi r31, r3, 0x80
	ctx.r[31].s64 = ctx.r[3].s64 + 128;
	// 822F1C78: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F1C7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1C80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1C84: 409A000C  bne cr6, 0x822f1c90
	if !ctx.cr[6].eq {
	pc = 0x822F1C90; continue 'dispatch;
	}
	// 822F1C88: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822F1C8C: 4800002C  b 0x822f1cb8
	pc = 0x822F1CB8; continue 'dispatch;
            }
            0x822F1C90 => {
    //   block [0x822F1C90..0x822F1CA8)
	// 822F1C90: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1C94: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1C98: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F1C9C: 419A000C  beq cr6, 0x822f1ca8
	if ctx.cr[6].eq {
	pc = 0x822F1CA8; continue 'dispatch;
	}
	// 822F1CA0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822F1CA4: 48000014  b 0x822f1cb8
	pc = 0x822F1CB8; continue 'dispatch;
            }
            0x822F1CA8 => {
    //   block [0x822F1CA8..0x822F1CB8)
	// 822F1CA8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1CAC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F1CB0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F1CB4: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F1CB8; continue 'dispatch;
            }
            0x822F1CB8 => {
    //   block [0x822F1CB8..0x822F1CE0)
	// 822F1CB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F1CBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1CC0: 419A0020  beq cr6, 0x822f1ce0
	if ctx.cr[6].eq {
	pc = 0x822F1CE0; continue 'dispatch;
	}
	// 822F1CC4: 4800027D  bl 0x822f1f40
	ctx.lr = 0x822F1CC8;
	sub_822F1F40(ctx, base);
	// 822F1CC8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822F1CCC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F1CD0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822F1CD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F1CD8: 419A0008  beq cr6, 0x822f1ce0
	if ctx.cr[6].eq {
	pc = 0x822F1CE0; continue 'dispatch;
	}
	// 822F1CDC: 4BE2B37D  bl 0x8211d058
	ctx.lr = 0x822F1CE0;
	sub_8211D058(ctx, base);
	pc = 0x822F1CE0; continue 'dispatch;
            }
            0x822F1CE0 => {
    //   block [0x822F1CE0..0x822F1CF8)
	// 822F1CE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F1CE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F1CE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F1CEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F1CF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F1CF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F1CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F1CF8 size=584
    let mut pc: u32 = 0x822F1CF8;
    'dispatch: loop {
        match pc {
            0x822F1CF8 => {
    //   block [0x822F1CF8..0x822F1D3C)
	// 822F1CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F1CFC: 482433AD  bl 0x825350a8
	ctx.lr = 0x822F1D00;
	sub_82535080(ctx, base);
	// 822F1D00: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 822F1D04: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F1D08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F1D0C: 4BFFB425  bl 0x822ed130
	ctx.lr = 0x822F1D10;
	sub_822ED130(ctx, base);
	// 822F1D10: 395F0080  addi r10, r31, 0x80
	ctx.r[10].s64 = ctx.r[31].s64 + 128;
	// 822F1D14: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 822F1D18: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1D1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1D20: 419A002C  beq cr6, 0x822f1d4c
	if ctx.cr[6].eq {
	pc = 0x822F1D4C; continue 'dispatch;
	}
	// 822F1D24: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1D28: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1D2C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822F1D30: 419A000C  beq cr6, 0x822f1d3c
	if ctx.cr[6].eq {
	pc = 0x822F1D3C; continue 'dispatch;
	}
	// 822F1D34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F1D38: 48000014  b 0x822f1d4c
	pc = 0x822F1D4C; continue 'dispatch;
            }
            0x822F1D3C => {
    //   block [0x822F1D3C..0x822F1D4C)
	// 822F1D3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1D40: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F1D44: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F1D48: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F1D4C; continue 'dispatch;
            }
            0x822F1D4C => {
    //   block [0x822F1D4C..0x822F1D68)
	// 822F1D4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F1D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1D54: 409A0014  bne cr6, 0x822f1d68
	if !ctx.cr[6].eq {
	pc = 0x822F1D68; continue 'dispatch;
	}
	// 822F1D58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822F1D5C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822F1D60: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 822F1D64: 48243394  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x822F1D68 => {
    //   block [0x822F1D68..0x822F1DAC)
	// 822F1D68: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 822F1D6C: 4BF3B67D  bl 0x8222d3e8
	ctx.lr = 0x822F1D70;
	sub_8222D3E8(ctx, base);
	// 822F1D70: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F1D74: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 822F1D78: 817D00A4  lwz r11, 0xa4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(164 as u32) ) } as u64;
	// 822F1D7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F1D80: 419A002C  beq cr6, 0x822f1dac
	if ctx.cr[6].eq {
	pc = 0x822F1DAC; continue 'dispatch;
	}
	// 822F1D84: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822F1D88: 419A0024  beq cr6, 0x822f1dac
	if ctx.cr[6].eq {
	pc = 0x822F1DAC; continue 'dispatch;
	}
	// 822F1D8C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822F1D90: 419A001C  beq cr6, 0x822f1dac
	if ctx.cr[6].eq {
	pc = 0x822F1DAC; continue 'dispatch;
	}
	// 822F1D94: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 822F1D98: 419A0014  beq cr6, 0x822f1dac
	if ctx.cr[6].eq {
	pc = 0x822F1DAC; continue 'dispatch;
	}
	// 822F1D9C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 822F1DA0: 419A000C  beq cr6, 0x822f1dac
	if ctx.cr[6].eq {
	pc = 0x822F1DAC; continue 'dispatch;
	}
	// 822F1DA4: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 822F1DA8: 409A0008  bne cr6, 0x822f1db0
	if !ctx.cr[6].eq {
	pc = 0x822F1DB0; continue 'dispatch;
	}
	pc = 0x822F1DAC; continue 'dispatch;
            }
            0x822F1DAC => {
    //   block [0x822F1DAC..0x822F1DB0)
	// 822F1DAC: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	pc = 0x822F1DB0; continue 'dispatch;
            }
            0x822F1DB0 => {
    //   block [0x822F1DB0..0x822F1DF0)
	// 822F1DB0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822F1DB4: 815D00A0  lwz r10, 0xa0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 822F1DB8: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 822F1DBC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 822F1DC0: 3929C570  addi r9, r9, -0x3a90
	ctx.r[9].s64 = ctx.r[9].s64 + -14992;
	// 822F1DC4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822F1DC8: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 822F1DCC: 9341007C  stw r26, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[26].u32 ) };
	// 822F1DD0: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 822F1DD4: 93410080  stw r26, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	// 822F1DD8: 837D0008  lwz r27, 8(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1DDC: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 822F1DE0: 409900C8  ble cr6, 0x822f1ea8
	if !ctx.cr[6].gt {
	pc = 0x822F1EA8; continue 'dispatch;
	}
	// 822F1DE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F1DE8: 3BFD0014  addi r31, r29, 0x14
	ctx.r[31].s64 = ctx.r[29].s64 + 20;
	// 822F1DEC: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x822F1DF0; continue 'dispatch;
            }
            0x822F1DF0 => {
    //   block [0x822F1DF0..0x822F1E58)
	// 822F1DF0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822F1DF4: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 822F1DF8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F1DFC: 4BFFB655  bl 0x822ed450
	ctx.lr = 0x822F1E00;
	sub_822ED450(ctx, base);
	// 822F1E00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F1E04: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F1E08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F1E0C: 4BFFB45D  bl 0x822ed268
	ctx.lr = 0x822F1E10;
	sub_822ED268(ctx, base);
	// 822F1E10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F1E14: 419A0084  beq cr6, 0x822f1e98
	if ctx.cr[6].eq {
	pc = 0x822F1E98; continue 'dispatch;
	}
	// 822F1E18: 4809B1A9  bl 0x8238cfc0
	ctx.lr = 0x822F1E1C;
	sub_8238CFC0(ctx, base);
	// 822F1E1C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 822F1E20: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F1E24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1E28: 419A0070  beq cr6, 0x822f1e98
	if ctx.cr[6].eq {
	pc = 0x822F1E98; continue 'dispatch;
	}
	// 822F1E2C: 386B00D0  addi r3, r11, 0xd0
	ctx.r[3].s64 = ctx.r[11].s64 + 208;
	// 822F1E30: 481A9709  bl 0x8249b538
	ctx.lr = 0x822F1E34;
	sub_8249B538(ctx, base);
	// 822F1E34: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 822F1E38: 40990060  ble cr6, 0x822f1e98
	if !ctx.cr[6].gt {
	pc = 0x822F1E98; continue 'dispatch;
	}
	// 822F1E3C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 822F1E40: 419A0058  beq cr6, 0x822f1e98
	if ctx.cr[6].eq {
	pc = 0x822F1E98; continue 'dispatch;
	}
	// 822F1E44: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1E48: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F1E4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1E50: 419A0008  beq cr6, 0x822f1e58
	if ctx.cr[6].eq {
	pc = 0x822F1E58; continue 'dispatch;
	}
	// 822F1E54: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	pc = 0x822F1E58; continue 'dispatch;
            }
            0x822F1E58 => {
    //   block [0x822F1E58..0x822F1E68)
	// 822F1E58: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1E60: 419A0008  beq cr6, 0x822f1e68
	if ctx.cr[6].eq {
	pc = 0x822F1E68; continue 'dispatch;
	}
	// 822F1E64: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x822F1E68; continue 'dispatch;
            }
            0x822F1E68 => {
    //   block [0x822F1E68..0x822F1E8C)
	// 822F1E68: 817F01B0  lwz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 822F1E6C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F1E70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F1E74: 409A0018  bne cr6, 0x822f1e8c
	if !ctx.cr[6].eq {
	pc = 0x822F1E8C; continue 'dispatch;
	}
	// 822F1E78: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1E7C: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 822F1E80: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822F1E84: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F1E88: 4819C831  bl 0x8248e6b8
	ctx.lr = 0x822F1E8C;
	sub_8248E6B8(ctx, base);
	pc = 0x822F1E8C; continue 'dispatch;
            }
            0x822F1E8C => {
    //   block [0x822F1E8C..0x822F1E98)
	// 822F1E8C: 817D01C0  lwz r11, 0x1c0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(448 as u32) ) } as u64;
	// 822F1E90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822F1E94: 917D01C0  stw r11, 0x1c0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	pc = 0x822F1E98; continue 'dispatch;
            }
            0x822F1E98 => {
    //   block [0x822F1E98..0x822F1EA8)
	// 822F1E98: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822F1E9C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822F1EA0: 7F1CD800  cmpw cr6, r28, r27
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[27].s32, &mut ctx.xer);
	// 822F1EA4: 4198FF4C  blt cr6, 0x822f1df0
	if ctx.cr[6].lt {
	pc = 0x822F1DF0; continue 'dispatch;
	}
	pc = 0x822F1EA8; continue 'dispatch;
            }
            0x822F1EA8 => {
    //   block [0x822F1EA8..0x822F1EF4)
	// 822F1EA8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822F1EAC: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 822F1EB0: 813D00A4  lwz r9, 0xa4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(164 as u32) ) } as u64;
	// 822F1EB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822F1EB8: 394AC588  addi r10, r10, -0x3a78
	ctx.r[10].s64 = ctx.r[10].s64 + -14968;
	// 822F1EBC: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 822F1EC0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F1EC4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 822F1EC8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 822F1ECC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822F1ED0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822F1ED4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822F1ED8: 4BFFB6B9  bl 0x822ed590
	ctx.lr = 0x822F1EDC;
	sub_822ED590(ctx, base);
	// 822F1EDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F1EE0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F1EE4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822F1EE8: 93DD013C  stw r30, 0x13c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(316 as u32), ctx.r[30].u32 ) };
	// 822F1EEC: 40990044  ble cr6, 0x822f1f30
	if !ctx.cr[6].gt {
	pc = 0x822F1F30; continue 'dispatch;
	}
	// 822F1EF0: 3BBD0140  addi r29, r29, 0x140
	ctx.r[29].s64 = ctx.r[29].s64 + 320;
	pc = 0x822F1EF4; continue 'dispatch;
            }
            0x822F1EF4 => {
    //   block [0x822F1EF4..0x822F1F20)
	// 822F1EF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822F1EF8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 822F1EFC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F1F00: 4BFFB551  bl 0x822ed450
	ctx.lr = 0x822F1F04;
	sub_822ED450(ctx, base);
	// 822F1F04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F1F08: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F1F0C: 4BFFB35D  bl 0x822ed268
	ctx.lr = 0x822F1F10;
	sub_822ED268(ctx, base);
	// 822F1F10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F1F14: 419A000C  beq cr6, 0x822f1f20
	if ctx.cr[6].eq {
	pc = 0x822F1F20; continue 'dispatch;
	}
	// 822F1F18: 4809B0A9  bl 0x8238cfc0
	ctx.lr = 0x822F1F1C;
	sub_8238CFC0(ctx, base);
	// 822F1F1C: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x822F1F20; continue 'dispatch;
            }
            0x822F1F20 => {
    //   block [0x822F1F20..0x822F1F30)
	// 822F1F20: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822F1F24: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822F1F28: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822F1F2C: 4198FFC8  blt cr6, 0x822f1ef4
	if ctx.cr[6].lt {
	pc = 0x822F1EF4; continue 'dispatch;
	}
	pc = 0x822F1F30; continue 'dispatch;
            }
            0x822F1F30 => {
    //   block [0x822F1F30..0x822F1F40)
	// 822F1F30: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822F1F34: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822F1F38: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 822F1F3C: 482431BC  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F1F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F1F40 size=432
    let mut pc: u32 = 0x822F1F40;
    'dispatch: loop {
        match pc {
            0x822F1F40 => {
    //   block [0x822F1F40..0x822F1F74)
	// 822F1F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F1F44: 48243169  bl 0x825350ac
	ctx.lr = 0x822F1F48;
	sub_82535080(ctx, base);
	// 822F1F48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F1F4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F1F50: 4BFFB1E1  bl 0x822ed130
	ctx.lr = 0x822F1F54;
	sub_822ED130(ctx, base);
	// 822F1F54: 395F0080  addi r10, r31, 0x80
	ctx.r[10].s64 = ctx.r[31].s64 + 128;
	// 822F1F58: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 822F1F5C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822F1F60: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1F64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1F68: 409A000C  bne cr6, 0x822f1f74
	if !ctx.cr[6].eq {
	pc = 0x822F1F74; continue 'dispatch;
	}
	// 822F1F6C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 822F1F70: 4800002C  b 0x822f1f9c
	pc = 0x822F1F9C; continue 'dispatch;
            }
            0x822F1F74 => {
    //   block [0x822F1F74..0x822F1F8C)
	// 822F1F74: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1F78: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F1F7C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822F1F80: 419A000C  beq cr6, 0x822f1f8c
	if ctx.cr[6].eq {
	pc = 0x822F1F8C; continue 'dispatch;
	}
	// 822F1F84: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 822F1F88: 48000014  b 0x822f1f9c
	pc = 0x822F1F9C; continue 'dispatch;
            }
            0x822F1F8C => {
    //   block [0x822F1F8C..0x822F1F9C)
	// 822F1F8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1F90: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F1F94: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F1F98: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F1F9C; continue 'dispatch;
            }
            0x822F1F9C => {
    //   block [0x822F1F9C..0x822F1FB4)
	// 822F1F9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F1FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1FA4: 409A0010  bne cr6, 0x822f1fb4
	if !ctx.cr[6].eq {
	pc = 0x822F1FB4; continue 'dispatch;
	}
	// 822F1FA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822F1FAC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F1FB0: 4824314C  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x822F1FB4 => {
    //   block [0x822F1FB4..0x822F1FD4)
	// 822F1FB4: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 822F1FB8: 4BF3B431  bl 0x8222d3e8
	ctx.lr = 0x822F1FBC;
	sub_8222D3E8(ctx, base);
	// 822F1FBC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822F1FC0: 817B01C0  lwz r11, 0x1c0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(448 as u32) ) } as u64;
	// 822F1FC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F1FC8: 40990048  ble cr6, 0x822f2010
	if !ctx.cr[6].gt {
	pc = 0x822F2010; continue 'dispatch;
	}
	// 822F1FCC: 3BDB01C4  addi r30, r27, 0x1c4
	ctx.r[30].s64 = ctx.r[27].s64 + 452;
	// 822F1FD0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x822F1FD4; continue 'dispatch;
            }
            0x822F1FD4 => {
    //   block [0x822F1FD4..0x822F1FFC)
	// 822F1FD4: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F1FD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F1FDC: 419A0024  beq cr6, 0x822f2000
	if ctx.cr[6].eq {
	pc = 0x822F2000; continue 'dispatch;
	}
	// 822F1FE0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F1FE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F1FE8: 419A0014  beq cr6, 0x822f1ffc
	if ctx.cr[6].eq {
	pc = 0x822F1FFC; continue 'dispatch;
	}
	// 822F1FEC: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 822F1FF0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F1FF4: 4819C175  bl 0x8248e168
	ctx.lr = 0x822F1FF8;
	sub_8248E168(ctx, base);
	// 822F1FF8: 935F000C  stw r26, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	pc = 0x822F1FFC; continue 'dispatch;
            }
            0x822F1FFC => {
    //   block [0x822F1FFC..0x822F2000)
	// 822F1FFC: 935E0000  stw r26, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x822F2000; continue 'dispatch;
            }
            0x822F2000 => {
    //   block [0x822F2000..0x822F2010)
	// 822F2000: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 822F2004: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F2008: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822F200C: 409AFFC8  bne cr6, 0x822f1fd4
	if !ctx.cr[6].eq {
	pc = 0x822F1FD4; continue 'dispatch;
	}
	pc = 0x822F2010; continue 'dispatch;
            }
            0x822F2010 => {
    //   block [0x822F2010..0x822F2028)
	// 822F2010: 817B013C  lwz r11, 0x13c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(316 as u32) ) } as u64;
	// 822F2014: 3FA08273  lis r29, -0x7d8d
	ctx.r[29].s64 = -2106392576;
	// 822F2018: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F201C: 40990060  ble cr6, 0x822f207c
	if !ctx.cr[6].gt {
	pc = 0x822F207C; continue 'dispatch;
	}
	// 822F2020: 3BDB0140  addi r30, r27, 0x140
	ctx.r[30].s64 = ctx.r[27].s64 + 320;
	// 822F2024: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	pc = 0x822F2028; continue 'dispatch;
            }
            0x822F2028 => {
    //   block [0x822F2028..0x822F206C)
	// 822F2028: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F202C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822F2030: 419A003C  beq cr6, 0x822f206c
	if ctx.cr[6].eq {
	pc = 0x822F206C; continue 'dispatch;
	}
	// 822F2034: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F2038: 4BFFBDC1  bl 0x822eddf8
	ctx.lr = 0x822F203C;
	sub_822EDDF8(ctx, base);
	// 822F203C: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2040: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822F2044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F2048: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F204C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F2054: 4E800421  bctrl
	ctx.lr = 0x822F2058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F2058: 817D49B0  lwz r11, 0x49b0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822F205C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F2060: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F2064: 4E800421  bctrl
	ctx.lr = 0x822F2068;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F2068: 935E0000  stw r26, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
            }
            0x822F206C => {
    //   block [0x822F206C..0x822F207C)
	// 822F206C: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 822F2070: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F2074: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 822F2078: 409AFFB0  bne cr6, 0x822f2028
	if !ctx.cr[6].eq {
	pc = 0x822F2028; continue 'dispatch;
	}
	pc = 0x822F207C; continue 'dispatch;
            }
            0x822F207C => {
    //   block [0x822F207C..0x822F2090)
	// 822F207C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2080: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F2084: 40990060  ble cr6, 0x822f20e4
	if !ctx.cr[6].gt {
	pc = 0x822F20E4; continue 'dispatch;
	}
	// 822F2088: 3BDB0014  addi r30, r27, 0x14
	ctx.r[30].s64 = ctx.r[27].s64 + 20;
	// 822F208C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	pc = 0x822F2090; continue 'dispatch;
            }
            0x822F2090 => {
    //   block [0x822F2090..0x822F20D4)
	// 822F2090: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2094: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822F2098: 419A003C  beq cr6, 0x822f20d4
	if ctx.cr[6].eq {
	pc = 0x822F20D4; continue 'dispatch;
	}
	// 822F209C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F20A0: 4BFFBD59  bl 0x822eddf8
	ctx.lr = 0x822F20A4;
	sub_822EDDF8(ctx, base);
	// 822F20A4: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F20A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822F20AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F20B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F20B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F20B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F20BC: 4E800421  bctrl
	ctx.lr = 0x822F20C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F20C0: 817D49B0  lwz r11, 0x49b0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822F20C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F20C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F20CC: 4E800421  bctrl
	ctx.lr = 0x822F20D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F20D0: 935E0000  stw r26, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
            }
            0x822F20D4 => {
    //   block [0x822F20D4..0x822F20E4)
	// 822F20D4: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 822F20D8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F20DC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 822F20E0: 409AFFB0  bne cr6, 0x822f2090
	if !ctx.cr[6].eq {
	pc = 0x822F2090; continue 'dispatch;
	}
	pc = 0x822F20E4; continue 'dispatch;
            }
            0x822F20E4 => {
    //   block [0x822F20E4..0x822F20F0)
	// 822F20E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822F20E8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F20EC: 48243010  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F20F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F20F0 size=2564
    let mut pc: u32 = 0x822F20F0;
    'dispatch: loop {
        match pc {
            0x822F20F0 => {
    //   block [0x822F20F0..0x822F2AF4)
	// 822F20F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F20F4: 48242FB1  bl 0x825350a4
	ctx.lr = 0x822F20F8;
	sub_82535080(ctx, base);
	// 822F20F8: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 822F20FC: 48243ED5  bl 0x82535fd0
	ctx.lr = 0x822F2100;
	sub_82535FB0(ctx, base);
	// 822F2100: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F2AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F2AF8 size=364
    let mut pc: u32 = 0x822F2AF8;
    'dispatch: loop {
        match pc {
            0x822F2AF8 => {
    //   block [0x822F2AF8..0x822F2B60)
	// 822F2AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F2AFC: 482425B5  bl 0x825350b0
	ctx.lr = 0x822F2B00;
	sub_82535080(ctx, base);
	// 822F2B00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F2B04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F2B08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F2B0C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822F2B10: 396BC668  addi r11, r11, -0x3998
	ctx.r[11].s64 = ctx.r[11].s64 + -14744;
	// 822F2B14: 3BDD0080  addi r30, r29, 0x80
	ctx.r[30].s64 = ctx.r[29].s64 + 128;
	// 822F2B18: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 822F2B1C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F2B20: 38CAC62C  addi r6, r10, -0x39d4
	ctx.r[6].s64 = ctx.r[10].s64 + -14804;
	// 822F2B24: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 822F2B28: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F2B2C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822F2B30: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822F2B34: 386ADBE0  addi r3, r10, -0x2420
	ctx.r[3].s64 = ctx.r[10].s64 + -9248;
	// 822F2B38: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822F2B3C: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 822F2B40: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822F2B44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F2B48: 4BF027A1  bl 0x821f52e8
	ctx.lr = 0x822F2B4C;
	sub_821F52E8(ctx, base);
	// 822F2B4C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2B50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2B54: 409A000C  bne cr6, 0x822f2b60
	if !ctx.cr[6].eq {
	pc = 0x822F2B60; continue 'dispatch;
	}
	// 822F2B58: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822F2B5C: 4800002C  b 0x822f2b88
	pc = 0x822F2B88; continue 'dispatch;
            }
            0x822F2B60 => {
    //   block [0x822F2B60..0x822F2B78)
	// 822F2B60: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2B64: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2B68: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F2B6C: 419A000C  beq cr6, 0x822f2b78
	if ctx.cr[6].eq {
	pc = 0x822F2B78; continue 'dispatch;
	}
	// 822F2B70: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822F2B74: 48000014  b 0x822f2b88
	pc = 0x822F2B88; continue 'dispatch;
            }
            0x822F2B78 => {
    //   block [0x822F2B78..0x822F2B88)
	// 822F2B78: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2B7C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F2B80: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F2B84: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F2B88; continue 'dispatch;
            }
            0x822F2B88 => {
    //   block [0x822F2B88..0x822F2BF4)
	// 822F2B88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F2B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2B90: 419A00C8  beq cr6, 0x822f2c58
	if ctx.cr[6].eq {
	pc = 0x822F2C58; continue 'dispatch;
	}
	// 822F2B94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F2B98: 4BF3A851  bl 0x8222d3e8
	ctx.lr = 0x822F2B9C;
	sub_8222D3E8(ctx, base);
	// 822F2B9C: 7C001A2C  dcbt 0, r3
	// 822F2BA0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 822F2BA4: 93830034  stw r28, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[28].u32 ) };
	// 822F2BA8: 39630014  addi r11, r3, 0x14
	ctx.r[11].s64 = ctx.r[3].s64 + 20;
	// 822F2BAC: 93630038  stw r27, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[27].u32 ) };
	// 822F2BB0: 394A3B80  addi r10, r10, 0x3b80
	ctx.r[10].s64 = ctx.r[10].s64 + 15232;
	// 822F2BB4: 93430050  stw r26, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 822F2BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2BBC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F2BC0: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822F2BC4: B3E30008  sth r31, 8(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u16 ) };
	// 822F2BC8: B3E3000A  sth r31, 0xa(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(10 as u32), ctx.r[31].u16 ) };
	// 822F2BCC: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822F2BD0: B3E30010  sth r31, 0x10(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[31].u16 ) };
	// 822F2BD4: B3E30012  sth r31, 0x12(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(18 as u32), ctx.r[31].u16 ) };
	// 822F2BD8: 419A001C  beq cr6, 0x822f2bf4
	if ctx.cr[6].eq {
	pc = 0x822F2BF4; continue 'dispatch;
	}
	// 822F2BDC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822F2BE0: 394AC6A4  addi r10, r10, -0x395c
	ctx.r[10].s64 = ctx.r[10].s64 + -14684;
	// 822F2BE4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F2BE8: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822F2BEC: B3EB0008  sth r31, 8(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u16 ) };
	// 822F2BF0: B3EB000A  sth r31, 0xa(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), ctx.r[31].u16 ) };
	pc = 0x822F2BF4; continue 'dispatch;
            }
            0x822F2BF4 => {
    //   block [0x822F2BF4..0x822F2C14)
	// 822F2BF4: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	// 822F2BF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2BFC: 419A0018  beq cr6, 0x822f2c14
	if ctx.cr[6].eq {
	pc = 0x822F2C14; continue 'dispatch;
	}
	// 822F2C00: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 822F2C04: 394AE088  addi r10, r10, -0x1f78
	ctx.r[10].s64 = ctx.r[10].s64 + -8056;
	// 822F2C08: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F2C0C: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822F2C10: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x822F2C14; continue 'dispatch;
            }
            0x822F2C14 => {
    //   block [0x822F2C14..0x822F2C58)
	// 822F2C14: 3D408287  lis r10, -0x7d79
	ctx.r[10].s64 = -2105081856;
	// 822F2C18: B3E3000A  sth r31, 0xa(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(10 as u32), ctx.r[31].u16 ) };
	// 822F2C1C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 822F2C20: 392A7790  addi r9, r10, 0x7790
	ctx.r[9].s64 = ctx.r[10].s64 + 30608;
	// 822F2C24: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 822F2C28: 396B8E38  addi r11, r11, -0x71c8
	ctx.r[11].s64 = ctx.r[11].s64 + -29128;
	// 822F2C2C: B1430008  sth r10, 8(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u16 ) };
	// 822F2C30: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822F2C34: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 822F2C38: B1430010  sth r10, 0x10(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u16 ) };
	// 822F2C3C: B3E30012  sth r31, 0x12(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(18 as u32), ctx.r[31].u16 ) };
	// 822F2C40: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 822F2C44: B143001C  sth r10, 0x1c(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u16 ) };
	// 822F2C48: B3E3001E  sth r31, 0x1e(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[31].u16 ) };
	// 822F2C4C: 4BFFA4E5  bl 0x822ed130
	ctx.lr = 0x822F2C50;
	sub_822ED130(ctx, base);
	// 822F2C50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F2C54: 4BFFAEED  bl 0x822edb40
	ctx.lr = 0x822F2C58;
	sub_822EDB40(ctx, base);
	pc = 0x822F2C58; continue 'dispatch;
            }
            0x822F2C58 => {
    //   block [0x822F2C58..0x822F2C64)
	// 822F2C58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F2C5C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F2C60: 482424A0  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F2C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F2C68 size=316
    let mut pc: u32 = 0x822F2C68;
    'dispatch: loop {
        match pc {
            0x822F2C68 => {
    //   block [0x822F2C68..0x822F2C8C)
	// 822F2C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F2C6C: 48242445  bl 0x825350b0
	ctx.lr = 0x822F2C70;
	sub_82535080(ctx, base);
	// 822F2C70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F2C74: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 822F2C78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822F2C7C: 817B00CC  lwz r11, 0xcc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(204 as u32) ) } as u64;
	// 822F2C80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2C84: 419A0008  beq cr6, 0x822f2c8c
	if ctx.cr[6].eq {
	pc = 0x822F2C8C; continue 'dispatch;
	}
	// 822F2C88: 480001A1  bl 0x822f2e28
	ctx.lr = 0x822F2C8C;
	sub_822F2E28(ctx, base);
	pc = 0x822F2C8C; continue 'dispatch;
            }
            0x822F2C8C => {
    //   block [0x822F2C8C..0x822F2CC4)
	// 822F2C8C: 817B00E4  lwz r11, 0xe4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(228 as u32) ) } as u64;
	// 822F2C90: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 822F2C94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2C98: 419A009C  beq cr6, 0x822f2d34
	if ctx.cr[6].eq {
	pc = 0x822F2D34; continue 'dispatch;
	}
	// 822F2C9C: 387C0080  addi r3, r28, 0x80
	ctx.r[3].s64 = ctx.r[28].s64 + 128;
	// 822F2CA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2CA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2CA8: 419A002C  beq cr6, 0x822f2cd4
	if ctx.cr[6].eq {
	pc = 0x822F2CD4; continue 'dispatch;
	}
	// 822F2CAC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2CB0: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2CB4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F2CB8: 419A000C  beq cr6, 0x822f2cc4
	if ctx.cr[6].eq {
	pc = 0x822F2CC4; continue 'dispatch;
	}
	// 822F2CBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F2CC0: 48000014  b 0x822f2cd4
	pc = 0x822F2CD4; continue 'dispatch;
            }
            0x822F2CC4 => {
    //   block [0x822F2CC4..0x822F2CD4)
	// 822F2CC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2CC8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F2CCC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F2CD0: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F2CD4; continue 'dispatch;
            }
            0x822F2CD4 => {
    //   block [0x822F2CD4..0x822F2D00)
	// 822F2CD4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F2CD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2CDC: 419A0058  beq cr6, 0x822f2d34
	if ctx.cr[6].eq {
	pc = 0x822F2D34; continue 'dispatch;
	}
	// 822F2CE0: 4BF3A709  bl 0x8222d3e8
	ctx.lr = 0x822F2CE4;
	sub_8222D3E8(ctx, base);
	// 822F2CE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F2CE8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822F2CEC: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F2CF0: 935E003C  stw r26, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[26].u32 ) };
	// 822F2CF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F2CF8: 4099003C  ble cr6, 0x822f2d34
	if !ctx.cr[6].gt {
	pc = 0x822F2D34; continue 'dispatch;
	}
	// 822F2CFC: 3BFE005C  addi r31, r30, 0x5c
	ctx.r[31].s64 = ctx.r[30].s64 + 92;
	pc = 0x822F2D00; continue 'dispatch;
            }
            0x822F2D00 => {
    //   block [0x822F2D00..0x822F2D20)
	// 822F2D00: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2D04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F2D08: 419A0018  beq cr6, 0x822f2d20
	if ctx.cr[6].eq {
	pc = 0x822F2D20; continue 'dispatch;
	}
	// 822F2D0C: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822F2D10: 815FFFFC  lwz r10, -4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822F2D14: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822F2D18: 409A0008  bne cr6, 0x822f2d20
	if !ctx.cr[6].eq {
	pc = 0x822F2D20; continue 'dispatch;
	}
	// 822F2D1C: 4BFFF225  bl 0x822f1f40
	ctx.lr = 0x822F2D20;
	sub_822F1F40(ctx, base);
	pc = 0x822F2D20; continue 'dispatch;
            }
            0x822F2D20 => {
    //   block [0x822F2D20..0x822F2D34)
	// 822F2D20: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F2D24: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822F2D28: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 822F2D2C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F2D30: 4198FFD0  blt cr6, 0x822f2d00
	if ctx.cr[6].lt {
	pc = 0x822F2D00; continue 'dispatch;
	}
	pc = 0x822F2D34; continue 'dispatch;
            }
            0x822F2D34 => {
    //   block [0x822F2D34..0x822F2D68)
	// 822F2D34: 817B00DC  lwz r11, 0xdc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(220 as u32) ) } as u64;
	// 822F2D38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2D3C: 419A0060  beq cr6, 0x822f2d9c
	if ctx.cr[6].eq {
	pc = 0x822F2D9C; continue 'dispatch;
	}
	// 822F2D40: 387C0080  addi r3, r28, 0x80
	ctx.r[3].s64 = ctx.r[28].s64 + 128;
	// 822F2D44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2D48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2D4C: 419A002C  beq cr6, 0x822f2d78
	if ctx.cr[6].eq {
	pc = 0x822F2D78; continue 'dispatch;
	}
	// 822F2D50: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2D54: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2D58: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F2D5C: 419A000C  beq cr6, 0x822f2d68
	if ctx.cr[6].eq {
	pc = 0x822F2D68; continue 'dispatch;
	}
	// 822F2D60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F2D64: 48000014  b 0x822f2d78
	pc = 0x822F2D78; continue 'dispatch;
            }
            0x822F2D68 => {
    //   block [0x822F2D68..0x822F2D78)
	// 822F2D68: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2D6C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F2D70: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F2D74: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F2D78; continue 'dispatch;
            }
            0x822F2D78 => {
    //   block [0x822F2D78..0x822F2D9C)
	// 822F2D78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F2D7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2D80: 419A001C  beq cr6, 0x822f2d9c
	if ctx.cr[6].eq {
	pc = 0x822F2D9C; continue 'dispatch;
	}
	// 822F2D84: 4BF3A665  bl 0x8222d3e8
	ctx.lr = 0x822F2D88;
	sub_8222D3E8(ctx, base);
	// 822F2D88: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2D8C: 81430050  lwz r10, 0x50(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F2D90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822F2D94: 409A0008  bne cr6, 0x822f2d9c
	if !ctx.cr[6].eq {
	pc = 0x822F2D9C; continue 'dispatch;
	}
	// 822F2D98: 93430040  stw r26, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[26].u32 ) };
	pc = 0x822F2D9C; continue 'dispatch;
            }
            0x822F2D9C => {
    //   block [0x822F2D9C..0x822F2DA4)
	// 822F2D9C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F2DA0: 48242360  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F2DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F2DA8 size=124
    let mut pc: u32 = 0x822F2DA8;
    'dispatch: loop {
        match pc {
            0x822F2DA8 => {
    //   block [0x822F2DA8..0x822F2DDC)
	// 822F2DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F2DAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F2DB0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F2DB4: 38630080  addi r3, r3, 0x80
	ctx.r[3].s64 = ctx.r[3].s64 + 128;
	// 822F2DB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2DBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2DC0: 419A002C  beq cr6, 0x822f2dec
	if ctx.cr[6].eq {
	pc = 0x822F2DEC; continue 'dispatch;
	}
	// 822F2DC4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2DC8: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2DCC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F2DD0: 419A000C  beq cr6, 0x822f2ddc
	if ctx.cr[6].eq {
	pc = 0x822F2DDC; continue 'dispatch;
	}
	// 822F2DD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F2DD8: 48000014  b 0x822f2dec
	pc = 0x822F2DEC; continue 'dispatch;
            }
            0x822F2DDC => {
    //   block [0x822F2DDC..0x822F2DEC)
	// 822F2DDC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2DE0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F2DE4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F2DE8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F2DEC; continue 'dispatch;
            }
            0x822F2DEC => {
    //   block [0x822F2DEC..0x822F2E0C)
	// 822F2DEC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F2DF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2DF4: 409A0018  bne cr6, 0x822f2e0c
	if !ctx.cr[6].eq {
	pc = 0x822F2E0C; continue 'dispatch;
	}
	// 822F2DF8: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 822F2DFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F2E00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F2E04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F2E08: 4E800020  blr
	return;
            }
            0x822F2E0C => {
    //   block [0x822F2E0C..0x822F2E24)
	// 822F2E0C: 4BF3A5DD  bl 0x8222d3e8
	ctx.lr = 0x822F2E10;
	sub_8222D3E8(ctx, base);
	// 822F2E10: 80630050  lwz r3, 0x50(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F2E14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F2E18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F2E1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F2E20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F2E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F2E28 size=684
    let mut pc: u32 = 0x822F2E28;
    'dispatch: loop {
        match pc {
            0x822F2E28 => {
    //   block [0x822F2E28..0x822F2E58)
	// 822F2E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F2E2C: 48242281  bl 0x825350ac
	ctx.lr = 0x822F2E30;
	sub_82535080(ctx, base);
	// 822F2E30: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F2E34: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822F2E38: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 822F2E3C: 391A0080  addi r8, r26, 0x80
	ctx.r[8].s64 = ctx.r[26].s64 + 128;
	// 822F2E40: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F2E44: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2E48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2E4C: 409A000C  bne cr6, 0x822f2e58
	if !ctx.cr[6].eq {
	pc = 0x822F2E58; continue 'dispatch;
	}
	// 822F2E50: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822F2E54: 4800002C  b 0x822f2e80
	pc = 0x822F2E80; continue 'dispatch;
            }
            0x822F2E58 => {
    //   block [0x822F2E58..0x822F2E70)
	// 822F2E58: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2E5C: 81280008  lwz r9, 8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2E60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F2E64: 419A000C  beq cr6, 0x822f2e70
	if ctx.cr[6].eq {
	pc = 0x822F2E70; continue 'dispatch;
	}
	// 822F2E68: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822F2E6C: 48000014  b 0x822f2e80
	pc = 0x822F2E80; continue 'dispatch;
            }
            0x822F2E70 => {
    //   block [0x822F2E70..0x822F2E80)
	// 822F2E70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2E74: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F2E78: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F2E7C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F2E80; continue 'dispatch;
            }
            0x822F2E80 => {
    //   block [0x822F2E80..0x822F2EBC)
	// 822F2E80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F2E84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2E88: 419A0244  beq cr6, 0x822f30cc
	if ctx.cr[6].eq {
	pc = 0x822F30CC; continue 'dispatch;
	}
	// 822F2E8C: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 822F2E90: 4BF3A559  bl 0x8222d3e8
	ctx.lr = 0x822F2E94;
	sub_8222D3E8(ctx, base);
	// 822F2E94: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822F2E98: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2E9C: 815C0050  lwz r10, 0x50(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F2EA0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822F2EA4: 409A0228  bne cr6, 0x822f30cc
	if !ctx.cr[6].eq {
	pc = 0x822F30CC; continue 'dispatch;
	}
	// 822F2EA8: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2EB0: 409A000C  bne cr6, 0x822f2ebc
	if !ctx.cr[6].eq {
	pc = 0x822F2EBC; continue 'dispatch;
	}
	// 822F2EB4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822F2EB8: 4800002C  b 0x822f2ee4
	pc = 0x822F2EE4; continue 'dispatch;
            }
            0x822F2EBC => {
    //   block [0x822F2EBC..0x822F2ED4)
	// 822F2EBC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2EC0: 81280008  lwz r9, 8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2EC4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F2EC8: 419A000C  beq cr6, 0x822f2ed4
	if ctx.cr[6].eq {
	pc = 0x822F2ED4; continue 'dispatch;
	}
	// 822F2ECC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822F2ED0: 48000014  b 0x822f2ee4
	pc = 0x822F2EE4; continue 'dispatch;
            }
            0x822F2ED4 => {
    //   block [0x822F2ED4..0x822F2EE4)
	// 822F2ED4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2ED8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F2EDC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F2EE0: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F2EE4; continue 'dispatch;
            }
            0x822F2EE4 => {
    //   block [0x822F2EE4..0x822F2F64)
	// 822F2EE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F2EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F2EEC: 419A01D8  beq cr6, 0x822f30c4
	if ctx.cr[6].eq {
	pc = 0x822F30C4; continue 'dispatch;
	}
	// 822F2EF0: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 822F2EF4: 4BF3A4F5  bl 0x8222d3e8
	ctx.lr = 0x822F2EF8;
	sub_8222D3E8(ctx, base);
	// 822F2EF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F2EFC: 809900E0  lwz r4, 0xe0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(224 as u32) ) } as u64;
	// 822F2F00: 3BDD0020  addi r30, r29, 0x20
	ctx.r[30].s64 = ctx.r[29].s64 + 32;
	// 822F2F04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F2F08: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F2F0C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F2F10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F2F14: 4E800421  bctrl
	ctx.lr = 0x822F2F18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F2F18: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F2F1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F2F20: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F2F24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F2F28: 4E800421  bctrl
	ctx.lr = 0x822F2F2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F2F2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F2F30: 419A0194  beq cr6, 0x822f30c4
	if ctx.cr[6].eq {
	pc = 0x822F30C4; continue 'dispatch;
	}
	// 822F2F34: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2F38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F2F3C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F2F40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F2F44: 4E800421  bctrl
	ctx.lr = 0x822F2F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F2F48: 817900D0  lwz r11, 0xd0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(208 as u32) ) } as u64;
	// 822F2F4C: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 822F2F50: 917D0034  stw r11, 0x34(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 822F2F54: 817C0054  lwz r11, 0x54(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F2F58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F2F5C: 40990048  ble cr6, 0x822f2fa4
	if !ctx.cr[6].gt {
	pc = 0x822F2FA4; continue 'dispatch;
	}
	// 822F2F60: 3BDC005C  addi r30, r28, 0x5c
	ctx.r[30].s64 = ctx.r[28].s64 + 92;
            }
            0x822F2F64 => {
    //   block [0x822F2F64..0x822F2FA4)
	// 822F2F64: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F2F68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F2F6C: 419A0038  beq cr6, 0x822f2fa4
	if ctx.cr[6].eq {
	pc = 0x822F2FA4; continue 'dispatch;
	}
	// 822F2F70: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822F2F74: 815EFFFC  lwz r10, -4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822F2F78: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822F2F7C: 409A0028  bne cr6, 0x822f2fa4
	if !ctx.cr[6].eq {
	pc = 0x822F2FA4; continue 'dispatch;
	}
	// 822F2F80: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 822F2F84: 4BFFF16D  bl 0x822f20f0
	ctx.lr = 0x822F2F88;
	sub_822F20F0(ctx, base);
	// 822F2F88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F2F8C: 419A0018  beq cr6, 0x822f2fa4
	if ctx.cr[6].eq {
	pc = 0x822F2FA4; continue 'dispatch;
	}
	// 822F2F90: 817C0054  lwz r11, 0x54(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F2F94: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 822F2F98: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 822F2F9C: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F2FA0: 4198FFC4  blt cr6, 0x822f2f64
	if ctx.cr[6].lt {
	pc = 0x822F2F64; continue 'dispatch;
	}
	pc = 0x822F2FA4; continue 'dispatch;
            }
            0x822F2FA4 => {
    //   block [0x822F2FA4..0x822F2FDC)
	// 822F2FA4: 817C0054  lwz r11, 0x54(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F2FA8: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F2FAC: 409A0118  bne cr6, 0x822f30c4
	if !ctx.cr[6].eq {
	pc = 0x822F30C4; continue 'dispatch;
	}
	// 822F2FB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F2FB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822F2FB8: 38EBC640  addi r7, r11, -0x39c0
	ctx.r[7].s64 = ctx.r[11].s64 + -14784;
	// 822F2FBC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F2FC0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822F2FC4: 386000E8  li r3, 0xe8
	ctx.r[3].s64 = 232;
	// 822F2FC8: 480774C9  bl 0x8236a490
	ctx.lr = 0x822F2FCC;
	sub_8236A490(ctx, base);
	// 822F2FCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F2FD0: 419A000C  beq cr6, 0x822f2fdc
	if ctx.cr[6].eq {
	pc = 0x822F2FDC; continue 'dispatch;
	}
	// 822F2FD4: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822F2FD8: 48000008  b 0x822f2fe0
	pc = 0x822F2FE0; continue 'dispatch;
            }
            0x822F2FDC => {
    //   block [0x822F2FDC..0x822F2FE0)
	// 822F2FDC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822F2FE0; continue 'dispatch;
            }
            0x822F2FE0 => {
    //   block [0x822F2FE0..0x822F3098)
	// 822F2FE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F2FE4: 917C0048  stw r11, 0x48(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 822F2FE8: 907C004C  stw r3, 0x4c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(76 as u32), ctx.r[3].u32 ) };
	// 822F2FEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822F2FF0: 419A00A8  beq cr6, 0x822f3098
	if ctx.cr[6].eq {
	pc = 0x822F3098; continue 'dispatch;
	}
	// 822F2FF4: 39630090  addi r11, r3, 0x90
	ctx.r[11].s64 = ctx.r[3].s64 + 144;
	// 822F2FF8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 822F2FFC: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 822F3000: 393C0020  addi r9, r28, 0x20
	ctx.r[9].s64 = ctx.r[28].s64 + 32;
	// 822F3004: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 822F3008: FBEB0000  std r31, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 822F300C: 3C800000  lis r4, 0
	ctx.r[4].s64 = 0;
	// 822F3010: FBEB0008  std r31, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u64 ) };
	// 822F3014: C008BA38  lfs f0, -0x45c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3018: FBEB0010  std r31, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u64 ) };
	// 822F301C: 3D008288  lis r8, -0x7d78
	ctx.r[8].s64 = -2105016320;
	// 822F3020: FBEB0018  std r31, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[31].u64 ) };
	// 822F3024: 38E7C7DC  addi r7, r7, -0x3824
	ctx.r[7].s64 = ctx.r[7].s64 + -14372;
	// 822F3028: FBEB0020  std r31, 0x20(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[31].u64 ) };
	// 822F302C: 39088E40  addi r8, r8, -0x71c0
	ctx.r[8].s64 = ctx.r[8].s64 + -29120;
	// 822F3030: FBEB0028  std r31, 0x28(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[31].u64 ) };
	// 822F3034: 38BC0014  addi r5, r28, 0x14
	ctx.r[5].s64 = ctx.r[28].s64 + 20;
	// 822F3038: FBEB0030  std r31, 0x30(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[31].u64 ) };
	// 822F303C: 60848000  ori r4, r4, 0x8000
	ctx.r[4].u64 = ctx.r[4].u64 | 32768;
	// 822F3040: FBEB0038  std r31, 0x38(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[31].u64 ) };
	// 822F3044: 93EB0040  stw r31, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	// 822F3048: B3EB0044  sth r31, 0x44(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[31].u16 ) };
	// 822F304C: B3EB0046  sth r31, 0x46(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(70 as u32), ctx.r[31].u16 ) };
	// 822F3050: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 822F3054: A3C30014  lhz r30, 0x14(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F3058: 91230080  stw r9, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 822F305C: 50DE1EDE  rlwimi r30, r6, 3, 0x1b, 0xf
	ctx.r[30].u64 = (((ctx.r[6].u32).rotate_left(3) as u64) & 0xFFFFFFFFFFFF001F) | (ctx.r[30].u64 & 0x000000000000FFE0);
	// 822F3060: 91430084  stw r10, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 822F3064: 9943001D  stb r10, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[10].u8 ) };
	// 822F3068: 9943001E  stb r10, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[10].u8 ) };
	// 822F306C: 910300D0  stw r8, 0xd0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[8].u32 ) };
	// 822F3070: B3C30014  sth r30, 0x14(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[30].u16 ) };
	// 822F3074: 93EB0048  stw r31, 0x48(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[31].u32 ) };
	// 822F3078: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 822F307C: A1630014  lhz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F3080: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 822F3084: 616B0300  ori r11, r11, 0x300
	ctx.r[11].u64 = ctx.r[11].u64 | 768;
	// 822F3088: 90A300E0  stw r5, 0xe0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), ctx.r[5].u32 ) };
	// 822F308C: 912300E4  stw r9, 0xe4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 822F3090: 90830088  stw r4, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[4].u32 ) };
	// 822F3094: B1630014  sth r11, 0x14(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	pc = 0x822F3098; continue 'dispatch;
            }
            0x822F3098 => {
    //   block [0x822F3098..0x822F30C4)
	// 822F3098: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822F309C: 915C0030  stw r10, 0x30(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 822F30A0: 806BBAC8  lwz r3, -0x4538(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17720 as u32) ) } as u64;
	// 822F30A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F30A8: 419A0024  beq cr6, 0x822f30cc
	if ctx.cr[6].eq {
	pc = 0x822F30CC; continue 'dispatch;
	}
	// 822F30AC: 38C0016D  li r6, 0x16d
	ctx.r[6].s64 = 365;
	// 822F30B0: 80B900D4  lwz r5, 0xd4(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(212 as u32) ) } as u64;
	// 822F30B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822F30B8: 4806D8B1  bl 0x82360968
	ctx.lr = 0x822F30BC;
	sub_82360968(ctx, base);
	// 822F30BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F30C0: 4824203C  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x822F30C4 => {
    //   block [0x822F30C4..0x822F30CC)
	// 822F30C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822F30C8: 917C003C  stw r11, 0x3c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	pc = 0x822F30CC; continue 'dispatch;
            }
            0x822F30CC => {
    //   block [0x822F30CC..0x822F30D4)
	// 822F30CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F30D0: 4824202C  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F30D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F30D8 size=28
    let mut pc: u32 = 0x822F30D8;
    'dispatch: loop {
        match pc {
            0x822F30D8 => {
    //   block [0x822F30D8..0x822F30F4)
	// 822F30D8: A1430014  lhz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F30DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822F30E0: 614A0300  ori r10, r10, 0x300
	ctx.r[10].u64 = ctx.r[10].u64 | 768;
	// 822F30E4: 9963001E  stb r11, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[11].u8 ) };
	// 822F30E8: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 822F30EC: B1430014  sth r10, 0x14(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 822F30F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F30F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F30F8 size=440
    let mut pc: u32 = 0x822F30F8;
    'dispatch: loop {
        match pc {
            0x822F30F8 => {
    //   block [0x822F30F8..0x822F3138)
	// 822F30F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F30FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F3100: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F3104: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F3108: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F310C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F3110: 387E0080  addi r3, r30, 0x80
	ctx.r[3].s64 = ctx.r[30].s64 + 128;
	// 822F3114: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F311C: 419A002C  beq cr6, 0x822f3148
	if ctx.cr[6].eq {
	pc = 0x822F3148; continue 'dispatch;
	}
	// 822F3120: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3124: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3128: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F312C: 419A000C  beq cr6, 0x822f3138
	if ctx.cr[6].eq {
	pc = 0x822F3138; continue 'dispatch;
	}
	// 822F3130: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F3134: 48000014  b 0x822f3148
	pc = 0x822F3148; continue 'dispatch;
            }
            0x822F3138 => {
    //   block [0x822F3138..0x822F3148)
	// 822F3138: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F313C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F3140: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F3144: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F3148; continue 'dispatch;
            }
            0x822F3148 => {
    //   block [0x822F3148..0x822F3170)
	// 822F3148: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F314C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3150: 419A0148  beq cr6, 0x822f3298
	if ctx.cr[6].eq {
	pc = 0x822F3298; continue 'dispatch;
	}
	// 822F3154: 4BF3A295  bl 0x8222d3e8
	ctx.lr = 0x822F3158;
	sub_8222D3E8(ctx, base);
	// 822F3158: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 822F315C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 822F3160: 81670030  lwz r11, 0x30(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) } as u64;
	// 822F3164: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3168: 409A0008  bne cr6, 0x822f3170
	if !ctx.cr[6].eq {
	pc = 0x822F3170; continue 'dispatch;
	}
	// 822F316C: 93E7003C  stw r31, 0x3c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(60 as u32), ctx.r[31].u32 ) };
	pc = 0x822F3170; continue 'dispatch;
            }
            0x822F3170 => {
    //   block [0x822F3170..0x822F3190)
	// 822F3170: 81670040  lwz r11, 0x40(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(64 as u32) ) } as u64;
	// 822F3174: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3178: 419A009C  beq cr6, 0x822f3214
	if ctx.cr[6].eq {
	pc = 0x822F3214; continue 'dispatch;
	}
	// 822F317C: 81670054  lwz r11, 0x54(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F3180: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822F3184: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F3188: 40990084  ble cr6, 0x822f320c
	if !ctx.cr[6].gt {
	pc = 0x822F320C; continue 'dispatch;
	}
	// 822F318C: 3907005C  addi r8, r7, 0x5c
	ctx.r[8].s64 = ctx.r[7].s64 + 92;
	pc = 0x822F3190; continue 'dispatch;
            }
            0x822F3190 => {
    //   block [0x822F3190..0x822F31D4)
	// 822F3190: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3198: 419A0060  beq cr6, 0x822f31f8
	if ctx.cr[6].eq {
	pc = 0x822F31F8; continue 'dispatch;
	}
	// 822F319C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822F31A0: 8128FFFC  lwz r9, -4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822F31A4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F31A8: 409A0050  bne cr6, 0x822f31f8
	if !ctx.cr[6].eq {
	pc = 0x822F31F8; continue 'dispatch;
	}
	// 822F31AC: 386B0080  addi r3, r11, 0x80
	ctx.r[3].s64 = ctx.r[11].s64 + 128;
	// 822F31B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F31B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F31B8: 419A002C  beq cr6, 0x822f31e4
	if ctx.cr[6].eq {
	pc = 0x822F31E4; continue 'dispatch;
	}
	// 822F31BC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F31C0: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F31C4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F31C8: 419A000C  beq cr6, 0x822f31d4
	if ctx.cr[6].eq {
	pc = 0x822F31D4; continue 'dispatch;
	}
	// 822F31CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F31D0: 48000014  b 0x822f31e4
	pc = 0x822F31E4; continue 'dispatch;
            }
            0x822F31D4 => {
    //   block [0x822F31D4..0x822F31E4)
	// 822F31D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F31D8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F31DC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F31E0: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F31E4; continue 'dispatch;
            }
            0x822F31E4 => {
    //   block [0x822F31E4..0x822F31F8)
	// 822F31E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F31E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F31EC: 419A000C  beq cr6, 0x822f31f8
	if ctx.cr[6].eq {
	pc = 0x822F31F8; continue 'dispatch;
	}
	// 822F31F0: 4BF3A1F9  bl 0x8222d3e8
	ctx.lr = 0x822F31F4;
	sub_8222D3E8(ctx, base);
	// 822F31F4: 93E30134  stw r31, 0x134(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(308 as u32), ctx.r[31].u32 ) };
	pc = 0x822F31F8; continue 'dispatch;
            }
            0x822F31F8 => {
    //   block [0x822F31F8..0x822F320C)
	// 822F31F8: 81670054  lwz r11, 0x54(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F31FC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 822F3200: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 822F3204: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F3208: 4198FF88  blt cr6, 0x822f3190
	if ctx.cr[6].lt {
	pc = 0x822F3190; continue 'dispatch;
	}
	pc = 0x822F320C; continue 'dispatch;
            }
            0x822F320C => {
    //   block [0x822F320C..0x822F3214)
	// 822F320C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F3210: 91670040  stw r11, 0x40(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	pc = 0x822F3214; continue 'dispatch;
            }
            0x822F3214 => {
    //   block [0x822F3214..0x822F3228)
	// 822F3214: 81070054  lwz r8, 0x54(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F3218: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822F321C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822F3220: 40990038  ble cr6, 0x822f3258
	if !ctx.cr[6].gt {
	pc = 0x822F3258; continue 'dispatch;
	}
	// 822F3224: 3967005C  addi r11, r7, 0x5c
	ctx.r[11].s64 = ctx.r[7].s64 + 92;
	pc = 0x822F3228; continue 'dispatch;
            }
            0x822F3228 => {
    //   block [0x822F3228..0x822F3244)
	// 822F3228: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F322C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822F3230: 419A0014  beq cr6, 0x822f3244
	if ctx.cr[6].eq {
	pc = 0x822F3244; continue 'dispatch;
	}
	// 822F3234: 81290030  lwz r9, 0x30(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 822F3238: 80CBFFFC  lwz r6, -4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822F323C: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822F3240: 419A0018  beq cr6, 0x822f3258
	if ctx.cr[6].eq {
	pc = 0x822F3258; continue 'dispatch;
	}
	pc = 0x822F3244; continue 'dispatch;
            }
            0x822F3244 => {
    //   block [0x822F3244..0x822F3258)
	// 822F3244: 81270054  lwz r9, 0x54(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F3248: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F324C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822F3250: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 822F3254: 4198FFD4  blt cr6, 0x822f3228
	if ctx.cr[6].lt {
	pc = 0x822F3228; continue 'dispatch;
	}
	pc = 0x822F3258; continue 'dispatch;
            }
            0x822F3258 => {
    //   block [0x822F3258..0x822F3264)
	// 822F3258: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 822F325C: 409A0008  bne cr6, 0x822f3264
	if !ctx.cr[6].eq {
	pc = 0x822F3264; continue 'dispatch;
	}
	// 822F3260: 93E7003C  stw r31, 0x3c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(60 as u32), ctx.r[31].u32 ) };
	pc = 0x822F3264; continue 'dispatch;
            }
            0x822F3264 => {
    //   block [0x822F3264..0x822F3298)
	// 822F3264: 8167003C  lwz r11, 0x3c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(60 as u32) ) } as u64;
	// 822F3268: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F326C: 419A002C  beq cr6, 0x822f3298
	if ctx.cr[6].eq {
	pc = 0x822F3298; continue 'dispatch;
	}
	// 822F3270: 4BFF9EC1  bl 0x822ed130
	ctx.lr = 0x822F3274;
	sub_822ED130(ctx, base);
	// 822F3274: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F3278: 4BFFA9C1  bl 0x822edc38
	ctx.lr = 0x822F327C;
	sub_822EDC38(ctx, base);
	// 822F327C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 822F3280: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 822F3284: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822F3288: 409A0010  bne cr6, 0x822f3298
	if !ctx.cr[6].eq {
	pc = 0x822F3298; continue 'dispatch;
	}
	// 822F328C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 822F3290: 9BFE0025  stb r31, 0x25(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(37 as u32), ctx.r[31].u8 ) };
	// 822F3294: 997E0019  stb r11, 0x19(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	pc = 0x822F3298; continue 'dispatch;
            }
            0x822F3298 => {
    //   block [0x822F3298..0x822F32B0)
	// 822F3298: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F329C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F32A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F32A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F32A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F32AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F32B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F32B0 size=184
    let mut pc: u32 = 0x822F32B0;
    'dispatch: loop {
        match pc {
            0x822F32B0 => {
    //   block [0x822F32B0..0x822F32D8)
	// 822F32B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F32B4: 48241E09  bl 0x825350bc
	ctx.lr = 0x822F32B8;
	sub_82535080(ctx, base);
	// 822F32B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F32BC: 3BE30080  addi r31, r3, 0x80
	ctx.r[31].s64 = ctx.r[3].s64 + 128;
	// 822F32C0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822F32C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F32C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F32CC: 409A000C  bne cr6, 0x822f32d8
	if !ctx.cr[6].eq {
	pc = 0x822F32D8; continue 'dispatch;
	}
	// 822F32D0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822F32D4: 4800002C  b 0x822f3300
	pc = 0x822F3300; continue 'dispatch;
            }
            0x822F32D8 => {
    //   block [0x822F32D8..0x822F32F0)
	// 822F32D8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F32DC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F32E0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F32E4: 419A000C  beq cr6, 0x822f32f0
	if ctx.cr[6].eq {
	pc = 0x822F32F0; continue 'dispatch;
	}
	// 822F32E8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822F32EC: 48000014  b 0x822f3300
	pc = 0x822F3300; continue 'dispatch;
            }
            0x822F32F0 => {
    //   block [0x822F32F0..0x822F3300)
	// 822F32F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F32F4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F32F8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F32FC: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F3300; continue 'dispatch;
            }
            0x822F3300 => {
    //   block [0x822F3300..0x822F3348)
	// 822F3300: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F3304: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3308: 419A0058  beq cr6, 0x822f3360
	if ctx.cr[6].eq {
	pc = 0x822F3360; continue 'dispatch;
	}
	// 822F330C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F3310: 4BF3A0D9  bl 0x8222d3e8
	ctx.lr = 0x822F3314;
	sub_8222D3E8(ctx, base);
	// 822F3314: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F3318: 3BC30020  addi r30, r3, 0x20
	ctx.r[30].s64 = ctx.r[3].s64 + 32;
	// 822F331C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F3320: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F3324: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F3328: 4E800421  bctrl
	ctx.lr = 0x822F332C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F332C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F3330: 419A0018  beq cr6, 0x822f3348
	if ctx.cr[6].eq {
	pc = 0x822F3348; continue 'dispatch;
	}
	// 822F3334: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3338: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F333C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F3340: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F3344: 4E800421  bctrl
	ctx.lr = 0x822F3348;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822F3348 => {
    //   block [0x822F3348..0x822F3360)
	// 822F3348: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822F334C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3350: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822F3354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F3358: 419A0008  beq cr6, 0x822f3360
	if ctx.cr[6].eq {
	pc = 0x822F3360; continue 'dispatch;
	}
	// 822F335C: 4BE29CFD  bl 0x8211d058
	ctx.lr = 0x822F3360;
	sub_8211D058(ctx, base);
	pc = 0x822F3360; continue 'dispatch;
            }
            0x822F3360 => {
    //   block [0x822F3360..0x822F3368)
	// 822F3360: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F3364: 48241DA8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F3368 size=368
    let mut pc: u32 = 0x822F3368;
    'dispatch: loop {
        match pc {
            0x822F3368 => {
    //   block [0x822F3368..0x822F33A8)
	// 822F3368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F336C: 48241D4D  bl 0x825350b8
	ctx.lr = 0x822F3370;
	sub_82535080(ctx, base);
	// 822F3370: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F3374: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F3378: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F337C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822F3380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F3384: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3388: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F338C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F3390: 4E800421  bctrl
	ctx.lr = 0x822F3394;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F3394: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 822F3398: 409A0010  bne cr6, 0x822f33a8
	if !ctx.cr[6].eq {
	pc = 0x822F33A8; continue 'dispatch;
	}
	// 822F339C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 822F33A0: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 822F33A4: 48000008  b 0x822f33ac
	pc = 0x822F33AC; continue 'dispatch;
            }
            0x822F33A8 => {
    //   block [0x822F33A8..0x822F33AC)
	// 822F33A8: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x822F33AC; continue 'dispatch;
            }
            0x822F33AC => {
    //   block [0x822F33AC..0x822F34B0)
	// 822F33AC: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F33B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F33B4: 4099011C  ble cr6, 0x822f34d0
	if !ctx.cr[6].gt {
	pc = 0x822F34D0; continue 'dispatch;
	}
	// 822F33B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F33BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F33C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F33C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F33C8: 4E800421  bctrl
	ctx.lr = 0x822F33CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F33CC: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 822F33D0: 409A0100  bne cr6, 0x822f34d0
	if !ctx.cr[6].eq {
	pc = 0x822F34D0; continue 'dispatch;
	}
	// 822F33D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F33D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F33DC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F33E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F33E4: 4E800421  bctrl
	ctx.lr = 0x822F33E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F33E8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 822F33EC: 409900E4  ble cr6, 0x822f34d0
	if !ctx.cr[6].gt {
	pc = 0x822F34D0; continue 'dispatch;
	}
	// 822F33F0: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F33F4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 822F33F8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F33FC: C00B011C  lfs f0, 0x11c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3400: C1AB0118  lfs f13, 0x118(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F3404: C18B0114  lfs f12, 0x114(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822F3408: C16B0110  lfs f11, 0x110(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822F340C: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822F3410: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822F3414: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822F3418: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822F341C: 4809A80D  bl 0x8238dc28
	ctx.lr = 0x822F3420;
	sub_8238DC28(ctx, base);
	// 822F3420: 83FD000C  lwz r31, 0xc(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F3424: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822F3428: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822F342C: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F3430: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 822F3434: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 822F3438: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 822F343C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3440: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 822F3444: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 822F3448: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 822F344C: C00B01A0  lfs f0, 0x1a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3450: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 822F3454: C00B01A4  lfs f0, 0x1a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3458: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 822F345C: C00B01A8  lfs f0, 0x1a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(424 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3460: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 822F3464: C00B01AC  lfs f0, 0x1ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3468: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 822F346C: C00B01B0  lfs f0, 0x1b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3470: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 822F3474: C00B01B4  lfs f0, 0x1b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(436 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3478: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 822F347C: C00B01B8  lfs f0, 0x1b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3480: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 822F3484: C00B01BC  lfs f0, 0x1bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(444 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3488: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 822F348C: 4BFF9215  bl 0x822ec6a0
	ctx.lr = 0x822F3490;
	sub_822EC6A0(ctx, base);
	// 822F3490: 4BFF9CA1  bl 0x822ed130
	ctx.lr = 0x822F3494;
	sub_822ED130(ctx, base);
	// 822F3494: 81630258  lwz r11, 0x258(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(600 as u32) ) } as u64;
	// 822F3498: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F349C: 419A0014  beq cr6, 0x822f34b0
	if ctx.cr[6].eq {
	pc = 0x822F34B0; continue 'dispatch;
	}
	// 822F34A0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822F34A4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822F34A8: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 822F34AC: 4806F1D5  bl 0x82362680
	ctx.lr = 0x822F34B0;
	sub_82362680(ctx, base);
            }
            0x822F34B0 => {
    //   block [0x822F34B0..0x822F34D0)
	// 822F34B0: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F34B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F34B8: 419A0018  beq cr6, 0x822f34d0
	if ctx.cr[6].eq {
	pc = 0x822F34D0; continue 'dispatch;
	}
	// 822F34BC: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 822F34C0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F34C4: 4819ACA5  bl 0x8248e168
	ctx.lr = 0x822F34C8;
	sub_8248E168(ctx, base);
	// 822F34C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F34CC: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x822F34D0; continue 'dispatch;
            }
            0x822F34D0 => {
    //   block [0x822F34D0..0x822F34D8)
	// 822F34D0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822F34D4: 48241C34  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F34D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F34D8 size=212
    let mut pc: u32 = 0x822F34D8;
    'dispatch: loop {
        match pc {
            0x822F34D8 => {
    //   block [0x822F34D8..0x822F351C)
	// 822F34D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F34DC: 48241BDD  bl 0x825350b8
	ctx.lr = 0x822F34E0;
	sub_82535080(ctx, base);
	// 822F34E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F34E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F34E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F34EC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822F34F0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822F34F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F34F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F34FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F3504: 4E800421  bctrl
	ctx.lr = 0x822F3508;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F3508: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 822F350C: 409A0010  bne cr6, 0x822f351c
	if !ctx.cr[6].eq {
	pc = 0x822F351C; continue 'dispatch;
	}
	// 822F3510: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822F3514: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 822F3518: 48000008  b 0x822f3520
	pc = 0x822F3520; continue 'dispatch;
            }
            0x822F351C => {
    //   block [0x822F351C..0x822F3520)
	// 822F351C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822F3520; continue 'dispatch;
            }
            0x822F3520 => {
    //   block [0x822F3520..0x822F3584)
	// 822F3520: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822F3524: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F3528: 4099007C  ble cr6, 0x822f35a4
	if !ctx.cr[6].gt {
	pc = 0x822F35A4; continue 'dispatch;
	}
	// 822F352C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F3534: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3538: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F353C: 4E800421  bctrl
	ctx.lr = 0x822F3540;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F3540: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 822F3544: 409A0060  bne cr6, 0x822f35a4
	if !ctx.cr[6].eq {
	pc = 0x822F35A4; continue 'dispatch;
	}
	// 822F3548: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F354C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F3550: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F3554: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F3558: 4E800421  bctrl
	ctx.lr = 0x822F355C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F355C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 822F3560: 40990044  ble cr6, 0x822f35a4
	if !ctx.cr[6].gt {
	pc = 0x822F35A4; continue 'dispatch;
	}
	// 822F3564: 4BFF9BCD  bl 0x822ed130
	ctx.lr = 0x822F3568;
	sub_822ED130(ctx, base);
	// 822F3568: 81630258  lwz r11, 0x258(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(600 as u32) ) } as u64;
	// 822F356C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3570: 419A0014  beq cr6, 0x822f3584
	if ctx.cr[6].eq {
	pc = 0x822F3584; continue 'dispatch;
	}
	// 822F3574: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822F3578: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822F357C: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 822F3580: 4806F101  bl 0x82362680
	ctx.lr = 0x822F3584;
	sub_82362680(ctx, base);
            }
            0x822F3584 => {
    //   block [0x822F3584..0x822F35A4)
	// 822F3584: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F3588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F358C: 419A0018  beq cr6, 0x822f35a4
	if ctx.cr[6].eq {
	pc = 0x822F35A4; continue 'dispatch;
	}
	// 822F3590: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 822F3594: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3598: 4819ABD1  bl 0x8248e168
	ctx.lr = 0x822F359C;
	sub_8248E168(ctx, base);
	// 822F359C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F35A0: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x822F35A4; continue 'dispatch;
            }
            0x822F35A4 => {
    //   block [0x822F35A4..0x822F35AC)
	// 822F35A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822F35A8: 48241B60  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F35B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F35B0 size=44
    let mut pc: u32 = 0x822F35B0;
    'dispatch: loop {
        match pc {
            0x822F35B0 => {
    //   block [0x822F35B0..0x822F35DC)
	// 822F35B0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822F35B4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822F35B8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 822F35BC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822F35C0: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F35C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F35C8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 822F35CC: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F35D0: 7C6B1A14  add r3, r11, r3
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822F35D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822F35D8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F35E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F35E0 size=136
    let mut pc: u32 = 0x822F35E0;
    'dispatch: loop {
        match pc {
            0x822F35E0 => {
    //   block [0x822F35E0..0x822F3634)
	// 822F35E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F35E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F35E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F35EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F35F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F35F4: 4BFF9B3D  bl 0x822ed130
	ctx.lr = 0x822F35F8;
	sub_822ED130(ctx, base);
	// 822F35F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F35FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F3600: 38EBC6AC  addi r7, r11, -0x3954
	ctx.r[7].s64 = ctx.r[11].s64 + -14676;
	// 822F3604: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822F3608: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F360C: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 822F3610: 48076E81  bl 0x8236a490
	ctx.lr = 0x822F3614;
	sub_8236A490(ctx, base);
	// 822F3614: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F3618: 419A001C  beq cr6, 0x822f3634
	if ctx.cr[6].eq {
	pc = 0x822F3634; continue 'dispatch;
	}
	// 822F361C: 811F0090  lwz r8, 0x90(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 822F3620: 80FF008C  lwz r7, 0x8c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 822F3624: 80DF0088  lwz r6, 0x88(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 822F3628: 80BF0084  lwz r5, 0x84(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822F362C: 809F0080  lwz r4, 0x80(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822F3630: 48000039  bl 0x822f3668
	ctx.lr = 0x822F3634;
	sub_822F3668(ctx, base);
	pc = 0x822F3634; continue 'dispatch;
            }
            0x822F3634 => {
    //   block [0x822F3634..0x822F3654)
	// 822F3634: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 822F3638: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 822F363C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822F3640: 409A0014  bne cr6, 0x822f3654
	if !ctx.cr[6].eq {
	pc = 0x822F3654; continue 'dispatch;
	}
	// 822F3644: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 822F3648: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822F364C: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 822F3650: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x822F3654; continue 'dispatch;
            }
            0x822F3654 => {
    //   block [0x822F3654..0x822F3668)
	// 822F3654: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F3658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F365C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F3660: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F3664: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F3668 size=708
    let mut pc: u32 = 0x822F3668;
    'dispatch: loop {
        match pc {
            0x822F3668 => {
    //   block [0x822F3668..0x822F36EC)
	// 822F3668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F366C: 48241A41  bl 0x825350ac
	ctx.lr = 0x822F3670;
	sub_82535080(ctx, base);
	// 822F3670: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F3674: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F3678: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822F367C: 396BC6E8  addi r11, r11, -0x3918
	ctx.r[11].s64 = ctx.r[11].s64 + -14616;
	// 822F3680: 3BFC0080  addi r31, r28, 0x80
	ctx.r[31].s64 = ctx.r[28].s64 + 128;
	// 822F3684: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F3688: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822F368C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822F3690: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F3694: 39600300  li r11, 0x300
	ctx.r[11].s64 = 768;
	// 822F3698: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822F369C: 38CAC6B8  addi r6, r10, -0x3948
	ctx.r[6].s64 = ctx.r[10].s64 + -14664;
	// 822F36A0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822F36A4: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 822F36A8: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822F36AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F36B0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 822F36B4: 386ADBE0  addi r3, r10, -0x2420
	ctx.r[3].s64 = ctx.r[10].s64 + -9248;
	// 822F36B8: A17D0008  lhz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F36BC: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 822F36C0: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 822F36C4: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 822F36C8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822F36CC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F36D0: 38AB0300  addi r5, r11, 0x300
	ctx.r[5].s64 = ctx.r[11].s64 + 768;
	// 822F36D4: 4BF01C15  bl 0x821f52e8
	ctx.lr = 0x822F36D8;
	sub_821F52E8(ctx, base);
	// 822F36D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F36DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F36E0: 409A000C  bne cr6, 0x822f36ec
	if !ctx.cr[6].eq {
	pc = 0x822F36EC; continue 'dispatch;
	}
	// 822F36E4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822F36E8: 4800002C  b 0x822f3714
	pc = 0x822F3714; continue 'dispatch;
            }
            0x822F36EC => {
    //   block [0x822F36EC..0x822F3704)
	// 822F36EC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F36F0: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F36F4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F36F8: 419A000C  beq cr6, 0x822f3704
	if ctx.cr[6].eq {
	pc = 0x822F3704; continue 'dispatch;
	}
	// 822F36FC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822F3700: 48000014  b 0x822f3714
	pc = 0x822F3714; continue 'dispatch;
            }
            0x822F3704 => {
    //   block [0x822F3704..0x822F3714)
	// 822F3704: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3708: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F370C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F3710: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F3714; continue 'dispatch;
            }
            0x822F3714 => {
    //   block [0x822F3714..0x822F3754)
	// 822F3714: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F3718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F371C: 419A0204  beq cr6, 0x822f3920
	if ctx.cr[6].eq {
	pc = 0x822F3920; continue 'dispatch;
	}
	// 822F3720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F3724: 4BF39CC5  bl 0x8222d3e8
	ctx.lr = 0x822F3728;
	sub_8222D3E8(ctx, base);
	// 822F3728: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 822F372C: 3968007F  addi r11, r8, 0x7f
	ctx.r[11].s64 = ctx.r[8].s64 + 127;
	// 822F3730: 39480300  addi r10, r8, 0x300
	ctx.r[10].s64 = ctx.r[8].s64 + 768;
	// 822F3734: 55690030  rlwinm r9, r11, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822F3738: 554B0030  rlwinm r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822F373C: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 822F3740: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822F3744: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822F3748: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822F374C: 419A0008  beq cr6, 0x822f3754
	if ctx.cr[6].eq {
	pc = 0x822F3754; continue 'dispatch;
	}
	// 822F3750: 7C00422C  dcbt 0, r8
	pc = 0x822F3754; continue 'dispatch;
            }
            0x822F3754 => {
    //   block [0x822F3754..0x822F3760)
	// 822F3754: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822F3758: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 822F375C: 41980084  blt cr6, 0x822f37e0
	if ctx.cr[6].lt {
	pc = 0x822F37E0; continue 'dispatch;
	}
	pc = 0x822F3760; continue 'dispatch;
            }
            0x822F3760 => {
    //   block [0x822F3760..0x822F37E0)
	// 822F3760: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 822F3764: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F3768: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F376C: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 822F3770: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F3774: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 822F3778: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F377C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F3780: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 822F3784: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F3788: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F378C: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 822F3790: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F3794: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F3798: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 822F379C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F37A0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F37A4: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 822F37A8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F37AC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F37B0: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 822F37B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F37B8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F37BC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F37C0: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 822F37C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F37C8: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 822F37CC: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 822F37D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822F37D4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822F37D8: 4098FF88  bge cr6, 0x822f3760
	if !ctx.cr[6].lt {
	pc = 0x822F3760; continue 'dispatch;
	}
	// 822F37DC: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x822F37E0; continue 'dispatch;
            }
            0x822F37E0 => {
    //   block [0x822F37E0..0x822F3824)
	// 822F37E0: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 822F37E4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822F37E8: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 822F37EC: 4199008C  bgt cr6, 0x822f3878
	if ctx.cr[6].gt {
	pc = 0x822F3878; continue 'dispatch;
	}
	// 822F37F0: 3D80822F  lis r12, -0x7dd1
	ctx.r[12].s64 = -2110849024;
	// 822F37F4: 398C3808  addi r12, r12, 0x3808
	ctx.r[12].s64 = ctx.r[12].s64 + 14344;
	// 822F37F8: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 822F37FC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 822F3800: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 822F3804: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x822F386C; continue 'dispatch;
		},
		1 => {
	pc = 0x822F3860; continue 'dispatch;
		},
		2 => {
	pc = 0x822F3854; continue 'dispatch;
		},
		3 => {
	pc = 0x822F3848; continue 'dispatch;
		},
		4 => {
	pc = 0x822F383C; continue 'dispatch;
		},
		5 => {
	pc = 0x822F3830; continue 'dispatch;
		},
		6 => {
	pc = 0x822F3824; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 822F3808: 822F386C  lwz r17, 0x386c(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(14444 as u32) ) } as u64;
	// 822F380C: 822F3860  lwz r17, 0x3860(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(14432 as u32) ) } as u64;
	// 822F3810: 822F3854  lwz r17, 0x3854(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(14420 as u32) ) } as u64;
	// 822F3814: 822F3848  lwz r17, 0x3848(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(14408 as u32) ) } as u64;
	// 822F3818: 822F383C  lwz r17, 0x383c(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(14396 as u32) ) } as u64;
	// 822F381C: 822F3830  lwz r17, 0x3830(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(14384 as u32) ) } as u64;
	// 822F3820: 822F3824  lwz r17, 0x3824(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(14372 as u32) ) } as u64;
            }
            0x822F3824 => {
    //   block [0x822F3824..0x822F3830)
	// 822F3824: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 822F3828: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F382C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F3830; continue 'dispatch;
            }
            0x822F3830 => {
    //   block [0x822F3830..0x822F383C)
	// 822F3830: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 822F3834: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F3838: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F383C; continue 'dispatch;
            }
            0x822F383C => {
    //   block [0x822F383C..0x822F3848)
	// 822F383C: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 822F3840: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F3844: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F3848; continue 'dispatch;
            }
            0x822F3848 => {
    //   block [0x822F3848..0x822F3854)
	// 822F3848: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 822F384C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F3850: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F3854; continue 'dispatch;
            }
            0x822F3854 => {
    //   block [0x822F3854..0x822F3860)
	// 822F3854: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 822F3858: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F385C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F3860; continue 'dispatch;
            }
            0x822F3860 => {
    //   block [0x822F3860..0x822F386C)
	// 822F3860: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 822F3864: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F3868: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F386C; continue 'dispatch;
            }
            0x822F386C => {
    //   block [0x822F386C..0x822F3878)
	// 822F386C: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 822F3870: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F3874: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x822F3878; continue 'dispatch;
            }
            0x822F3878 => {
    //   block [0x822F3878..0x822F38B0)
	// 822F3878: A17D0008  lhz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F387C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F3880: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822F3884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3888: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822F388C: 419A0074  beq cr6, 0x822f3900
	if ctx.cr[6].eq {
	pc = 0x822F3900; continue 'dispatch;
	}
	// 822F3890: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822F3894: 3948020C  addi r10, r8, 0x20c
	ctx.r[10].s64 = ctx.r[8].s64 + 524;
	// 822F3898: 392B45C8  addi r9, r11, 0x45c8
	ctx.r[9].s64 = ctx.r[11].s64 + 17864;
	// 822F389C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F38A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822F38A4: 38EBC798  addi r7, r11, -0x3868
	ctx.r[7].s64 = ctx.r[11].s64 + -14440;
	// 822F38A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F38AC: 38CBC714  addi r6, r11, -0x38ec
	ctx.r[6].s64 = ctx.r[11].s64 + -14572;
	pc = 0x822F38B0; continue 'dispatch;
            }
            0x822F38B0 => {
    //   block [0x822F38B0..0x822F38EC)
	// 822F38B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822F38B4: 38630018  addi r3, r3, 0x18
	ctx.r[3].s64 = ctx.r[3].s64 + 24;
	// 822F38B8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F38BC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F38C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F38C4: 419A0028  beq cr6, 0x822f38ec
	if ctx.cr[6].eq {
	pc = 0x822F38EC; continue 'dispatch;
	}
	// 822F38C8: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 822F38CC: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 822F38D0: EBE10060  ld r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822F38D4: B0AB0006  sth r5, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[5].u16 ) };
	// 822F38D8: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822F38DC: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 822F38E0: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 822F38E4: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 822F38E8: FBEB0010  std r31, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u64 ) };
	pc = 0x822F38EC; continue 'dispatch;
            }
            0x822F38EC => {
    //   block [0x822F38EC..0x822F3900)
	// 822F38EC: A17D0008  lhz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F38F0: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 822F38F4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822F38F8: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822F38FC: 4198FFB4  blt cr6, 0x822f38b0
	if ctx.cr[6].lt {
	pc = 0x822F38B0; continue 'dispatch;
	}
	pc = 0x822F3900; continue 'dispatch;
            }
            0x822F3900 => {
    //   block [0x822F3900..0x822F3920)
	// 822F3900: A17D0008  lhz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3904: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822F3908: 93A80000  stw r29, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822F390C: 93680004  stw r27, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 822F3910: 9348000C  stw r26, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 822F3914: 93280010  stw r25, 0x10(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[25].u32 ) };
	// 822F3918: 91680008  stw r11, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822F391C: 48000015  bl 0x822f3930
	ctx.lr = 0x822F3920;
	sub_822F3930(ctx, base);
	pc = 0x822F3920; continue 'dispatch;
            }
            0x822F3920 => {
    //   block [0x822F3920..0x822F392C)
	// 822F3920: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822F3924: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822F3928: 482417D4  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F3930 size=1980
    let mut pc: u32 = 0x822F3930;
    'dispatch: loop {
        match pc {
            0x822F3930 => {
    //   block [0x822F3930..0x822F3964)
	// 822F3930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F3934: 4824174D  bl 0x82535080
	ctx.lr = 0x822F3938;
	sub_82535080(ctx, base);
	// 822F3938: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 822F393C: 9421FA10  stwu r1, -0x5f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1520 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F3940: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 822F3944: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 822F3948: 3BF90080  addi r31, r25, 0x80
	ctx.r[31].s64 = ctx.r[25].s64 + 128;
	// 822F394C: 93210604  stw r25, 0x604(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1540 as u32), ctx.r[25].u32 ) };
	// 822F3950: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3954: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3958: 409A000C  bne cr6, 0x822f3964
	if !ctx.cr[6].eq {
	pc = 0x822F3964; continue 'dispatch;
	}
	// 822F395C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822F3960: 4800002C  b 0x822f398c
	pc = 0x822F398C; continue 'dispatch;
            }
            0x822F3964 => {
    //   block [0x822F3964..0x822F397C)
	// 822F3964: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3968: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F396C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F3970: 419A000C  beq cr6, 0x822f397c
	if ctx.cr[6].eq {
	pc = 0x822F397C; continue 'dispatch;
	}
	// 822F3974: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822F3978: 48000014  b 0x822f398c
	pc = 0x822F398C; continue 'dispatch;
            }
            0x822F397C => {
    //   block [0x822F397C..0x822F398C)
	// 822F397C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3980: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F3984: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F3988: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F398C; continue 'dispatch;
            }
            0x822F398C => {
    //   block [0x822F398C..0x822F39CC)
	// 822F398C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F3990: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3994: 419A074C  beq cr6, 0x822f40e0
	if ctx.cr[6].eq {
	pc = 0x822F40E0; continue 'dispatch;
	}
	// 822F3998: 4BFF9799  bl 0x822ed130
	ctx.lr = 0x822F399C;
	sub_822ED130(ctx, base);
	// 822F399C: 7C701B78  mr r16, r3
	ctx.r[16].u64 = ctx.r[3].u64;
	// 822F39A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F39A4: 4BF39A45  bl 0x8222d3e8
	ctx.lr = 0x822F39A8;
	sub_8222D3E8(ctx, base);
	// 822F39A8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822F39AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822F39B0: 81FA0008  lwz r15, 8(r26)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F39B4: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822F39B8: 2F0F0000  cmpwi cr6, r15, 0
	ctx.cr[6].compare_i32(ctx.r[15].s32, 0, &mut ctx.xer);
	// 822F39BC: 409900E0  ble cr6, 0x822f3a9c
	if !ctx.cr[6].gt {
	pc = 0x822F3A9C; continue 'dispatch;
	}
	// 822F39C0: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 822F39C4: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 822F39C8: 7DFC7B78  mr r28, r15
	ctx.r[28].u64 = ctx.r[15].u64;
	pc = 0x822F39CC; continue 'dispatch;
            }
            0x822F39CC => {
    //   block [0x822F39CC..0x822F3A9C)
	// 822F39CC: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F39D0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F39D4: 7FDD5A14  add r30, r29, r11
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 822F39D8: 816A0060  lwz r11, 0x60(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(96 as u32) ) } as u64;
	// 822F39DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F39E0: 7FEBDA14  add r31, r11, r27
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822F39E4: C07F0008  lfs f3, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822F39E8: C05F0004  lfs f2, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822F39EC: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822F39F0: 48074829  bl 0x82368218
	ctx.lr = 0x822F39F4;
	sub_82368218(ctx, base);
	// 822F39F4: C01F0010  lfs f0, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F39F8: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 822F39FC: D01E0030  stfs f0, 0x30(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 822F3A00: 3B7B0050  addi r27, r27, 0x50
	ctx.r[27].s64 = ctx.r[27].s64 + 80;
	// 822F3A04: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3A08: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 822F3A0C: D01E0034  stfs f0, 0x34(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 822F3A10: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3A14: D01E0038  stfs f0, 0x38(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 822F3A18: D3FE003C  stfs f31, 0x3c(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 822F3A1C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3A20: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3A24: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 822F3A28: 3BBD0040  addi r29, r29, 0x40
	ctx.r[29].s64 = ctx.r[29].s64 + 64;
	// 822F3A2C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F3A30: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822F3A34: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822F3A38: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822F3A3C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F3A40: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822F3A44: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F3A48: C12B0014  lfs f9, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822F3A4C: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F3A50: C10B0018  lfs f8, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822F3A54: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F3A58: C0EB0020  lfs f7, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822F3A5C: ED080032  fmuls f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F3A60: C0CB0024  lfs f6, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822F3A64: ECE70032  fmuls f7, f7, f0
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F3A68: C0AB0028  lfs f5, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 822F3A6C: ECC60032  fmuls f6, f6, f0
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F3A70: EC050032  fmuls f0, f5, f0
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F3A74: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822F3A78: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822F3A7C: D16B0008  stfs f11, 8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822F3A80: D14B0010  stfs f10, 0x10(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822F3A84: D12B0014  stfs f9, 0x14(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 822F3A88: D10B0018  stfs f8, 0x18(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 822F3A8C: D0EB0020  stfs f7, 0x20(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822F3A90: D0CB0024  stfs f6, 0x24(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822F3A94: D00B0028  stfs f0, 0x28(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822F3A98: 409AFF34  bne cr6, 0x822f39cc
	if !ctx.cr[6].eq {
	pc = 0x822F39CC; continue 'dispatch;
	}
	pc = 0x822F3A9C; continue 'dispatch;
            }
            0x822F3A9C => {
    //   block [0x822F3A9C..0x822F3ADC)
	// 822F3A9C: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3AA0: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3AA4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 822F3AA8: 409A0638  bne cr6, 0x822f40e0
	if !ctx.cr[6].eq {
	pc = 0x822F40E0; continue 'dispatch;
	}
	// 822F3AAC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822F3AB0: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F3AB4: 890A0005  lbz r8, 5(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 822F3AB8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822F3ABC: C1A91FF8  lfs f13, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F3AC0: 828B0000  lwz r20, 0(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3AC4: 826B0004  lwz r19, 4(r11)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3AC8: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 822F3ACC: 81CB0008  lwz r14, 8(r11)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3AD0: 419A000C  beq cr6, 0x822f3adc
	if ctx.cr[6].eq {
	pc = 0x822F3ADC; continue 'dispatch;
	}
	// 822F3AD4: 816A0054  lwz r11, 0x54(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F3AD8: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x822F3ADC; continue 'dispatch;
            }
            0x822F3ADC => {
    //   block [0x822F3ADC..0x822F3AF8)
	// 822F3ADC: 7DCB0034  cntlzw r11, r14
	ctx.r[11].u64 = if ctx.r[14].u32 == 0 { 32 } else { ctx.r[14].u32.leading_zeros() as u64 };
	// 822F3AE0: 2F0E0000  cmpwi cr6, r14, 0
	ctx.cr[6].compare_i32(ctx.r[14].s32, 0, &mut ctx.xer);
	// 822F3AE4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F3AE8: 917A0070  stw r11, 0x70(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822F3AEC: 419A000C  beq cr6, 0x822f3af8
	if ctx.cr[6].eq {
	pc = 0x822F3AF8; continue 'dispatch;
	}
	// 822F3AF0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 822F3AF4: 48000008  b 0x822f3afc
	pc = 0x822F3AFC; continue 'dispatch;
            }
            0x822F3AF8 => {
    //   block [0x822F3AF8..0x822F3AFC)
	// 822F3AF8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x822F3AFC; continue 'dispatch;
            }
            0x822F3AFC => {
    //   block [0x822F3AFC..0x822F3B10)
	// 822F3AFC: D01A0060  stfs f0, 0x60(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822F3B00: 2F0E0000  cmpwi cr6, r14, 0
	ctx.cr[6].compare_i32(ctx.r[14].s32, 0, &mut ctx.xer);
	// 822F3B04: 419A000C  beq cr6, 0x822f3b10
	if ctx.cr[6].eq {
	pc = 0x822F3B10; continue 'dispatch;
	}
	// 822F3B08: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 822F3B0C: 48000008  b 0x822f3b14
	pc = 0x822F3B14; continue 'dispatch;
            }
            0x822F3B10 => {
    //   block [0x822F3B10..0x822F3B14)
	// 822F3B10: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x822F3B14; continue 'dispatch;
            }
            0x822F3B14 => {
    //   block [0x822F3B14..0x822F3B3C)
	// 822F3B14: 817A000C  lwz r11, 0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F3B18: 3A200001  li r17, 1
	ctx.r[17].s64 = 1;
	// 822F3B1C: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 822F3B20: 7E2A8B78  mr r10, r17
	ctx.r[10].u64 = ctx.r[17].u64;
	// 822F3B24: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822F3B28: 929A0068  stw r20, 0x68(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(104 as u32), ctx.r[20].u32 ) };
	// 822F3B2C: 927A006C  stw r19, 0x6c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(108 as u32), ctx.r[19].u32 ) };
	// 822F3B30: 92FA0064  stw r23, 0x64(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(100 as u32), ctx.r[23].u32 ) };
	// 822F3B34: 41990008  bgt cr6, 0x822f3b3c
	if ctx.cr[6].gt {
	pc = 0x822F3B3C; continue 'dispatch;
	}
	// 822F3B38: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	pc = 0x822F3B3C; continue 'dispatch;
            }
            0x822F3B3C => {
    //   block [0x822F3B3C..0x822F3B78)
	// 822F3B3C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F3B40: 915A0078  stw r10, 0x78(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 822F3B44: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F3B48: 92FA007C  stw r23, 0x7c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(124 as u32), ctx.r[23].u32 ) };
	// 822F3B4C: 92FA028C  stw r23, 0x28c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(652 as u32), ctx.r[23].u32 ) };
	// 822F3B50: 92FA0290  stw r23, 0x290(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(656 as u32), ctx.r[23].u32 ) };
	// 822F3B54: C00B2238  lfs f0, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3B58: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F3B5C: D01A0074  stfs f0, 0x74(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822F3B60: 48000CE9  bl 0x822f4848
	ctx.lr = 0x822F3B64;
	sub_822F4848(ctx, base);
	// 822F3B64: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822F3B68: 3940001F  li r10, 0x1f
	ctx.r[10].s64 = 31;
	// 822F3B6C: 396100D8  addi r11, r1, 0xd8
	ctx.r[11].s64 = ctx.r[1].s64 + 216;
	// 822F3B70: 3B89C560  addi r28, r9, -0x3aa0
	ctx.r[28].s64 = ctx.r[9].s64 + -15008;
	// 822F3B74: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	pc = 0x822F3B78; continue 'dispatch;
            }
            0x822F3B78 => {
    //   block [0x822F3B78..0x822F3C30)
	// 822F3B78: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822F3B7C: 936BFFFC  stw r27, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[27].u32 ) };
	// 822F3B80: 938BFFF8  stw r28, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[28].u32 ) };
	// 822F3B84: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 822F3B88: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F3B8C: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 822F3B90: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 822F3B94: 936B0010  stw r27, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[27].u32 ) };
	// 822F3B98: 936B000C  stw r27, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 822F3B9C: 92EB0018  stw r23, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[23].u32 ) };
	// 822F3BA0: 92EB0014  stw r23, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[23].u32 ) };
	// 822F3BA4: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 822F3BA8: 4098FFD0  bge cr6, 0x822f3b78
	if !ctx.cr[6].lt {
	pc = 0x822F3B78; continue 'dispatch;
	}
	// 822F3BAC: 39610064  addi r11, r1, 0x64
	ctx.r[11].s64 = ctx.r[1].s64 + 100;
	// 822F3BB0: 92810054  stw r20, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[20].u32 ) };
	// 822F3BB4: 3941006C  addi r10, r1, 0x6c
	ctx.r[10].s64 = ctx.r[1].s64 + 108;
	// 822F3BB8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 822F3BBC: 92610058  stw r19, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[19].u32 ) };
	// 822F3BC0: 392100E4  addi r9, r1, 0xe4
	ctx.r[9].s64 = ctx.r[1].s64 + 228;
	// 822F3BC4: 92E1005C  stw r23, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[23].u32 ) };
	// 822F3BC8: 390100EC  addi r8, r1, 0xec
	ctx.r[8].s64 = ctx.r[1].s64 + 236;
	// 822F3BCC: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 822F3BD0: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 822F3BD4: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 822F3BD8: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 822F3BDC: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 822F3BE0: 92E10070  stw r23, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[23].u32 ) };
	// 822F3BE4: 92E1006C  stw r23, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[23].u32 ) };
	// 822F3BE8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3BEC: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3BF0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3BF4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3BF8: 928100D4  stw r20, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[20].u32 ) };
	// 822F3BFC: 926100D8  stw r19, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[19].u32 ) };
	// 822F3C00: 92E100DC  stw r23, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[23].u32 ) };
	// 822F3C04: 936100E0  stw r27, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[27].u32 ) };
	// 822F3C08: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 822F3C0C: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822F3C10: 90C80000  stw r6, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 822F3C14: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F3C18: 4BFF9DB1  bl 0x822ed9c8
	ctx.lr = 0x822F3C1C;
	sub_822ED9C8(ctx, base);
	// 822F3C1C: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 822F3C20: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 822F3C24: 2F120000  cmpwi cr6, r18, 0
	ctx.cr[6].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 822F3C28: 409900A8  ble cr6, 0x822f3cd0
	if !ctx.cr[6].gt {
	pc = 0x822F3CD0; continue 'dispatch;
	}
	// 822F3C2C: 3BE100D8  addi r31, r1, 0xd8
	ctx.r[31].s64 = ctx.r[1].s64 + 216;
	pc = 0x822F3C30; continue 'dispatch;
            }
            0x822F3C30 => {
    //   block [0x822F3C30..0x822F3CAC)
	// 822F3C30: 39610064  addi r11, r1, 0x64
	ctx.r[11].s64 = ctx.r[1].s64 + 100;
	// 822F3C34: 92810054  stw r20, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[20].u32 ) };
	// 822F3C38: 3941006C  addi r10, r1, 0x6c
	ctx.r[10].s64 = ctx.r[1].s64 + 108;
	// 822F3C3C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 822F3C40: 92610058  stw r19, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[19].u32 ) };
	// 822F3C44: 3BDFFFF8  addi r30, r31, -8
	ctx.r[30].s64 = ctx.r[31].s64 + -8;
	// 822F3C48: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 822F3C4C: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 822F3C50: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 822F3C54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F3C58: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 822F3C5C: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 822F3C60: 92E10070  stw r23, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[23].u32 ) };
	// 822F3C64: 92E1006C  stw r23, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[23].u32 ) };
	// 822F3C68: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3C6C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3C70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3C74: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3C78: 929FFFFC  stw r20, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[20].u32 ) };
	// 822F3C7C: 927F0000  stw r19, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[19].u32 ) };
	// 822F3C80: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822F3C84: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 822F3C88: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 822F3C8C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 822F3C90: 911F0014  stw r8, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 822F3C94: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 822F3C98: 4BFF9C59  bl 0x822ed8f0
	ctx.lr = 0x822F3C9C;
	sub_822ED8F0(ctx, base);
	// 822F3C9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F3CA0: 419A0020  beq cr6, 0x822f3cc0
	if ctx.cr[6].eq {
	pc = 0x822F3CC0; continue 'dispatch;
	}
	// 822F3CA4: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 822F3CA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x822F3CAC; continue 'dispatch;
            }
            0x822F3CAC => {
    //   block [0x822F3CAC..0x822F3CC0)
	// 822F3CAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3CB0: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 822F3CB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F3CB8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F3CBC: 4200FFF0  bdnz 0x822f3cac
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822F3CAC; continue 'dispatch;
	}
	pc = 0x822F3CC0; continue 'dispatch;
            }
            0x822F3CC0 => {
    //   block [0x822F3CC0..0x822F3CD0)
	// 822F3CC0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822F3CC4: 3BFF0024  addi r31, r31, 0x24
	ctx.r[31].s64 = ctx.r[31].s64 + 36;
	// 822F3CC8: 7F1D9000  cmpw cr6, r29, r18
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[18].s32, &mut ctx.xer);
	// 822F3CCC: 4198FF64  blt cr6, 0x822f3c30
	if ctx.cr[6].lt {
	pc = 0x822F3C30; continue 'dispatch;
	}
	pc = 0x822F3CD0; continue 'dispatch;
            }
            0x822F3CD0 => {
    //   block [0x822F3CD0..0x822F3D08)
	// 822F3CD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F3CD4: 92810084  stw r20, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[20].u32 ) };
	// 822F3CD8: 92610088  stw r19, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[19].u32 ) };
	// 822F3CDC: 7EF5BB78  mr r21, r23
	ctx.r[21].u64 = ctx.r[23].u64;
	// 822F3CE0: 396BC530  addi r11, r11, -0x3ad0
	ctx.r[11].s64 = ctx.r[11].s64 + -15056;
	// 822F3CE4: 9361008C  stw r27, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[27].u32 ) };
	// 822F3CE8: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	// 822F3CEC: 2F0F0000  cmpwi cr6, r15, 0
	ctx.cr[6].compare_i32(ctx.r[15].s32, 0, &mut ctx.xer);
	// 822F3CF0: 92E10094  stw r23, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[23].u32 ) };
	// 822F3CF4: 93610098  stw r27, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[27].u32 ) };
	// 822F3CF8: 9361009C  stw r27, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[27].u32 ) };
	// 822F3CFC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 822F3D00: 409901EC  ble cr6, 0x822f3eec
	if !ctx.cr[6].gt {
	pc = 0x822F3EEC; continue 'dispatch;
	}
	// 822F3D04: 3ADA0080  addi r22, r26, 0x80
	ctx.r[22].s64 = ctx.r[26].s64 + 128;
	pc = 0x822F3D08; continue 'dispatch;
            }
            0x822F3D08 => {
    //   block [0x822F3D08..0x822F3D40)
	// 822F3D08: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 822F3D0C: 92A1008C  stw r21, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[21].u32 ) };
	// 822F3D10: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 822F3D14: 4BFF973D  bl 0x822ed450
	ctx.lr = 0x822F3D18;
	sub_822ED450(ctx, base);
	// 822F3D18: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 822F3D1C: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 822F3D20: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 822F3D24: 4BFF9545  bl 0x822ed268
	ctx.lr = 0x822F3D28;
	sub_822ED268(ctx, base);
	// 822F3D28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F3D2C: 419A01B0  beq cr6, 0x822f3edc
	if ctx.cr[6].eq {
	pc = 0x822F3EDC; continue 'dispatch;
	}
	// 822F3D30: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 822F3D34: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 822F3D38: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 822F3D3C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x822F3D40; continue 'dispatch;
            }
            0x822F3D40 => {
    //   block [0x822F3D40..0x822F3D6C)
	// 822F3D40: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3D44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822F3D48: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822F3D4C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822F3D50: 4200FFF0  bdnz 0x822f3d40
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822F3D40; continue 'dispatch;
	}
	// 822F3D54: 4809926D  bl 0x8238cfc0
	ctx.lr = 0x822F3D58;
	sub_8238CFC0(ctx, base);
	// 822F3D58: 90760000  stw r3, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 822F3D5C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3D64: 419A0008  beq cr6, 0x822f3d6c
	if ctx.cr[6].eq {
	pc = 0x822F3D6C; continue 'dispatch;
	}
	// 822F3D68: 930B000C  stw r24, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	pc = 0x822F3D6C; continue 'dispatch;
            }
            0x822F3D6C => {
    //   block [0x822F3D6C..0x822F3D7C)
	// 822F3D6C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3D74: 419A0008  beq cr6, 0x822f3d7c
	if ctx.cr[6].eq {
	pc = 0x822F3D7C; continue 'dispatch;
	}
	// 822F3D78: 930B0008  stw r24, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	pc = 0x822F3D7C; continue 'dispatch;
            }
            0x822F3D7C => {
    //   block [0x822F3D7C..0x822F3DB8)
	// 822F3D7C: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 822F3D80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F3D84: 40990068  ble cr6, 0x822f3dec
	if !ctx.cr[6].gt {
	pc = 0x822F3DEC; continue 'dispatch;
	}
	// 822F3D88: 817A0208  lwz r11, 0x208(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(520 as u32) ) } as u64;
	// 822F3D8C: 396B0083  addi r11, r11, 0x83
	ctx.r[11].s64 = ctx.r[11].s64 + 131;
	// 822F3D90: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F3D94: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 822F3D98: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F3D9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F3DA0: 409A0018  bne cr6, 0x822f3db8
	if !ctx.cr[6].eq {
	pc = 0x822F3DB8; continue 'dispatch;
	}
	// 822F3DA4: 81560000  lwz r10, 0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3DA8: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 822F3DAC: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822F3DB0: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3DB4: 4819A905  bl 0x8248e6b8
	ctx.lr = 0x822F3DB8;
	sub_8248E6B8(ctx, base);
	pc = 0x822F3DB8; continue 'dispatch;
            }
            0x822F3DB8 => {
    //   block [0x822F3DB8..0x822F3DEC)
	// 822F3DB8: 3D60822F  lis r11, -0x7dd1
	ctx.r[11].s64 = -2110849024;
	// 822F3DBC: 815A0208  lwz r10, 0x208(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(520 as u32) ) } as u64;
	// 822F3DC0: 92E100BC  stw r23, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[23].u32 ) };
	// 822F3DC4: 396B3368  addi r11, r11, 0x3368
	ctx.r[11].s64 = ctx.r[11].s64 + 13160;
	// 822F3DC8: 394A0083  addi r10, r10, 0x83
	ctx.r[10].s64 = ctx.r[10].s64 + 131;
	// 822F3DCC: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 822F3DD0: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F3DD4: E94100B8  ld r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 822F3DD8: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 822F3DDC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 822F3DE0: 817A0208  lwz r11, 0x208(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(520 as u32) ) } as u64;
	// 822F3DE4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822F3DE8: 917A0208  stw r11, 0x208(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	pc = 0x822F3DEC; continue 'dispatch;
            }
            0x822F3DEC => {
    //   block [0x822F3DEC..0x822F3E28)
	// 822F3DEC: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 822F3DF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F3DF4: 4099006C  ble cr6, 0x822f3e60
	if !ctx.cr[6].gt {
	pc = 0x822F3E60; continue 'dispatch;
	}
	// 822F3DF8: 817A0208  lwz r11, 0x208(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(520 as u32) ) } as u64;
	// 822F3DFC: 396B0083  addi r11, r11, 0x83
	ctx.r[11].s64 = ctx.r[11].s64 + 131;
	// 822F3E00: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F3E04: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 822F3E08: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F3E0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F3E10: 409A0018  bne cr6, 0x822f3e28
	if !ctx.cr[6].eq {
	pc = 0x822F3E28; continue 'dispatch;
	}
	// 822F3E14: 81560000  lwz r10, 0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3E18: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 822F3E1C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822F3E20: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3E24: 4819A895  bl 0x8248e6b8
	ctx.lr = 0x822F3E28;
	sub_8248E6B8(ctx, base);
	pc = 0x822F3E28; continue 'dispatch;
            }
            0x822F3E28 => {
    //   block [0x822F3E28..0x822F3E60)
	// 822F3E28: 3D60822F  lis r11, -0x7dd1
	ctx.r[11].s64 = -2110849024;
	// 822F3E2C: 815A0208  lwz r10, 0x208(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(520 as u32) ) } as u64;
	// 822F3E30: 92E100C4  stw r23, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[23].u32 ) };
	// 822F3E34: 396B34D8  addi r11, r11, 0x34d8
	ctx.r[11].s64 = ctx.r[11].s64 + 13528;
	// 822F3E38: 394A0083  addi r10, r10, 0x83
	ctx.r[10].s64 = ctx.r[10].s64 + 131;
	// 822F3E3C: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 822F3E40: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F3E44: E94100C0  ld r10, 0xc0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 822F3E48: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 822F3E4C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 822F3E50: 817A0208  lwz r11, 0x208(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(520 as u32) ) } as u64;
	// 822F3E54: 923A028C  stw r17, 0x28c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(652 as u32), ctx.r[17].u32 ) };
	// 822F3E58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822F3E5C: 917A0208  stw r11, 0x208(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	pc = 0x822F3E60; continue 'dispatch;
            }
            0x822F3E60 => {
    //   block [0x822F3E60..0x822F3E74)
	// 822F3E60: 2F120000  cmpwi cr6, r18, 0
	ctx.cr[6].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 822F3E64: 40990078  ble cr6, 0x822f3edc
	if !ctx.cr[6].gt {
	pc = 0x822F3EDC; continue 'dispatch;
	}
	// 822F3E68: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 822F3E6C: 3BA100E4  addi r29, r1, 0xe4
	ctx.r[29].s64 = ctx.r[1].s64 + 228;
	// 822F3E70: 7E599378  mr r25, r18
	ctx.r[25].u64 = ctx.r[18].u64;
	pc = 0x822F3E74; continue 'dispatch;
            }
            0x822F3E74 => {
    //   block [0x822F3E74..0x822F3E7C)
	// 822F3E74: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 822F3E78: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x822F3E7C; continue 'dispatch;
            }
            0x822F3E7C => {
    //   block [0x822F3E7C..0x822F3EB0)
	// 822F3E7C: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3E80: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822F3E84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3E88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F3E8C: 4E800421  bctrl
	ctx.lr = 0x822F3E90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F3E90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3E94: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 822F3E98: 419A0018  beq cr6, 0x822f3eb0
	if ctx.cr[6].eq {
	pc = 0x822F3EB0; continue 'dispatch;
	}
	// 822F3E9C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822F3EA0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822F3EA4: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 822F3EA8: 4198FFD4  blt cr6, 0x822f3e7c
	if ctx.cr[6].lt {
	pc = 0x822F3E7C; continue 'dispatch;
	}
	// 822F3EAC: 48000018  b 0x822f3ec4
	pc = 0x822F3EC4; continue 'dispatch;
            }
            0x822F3EB0 => {
    //   block [0x822F3EB0..0x822F3EC4)
	// 822F3EB0: 7D7CF214  add r11, r28, r30
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 822F3EB4: 81560000  lwz r10, 0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3EB8: 392100EC  addi r9, r1, 0xec
	ctx.r[9].s64 = ctx.r[1].s64 + 236;
	// 822F3EBC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F3EC0: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	pc = 0x822F3EC4; continue 'dispatch;
            }
            0x822F3EC4 => {
    //   block [0x822F3EC4..0x822F3EDC)
	// 822F3EC4: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 822F3EC8: 3BBD0024  addi r29, r29, 0x24
	ctx.r[29].s64 = ctx.r[29].s64 + 36;
	// 822F3ECC: 3B9C0009  addi r28, r28, 9
	ctx.r[28].s64 = ctx.r[28].s64 + 9;
	// 822F3ED0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822F3ED4: 409AFFA0  bne cr6, 0x822f3e74
	if !ctx.cr[6].eq {
	pc = 0x822F3E74; continue 'dispatch;
	}
	// 822F3ED8: 83210604  lwz r25, 0x604(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1540 as u32) ) } as u64;
	pc = 0x822F3EDC; continue 'dispatch;
            }
            0x822F3EDC => {
    //   block [0x822F3EDC..0x822F3EEC)
	// 822F3EDC: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 822F3EE0: 3AD60004  addi r22, r22, 4
	ctx.r[22].s64 = ctx.r[22].s64 + 4;
	// 822F3EE4: 7F157800  cmpw cr6, r21, r15
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[15].s32, &mut ctx.xer);
	// 822F3EE8: 4198FE20  blt cr6, 0x822f3d08
	if ctx.cr[6].lt {
	pc = 0x822F3D08; continue 'dispatch;
	}
	pc = 0x822F3EEC; continue 'dispatch;
            }
            0x822F3EEC => {
    //   block [0x822F3EEC..0x822F3F00)
	// 822F3EEC: 2F120000  cmpwi cr6, r18, 0
	ctx.cr[6].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 822F3EF0: 40990058  ble cr6, 0x822f3f48
	if !ctx.cr[6].gt {
	pc = 0x822F3F48; continue 'dispatch;
	}
	// 822F3EF4: 3BE100F0  addi r31, r1, 0xf0
	ctx.r[31].s64 = ctx.r[1].s64 + 240;
	// 822F3EF8: 3BDA0188  addi r30, r26, 0x188
	ctx.r[30].s64 = ctx.r[26].s64 + 392;
	// 822F3EFC: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	pc = 0x822F3F00; continue 'dispatch;
            }
            0x822F3F00 => {
    //   block [0x822F3F00..0x822F3F18)
	// 822F3F00: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822F3F04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3F08: 409A0010  bne cr6, 0x822f3f18
	if !ctx.cr[6].eq {
	pc = 0x822F3F18; continue 'dispatch;
	}
	// 822F3F0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3F14: 419A0020  beq cr6, 0x822f3f34
	if ctx.cr[6].eq {
	pc = 0x822F3F34; continue 'dispatch;
	}
	pc = 0x822F3F18; continue 'dispatch;
            }
            0x822F3F18 => {
    //   block [0x822F3F18..0x822F3F34)
	// 822F3F18: 389FFFE0  addi r4, r31, -0x20
	ctx.r[4].s64 = ctx.r[31].s64 + -32;
	// 822F3F1C: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 822F3F20: 4BFF9881  bl 0x822ed7a0
	ctx.lr = 0x822F3F24;
	sub_822ED7A0(ctx, base);
	// 822F3F24: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F3F28: 809FFFFC  lwz r4, -4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822F3F2C: 48099285  bl 0x8238d1b0
	ctx.lr = 0x822F3F30;
	sub_8238D1B0(ctx, base);
	// 822F3F30: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x822F3F34; continue 'dispatch;
            }
            0x822F3F34 => {
    //   block [0x822F3F34..0x822F3F48)
	// 822F3F34: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 822F3F38: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F3F3C: 3BFF0024  addi r31, r31, 0x24
	ctx.r[31].s64 = ctx.r[31].s64 + 36;
	// 822F3F40: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822F3F44: 409AFFBC  bne cr6, 0x822f3f00
	if !ctx.cr[6].eq {
	pc = 0x822F3F00; continue 'dispatch;
	}
	pc = 0x822F3F48; continue 'dispatch;
            }
            0x822F3F48 => {
    //   block [0x822F3F48..0x822F3F90)
	// 822F3F48: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F3F4C: 925A0184  stw r18, 0x184(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(388 as u32), ctx.r[18].u32 ) };
	// 822F3F50: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 822F3F54: 928100A4  stw r20, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[20].u32 ) };
	// 822F3F58: 396BC548  addi r11, r11, -0x3ab8
	ctx.r[11].s64 = ctx.r[11].s64 + -15032;
	// 822F3F5C: 926100A8  stw r19, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[19].u32 ) };
	// 822F3F60: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 822F3F64: 92E100AC  stw r23, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[23].u32 ) };
	// 822F3F68: 936100B0  stw r27, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u32 ) };
	// 822F3F6C: 92E100B4  stw r23, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[23].u32 ) };
	// 822F3F70: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 822F3F74: 4BFF961D  bl 0x822ed590
	ctx.lr = 0x822F3F78;
	sub_822ED590(ctx, base);
	// 822F3F78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F3F7C: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 822F3F80: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822F3F84: 93BA0100  stw r29, 0x100(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(256 as u32), ctx.r[29].u32 ) };
	// 822F3F88: 40990068  ble cr6, 0x822f3ff0
	if !ctx.cr[6].gt {
	pc = 0x822F3FF0; continue 'dispatch;
	}
	// 822F3F8C: 3B9A0104  addi r28, r26, 0x104
	ctx.r[28].s64 = ctx.r[26].s64 + 260;
	pc = 0x822F3F90; continue 'dispatch;
            }
            0x822F3F90 => {
    //   block [0x822F3F90..0x822F3FD0)
	// 822F3F90: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 822F3F94: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 822F3F98: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 822F3F9C: 4BFF94B5  bl 0x822ed450
	ctx.lr = 0x822F3FA0;
	sub_822ED450(ctx, base);
	// 822F3FA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F3FA4: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 822F3FA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F3FAC: 4BFF92BD  bl 0x822ed268
	ctx.lr = 0x822F3FB0;
	sub_822ED268(ctx, base);
	// 822F3FB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F3FB4: 419A002C  beq cr6, 0x822f3fe0
	if ctx.cr[6].eq {
	pc = 0x822F3FE0; continue 'dispatch;
	}
	// 822F3FB8: 48099009  bl 0x8238cfc0
	ctx.lr = 0x822F3FBC;
	sub_8238CFC0(ctx, base);
	// 822F3FBC: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 822F3FC0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F3FC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3FC8: 419A0008  beq cr6, 0x822f3fd0
	if ctx.cr[6].eq {
	pc = 0x822F3FD0; continue 'dispatch;
	}
	// 822F3FCC: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	pc = 0x822F3FD0; continue 'dispatch;
            }
            0x822F3FD0 => {
    //   block [0x822F3FD0..0x822F3FE0)
	// 822F3FD0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3FD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F3FD8: 419A0008  beq cr6, 0x822f3fe0
	if ctx.cr[6].eq {
	pc = 0x822F3FE0; continue 'dispatch;
	}
	// 822F3FDC: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x822F3FE0; continue 'dispatch;
            }
            0x822F3FE0 => {
    //   block [0x822F3FE0..0x822F3FF0)
	// 822F3FE0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822F3FE4: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 822F3FE8: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 822F3FEC: 4198FFA4  blt cr6, 0x822f3f90
	if ctx.cr[6].lt {
	pc = 0x822F3F90; continue 'dispatch;
	}
	pc = 0x822F3FF0; continue 'dispatch;
            }
            0x822F3FF0 => {
    //   block [0x822F3FF0..0x822F4010)
	// 822F3FF0: 2F0E0000  cmpwi cr6, r14, 0
	ctx.cr[6].compare_i32(ctx.r[14].s32, 0, &mut ctx.xer);
	// 822F3FF4: 419A00E0  beq cr6, 0x822f40d4
	if ctx.cr[6].eq {
	pc = 0x822F40D4; continue 'dispatch;
	}
	// 822F3FF8: 39390080  addi r9, r25, 0x80
	ctx.r[9].s64 = ctx.r[25].s64 + 128;
	// 822F3FFC: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4004: 409A000C  bne cr6, 0x822f4010
	if !ctx.cr[6].eq {
	pc = 0x822F4010; continue 'dispatch;
	}
	// 822F4008: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822F400C: 4800002C  b 0x822f4038
	pc = 0x822F4038; continue 'dispatch;
            }
            0x822F4010 => {
    //   block [0x822F4010..0x822F4028)
	// 822F4010: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4014: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4018: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822F401C: 419A000C  beq cr6, 0x822f4028
	if ctx.cr[6].eq {
	pc = 0x822F4028; continue 'dispatch;
	}
	// 822F4020: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822F4024: 48000014  b 0x822f4038
	pc = 0x822F4038; continue 'dispatch;
            }
            0x822F4028 => {
    //   block [0x822F4028..0x822F4038)
	// 822F4028: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F402C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F4030: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F4034: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F4038; continue 'dispatch;
            }
            0x822F4038 => {
    //   block [0x822F4038..0x822F4058)
	// 822F4038: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F403C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4040: 419A0094  beq cr6, 0x822f40d4
	if ctx.cr[6].eq {
	pc = 0x822F40D4; continue 'dispatch;
	}
	// 822F4044: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4048: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F404C: 409A000C  bne cr6, 0x822f4058
	if !ctx.cr[6].eq {
	pc = 0x822F4058; continue 'dispatch;
	}
	// 822F4050: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822F4054: 4800002C  b 0x822f4080
	pc = 0x822F4080; continue 'dispatch;
            }
            0x822F4058 => {
    //   block [0x822F4058..0x822F4070)
	// 822F4058: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F405C: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4060: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F4064: 419A000C  beq cr6, 0x822f4070
	if ctx.cr[6].eq {
	pc = 0x822F4070; continue 'dispatch;
	}
	// 822F4068: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822F406C: 48000014  b 0x822f4080
	pc = 0x822F4080; continue 'dispatch;
            }
            0x822F4070 => {
    //   block [0x822F4070..0x822F4080)
	// 822F4070: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4074: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F4078: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F407C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F4080; continue 'dispatch;
            }
            0x822F4080 => {
    //   block [0x822F4080..0x822F4094)
	// 822F4080: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F4084: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 822F4088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F408C: 419A0008  beq cr6, 0x822f4094
	if ctx.cr[6].eq {
	pc = 0x822F4094; continue 'dispatch;
	}
	// 822F4090: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822F4094; continue 'dispatch;
            }
            0x822F4094 => {
    //   block [0x822F4094..0x822F40B0)
	// 822F4094: 4BFF909D  bl 0x822ed130
	ctx.lr = 0x822F4098;
	sub_822ED130(ctx, base);
	// 822F4098: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F409C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F40A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F40A4: 40990030  ble cr6, 0x822f40d4
	if !ctx.cr[6].gt {
	pc = 0x822F40D4; continue 'dispatch;
	}
	// 822F40A8: 3BFF0080  addi r31, r31, 0x80
	ctx.r[31].s64 = ctx.r[31].s64 + 128;
	// 822F40AC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	pc = 0x822F40B0; continue 'dispatch;
            }
            0x822F40B0 => {
    //   block [0x822F40B0..0x822F40C4)
	// 822F40B0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F40B4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822F40B8: 419A000C  beq cr6, 0x822f40c4
	if ctx.cr[6].eq {
	pc = 0x822F40C4; continue 'dispatch;
	}
	// 822F40BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F40C0: 4BFF9C79  bl 0x822edd38
	ctx.lr = 0x822F40C4;
	sub_822EDD38(ctx, base);
	pc = 0x822F40C4; continue 'dispatch;
            }
            0x822F40C4 => {
    //   block [0x822F40C4..0x822F40D4)
	// 822F40C4: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 822F40C8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822F40CC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822F40D0: 409AFFE0  bne cr6, 0x822f40b0
	if !ctx.cr[6].eq {
	pc = 0x822F40B0; continue 'dispatch;
	}
	pc = 0x822F40D4; continue 'dispatch;
            }
            0x822F40D4 => {
    //   block [0x822F40D4..0x822F40E0)
	// 822F40D4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 822F40D8: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 822F40DC: 4BFF9A65  bl 0x822edb40
	ctx.lr = 0x822F40E0;
	sub_822EDB40(ctx, base);
	pc = 0x822F40E0; continue 'dispatch;
            }
            0x822F40E0 => {
    //   block [0x822F40E0..0x822F40EC)
	// 822F40E0: 382105F0  addi r1, r1, 0x5f0
	ctx.r[1].s64 = ctx.r[1].s64 + 1520;
	// 822F40E4: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 822F40E8: 48240FE8  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F40F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F40F0 size=252
    let mut pc: u32 = 0x822F40F0;
    'dispatch: loop {
        match pc {
            0x822F40F0 => {
    //   block [0x822F40F0..0x822F4124)
	// 822F40F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F40F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F40F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F40FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F4100: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F4104: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822F4108: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F410C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F4110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4114: 409A0010  bne cr6, 0x822f4124
	if !ctx.cr[6].eq {
	pc = 0x822F4124; continue 'dispatch;
	}
	// 822F4118: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F411C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4120: 419A0010  beq cr6, 0x822f4130
	if ctx.cr[6].eq {
	pc = 0x822F4130; continue 'dispatch;
	}
	pc = 0x822F4124; continue 'dispatch;
            }
            0x822F4124 => {
    //   block [0x822F4124..0x822F4130)
	// 822F4124: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F4128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F412C: 480000C5  bl 0x822f41f0
	ctx.lr = 0x822F4130;
	sub_822F41F0(ctx, base);
	pc = 0x822F4130; continue 'dispatch;
            }
            0x822F4130 => {
    //   block [0x822F4130..0x822F4144)
	// 822F4130: 817E00C4  lwz r11, 0xc4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
	// 822F4134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4138: 419A000C  beq cr6, 0x822f4144
	if ctx.cr[6].eq {
	pc = 0x822F4144; continue 'dispatch;
	}
	// 822F413C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F4140: 4BFFF7F1  bl 0x822f3930
	ctx.lr = 0x822F4144;
	sub_822F3930(ctx, base);
	pc = 0x822F4144; continue 'dispatch;
            }
            0x822F4144 => {
    //   block [0x822F4144..0x822F415C)
	// 822F4144: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F4148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F414C: 419A0010  beq cr6, 0x822f415c
	if ctx.cr[6].eq {
	pc = 0x822F415C; continue 'dispatch;
	}
	// 822F4150: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F4154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F4158: 48000239  bl 0x822f4390
	ctx.lr = 0x822F415C;
	sub_822F4390(ctx, base);
	pc = 0x822F415C; continue 'dispatch;
            }
            0x822F415C => {
    //   block [0x822F415C..0x822F4190)
	// 822F415C: 817E00EC  lwz r11, 0xec(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 822F4160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4164: 419A0070  beq cr6, 0x822f41d4
	if ctx.cr[6].eq {
	pc = 0x822F41D4; continue 'dispatch;
	}
	// 822F4168: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 822F416C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4174: 419A002C  beq cr6, 0x822f41a0
	if ctx.cr[6].eq {
	pc = 0x822F41A0; continue 'dispatch;
	}
	// 822F4178: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F417C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4180: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F4184: 419A000C  beq cr6, 0x822f4190
	if ctx.cr[6].eq {
	pc = 0x822F4190; continue 'dispatch;
	}
	// 822F4188: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F418C: 48000014  b 0x822f41a0
	pc = 0x822F41A0; continue 'dispatch;
            }
            0x822F4190 => {
    //   block [0x822F4190..0x822F41A0)
	// 822F4190: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4194: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F4198: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F419C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F41A0; continue 'dispatch;
            }
            0x822F41A0 => {
    //   block [0x822F41A0..0x822F41D4)
	// 822F41A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F41A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F41A8: 419A002C  beq cr6, 0x822f41d4
	if ctx.cr[6].eq {
	pc = 0x822F41D4; continue 'dispatch;
	}
	// 822F41AC: 4BF3923D  bl 0x8222d3e8
	ctx.lr = 0x822F41B0;
	sub_8222D3E8(ctx, base);
	// 822F41B0: 81630064  lwz r11, 0x64(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 822F41B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F41B8: 419A001C  beq cr6, 0x822f41d4
	if ctx.cr[6].eq {
	pc = 0x822F41D4; continue 'dispatch;
	}
	// 822F41BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822F41C0: C0030074  lfs f0, 0x74(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F41C4: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 822F41C8: C1BE00F0  lfs f13, 0xf0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F41CC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 822F41D0: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	pc = 0x822F41D4; continue 'dispatch;
            }
            0x822F41D4 => {
    //   block [0x822F41D4..0x822F41EC)
	// 822F41D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F41D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F41DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F41E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F41E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F41E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F41F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F41F0 size=416
    let mut pc: u32 = 0x822F41F0;
    'dispatch: loop {
        match pc {
            0x822F41F0 => {
    //   block [0x822F41F0..0x822F4220)
	// 822F41F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F41F4: 48240EB5  bl 0x825350a8
	ctx.lr = 0x822F41F8;
	sub_82535080(ctx, base);
	// 822F41F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F41FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F4200: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 822F4204: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 822F4208: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822F420C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4214: 409A000C  bne cr6, 0x822f4220
	if !ctx.cr[6].eq {
	pc = 0x822F4220; continue 'dispatch;
	}
	// 822F4218: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 822F421C: 4800002C  b 0x822f4248
	pc = 0x822F4248; continue 'dispatch;
            }
            0x822F4220 => {
    //   block [0x822F4220..0x822F4238)
	// 822F4220: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4224: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4228: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F422C: 419A000C  beq cr6, 0x822f4238
	if ctx.cr[6].eq {
	pc = 0x822F4238; continue 'dispatch;
	}
	// 822F4230: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 822F4234: 48000014  b 0x822f4248
	pc = 0x822F4248; continue 'dispatch;
            }
            0x822F4238 => {
    //   block [0x822F4238..0x822F4248)
	// 822F4238: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F423C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F4240: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F4244: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F4248; continue 'dispatch;
            }
            0x822F4248 => {
    //   block [0x822F4248..0x822F42A4)
	// 822F4248: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F424C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4250: 419A0138  beq cr6, 0x822f4388
	if ctx.cr[6].eq {
	pc = 0x822F4388; continue 'dispatch;
	}
	// 822F4254: 4BF39195  bl 0x8222d3e8
	ctx.lr = 0x822F4258;
	sub_8222D3E8(ctx, base);
	// 822F4258: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F425C: 4BFF8ED5  bl 0x822ed130
	ctx.lr = 0x822F4260;
	sub_822ED130(ctx, base);
	// 822F4260: 81780014  lwz r11, 0x14(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F4264: 815E0068  lwz r10, 0x68(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 822F4268: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 822F426C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822F4270: 419A00A8  beq cr6, 0x822f4318
	if ctx.cr[6].eq {
	pc = 0x822F4318; continue 'dispatch;
	}
	// 822F4274: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F4278: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F427C: 419A010C  beq cr6, 0x822f4388
	if ctx.cr[6].eq {
	pc = 0x822F4388; continue 'dispatch;
	}
	// 822F4280: 817800C0  lwz r11, 0xc0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(192 as u32) ) } as u64;
	// 822F4284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4288: 419A0100  beq cr6, 0x822f4388
	if ctx.cr[6].eq {
	pc = 0x822F4388; continue 'dispatch;
	}
	// 822F428C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4290: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 822F4294: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F4298: 409900F0  ble cr6, 0x822f4388
	if !ctx.cr[6].gt {
	pc = 0x822F4388; continue 'dispatch;
	}
	// 822F429C: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 822F42A0: 3BFE0080  addi r31, r30, 0x80
	ctx.r[31].s64 = ctx.r[30].s64 + 128;
	pc = 0x822F42A4; continue 'dispatch;
            }
            0x822F42A4 => {
    //   block [0x822F42A4..0x822F42EC)
	// 822F42A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F42A8: 815800C0  lwz r10, 0xc0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(192 as u32) ) } as u64;
	// 822F42AC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822F42B0: 409A0048  bne cr6, 0x822f42f8
	if !ctx.cr[6].eq {
	pc = 0x822F42F8; continue 'dispatch;
	}
	// 822F42B4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F42B8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F42BC: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 822F42C0: 936B003C  stw r27, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[27].u32 ) };
	// 822F42C4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F42C8: 4BFF9B31  bl 0x822eddf8
	ctx.lr = 0x822F42CC;
	sub_822EDDF8(ctx, base);
	// 822F42CC: 83BF018C  lwz r29, 0x18c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 822F42D0: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F42D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F42D8: 419A0014  beq cr6, 0x822f42ec
	if ctx.cr[6].eq {
	pc = 0x822F42EC; continue 'dispatch;
	}
	// 822F42DC: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 822F42E0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F42E4: 48199E85  bl 0x8248e168
	ctx.lr = 0x822F42E8;
	sub_8248E168(ctx, base);
	// 822F42E8: 937D000C  stw r27, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	pc = 0x822F42EC; continue 'dispatch;
            }
            0x822F42EC => {
    //   block [0x822F42EC..0x822F42F8)
	// 822F42EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F42F0: 48098E71  bl 0x8238d160
	ctx.lr = 0x822F42F4;
	sub_8238D160(ctx, base);
	// 822F42F4: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x822F42F8; continue 'dispatch;
            }
            0x822F42F8 => {
    //   block [0x822F42F8..0x822F4318)
	// 822F42F8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F42FC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 822F4300: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822F4304: 3B9C0040  addi r28, r28, 0x40
	ctx.r[28].s64 = ctx.r[28].s64 + 64;
	// 822F4308: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F430C: 4198FF98  blt cr6, 0x822f42a4
	if ctx.cr[6].lt {
	pc = 0x822F42A4; continue 'dispatch;
	}
	// 822F4310: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822F4314: 48240DE4  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x822F4318 => {
    //   block [0x822F4318..0x822F4360)
	// 822F4318: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 822F431C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4320: 409A0068  bne cr6, 0x822f4388
	if !ctx.cr[6].eq {
	pc = 0x822F4388; continue 'dispatch;
	}
	// 822F4324: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822F4328: 817E0070  lwz r11, 0x70(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 822F432C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822F4330: 915E0064  stw r10, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822F4334: 4198002C  blt cr6, 0x822f4360
	if ctx.cr[6].lt {
	pc = 0x822F4360; continue 'dispatch;
	}
	// 822F4338: 409A0050  bne cr6, 0x822f4388
	if !ctx.cr[6].eq {
	pc = 0x822F4388; continue 'dispatch;
	}
	// 822F433C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822F4340: 915E0064  stw r10, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822F4344: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 822F4348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F434C: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F4350: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822F4354: 4800023D  bl 0x822f4590
	ctx.lr = 0x822F4358;
	sub_822F4590(ctx, base);
	// 822F4358: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822F435C: 48240D9C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x822F4360 => {
    //   block [0x822F4360..0x822F4388)
	// 822F4360: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F4364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F4368: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F436C: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822F4370: 480004D9  bl 0x822f4848
	ctx.lr = 0x822F4374;
	sub_822F4848(ctx, base);
	// 822F4374: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F4378: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F437C: 80BE006C  lwz r5, 0x6c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 822F4380: 809E0068  lwz r4, 0x68(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 822F4384: 4BFFA38D  bl 0x822ee710
	ctx.lr = 0x822F4388;
	sub_822EE710(ctx, base);
	pc = 0x822F4388; continue 'dispatch;
            }
            0x822F4388 => {
    //   block [0x822F4388..0x822F4390)
	// 822F4388: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822F438C: 48240D6C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F4390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F4390 size=512
    let mut pc: u32 = 0x822F4390;
    'dispatch: loop {
        match pc {
            0x822F4390 => {
    //   block [0x822F4390..0x822F43CC)
	// 822F4390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F4394: 48240D19  bl 0x825350ac
	ctx.lr = 0x822F4398;
	sub_82535080(ctx, base);
	// 822F4398: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 822F439C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F43A0: 38630080  addi r3, r3, 0x80
	ctx.r[3].s64 = ctx.r[3].s64 + 128;
	// 822F43A4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 822F43A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F43AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F43B0: 419A002C  beq cr6, 0x822f43dc
	if ctx.cr[6].eq {
	pc = 0x822F43DC; continue 'dispatch;
	}
	// 822F43B4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F43B8: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F43BC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F43C0: 419A000C  beq cr6, 0x822f43cc
	if ctx.cr[6].eq {
	pc = 0x822F43CC; continue 'dispatch;
	}
	// 822F43C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F43C8: 48000014  b 0x822f43dc
	pc = 0x822F43DC; continue 'dispatch;
            }
            0x822F43CC => {
    //   block [0x822F43CC..0x822F43DC)
	// 822F43CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F43D0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F43D4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F43D8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F43DC; continue 'dispatch;
            }
            0x822F43DC => {
    //   block [0x822F43DC..0x822F4548)
	// 822F43DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F43E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F43E4: 419A01A0  beq cr6, 0x822f4584
	if ctx.cr[6].eq {
	pc = 0x822F4584; continue 'dispatch;
	}
	// 822F43E8: 4BF39001  bl 0x8222d3e8
	ctx.lr = 0x822F43EC;
	sub_8222D3E8(ctx, base);
	// 822F43EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F43F0: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F43F4: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 822F43F8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F43FC: 409A0188  bne cr6, 0x822f4584
	if !ctx.cr[6].eq {
	pc = 0x822F4584; continue 'dispatch;
	}
	// 822F4400: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 822F4404: 815B0018  lwz r10, 0x18(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F4408: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822F440C: 409A0178  bne cr6, 0x822f4584
	if !ctx.cr[6].eq {
	pc = 0x822F4584; continue 'dispatch;
	}
	// 822F4410: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 822F4414: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822F4418: 409A016C  bne cr6, 0x822f4584
	if !ctx.cr[6].eq {
	pc = 0x822F4584; continue 'dispatch;
	}
	// 822F441C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4420: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 822F4424: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F4428: 40990138  ble cr6, 0x822f4560
	if !ctx.cr[6].gt {
	pc = 0x822F4560; continue 'dispatch;
	}
	// 822F442C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822F4430: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F4434: 3B5F0080  addi r26, r31, 0x80
	ctx.r[26].s64 = ctx.r[31].s64 + 128;
	// 822F4438: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 822F443C: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 822F4440: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822F4444: 80FA0000  lwz r7, 0(r26)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4448: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822F444C: 419A00FC  beq cr6, 0x822f4548
	if ctx.cr[6].eq {
	pc = 0x822F4548; continue 'dispatch;
	}
	// 822F4450: 389B0080  addi r4, r27, 0x80
	ctx.r[4].s64 = ctx.r[27].s64 + 128;
	// 822F4454: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F4458: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 822F445C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822F4460: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 822F4464: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 822F4468: C0040030  lfs f0, 0x30(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F446C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822F4470: C0040034  lfs f0, 0x34(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F4474: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822F4478: C0040038  lfs f0, 0x38(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F447C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822F4480: C00B0030  lfs f0, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F4484: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822F4488: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F448C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822F4490: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F4494: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 822F4498: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	pc = 0x822F4548; continue 'dispatch;
            }
            0x822F4548 => {
    //   block [0x822F4548..0x822F4560)
	// 822F4548: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F454C: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 822F4550: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 822F4554: 3BDE0040  addi r30, r30, 0x40
	ctx.r[30].s64 = ctx.r[30].s64 + 64;
	// 822F4558: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F455C: 4198FEE8  blt cr6, 0x822f4444
	if ctx.cr[6].lt {
	pc = 0x822F4444; continue 'dispatch;
	}
	pc = 0x822F4560; continue 'dispatch;
            }
            0x822F4560 => {
    //   block [0x822F4560..0x822F4584)
	// 822F4560: 397B0080  addi r11, r27, 0x80
	ctx.r[11].s64 = ctx.r[27].s64 + 128;
	// 822F4564: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 822F4568: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 822F456C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822F4570: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822F4574: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822F4578: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822F457C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822F4580: 4200FFF0  bdnz 0x822f4570
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822F4570; continue 'dispatch;
	}
	pc = 0x822F4584; continue 'dispatch;
            }
            0x822F4584 => {
    //   block [0x822F4584..0x822F4590)
	// 822F4584: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 822F4588: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 822F458C: 48240B70  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F4590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F4590 size=696
    let mut pc: u32 = 0x822F4590;
    'dispatch: loop {
        match pc {
            0x822F4590 => {
    //   block [0x822F4590..0x822F45C8)
	// 822F4590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F4594: 48240B19  bl 0x825350ac
	ctx.lr = 0x822F4598;
	sub_82535080(ctx, base);
	// 822F4598: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F459C: 38630080  addi r3, r3, 0x80
	ctx.r[3].s64 = ctx.r[3].s64 + 128;
	// 822F45A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822F45A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F45A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F45AC: 419A002C  beq cr6, 0x822f45d8
	if ctx.cr[6].eq {
	pc = 0x822F45D8; continue 'dispatch;
	}
	// 822F45B0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F45B4: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F45B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F45BC: 419A000C  beq cr6, 0x822f45c8
	if ctx.cr[6].eq {
	pc = 0x822F45C8; continue 'dispatch;
	}
	// 822F45C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F45C4: 48000014  b 0x822f45d8
	pc = 0x822F45D8; continue 'dispatch;
            }
            0x822F45C8 => {
    //   block [0x822F45C8..0x822F45D8)
	// 822F45C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F45CC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F45D0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F45D4: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F45D8; continue 'dispatch;
            }
            0x822F45D8 => {
    //   block [0x822F45D8..0x822F474C)
	// 822F45D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F45DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F45E0: 419A0260  beq cr6, 0x822f4840
	if ctx.cr[6].eq {
	pc = 0x822F4840; continue 'dispatch;
	}
	// 822F45E4: 4BF38E05  bl 0x8222d3e8
	ctx.lr = 0x822F45E8;
	sub_8222D3E8(ctx, base);
	// 822F45E8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822F45EC: 4BFF8B45  bl 0x822ed130
	ctx.lr = 0x822F45F0;
	sub_822ED130(ctx, base);
	// 822F45F0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F45F4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 822F45F8: 3B600020  li r27, 0x20
	ctx.r[27].s64 = 32;
	// 822F45FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F4600: 40990168  ble cr6, 0x822f4768
	if !ctx.cr[6].gt {
	pc = 0x822F4768; continue 'dispatch;
	}
	// 822F4604: 3BFA0080  addi r31, r26, 0x80
	ctx.r[31].s64 = ctx.r[26].s64 + 128;
	// 822F4608: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822F460C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4610: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822F4614: 419A0144  beq cr6, 0x822f4758
	if ctx.cr[6].eq {
	pc = 0x822F4758; continue 'dispatch;
	}
	// 822F4618: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F461C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4620: 419A012C  beq cr6, 0x822f474c
	if ctx.cr[6].eq {
	pc = 0x822F474C; continue 'dispatch;
	}
	// 822F4624: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F4628: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822F462C: C07D0048  lfs f3, 0x48(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822F4630: C05D0044  lfs f2, 0x44(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822F4634: C03D0040  lfs f1, 0x40(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822F4638: C00B0110  lfs f0, 0x110(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F463C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822F4640: C00B0114  lfs f0, 0x114(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F4644: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822F4648: C00B0118  lfs f0, 0x118(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F464C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822F4650: C00B011C  lfs f0, 0x11c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F4654: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822F4658: 48073BC1  bl 0x82368218
	ctx.lr = 0x822F465C;
	sub_82368218(ctx, base);
	// 822F465C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822F4660: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x822F474C; continue 'dispatch;
            }
            0x822F474C => {
    //   block [0x822F474C..0x822F4758)
	// 822F474C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F4750: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4754: 4BFF95E5  bl 0x822edd38
	ctx.lr = 0x822F4758;
	sub_822EDD38(ctx, base);
	pc = 0x822F4758; continue 'dispatch;
            }
            0x822F4758 => {
    //   block [0x822F4758..0x822F4768)
	// 822F4758: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 822F475C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822F4760: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 822F4764: 409AFEA8  bne cr6, 0x822f460c
	if !ctx.cr[6].eq {
	pc = 0x822F460C; continue 'dispatch;
	}
	pc = 0x822F4768; continue 'dispatch;
            }
            0x822F4768 => {
    //   block [0x822F4768..0x822F4840)
	// 822F4768: 817A0100  lwz r11, 0x100(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(256 as u32) ) } as u64;
	// 822F476C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F4770: 4099009C  ble cr6, 0x822f480c
	if !ctx.cr[6].gt {
	pc = 0x822F480C; continue 'dispatch;
	}
	// 822F4774: 3BFA0104  addi r31, r26, 0x104
	ctx.r[31].s64 = ctx.r[26].s64 + 260;
	// 822F4778: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 822F477C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4780: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F4784: 419A0078  beq cr6, 0x822f47fc
	if ctx.cr[6].eq {
	pc = 0x822F47FC; continue 'dispatch;
	}
	// 822F4788: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F478C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4790: 419A0060  beq cr6, 0x822f47f0
	if ctx.cr[6].eq {
	pc = 0x822F47F0; continue 'dispatch;
	}
	// 822F4794: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F4798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F479C: 419A0054  beq cr6, 0x822f47f0
	if ctx.cr[6].eq {
	pc = 0x822F47F0; continue 'dispatch;
	}
	// 822F47A0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F47A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F47A8: 409A0048  bne cr6, 0x822f47f0
	if !ctx.cr[6].eq {
	pc = 0x822F47F0; continue 'dispatch;
	}
	// 822F47AC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x822F4840; continue 'dispatch;
            }
            0x822F4840 => {
    //   block [0x822F4840..0x822F4848)
	// 822F4840: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822F4844: 482408B8  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F4848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F4848 size=520
    let mut pc: u32 = 0x822F4848;
    'dispatch: loop {
        match pc {
            0x822F4848 => {
    //   block [0x822F4848..0x822F4870)
	// 822F4848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F484C: 48240861  bl 0x825350ac
	ctx.lr = 0x822F4850;
	sub_82535080(ctx, base);
	// 822F4850: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F4854: 38630080  addi r3, r3, 0x80
	ctx.r[3].s64 = ctx.r[3].s64 + 128;
	// 822F4858: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 822F485C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4864: 409A000C  bne cr6, 0x822f4870
	if !ctx.cr[6].eq {
	pc = 0x822F4870; continue 'dispatch;
	}
	// 822F4868: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822F486C: 4800002C  b 0x822f4898
	pc = 0x822F4898; continue 'dispatch;
            }
            0x822F4870 => {
    //   block [0x822F4870..0x822F4888)
	// 822F4870: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4874: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4878: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F487C: 419A000C  beq cr6, 0x822f4888
	if ctx.cr[6].eq {
	pc = 0x822F4888; continue 'dispatch;
	}
	// 822F4880: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822F4884: 48000014  b 0x822f4898
	pc = 0x822F4898; continue 'dispatch;
            }
            0x822F4888 => {
    //   block [0x822F4888..0x822F4898)
	// 822F4888: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F488C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F4890: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F4894: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F4898; continue 'dispatch;
            }
            0x822F4898 => {
    //   block [0x822F4898..0x822F48C8)
	// 822F4898: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F489C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F48A0: 419A01A8  beq cr6, 0x822f4a48
	if ctx.cr[6].eq {
	pc = 0x822F4A48; continue 'dispatch;
	}
	// 822F48A4: 4BF38B45  bl 0x8222d3e8
	ctx.lr = 0x822F48A8;
	sub_8222D3E8(ctx, base);
	// 822F48A8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822F48AC: 4BFF8885  bl 0x822ed130
	ctx.lr = 0x822F48B0;
	sub_822ED130(ctx, base);
	// 822F48B0: 817C0208  lwz r11, 0x208(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(520 as u32) ) } as u64;
	// 822F48B4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822F48B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F48BC: 40990044  ble cr6, 0x822f4900
	if !ctx.cr[6].gt {
	pc = 0x822F4900; continue 'dispatch;
	}
	// 822F48C0: 3BDC020C  addi r30, r28, 0x20c
	ctx.r[30].s64 = ctx.r[28].s64 + 524;
	// 822F48C4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x822F48C8; continue 'dispatch;
            }
            0x822F48C8 => {
    //   block [0x822F48C8..0x822F48F0)
	// 822F48C8: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F48CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F48D0: 419A0020  beq cr6, 0x822f48f0
	if ctx.cr[6].eq {
	pc = 0x822F48F0; continue 'dispatch;
	}
	// 822F48D4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F48D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F48DC: 419A0014  beq cr6, 0x822f48f0
	if ctx.cr[6].eq {
	pc = 0x822F48F0; continue 'dispatch;
	}
	// 822F48E0: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 822F48E4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F48E8: 48199881  bl 0x8248e168
	ctx.lr = 0x822F48EC;
	sub_8248E168(ctx, base);
	// 822F48EC: 933F000C  stw r25, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	pc = 0x822F48F0; continue 'dispatch;
            }
            0x822F48F0 => {
    //   block [0x822F48F0..0x822F4900)
	// 822F48F0: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 822F48F4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F48F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822F48FC: 409AFFCC  bne cr6, 0x822f48c8
	if !ctx.cr[6].eq {
	pc = 0x822F48C8; continue 'dispatch;
	}
	pc = 0x822F4900; continue 'dispatch;
            }
            0x822F4900 => {
    //   block [0x822F4900..0x822F491C)
	// 822F4900: 817C0184  lwz r11, 0x184(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(388 as u32) ) } as u64;
	// 822F4904: 3F608273  lis r27, -0x7d8d
	ctx.r[27].s64 = -2106392576;
	// 822F4908: 933C0208  stw r25, 0x208(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(520 as u32), ctx.r[25].u32 ) };
	// 822F490C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F4910: 40990060  ble cr6, 0x822f4970
	if !ctx.cr[6].gt {
	pc = 0x822F4970; continue 'dispatch;
	}
	// 822F4914: 3BDC0188  addi r30, r28, 0x188
	ctx.r[30].s64 = ctx.r[28].s64 + 392;
	// 822F4918: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x822F491C; continue 'dispatch;
            }
            0x822F491C => {
    //   block [0x822F491C..0x822F495C)
	// 822F491C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4920: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822F4924: 419A0038  beq cr6, 0x822f495c
	if ctx.cr[6].eq {
	pc = 0x822F495C; continue 'dispatch;
	}
	// 822F4928: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822F492C: 4BFF965D  bl 0x822edf88
	ctx.lr = 0x822F4930;
	sub_822EDF88(ctx, base);
	// 822F4930: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4934: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822F4938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F493C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4940: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4944: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F4948: 4E800421  bctrl
	ctx.lr = 0x822F494C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F494C: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822F4950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F4954: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F4958: 4E800421  bctrl
	ctx.lr = 0x822F495C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822F495C => {
    //   block [0x822F495C..0x822F4970)
	// 822F495C: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 822F4960: 933E0000  stw r25, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822F4964: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F4968: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822F496C: 409AFFB0  bne cr6, 0x822f491c
	if !ctx.cr[6].eq {
	pc = 0x822F491C; continue 'dispatch;
	}
	pc = 0x822F4970; continue 'dispatch;
            }
            0x822F4970 => {
    //   block [0x822F4970..0x822F4988)
	// 822F4970: 817C0100  lwz r11, 0x100(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(256 as u32) ) } as u64;
	// 822F4974: 933C0184  stw r25, 0x184(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(388 as u32), ctx.r[25].u32 ) };
	// 822F4978: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F497C: 40990060  ble cr6, 0x822f49dc
	if !ctx.cr[6].gt {
	pc = 0x822F49DC; continue 'dispatch;
	}
	// 822F4980: 3BDC0104  addi r30, r28, 0x104
	ctx.r[30].s64 = ctx.r[28].s64 + 260;
	// 822F4984: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x822F4988; continue 'dispatch;
            }
            0x822F4988 => {
    //   block [0x822F4988..0x822F49C8)
	// 822F4988: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F498C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822F4990: 419A0038  beq cr6, 0x822f49c8
	if ctx.cr[6].eq {
	pc = 0x822F49C8; continue 'dispatch;
	}
	// 822F4994: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822F4998: 4BFF9461  bl 0x822eddf8
	ctx.lr = 0x822F499C;
	sub_822EDDF8(ctx, base);
	// 822F499C: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F49A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822F49A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F49A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F49AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F49B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F49B4: 4E800421  bctrl
	ctx.lr = 0x822F49B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F49B8: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822F49BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F49C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F49C4: 4E800421  bctrl
	ctx.lr = 0x822F49C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822F49C8 => {
    //   block [0x822F49C8..0x822F49DC)
	// 822F49C8: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 822F49CC: 933E0000  stw r25, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822F49D0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F49D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822F49D8: 409AFFB0  bne cr6, 0x822f4988
	if !ctx.cr[6].eq {
	pc = 0x822F4988; continue 'dispatch;
	}
	pc = 0x822F49DC; continue 'dispatch;
            }
            0x822F49DC => {
    //   block [0x822F49DC..0x822F49F4)
	// 822F49DC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F49E0: 933C0100  stw r25, 0x100(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(256 as u32), ctx.r[25].u32 ) };
	// 822F49E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F49E8: 40990060  ble cr6, 0x822f4a48
	if !ctx.cr[6].gt {
	pc = 0x822F4A48; continue 'dispatch;
	}
	// 822F49EC: 3BDC0080  addi r30, r28, 0x80
	ctx.r[30].s64 = ctx.r[28].s64 + 128;
	// 822F49F0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x822F49F4; continue 'dispatch;
            }
            0x822F49F4 => {
    //   block [0x822F49F4..0x822F4A34)
	// 822F49F4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F49F8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822F49FC: 419A0038  beq cr6, 0x822f4a34
	if ctx.cr[6].eq {
	pc = 0x822F4A34; continue 'dispatch;
	}
	// 822F4A00: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822F4A04: 4BFF93F5  bl 0x822eddf8
	ctx.lr = 0x822F4A08;
	sub_822EDDF8(ctx, base);
	// 822F4A08: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4A0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822F4A10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F4A14: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4A18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4A1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F4A20: 4E800421  bctrl
	ctx.lr = 0x822F4A24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F4A24: 817B49B0  lwz r11, 0x49b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(18864 as u32) ) } as u64;
	// 822F4A28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F4A2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F4A30: 4E800421  bctrl
	ctx.lr = 0x822F4A34;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822F4A34 => {
    //   block [0x822F4A34..0x822F4A48)
	// 822F4A34: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 822F4A38: 933E0000  stw r25, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822F4A3C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F4A40: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822F4A44: 409AFFB0  bne cr6, 0x822f49f4
	if !ctx.cr[6].eq {
	pc = 0x822F49F4; continue 'dispatch;
	}
	pc = 0x822F4A48; continue 'dispatch;
            }
            0x822F4A48 => {
    //   block [0x822F4A48..0x822F4A50)
	// 822F4A48: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F4A4C: 482406B0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F4A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F4A50 size=324
    let mut pc: u32 = 0x822F4A50;
    'dispatch: loop {
        match pc {
            0x822F4A50 => {
    //   block [0x822F4A50..0x822F4A84)
	// 822F4A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F4A54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F4A58: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F4A5C: 38630080  addi r3, r3, 0x80
	ctx.r[3].s64 = ctx.r[3].s64 + 128;
	// 822F4A60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4A64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4A68: 419A002C  beq cr6, 0x822f4a94
	if ctx.cr[6].eq {
	pc = 0x822F4A94; continue 'dispatch;
	}
	// 822F4A6C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4A70: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4A74: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F4A78: 419A000C  beq cr6, 0x822f4a84
	if ctx.cr[6].eq {
	pc = 0x822F4A84; continue 'dispatch;
	}
	// 822F4A7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F4A80: 48000014  b 0x822f4a94
	pc = 0x822F4A94; continue 'dispatch;
            }
            0x822F4A84 => {
    //   block [0x822F4A84..0x822F4A94)
	// 822F4A84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4A88: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F4A8C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F4A90: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F4A94; continue 'dispatch;
            }
            0x822F4A94 => {
    //   block [0x822F4A94..0x822F4B24)
	// 822F4A94: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F4A98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4A9C: 419A00E8  beq cr6, 0x822f4b84
	if ctx.cr[6].eq {
	pc = 0x822F4B84; continue 'dispatch;
	}
	// 822F4AA0: 4BF38949  bl 0x8222d3e8
	ctx.lr = 0x822F4AA4;
	sub_8222D3E8(ctx, base);
	// 822F4AA4: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 822F4AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4AAC: 419A00D8  beq cr6, 0x822f4b84
	if ctx.cr[6].eq {
	pc = 0x822F4B84; continue 'dispatch;
	}
	// 822F4AB0: 8163007C  lwz r11, 0x7c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 822F4AB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4AB8: 419A0080  beq cr6, 0x822f4b38
	if ctx.cr[6].eq {
	pc = 0x822F4B38; continue 'dispatch;
	}
	// 822F4ABC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822F4AC0: C1A30074  lfs f13, 0x74(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F4AC4: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 822F4AC8: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 822F4ACC: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 822F4AD0: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F4AD4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F4AD8: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 822F4ADC: D1A30074  stfs f13, 0x74(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822F4AE0: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F4AE4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822F4AE8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F4AEC: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F4AF0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F4AF4: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F4AF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F4AFC: EC0C683C  fnmsubs f0, f12, f0, f13
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822F4B00: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F4B04: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822F4B08: 4198001C  blt cr6, 0x822f4b24
	if ctx.cr[6].lt {
	pc = 0x822F4B24; continue 'dispatch;
	}
	// 822F4B0C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 822F4B10: D0030060  stfs f0, 0x60(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822F4B14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F4B18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F4B1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F4B20: 4E800020  blr
	return;
            }
            0x822F4B24 => {
    //   block [0x822F4B24..0x822F4B38)
	// 822F4B24: D1A30060  stfs f13, 0x60(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822F4B28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F4B2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F4B30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F4B34: 4E800020  blr
	return;
            }
            0x822F4B38 => {
    //   block [0x822F4B38..0x822F4B78)
	// 822F4B38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F4B3C: C0030074  lfs f0, 0x74(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F4B40: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F4B44: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822F4B48: 41980030  blt cr6, 0x822f4b78
	if ctx.cr[6].lt {
	pc = 0x822F4B78; continue 'dispatch;
	}
	// 822F4B4C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 822F4B50: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 822F4B54: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 822F4B58: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 822F4B5C: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F4B60: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822F4B64: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822F4B68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F4B6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F4B70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F4B74: 4E800020  blr
	return;
            }
            0x822F4B78 => {
    //   block [0x822F4B78..0x822F4B84)
	// 822F4B78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822F4B7C: D1A30074  stfs f13, 0x74(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822F4B80: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	pc = 0x822F4B84; continue 'dispatch;
            }
            0x822F4B84 => {
    //   block [0x822F4B84..0x822F4B94)
	// 822F4B84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F4B88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F4B8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F4B90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F4B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F4B98 size=100
    let mut pc: u32 = 0x822F4B98;
    'dispatch: loop {
        match pc {
            0x822F4B98 => {
    //   block [0x822F4B98..0x822F4BBC)
	// 822F4B98: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 822F4B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4BA0: 419A002C  beq cr6, 0x822f4bcc
	if ctx.cr[6].eq {
	pc = 0x822F4BCC; continue 'dispatch;
	}
	// 822F4BA4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4BA8: 81230088  lwz r9, 0x88(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 822F4BAC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F4BB0: 419A000C  beq cr6, 0x822f4bbc
	if ctx.cr[6].eq {
	pc = 0x822F4BBC; continue 'dispatch;
	}
	// 822F4BB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F4BB8: 48000014  b 0x822f4bcc
	pc = 0x822F4BCC; continue 'dispatch;
            }
            0x822F4BBC => {
    //   block [0x822F4BBC..0x822F4BCC)
	// 822F4BBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4BC0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F4BC4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F4BC8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F4BCC; continue 'dispatch;
            }
            0x822F4BCC => {
    //   block [0x822F4BCC..0x822F4BFC)
	// 822F4BCC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F4BD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4BD4: 409A0028  bne cr6, 0x822f4bfc
	if !ctx.cr[6].eq {
		sub_822F4BFC(ctx, base);
		return;
	}
	// 822F4BD8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 822F4BDC: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 822F4BE0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 822F4BE4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 822F4BE8: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 822F4BEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822F4BF0: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 822F4BF4: 99430025  stb r10, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 822F4BF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F4BFC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F4BFC size=24
    let mut pc: u32 = 0x822F4BFC;
    'dispatch: loop {
        match pc {
            0x822F4BFC => {
    //   block [0x822F4BFC..0x822F4C14)
	// 822F4BFC: A1630014  lhz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F4C00: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822F4C04: 616B0300  ori r11, r11, 0x300
	ctx.r[11].u64 = ctx.r[11].u64 | 768;
	// 822F4C08: 9943001C  stb r10, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 822F4C0C: B1630014  sth r11, 0x14(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 822F4C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F4C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F4C18 size=288
    let mut pc: u32 = 0x822F4C18;
    'dispatch: loop {
        match pc {
            0x822F4C18 => {
    //   block [0x822F4C18..0x822F4C58)
	// 822F4C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F4C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F4C20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F4C24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F4C28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F4C2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F4C30: 387E0080  addi r3, r30, 0x80
	ctx.r[3].s64 = ctx.r[30].s64 + 128;
	// 822F4C34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4C38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4C3C: 419A002C  beq cr6, 0x822f4c68
	if ctx.cr[6].eq {
	pc = 0x822F4C68; continue 'dispatch;
	}
	// 822F4C40: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4C44: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4C48: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F4C4C: 419A000C  beq cr6, 0x822f4c58
	if ctx.cr[6].eq {
	pc = 0x822F4C58; continue 'dispatch;
	}
	// 822F4C50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F4C54: 48000014  b 0x822f4c68
	pc = 0x822F4C68; continue 'dispatch;
            }
            0x822F4C58 => {
    //   block [0x822F4C58..0x822F4C68)
	// 822F4C58: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4C5C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F4C60: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F4C64: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F4C68; continue 'dispatch;
            }
            0x822F4C68 => {
    //   block [0x822F4C68..0x822F4C9C)
	// 822F4C68: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F4C6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4C70: 419A00B0  beq cr6, 0x822f4d20
	if ctx.cr[6].eq {
	pc = 0x822F4D20; continue 'dispatch;
	}
	// 822F4C74: 4BF38775  bl 0x8222d3e8
	ctx.lr = 0x822F4C78;
	sub_8222D3E8(ctx, base);
	// 822F4C78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F4C7C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 822F4C80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4C84: 419A0090  beq cr6, 0x822f4d14
	if ctx.cr[6].eq {
	pc = 0x822F4D14; continue 'dispatch;
	}
	// 822F4C88: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4C8C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 822F4C90: 40990038  ble cr6, 0x822f4cc8
	if !ctx.cr[6].gt {
	pc = 0x822F4CC8; continue 'dispatch;
	}
	// 822F4C94: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822F4C98: 391F0080  addi r8, r31, 0x80
	ctx.r[8].s64 = ctx.r[31].s64 + 128;
	pc = 0x822F4C9C; continue 'dispatch;
            }
            0x822F4C9C => {
    //   block [0x822F4C9C..0x822F4CB4)
	// 822F4C9C: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4CA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F4CA4: 419A0010  beq cr6, 0x822f4cb4
	if ctx.cr[6].eq {
	pc = 0x822F4CB4; continue 'dispatch;
	}
	// 822F4CA8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F4CAC: 7C8B4A14  add r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822F4CB0: 48098FE1  bl 0x8238dc90
	ctx.lr = 0x822F4CB4;
	sub_8238DC90(ctx, base);
	pc = 0x822F4CB4; continue 'dispatch;
            }
            0x822F4CB4 => {
    //   block [0x822F4CB4..0x822F4CC8)
	// 822F4CB4: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 822F4CB8: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 822F4CBC: 39290040  addi r9, r9, 0x40
	ctx.r[9].s64 = ctx.r[9].s64 + 64;
	// 822F4CC0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822F4CC4: 409AFFD8  bne cr6, 0x822f4c9c
	if !ctx.cr[6].eq {
	pc = 0x822F4C9C; continue 'dispatch;
	}
	pc = 0x822F4CC8; continue 'dispatch;
            }
            0x822F4CC8 => {
    //   block [0x822F4CC8..0x822F4CF0)
	// 822F4CC8: 817F028C  lwz r11, 0x28c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) } as u64;
	// 822F4CCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4CD0: 419A0020  beq cr6, 0x822f4cf0
	if ctx.cr[6].eq {
	pc = 0x822F4CF0; continue 'dispatch;
	}
	// 822F4CD4: 817F0290  lwz r11, 0x290(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(656 as u32) ) } as u64;
	// 822F4CD8: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 822F4CDC: 2B0B0041  cmplwi cr6, r11, 0x41
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65 as u32, &mut ctx.xer);
	// 822F4CE0: 915F0290  stw r10, 0x290(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(656 as u32), ctx.r[10].u32 ) };
	// 822F4CE4: 409A000C  bne cr6, 0x822f4cf0
	if !ctx.cr[6].eq {
	pc = 0x822F4CF0; continue 'dispatch;
	}
	// 822F4CE8: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 822F4CEC: 4BEC0795  bl 0x821b5480
	ctx.lr = 0x822F4CF0;
	sub_821B5480(ctx, base);
	pc = 0x822F4CF0; continue 'dispatch;
            }
            0x822F4CF0 => {
    //   block [0x822F4CF0..0x822F4D14)
	// 822F4CF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F4CF4: 4BFFFD5D  bl 0x822f4a50
	ctx.lr = 0x822F4CF8;
	sub_822F4A50(ctx, base);
	// 822F4CF8: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 822F4CFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4D00: 409A0014  bne cr6, 0x822f4d14
	if !ctx.cr[6].eq {
	pc = 0x822F4D14; continue 'dispatch;
	}
	// 822F4D04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F4D08: 4BFFFB41  bl 0x822f4848
	ctx.lr = 0x822F4D0C;
	sub_822F4848(ctx, base);
	// 822F4D0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F4D10: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	pc = 0x822F4D14; continue 'dispatch;
            }
            0x822F4D14 => {
    //   block [0x822F4D14..0x822F4D20)
	// 822F4D14: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F4D18: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F4D1C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x822F4D20; continue 'dispatch;
            }
            0x822F4D20 => {
    //   block [0x822F4D20..0x822F4D38)
	// 822F4D20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F4D24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F4D28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F4D2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F4D30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F4D34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F4D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F4D38 size=76
    let mut pc: u32 = 0x822F4D38;
    'dispatch: loop {
        match pc {
            0x822F4D38 => {
    //   block [0x822F4D38..0x822F4D70)
	// 822F4D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F4D3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F4D40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F4D44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F4D48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F4D4C: 4BFFFAFD  bl 0x822f4848
	ctx.lr = 0x822F4D50;
	sub_822F4848(ctx, base);
	// 822F4D50: 397F0080  addi r11, r31, 0x80
	ctx.r[11].s64 = ctx.r[31].s64 + 128;
	// 822F4D54: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822F4D58: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F4D5C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F4D60: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F4D64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F4D68: 419A0008  beq cr6, 0x822f4d70
	if ctx.cr[6].eq {
	pc = 0x822F4D70; continue 'dispatch;
	}
	// 822F4D6C: 4BE282ED  bl 0x8211d058
	ctx.lr = 0x822F4D70;
	sub_8211D058(ctx, base);
	pc = 0x822F4D70; continue 'dispatch;
            }
            0x822F4D70 => {
    //   block [0x822F4D70..0x822F4D84)
	// 822F4D70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F4D74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F4D78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F4D7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F4D80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F4D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F4D88 size=132
    let mut pc: u32 = 0x822F4D88;
    'dispatch: loop {
        match pc {
            0x822F4D88 => {
    //   block [0x822F4D88..0x822F4DD8)
	// 822F4D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F4D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F4D90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F4D94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F4D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F4D9C: 4BFF8395  bl 0x822ed130
	ctx.lr = 0x822F4DA0;
	sub_822ED130(ctx, base);
	// 822F4DA0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F4DA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F4DA8: 38EBC724  addi r7, r11, -0x38dc
	ctx.r[7].s64 = ctx.r[11].s64 + -14556;
	// 822F4DAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822F4DB0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F4DB4: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 822F4DB8: 480756D9  bl 0x8236a490
	ctx.lr = 0x822F4DBC;
	sub_8236A490(ctx, base);
	// 822F4DBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F4DC0: 419A0018  beq cr6, 0x822f4dd8
	if ctx.cr[6].eq {
	pc = 0x822F4DD8; continue 'dispatch;
	}
	// 822F4DC4: 80FF008C  lwz r7, 0x8c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 822F4DC8: 80DF0088  lwz r6, 0x88(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 822F4DCC: 80BF0084  lwz r5, 0x84(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822F4DD0: 809F0080  lwz r4, 0x80(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822F4DD4: 4800003D  bl 0x822f4e10
	ctx.lr = 0x822F4DD8;
	sub_822F4E10(ctx, base);
	pc = 0x822F4DD8; continue 'dispatch;
            }
            0x822F4DD8 => {
    //   block [0x822F4DD8..0x822F4DF8)
	// 822F4DD8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 822F4DDC: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 822F4DE0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822F4DE4: 409A0014  bne cr6, 0x822f4df8
	if !ctx.cr[6].eq {
	pc = 0x822F4DF8; continue 'dispatch;
	}
	// 822F4DE8: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 822F4DEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822F4DF0: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 822F4DF4: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x822F4DF8; continue 'dispatch;
            }
            0x822F4DF8 => {
    //   block [0x822F4DF8..0x822F4E0C)
	// 822F4DF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F4DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F4E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F4E04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F4E08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F4E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F4E10 size=676
    let mut pc: u32 = 0x822F4E10;
    'dispatch: loop {
        match pc {
            0x822F4E10 => {
    //   block [0x822F4E10..0x822F4E88)
	// 822F4E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F4E14: 4824029D  bl 0x825350b0
	ctx.lr = 0x822F4E18;
	sub_82535080(ctx, base);
	// 822F4E18: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F4E1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F4E20: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822F4E24: 396BC75C  addi r11, r11, -0x38a4
	ctx.r[11].s64 = ctx.r[11].s64 + -14500;
	// 822F4E28: 3BFC0080  addi r31, r28, 0x80
	ctx.r[31].s64 = ctx.r[28].s64 + 128;
	// 822F4E2C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822F4E30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822F4E34: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 822F4E38: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F4E3C: 39600300  li r11, 0x300
	ctx.r[11].s64 = 768;
	// 822F4E40: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822F4E44: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822F4E48: 38CAC72C  addi r6, r10, -0x38d4
	ctx.r[6].s64 = ctx.r[10].s64 + -14548;
	// 822F4E4C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822F4E50: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 822F4E54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F4E58: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 822F4E5C: 386ADBE0  addi r3, r10, -0x2420
	ctx.r[3].s64 = ctx.r[10].s64 + -9248;
	// 822F4E60: A17E0008  lhz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4E64: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 822F4E68: 556B203E  rotlwi r11, r11, 4
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 822F4E6C: 38AB0300  addi r5, r11, 0x300
	ctx.r[5].s64 = ctx.r[11].s64 + 768;
	// 822F4E70: 4BF00479  bl 0x821f52e8
	ctx.lr = 0x822F4E74;
	sub_821F52E8(ctx, base);
	// 822F4E74: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4E7C: 409A000C  bne cr6, 0x822f4e88
	if !ctx.cr[6].eq {
	pc = 0x822F4E88; continue 'dispatch;
	}
	// 822F4E80: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822F4E84: 4800002C  b 0x822f4eb0
	pc = 0x822F4EB0; continue 'dispatch;
            }
            0x822F4E88 => {
    //   block [0x822F4E88..0x822F4EA0)
	// 822F4E88: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4E8C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4E90: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F4E94: 419A000C  beq cr6, 0x822f4ea0
	if ctx.cr[6].eq {
	pc = 0x822F4EA0; continue 'dispatch;
	}
	// 822F4E98: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822F4E9C: 48000014  b 0x822f4eb0
	pc = 0x822F4EB0; continue 'dispatch;
            }
            0x822F4EA0 => {
    //   block [0x822F4EA0..0x822F4EB0)
	// 822F4EA0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F4EA4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F4EA8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F4EAC: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F4EB0; continue 'dispatch;
            }
            0x822F4EB0 => {
    //   block [0x822F4EB0..0x822F4EF0)
	// 822F4EB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F4EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F4EB8: 419A01F0  beq cr6, 0x822f50a8
	if ctx.cr[6].eq {
	pc = 0x822F50A8; continue 'dispatch;
	}
	// 822F4EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F4EC0: 4BF38529  bl 0x8222d3e8
	ctx.lr = 0x822F4EC4;
	sub_8222D3E8(ctx, base);
	// 822F4EC4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822F4EC8: 3966007F  addi r11, r6, 0x7f
	ctx.r[11].s64 = ctx.r[6].s64 + 127;
	// 822F4ECC: 39460300  addi r10, r6, 0x300
	ctx.r[10].s64 = ctx.r[6].s64 + 768;
	// 822F4ED0: 55690030  rlwinm r9, r11, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822F4ED4: 554B0030  rlwinm r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822F4ED8: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 822F4EDC: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822F4EE0: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822F4EE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822F4EE8: 419A0008  beq cr6, 0x822f4ef0
	if ctx.cr[6].eq {
	pc = 0x822F4EF0; continue 'dispatch;
	}
	// 822F4EEC: 7C00322C  dcbt 0, r6
	pc = 0x822F4EF0; continue 'dispatch;
            }
            0x822F4EF0 => {
    //   block [0x822F4EF0..0x822F4EFC)
	// 822F4EF0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822F4EF4: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 822F4EF8: 41980084  blt cr6, 0x822f4f7c
	if ctx.cr[6].lt {
	pc = 0x822F4F7C; continue 'dispatch;
	}
	pc = 0x822F4EFC; continue 'dispatch;
            }
            0x822F4EFC => {
    //   block [0x822F4EFC..0x822F4F7C)
	// 822F4EFC: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 822F4F00: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F4F04: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F4F08: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 822F4F0C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F4F10: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 822F4F14: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F4F18: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F4F1C: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 822F4F20: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F4F24: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F4F28: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 822F4F2C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F4F30: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F4F34: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 822F4F38: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F4F3C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F4F40: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 822F4F44: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F4F48: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F4F4C: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 822F4F50: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F4F54: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F4F58: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F4F5C: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 822F4F60: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F4F64: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 822F4F68: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 822F4F6C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822F4F70: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822F4F74: 4098FF88  bge cr6, 0x822f4efc
	if !ctx.cr[6].lt {
	pc = 0x822F4EFC; continue 'dispatch;
	}
	// 822F4F78: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x822F4F7C; continue 'dispatch;
            }
            0x822F4F7C => {
    //   block [0x822F4F7C..0x822F4FC0)
	// 822F4F7C: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 822F4F80: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822F4F84: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 822F4F88: 4199008C  bgt cr6, 0x822f5014
	if ctx.cr[6].gt {
	pc = 0x822F5014; continue 'dispatch;
	}
	// 822F4F8C: 3D80822F  lis r12, -0x7dd1
	ctx.r[12].s64 = -2110849024;
	// 822F4F90: 398C4FA4  addi r12, r12, 0x4fa4
	ctx.r[12].s64 = ctx.r[12].s64 + 20388;
	// 822F4F94: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 822F4F98: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 822F4F9C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 822F4FA0: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x822F5008; continue 'dispatch;
		},
		1 => {
	pc = 0x822F4FFC; continue 'dispatch;
		},
		2 => {
	pc = 0x822F4FF0; continue 'dispatch;
		},
		3 => {
	pc = 0x822F4FE4; continue 'dispatch;
		},
		4 => {
	pc = 0x822F4FD8; continue 'dispatch;
		},
		5 => {
	pc = 0x822F4FCC; continue 'dispatch;
		},
		6 => {
	pc = 0x822F4FC0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 822F4FA4: 822F5008  lwz r17, 0x5008(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(20488 as u32) ) } as u64;
	// 822F4FA8: 822F4FFC  lwz r17, 0x4ffc(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(20476 as u32) ) } as u64;
	// 822F4FAC: 822F4FF0  lwz r17, 0x4ff0(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(20464 as u32) ) } as u64;
	// 822F4FB0: 822F4FE4  lwz r17, 0x4fe4(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(20452 as u32) ) } as u64;
	// 822F4FB4: 822F4FD8  lwz r17, 0x4fd8(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(20440 as u32) ) } as u64;
	// 822F4FB8: 822F4FCC  lwz r17, 0x4fcc(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(20428 as u32) ) } as u64;
	// 822F4FBC: 822F4FC0  lwz r17, 0x4fc0(r15)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(20416 as u32) ) } as u64;
            }
            0x822F4FC0 => {
    //   block [0x822F4FC0..0x822F4FCC)
	// 822F4FC0: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 822F4FC4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F4FC8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F4FCC; continue 'dispatch;
            }
            0x822F4FCC => {
    //   block [0x822F4FCC..0x822F4FD8)
	// 822F4FCC: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 822F4FD0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F4FD4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F4FD8; continue 'dispatch;
            }
            0x822F4FD8 => {
    //   block [0x822F4FD8..0x822F4FE4)
	// 822F4FD8: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 822F4FDC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F4FE0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F4FE4; continue 'dispatch;
            }
            0x822F4FE4 => {
    //   block [0x822F4FE4..0x822F4FF0)
	// 822F4FE4: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 822F4FE8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F4FEC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F4FF0; continue 'dispatch;
            }
            0x822F4FF0 => {
    //   block [0x822F4FF0..0x822F4FFC)
	// 822F4FF0: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 822F4FF4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F4FF8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F4FFC; continue 'dispatch;
            }
            0x822F4FFC => {
    //   block [0x822F4FFC..0x822F5008)
	// 822F4FFC: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 822F5000: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F5004: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x822F5008; continue 'dispatch;
            }
            0x822F5008 => {
    //   block [0x822F5008..0x822F5014)
	// 822F5008: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 822F500C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 822F5010: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x822F5014; continue 'dispatch;
            }
            0x822F5014 => {
    //   block [0x822F5014..0x822F504C)
	// 822F5014: A17E0008  lhz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F5018: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F501C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822F5020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F5024: 7C665214  add r3, r6, r10
	ctx.r[3].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 822F5028: 419A0064  beq cr6, 0x822f508c
	if ctx.cr[6].eq {
	pc = 0x822F508C; continue 'dispatch;
	}
	// 822F502C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822F5030: 394601A4  addi r10, r6, 0x1a4
	ctx.r[10].s64 = ctx.r[6].s64 + 420;
	// 822F5034: 392B45C8  addi r9, r11, 0x45c8
	ctx.r[9].s64 = ctx.r[11].s64 + 17864;
	// 822F5038: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F503C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822F5040: 390BC798  addi r8, r11, -0x3868
	ctx.r[8].s64 = ctx.r[11].s64 + -14440;
	// 822F5044: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F5048: 38EBC788  addi r7, r11, -0x3878
	ctx.r[7].s64 = ctx.r[11].s64 + -14456;
	pc = 0x822F504C; continue 'dispatch;
            }
            0x822F504C => {
    //   block [0x822F504C..0x822F5078)
	// 822F504C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822F5050: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 822F5054: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F5058: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F505C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F5060: 419A0018  beq cr6, 0x822f5078
	if ctx.cr[6].eq {
	pc = 0x822F5078; continue 'dispatch;
	}
	// 822F5064: B0AB0006  sth r5, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[5].u16 ) };
	// 822F5068: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822F506C: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 822F5070: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 822F5074: 93AB000C  stw r29, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	pc = 0x822F5078; continue 'dispatch;
            }
            0x822F5078 => {
    //   block [0x822F5078..0x822F508C)
	// 822F5078: A17E0008  lhz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F507C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 822F5080: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822F5084: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822F5088: 4198FFC4  blt cr6, 0x822f504c
	if ctx.cr[6].lt {
	pc = 0x822F504C; continue 'dispatch;
	}
	pc = 0x822F508C; continue 'dispatch;
            }
            0x822F508C => {
    //   block [0x822F508C..0x822F50A8)
	// 822F508C: A17E0008  lhz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F5090: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822F5094: 93C60000  stw r30, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822F5098: 93660004  stw r27, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 822F509C: 9346000C  stw r26, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 822F50A0: 91660008  stw r11, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822F50A4: 48000015  bl 0x822f50b8
	ctx.lr = 0x822F50A8;
	sub_822F50B8(ctx, base);
	pc = 0x822F50A8; continue 'dispatch;
            }
            0x822F50A8 => {
    //   block [0x822F50A8..0x822F50B4)
	// 822F50A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822F50AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822F50B0: 48240050  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F50B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F50B8 size=1192
    let mut pc: u32 = 0x822F50B8;
    'dispatch: loop {
        match pc {
            0x822F50B8 => {
    //   block [0x822F50B8..0x822F50E8)
	// 822F50B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F50BC: 4823FFD1  bl 0x8253508c
	ctx.lr = 0x822F50C0;
	sub_82535080(ctx, base);
	// 822F50C0: DBE1FF78  stfd f31, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 822F50C4: 9421FAE0  stwu r1, -0x520(r1)
	ea = ctx.r[1].u32.wrapping_add(-1312 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F50C8: 7C711B78  mr r17, r3
	ctx.r[17].u64 = ctx.r[3].u64;
	// 822F50CC: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 822F50D0: 3BF10080  addi r31, r17, 0x80
	ctx.r[31].s64 = ctx.r[17].s64 + 128;
	// 822F50D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F50D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F50DC: 409A000C  bne cr6, 0x822f50e8
	if !ctx.cr[6].eq {
	pc = 0x822F50E8; continue 'dispatch;
	}
	// 822F50E0: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822F50E4: 4800002C  b 0x822f5110
	pc = 0x822F5110; continue 'dispatch;
            }
            0x822F50E8 => {
    //   block [0x822F50E8..0x822F5100)
	// 822F50E8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F50EC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F50F0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F50F4: 419A000C  beq cr6, 0x822f5100
	if ctx.cr[6].eq {
	pc = 0x822F5100; continue 'dispatch;
	}
	// 822F50F8: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822F50FC: 48000014  b 0x822f5110
	pc = 0x822F5110; continue 'dispatch;
            }
            0x822F5100 => {
    //   block [0x822F5100..0x822F5110)
	// 822F5100: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F5104: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822F5108: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822F510C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x822F5110; continue 'dispatch;
            }
            0x822F5110 => {
    //   block [0x822F5110..0x822F5150)
	// 822F5110: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822F5114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F5118: 419A043C  beq cr6, 0x822f5554
	if ctx.cr[6].eq {
	pc = 0x822F5554; continue 'dispatch;
	}
	// 822F511C: 4BFF8015  bl 0x822ed130
	ctx.lr = 0x822F5120;
	sub_822ED130(ctx, base);
	// 822F5120: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 822F5124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F5128: 4BF382C1  bl 0x8222d3e8
	ctx.lr = 0x822F512C;
	sub_8222D3E8(ctx, base);
	// 822F512C: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 822F5130: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822F5134: 82550008  lwz r18, 8(r21)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F5138: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822F513C: 2F120000  cmpwi cr6, r18, 0
	ctx.cr[6].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 822F5140: 409900E0  ble cr6, 0x822f5220
	if !ctx.cr[6].gt {
	pc = 0x822F5220; continue 'dispatch;
	}
	// 822F5144: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 822F5148: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 822F514C: 7E5C9378  mr r28, r18
	ctx.r[28].u64 = ctx.r[18].u64;
	pc = 0x822F5150; continue 'dispatch;
            }
            0x822F5150 => {
    //   block [0x822F5150..0x822F5220)
	// 822F5150: 81550000  lwz r10, 0(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F5154: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F5158: 7FDD5A14  add r30, r29, r11
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 822F515C: 816A0060  lwz r11, 0x60(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(96 as u32) ) } as u64;
	// 822F5160: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F5164: 7FEBDA14  add r31, r11, r27
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822F5168: C07F0008  lfs f3, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822F516C: C05F0004  lfs f2, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822F5170: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822F5174: 480730A5  bl 0x82368218
	ctx.lr = 0x822F5178;
	sub_82368218(ctx, base);
	// 822F5178: C01F0010  lfs f0, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F517C: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 822F5180: D01E0030  stfs f0, 0x30(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 822F5184: 3B7B0050  addi r27, r27, 0x50
	ctx.r[27].s64 = ctx.r[27].s64 + 80;
	// 822F5188: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F518C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 822F5190: D01E0034  stfs f0, 0x34(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 822F5194: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F5198: D01E0038  stfs f0, 0x38(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 822F519C: D3FE003C  stfs f31, 0x3c(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 822F51A0: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F51A4: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F51A8: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 822F51AC: 3BBD0040  addi r29, r29, 0x40
	ctx.r[29].s64 = ctx.r[29].s64 + 64;
	// 822F51B0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F51B4: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822F51B8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F51BC: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822F51C0: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F51C4: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822F51C8: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F51CC: C12B0014  lfs f9, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822F51D0: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F51D4: C10B0018  lfs f8, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822F51D8: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F51DC: C0EB0020  lfs f7, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822F51E0: ED080032  fmuls f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F51E4: C0CB0024  lfs f6, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822F51E8: ECE70032  fmuls f7, f7, f0
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F51EC: C0AB0028  lfs f5, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 822F51F0: ECC60032  fmuls f6, f6, f0
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F51F4: EC050032  fmuls f0, f5, f0
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 822F51F8: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822F51FC: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822F5200: D16B0008  stfs f11, 8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822F5204: D14B0010  stfs f10, 0x10(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822F5208: D12B0014  stfs f9, 0x14(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 822F520C: D10B0018  stfs f8, 0x18(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 822F5210: D0EB0020  stfs f7, 0x20(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822F5214: D0CB0024  stfs f6, 0x24(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822F5218: D00B0028  stfs f0, 0x28(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822F521C: 409AFF34  bne cr6, 0x822f5150
	if !ctx.cr[6].eq {
	pc = 0x822F5150; continue 'dispatch;
	}
	pc = 0x822F5220; continue 'dispatch;
            }
            0x822F5220 => {
    //   block [0x822F5220..0x822F5270)
	// 822F5220: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F5224: 894B0004  lbz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F5228: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822F522C: 409A0328  bne cr6, 0x822f5554
	if !ctx.cr[6].eq {
	pc = 0x822F5554; continue 'dispatch;
	}
	// 822F5230: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F5234: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 822F5238: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F523C: D3F50010  stfs f31, 0x10(r21)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822F5240: 91550014  stw r10, 0x14(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 822F5244: 93750018  stw r27, 0x18(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(24 as u32), ctx.r[27].u32 ) };
	// 822F5248: 48000511  bl 0x822f5758
	ctx.lr = 0x822F524C;
	sub_822F5758(ctx, base);
	// 822F524C: 8174019C  lwz r11, 0x19c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(412 as u32) ) } as u64;
	// 822F5250: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F5254: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F5258: 419A02FC  beq cr6, 0x822f5554
	if ctx.cr[6].eq {
	pc = 0x822F5554; continue 'dispatch;
	}
	// 822F525C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822F5260: 3940001F  li r10, 0x1f
	ctx.r[10].s64 = 31;
	// 822F5264: 39610098  addi r11, r1, 0x98
	ctx.r[11].s64 = ctx.r[1].s64 + 152;
	// 822F5268: 38E9C520  addi r7, r9, -0x3ae0
	ctx.r[7].s64 = ctx.r[9].s64 + -15072;
	// 822F526C: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	pc = 0x822F5270; continue 'dispatch;
            }
            0x822F5270 => {
    //   block [0x822F5270..0x822F531C)
	// 822F5270: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822F5274: 93EBFFFC  stw r31, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[31].u32 ) };
	// 822F5278: 90EBFFF8  stw r7, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 822F527C: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822F5280: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F5284: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822F5288: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822F528C: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 822F5290: 92EB0014  stw r23, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[23].u32 ) };
	// 822F5294: 92EB0010  stw r23, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 822F5298: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 822F529C: 4098FFD4  bge cr6, 0x822f5270
	if !ctx.cr[6].lt {
	pc = 0x822F5270; continue 'dispatch;
	}
	// 822F52A0: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 822F52A4: 90E10070  stw r7, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[7].u32 ) };
	// 822F52A8: 39410088  addi r10, r1, 0x88
	ctx.r[10].s64 = ctx.r[1].s64 + 136;
	// 822F52AC: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 822F52B0: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 822F52B4: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 822F52B8: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 822F52BC: 390100A8  addi r8, r1, 0xa8
	ctx.r[8].s64 = ctx.r[1].s64 + 168;
	// 822F52C0: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 822F52C4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 822F52C8: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 822F52CC: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 822F52D0: 92E1008C  stw r23, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[23].u32 ) };
	// 822F52D4: 92E10088  stw r23, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[23].u32 ) };
	// 822F52D8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F52DC: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F52E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F52E4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F52E8: 93610094  stw r27, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[27].u32 ) };
	// 822F52EC: 92E10098  stw r23, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[23].u32 ) };
	// 822F52F0: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 822F52F4: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 822F52F8: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822F52FC: 90C80000  stw r6, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 822F5300: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F5304: 4BFF86C5  bl 0x822ed9c8
	ctx.lr = 0x822F5308;
	sub_822ED9C8(ctx, base);
	// 822F5308: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 822F530C: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 822F5310: 2F130000  cmpwi cr6, r19, 0
	ctx.cr[6].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 822F5314: 40990068  ble cr6, 0x822f537c
	if !ctx.cr[6].gt {
	pc = 0x822F537C; continue 'dispatch;
	}
	// 822F5318: 3BC10098  addi r30, r1, 0x98
	ctx.r[30].s64 = ctx.r[1].s64 + 152;
	pc = 0x822F531C; continue 'dispatch;
            }
            0x822F531C => {
    //   block [0x822F531C..0x822F5358)
	// 822F531C: 3BBEFFF8  addi r29, r30, -8
	ctx.r[29].s64 = ctx.r[30].s64 + -8;
	// 822F5320: 937EFFFC  stw r27, -4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[27].u32 ) };
	// 822F5324: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822F5328: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 822F532C: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822F5330: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F5334: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 822F5338: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822F533C: 92FE0010  stw r23, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 822F5340: 92FE0014  stw r23, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[23].u32 ) };
	// 822F5344: 4BFF85AD  bl 0x822ed8f0
	ctx.lr = 0x822F5348;
	sub_822ED8F0(ctx, base);
	// 822F5348: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F534C: 419A0020  beq cr6, 0x822f536c
	if ctx.cr[6].eq {
	pc = 0x822F536C; continue 'dispatch;
	}
	// 822F5350: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 822F5354: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x822F5358; continue 'dispatch;
            }
            0x822F5358 => {
    //   block [0x822F5358..0x822F536C)
	// 822F5358: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F535C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 822F5360: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F5364: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822F5368: 4200FFF0  bdnz 0x822f5358
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822F5358; continue 'dispatch;
	}
	pc = 0x822F536C; continue 'dispatch;
            }
            0x822F536C => {
    //   block [0x822F536C..0x822F537C)
	// 822F536C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822F5370: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 822F5374: 7F1C9800  cmpw cr6, r28, r19
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[19].s32, &mut ctx.xer);
	// 822F5378: 4198FFA4  blt cr6, 0x822f531c
	if ctx.cr[6].lt {
	pc = 0x822F531C; continue 'dispatch;
	}
	pc = 0x822F537C; continue 'dispatch;
            }
            0x822F537C => {
    //   block [0x822F537C..0x822F53B0)
	// 822F537C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822F5380: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 822F5384: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 822F5388: 7EF6BB78  mr r22, r23
	ctx.r[22].u64 = ctx.r[23].u64;
	// 822F538C: 396BC508  addi r11, r11, -0x3af8
	ctx.r[11].s64 = ctx.r[11].s64 + -15096;
	// 822F5390: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 822F5394: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 822F5398: 2F120000  cmpwi cr6, r18, 0
	ctx.cr[6].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 822F539C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 822F53A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822F53A4: 40990130  ble cr6, 0x822f54d4
	if !ctx.cr[6].gt {
	pc = 0x822F54D4; continue 'dispatch;
	}
	// 822F53A8: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 822F53AC: 3B55001C  addi r26, r21, 0x1c
	ctx.r[26].s64 = ctx.r[21].s64 + 28;
	pc = 0x822F53B0; continue 'dispatch;
            }
            0x822F53B0 => {
    //   block [0x822F53B0..0x822F5408)
	// 822F53B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822F53B4: 92C10058  stw r22, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 822F53B8: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 822F53BC: 4BFF8095  bl 0x822ed450
	ctx.lr = 0x822F53C0;
	sub_822ED450(ctx, base);
	// 822F53C0: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 822F53C4: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 822F53C8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 822F53CC: 4BFF7E9D  bl 0x822ed268
	ctx.lr = 0x822F53D0;
	sub_822ED268(ctx, base);
	// 822F53D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F53D4: 419A00EC  beq cr6, 0x822f54c0
	if ctx.cr[6].eq {
	pc = 0x822F54C0; continue 'dispatch;
	}
	// 822F53D8: 48097BE9  bl 0x8238cfc0
	ctx.lr = 0x822F53DC;
	sub_8238CFC0(ctx, base);
	// 822F53DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F53E0: 907A0000  stw r3, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 822F53E4: 419A00DC  beq cr6, 0x822f54c0
	if ctx.cr[6].eq {
	pc = 0x822F54C0; continue 'dispatch;
	}
	// 822F53E8: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F53EC: 7C8BC214  add r4, r11, r24
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 822F53F0: 48098661  bl 0x8238da50
	ctx.lr = 0x822F53F4;
	sub_8238DA50(ctx, base);
	// 822F53F4: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F53F8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F53FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F5400: 419A0008  beq cr6, 0x822f5408
	if ctx.cr[6].eq {
	pc = 0x822F5408; continue 'dispatch;
	}
	// 822F5404: 932B000C  stw r25, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	pc = 0x822F5408; continue 'dispatch;
            }
            0x822F5408 => {
    //   block [0x822F5408..0x822F5418)
	// 822F5408: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F540C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F5410: 419A0008  beq cr6, 0x822f5418
	if ctx.cr[6].eq {
	pc = 0x822F5418; continue 'dispatch;
	}
	// 822F5414: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	pc = 0x822F5418; continue 'dispatch;
            }
            0x822F5418 => {
    //   block [0x822F5418..0x822F5448)
	// 822F5418: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 822F541C: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F5420: 4BFF8919  bl 0x822edd38
	ctx.lr = 0x822F5424;
	sub_822EDD38(ctx, base);
	// 822F5424: 817A0188  lwz r11, 0x188(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(392 as u32) ) } as u64;
	// 822F5428: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F542C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F5430: 409A0018  bne cr6, 0x822f5448
	if !ctx.cr[6].eq {
	pc = 0x822F5448; continue 'dispatch;
	}
	// 822F5434: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F5438: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 822F543C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822F5440: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F5444: 48199275  bl 0x8248e6b8
	ctx.lr = 0x822F5448;
	sub_8248E6B8(ctx, base);
	pc = 0x822F5448; continue 'dispatch;
            }
            0x822F5448 => {
    //   block [0x822F5448..0x822F545C)
	// 822F5448: 2F130000  cmpwi cr6, r19, 0
	ctx.cr[6].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 822F544C: 40990074  ble cr6, 0x822f54c0
	if !ctx.cr[6].gt {
	pc = 0x822F54C0; continue 'dispatch;
	}
	// 822F5450: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 822F5454: 3BA100A0  addi r29, r1, 0xa0
	ctx.r[29].s64 = ctx.r[1].s64 + 160;
	// 822F5458: 7E7B9B78  mr r27, r19
	ctx.r[27].u64 = ctx.r[19].u64;
	pc = 0x822F545C; continue 'dispatch;
            }
            0x822F545C => {
    //   block [0x822F545C..0x822F5464)
	// 822F545C: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 822F5460: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x822F5464; continue 'dispatch;
            }
            0x822F5464 => {
    //   block [0x822F5464..0x822F5498)
	// 822F5464: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F5468: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F546C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F5470: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F5474: 4E800421  bctrl
	ctx.lr = 0x822F5478;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F5478: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F547C: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 822F5480: 419A0018  beq cr6, 0x822f5498
	if ctx.cr[6].eq {
	pc = 0x822F5498; continue 'dispatch;
	}
	// 822F5484: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822F5488: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822F548C: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 822F5490: 4198FFD4  blt cr6, 0x822f5464
	if ctx.cr[6].lt {
	pc = 0x822F5464; continue 'dispatch;
	}
	// 822F5494: 48000018  b 0x822f54ac
	pc = 0x822F54AC; continue 'dispatch;
            }
            0x822F5498 => {
    //   block [0x822F5498..0x822F54AC)
	// 822F5498: 7D7CF214  add r11, r28, r30
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 822F549C: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F54A0: 392100A8  addi r9, r1, 0xa8
	ctx.r[9].s64 = ctx.r[1].s64 + 168;
	// 822F54A4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F54A8: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	pc = 0x822F54AC; continue 'dispatch;
            }
            0x822F54AC => {
    //   block [0x822F54AC..0x822F54C0)
	// 822F54AC: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 822F54B0: 3BBD0020  addi r29, r29, 0x20
	ctx.r[29].s64 = ctx.r[29].s64 + 32;
	// 822F54B4: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 822F54B8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822F54BC: 409AFFA0  bne cr6, 0x822f545c
	if !ctx.cr[6].eq {
	pc = 0x822F545C; continue 'dispatch;
	}
	pc = 0x822F54C0; continue 'dispatch;
            }
            0x822F54C0 => {
    //   block [0x822F54C0..0x822F54D4)
	// 822F54C0: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 822F54C4: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 822F54C8: 3B180040  addi r24, r24, 0x40
	ctx.r[24].s64 = ctx.r[24].s64 + 64;
	// 822F54CC: 7F169000  cmpw cr6, r22, r18
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[18].s32, &mut ctx.xer);
	// 822F54D0: 4198FEE0  blt cr6, 0x822f53b0
	if ctx.cr[6].lt {
	pc = 0x822F53B0; continue 'dispatch;
	}
	pc = 0x822F54D4; continue 'dispatch;
            }
            0x822F54D4 => {
    //   block [0x822F54D4..0x822F54E8)
	// 822F54D4: 2F130000  cmpwi cr6, r19, 0
	ctx.cr[6].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 822F54D8: 4099006C  ble cr6, 0x822f5544
	if !ctx.cr[6].gt {
	pc = 0x822F5544; continue 'dispatch;
	}
	// 822F54DC: 3BE100AC  addi r31, r1, 0xac
	ctx.r[31].s64 = ctx.r[1].s64 + 172;
	// 822F54E0: 3BD50124  addi r30, r21, 0x124
	ctx.r[30].s64 = ctx.r[21].s64 + 292;
	// 822F54E4: 7E7D9B78  mr r29, r19
	ctx.r[29].u64 = ctx.r[19].u64;
	pc = 0x822F54E8; continue 'dispatch;
            }
            0x822F54E8 => {
    //   block [0x822F54E8..0x822F5500)
	// 822F54E8: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822F54EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F54F0: 409A0010  bne cr6, 0x822f5500
	if !ctx.cr[6].eq {
	pc = 0x822F5500; continue 'dispatch;
	}
	// 822F54F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F54F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F54FC: 419A0034  beq cr6, 0x822f5530
	if ctx.cr[6].eq {
	pc = 0x822F5530; continue 'dispatch;
	}
	pc = 0x822F5500; continue 'dispatch;
            }
            0x822F5500 => {
    //   block [0x822F5500..0x822F5530)
	// 822F5500: 389FFFE4  addi r4, r31, -0x1c
	ctx.r[4].s64 = ctx.r[31].s64 + -28;
	// 822F5504: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 822F5508: 4BFF8299  bl 0x822ed7a0
	ctx.lr = 0x822F550C;
	sub_822ED7A0(ctx, base);
	// 822F550C: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F5510: 809FFFFC  lwz r4, -4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822F5514: 48097C9D  bl 0x8238d1b0
	ctx.lr = 0x822F5518;
	sub_8238D1B0(ctx, base);
	// 822F5518: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F551C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822F5520: 909E0000  stw r4, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 822F5524: 419A000C  beq cr6, 0x822f5530
	if ctx.cr[6].eq {
	pc = 0x822F5530; continue 'dispatch;
	}
	// 822F5528: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 822F552C: 4BFF89A5  bl 0x822eded0
	ctx.lr = 0x822F5530;
	sub_822EDED0(ctx, base);
	pc = 0x822F5530; continue 'dispatch;
            }
            0x822F5530 => {
    //   block [0x822F5530..0x822F5544)
	// 822F5530: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 822F5534: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F5538: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 822F553C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822F5540: 409AFFA8  bne cr6, 0x822f54e8
	if !ctx.cr[6].eq {
	pc = 0x822F54E8; continue 'dispatch;
	}
	pc = 0x822F5544; continue 'dispatch;
            }
            0x822F5544 => {
    //   block [0x822F5544..0x822F5554)
	// 822F5544: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 822F5548: 92750120  stw r19, 0x120(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(288 as u32), ctx.r[19].u32 ) };
	// 822F554C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 822F5550: 4BFF85F1  bl 0x822edb40
	ctx.lr = 0x822F5554;
	sub_822EDB40(ctx, base);
	pc = 0x822F5554; continue 'dispatch;
            }
            0x822F5554 => {
    //   block [0x822F5554..0x822F5560)
	// 822F5554: 38210520  addi r1, r1, 0x520
	ctx.r[1].s64 = ctx.r[1].s64 + 1312;
	// 822F5558: CBE1FF78  lfd f31, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 822F555C: 4823FB80  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


