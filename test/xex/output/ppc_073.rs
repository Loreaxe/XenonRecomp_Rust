pub fn sub_8284D5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8284D5F0 size=364
    let mut pc: u32 = 0x8284D5F0;
    'dispatch: loop {
        match pc {
            0x8284D5F0 => {
    //   block [0x8284D5F0..0x8284D65C)
	// 8284D5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284D5F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8284D5F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8284D5FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8284D600: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284D604: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 8284D608: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8284D60C: 813F6AB8  lwz r9, 0x6ab8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284D610: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284D614: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284D618: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284D61C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284D620: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8284D624: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 8284D628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284D62C: 419A0088  beq cr6, 0x8284d6b4
	if ctx.cr[6].eq {
	pc = 0x8284D6B4; continue 'dispatch;
	}
	// 8284D630: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284D634: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284D638: 419A0074  beq cr6, 0x8284d6ac
	if ctx.cr[6].eq {
	pc = 0x8284D6AC; continue 'dispatch;
	}
	// 8284D63C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8284D640: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284D644: 419A0018  beq cr6, 0x8284d65c
	if ctx.cr[6].eq {
	pc = 0x8284D65C; continue 'dispatch;
	}
	// 8284D648: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8284D64C: 55480672  rlwinm r8, r10, 0, 0x19, 0x19
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8284D650: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8284D654: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8284D658: 409A0008  bne cr6, 0x8284d660
	if !ctx.cr[6].eq {
	pc = 0x8284D660; continue 'dispatch;
	}
	pc = 0x8284D65C; continue 'dispatch;
            }
            0x8284D65C => {
    //   block [0x8284D65C..0x8284D660)
	// 8284D65C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8284D660; continue 'dispatch;
            }
            0x8284D660 => {
    //   block [0x8284D660..0x8284D690)
	// 8284D660: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8284D664: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284D668: 419A0054  beq cr6, 0x8284d6bc
	if ctx.cr[6].eq {
	pc = 0x8284D6BC; continue 'dispatch;
	}
	// 8284D66C: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8284D670: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8284D674: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8284D678: 409A0018  bne cr6, 0x8284d690
	if !ctx.cr[6].eq {
	pc = 0x8284D690; continue 'dispatch;
	}
	// 8284D67C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8284D680: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8284D684: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8284D688: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284D68C: 419A0008  beq cr6, 0x8284d694
	if ctx.cr[6].eq {
	pc = 0x8284D694; continue 'dispatch;
	}
	pc = 0x8284D690; continue 'dispatch;
            }
            0x8284D690 => {
    //   block [0x8284D690..0x8284D694)
	// 8284D690: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8284D694; continue 'dispatch;
            }
            0x8284D694 => {
    //   block [0x8284D694..0x8284D6AC)
	// 8284D694: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284D698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284D69C: 419A0020  beq cr6, 0x8284d6bc
	if ctx.cr[6].eq {
	pc = 0x8284D6BC; continue 'dispatch;
	}
	// 8284D6A0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8284D6A4: 886B6D46  lbz r3, 0x6d46(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27974 as u32) ) } as u64;
	// 8284D6A8: 4800009C  b 0x8284d744
	pc = 0x8284D744; continue 'dispatch;
            }
            0x8284D6AC => {
    //   block [0x8284D6AC..0x8284D6B4)
	// 8284D6AC: 4B94678D  bl 0x82193e38
	ctx.lr = 0x8284D6B0;
	sub_82193E38(ctx, base);
	// 8284D6B0: 813F6AB8  lwz r9, 0x6ab8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	pc = 0x8284D6B4; continue 'dispatch;
            }
            0x8284D6B4 => {
    //   block [0x8284D6B4..0x8284D6BC)
	// 8284D6B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8284D6B8: 4BFFFFA4  b 0x8284d65c
	pc = 0x8284D65C; continue 'dispatch;
            }
            0x8284D6BC => {
    //   block [0x8284D6BC..0x8284D6EC)
	// 8284D6BC: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284D6C0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284D6C4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284D6C8: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284D6CC: 480983AD  bl 0x828e5a78
	ctx.lr = 0x8284D6D0;
	sub_828E5A78(ctx, base);
	// 8284D6D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284D6D4: 419A0018  beq cr6, 0x8284d6ec
	if ctx.cr[6].eq {
	pc = 0x8284D6EC; continue 'dispatch;
	}
	// 8284D6D8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8284D6DC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8284D6E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284D6E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284D6E8: 409A0008  bne cr6, 0x8284d6f0
	if !ctx.cr[6].eq {
	pc = 0x8284D6F0; continue 'dispatch;
	}
	pc = 0x8284D6EC; continue 'dispatch;
            }
            0x8284D6EC => {
    //   block [0x8284D6EC..0x8284D6F0)
	// 8284D6EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8284D6F0; continue 'dispatch;
            }
            0x8284D6F0 => {
    //   block [0x8284D6F0..0x8284D720)
	// 8284D6F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284D6F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284D6F8: 419A0044  beq cr6, 0x8284d73c
	if ctx.cr[6].eq {
	pc = 0x8284D73C; continue 'dispatch;
	}
	// 8284D6FC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8284D700: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8284D704: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8284D708: 409A0018  bne cr6, 0x8284d720
	if !ctx.cr[6].eq {
	pc = 0x8284D720; continue 'dispatch;
	}
	// 8284D70C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8284D710: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8284D714: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8284D718: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284D71C: 419A0008  beq cr6, 0x8284d724
	if ctx.cr[6].eq {
	pc = 0x8284D724; continue 'dispatch;
	}
	pc = 0x8284D720; continue 'dispatch;
            }
            0x8284D720 => {
    //   block [0x8284D720..0x8284D724)
	// 8284D720: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8284D724; continue 'dispatch;
            }
            0x8284D724 => {
    //   block [0x8284D724..0x8284D73C)
	// 8284D724: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284D728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284D72C: 419A0010  beq cr6, 0x8284d73c
	if ctx.cr[6].eq {
	pc = 0x8284D73C; continue 'dispatch;
	}
	// 8284D730: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8284D734: 886B6D4C  lbz r3, 0x6d4c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27980 as u32) ) } as u64;
	// 8284D738: 4800000C  b 0x8284d744
	pc = 0x8284D744; continue 'dispatch;
            }
            0x8284D73C => {
    //   block [0x8284D73C..0x8284D744)
	// 8284D73C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8284D740: 886B6D47  lbz r3, 0x6d47(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27975 as u32) ) } as u64;
	pc = 0x8284D744; continue 'dispatch;
            }
            0x8284D744 => {
    //   block [0x8284D744..0x8284D75C)
	// 8284D744: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8284D748: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8284D74C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8284D750: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8284D754: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8284D758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8284D760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8284D760 size=356
    let mut pc: u32 = 0x8284D760;
    'dispatch: loop {
        match pc {
            0x8284D760 => {
    //   block [0x8284D760..0x8284D790)
	// 8284D760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284D764: 4845BCA9  bl 0x82ca940c
	ctx.lr = 0x8284D768;
	sub_82CA93D0(ctx, base);
	// 8284D768: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284D76C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8284D770: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8284D774: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8284D778: 419A0018  beq cr6, 0x8284d790
	if ctx.cr[6].eq {
	pc = 0x8284D790; continue 'dispatch;
	}
	// 8284D77C: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 8284D780: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8284D784: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284D788: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284D78C: 409A0008  bne cr6, 0x8284d794
	if !ctx.cr[6].eq {
	pc = 0x8284D794; continue 'dispatch;
	}
	pc = 0x8284D790; continue 'dispatch;
            }
            0x8284D790 => {
    //   block [0x8284D790..0x8284D794)
	// 8284D790: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8284D794; continue 'dispatch;
            }
            0x8284D794 => {
    //   block [0x8284D794..0x8284D7D8)
	// 8284D794: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284D798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284D79C: 419A0120  beq cr6, 0x8284d8bc
	if ctx.cr[6].eq {
	pc = 0x8284D8BC; continue 'dispatch;
	}
	// 8284D7A0: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 8284D7A4: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284D7A8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284D7AC: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284D7B0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284D7B4: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284D7B8: 4B9DEA01  bl 0x8222c1b8
	ctx.lr = 0x8284D7BC;
	sub_8222C1B8(ctx, base);
	// 8284D7BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284D7C0: 419A0018  beq cr6, 0x8284d7d8
	if ctx.cr[6].eq {
	pc = 0x8284D7D8; continue 'dispatch;
	}
	// 8284D7C4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8284D7C8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8284D7CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284D7D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284D7D4: 409A0008  bne cr6, 0x8284d7dc
	if !ctx.cr[6].eq {
	pc = 0x8284D7DC; continue 'dispatch;
	}
	pc = 0x8284D7D8; continue 'dispatch;
            }
            0x8284D7D8 => {
    //   block [0x8284D7D8..0x8284D7DC)
	// 8284D7D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8284D7DC; continue 'dispatch;
            }
            0x8284D7DC => {
    //   block [0x8284D7DC..0x8284D80C)
	// 8284D7DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284D7E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284D7E4: 419A0048  beq cr6, 0x8284d82c
	if ctx.cr[6].eq {
	pc = 0x8284D82C; continue 'dispatch;
	}
	// 8284D7E8: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8284D7EC: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8284D7F0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8284D7F4: 409A0018  bne cr6, 0x8284d80c
	if !ctx.cr[6].eq {
	pc = 0x8284D80C; continue 'dispatch;
	}
	// 8284D7F8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8284D7FC: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8284D800: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8284D804: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284D808: 419A0008  beq cr6, 0x8284d810
	if ctx.cr[6].eq {
	pc = 0x8284D810; continue 'dispatch;
	}
	pc = 0x8284D80C; continue 'dispatch;
            }
            0x8284D80C => {
    //   block [0x8284D80C..0x8284D810)
	// 8284D80C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8284D810; continue 'dispatch;
            }
            0x8284D810 => {
    //   block [0x8284D810..0x8284D82C)
	// 8284D810: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284D814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284D818: 419A0014  beq cr6, 0x8284d82c
	if ctx.cr[6].eq {
	pc = 0x8284D82C; continue 'dispatch;
	}
	// 8284D81C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8284D820: 9BAB6D46  stb r29, 0x6d46(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(27974 as u32), ctx.r[29].u8 ) };
	// 8284D824: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8284D828: 4845BC34  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8284D82C => {
    //   block [0x8284D82C..0x8284D860)
	// 8284D82C: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284D830: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284D834: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284D838: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284D83C: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284D840: 48098239  bl 0x828e5a78
	ctx.lr = 0x8284D844;
	sub_828E5A78(ctx, base);
	// 8284D844: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284D848: 419A0018  beq cr6, 0x8284d860
	if ctx.cr[6].eq {
	pc = 0x8284D860; continue 'dispatch;
	}
	// 8284D84C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8284D850: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8284D854: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284D858: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284D85C: 409A0008  bne cr6, 0x8284d864
	if !ctx.cr[6].eq {
	pc = 0x8284D864; continue 'dispatch;
	}
	pc = 0x8284D860; continue 'dispatch;
            }
            0x8284D860 => {
    //   block [0x8284D860..0x8284D864)
	// 8284D860: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8284D864; continue 'dispatch;
            }
            0x8284D864 => {
    //   block [0x8284D864..0x8284D894)
	// 8284D864: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284D868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284D86C: 419A0048  beq cr6, 0x8284d8b4
	if ctx.cr[6].eq {
	pc = 0x8284D8B4; continue 'dispatch;
	}
	// 8284D870: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8284D874: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8284D878: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8284D87C: 409A0018  bne cr6, 0x8284d894
	if !ctx.cr[6].eq {
	pc = 0x8284D894; continue 'dispatch;
	}
	// 8284D880: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8284D884: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8284D888: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8284D88C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284D890: 419A0008  beq cr6, 0x8284d898
	if ctx.cr[6].eq {
	pc = 0x8284D898; continue 'dispatch;
	}
	pc = 0x8284D894; continue 'dispatch;
            }
            0x8284D894 => {
    //   block [0x8284D894..0x8284D898)
	// 8284D894: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8284D898; continue 'dispatch;
            }
            0x8284D898 => {
    //   block [0x8284D898..0x8284D8B4)
	// 8284D898: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284D89C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284D8A0: 419A0014  beq cr6, 0x8284d8b4
	if ctx.cr[6].eq {
	pc = 0x8284D8B4; continue 'dispatch;
	}
	// 8284D8A4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8284D8A8: 9BAB6D4C  stb r29, 0x6d4c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(27980 as u32), ctx.r[29].u8 ) };
	// 8284D8AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8284D8B0: 4845BBAC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8284D8B4 => {
    //   block [0x8284D8B4..0x8284D8BC)
	// 8284D8B4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8284D8B8: 9BAB6D47  stb r29, 0x6d47(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(27975 as u32), ctx.r[29].u8 ) };
	pc = 0x8284D8BC; continue 'dispatch;
            }
            0x8284D8BC => {
    //   block [0x8284D8BC..0x8284D8C4)
	// 8284D8BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8284D8C0: 4845BB9C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8284D8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8284D8C8 size=2808
    let mut pc: u32 = 0x8284D8C8;
    'dispatch: loop {
        match pc {
            0x8284D8C8 => {
    //   block [0x8284D8C8..0x8284D938)
	// 8284D8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284D8CC: 4845BB15  bl 0x82ca93e0
	ctx.lr = 0x8284D8D0;
	sub_82CA93D0(ctx, base);
	// 8284D8D0: DBE1FF80  stfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 8284D8D4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284D8D8: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 8284D8DC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8284D8E0: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 8284D8E4: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 8284D8E8: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 8284D8EC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8284D8F0: 81770034  lwz r11, 0x34(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(52 as u32) ) } as u64;
	// 8284D8F4: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 8284D8F8: 3A400001  li r18, 1
	ctx.r[18].s64 = 1;
	// 8284D8FC: 556A37FE  rlwinm r10, r11, 6, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 8284D900: 7E7C9B78  mr r28, r19
	ctx.r[28].u64 = ctx.r[19].u64;
	// 8284D904: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284D908: 419A00F4  beq cr6, 0x8284d9fc
	if ctx.cr[6].eq {
	pc = 0x8284D9FC; continue 'dispatch;
	}
	// 8284D90C: 8177008C  lwz r11, 0x8c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(140 as u32) ) } as u64;
	// 8284D910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284D914: 419A0024  beq cr6, 0x8284d938
	if ctx.cr[6].eq {
	pc = 0x8284D938; continue 'dispatch;
	}
	// 8284D918: 894B009A  lbz r10, 0x9a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(154 as u32) ) } as u64;
	// 8284D91C: 81770048  lwz r11, 0x48(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284D920: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8284D924: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8284D928: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284D92C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8284D930: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284D934: 480000CC  b 0x8284da00
	pc = 0x8284DA00; continue 'dispatch;
            }
            0x8284D938 => {
    //   block [0x8284D938..0x8284D954)
	// 8284D938: 81570048  lwz r10, 0x48(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284D93C: 80B7004C  lwz r5, 0x4c(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(76 as u32) ) } as u64;
	// 8284D940: 92610068  stw r19, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[19].u32 ) };
	// 8284D944: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 8284D948: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 8284D94C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284D950: 40810054  ble 0x8284d9a4
	if !ctx.cr[0].gt {
	pc = 0x8284D9A4; continue 'dispatch;
	}
	pc = 0x8284D954; continue 'dispatch;
            }
            0x8284D954 => {
    //   block [0x8284D954..0x8284D974)
	// 8284D954: 7D680E70  srawi r8, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8284D958: 55071838  slwi r7, r8, 3
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8284D95C: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 8284D960: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284D964: 2F06009A  cmpwi cr6, r6, 0x9a
	ctx.cr[6].compare_i32(ctx.r[6].s32, 154, &mut ctx.xer);
	// 8284D968: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 8284D96C: 41980008  blt cr6, 0x8284d974
	if ctx.cr[6].lt {
	pc = 0x8284D974; continue 'dispatch;
	}
	// 8284D970: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	pc = 0x8284D974; continue 'dispatch;
            }
            0x8284D974 => {
    //   block [0x8284D974..0x8284D990)
	// 8284D974: 54C6063E  clrlwi r6, r6, 0x18
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 8284D978: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8284D97C: 419A0014  beq cr6, 0x8284d990
	if ctx.cr[6].eq {
	pc = 0x8284D990; continue 'dispatch;
	}
	// 8284D980: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 8284D984: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8284D988: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8284D98C: 4800000C  b 0x8284d998
	pc = 0x8284D998; continue 'dispatch;
            }
            0x8284D990 => {
    //   block [0x8284D990..0x8284D998)
	// 8284D990: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 8284D994: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x8284D998; continue 'dispatch;
            }
            0x8284D998 => {
    //   block [0x8284D998..0x8284D9A4)
	// 8284D998: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284D99C: 4199FFB8  bgt cr6, 0x8284d954
	if ctx.cr[6].gt {
	pc = 0x8284D954; continue 'dispatch;
	}
	// 8284D9A0: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x8284D9A4; continue 'dispatch;
            }
            0x8284D9A4 => {
    //   block [0x8284D9A4..0x8284D9C0)
	// 8284D9A4: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8284D9A8: 419A0040  beq cr6, 0x8284d9e8
	if ctx.cr[6].eq {
	pc = 0x8284D9E8; continue 'dispatch;
	}
	// 8284D9AC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284D9B0: 2F0B009A  cmpwi cr6, r11, 0x9a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 154, &mut ctx.xer);
	// 8284D9B4: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284D9B8: 41990008  bgt cr6, 0x8284d9c0
	if ctx.cr[6].gt {
	pc = 0x8284D9C0; continue 'dispatch;
	}
	// 8284D9BC: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	pc = 0x8284D9C0; continue 'dispatch;
            }
            0x8284D9C0 => {
    //   block [0x8284D9C0..0x8284D9E8)
	// 8284D9C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284D9C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284D9C8: 409A0020  bne cr6, 0x8284d9e8
	if !ctx.cr[6].eq {
	pc = 0x8284D9E8; continue 'dispatch;
	}
	// 8284D9CC: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8284D9D0: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 8284D9D4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8284D9D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284D9DC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8284D9E0: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284D9E4: 4800001C  b 0x8284da00
	pc = 0x8284DA00; continue 'dispatch;
            }
            0x8284D9E8 => {
    //   block [0x8284D9E8..0x8284D9FC)
	// 8284D9E8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8284D9EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284D9F0: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8284D9F4: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284D9F8: 48000008  b 0x8284da00
	pc = 0x8284DA00; continue 'dispatch;
            }
            0x8284D9FC => {
    //   block [0x8284D9FC..0x8284DA00)
	// 8284D9FC: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	pc = 0x8284DA00; continue 'dispatch;
            }
            0x8284DA00 => {
    //   block [0x8284DA00..0x8284DAB0)
	// 8284DA00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284DA04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DA08: 419A09AC  beq cr6, 0x8284e3b4
	if ctx.cr[6].eq {
	pc = 0x8284E3B4; continue 'dispatch;
	}
	// 8284DA0C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284DA10: 3D40811C  lis r10, -0x7ee4
	ctx.r[10].s64 = -2128871424;
	// 8284DA14: 83430000  lwz r26, 0(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284DA18: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8284DA1C: E9170014  ld r8, 0x14(r23)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) };
	// 8284DA20: 61569DC5  ori r22, r10, 0x9dc5
	ctx.r[22].u64 = ctx.r[10].u64 | 40389;
	// 8284DA24: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8284DA28: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 8284DA2C: F9010070  std r8, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	// 8284DA30: 419A00E8  beq cr6, 0x8284db18
	if ctx.cr[6].eq {
	pc = 0x8284DB18; continue 'dispatch;
	}
	// 8284DA34: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 8284DA38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8284DA3C: 4B98C90D  bl 0x821da348
	ctx.lr = 0x8284DA40;
	sub_821DA348(ctx, base);
	// 8284DA40: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8284DA44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DA48: 419A00D0  beq cr6, 0x8284db18
	if ctx.cr[6].eq {
	pc = 0x8284DB18; continue 'dispatch;
	}
	// 8284DA4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8284DA50: 4B964AA9  bl 0x821b24f8
	ctx.lr = 0x8284DA54;
	sub_821B24F8(ctx, base);
	// 8284DA54: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8284DA58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8284DA5C: 3BEB8E84  addi r31, r11, -0x717c
	ctx.r[31].s64 = ctx.r[11].s64 + -29052;
	// 8284DA60: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8284DA64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284DA68: 4B9A62F1  bl 0x821f3d58
	ctx.lr = 0x8284DA6C;
	sub_821F3D58(ctx, base);
	// 8284DA6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8284DA70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284DA74: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 8284DA78: 481B2C51  bl 0x82a006c8
	ctx.lr = 0x8284DA7C;
	sub_82A006C8(ctx, base);
	// 8284DA7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284DA80: 419A0098  beq cr6, 0x8284db18
	if ctx.cr[6].eq {
	pc = 0x8284DB18; continue 'dispatch;
	}
	// 8284DA84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284DA88: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8284DA8C: 4B9A62CD  bl 0x821f3d58
	ctx.lr = 0x8284DA90;
	sub_821F3D58(ctx, base);
	// 8284DA90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8284DA94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284DA98: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 8284DA9C: 481B2C2D  bl 0x82a006c8
	ctx.lr = 0x8284DAA0;
	sub_82A006C8(ctx, base);
	// 8284DAA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284DAA4: 419A000C  beq cr6, 0x8284dab0
	if ctx.cr[6].eq {
	pc = 0x8284DAB0; continue 'dispatch;
	}
	// 8284DAA8: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284DAAC: 48000008  b 0x8284dab4
	pc = 0x8284DAB4; continue 'dispatch;
            }
            0x8284DAB0 => {
    //   block [0x8284DAB0..0x8284DAB4)
	// 8284DAB0: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	pc = 0x8284DAB4; continue 'dispatch;
            }
            0x8284DAB4 => {
    //   block [0x8284DAB4..0x8284DB00)
	// 8284DAB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8284DAB8: 4B98C891  bl 0x821da348
	ctx.lr = 0x8284DABC;
	sub_821DA348(ctx, base);
	// 8284DABC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8284DAC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DAC4: 419A0054  beq cr6, 0x8284db18
	if ctx.cr[6].eq {
	pc = 0x8284DB18; continue 'dispatch;
	}
	// 8284DAC8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8284DACC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8284DAD0: 386B8EA4  addi r3, r11, -0x715c
	ctx.r[3].s64 = ctx.r[11].s64 + -29020;
	// 8284DAD4: 4B9A6285  bl 0x821f3d58
	ctx.lr = 0x8284DAD8;
	sub_821F3D58(ctx, base);
	// 8284DAD8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8284DADC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8284DAE0: 4B964A19  bl 0x821b24f8
	ctx.lr = 0x8284DAE4;
	sub_821B24F8(ctx, base);
	// 8284DAE4: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8284DAE8: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 8284DAEC: 481B2BDD  bl 0x82a006c8
	ctx.lr = 0x8284DAF0;
	sub_82A006C8(ctx, base);
	// 8284DAF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284DAF4: 419A000C  beq cr6, 0x8284db00
	if ctx.cr[6].eq {
	pc = 0x8284DB00; continue 'dispatch;
	}
	// 8284DAF8: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284DAFC: 48000008  b 0x8284db04
	pc = 0x8284DB04; continue 'dispatch;
            }
            0x8284DB00 => {
    //   block [0x8284DB00..0x8284DB04)
	// 8284DB00: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	pc = 0x8284DB04; continue 'dispatch;
            }
            0x8284DB04 => {
    //   block [0x8284DB04..0x8284DB18)
	// 8284DB04: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8284DB08: 4B98C841  bl 0x821da348
	ctx.lr = 0x8284DB0C;
	sub_821DA348(ctx, base);
	// 8284DB0C: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8284DB10: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 8284DB14: 83410068  lwz r26, 0x68(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	pc = 0x8284DB18; continue 'dispatch;
            }
            0x8284DB18 => {
    //   block [0x8284DB18..0x8284DBA4)
	// 8284DB18: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8284DB1C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8284DB20: 38EB9EC8  addi r7, r11, -0x6138
	ctx.r[7].s64 = ctx.r[11].s64 + -24888;
	// 8284DB24: 4B9649D5  bl 0x821b24f8
	ctx.lr = 0x8284DB28;
	sub_821B24F8(ctx, base);
	// 8284DB28: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8284DB2C: 4BA5BEBD  bl 0x822a99e8
	ctx.lr = 0x8284DB30;
	sub_822A99E8(ctx, base);
	// 8284DB30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8284DB34: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 8284DB38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8284DB3C: 419A0120  beq cr6, 0x8284dc5c
	if ctx.cr[6].eq {
	pc = 0x8284DC5C; continue 'dispatch;
	}
	// 8284DB40: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8284DB44: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8284DB48: 3BABC0D8  addi r29, r11, -0x3f28
	ctx.r[29].s64 = ctx.r[11].s64 + -16168;
	// 8284DB4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8284DB50: 4B9A6209  bl 0x821f3d58
	ctx.lr = 0x8284DB54;
	sub_821F3D58(ctx, base);
	// 8284DB54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8284DB58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284DB5C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 8284DB60: 481B2B69  bl 0x82a006c8
	ctx.lr = 0x8284DB64;
	sub_82A006C8(ctx, base);
	// 8284DB64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284DB68: 419A00F4  beq cr6, 0x8284dc5c
	if ctx.cr[6].eq {
	pc = 0x8284DC5C; continue 'dispatch;
	}
	// 8284DB6C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8284DB70: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8284DB74: 3BCB04D8  addi r30, r11, 0x4d8
	ctx.r[30].s64 = ctx.r[11].s64 + 1240;
	// 8284DB78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284DB7C: 4B9A61DD  bl 0x821f3d58
	ctx.lr = 0x8284DB80;
	sub_821F3D58(ctx, base);
	// 8284DB80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8284DB84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284DB88: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 8284DB8C: 481B2B3D  bl 0x82a006c8
	ctx.lr = 0x8284DB90;
	sub_82A006C8(ctx, base);
	// 8284DB90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284DB94: 419A00C8  beq cr6, 0x8284dc5c
	if ctx.cr[6].eq {
	pc = 0x8284DC5C; continue 'dispatch;
	}
	// 8284DB98: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8284DB9C: 92610050  stw r19, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[19].u32 ) };
	// 8284DBA0: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x8284DBA4; continue 'dispatch;
            }
            0x8284DBA4 => {
    //   block [0x8284DBA4..0x8284DBE0)
	// 8284DBA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8284DBA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8284DBAC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8284DBB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8284DBB4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8284DBB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8284DBBC: 4082FFE8  bne 0x8284dba4
	if !ctx.cr[0].eq {
	pc = 0x8284DBA4; continue 'dispatch;
	}
	// 8284DBC0: 5767063E  clrlwi r7, r27, 0x18
	ctx.r[7].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 8284DBC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284DBC8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8284DBCC: 419A0014  beq cr6, 0x8284dbe0
	if ctx.cr[6].eq {
	pc = 0x8284DBE0; continue 'dispatch;
	}
	// 8284DBD0: 568B063E  clrlwi r11, r20, 0x18
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0x000000FFu64;
	// 8284DBD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8284DBD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DBDC: 419A0008  beq cr6, 0x8284dbe4
	if ctx.cr[6].eq {
	pc = 0x8284DBE4; continue 'dispatch;
	}
	pc = 0x8284DBE0; continue 'dispatch;
            }
            0x8284DBE0 => {
    //   block [0x8284DBE0..0x8284DBE4)
	// 8284DBE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x8284DBE4; continue 'dispatch;
            }
            0x8284DBE4 => {
    //   block [0x8284DBE4..0x8284DC54)
	// 8284DBE4: 4BAD595D  bl 0x82323540
	ctx.lr = 0x8284DBE8;
	sub_82323540(ctx, base);
	// 8284DBE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8284DBEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284DBF0: 4BA27849  bl 0x82275438
	ctx.lr = 0x8284DBF4;
	sub_82275438(ctx, base);
	// 8284DBF4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8284DBF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DBFC: 419A0058  beq cr6, 0x8284dc54
	if ctx.cr[6].eq {
	pc = 0x8284DC54; continue 'dispatch;
	}
	// 8284DC00: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284DC04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284DC08: 419A004C  beq cr6, 0x8284dc54
	if ctx.cr[6].eq {
	pc = 0x8284DC54; continue 'dispatch;
	}
	// 8284DC0C: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284DC10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8284DC14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8284DC18: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284DC1C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284DC20: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284DC24: 83E90028  lwz r31, 0x28(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 8284DC28: 4B9A2619  bl 0x821f0240
	ctx.lr = 0x8284DC2C;
	sub_821F0240(ctx, base);
	// 8284DC2C: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 8284DC30: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8284DC34: 3888C0E4  addi r4, r8, -0x3f1c
	ctx.r[4].s64 = ctx.r[8].s64 + -16156;
	// 8284DC38: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8284DC3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8284DC40: 4B9DF291  bl 0x8222ced0
	ctx.lr = 0x8284DC44;
	sub_8222CED0(ctx, base);
	// 8284DC44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8284DC48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284DC4C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8284DC50: 4BC2CE21  bl 0x8247aa70
	ctx.lr = 0x8284DC54;
	sub_8247AA70(ctx, base);
	pc = 0x8284DC54; continue 'dispatch;
            }
            0x8284DC54 => {
    //   block [0x8284DC54..0x8284DC5C)
	// 8284DC54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284DC58: 4B9C7181  bl 0x82214dd8
	ctx.lr = 0x8284DC5C;
	sub_82214DD8(ctx, base);
	pc = 0x8284DC5C; continue 'dispatch;
            }
            0x8284DC5C => {
    //   block [0x8284DC5C..0x8284DC84)
	// 8284DC5C: 577B063E  clrlwi r27, r27, 0x18
	ctx.r[27].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 8284DC60: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8284DC64: 419A002C  beq cr6, 0x8284dc90
	if ctx.cr[6].eq {
	pc = 0x8284DC90; continue 'dispatch;
	}
	// 8284DC68: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8284DC6C: 419A0024  beq cr6, 0x8284dc90
	if ctx.cr[6].eq {
	pc = 0x8284DC90; continue 'dispatch;
	}
	// 8284DC70: 568B063E  clrlwi r11, r20, 0x18
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0x000000FFu64;
	// 8284DC74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DC78: 419A000C  beq cr6, 0x8284dc84
	if ctx.cr[6].eq {
	pc = 0x8284DC84; continue 'dispatch;
	}
	// 8284DC7C: 9A5C000E  stb r18, 0xe(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(14 as u32), ctx.r[18].u8 ) };
	// 8284DC80: 48000008  b 0x8284dc88
	pc = 0x8284DC88; continue 'dispatch;
            }
            0x8284DC84 => {
    //   block [0x8284DC84..0x8284DC88)
	// 8284DC84: 9A5C000F  stb r18, 0xf(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(15 as u32), ctx.r[18].u8 ) };
	pc = 0x8284DC88; continue 'dispatch;
            }
            0x8284DC88 => {
    //   block [0x8284DC88..0x8284DC90)
	// 8284DC88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8284DC8C: 4BBC9DC5  bl 0x82417a50
	ctx.lr = 0x8284DC90;
	sub_82417A50(ctx, base);
	pc = 0x8284DC90; continue 'dispatch;
            }
            0x8284DC90 => {
    //   block [0x8284DC90..0x8284DCFC)
	// 8284DC90: 3FA08332  lis r29, -0x7cce
	ctx.r[29].s64 = -2093875200;
	// 8284DC94: 7E5E9378  mr r30, r18
	ctx.r[30].u64 = ctx.r[18].u64;
	// 8284DC98: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8284DC9C: 419A0298  beq cr6, 0x8284df34
	if ctx.cr[6].eq {
	pc = 0x8284DF34; continue 'dispatch;
	}
	// 8284DCA0: 568B063E  clrlwi r11, r20, 0x18
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0x000000FFu64;
	// 8284DCA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DCA8: 419A028C  beq cr6, 0x8284df34
	if ctx.cr[6].eq {
	pc = 0x8284DF34; continue 'dispatch;
	}
	// 8284DCAC: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284DCB0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284DCB4: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284DCB8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284DCBC: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284DCC0: 4B9DE4F9  bl 0x8222c1b8
	ctx.lr = 0x8284DCC4;
	sub_8222C1B8(ctx, base);
	// 8284DCC4: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284DCC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8284DCCC: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284DCD0: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284DCD4: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284DCD8: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284DCDC: 48097D9D  bl 0x828e5a78
	ctx.lr = 0x8284DCE0;
	sub_828E5A78(ctx, base);
	// 8284DCE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284DCE4: 419A0018  beq cr6, 0x8284dcfc
	if ctx.cr[6].eq {
	pc = 0x8284DCFC; continue 'dispatch;
	}
	// 8284DCE8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8284DCEC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8284DCF0: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284DCF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284DCF8: 409A0008  bne cr6, 0x8284dd00
	if !ctx.cr[6].eq {
	pc = 0x8284DD00; continue 'dispatch;
	}
	pc = 0x8284DCFC; continue 'dispatch;
            }
            0x8284DCFC => {
    //   block [0x8284DCFC..0x8284DD00)
	// 8284DCFC: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	pc = 0x8284DD00; continue 'dispatch;
            }
            0x8284DD00 => {
    //   block [0x8284DD00..0x8284DD28)
	// 8284DD00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284DD04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DD08: 419A022C  beq cr6, 0x8284df34
	if ctx.cr[6].eq {
	pc = 0x8284DF34; continue 'dispatch;
	}
	// 8284DD0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8284DD10: 419A0018  beq cr6, 0x8284dd28
	if ctx.cr[6].eq {
	pc = 0x8284DD28; continue 'dispatch;
	}
	// 8284DD14: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 8284DD18: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8284DD1C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284DD20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284DD24: 409A0008  bne cr6, 0x8284dd2c
	if !ctx.cr[6].eq {
	pc = 0x8284DD2C; continue 'dispatch;
	}
	pc = 0x8284DD28; continue 'dispatch;
            }
            0x8284DD28 => {
    //   block [0x8284DD28..0x8284DD2C)
	// 8284DD28: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	pc = 0x8284DD2C; continue 'dispatch;
            }
            0x8284DD2C => {
    //   block [0x8284DD2C..0x8284DD60)
	// 8284DD2C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284DD30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DD34: 419A0200  beq cr6, 0x8284df34
	if ctx.cr[6].eq {
	pc = 0x8284DF34; continue 'dispatch;
	}
	// 8284DD38: 81570014  lwz r10, 0x14(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 8284DD3C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 8284DD40: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8284DD44: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8284DD48: 409A0018  bne cr6, 0x8284dd60
	if !ctx.cr[6].eq {
	pc = 0x8284DD60; continue 'dispatch;
	}
	// 8284DD4C: 81570018  lwz r10, 0x18(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 8284DD50: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8284DD54: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8284DD58: 7E4A9378  mr r10, r18
	ctx.r[10].u64 = ctx.r[18].u64;
	// 8284DD5C: 419A0008  beq cr6, 0x8284dd64
	if ctx.cr[6].eq {
	pc = 0x8284DD64; continue 'dispatch;
	}
	pc = 0x8284DD60; continue 'dispatch;
            }
            0x8284DD60 => {
    //   block [0x8284DD60..0x8284DD64)
	// 8284DD60: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	pc = 0x8284DD64; continue 'dispatch;
            }
            0x8284DD64 => {
    //   block [0x8284DD64..0x8284DD74)
	// 8284DD64: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8284DD68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284DD6C: 419A0008  beq cr6, 0x8284dd74
	if ctx.cr[6].eq {
	pc = 0x8284DD74; continue 'dispatch;
	}
	// 8284DD70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x8284DD74; continue 'dispatch;
            }
            0x8284DD74 => {
    //   block [0x8284DD74..0x8284DDB4)
	// 8284DD74: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8284DD78: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 8284DD7C: 552837FE  rlwinm r8, r9, 6, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x03FFFFFFu64;
	// 8284DD80: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8284DD84: 419A00F4  beq cr6, 0x8284de78
	if ctx.cr[6].eq {
	pc = 0x8284DE78; continue 'dispatch;
	}
	// 8284DD88: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8284DD8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284DD90: 419A0024  beq cr6, 0x8284ddb4
	if ctx.cr[6].eq {
	pc = 0x8284DDB4; continue 'dispatch;
	}
	// 8284DD94: 894A009A  lbz r10, 0x9a(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(154 as u32) ) } as u64;
	// 8284DD98: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284DD9C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8284DDA0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8284DDA4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284DDA8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8284DDAC: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284DDB0: 480000CC  b 0x8284de7c
	pc = 0x8284DE7C; continue 'dispatch;
            }
            0x8284DDB4 => {
    //   block [0x8284DDB4..0x8284DDD0)
	// 8284DDB4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284DDB8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8284DDBC: 92610060  stw r19, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[19].u32 ) };
	// 8284DDC0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8284DDC4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 8284DDC8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284DDCC: 40810054  ble 0x8284de20
	if !ctx.cr[0].gt {
	pc = 0x8284DE20; continue 'dispatch;
	}
	pc = 0x8284DDD0; continue 'dispatch;
            }
            0x8284DDD0 => {
    //   block [0x8284DDD0..0x8284DDF0)
	// 8284DDD0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8284DDD4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8284DDD8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8284DDDC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284DDE0: 2F07009A  cmpwi cr6, r7, 0x9a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 154, &mut ctx.xer);
	// 8284DDE4: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	// 8284DDE8: 41980008  blt cr6, 0x8284ddf0
	if ctx.cr[6].lt {
	pc = 0x8284DDF0; continue 'dispatch;
	}
	// 8284DDEC: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	pc = 0x8284DDF0; continue 'dispatch;
            }
            0x8284DDF0 => {
    //   block [0x8284DDF0..0x8284DE0C)
	// 8284DDF0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8284DDF4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8284DDF8: 419A0014  beq cr6, 0x8284de0c
	if ctx.cr[6].eq {
	pc = 0x8284DE0C; continue 'dispatch;
	}
	// 8284DDFC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8284DE00: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8284DE04: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8284DE08: 4800000C  b 0x8284de14
	pc = 0x8284DE14; continue 'dispatch;
            }
            0x8284DE0C => {
    //   block [0x8284DE0C..0x8284DE14)
	// 8284DE0C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8284DE10: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8284DE14; continue 'dispatch;
            }
            0x8284DE14 => {
    //   block [0x8284DE14..0x8284DE20)
	// 8284DE14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284DE18: 4199FFB8  bgt cr6, 0x8284ddd0
	if ctx.cr[6].gt {
	pc = 0x8284DDD0; continue 'dispatch;
	}
	// 8284DE1C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x8284DE20; continue 'dispatch;
            }
            0x8284DE20 => {
    //   block [0x8284DE20..0x8284DE3C)
	// 8284DE20: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8284DE24: 419A0040  beq cr6, 0x8284de64
	if ctx.cr[6].eq {
	pc = 0x8284DE64; continue 'dispatch;
	}
	// 8284DE28: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284DE2C: 2F0B009A  cmpwi cr6, r11, 0x9a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 154, &mut ctx.xer);
	// 8284DE30: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284DE34: 41990008  bgt cr6, 0x8284de3c
	if ctx.cr[6].gt {
	pc = 0x8284DE3C; continue 'dispatch;
	}
	// 8284DE38: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	pc = 0x8284DE3C; continue 'dispatch;
            }
            0x8284DE3C => {
    //   block [0x8284DE3C..0x8284DE64)
	// 8284DE3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284DE40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DE44: 409A0020  bne cr6, 0x8284de64
	if !ctx.cr[6].eq {
	pc = 0x8284DE64; continue 'dispatch;
	}
	// 8284DE48: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8284DE4C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8284DE50: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8284DE54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284DE58: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8284DE5C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284DE60: 4800001C  b 0x8284de7c
	pc = 0x8284DE7C; continue 'dispatch;
            }
            0x8284DE64 => {
    //   block [0x8284DE64..0x8284DE78)
	// 8284DE64: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8284DE68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284DE6C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8284DE70: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284DE74: 48000008  b 0x8284de7c
	pc = 0x8284DE7C; continue 'dispatch;
            }
            0x8284DE78 => {
    //   block [0x8284DE78..0x8284DE7C)
	// 8284DE78: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	pc = 0x8284DE7C; continue 'dispatch;
            }
            0x8284DE7C => {
    //   block [0x8284DE7C..0x8284DE94)
	// 8284DE7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284DE80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DE84: 419A0010  beq cr6, 0x8284de94
	if ctx.cr[6].eq {
	pc = 0x8284DE94; continue 'dispatch;
	}
	// 8284DE88: 896A000C  lbz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284DE8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DE90: 409A0044  bne cr6, 0x8284ded4
	if !ctx.cr[6].eq {
	pc = 0x8284DED4; continue 'dispatch;
	}
	pc = 0x8284DE94; continue 'dispatch;
            }
            0x8284DE94 => {
    //   block [0x8284DE94..0x8284DEC4)
	// 8284DE94: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284DE98: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284DE9C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284DEA0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284DEA4: 80E8001C  lwz r7, 0x1c(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 8284DEA8: 81670234  lwz r11, 0x234(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(564 as u32) ) } as u64;
	// 8284DEAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DEB0: 419A0014  beq cr6, 0x8284dec4
	if ctx.cr[6].eq {
	pc = 0x8284DEC4; continue 'dispatch;
	}
	// 8284DEB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284DEB8: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8284DEBC: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284DEC0: 419A0008  beq cr6, 0x8284dec8
	if ctx.cr[6].eq {
	pc = 0x8284DEC8; continue 'dispatch;
	}
	pc = 0x8284DEC4; continue 'dispatch;
            }
            0x8284DEC4 => {
    //   block [0x8284DEC4..0x8284DEC8)
	// 8284DEC4: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	pc = 0x8284DEC8; continue 'dispatch;
            }
            0x8284DEC8 => {
    //   block [0x8284DEC8..0x8284DED4)
	// 8284DEC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284DECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DED0: 419A0064  beq cr6, 0x8284df34
	if ctx.cr[6].eq {
	pc = 0x8284DF34; continue 'dispatch;
	}
	pc = 0x8284DED4; continue 'dispatch;
            }
            0x8284DED4 => {
    //   block [0x8284DED4..0x8284DF34)
	// 8284DED4: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284DED8: 570A063E  clrlwi r10, r24, 0x18
	ctx.r[10].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 8284DEDC: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 8284DEE0: 811D9650  lwz r8, -0x69b0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 8284DEE4: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8284DEE8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8284DEEC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8284DEF0: 5529DFFE  rlwinm r9, r9, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8284DEF4: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284DEF8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8284DEFC: 80670058  lwz r3, 0x58(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284DF00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284DF04: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8284DF08: 4BDCDBA9  bl 0x8261bab0
	ctx.lr = 0x8284DF0C;
	sub_8261BAB0(ctx, base);
	// 8284DF0C: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284DF10: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8284DF14: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 8284DF18: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8284DF1C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284DF20: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284DF24: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284DF28: 8068001C  lwz r3, 0x1c(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 8284DF2C: 4BDCF565  bl 0x8261d490
	ctx.lr = 0x8284DF30;
	sub_8261D490(ctx, base);
	// 8284DF30: 7E7E9B78  mr r30, r19
	ctx.r[30].u64 = ctx.r[19].u64;
	pc = 0x8284DF34; continue 'dispatch;
            }
            0x8284DF34 => {
    //   block [0x8284DF34..0x8284DF64)
	// 8284DF34: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 8284DF38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DF3C: 419A00A0  beq cr6, 0x8284dfdc
	if ctx.cr[6].eq {
	pc = 0x8284DFDC; continue 'dispatch;
	}
	// 8284DF40: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8284DF44: 419A0020  beq cr6, 0x8284df64
	if ctx.cr[6].eq {
	pc = 0x8284DF64; continue 'dispatch;
	}
	// 8284DF48: 568B063E  clrlwi r11, r20, 0x18
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0x000000FFu64;
	// 8284DF4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DF50: 419A0014  beq cr6, 0x8284df64
	if ctx.cr[6].eq {
	pc = 0x8284DF64; continue 'dispatch;
	}
	// 8284DF54: 570B063E  clrlwi r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 8284DF58: 7E499378  mr r9, r18
	ctx.r[9].u64 = ctx.r[18].u64;
	// 8284DF5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284DF60: 419A0008  beq cr6, 0x8284df68
	if ctx.cr[6].eq {
	pc = 0x8284DF68; continue 'dispatch;
	}
	pc = 0x8284DF64; continue 'dispatch;
            }
            0x8284DF64 => {
    //   block [0x8284DF64..0x8284DF68)
	// 8284DF64: 7E699B78  mr r9, r19
	ctx.r[9].u64 = ctx.r[19].u64;
	pc = 0x8284DF68; continue 'dispatch;
            }
            0x8284DF68 => {
    //   block [0x8284DF68..0x8284DFDC)
	// 8284DF68: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284DF6C: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 8284DF70: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8284DF74: 811D9650  lwz r8, -0x69b0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 8284DF78: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8284DF7C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8284DF80: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284DF84: 80EA0058  lwz r7, 0x58(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284DF88: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284DF8C: 8063001C  lwz r3, 0x1c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 8284DF90: 4BDCDB21  bl 0x8261bab0
	ctx.lr = 0x8284DF94;
	sub_8261BAB0(ctx, base);
	// 8284DF94: 8097007C  lwz r4, 0x7c(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(124 as u32) ) } as u64;
	// 8284DF98: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8284DF9C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284DFA0: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8284DFA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8284DFA8: 4E800421  bctrl
	ctx.lr = 0x8284DFAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8284DFAC: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284DFB0: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 8284DFB4: 39000065  li r8, 0x65
	ctx.r[8].s64 = 101;
	// 8284DFB8: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 8284DFBC: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 8284DFC0: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284DFC4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8284DFC8: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 8284DFCC: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284DFD0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284DFD4: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8284DFD8: 4BA2BBA9  bl 0x82279b80
	ctx.lr = 0x8284DFDC;
	sub_82279B80(ctx, base);
            }
            0x8284DFDC => {
    //   block [0x8284DFDC..0x8284DFFC)
	// 8284DFDC: 7E7E9B78  mr r30, r19
	ctx.r[30].u64 = ctx.r[19].u64;
	// 8284DFE0: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 8284DFE4: 419A0018  beq cr6, 0x8284dffc
	if ctx.cr[6].eq {
	pc = 0x8284DFFC; continue 'dispatch;
	}
	// 8284DFE8: 89750090  lbz r11, 0x90(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(144 as u32) ) } as u64;
	// 8284DFEC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8284DFF0: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284DFF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284DFF8: 409A0008  bne cr6, 0x8284e000
	if !ctx.cr[6].eq {
	pc = 0x8284E000; continue 'dispatch;
	}
	pc = 0x8284DFFC; continue 'dispatch;
            }
            0x8284DFFC => {
    //   block [0x8284DFFC..0x8284E000)
	// 8284DFFC: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	pc = 0x8284E000; continue 'dispatch;
            }
            0x8284E000 => {
    //   block [0x8284E000..0x8284E050)
	// 8284E000: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E004: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8284E008: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284E00C: 3BABF158  addi r29, r11, -0xea8
	ctx.r[29].s64 = ctx.r[11].s64 + -3752;
	// 8284E010: 419A0190  beq cr6, 0x8284e1a0
	if ctx.cr[6].eq {
	pc = 0x8284E1A0; continue 'dispatch;
	}
	// 8284E014: 81750030  lwz r11, 0x30(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(48 as u32) ) } as u64;
	// 8284E018: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8284E01C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284E020: 419A00F4  beq cr6, 0x8284e114
	if ctx.cr[6].eq {
	pc = 0x8284E114; continue 'dispatch;
	}
	// 8284E024: 8175008C  lwz r11, 0x8c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(140 as u32) ) } as u64;
	// 8284E028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E02C: 419A0024  beq cr6, 0x8284e050
	if ctx.cr[6].eq {
	pc = 0x8284E050; continue 'dispatch;
	}
	// 8284E030: 894B0065  lbz r10, 0x65(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(101 as u32) ) } as u64;
	// 8284E034: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284E038: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8284E03C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8284E040: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E044: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8284E048: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284E04C: 480000CC  b 0x8284e118
	pc = 0x8284E118; continue 'dispatch;
            }
            0x8284E050 => {
    //   block [0x8284E050..0x8284E06C)
	// 8284E050: 81550048  lwz r10, 0x48(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284E054: 80D5004C  lwz r6, 0x4c(r21)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(76 as u32) ) } as u64;
	// 8284E058: 92610060  stw r19, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[19].u32 ) };
	// 8284E05C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8284E060: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 8284E064: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284E068: 40810054  ble 0x8284e0bc
	if !ctx.cr[0].gt {
	pc = 0x8284E0BC; continue 'dispatch;
	}
	pc = 0x8284E06C; continue 'dispatch;
            }
            0x8284E06C => {
    //   block [0x8284E06C..0x8284E08C)
	// 8284E06C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8284E070: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8284E074: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8284E078: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E07C: 2F070065  cmpwi cr6, r7, 0x65
	ctx.cr[6].compare_i32(ctx.r[7].s32, 101, &mut ctx.xer);
	// 8284E080: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	// 8284E084: 41980008  blt cr6, 0x8284e08c
	if ctx.cr[6].lt {
	pc = 0x8284E08C; continue 'dispatch;
	}
	// 8284E088: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	pc = 0x8284E08C; continue 'dispatch;
            }
            0x8284E08C => {
    //   block [0x8284E08C..0x8284E0A8)
	// 8284E08C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8284E090: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8284E094: 419A0014  beq cr6, 0x8284e0a8
	if ctx.cr[6].eq {
	pc = 0x8284E0A8; continue 'dispatch;
	}
	// 8284E098: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8284E09C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8284E0A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8284E0A4: 4800000C  b 0x8284e0b0
	pc = 0x8284E0B0; continue 'dispatch;
            }
            0x8284E0A8 => {
    //   block [0x8284E0A8..0x8284E0B0)
	// 8284E0A8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8284E0AC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8284E0B0; continue 'dispatch;
            }
            0x8284E0B0 => {
    //   block [0x8284E0B0..0x8284E0BC)
	// 8284E0B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284E0B4: 4199FFB8  bgt cr6, 0x8284e06c
	if ctx.cr[6].gt {
	pc = 0x8284E06C; continue 'dispatch;
	}
	// 8284E0B8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x8284E0BC; continue 'dispatch;
            }
            0x8284E0BC => {
    //   block [0x8284E0BC..0x8284E0D8)
	// 8284E0BC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8284E0C0: 419A0040  beq cr6, 0x8284e100
	if ctx.cr[6].eq {
	pc = 0x8284E100; continue 'dispatch;
	}
	// 8284E0C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E0C8: 2F0B0065  cmpwi cr6, r11, 0x65
	ctx.cr[6].compare_i32(ctx.r[11].s32, 101, &mut ctx.xer);
	// 8284E0CC: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284E0D0: 41990008  bgt cr6, 0x8284e0d8
	if ctx.cr[6].gt {
	pc = 0x8284E0D8; continue 'dispatch;
	}
	// 8284E0D4: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	pc = 0x8284E0D8; continue 'dispatch;
            }
            0x8284E0D8 => {
    //   block [0x8284E0D8..0x8284E100)
	// 8284E0D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E0E0: 409A0020  bne cr6, 0x8284e100
	if !ctx.cr[6].eq {
	pc = 0x8284E100; continue 'dispatch;
	}
	// 8284E0E4: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8284E0E8: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 8284E0EC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8284E0F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E0F4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8284E0F8: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284E0FC: 4800001C  b 0x8284e118
	pc = 0x8284E118; continue 'dispatch;
            }
            0x8284E100 => {
    //   block [0x8284E100..0x8284E114)
	// 8284E100: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8284E104: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E108: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8284E10C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284E110: 48000008  b 0x8284e118
	pc = 0x8284E118; continue 'dispatch;
            }
            0x8284E114 => {
    //   block [0x8284E114..0x8284E118)
	// 8284E114: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	pc = 0x8284E118; continue 'dispatch;
            }
            0x8284E118 => {
    //   block [0x8284E118..0x8284E170)
	// 8284E118: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E11C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E120: 419A0080  beq cr6, 0x8284e1a0
	if ctx.cr[6].eq {
	pc = 0x8284E1A0; continue 'dispatch;
	}
	// 8284E124: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284E128: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 8284E12C: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 8284E130: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284E134: 812A0078  lwz r9, 0x78(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 8284E138: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E13C: 388B00E0  addi r4, r11, 0xe0
	ctx.r[4].s64 = ctx.r[11].s64 + 224;
	// 8284E140: 386B0118  addi r3, r11, 0x118
	ctx.r[3].s64 = ctx.r[11].s64 + 280;
	// 8284E144: 4BC1615D  bl 0x824642a0
	ctx.lr = 0x8284E148;
	sub_824642A0(ctx, base);
	// 8284E148: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8284E14C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8284E150: 419A0050  beq cr6, 0x8284e1a0
	if ctx.cr[6].eq {
	pc = 0x8284E1A0; continue 'dispatch;
	}
	// 8284E154: 7E5F9378  mr r31, r18
	ctx.r[31].u64 = ctx.r[18].u64;
	// 8284E158: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8284E15C: 419A0014  beq cr6, 0x8284e170
	if ctx.cr[6].eq {
	pc = 0x8284E170; continue 'dispatch;
	}
	// 8284E160: 568B063E  clrlwi r11, r20, 0x18
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0x000000FFu64;
	// 8284E164: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E168: 409A0008  bne cr6, 0x8284e170
	if !ctx.cr[6].eq {
	pc = 0x8284E170; continue 'dispatch;
	}
	// 8284E16C: 7E7F9B78  mr r31, r19
	ctx.r[31].u64 = ctx.r[19].u64;
	pc = 0x8284E170; continue 'dispatch;
            }
            0x8284E170 => {
    //   block [0x8284E170..0x8284E1A0)
	// 8284E170: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8284E174: 92610050  stw r19, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[19].u32 ) };
	// 8284E178: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8284E17C: 4B96437D  bl 0x821b24f8
	ctx.lr = 0x8284E180;
	sub_821B24F8(ctx, base);
	// 8284E180: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8284E184: 4BBA7B7D  bl 0x823f5d00
	ctx.lr = 0x8284E188;
	sub_823F5D00(ctx, base);
	// 8284E188: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8284E18C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8284E190: 419A0010  beq cr6, 0x8284e1a0
	if ctx.cr[6].eq {
	pc = 0x8284E1A0; continue 'dispatch;
	}
	// 8284E194: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8284E198: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284E19C: 4804AD0D  bl 0x82898ea8
	ctx.lr = 0x8284E1A0;
	sub_82898EA8(ctx, base);
	pc = 0x8284E1A0; continue 'dispatch;
            }
            0x8284E1A0 => {
    //   block [0x8284E1A0..0x8284E1D8)
	// 8284E1A0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8284E1A4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8284E1A8: 386B04A0  addi r3, r11, 0x4a0
	ctx.r[3].s64 = ctx.r[11].s64 + 1184;
	// 8284E1AC: 4B9A5BAD  bl 0x821f3d58
	ctx.lr = 0x8284E1B0;
	sub_821F3D58(ctx, base);
	// 8284E1B0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8284E1B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8284E1B8: 4B964341  bl 0x821b24f8
	ctx.lr = 0x8284E1BC;
	sub_821B24F8(ctx, base);
	// 8284E1BC: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8284E1C0: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 8284E1C4: 481B2505  bl 0x82a006c8
	ctx.lr = 0x8284E1C8;
	sub_82A006C8(ctx, base);
	// 8284E1C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284E1CC: 419A000C  beq cr6, 0x8284e1d8
	if ctx.cr[6].eq {
	pc = 0x8284E1D8; continue 'dispatch;
	}
	// 8284E1D0: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E1D4: 48000008  b 0x8284e1dc
	pc = 0x8284E1DC; continue 'dispatch;
            }
            0x8284E1D8 => {
    //   block [0x8284E1D8..0x8284E1DC)
	// 8284E1D8: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	pc = 0x8284E1DC; continue 'dispatch;
            }
            0x8284E1DC => {
    //   block [0x8284E1DC..0x8284E228)
	// 8284E1DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8284E1E0: 4B98C169  bl 0x821da348
	ctx.lr = 0x8284E1E4;
	sub_821DA348(ctx, base);
	// 8284E1E4: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284E1E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8284E1EC: 419A01C8  beq cr6, 0x8284e3b4
	if ctx.cr[6].eq {
	pc = 0x8284E3B4; continue 'dispatch;
	}
	// 8284E1F0: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284E1F4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284E1F8: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284E1FC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E200: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284E208: 4B9DDFB1  bl 0x8222c1b8
	ctx.lr = 0x8284E20C;
	sub_8222C1B8(ctx, base);
	// 8284E20C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8284E210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284E214: 48097865  bl 0x828e5a78
	ctx.lr = 0x8284E218;
	sub_828E5A78(ctx, base);
	// 8284E218: 7F17E040  cmplw cr6, r23, r28
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8284E21C: 419A000C  beq cr6, 0x8284e228
	if ctx.cr[6].eq {
	pc = 0x8284E228; continue 'dispatch;
	}
	// 8284E220: 7F171840  cmplw cr6, r23, r3
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[3].u32, &mut ctx.xer);
	// 8284E224: 409A0190  bne cr6, 0x8284e3b4
	if !ctx.cr[6].eq {
	pc = 0x8284E3B4; continue 'dispatch;
	}
	pc = 0x8284E228; continue 'dispatch;
            }
            0x8284E228 => {
    //   block [0x8284E228..0x8284E24C)
	// 8284E228: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284E22C: 4BB15B0D  bl 0x82363d38
	ctx.lr = 0x8284E230;
	sub_82363D38(ctx, base);
	// 8284E230: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284E234: 419A0018  beq cr6, 0x8284e24c
	if ctx.cr[6].eq {
	pc = 0x8284E24C; continue 'dispatch;
	}
	// 8284E238: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8284E23C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8284E240: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284E244: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284E248: 409A0008  bne cr6, 0x8284e250
	if !ctx.cr[6].eq {
	pc = 0x8284E250; continue 'dispatch;
	}
	pc = 0x8284E24C; continue 'dispatch;
            }
            0x8284E24C => {
    //   block [0x8284E24C..0x8284E250)
	// 8284E24C: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	pc = 0x8284E250; continue 'dispatch;
            }
            0x8284E250 => {
    //   block [0x8284E250..0x8284E29C)
	// 8284E250: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E254: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E258: 419A015C  beq cr6, 0x8284e3b4
	if ctx.cr[6].eq {
	pc = 0x8284E3B4; continue 'dispatch;
	}
	// 8284E25C: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8284E260: 7E7F9B78  mr r31, r19
	ctx.r[31].u64 = ctx.r[19].u64;
	// 8284E264: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8284E268: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284E26C: 419A00F4  beq cr6, 0x8284e360
	if ctx.cr[6].eq {
	pc = 0x8284E360; continue 'dispatch;
	}
	// 8284E270: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8284E274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E278: 419A0024  beq cr6, 0x8284e29c
	if ctx.cr[6].eq {
	pc = 0x8284E29C; continue 'dispatch;
	}
	// 8284E27C: 894B0061  lbz r10, 0x61(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(97 as u32) ) } as u64;
	// 8284E280: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284E284: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8284E288: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8284E28C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E290: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8284E294: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284E298: 480000CC  b 0x8284e364
	pc = 0x8284E364; continue 'dispatch;
            }
            0x8284E29C => {
    //   block [0x8284E29C..0x8284E2B8)
	// 8284E29C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284E2A0: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8284E2A4: 92610060  stw r19, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[19].u32 ) };
	// 8284E2A8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8284E2AC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 8284E2B0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284E2B4: 40810054  ble 0x8284e308
	if !ctx.cr[0].gt {
	pc = 0x8284E308; continue 'dispatch;
	}
	pc = 0x8284E2B8; continue 'dispatch;
            }
            0x8284E2B8 => {
    //   block [0x8284E2B8..0x8284E2D8)
	// 8284E2B8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8284E2BC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8284E2C0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8284E2C4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E2C8: 2F070061  cmpwi cr6, r7, 0x61
	ctx.cr[6].compare_i32(ctx.r[7].s32, 97, &mut ctx.xer);
	// 8284E2CC: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	// 8284E2D0: 41980008  blt cr6, 0x8284e2d8
	if ctx.cr[6].lt {
	pc = 0x8284E2D8; continue 'dispatch;
	}
	// 8284E2D4: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	pc = 0x8284E2D8; continue 'dispatch;
            }
            0x8284E2D8 => {
    //   block [0x8284E2D8..0x8284E2F4)
	// 8284E2D8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8284E2DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8284E2E0: 419A0014  beq cr6, 0x8284e2f4
	if ctx.cr[6].eq {
	pc = 0x8284E2F4; continue 'dispatch;
	}
	// 8284E2E4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8284E2E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8284E2EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8284E2F0: 4800000C  b 0x8284e2fc
	pc = 0x8284E2FC; continue 'dispatch;
            }
            0x8284E2F4 => {
    //   block [0x8284E2F4..0x8284E2FC)
	// 8284E2F4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8284E2F8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8284E2FC; continue 'dispatch;
            }
            0x8284E2FC => {
    //   block [0x8284E2FC..0x8284E308)
	// 8284E2FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284E300: 4199FFB8  bgt cr6, 0x8284e2b8
	if ctx.cr[6].gt {
	pc = 0x8284E2B8; continue 'dispatch;
	}
	// 8284E304: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x8284E308; continue 'dispatch;
            }
            0x8284E308 => {
    //   block [0x8284E308..0x8284E324)
	// 8284E308: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8284E30C: 419A0040  beq cr6, 0x8284e34c
	if ctx.cr[6].eq {
	pc = 0x8284E34C; continue 'dispatch;
	}
	// 8284E310: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E314: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 8284E318: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284E31C: 41990008  bgt cr6, 0x8284e324
	if ctx.cr[6].gt {
	pc = 0x8284E324; continue 'dispatch;
	}
	// 8284E320: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	pc = 0x8284E324; continue 'dispatch;
            }
            0x8284E324 => {
    //   block [0x8284E324..0x8284E34C)
	// 8284E324: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E32C: 409A0020  bne cr6, 0x8284e34c
	if !ctx.cr[6].eq {
	pc = 0x8284E34C; continue 'dispatch;
	}
	// 8284E330: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8284E334: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 8284E338: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8284E33C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E340: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8284E344: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284E348: 4800001C  b 0x8284e364
	pc = 0x8284E364; continue 'dispatch;
            }
            0x8284E34C => {
    //   block [0x8284E34C..0x8284E360)
	// 8284E34C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8284E350: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E354: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8284E358: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8284E35C: 48000008  b 0x8284e364
	pc = 0x8284E364; continue 'dispatch;
            }
            0x8284E360 => {
    //   block [0x8284E360..0x8284E364)
	// 8284E360: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	pc = 0x8284E364; continue 'dispatch;
            }
            0x8284E364 => {
    //   block [0x8284E364..0x8284E3B0)
	// 8284E364: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E36C: 419A0048  beq cr6, 0x8284e3b4
	if ctx.cr[6].eq {
	pc = 0x8284E3B4; continue 'dispatch;
	}
	// 8284E370: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8284E374: 92610050  stw r19, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[19].u32 ) };
	// 8284E378: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8284E37C: 4B96417D  bl 0x821b24f8
	ctx.lr = 0x8284E380;
	sub_821B24F8(ctx, base);
	// 8284E380: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8284E384: 4BBA797D  bl 0x823f5d00
	ctx.lr = 0x8284E388;
	sub_823F5D00(ctx, base);
	// 8284E388: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8284E38C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 8284E390: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8284E394: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8284E398: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8284E39C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284E3A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8284E3A4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8284E3A8: 419A0008  beq cr6, 0x8284e3b0
	if ctx.cr[6].eq {
	pc = 0x8284E3B0; continue 'dispatch;
	}
	// 8284E3AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	pc = 0x8284E3B0; continue 'dispatch;
            }
            0x8284E3B0 => {
    //   block [0x8284E3B0..0x8284E3B4)
	// 8284E3B0: 4BFC2C31  bl 0x82810fe0
	ctx.lr = 0x8284E3B4;
	sub_82810FE0(ctx, base);
	pc = 0x8284E3B4; continue 'dispatch;
            }
            0x8284E3B4 => {
    //   block [0x8284E3B4..0x8284E3C0)
	// 8284E3B4: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8284E3B8: CBE1FF80  lfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 8284E3BC: 4845B074  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8284E3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8284E3C0 size=992
    let mut pc: u32 = 0x8284E3C0;
    'dispatch: loop {
        match pc {
            0x8284E3C0 => {
    //   block [0x8284E3C0..0x8284E444)
	// 8284E3C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284E3C4: 4845B02D  bl 0x82ca93f0
	ctx.lr = 0x8284E3C8;
	sub_82CA93D0(ctx, base);
	// 8284E3C8: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 8284E3CC: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284E3D0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 8284E3D4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8284E3D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8284E3DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8284E3E0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8284E3E4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8284E3E8: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 8284E3EC: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 8284E3F0: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 8284E3F4: 4BFFF1FD  bl 0x8284d5f0
	ctx.lr = 0x8284E3F8;
	sub_8284D5F0(ctx, base);
	// 8284E3F8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8284E3FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E400: 409A0394  bne cr6, 0x8284e794
	if !ctx.cr[6].eq {
	pc = 0x8284E794; continue 'dispatch;
	}
	// 8284E404: 817A0034  lwz r11, 0x34(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(52 as u32) ) } as u64;
	// 8284E408: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 8284E40C: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 8284E410: 556A37FE  rlwinm r10, r11, 6, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 8284E414: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 8284E418: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284E41C: 419A00D8  beq cr6, 0x8284e4f4
	if ctx.cr[6].eq {
	pc = 0x8284E4F4; continue 'dispatch;
	}
	// 8284E420: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 8284E424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E428: 419A001C  beq cr6, 0x8284e444
	if ctx.cr[6].eq {
	pc = 0x8284E444; continue 'dispatch;
	}
	// 8284E42C: 894B009A  lbz r10, 0x9a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(154 as u32) ) } as u64;
	// 8284E430: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284E434: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8284E438: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8284E43C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E440: 480000B0  b 0x8284e4f0
	pc = 0x8284E4F0; continue 'dispatch;
            }
            0x8284E444 => {
    //   block [0x8284E444..0x8284E460)
	// 8284E444: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284E448: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 8284E44C: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 8284E450: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8284E454: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8284E458: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284E45C: 40810054  ble 0x8284e4b0
	if !ctx.cr[0].gt {
	pc = 0x8284E4B0; continue 'dispatch;
	}
	pc = 0x8284E460; continue 'dispatch;
            }
            0x8284E460 => {
    //   block [0x8284E460..0x8284E480)
	// 8284E460: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8284E464: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8284E468: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8284E46C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E470: 2F07009A  cmpwi cr6, r7, 0x9a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 154, &mut ctx.xer);
	// 8284E474: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 8284E478: 41980008  blt cr6, 0x8284e480
	if ctx.cr[6].lt {
	pc = 0x8284E480; continue 'dispatch;
	}
	// 8284E47C: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	pc = 0x8284E480; continue 'dispatch;
            }
            0x8284E480 => {
    //   block [0x8284E480..0x8284E49C)
	// 8284E480: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8284E484: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8284E488: 419A0014  beq cr6, 0x8284e49c
	if ctx.cr[6].eq {
	pc = 0x8284E49C; continue 'dispatch;
	}
	// 8284E48C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8284E490: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8284E494: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8284E498: 4800000C  b 0x8284e4a4
	pc = 0x8284E4A4; continue 'dispatch;
            }
            0x8284E49C => {
    //   block [0x8284E49C..0x8284E4A4)
	// 8284E49C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8284E4A0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8284E4A4; continue 'dispatch;
            }
            0x8284E4A4 => {
    //   block [0x8284E4A4..0x8284E4B0)
	// 8284E4A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284E4A8: 4199FFB8  bgt cr6, 0x8284e460
	if ctx.cr[6].gt {
	pc = 0x8284E460; continue 'dispatch;
	}
	// 8284E4AC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8284E4B0; continue 'dispatch;
            }
            0x8284E4B0 => {
    //   block [0x8284E4B0..0x8284E4CC)
	// 8284E4B0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8284E4B4: 419A0034  beq cr6, 0x8284e4e8
	if ctx.cr[6].eq {
	pc = 0x8284E4E8; continue 'dispatch;
	}
	// 8284E4B8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E4BC: 2F0B009A  cmpwi cr6, r11, 0x9a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 154, &mut ctx.xer);
	// 8284E4C0: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 8284E4C4: 41990008  bgt cr6, 0x8284e4cc
	if ctx.cr[6].gt {
	pc = 0x8284E4CC; continue 'dispatch;
	}
	// 8284E4C8: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x8284E4CC; continue 'dispatch;
            }
            0x8284E4CC => {
    //   block [0x8284E4CC..0x8284E4E8)
	// 8284E4CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E4D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E4D4: 409A0014  bne cr6, 0x8284e4e8
	if !ctx.cr[6].eq {
	pc = 0x8284E4E8; continue 'dispatch;
	}
	// 8284E4D8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8284E4DC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8284E4E0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8284E4E4: 48000008  b 0x8284e4ec
	pc = 0x8284E4EC; continue 'dispatch;
            }
            0x8284E4E8 => {
    //   block [0x8284E4E8..0x8284E4EC)
	// 8284E4E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x8284E4EC; continue 'dispatch;
            }
            0x8284E4EC => {
    //   block [0x8284E4EC..0x8284E4F0)
	// 8284E4EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x8284E4F0; continue 'dispatch;
            }
            0x8284E4F0 => {
    //   block [0x8284E4F0..0x8284E4F4)
	// 8284E4F0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x8284E4F4; continue 'dispatch;
            }
            0x8284E4F4 => {
    //   block [0x8284E4F4..0x8284E558)
	// 8284E4F4: 897F0012  lbz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 8284E4F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E4FC: 409A0298  bne cr6, 0x8284e794
	if !ctx.cr[6].eq {
	pc = 0x8284E794; continue 'dispatch;
	}
	// 8284E500: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8284E504: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 8284E508: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8284E50C: 38EBE9C4  addi r7, r11, -0x163c
	ctx.r[7].s64 = ctx.r[11].s64 + -5692;
	// 8284E510: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8284E514: 4B963FE5  bl 0x821b24f8
	ctx.lr = 0x8284E518;
	sub_821B24F8(ctx, base);
	// 8284E518: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8284E51C: 4BB8588D  bl 0x823d3da8
	ctx.lr = 0x8284E520;
	sub_823D3DA8(ctx, base);
	// 8284E520: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8284E524: 2F060011  cmpwi cr6, r6, 0x11
	ctx.cr[6].compare_i32(ctx.r[6].s32, 17, &mut ctx.xer);
	// 8284E528: 419A026C  beq cr6, 0x8284e794
	if ctx.cr[6].eq {
	pc = 0x8284E794; continue 'dispatch;
	}
	// 8284E52C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8284E530: 80AB6AB8  lwz r5, 0x6ab8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284E534: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284E538: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 8284E53C: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8284E540: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8284E544: 419A0014  beq cr6, 0x8284e558
	if ctx.cr[6].eq {
	pc = 0x8284E558; continue 'dispatch;
	}
	// 8284E548: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 8284E54C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E550: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 8284E554: 409A0008  bne cr6, 0x8284e55c
	if !ctx.cr[6].eq {
	pc = 0x8284E55C; continue 'dispatch;
	}
	pc = 0x8284E558; continue 'dispatch;
            }
            0x8284E558 => {
    //   block [0x8284E558..0x8284E55C)
	// 8284E558: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x8284E55C; continue 'dispatch;
            }
            0x8284E55C => {
    //   block [0x8284E55C..0x8284E5B4)
	// 8284E55C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E564: 419A00E4  beq cr6, 0x8284e648
	if ctx.cr[6].eq {
	pc = 0x8284E648; continue 'dispatch;
	}
	// 8284E568: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8284E56C: 92E10070  stw r23, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[23].u32 ) };
	// 8284E570: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8284E574: 92E10074  stw r23, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[23].u32 ) };
	// 8284E578: 9AE10078  stb r23, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u8 ) };
	// 8284E57C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8284E580: 392A6750  addi r9, r10, 0x6750
	ctx.r[9].s64 = ctx.r[10].s64 + 26448;
	// 8284E584: 9AC10079  stb r22, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[22].u8 ) };
	// 8284E588: 9AE10080  stb r23, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[23].u8 ) };
	// 8284E58C: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8284E590: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 8284E594: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8284E598: FAE10068  std r23, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[23].u64 ) };
	// 8284E59C: 419A0018  beq cr6, 0x8284e5b4
	if ctx.cr[6].eq {
	pc = 0x8284E5B4; continue 'dispatch;
	}
	// 8284E5A0: 897C0090  lbz r11, 0x90(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) } as u64;
	// 8284E5A4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8284E5A8: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 8284E5AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284E5B0: 409A0008  bne cr6, 0x8284e5b8
	if !ctx.cr[6].eq {
	pc = 0x8284E5B8; continue 'dispatch;
	}
	pc = 0x8284E5B4; continue 'dispatch;
            }
            0x8284E5B4 => {
    //   block [0x8284E5B4..0x8284E5B8)
	// 8284E5B4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x8284E5B8; continue 'dispatch;
            }
            0x8284E5B8 => {
    //   block [0x8284E5B8..0x8284E5D0)
	// 8284E5B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E5BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E5C0: 419A0010  beq cr6, 0x8284e5d0
	if ctx.cr[6].eq {
	pc = 0x8284E5D0; continue 'dispatch;
	}
	// 8284E5C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8284E5C8: 4B963DC9  bl 0x821b2390
	ctx.lr = 0x8284E5CC;
	sub_821B2390(ctx, base);
	// 8284E5CC: F8610068  std r3, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u64 ) };
	pc = 0x8284E5D0; continue 'dispatch;
            }
            0x8284E5D0 => {
    //   block [0x8284E5D0..0x8284E62C)
	// 8284E5D0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E5D4: D3E1007C  stfs f31, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8284E5D8: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 8284E5DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8284E5E0: 9BC10078  stb r30, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u8 ) };
	// 8284E5E4: 9B610079  stb r27, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[27].u8 ) };
	// 8284E5E8: 9B010080  stb r24, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[24].u8 ) };
	// 8284E5EC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8284E5F0: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284E5F4: 83AA008C  lwz r29, 0x8c(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 8284E5F8: 4B963D99  bl 0x821b2390
	ctx.lr = 0x8284E5FC;
	sub_821B2390(ctx, base);
	// 8284E5FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8284E600: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8284E604: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8284E608: 48004A21  bl 0x82853028
	ctx.lr = 0x8284E60C;
	sub_82853028(ctx, base);
	// 8284E60C: 57C9063E  clrlwi r9, r30, 0x18
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 8284E610: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8284E614: 419A0024  beq cr6, 0x8284e638
	if ctx.cr[6].eq {
	pc = 0x8284E638; continue 'dispatch;
	}
	// 8284E618: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 8284E61C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E620: 419A000C  beq cr6, 0x8284e62c
	if ctx.cr[6].eq {
	pc = 0x8284E62C; continue 'dispatch;
	}
	// 8284E624: 9ADF000E  stb r22, 0xe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(14 as u32), ctx.r[22].u8 ) };
	// 8284E628: 48000008  b 0x8284e630
	pc = 0x8284E630; continue 'dispatch;
            }
            0x8284E62C => {
    //   block [0x8284E62C..0x8284E630)
	// 8284E62C: 9ADF000F  stb r22, 0xf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(15 as u32), ctx.r[22].u8 ) };
	pc = 0x8284E630; continue 'dispatch;
            }
            0x8284E630 => {
    //   block [0x8284E630..0x8284E638)
	// 8284E630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284E634: 4BBC941D  bl 0x82417a50
	ctx.lr = 0x8284E638;
	sub_82417A50(ctx, base);
	pc = 0x8284E638; continue 'dispatch;
            }
            0x8284E638 => {
    //   block [0x8284E638..0x8284E648)
	// 8284E638: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8284E63C: 394B2DC8  addi r10, r11, 0x2dc8
	ctx.r[10].s64 = ctx.r[11].s64 + 11720;
	// 8284E640: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8284E644: 48000028  b 0x8284e66c
	pc = 0x8284E66C; continue 'dispatch;
            }
            0x8284E648 => {
    //   block [0x8284E648..0x8284E66C)
	// 8284E648: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8284E64C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8284E650: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 8284E654: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8284E658: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8284E65C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8284E660: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8284E664: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8284E668: 4BFFF261  bl 0x8284d8c8
	ctx.lr = 0x8284E66C;
	sub_8284D8C8(ctx, base);
	pc = 0x8284E66C; continue 'dispatch;
            }
            0x8284E66C => {
    //   block [0x8284E66C..0x8284E6A8)
	// 8284E66C: 817A0028  lwz r11, 0x28(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 8284E670: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 8284E674: 556A3FFE  rlwinm r10, r11, 7, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 8284E678: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284E67C: 419A00E8  beq cr6, 0x8284e764
	if ctx.cr[6].eq {
	pc = 0x8284E764; continue 'dispatch;
	}
	// 8284E680: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 8284E684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E688: 419A0020  beq cr6, 0x8284e6a8
	if ctx.cr[6].eq {
	pc = 0x8284E6A8; continue 'dispatch;
	}
	// 8284E68C: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 8284E690: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284E694: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8284E698: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8284E69C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 8284E6A0: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E6A4: 480000C4  b 0x8284e768
	pc = 0x8284E768; continue 'dispatch;
            }
            0x8284E6A8 => {
    //   block [0x8284E6A8..0x8284E6C4)
	// 8284E6A8: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284E6AC: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 8284E6B0: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 8284E6B4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8284E6B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8284E6BC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284E6C0: 40810054  ble 0x8284e714
	if !ctx.cr[0].gt {
	pc = 0x8284E714; continue 'dispatch;
	}
	pc = 0x8284E6C4; continue 'dispatch;
            }
            0x8284E6C4 => {
    //   block [0x8284E6C4..0x8284E6E4)
	// 8284E6C4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8284E6C8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8284E6CC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8284E6D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E6D4: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 8284E6D8: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 8284E6DC: 41980008  blt cr6, 0x8284e6e4
	if ctx.cr[6].lt {
	pc = 0x8284E6E4; continue 'dispatch;
	}
	// 8284E6E0: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	pc = 0x8284E6E4; continue 'dispatch;
            }
            0x8284E6E4 => {
    //   block [0x8284E6E4..0x8284E700)
	// 8284E6E4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8284E6E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8284E6EC: 419A0014  beq cr6, 0x8284e700
	if ctx.cr[6].eq {
	pc = 0x8284E700; continue 'dispatch;
	}
	// 8284E6F0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8284E6F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8284E6F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8284E6FC: 4800000C  b 0x8284e708
	pc = 0x8284E708; continue 'dispatch;
            }
            0x8284E700 => {
    //   block [0x8284E700..0x8284E708)
	// 8284E700: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8284E704: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8284E708; continue 'dispatch;
            }
            0x8284E708 => {
    //   block [0x8284E708..0x8284E714)
	// 8284E708: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284E70C: 4199FFB8  bgt cr6, 0x8284e6c4
	if ctx.cr[6].gt {
	pc = 0x8284E6C4; continue 'dispatch;
	}
	// 8284E710: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8284E714; continue 'dispatch;
            }
            0x8284E714 => {
    //   block [0x8284E714..0x8284E730)
	// 8284E714: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8284E718: 419A003C  beq cr6, 0x8284e754
	if ctx.cr[6].eq {
	pc = 0x8284E754; continue 'dispatch;
	}
	// 8284E71C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E720: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 8284E724: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 8284E728: 41990008  bgt cr6, 0x8284e730
	if ctx.cr[6].gt {
	pc = 0x8284E730; continue 'dispatch;
	}
	// 8284E72C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x8284E730; continue 'dispatch;
            }
            0x8284E730 => {
    //   block [0x8284E730..0x8284E754)
	// 8284E730: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E738: 409A001C  bne cr6, 0x8284e754
	if !ctx.cr[6].eq {
	pc = 0x8284E754; continue 'dispatch;
	}
	// 8284E73C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8284E740: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8284E744: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8284E748: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E74C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 8284E750: 48000018  b 0x8284e768
	pc = 0x8284E768; continue 'dispatch;
            }
            0x8284E754 => {
    //   block [0x8284E754..0x8284E764)
	// 8284E754: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8284E758: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E75C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 8284E760: 48000008  b 0x8284e768
	pc = 0x8284E768; continue 'dispatch;
            }
            0x8284E764 => {
    //   block [0x8284E764..0x8284E768)
	// 8284E764: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x8284E768; continue 'dispatch;
            }
            0x8284E768 => {
    //   block [0x8284E768..0x8284E788)
	// 8284E768: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E770: 419A0018  beq cr6, 0x8284e788
	if ctx.cr[6].eq {
	pc = 0x8284E788; continue 'dispatch;
	}
	// 8284E774: 816304E0  lwz r11, 0x4e0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1248 as u32) ) } as u64;
	// 8284E778: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8284E77C: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 8284E780: 90A304E0  stw r5, 0x4e0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1248 as u32), ctx.r[5].u32 ) };
	// 8284E784: 4BC8A735  bl 0x824d8eb8
	ctx.lr = 0x8284E788;
	sub_824D8EB8(ctx, base);
	pc = 0x8284E788; continue 'dispatch;
            }
            0x8284E788 => {
    //   block [0x8284E788..0x8284E794)
	// 8284E788: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8284E78C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8284E790: 4BFFEFD1  bl 0x8284d760
	ctx.lr = 0x8284E794;
	sub_8284D760(ctx, base);
	pc = 0x8284E794; continue 'dispatch;
            }
            0x8284E794 => {
    //   block [0x8284E794..0x8284E7A0)
	// 8284E794: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8284E798: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 8284E79C: 4845ACA4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8284E7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8284E7A0 size=220
    let mut pc: u32 = 0x8284E7A0;
    'dispatch: loop {
        match pc {
            0x8284E7A0 => {
    //   block [0x8284E7A0..0x8284E868)
	// 8284E7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284E7A4: 4845AC61  bl 0x82ca9404
	ctx.lr = 0x8284E7A8;
	sub_82CA93D0(ctx, base);
	// 8284E7A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284E7AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8284E7B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8284E7B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8284E7B8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8284E7BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8284E7C0: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8284E7C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284E7C8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8284E7CC: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 8284E7D0: 4B9DE701  bl 0x8222ced0
	ctx.lr = 0x8284E7D4;
	sub_8222CED0(ctx, base);
	// 8284E7D4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8284E7D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8284E7DC: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8284E7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284E7E4: 4BFFD04D  bl 0x8284b830
	ctx.lr = 0x8284E7E8;
	sub_8284B830(ctx, base);
	// 8284E7E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284E7EC: 4B9C65ED  bl 0x82214dd8
	ctx.lr = 0x8284E7F0;
	sub_82214DD8(ctx, base);
	// 8284E7F0: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 8284E7F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8284E7F8: 392AEE58  addi r9, r10, -0x11a8
	ctx.r[9].s64 = ctx.r[10].s64 + -4520;
	// 8284E7FC: 38DF0080  addi r6, r31, 0x80
	ctx.r[6].s64 = ctx.r[31].s64 + 128;
	// 8284E800: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8284E804: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8284E808: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E80C: 911F0078  stw r8, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 8284E810: 80FC0004  lwz r7, 4(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E814: 90FF007C  stw r7, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 8284E818: 90BF0080  stw r5, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[5].u32 ) };
	// 8284E81C: 90BF0084  stw r5, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 8284E820: 98BF0088  stb r5, 0x88(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[5].u8 ) };
	// 8284E824: 9B7F0089  stb r27, 0x89(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(137 as u32), ctx.r[27].u8 ) };
	// 8284E828: 98BF008A  stb r5, 0x8a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(138 as u32), ctx.r[5].u8 ) };
	// 8284E82C: 90BF0080  stw r5, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[5].u32 ) };
	// 8284E830: 419A0038  beq cr6, 0x8284e868
	if ctx.cr[6].eq {
	pc = 0x8284E868; continue 'dispatch;
	}
	// 8284E834: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8284E838: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284E83C: 4B98BB0D  bl 0x821da348
	ctx.lr = 0x8284E840;
	sub_821DA348(ctx, base);
	// 8284E840: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8284E844: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 8284E848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284E84C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E850: 98AA6D45  stb r5, 0x6d45(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(27973 as u32), ctx.r[5].u8 ) };
	// 8284E854: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8284E858: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E85C: 91060004  stw r8, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 8284E860: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8284E864: 4845ABF0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8284E868 => {
    //   block [0x8284E868..0x8284E87C)
	// 8284E868: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8284E86C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284E870: 98AB6D45  stb r5, 0x6d45(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(27973 as u32), ctx.r[5].u8 ) };
	// 8284E874: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8284E878: 4845ABDC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8284E880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8284E880 size=796
    let mut pc: u32 = 0x8284E880;
    'dispatch: loop {
        match pc {
            0x8284E880 => {
    //   block [0x8284E880..0x8284E8D4)
	// 8284E880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284E884: 4845AB85  bl 0x82ca9408
	ctx.lr = 0x8284E888;
	sub_82CA93D0(ctx, base);
	// 8284E888: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284E88C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8284E890: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8284E894: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 8284E898: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 8284E89C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8284E8A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E8A4: 419A0030  beq cr6, 0x8284e8d4
	if ctx.cr[6].eq {
	pc = 0x8284E8D4; continue 'dispatch;
	}
	// 8284E8A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E8AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284E8B0: 419A0078  beq cr6, 0x8284e928
	if ctx.cr[6].eq {
	pc = 0x8284E928; continue 'dispatch;
	}
	// 8284E8B4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8284E8B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E8BC: 419A0018  beq cr6, 0x8284e8d4
	if ctx.cr[6].eq {
	pc = 0x8284E8D4; continue 'dispatch;
	}
	// 8284E8C0: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8284E8C4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8284E8C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284E8CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284E8D0: 409A0008  bne cr6, 0x8284e8d8
	if !ctx.cr[6].eq {
	pc = 0x8284E8D8; continue 'dispatch;
	}
	pc = 0x8284E8D4; continue 'dispatch;
            }
            0x8284E8D4 => {
    //   block [0x8284E8D4..0x8284E8D8)
	// 8284E8D4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8284E8D8; continue 'dispatch;
            }
            0x8284E8D8 => {
    //   block [0x8284E8D8..0x8284E928)
	// 8284E8D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E8DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E8E0: 419A014C  beq cr6, 0x8284ea2c
	if ctx.cr[6].eq {
	pc = 0x8284EA2C; continue 'dispatch;
	}
	// 8284E8E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8284E8E8: 4B925B81  bl 0x82174468
	ctx.lr = 0x8284E8EC;
	sub_82174468(ctx, base);
	// 8284E8EC: 81630034  lwz r11, 0x34(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 8284E8F0: 556A37FE  rlwinm r10, r11, 6, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 8284E8F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284E8F8: 419A00FC  beq cr6, 0x8284e9f4
	if ctx.cr[6].eq {
	pc = 0x8284E9F4; continue 'dispatch;
	}
	// 8284E8FC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8284E900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E904: 419A002C  beq cr6, 0x8284e930
	if ctx.cr[6].eq {
	pc = 0x8284E930; continue 'dispatch;
	}
	// 8284E908: 894B009A  lbz r10, 0x9a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(154 as u32) ) } as u64;
	// 8284E90C: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284E910: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8284E914: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8284E918: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E91C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8284E920: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284E924: 480000D4  b 0x8284e9f8
	pc = 0x8284E9F8; continue 'dispatch;
            }
            0x8284E928 => {
    //   block [0x8284E928..0x8284E930)
	// 8284E928: 4B945511  bl 0x82193e38
	ctx.lr = 0x8284E92C;
	sub_82193E38(ctx, base);
	// 8284E92C: 4BFFFFA8  b 0x8284e8d4
	pc = 0x8284E8D4; continue 'dispatch;
            }
            0x8284E930 => {
    //   block [0x8284E930..0x8284E94C)
	// 8284E930: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284E934: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8284E938: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8284E93C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8284E940: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8284E944: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284E948: 40810054  ble 0x8284e99c
	if !ctx.cr[0].gt {
	pc = 0x8284E99C; continue 'dispatch;
	}
	pc = 0x8284E94C; continue 'dispatch;
            }
            0x8284E94C => {
    //   block [0x8284E94C..0x8284E96C)
	// 8284E94C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8284E950: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8284E954: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8284E958: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E95C: 2F07009A  cmpwi cr6, r7, 0x9a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 154, &mut ctx.xer);
	// 8284E960: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8284E964: 41980008  blt cr6, 0x8284e96c
	if ctx.cr[6].lt {
	pc = 0x8284E96C; continue 'dispatch;
	}
	// 8284E968: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8284E96C; continue 'dispatch;
            }
            0x8284E96C => {
    //   block [0x8284E96C..0x8284E988)
	// 8284E96C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8284E970: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8284E974: 419A0014  beq cr6, 0x8284e988
	if ctx.cr[6].eq {
	pc = 0x8284E988; continue 'dispatch;
	}
	// 8284E978: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8284E97C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8284E980: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8284E984: 4800000C  b 0x8284e990
	pc = 0x8284E990; continue 'dispatch;
            }
            0x8284E988 => {
    //   block [0x8284E988..0x8284E990)
	// 8284E988: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8284E98C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8284E990; continue 'dispatch;
            }
            0x8284E990 => {
    //   block [0x8284E990..0x8284E99C)
	// 8284E990: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284E994: 4199FFB8  bgt cr6, 0x8284e94c
	if ctx.cr[6].gt {
	pc = 0x8284E94C; continue 'dispatch;
	}
	// 8284E998: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8284E99C; continue 'dispatch;
            }
            0x8284E99C => {
    //   block [0x8284E99C..0x8284E9B8)
	// 8284E99C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8284E9A0: 419A0040  beq cr6, 0x8284e9e0
	if ctx.cr[6].eq {
	pc = 0x8284E9E0; continue 'dispatch;
	}
	// 8284E9A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284E9A8: 2F0B009A  cmpwi cr6, r11, 0x9a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 154, &mut ctx.xer);
	// 8284E9AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284E9B0: 41990008  bgt cr6, 0x8284e9b8
	if ctx.cr[6].gt {
	pc = 0x8284E9B8; continue 'dispatch;
	}
	// 8284E9B4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8284E9B8; continue 'dispatch;
            }
            0x8284E9B8 => {
    //   block [0x8284E9B8..0x8284E9E0)
	// 8284E9B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E9BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284E9C0: 409A0020  bne cr6, 0x8284e9e0
	if !ctx.cr[6].eq {
	pc = 0x8284E9E0; continue 'dispatch;
	}
	// 8284E9C4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8284E9C8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8284E9CC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8284E9D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E9D4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8284E9D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284E9DC: 4800001C  b 0x8284e9f8
	pc = 0x8284E9F8; continue 'dispatch;
            }
            0x8284E9E0 => {
    //   block [0x8284E9E0..0x8284E9F4)
	// 8284E9E0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8284E9E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284E9E8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8284E9EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284E9F0: 48000008  b 0x8284e9f8
	pc = 0x8284E9F8; continue 'dispatch;
            }
            0x8284E9F4 => {
    //   block [0x8284E9F4..0x8284E9F8)
	// 8284E9F4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8284E9F8; continue 'dispatch;
            }
            0x8284E9F8 => {
    //   block [0x8284E9F8..0x8284EA2C)
	// 8284E9F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284E9FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284EA00: 419A002C  beq cr6, 0x8284ea2c
	if ctx.cr[6].eq {
	pc = 0x8284EA2C; continue 'dispatch;
	}
	// 8284EA04: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 8284EA08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284EA0C: 409A0020  bne cr6, 0x8284ea2c
	if !ctx.cr[6].eq {
	pc = 0x8284EA2C; continue 'dispatch;
	}
	// 8284EA10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284EA14: 809F0070  lwz r4, 0x70(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8284EA18: 4B98B931  bl 0x821da348
	ctx.lr = 0x8284EA1C;
	sub_821DA348(ctx, base);
	// 8284EA1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284EA20: 917D0080  stw r11, 0x80(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8284EA24: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284EA28: 915D0084  stw r10, 0x84(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	pc = 0x8284EA2C; continue 'dispatch;
            }
            0x8284EA2C => {
    //   block [0x8284EA2C..0x8284EAC4)
	// 8284EA2C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8284EA30: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8284EA34: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 8284EA38: 386BE9C4  addi r3, r11, -0x163c
	ctx.r[3].s64 = ctx.r[11].s64 + -5692;
	// 8284EA3C: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 8284EA40: 3BDD0078  addi r30, r29, 0x78
	ctx.r[30].s64 = ctx.r[29].s64 + 120;
	// 8284EA44: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 8284EA48: 4B9A5311  bl 0x821f3d58
	ctx.lr = 0x8284EA4C;
	sub_821F3D58(ctx, base);
	// 8284EA4C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8284EA50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284EA54: 4B963AA5  bl 0x821b24f8
	ctx.lr = 0x8284EA58;
	sub_821B24F8(ctx, base);
	// 8284EA58: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8284EA5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8284EA60: 48063029  bl 0x828b1a88
	ctx.lr = 0x8284EA64;
	sub_828B1A88(ctx, base);
	// 8284EA64: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8284EA68: 2F060010  cmpwi cr6, r6, 0x10
	ctx.cr[6].compare_i32(ctx.r[6].s32, 16, &mut ctx.xer);
	// 8284EA6C: 409A0080  bne cr6, 0x8284eaec
	if !ctx.cr[6].eq {
	pc = 0x8284EAEC; continue 'dispatch;
	}
	// 8284EA70: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8284EA74: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8284EA78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284EA7C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284EA80: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284EA84: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284EA88: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284EA8C: 810B0078  lwz r8, 0x78(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 8284EA90: 1D4824A1  mulli r10, r8, 0x24a1
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * 9377 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8284EA94: 38EA24DF  addi r7, r10, 0x24df
	ctx.r[7].s64 = ctx.r[10].s64 + 9439;
	// 8284EA98: 54E6983E  rotlwi r6, r7, 0x13
	ctx.r[6].u64 = ((ctx.r[7].u32).rotate_left(19)) as u64;
	// 8284EA9C: 54CA07FE  clrlwi r10, r6, 0x1f
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 8284EAA0: 90CB0078  stw r6, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[6].u32 ) };
	// 8284EAA4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 8284EAA8: 41980030  blt cr6, 0x8284ead8
	if ctx.cr[6].lt {
	pc = 0x8284EAD8; continue 'dispatch;
	}
	// 8284EAAC: 419A0018  beq cr6, 0x8284eac4
	if ctx.cr[6].eq {
	pc = 0x8284EAC4; continue 'dispatch;
	}
	// 8284EAB0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8284EAB4: 388BED18  addi r4, r11, -0x12e8
	ctx.r[4].s64 = ctx.r[11].s64 + -4840;
	// 8284EAB8: 4B9DE419  bl 0x8222ced0
	ctx.lr = 0x8284EABC;
	sub_8222CED0(ctx, base);
	// 8284EABC: 387D0054  addi r3, r29, 0x54
	ctx.r[3].s64 = ctx.r[29].s64 + 84;
	// 8284EAC0: 48000074  b 0x8284eb34
	pc = 0x8284EB34; continue 'dispatch;
            }
            0x8284EAC4 => {
    //   block [0x8284EAC4..0x8284EAD8)
	// 8284EAC4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8284EAC8: 388BED00  addi r4, r11, -0x1300
	ctx.r[4].s64 = ctx.r[11].s64 + -4864;
	// 8284EACC: 4B9DE405  bl 0x8222ced0
	ctx.lr = 0x8284EAD0;
	sub_8222CED0(ctx, base);
	// 8284EAD0: 387D0054  addi r3, r29, 0x54
	ctx.r[3].s64 = ctx.r[29].s64 + 84;
	// 8284EAD4: 48000060  b 0x8284eb34
	pc = 0x8284EB34; continue 'dispatch;
            }
            0x8284EAD8 => {
    //   block [0x8284EAD8..0x8284EAEC)
	// 8284EAD8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8284EADC: 388BECE8  addi r4, r11, -0x1318
	ctx.r[4].s64 = ctx.r[11].s64 + -4888;
	// 8284EAE0: 4B9DE3F1  bl 0x8222ced0
	ctx.lr = 0x8284EAE4;
	sub_8222CED0(ctx, base);
	// 8284EAE4: 387D0054  addi r3, r29, 0x54
	ctx.r[3].s64 = ctx.r[29].s64 + 84;
	// 8284EAE8: 4800004C  b 0x8284eb34
	pc = 0x8284EB34; continue 'dispatch;
            }
            0x8284EAEC => {
    //   block [0x8284EAEC..0x8284EB08)
	// 8284EAEC: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 8284EAF0: 3BFD0054  addi r31, r29, 0x54
	ctx.r[31].s64 = ctx.r[29].s64 + 84;
	// 8284EAF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284EAF8: 419A0010  beq cr6, 0x8284eb08
	if ctx.cr[6].eq {
	pc = 0x8284EB08; continue 'dispatch;
	}
	// 8284EAFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284EB00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284EB04: 409A0040  bne cr6, 0x8284eb44
	if !ctx.cr[6].eq {
	pc = 0x8284EB44; continue 'dispatch;
	}
	pc = 0x8284EB08; continue 'dispatch;
            }
            0x8284EB08 => {
    //   block [0x8284EB08..0x8284EB34)
	// 8284EB08: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8284EB0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284EB10: 38EB2CCC  addi r7, r11, 0x2ccc
	ctx.r[7].s64 = ctx.r[11].s64 + 11468;
	// 8284EB14: 4B9639E5  bl 0x821b24f8
	ctx.lr = 0x8284EB18;
	sub_821B24F8(ctx, base);
	// 8284EB18: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8284EB1C: 4BAD4A25  bl 0x82323540
	ctx.lr = 0x8284EB20;
	sub_82323540(ctx, base);
	// 8284EB20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8284EB24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284EB28: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8284EB2C: 4B9DE3A5  bl 0x8222ced0
	ctx.lr = 0x8284EB30;
	sub_8222CED0(ctx, base);
	// 8284EB30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8284EB34; continue 'dispatch;
            }
            0x8284EB34 => {
    //   block [0x8284EB34..0x8284EB44)
	// 8284EB34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8284EB38: 4BA16669  bl 0x822651a0
	ctx.lr = 0x8284EB3C;
	sub_822651A0(ctx, base);
	// 8284EB3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284EB40: 4B9C6299  bl 0x82214dd8
	ctx.lr = 0x8284EB44;
	sub_82214DD8(ctx, base);
	pc = 0x8284EB44; continue 'dispatch;
            }
            0x8284EB44 => {
    //   block [0x8284EB44..0x8284EB74)
	// 8284EB44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8284EB48: 4B994BF1  bl 0x821e3738
	ctx.lr = 0x8284EB4C;
	sub_821E3738(ctx, base);
	// 8284EB4C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8284EB50: 4B9D0709  bl 0x8221f258
	ctx.lr = 0x8284EB54;
	sub_8221F258(ctx, base);
	// 8284EB54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284EB58: 419A001C  beq cr6, 0x8284eb74
	if ctx.cr[6].eq {
	pc = 0x8284EB74; continue 'dispatch;
	}
	// 8284EB5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8284EB60: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8284EB64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8284EB68: 394BB730  addi r10, r11, -0x48d0
	ctx.r[10].s64 = ctx.r[11].s64 + -18640;
	// 8284EB6C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8284EB70: 48000008  b 0x8284eb78
	pc = 0x8284EB78; continue 'dispatch;
            }
            0x8284EB74 => {
    //   block [0x8284EB74..0x8284EB78)
	// 8284EB74: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x8284EB78; continue 'dispatch;
            }
            0x8284EB78 => {
    //   block [0x8284EB78..0x8284EB9C)
	// 8284EB78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8284EB7C: 4B96CF35  bl 0x821bbab0
	ctx.lr = 0x8284EB80;
	sub_821BBAB0(ctx, base);
	// 8284EB80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8284EB84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8284EB88: 4BA1D2E1  bl 0x8226be68
	ctx.lr = 0x8284EB8C;
	sub_8226BE68(ctx, base);
	// 8284EB8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8284EB90: 4B968F89  bl 0x821b7b18
	ctx.lr = 0x8284EB94;
	sub_821B7B18(ctx, base);
	// 8284EB94: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8284EB98: 4845A8C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8284EBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8284EBA8 size=648
    let mut pc: u32 = 0x8284EBA8;
    'dispatch: loop {
        match pc {
            0x8284EBA8 => {
    //   block [0x8284EBA8..0x8284EBE8)
	// 8284EBA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284EBAC: 4845A851  bl 0x82ca93fc
	ctx.lr = 0x8284EBB0;
	sub_82CA93D0(ctx, base);
	// 8284EBB0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8284EBB4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284EBB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8284EBBC: 897E0088  lbz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 8284EBC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284EBC4: 409A0260  bne cr6, 0x8284ee24
	if !ctx.cr[6].eq {
	pc = 0x8284EE24; continue 'dispatch;
	}
	// 8284EBC8: 897E0089  lbz r11, 0x89(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(137 as u32) ) } as u64;
	// 8284EBCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284EBD0: 409A0070  bne cr6, 0x8284ec40
	if !ctx.cr[6].eq {
	pc = 0x8284EC40; continue 'dispatch;
	}
	// 8284EBD4: 817E0080  lwz r11, 0x80(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 8284EBD8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8284EBDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284EBE0: 419A0008  beq cr6, 0x8284ebe8
	if ctx.cr[6].eq {
	pc = 0x8284EBE8; continue 'dispatch;
	}
	// 8284EBE4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x8284EBE8; continue 'dispatch;
            }
            0x8284EBE8 => {
    //   block [0x8284EBE8..0x8284EC40)
	// 8284EBE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284EBEC: 4BA5028D  bl 0x8229ee78
	ctx.lr = 0x8284EBF0;
	sub_8229EE78(ctx, base);
	// 8284EBF0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8284EBF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284EBF8: 4B925871  bl 0x82174468
	ctx.lr = 0x8284EBFC;
	sub_82174468(ctx, base);
	// 8284EBFC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8284EC00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8284EC04: 387E0078  addi r3, r30, 0x78
	ctx.r[3].s64 = ctx.r[30].s64 + 120;
	// 8284EC08: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8284EC0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8284EC10: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8284EC14: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8284EC18: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 8284EC1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8284EC20: 4BFFF7A1  bl 0x8284e3c0
	ctx.lr = 0x8284EC24;
	sub_8284E3C0(ctx, base);
	// 8284EC24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284EC28: 48000209  bl 0x8284ee30
	ctx.lr = 0x8284EC2C;
	sub_8284EE30(ctx, base);
	// 8284EC2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8284EC30: 995E0088  stb r10, 0x88(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[10].u8 ) };
	// 8284EC34: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8284EC38: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8284EC3C: 4845A810  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8284EC40 => {
    //   block [0x8284EC40..0x8284EC8C)
	// 8284EC40: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8284EC44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284EC48: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 8284EC4C: 4B92581D  bl 0x82174468
	ctx.lr = 0x8284EC50;
	sub_82174468(ctx, base);
	// 8284EC50: 81630034  lwz r11, 0x34(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 8284EC54: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8284EC58: 556A37FE  rlwinm r10, r11, 6, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 8284EC5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284EC60: 419A00E8  beq cr6, 0x8284ed48
	if ctx.cr[6].eq {
	pc = 0x8284ED48; continue 'dispatch;
	}
	// 8284EC64: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8284EC68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284EC6C: 419A0020  beq cr6, 0x8284ec8c
	if ctx.cr[6].eq {
	pc = 0x8284EC8C; continue 'dispatch;
	}
	// 8284EC70: 894B009A  lbz r10, 0x9a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(154 as u32) ) } as u64;
	// 8284EC74: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284EC78: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8284EC7C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8284EC80: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 8284EC84: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284EC88: 480000C4  b 0x8284ed4c
	pc = 0x8284ED4C; continue 'dispatch;
            }
            0x8284EC8C => {
    //   block [0x8284EC8C..0x8284ECA8)
	// 8284EC8C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284EC90: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8284EC94: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8284EC98: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8284EC9C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8284ECA0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284ECA4: 40810054  ble 0x8284ecf8
	if !ctx.cr[0].gt {
	pc = 0x8284ECF8; continue 'dispatch;
	}
	pc = 0x8284ECA8; continue 'dispatch;
            }
            0x8284ECA8 => {
    //   block [0x8284ECA8..0x8284ECC8)
	// 8284ECA8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8284ECAC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8284ECB0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8284ECB4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284ECB8: 2F07009A  cmpwi cr6, r7, 0x9a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 154, &mut ctx.xer);
	// 8284ECBC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8284ECC0: 41980008  blt cr6, 0x8284ecc8
	if ctx.cr[6].lt {
	pc = 0x8284ECC8; continue 'dispatch;
	}
	// 8284ECC4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8284ECC8; continue 'dispatch;
            }
            0x8284ECC8 => {
    //   block [0x8284ECC8..0x8284ECE4)
	// 8284ECC8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8284ECCC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8284ECD0: 419A0014  beq cr6, 0x8284ece4
	if ctx.cr[6].eq {
	pc = 0x8284ECE4; continue 'dispatch;
	}
	// 8284ECD4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8284ECD8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8284ECDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8284ECE0: 4800000C  b 0x8284ecec
	pc = 0x8284ECEC; continue 'dispatch;
            }
            0x8284ECE4 => {
    //   block [0x8284ECE4..0x8284ECEC)
	// 8284ECE4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8284ECE8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8284ECEC; continue 'dispatch;
            }
            0x8284ECEC => {
    //   block [0x8284ECEC..0x8284ECF8)
	// 8284ECEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284ECF0: 4199FFB8  bgt cr6, 0x8284eca8
	if ctx.cr[6].gt {
	pc = 0x8284ECA8; continue 'dispatch;
	}
	// 8284ECF4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8284ECF8; continue 'dispatch;
            }
            0x8284ECF8 => {
    //   block [0x8284ECF8..0x8284ED14)
	// 8284ECF8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8284ECFC: 419A003C  beq cr6, 0x8284ed38
	if ctx.cr[6].eq {
	pc = 0x8284ED38; continue 'dispatch;
	}
	// 8284ED00: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284ED04: 2F0B009A  cmpwi cr6, r11, 0x9a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 154, &mut ctx.xer);
	// 8284ED08: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 8284ED0C: 41990008  bgt cr6, 0x8284ed14
	if ctx.cr[6].gt {
	pc = 0x8284ED14; continue 'dispatch;
	}
	// 8284ED10: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8284ED14; continue 'dispatch;
            }
            0x8284ED14 => {
    //   block [0x8284ED14..0x8284ED38)
	// 8284ED14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284ED18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284ED1C: 409A001C  bne cr6, 0x8284ed38
	if !ctx.cr[6].eq {
	pc = 0x8284ED38; continue 'dispatch;
	}
	// 8284ED20: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8284ED24: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8284ED28: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8284ED2C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284ED30: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 8284ED34: 48000018  b 0x8284ed4c
	pc = 0x8284ED4C; continue 'dispatch;
            }
            0x8284ED38 => {
    //   block [0x8284ED38..0x8284ED48)
	// 8284ED38: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8284ED3C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284ED40: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 8284ED44: 48000008  b 0x8284ed4c
	pc = 0x8284ED4C; continue 'dispatch;
            }
            0x8284ED48 => {
    //   block [0x8284ED48..0x8284ED4C)
	// 8284ED48: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8284ED4C; continue 'dispatch;
            }
            0x8284ED4C => {
    //   block [0x8284ED4C..0x8284EDDC)
	// 8284ED4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284ED50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284ED54: 419A00D0  beq cr6, 0x8284ee24
	if ctx.cr[6].eq {
	pc = 0x8284EE24; continue 'dispatch;
	}
	// 8284ED58: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 8284ED5C: 895F000C  lbz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284ED60: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 8284ED64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284ED68: 99696D45  stb r11, 0x6d45(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(27973 as u32), ctx.r[11].u8 ) };
	// 8284ED6C: 419A0070  beq cr6, 0x8284eddc
	if ctx.cr[6].eq {
	pc = 0x8284EDDC; continue 'dispatch;
	}
	// 8284ED70: 897F000D  lbz r11, 0xd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(13 as u32) ) } as u64;
	// 8284ED74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284ED78: 419A00AC  beq cr6, 0x8284ee24
	if ctx.cr[6].eq {
	pc = 0x8284EE24; continue 'dispatch;
	}
	// 8284ED7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284ED80: 419A005C  beq cr6, 0x8284eddc
	if ctx.cr[6].eq {
	pc = 0x8284EDDC; continue 'dispatch;
	}
	// 8284ED84: 9B9E008A  stb r28, 0x8a(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(138 as u32), ctx.r[28].u8 ) };
	// 8284ED88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284ED8C: 8B7E004B  lbz r27, 0x4b(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(75 as u32) ) } as u64;
	// 8284ED90: C3FF0018  lfs f31, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8284ED94: 8B5F0011  lbz r26, 0x11(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 8284ED98: 4BA500E1  bl 0x8229ee78
	ctx.lr = 0x8284ED9C;
	sub_8229EE78(ctx, base);
	// 8284ED9C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8284EDA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284EDA4: 4B9256C5  bl 0x82174468
	ctx.lr = 0x8284EDA8;
	sub_82174468(ctx, base);
	// 8284EDA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8284EDAC: 387E0078  addi r3, r30, 0x78
	ctx.r[3].s64 = ctx.r[30].s64 + 120;
	// 8284EDB0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8284EDB4: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8284EDB8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8284EDBC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 8284EDC0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8284EDC4: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 8284EDC8: 4BFFF5F9  bl 0x8284e3c0
	ctx.lr = 0x8284EDCC;
	sub_8284E3C0(ctx, base);
	// 8284EDCC: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 8284EDD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284EDD4: 4BBC8C7D  bl 0x82417a50
	ctx.lr = 0x8284EDD8;
	sub_82417A50(ctx, base);
	// 8284EDD8: 48000040  b 0x8284ee18
	pc = 0x8284EE18; continue 'dispatch;
            }
            0x8284EDDC => {
    //   block [0x8284EDDC..0x8284EE18)
	// 8284EDDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284EDE0: 4BA50099  bl 0x8229ee78
	ctx.lr = 0x8284EDE4;
	sub_8229EE78(ctx, base);
	// 8284EDE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8284EDE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284EDEC: 4B92567D  bl 0x82174468
	ctx.lr = 0x8284EDF0;
	sub_82174468(ctx, base);
	// 8284EDF0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8284EDF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8284EDF8: 387E0078  addi r3, r30, 0x78
	ctx.r[3].s64 = ctx.r[30].s64 + 120;
	// 8284EDFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8284EE00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8284EE04: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8284EE08: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8284EE0C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8284EE10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8284EE14: 4BFFF5AD  bl 0x8284e3c0
	ctx.lr = 0x8284EE18;
	sub_8284E3C0(ctx, base);
	pc = 0x8284EE18; continue 'dispatch;
            }
            0x8284EE18 => {
    //   block [0x8284EE18..0x8284EE24)
	// 8284EE18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284EE1C: 48000015  bl 0x8284ee30
	ctx.lr = 0x8284EE20;
	sub_8284EE30(ctx, base);
	// 8284EE20: 9B9E0088  stb r28, 0x88(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[28].u8 ) };
	pc = 0x8284EE24; continue 'dispatch;
            }
            0x8284EE24 => {
    //   block [0x8284EE24..0x8284EE30)
	// 8284EE24: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8284EE28: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8284EE2C: 4845A620  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8284EE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8284EE30 size=1356
    let mut pc: u32 = 0x8284EE30;
    'dispatch: loop {
        match pc {
            0x8284EE30 => {
    //   block [0x8284EE30..0x8284EEA8)
	// 8284EE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284EE34: 4845A5CD  bl 0x82ca9400
	ctx.lr = 0x8284EE38;
	sub_82CA93D0(ctx, base);
	// 8284EE38: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284EE3C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8284EE40: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 8284EE44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8284EE48: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8284EE4C: 386BE9C4  addi r3, r11, -0x163c
	ctx.r[3].s64 = ctx.r[11].s64 + -5692;
	// 8284EE50: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 8284EE54: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8284EE58: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 8284EE5C: 4B9A4EFD  bl 0x821f3d58
	ctx.lr = 0x8284EE60;
	sub_821F3D58(ctx, base);
	// 8284EE60: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8284EE64: 387E0078  addi r3, r30, 0x78
	ctx.r[3].s64 = ctx.r[30].s64 + 120;
	// 8284EE68: 4B963691  bl 0x821b24f8
	ctx.lr = 0x8284EE6C;
	sub_821B24F8(ctx, base);
	// 8284EE6C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8284EE70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8284EE74: 48062C15  bl 0x828b1a88
	ctx.lr = 0x8284EE78;
	sub_828B1A88(ctx, base);
	// 8284EE78: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8284EE7C: 2F060004  cmpwi cr6, r6, 4
	ctx.cr[6].compare_i32(ctx.r[6].s32, 4, &mut ctx.xer);
	// 8284EE80: 409A04F4  bne cr6, 0x8284f374
	if !ctx.cr[6].eq {
	pc = 0x8284F374; continue 'dispatch;
	}
	// 8284EE84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284EE88: 4BA4FFF1  bl 0x8229ee78
	ctx.lr = 0x8284EE8C;
	sub_8229EE78(ctx, base);
	// 8284EE8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284EE90: 419A0018  beq cr6, 0x8284eea8
	if ctx.cr[6].eq {
	pc = 0x8284EEA8; continue 'dispatch;
	}
	// 8284EE94: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8284EE98: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8284EE9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284EEA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284EEA4: 409A0008  bne cr6, 0x8284eeac
	if !ctx.cr[6].eq {
	pc = 0x8284EEAC; continue 'dispatch;
	}
	pc = 0x8284EEA8; continue 'dispatch;
            }
            0x8284EEA8 => {
    //   block [0x8284EEA8..0x8284EEAC)
	// 8284EEA8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8284EEAC; continue 'dispatch;
            }
            0x8284EEAC => {
    //   block [0x8284EEAC..0x8284EF24)
	// 8284EEAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284EEB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284EEB4: 419A04C0  beq cr6, 0x8284f374
	if ctx.cr[6].eq {
	pc = 0x8284F374; continue 'dispatch;
	}
	// 8284EEB8: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 8284EEBC: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 8284EEC0: 3BAB3CF4  addi r29, r11, 0x3cf4
	ctx.r[29].s64 = ctx.r[11].s64 + 15604;
	// 8284EEC4: 816A3D00  lwz r11, 0x3d00(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15616 as u32) ) } as u64;
	// 8284EEC8: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8284EECC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8284EED0: 409A0054  bne cr6, 0x8284ef24
	if !ctx.cr[6].eq {
	pc = 0x8284EF24; continue 'dispatch;
	}
	// 8284EED4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8284EED8: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 8284EEDC: 916A3D00  stw r11, 0x3d00(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15616 as u32), ctx.r[11].u32 ) };
	// 8284EEE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8284EEE4: 3889ED64  addi r4, r9, -0x129c
	ctx.r[4].s64 = ctx.r[9].s64 + -4764;
	// 8284EEE8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8284EEEC: 4B9DDFE5  bl 0x8222ced0
	ctx.lr = 0x8284EEF0;
	sub_8222CED0(ctx, base);
	// 8284EEF0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 8284EEF4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8284EEF8: 3888ED48  addi r4, r8, -0x12b8
	ctx.r[4].s64 = ctx.r[8].s64 + -4792;
	// 8284EEFC: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 8284EF00: 4B9DDFD1  bl 0x8222ced0
	ctx.lr = 0x8284EF04;
	sub_8222CED0(ctx, base);
	// 8284EF04: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 8284EF08: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8284EF0C: 3887ED2C  addi r4, r7, -0x12d4
	ctx.r[4].s64 = ctx.r[7].s64 + -4820;
	// 8284EF10: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 8284EF14: 4B9DDFBD  bl 0x8222ced0
	ctx.lr = 0x8284EF18;
	sub_8222CED0(ctx, base);
	// 8284EF18: 3CC0832B  lis r6, -0x7cd5
	ctx.r[6].s64 = -2094333952;
	// 8284EF1C: 3866E7E8  addi r3, r6, -0x1818
	ctx.r[3].s64 = ctx.r[6].s64 + -6168;
	// 8284EF20: 4845B001  bl 0x82ca9f20
	ctx.lr = 0x8284EF24;
	sub_82CA9F20(ctx, base);
	pc = 0x8284EF24; continue 'dispatch;
            }
            0x8284EF24 => {
    //   block [0x8284EF24..0x8284EFE8)
	// 8284EF24: 3D60AAAA  lis r11, -0x5556
	ctx.r[11].s64 = -1431699456;
	// 8284EF28: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 8284EF2C: 616BAAAB  ori r11, r11, 0xaaab
	ctx.r[11].u64 = ctx.r[11].u64 | 43691;
	// 8284EF30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284EF34: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 8284EF38: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 8284EF3C: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8284EF40: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 8284EF44: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284EF48: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284EF4C: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284EF50: 808A0078  lwz r4, 0x78(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 8284EF54: 1D2424A1  mulli r9, r4, 0x24a1
	ctx.r[9].s32 = ((ctx.r[4].s32 as i64 * 9377 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8284EF58: 392924DF  addi r9, r9, 0x24df
	ctx.r[9].s64 = ctx.r[9].s64 + 9439;
	// 8284EF5C: 5526983E  rotlwi r6, r9, 0x13
	ctx.r[6].u64 = ((ctx.r[9].u32).rotate_left(19)) as u64;
	// 8284EF60: 90CA0078  stw r6, 0x78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), ctx.r[6].u32 ) };
	// 8284EF64: 7C864016  mulhwu r4, r6, r8
	ctx.r[4].u64 = ((ctx.r[6].u32 as u64 * ctx.r[8].u32 as u64) >> 32);
	// 8284EF68: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8284EF6C: 548BF87E  srwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8284EF70: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8284EF74: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8284EF78: 7F6B3050  subf r27, r11, r6
	ctx.r[27].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 8284EF7C: 81450058  lwz r10, 0x58(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(88 as u32) ) } as u64;
	// 8284EF80: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284EF84: 812B0078  lwz r9, 0x78(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 8284EF88: 1D4924A1  mulli r10, r9, 0x24a1
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 9377 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8284EF8C: 390A24DF  addi r8, r10, 0x24df
	ctx.r[8].s64 = ctx.r[10].s64 + 9439;
	// 8284EF90: 5506983E  rotlwi r6, r8, 0x13
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(19)) as u64;
	// 8284EF94: 90CB0078  stw r6, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[6].u32 ) };
	// 8284EF98: 7CA63816  mulhwu r5, r6, r7
	ctx.r[5].u64 = ((ctx.r[6].u32 as u64 * ctx.r[7].u32 as u64) >> 32);
	// 8284EF9C: 54ABF87E  srwi r11, r5, 1
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8284EFA0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8284EFA4: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8284EFA8: 7F443050  subf r26, r4, r6
	ctx.r[26].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 8284EFAC: 4B9254BD  bl 0x82174468
	ctx.lr = 0x8284EFB0;
	sub_82174468(ctx, base);
	// 8284EFB0: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8284EFB4: 556AE7FE  rlwinm r10, r11, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 8284EFB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284EFBC: 419A00E8  beq cr6, 0x8284f0a4
	if ctx.cr[6].eq {
	pc = 0x8284F0A4; continue 'dispatch;
	}
	// 8284EFC0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8284EFC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284EFC8: 419A0020  beq cr6, 0x8284efe8
	if ctx.cr[6].eq {
	pc = 0x8284EFE8; continue 'dispatch;
	}
	// 8284EFCC: 894B0064  lbz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 8284EFD0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284EFD4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8284EFD8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8284EFDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284EFE0: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284EFE4: 480000C4  b 0x8284f0a8
	pc = 0x8284F0A8; continue 'dispatch;
            }
            0x8284EFE8 => {
    //   block [0x8284EFE8..0x8284F004)
	// 8284EFE8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284EFEC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8284EFF0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8284EFF4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8284EFF8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8284EFFC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284F000: 40810054  ble 0x8284f054
	if !ctx.cr[0].gt {
	pc = 0x8284F054; continue 'dispatch;
	}
	pc = 0x8284F004; continue 'dispatch;
            }
            0x8284F004 => {
    //   block [0x8284F004..0x8284F024)
	// 8284F004: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8284F008: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8284F00C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8284F010: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284F014: 2F070064  cmpwi cr6, r7, 0x64
	ctx.cr[6].compare_i32(ctx.r[7].s32, 100, &mut ctx.xer);
	// 8284F018: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8284F01C: 41980008  blt cr6, 0x8284f024
	if ctx.cr[6].lt {
	pc = 0x8284F024; continue 'dispatch;
	}
	// 8284F020: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8284F024; continue 'dispatch;
            }
            0x8284F024 => {
    //   block [0x8284F024..0x8284F040)
	// 8284F024: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8284F028: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8284F02C: 419A0014  beq cr6, 0x8284f040
	if ctx.cr[6].eq {
	pc = 0x8284F040; continue 'dispatch;
	}
	// 8284F030: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8284F034: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8284F038: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8284F03C: 4800000C  b 0x8284f048
	pc = 0x8284F048; continue 'dispatch;
            }
            0x8284F040 => {
    //   block [0x8284F040..0x8284F048)
	// 8284F040: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8284F044: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8284F048; continue 'dispatch;
            }
            0x8284F048 => {
    //   block [0x8284F048..0x8284F054)
	// 8284F048: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284F04C: 4199FFB8  bgt cr6, 0x8284f004
	if ctx.cr[6].gt {
	pc = 0x8284F004; continue 'dispatch;
	}
	// 8284F050: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8284F054; continue 'dispatch;
            }
            0x8284F054 => {
    //   block [0x8284F054..0x8284F070)
	// 8284F054: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8284F058: 419A003C  beq cr6, 0x8284f094
	if ctx.cr[6].eq {
	pc = 0x8284F094; continue 'dispatch;
	}
	// 8284F05C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284F060: 2F0B0064  cmpwi cr6, r11, 0x64
	ctx.cr[6].compare_i32(ctx.r[11].s32, 100, &mut ctx.xer);
	// 8284F064: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284F068: 41990008  bgt cr6, 0x8284f070
	if ctx.cr[6].gt {
	pc = 0x8284F070; continue 'dispatch;
	}
	// 8284F06C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8284F070; continue 'dispatch;
            }
            0x8284F070 => {
    //   block [0x8284F070..0x8284F094)
	// 8284F070: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284F074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284F078: 409A001C  bne cr6, 0x8284f094
	if !ctx.cr[6].eq {
	pc = 0x8284F094; continue 'dispatch;
	}
	// 8284F07C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8284F080: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8284F084: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8284F088: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284F08C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284F090: 48000018  b 0x8284f0a8
	pc = 0x8284F0A8; continue 'dispatch;
            }
            0x8284F094 => {
    //   block [0x8284F094..0x8284F0A4)
	// 8284F094: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8284F098: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284F09C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284F0A0: 48000008  b 0x8284f0a8
	pc = 0x8284F0A8; continue 'dispatch;
            }
            0x8284F0A4 => {
    //   block [0x8284F0A4..0x8284F0A8)
	// 8284F0A4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8284F0A8; continue 'dispatch;
            }
            0x8284F0A8 => {
    //   block [0x8284F0A8..0x8284F11C)
	// 8284F0A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284F0AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284F0B0: 419A02C4  beq cr6, 0x8284f374
	if ctx.cr[6].eq {
	pc = 0x8284F374; continue 'dispatch;
	}
	// 8284F0B4: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8284F0B8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8284F0BC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8284F0C0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8284F0C4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8284F0C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8284F0CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8284F0D0: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8284F0D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284F0D8: 4BD87F89  bl 0x825d7060
	ctx.lr = 0x8284F0DC;
	sub_825D7060(ctx, base);
	// 8284F0DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284F0E0: 4BA4FD99  bl 0x8229ee78
	ctx.lr = 0x8284F0E4;
	sub_8229EE78(ctx, base);
	// 8284F0E4: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8284F0E8: 556AE7FE  rlwinm r10, r11, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 8284F0EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284F0F0: 419A00E8  beq cr6, 0x8284f1d8
	if ctx.cr[6].eq {
	pc = 0x8284F1D8; continue 'dispatch;
	}
	// 8284F0F4: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8284F0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284F0FC: 419A0020  beq cr6, 0x8284f11c
	if ctx.cr[6].eq {
	pc = 0x8284F11C; continue 'dispatch;
	}
	// 8284F100: 894B0064  lbz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 8284F104: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284F108: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8284F10C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8284F110: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284F114: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284F118: 480000C4  b 0x8284f1dc
	pc = 0x8284F1DC; continue 'dispatch;
            }
            0x8284F11C => {
    //   block [0x8284F11C..0x8284F138)
	// 8284F11C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284F120: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8284F124: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8284F128: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8284F12C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8284F130: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284F134: 40810054  ble 0x8284f188
	if !ctx.cr[0].gt {
	pc = 0x8284F188; continue 'dispatch;
	}
	pc = 0x8284F138; continue 'dispatch;
            }
            0x8284F138 => {
    //   block [0x8284F138..0x8284F158)
	// 8284F138: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8284F13C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8284F140: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8284F144: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284F148: 2F070064  cmpwi cr6, r7, 0x64
	ctx.cr[6].compare_i32(ctx.r[7].s32, 100, &mut ctx.xer);
	// 8284F14C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8284F150: 41980008  blt cr6, 0x8284f158
	if ctx.cr[6].lt {
	pc = 0x8284F158; continue 'dispatch;
	}
	// 8284F154: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8284F158; continue 'dispatch;
            }
            0x8284F158 => {
    //   block [0x8284F158..0x8284F174)
	// 8284F158: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8284F15C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8284F160: 419A0014  beq cr6, 0x8284f174
	if ctx.cr[6].eq {
	pc = 0x8284F174; continue 'dispatch;
	}
	// 8284F164: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8284F168: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8284F16C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8284F170: 4800000C  b 0x8284f17c
	pc = 0x8284F17C; continue 'dispatch;
            }
            0x8284F174 => {
    //   block [0x8284F174..0x8284F17C)
	// 8284F174: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8284F178: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8284F17C; continue 'dispatch;
            }
            0x8284F17C => {
    //   block [0x8284F17C..0x8284F188)
	// 8284F17C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284F180: 4199FFB8  bgt cr6, 0x8284f138
	if ctx.cr[6].gt {
	pc = 0x8284F138; continue 'dispatch;
	}
	// 8284F184: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8284F188; continue 'dispatch;
            }
            0x8284F188 => {
    //   block [0x8284F188..0x8284F1A4)
	// 8284F188: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8284F18C: 419A003C  beq cr6, 0x8284f1c8
	if ctx.cr[6].eq {
	pc = 0x8284F1C8; continue 'dispatch;
	}
	// 8284F190: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284F194: 2F0B0064  cmpwi cr6, r11, 0x64
	ctx.cr[6].compare_i32(ctx.r[11].s32, 100, &mut ctx.xer);
	// 8284F198: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284F19C: 41990008  bgt cr6, 0x8284f1a4
	if ctx.cr[6].gt {
	pc = 0x8284F1A4; continue 'dispatch;
	}
	// 8284F1A0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8284F1A4; continue 'dispatch;
            }
            0x8284F1A4 => {
    //   block [0x8284F1A4..0x8284F1C8)
	// 8284F1A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284F1A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284F1AC: 409A001C  bne cr6, 0x8284f1c8
	if !ctx.cr[6].eq {
	pc = 0x8284F1C8; continue 'dispatch;
	}
	// 8284F1B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8284F1B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8284F1B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8284F1BC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284F1C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284F1C4: 48000018  b 0x8284f1dc
	pc = 0x8284F1DC; continue 'dispatch;
            }
            0x8284F1C8 => {
    //   block [0x8284F1C8..0x8284F1D8)
	// 8284F1C8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8284F1CC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284F1D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284F1D4: 48000008  b 0x8284f1dc
	pc = 0x8284F1DC; continue 'dispatch;
            }
            0x8284F1D8 => {
    //   block [0x8284F1D8..0x8284F1DC)
	// 8284F1D8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8284F1DC; continue 'dispatch;
            }
            0x8284F1DC => {
    //   block [0x8284F1DC..0x8284F254)
	// 8284F1DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284F1E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284F1E4: 419A0190  beq cr6, 0x8284f374
	if ctx.cr[6].eq {
	pc = 0x8284F374; continue 'dispatch;
	}
	// 8284F1E8: 574B103A  slwi r11, r26, 2
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8284F1EC: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8284F1F0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8284F1F4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8284F1F8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8284F1FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8284F200: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8284F204: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8284F208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284F20C: 4BD87E55  bl 0x825d7060
	ctx.lr = 0x8284F210;
	sub_825D7060(ctx, base);
	// 8284F210: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284F214: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 8284F218: 4B925251  bl 0x82174468
	ctx.lr = 0x8284F21C;
	sub_82174468(ctx, base);
	// 8284F21C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 8284F220: 556A3FFE  rlwinm r10, r11, 7, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 8284F224: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8284F228: 419A00E4  beq cr6, 0x8284f30c
	if ctx.cr[6].eq {
	pc = 0x8284F30C; continue 'dispatch;
	}
	// 8284F22C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8284F230: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8284F234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284F238: 419A001C  beq cr6, 0x8284f254
	if ctx.cr[6].eq {
	pc = 0x8284F254; continue 'dispatch;
	}
	// 8284F23C: 896B0039  lbz r11, 0x39(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 8284F240: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8284F244: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8284F248: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284F24C: 83EA0004  lwz r31, 4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284F250: 480000C0  b 0x8284f310
	pc = 0x8284F310; continue 'dispatch;
            }
            0x8284F254 => {
    //   block [0x8284F254..0x8284F26C)
	// 8284F254: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8284F258: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8284F25C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8284F260: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8284F264: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284F268: 40810054  ble 0x8284f2bc
	if !ctx.cr[0].gt {
	pc = 0x8284F2BC; continue 'dispatch;
	}
	pc = 0x8284F26C; continue 'dispatch;
            }
            0x8284F26C => {
    //   block [0x8284F26C..0x8284F28C)
	// 8284F26C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8284F270: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8284F274: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8284F278: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284F27C: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 8284F280: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8284F284: 41980008  blt cr6, 0x8284f28c
	if ctx.cr[6].lt {
	pc = 0x8284F28C; continue 'dispatch;
	}
	// 8284F288: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8284F28C; continue 'dispatch;
            }
            0x8284F28C => {
    //   block [0x8284F28C..0x8284F2A8)
	// 8284F28C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8284F290: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8284F294: 419A0014  beq cr6, 0x8284f2a8
	if ctx.cr[6].eq {
	pc = 0x8284F2A8; continue 'dispatch;
	}
	// 8284F298: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8284F29C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8284F2A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8284F2A4: 4800000C  b 0x8284f2b0
	pc = 0x8284F2B0; continue 'dispatch;
            }
            0x8284F2A8 => {
    //   block [0x8284F2A8..0x8284F2B0)
	// 8284F2A8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8284F2AC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8284F2B0; continue 'dispatch;
            }
            0x8284F2B0 => {
    //   block [0x8284F2B0..0x8284F2BC)
	// 8284F2B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284F2B4: 4199FFB8  bgt cr6, 0x8284f26c
	if ctx.cr[6].gt {
	pc = 0x8284F26C; continue 'dispatch;
	}
	// 8284F2B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8284F2BC; continue 'dispatch;
            }
            0x8284F2BC => {
    //   block [0x8284F2BC..0x8284F2D8)
	// 8284F2BC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8284F2C0: 419A003C  beq cr6, 0x8284f2fc
	if ctx.cr[6].eq {
	pc = 0x8284F2FC; continue 'dispatch;
	}
	// 8284F2C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284F2C8: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 8284F2CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284F2D0: 41990008  bgt cr6, 0x8284f2d8
	if ctx.cr[6].gt {
	pc = 0x8284F2D8; continue 'dispatch;
	}
	// 8284F2D4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8284F2D8; continue 'dispatch;
            }
            0x8284F2D8 => {
    //   block [0x8284F2D8..0x8284F2FC)
	// 8284F2D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284F2DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284F2E0: 409A001C  bne cr6, 0x8284f2fc
	if !ctx.cr[6].eq {
	pc = 0x8284F2FC; continue 'dispatch;
	}
	// 8284F2E4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8284F2E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8284F2EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8284F2F0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284F2F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284F2F8: 48000018  b 0x8284f310
	pc = 0x8284F310; continue 'dispatch;
            }
            0x8284F2FC => {
    //   block [0x8284F2FC..0x8284F30C)
	// 8284F2FC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8284F300: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284F304: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8284F308: 48000008  b 0x8284f310
	pc = 0x8284F310; continue 'dispatch;
            }
            0x8284F30C => {
    //   block [0x8284F30C..0x8284F310)
	// 8284F30C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8284F310; continue 'dispatch;
            }
            0x8284F310 => {
    //   block [0x8284F310..0x8284F340)
	// 8284F310: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8284F314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284F318: 419A005C  beq cr6, 0x8284f374
	if ctx.cr[6].eq {
	pc = 0x8284F374; continue 'dispatch;
	}
	// 8284F31C: 817F04E4  lwz r11, 0x4e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1252 as u32) ) } as u64;
	// 8284F320: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8284F324: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8284F328: 917F04E4  stw r11, 0x4e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1252 as u32), ctx.r[11].u32 ) };
	// 8284F32C: 409A0014  bne cr6, 0x8284f340
	if !ctx.cr[6].eq {
	pc = 0x8284F340; continue 'dispatch;
	}
	// 8284F330: 2B1A0002  cmplwi cr6, r26, 2
	ctx.cr[6].compare_u32(ctx.r[26].u32, 2 as u32, &mut ctx.xer);
	// 8284F334: 419A0034  beq cr6, 0x8284f368
	if ctx.cr[6].eq {
	pc = 0x8284F368; continue 'dispatch;
	}
	// 8284F338: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8284F33C: 4845A114  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8284F340 => {
    //   block [0x8284F340..0x8284F358)
	// 8284F340: 2B1B0001  cmplwi cr6, r27, 1
	ctx.cr[6].compare_u32(ctx.r[27].u32, 1 as u32, &mut ctx.xer);
	// 8284F344: 409A0014  bne cr6, 0x8284f358
	if !ctx.cr[6].eq {
	pc = 0x8284F358; continue 'dispatch;
	}
	// 8284F348: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8284F34C: 419A001C  beq cr6, 0x8284f368
	if ctx.cr[6].eq {
	pc = 0x8284F368; continue 'dispatch;
	}
	// 8284F350: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8284F354: 4845A0FC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8284F358 => {
    //   block [0x8284F358..0x8284F368)
	// 8284F358: 2B1B0002  cmplwi cr6, r27, 2
	ctx.cr[6].compare_u32(ctx.r[27].u32, 2 as u32, &mut ctx.xer);
	// 8284F35C: 409A0018  bne cr6, 0x8284f374
	if !ctx.cr[6].eq {
	pc = 0x8284F374; continue 'dispatch;
	}
	// 8284F360: 2B1A0001  cmplwi cr6, r26, 1
	ctx.cr[6].compare_u32(ctx.r[26].u32, 1 as u32, &mut ctx.xer);
	// 8284F364: 409A0010  bne cr6, 0x8284f374
	if !ctx.cr[6].eq {
	pc = 0x8284F374; continue 'dispatch;
	}
	pc = 0x8284F368; continue 'dispatch;
            }
            0x8284F368 => {
    //   block [0x8284F368..0x8284F374)
	// 8284F368: 817F04E8  lwz r11, 0x4e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1256 as u32) ) } as u64;
	// 8284F36C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8284F370: 917F04E8  stw r11, 0x4e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1256 as u32), ctx.r[11].u32 ) };
	pc = 0x8284F374; continue 'dispatch;
            }
            0x8284F374 => {
    //   block [0x8284F374..0x8284F37C)
	// 8284F374: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8284F378: 4845A0D8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8284F380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8284F380 size=232
    let mut pc: u32 = 0x8284F380;
    'dispatch: loop {
        match pc {
            0x8284F380 => {
    //   block [0x8284F380..0x8284F3EC)
	// 8284F380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284F384: 4845A089  bl 0x82ca940c
	ctx.lr = 0x8284F388;
	sub_82CA93D0(ctx, base);
	// 8284F388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284F38C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8284F390: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8284F394: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8284F398: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8284F39C: 4817F995  bl 0x829ced30
	ctx.lr = 0x8284F3A0;
	sub_829CED30(ctx, base);
	// 8284F3A0: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 8284F3A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8284F3A8: 38EAEEA8  addi r7, r10, -0x1158
	ctx.r[7].s64 = ctx.r[10].s64 + -4440;
	// 8284F3AC: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 8284F3B0: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8284F3B4: 395F0088  addi r10, r31, 0x88
	ctx.r[10].s64 = ctx.r[31].s64 + 136;
	// 8284F3B8: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284F3BC: 38A67088  addi r5, r6, 0x7088
	ctx.r[5].s64 = ctx.r[6].s64 + 28808;
	// 8284F3C0: 909F0080  stw r4, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[4].u32 ) };
	// 8284F3C4: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284F3C8: 907F0084  stw r3, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 8284F3CC: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 8284F3D0: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 8284F3D4: 997F0094  stb r11, 0x94(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u8 ) };
	// 8284F3D8: 997F0095  stb r11, 0x95(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(149 as u32), ctx.r[11].u8 ) };
	// 8284F3DC: 997F0096  stb r11, 0x96(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(150 as u32), ctx.r[11].u8 ) };
	// 8284F3E0: 997F0097  stb r11, 0x97(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(151 as u32), ctx.r[11].u8 ) };
	// 8284F3E4: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 8284F3E8: 917F009C  stw r11, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	pc = 0x8284F3EC; continue 'dispatch;
            }
            0x8284F3EC => {
    //   block [0x8284F3EC..0x8284F468)
	// 8284F3EC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8284F3F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8284F3F4: 7D202828  lwarx r9, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8284F3F8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8284F3FC: 7D20292D  stwcx. r9, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8284F400: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8284F404: 4082FFE8  bne 0x8284f3ec
	if !ctx.cr[0].eq {
	pc = 0x8284F3EC; continue 'dispatch;
	}
	// 8284F408: 997F00A0  stb r11, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[11].u8 ) };
	// 8284F40C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8284F410: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 8284F414: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284F418: 917F00A8  stw r11, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 8284F41C: 917F00AC  stw r11, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 8284F420: 917F00B0  stw r11, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 8284F424: 917F00B4  stw r11, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 8284F428: 917F00B8  stw r11, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 8284F42C: 917F00BC  stw r11, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 8284F430: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 8284F434: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 8284F438: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 8284F43C: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 8284F440: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 8284F444: 4BFFE31D  bl 0x8284d760
	ctx.lr = 0x8284F448;
	sub_8284D760(ctx, base);
	// 8284F448: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8284F44C: 39400090  li r10, 0x90
	ctx.r[10].s64 = 144;
	// 8284F450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284F454: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 8284F458: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8284F45C: 7C1F57AE  stfiwx f0, r31, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 8284F460: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8284F464: 48459FF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8284F468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8284F468 size=6360
    let mut pc: u32 = 0x8284F468;
    'dispatch: loop {
        match pc {
            0x8284F468 => {
    //   block [0x8284F468..0x82850D40)
	// 8284F468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284F46C: 48459F65  bl 0x82ca93d0
	ctx.lr = 0x8284F470;
	sub_82CA93D0(ctx, base);
	// 8284F470: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 8284F474: 3980FF40  li r12, -0xc0
	ctx.r[12].s64 = -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82850D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82850D40 size=784
    let mut pc: u32 = 0x82850D40;
    'dispatch: loop {
        match pc {
            0x82850D40 => {
    //   block [0x82850D40..0x82850D7C)
	// 82850D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82850D44: 484586C1  bl 0x82ca9404
	ctx.lr = 0x82850D48;
	sub_82CA93D0(ctx, base);
	// 82850D48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82850D4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82850D50: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82850D54: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82850D58: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 82850D5C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82850D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82850D64: 419A001C  beq cr6, 0x82850d80
	if ctx.cr[6].eq {
	pc = 0x82850D80; continue 'dispatch;
	}
	// 82850D68: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82850D6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82850D70: 419A000C  beq cr6, 0x82850d7c
	if ctx.cr[6].eq {
	pc = 0x82850D7C; continue 'dispatch;
	}
	// 82850D74: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82850D78: 4800000C  b 0x82850d84
	pc = 0x82850D84; continue 'dispatch;
            }
            0x82850D7C => {
    //   block [0x82850D7C..0x82850D80)
	// 82850D7C: 4B9430BD  bl 0x82193e38
	ctx.lr = 0x82850D80;
	sub_82193E38(ctx, base);
	pc = 0x82850D80; continue 'dispatch;
            }
            0x82850D80 => {
    //   block [0x82850D80..0x82850D84)
	// 82850D80: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82850D84; continue 'dispatch;
            }
            0x82850D84 => {
    //   block [0x82850D84..0x82850DC0)
	// 82850D84: 894B0024  lbz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82850D88: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82850D8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82850D90: 419A00F4  beq cr6, 0x82850e84
	if ctx.cr[6].eq {
	pc = 0x82850E84; continue 'dispatch;
	}
	// 82850D94: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82850D98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82850D9C: 419A0024  beq cr6, 0x82850dc0
	if ctx.cr[6].eq {
	pc = 0x82850DC0; continue 'dispatch;
	}
	// 82850DA0: 894A0018  lbz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82850DA4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82850DA8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82850DAC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82850DB0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82850DB4: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82850DB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82850DBC: 480000CC  b 0x82850e88
	pc = 0x82850E88; continue 'dispatch;
            }
            0x82850DC0 => {
    //   block [0x82850DC0..0x82850DDC)
	// 82850DC0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82850DC4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82850DC8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82850DCC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82850DD0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82850DD4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82850DD8: 40810054  ble 0x82850e2c
	if !ctx.cr[0].gt {
	pc = 0x82850E2C; continue 'dispatch;
	}
	pc = 0x82850DDC; continue 'dispatch;
            }
            0x82850DDC => {
    //   block [0x82850DDC..0x82850DFC)
	// 82850DDC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82850DE0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82850DE4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82850DE8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82850DEC: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 82850DF0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82850DF4: 41980008  blt cr6, 0x82850dfc
	if ctx.cr[6].lt {
	pc = 0x82850DFC; continue 'dispatch;
	}
	// 82850DF8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x82850DFC; continue 'dispatch;
            }
            0x82850DFC => {
    //   block [0x82850DFC..0x82850E18)
	// 82850DFC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82850E00: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82850E04: 419A0014  beq cr6, 0x82850e18
	if ctx.cr[6].eq {
	pc = 0x82850E18; continue 'dispatch;
	}
	// 82850E08: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82850E0C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82850E10: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82850E14: 4800000C  b 0x82850e20
	pc = 0x82850E20; continue 'dispatch;
            }
            0x82850E18 => {
    //   block [0x82850E18..0x82850E20)
	// 82850E18: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82850E1C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82850E20; continue 'dispatch;
            }
            0x82850E20 => {
    //   block [0x82850E20..0x82850E2C)
	// 82850E20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82850E24: 4199FFB8  bgt cr6, 0x82850ddc
	if ctx.cr[6].gt {
	pc = 0x82850DDC; continue 'dispatch;
	}
	// 82850E28: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82850E2C; continue 'dispatch;
            }
            0x82850E2C => {
    //   block [0x82850E2C..0x82850E48)
	// 82850E2C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82850E30: 419A0040  beq cr6, 0x82850e70
	if ctx.cr[6].eq {
	pc = 0x82850E70; continue 'dispatch;
	}
	// 82850E34: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82850E38: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 82850E3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82850E40: 41990008  bgt cr6, 0x82850e48
	if ctx.cr[6].gt {
	pc = 0x82850E48; continue 'dispatch;
	}
	// 82850E44: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82850E48; continue 'dispatch;
            }
            0x82850E48 => {
    //   block [0x82850E48..0x82850E70)
	// 82850E48: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82850E4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82850E50: 409A0020  bne cr6, 0x82850e70
	if !ctx.cr[6].eq {
	pc = 0x82850E70; continue 'dispatch;
	}
	// 82850E54: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82850E58: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82850E5C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82850E60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82850E64: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82850E68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82850E6C: 4800001C  b 0x82850e88
	pc = 0x82850E88; continue 'dispatch;
            }
            0x82850E70 => {
    //   block [0x82850E70..0x82850E84)
	// 82850E70: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82850E74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82850E78: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82850E7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82850E80: 48000008  b 0x82850e88
	pc = 0x82850E88; continue 'dispatch;
            }
            0x82850E84 => {
    //   block [0x82850E84..0x82850E88)
	// 82850E84: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82850E88; continue 'dispatch;
            }
            0x82850E88 => {
    //   block [0x82850E88..0x82850EDC)
	// 82850E88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82850E8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82850E90: 419A01B8  beq cr6, 0x82851048
	if ctx.cr[6].eq {
	pc = 0x82851048; continue 'dispatch;
	}
	// 82850E94: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82850E98: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82850E9C: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82850EA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82850EA4: 3BCBB780  addi r30, r11, -0x4880
	ctx.r[30].s64 = ctx.r[11].s64 + -18560;
	// 82850EA8: 419A0054  beq cr6, 0x82850efc
	if ctx.cr[6].eq {
	pc = 0x82850EFC; continue 'dispatch;
	}
	// 82850EAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82850EB0: 4BB5FB89  bl 0x823b0a38
	ctx.lr = 0x82850EB4;
	sub_823B0A38(ctx, base);
	// 82850EB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82850EB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82850EBC: 4BCAA62D  bl 0x824fb4e8
	ctx.lr = 0x82850EC0;
	sub_824FB4E8(ctx, base);
	// 82850EC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82850EC4: 419A0018  beq cr6, 0x82850edc
	if ctx.cr[6].eq {
	pc = 0x82850EDC; continue 'dispatch;
	}
	// 82850EC8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 82850ECC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82850ED0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82850ED4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82850ED8: 409A0008  bne cr6, 0x82850ee0
	if !ctx.cr[6].eq {
	pc = 0x82850EE0; continue 'dispatch;
	}
	pc = 0x82850EDC; continue 'dispatch;
            }
            0x82850EDC => {
    //   block [0x82850EDC..0x82850EE0)
	// 82850EDC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82850EE0; continue 'dispatch;
            }
            0x82850EE0 => {
    //   block [0x82850EE0..0x82850EFC)
	// 82850EE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82850EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82850EE8: 419A0118  beq cr6, 0x82851000
	if ctx.cr[6].eq {
	pc = 0x82851000; continue 'dispatch;
	}
	// 82850EEC: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82850EF0: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 82850EF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82850EF8: 48000100  b 0x82850ff8
	pc = 0x82850FF8; continue 'dispatch;
            }
            0x82850EFC => {
    //   block [0x82850EFC..0x82850F5C)
	// 82850EFC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82850F00: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82850F04: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82850F08: 38EBE9C4  addi r7, r11, -0x163c
	ctx.r[7].s64 = ctx.r[11].s64 + -5692;
	// 82850F0C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82850F10: 4B9615E9  bl 0x821b24f8
	ctx.lr = 0x82850F14;
	sub_821B24F8(ctx, base);
	// 82850F14: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82850F18: 4BB82E91  bl 0x823d3da8
	ctx.lr = 0x82850F1C;
	sub_823D3DA8(ctx, base);
	// 82850F1C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82850F20: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82850F24: 409A0054  bne cr6, 0x82850f78
	if !ctx.cr[6].eq {
	pc = 0x82850F78; continue 'dispatch;
	}
	// 82850F28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82850F2C: 4BB5FB0D  bl 0x823b0a38
	ctx.lr = 0x82850F30;
	sub_823B0A38(ctx, base);
	// 82850F30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82850F34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82850F38: 4BCAA5B1  bl 0x824fb4e8
	ctx.lr = 0x82850F3C;
	sub_824FB4E8(ctx, base);
	// 82850F3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82850F40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82850F44: 419A0018  beq cr6, 0x82850f5c
	if ctx.cr[6].eq {
	pc = 0x82850F5C; continue 'dispatch;
	}
	// 82850F48: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82850F4C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82850F50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82850F54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82850F58: 409A0008  bne cr6, 0x82850f60
	if !ctx.cr[6].eq {
	pc = 0x82850F60; continue 'dispatch;
	}
	pc = 0x82850F5C; continue 'dispatch;
            }
            0x82850F5C => {
    //   block [0x82850F5C..0x82850F60)
	// 82850F5C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82850F60; continue 'dispatch;
            }
            0x82850F60 => {
    //   block [0x82850F60..0x82850F78)
	// 82850F60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82850F64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82850F68: 419A0098  beq cr6, 0x82851000
	if ctx.cr[6].eq {
	pc = 0x82851000; continue 'dispatch;
	}
	// 82850F6C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82850F70: 388BE9AC  addi r4, r11, -0x1654
	ctx.r[4].s64 = ctx.r[11].s64 + -5716;
	// 82850F74: 48000058  b 0x82850fcc
	pc = 0x82850FCC; continue 'dispatch;
            }
            0x82850F78 => {
    //   block [0x82850F78..0x82850FB4)
	// 82850F78: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 82850F7C: 409A0084  bne cr6, 0x82851000
	if !ctx.cr[6].eq {
	pc = 0x82851000; continue 'dispatch;
	}
	// 82850F80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82850F84: 4BB5FAB5  bl 0x823b0a38
	ctx.lr = 0x82850F88;
	sub_823B0A38(ctx, base);
	// 82850F88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82850F8C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82850F90: 4BCAA559  bl 0x824fb4e8
	ctx.lr = 0x82850F94;
	sub_824FB4E8(ctx, base);
	// 82850F94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82850F98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82850F9C: 419A0018  beq cr6, 0x82850fb4
	if ctx.cr[6].eq {
	pc = 0x82850FB4; continue 'dispatch;
	}
	// 82850FA0: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82850FA4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82850FA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82850FAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82850FB0: 409A0008  bne cr6, 0x82850fb8
	if !ctx.cr[6].eq {
	pc = 0x82850FB8; continue 'dispatch;
	}
	pc = 0x82850FB4; continue 'dispatch;
            }
            0x82850FB4 => {
    //   block [0x82850FB4..0x82850FB8)
	// 82850FB4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82850FB8; continue 'dispatch;
            }
            0x82850FB8 => {
    //   block [0x82850FB8..0x82850FCC)
	// 82850FB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82850FBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82850FC0: 419A0040  beq cr6, 0x82851000
	if ctx.cr[6].eq {
	pc = 0x82851000; continue 'dispatch;
	}
	// 82850FC4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82850FC8: 388BE250  addi r4, r11, -0x1db0
	ctx.r[4].s64 = ctx.r[11].s64 + -7600;
	pc = 0x82850FCC; continue 'dispatch;
            }
            0x82850FCC => {
    //   block [0x82850FCC..0x82850FF8)
	// 82850FCC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82850FD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82850FD4: 4B9DBEFD  bl 0x8222ced0
	ctx.lr = 0x82850FD8;
	sub_8222CED0(ctx, base);
	// 82850FD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82850FDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82850FE0: 4B94B609  bl 0x8219c5e8
	ctx.lr = 0x82850FE4;
	sub_8219C5E8(ctx, base);
	// 82850FE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82850FE8: 4B9C3DF1  bl 0x82214dd8
	ctx.lr = 0x82850FEC;
	sub_82214DD8(ctx, base);
	// 82850FEC: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82850FF0: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82850FF4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	pc = 0x82850FF8; continue 'dispatch;
            }
            0x82850FF8 => {
    //   block [0x82850FF8..0x82851000)
	// 82850FF8: 409A0008  bne cr6, 0x82851000
	if !ctx.cr[6].eq {
	pc = 0x82851000; continue 'dispatch;
	}
	// 82850FFC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	pc = 0x82851000; continue 'dispatch;
            }
            0x82851000 => {
    //   block [0x82851000..0x82851034)
	// 82851000: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82851004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82851008: 419A0040  beq cr6, 0x82851048
	if ctx.cr[6].eq {
	pc = 0x82851048; continue 'dispatch;
	}
	// 8285100C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82851010: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82851014: 4BCABB0D  bl 0x824fcb20
	ctx.lr = 0x82851018;
	sub_824FCB20(ctx, base);
	// 82851018: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285101C: 419A0018  beq cr6, 0x82851034
	if ctx.cr[6].eq {
	pc = 0x82851034; continue 'dispatch;
	}
	// 82851020: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 82851024: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82851028: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285102C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82851030: 409A0008  bne cr6, 0x82851038
	if !ctx.cr[6].eq {
	pc = 0x82851038; continue 'dispatch;
	}
	pc = 0x82851034; continue 'dispatch;
            }
            0x82851034 => {
    //   block [0x82851034..0x82851038)
	// 82851034: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82851038; continue 'dispatch;
            }
            0x82851038 => {
    //   block [0x82851038..0x82851048)
	// 82851038: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285103C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82851040: 419A0008  beq cr6, 0x82851048
	if ctx.cr[6].eq {
	pc = 0x82851048; continue 'dispatch;
	}
	// 82851044: 4BB3C7E5  bl 0x8238d828
	ctx.lr = 0x82851048;
	sub_8238D828(ctx, base);
	pc = 0x82851048; continue 'dispatch;
            }
            0x82851048 => {
    //   block [0x82851048..0x82851050)
	// 82851048: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8285104C: 48458408  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82851050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82851050 size=6272
    let mut pc: u32 = 0x82851050;
    'dispatch: loop {
        match pc {
            0x82851050 => {
    //   block [0x82851050..0x828528D0)
	// 82851050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82851054: 4845839D  bl 0x82ca93f0
	ctx.lr = 0x82851058;
	sub_82CA93D0(ctx, base);
	// 82851058: DBA1FF90  stfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[29].u64 ) };
	// 8285105C: DBC1FF98  stfd f30, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 82851060: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82851064: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828528D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828528D0 size=720
    let mut pc: u32 = 0x828528D0;
    'dispatch: loop {
        match pc {
            0x828528D0 => {
    //   block [0x828528D0..0x8285294C)
	// 828528D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828528D4: 48456B39  bl 0x82ca940c
	ctx.lr = 0x828528D8;
	sub_82CA93D0(ctx, base);
	// 828528D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828528DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828528E0: 387D0080  addi r3, r29, 0x80
	ctx.r[3].s64 = ctx.r[29].s64 + 128;
	// 828528E4: 4B95FC15  bl 0x821b24f8
	ctx.lr = 0x828528E8;
	sub_821B24F8(ctx, base);
	// 828528E8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828528EC: 388BEDB4  addi r4, r11, -0x124c
	ctx.r[4].s64 = ctx.r[11].s64 + -4684;
	// 828528F0: 4BABD9A1  bl 0x82310290
	ctx.lr = 0x828528F4;
	sub_82310290(ctx, base);
	// 828528F4: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828528F8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828528FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82852900: 419A0128  beq cr6, 0x82852a28
	if ctx.cr[6].eq {
	pc = 0x82852A28; continue 'dispatch;
	}
	// 82852904: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82852908: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 8285290C: 4B921B5D  bl 0x82174468
	ctx.lr = 0x82852910;
	sub_82174468(ctx, base);
	// 82852910: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82852914: 556A77FE  rlwinm r10, r11, 0xe, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0003FFFFu64;
	// 82852918: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285291C: 419A00F4  beq cr6, 0x82852a10
	if ctx.cr[6].eq {
	pc = 0x82852A10; continue 'dispatch;
	}
	// 82852920: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 82852924: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852928: 419A0024  beq cr6, 0x8285294c
	if ctx.cr[6].eq {
	pc = 0x8285294C; continue 'dispatch;
	}
	// 8285292C: 894B0012  lbz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82852930: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82852934: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82852938: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285293C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82852940: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82852944: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82852948: 480000CC  b 0x82852a14
	pc = 0x82852A14; continue 'dispatch;
            }
            0x8285294C => {
    //   block [0x8285294C..0x82852968)
	// 8285294C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82852950: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 82852954: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82852958: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285295C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82852960: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82852964: 40810054  ble 0x828529b8
	if !ctx.cr[0].gt {
	pc = 0x828529B8; continue 'dispatch;
	}
	pc = 0x82852968; continue 'dispatch;
            }
            0x82852968 => {
    //   block [0x82852968..0x82852988)
	// 82852968: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285296C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82852970: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82852974: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82852978: 2F070012  cmpwi cr6, r7, 0x12
	ctx.cr[6].compare_i32(ctx.r[7].s32, 18, &mut ctx.xer);
	// 8285297C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82852980: 41980008  blt cr6, 0x82852988
	if ctx.cr[6].lt {
	pc = 0x82852988; continue 'dispatch;
	}
	// 82852984: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82852988; continue 'dispatch;
            }
            0x82852988 => {
    //   block [0x82852988..0x828529A4)
	// 82852988: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285298C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82852990: 419A0014  beq cr6, 0x828529a4
	if ctx.cr[6].eq {
	pc = 0x828529A4; continue 'dispatch;
	}
	// 82852994: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82852998: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285299C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828529A0: 4800000C  b 0x828529ac
	pc = 0x828529AC; continue 'dispatch;
            }
            0x828529A4 => {
    //   block [0x828529A4..0x828529AC)
	// 828529A4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828529A8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828529AC; continue 'dispatch;
            }
            0x828529AC => {
    //   block [0x828529AC..0x828529B8)
	// 828529AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828529B0: 4199FFB8  bgt cr6, 0x82852968
	if ctx.cr[6].gt {
	pc = 0x82852968; continue 'dispatch;
	}
	// 828529B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828529B8; continue 'dispatch;
            }
            0x828529B8 => {
    //   block [0x828529B8..0x828529D4)
	// 828529B8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828529BC: 419A0040  beq cr6, 0x828529fc
	if ctx.cr[6].eq {
	pc = 0x828529FC; continue 'dispatch;
	}
	// 828529C0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828529C4: 2F0B0012  cmpwi cr6, r11, 0x12
	ctx.cr[6].compare_i32(ctx.r[11].s32, 18, &mut ctx.xer);
	// 828529C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828529CC: 41990008  bgt cr6, 0x828529d4
	if ctx.cr[6].gt {
	pc = 0x828529D4; continue 'dispatch;
	}
	// 828529D0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828529D4; continue 'dispatch;
            }
            0x828529D4 => {
    //   block [0x828529D4..0x828529FC)
	// 828529D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828529D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828529DC: 409A0020  bne cr6, 0x828529fc
	if !ctx.cr[6].eq {
	pc = 0x828529FC; continue 'dispatch;
	}
	// 828529E0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828529E4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828529E8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828529EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828529F0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828529F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828529F8: 4800001C  b 0x82852a14
	pc = 0x82852A14; continue 'dispatch;
            }
            0x828529FC => {
    //   block [0x828529FC..0x82852A10)
	// 828529FC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82852A00: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82852A04: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82852A08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82852A0C: 48000008  b 0x82852a14
	pc = 0x82852A14; continue 'dispatch;
            }
            0x82852A10 => {
    //   block [0x82852A10..0x82852A14)
	// 82852A10: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82852A14; continue 'dispatch;
            }
            0x82852A14 => {
    //   block [0x82852A14..0x82852A28)
	// 82852A14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82852A18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852A1C: 419A000C  beq cr6, 0x82852a28
	if ctx.cr[6].eq {
	pc = 0x82852A28; continue 'dispatch;
	}
	// 82852A20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82852A24: 997F0034  stb r11, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	pc = 0x82852A28; continue 'dispatch;
            }
            0x82852A28 => {
    //   block [0x82852A28..0x82852A50)
	// 82852A28: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82852A2C: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 82852A30: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82852A34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852A38: 419A001C  beq cr6, 0x82852a54
	if ctx.cr[6].eq {
	pc = 0x82852A54; continue 'dispatch;
	}
	// 82852A3C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82852A40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82852A44: 419A000C  beq cr6, 0x82852a50
	if ctx.cr[6].eq {
	pc = 0x82852A50; continue 'dispatch;
	}
	// 82852A48: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82852A4C: 4800000C  b 0x82852a58
	pc = 0x82852A58; continue 'dispatch;
            }
            0x82852A50 => {
    //   block [0x82852A50..0x82852A54)
	// 82852A50: 4B9413E9  bl 0x82193e38
	ctx.lr = 0x82852A54;
	sub_82193E38(ctx, base);
	pc = 0x82852A54; continue 'dispatch;
            }
            0x82852A54 => {
    //   block [0x82852A54..0x82852A58)
	// 82852A54: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82852A58; continue 'dispatch;
            }
            0x82852A58 => {
    //   block [0x82852A58..0x82852A94)
	// 82852A58: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82852A5C: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 82852A60: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82852A64: 419A00F4  beq cr6, 0x82852b58
	if ctx.cr[6].eq {
	pc = 0x82852B58; continue 'dispatch;
	}
	// 82852A68: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82852A6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82852A70: 419A0024  beq cr6, 0x82852a94
	if ctx.cr[6].eq {
	pc = 0x82852A94; continue 'dispatch;
	}
	// 82852A74: 892A009A  lbz r9, 0x9a(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(154 as u32) ) } as u64;
	// 82852A78: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82852A7C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82852A80: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82852A84: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82852A88: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82852A8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82852A90: 480000CC  b 0x82852b5c
	pc = 0x82852B5C; continue 'dispatch;
            }
            0x82852A94 => {
    //   block [0x82852A94..0x82852AB0)
	// 82852A94: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82852A98: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82852A9C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82852AA0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82852AA4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82852AA8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82852AAC: 40810054  ble 0x82852b00
	if !ctx.cr[0].gt {
	pc = 0x82852B00; continue 'dispatch;
	}
	pc = 0x82852AB0; continue 'dispatch;
            }
            0x82852AB0 => {
    //   block [0x82852AB0..0x82852AD0)
	// 82852AB0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82852AB4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82852AB8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82852ABC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82852AC0: 2F07009A  cmpwi cr6, r7, 0x9a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 154, &mut ctx.xer);
	// 82852AC4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82852AC8: 41980008  blt cr6, 0x82852ad0
	if ctx.cr[6].lt {
	pc = 0x82852AD0; continue 'dispatch;
	}
	// 82852ACC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82852AD0; continue 'dispatch;
            }
            0x82852AD0 => {
    //   block [0x82852AD0..0x82852AEC)
	// 82852AD0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82852AD4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82852AD8: 419A0014  beq cr6, 0x82852aec
	if ctx.cr[6].eq {
	pc = 0x82852AEC; continue 'dispatch;
	}
	// 82852ADC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82852AE0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82852AE4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82852AE8: 4800000C  b 0x82852af4
	pc = 0x82852AF4; continue 'dispatch;
            }
            0x82852AEC => {
    //   block [0x82852AEC..0x82852AF4)
	// 82852AEC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82852AF0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82852AF4; continue 'dispatch;
            }
            0x82852AF4 => {
    //   block [0x82852AF4..0x82852B00)
	// 82852AF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82852AF8: 4199FFB8  bgt cr6, 0x82852ab0
	if ctx.cr[6].gt {
	pc = 0x82852AB0; continue 'dispatch;
	}
	// 82852AFC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82852B00; continue 'dispatch;
            }
            0x82852B00 => {
    //   block [0x82852B00..0x82852B1C)
	// 82852B00: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82852B04: 419A0040  beq cr6, 0x82852b44
	if ctx.cr[6].eq {
	pc = 0x82852B44; continue 'dispatch;
	}
	// 82852B08: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82852B0C: 2F0B009A  cmpwi cr6, r11, 0x9a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 154, &mut ctx.xer);
	// 82852B10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82852B14: 41990008  bgt cr6, 0x82852b1c
	if ctx.cr[6].gt {
	pc = 0x82852B1C; continue 'dispatch;
	}
	// 82852B18: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82852B1C; continue 'dispatch;
            }
            0x82852B1C => {
    //   block [0x82852B1C..0x82852B44)
	// 82852B1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82852B20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852B24: 409A0020  bne cr6, 0x82852b44
	if !ctx.cr[6].eq {
	pc = 0x82852B44; continue 'dispatch;
	}
	// 82852B28: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82852B2C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82852B30: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82852B34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82852B38: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82852B3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82852B40: 4800001C  b 0x82852b5c
	pc = 0x82852B5C; continue 'dispatch;
            }
            0x82852B44 => {
    //   block [0x82852B44..0x82852B58)
	// 82852B44: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82852B48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82852B4C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82852B50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82852B54: 48000008  b 0x82852b5c
	pc = 0x82852B5C; continue 'dispatch;
            }
            0x82852B58 => {
    //   block [0x82852B58..0x82852B5C)
	// 82852B58: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82852B5C; continue 'dispatch;
            }
            0x82852B5C => {
    //   block [0x82852B5C..0x82852B70)
	// 82852B5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82852B60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852B64: 419A000C  beq cr6, 0x82852b70
	if ctx.cr[6].eq {
	pc = 0x82852B70; continue 'dispatch;
	}
	// 82852B68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82852B6C: 4BBC1EE5  bl 0x82414a50
	ctx.lr = 0x82852B70;
	sub_82414A50(ctx, base);
	pc = 0x82852B70; continue 'dispatch;
            }
            0x82852B70 => {
    //   block [0x82852B70..0x82852B98)
	// 82852B70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82852B74: 4BFFE1CD  bl 0x82850d40
	ctx.lr = 0x82852B78;
	sub_82850D40(ctx, base);
	// 82852B78: 807D0078  lwz r3, 0x78(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(120 as u32) ) } as u64;
	// 82852B7C: 3BFD0078  addi r31, r29, 0x78
	ctx.r[31].s64 = ctx.r[29].s64 + 120;
	// 82852B80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82852B84: 419A0014  beq cr6, 0x82852b98
	if ctx.cr[6].eq {
	pc = 0x82852B98; continue 'dispatch;
	}
	// 82852B88: 4BA33621  bl 0x822861a8
	ctx.lr = 0x82852B8C;
	sub_822861A8(ctx, base);
	// 82852B8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82852B90: 4B964F89  bl 0x821b7b18
	ctx.lr = 0x82852B94;
	sub_821B7B18(ctx, base);
	// 82852B94: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82852B98; continue 'dispatch;
            }
            0x82852B98 => {
    //   block [0x82852B98..0x82852BA0)
	// 82852B98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82852B9C: 484568C0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82852BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82852BA0 size=752
    let mut pc: u32 = 0x82852BA0;
    'dispatch: loop {
        match pc {
            0x82852BA0 => {
    //   block [0x82852BA0..0x82852C14)
	// 82852BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82852BA4: 48456861  bl 0x82ca9404
	ctx.lr = 0x82852BA8;
	sub_82CA93D0(ctx, base);
	// 82852BA8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82852BAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82852BB0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82852BB4: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82852BB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82852BBC: 409A01F4  bne cr6, 0x82852db0
	if !ctx.cr[6].eq {
	pc = 0x82852DB0; continue 'dispatch;
	}
	// 82852BC0: 817E0078  lwz r11, 0x78(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) } as u64;
	// 82852BC4: 815E0070  lwz r10, 0x70(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 82852BC8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82852BCC: 419A01E4  beq cr6, 0x82852db0
	if ctx.cr[6].eq {
	pc = 0x82852DB0; continue 'dispatch;
	}
	// 82852BD0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82852BD4: 4B921895  bl 0x82174468
	ctx.lr = 0x82852BD8;
	sub_82174468(ctx, base);
	// 82852BD8: 81630034  lwz r11, 0x34(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82852BDC: 556ACFFE  rlwinm r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 82852BE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82852BE4: 419A00F8  beq cr6, 0x82852cdc
	if ctx.cr[6].eq {
	pc = 0x82852CDC; continue 'dispatch;
	}
	// 82852BE8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 82852BEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852BF0: 419A0024  beq cr6, 0x82852c14
	if ctx.cr[6].eq {
	pc = 0x82852C14; continue 'dispatch;
	}
	// 82852BF4: 894B0087  lbz r10, 0x87(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(135 as u32) ) } as u64;
	// 82852BF8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82852BFC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82852C00: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82852C04: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82852C08: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82852C0C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82852C10: 480000D0  b 0x82852ce0
	pc = 0x82852CE0; continue 'dispatch;
            }
            0x82852C14 => {
    //   block [0x82852C14..0x82852C34)
	// 82852C14: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82852C18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82852C1C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 82852C20: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82852C24: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82852C28: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82852C2C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82852C30: 40810054  ble 0x82852c84
	if !ctx.cr[0].gt {
	pc = 0x82852C84; continue 'dispatch;
	}
	pc = 0x82852C34; continue 'dispatch;
            }
            0x82852C34 => {
    //   block [0x82852C34..0x82852C54)
	// 82852C34: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82852C38: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82852C3C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82852C40: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82852C44: 2F070087  cmpwi cr6, r7, 0x87
	ctx.cr[6].compare_i32(ctx.r[7].s32, 135, &mut ctx.xer);
	// 82852C48: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82852C4C: 41980008  blt cr6, 0x82852c54
	if ctx.cr[6].lt {
	pc = 0x82852C54; continue 'dispatch;
	}
	// 82852C50: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82852C54; continue 'dispatch;
            }
            0x82852C54 => {
    //   block [0x82852C54..0x82852C70)
	// 82852C54: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82852C58: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82852C5C: 419A0014  beq cr6, 0x82852c70
	if ctx.cr[6].eq {
	pc = 0x82852C70; continue 'dispatch;
	}
	// 82852C60: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82852C64: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82852C68: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82852C6C: 4800000C  b 0x82852c78
	pc = 0x82852C78; continue 'dispatch;
            }
            0x82852C70 => {
    //   block [0x82852C70..0x82852C78)
	// 82852C70: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82852C74: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82852C78; continue 'dispatch;
            }
            0x82852C78 => {
    //   block [0x82852C78..0x82852C84)
	// 82852C78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82852C7C: 4199FFB8  bgt cr6, 0x82852c34
	if ctx.cr[6].gt {
	pc = 0x82852C34; continue 'dispatch;
	}
	// 82852C80: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x82852C84; continue 'dispatch;
            }
            0x82852C84 => {
    //   block [0x82852C84..0x82852CA0)
	// 82852C84: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82852C88: 419A0040  beq cr6, 0x82852cc8
	if ctx.cr[6].eq {
	pc = 0x82852CC8; continue 'dispatch;
	}
	// 82852C8C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82852C90: 2F0B0087  cmpwi cr6, r11, 0x87
	ctx.cr[6].compare_i32(ctx.r[11].s32, 135, &mut ctx.xer);
	// 82852C94: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82852C98: 41990008  bgt cr6, 0x82852ca0
	if ctx.cr[6].gt {
	pc = 0x82852CA0; continue 'dispatch;
	}
	// 82852C9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82852CA0; continue 'dispatch;
            }
            0x82852CA0 => {
    //   block [0x82852CA0..0x82852CC8)
	// 82852CA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82852CA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852CA8: 409A0020  bne cr6, 0x82852cc8
	if !ctx.cr[6].eq {
	pc = 0x82852CC8; continue 'dispatch;
	}
	// 82852CAC: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82852CB0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82852CB4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82852CB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82852CBC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82852CC0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82852CC4: 4800001C  b 0x82852ce0
	pc = 0x82852CE0; continue 'dispatch;
            }
            0x82852CC8 => {
    //   block [0x82852CC8..0x82852CDC)
	// 82852CC8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82852CCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82852CD0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82852CD4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82852CD8: 48000008  b 0x82852ce0
	pc = 0x82852CE0; continue 'dispatch;
            }
            0x82852CDC => {
    //   block [0x82852CDC..0x82852CE0)
	// 82852CDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82852CE0; continue 'dispatch;
            }
            0x82852CE0 => {
    //   block [0x82852CE0..0x82852DA8)
	// 82852CE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82852CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852CE8: 419A00C8  beq cr6, 0x82852db0
	if ctx.cr[6].eq {
	pc = 0x82852DB0; continue 'dispatch;
	}
	// 82852CEC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82852CF0: 387E0080  addi r3, r30, 0x80
	ctx.r[3].s64 = ctx.r[30].s64 + 128;
	// 82852CF4: 38EBEE44  addi r7, r11, -0x11bc
	ctx.r[7].s64 = ctx.r[11].s64 + -4540;
	// 82852CF8: 4B95F801  bl 0x821b24f8
	ctx.lr = 0x82852CFC;
	sub_821B24F8(ctx, base);
	// 82852CFC: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82852D00: 4BAD0841  bl 0x82323540
	ctx.lr = 0x82852D04;
	sub_82323540(ctx, base);
	// 82852D04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82852D08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82852D0C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82852D10: 4B9DA1C1  bl 0x8222ced0
	ctx.lr = 0x82852D14;
	sub_8222CED0(ctx, base);
	// 82852D14: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82852D18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852D1C: 419A008C  beq cr6, 0x82852da8
	if ctx.cr[6].eq {
	pc = 0x82852DA8; continue 'dispatch;
	}
	// 82852D20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82852D24: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82852D28: 40990080  ble cr6, 0x82852da8
	if !ctx.cr[6].gt {
	pc = 0x82852DA8; continue 'dispatch;
	}
	// 82852D2C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82852D30: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82852D34: 388BEDC8  addi r4, r11, -0x1238
	ctx.r[4].s64 = ctx.r[11].s64 + -4664;
	// 82852D38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82852D3C: 4B9DA195  bl 0x8222ced0
	ctx.lr = 0x82852D40;
	sub_8222CED0(ctx, base);
	// 82852D40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82852D44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82852D48: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82852D4C: 48000145  bl 0x82852e90
	ctx.lr = 0x82852D50;
	sub_82852E90(ctx, base);
	// 82852D50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82852D54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82852D58: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82852D5C: 4B9903AD  bl 0x821e3108
	ctx.lr = 0x82852D60;
	sub_821E3108(ctx, base);
	// 82852D60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82852D64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82852D68: 4BA14441  bl 0x822671a8
	ctx.lr = 0x82852D6C;
	sub_822671A8(ctx, base);
	// 82852D6C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82852D70: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82852D74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82852D78: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82852D7C: 4BBDEB8D  bl 0x82431908
	ctx.lr = 0x82852D80;
	sub_82431908(ctx, base);
	// 82852D80: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82852D84: 483B3175  bl 0x82c05ef8
	ctx.lr = 0x82852D88;
	sub_82C05EF8(ctx, base);
	// 82852D88: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82852D8C: 4BA36CBD  bl 0x82289a48
	ctx.lr = 0x82852D90;
	sub_82289A48(ctx, base);
	// 82852D90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82852D94: 4B9C2045  bl 0x82214dd8
	ctx.lr = 0x82852D98;
	sub_82214DD8(ctx, base);
	// 82852D98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82852D9C: 4B9C203D  bl 0x82214dd8
	ctx.lr = 0x82852DA0;
	sub_82214DD8(ctx, base);
	// 82852DA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82852DA4: 4B9C2035  bl 0x82214dd8
	ctx.lr = 0x82852DA8;
	sub_82214DD8(ctx, base);
	pc = 0x82852DA8; continue 'dispatch;
            }
            0x82852DA8 => {
    //   block [0x82852DA8..0x82852DB0)
	// 82852DA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82852DAC: 4B9C202D  bl 0x82214dd8
	ctx.lr = 0x82852DB0;
	sub_82214DD8(ctx, base);
	pc = 0x82852DB0; continue 'dispatch;
            }
            0x82852DB0 => {
    //   block [0x82852DB0..0x82852DE4)
	// 82852DB0: 897E0095  lbz r11, 0x95(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(149 as u32) ) } as u64;
	// 82852DB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852DB8: 409A00D0  bne cr6, 0x82852e88
	if !ctx.cr[6].eq {
	pc = 0x82852E88; continue 'dispatch;
	}
	// 82852DBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82852DC0: 4BA4C0B9  bl 0x8229ee78
	ctx.lr = 0x82852DC4;
	sub_8229EE78(ctx, base);
	// 82852DC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82852DC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82852DCC: 419A0018  beq cr6, 0x82852de4
	if ctx.cr[6].eq {
	pc = 0x82852DE4; continue 'dispatch;
	}
	// 82852DD0: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82852DD4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82852DD8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82852DDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82852DE0: 409A0008  bne cr6, 0x82852de8
	if !ctx.cr[6].eq {
	pc = 0x82852DE8; continue 'dispatch;
	}
	pc = 0x82852DE4; continue 'dispatch;
            }
            0x82852DE4 => {
    //   block [0x82852DE4..0x82852DE8)
	// 82852DE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82852DE8; continue 'dispatch;
            }
            0x82852DE8 => {
    //   block [0x82852DE8..0x82852E2C)
	// 82852DE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82852DEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852DF0: 419A003C  beq cr6, 0x82852e2c
	if ctx.cr[6].eq {
	pc = 0x82852E2C; continue 'dispatch;
	}
	// 82852DF4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82852DF8: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82852DFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82852E00: 419A002C  beq cr6, 0x82852e2c
	if ctx.cr[6].eq {
	pc = 0x82852E2C; continue 'dispatch;
	}
	// 82852E04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82852E08: 8B9E004B  lbz r28, 0x4b(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(75 as u32) ) } as u64;
	// 82852E0C: 4B92165D  bl 0x82174468
	ctx.lr = 0x82852E10;
	sub_82174468(ctx, base);
	// 82852E10: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82852E14: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82852E18: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 82852E1C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82852E20: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82852E24: C02A000C  lfs f1, 0xc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82852E28: 48000048  b 0x82852e70
	pc = 0x82852E70; continue 'dispatch;
            }
            0x82852E2C => {
    //   block [0x82852E2C..0x82852E4C)
	// 82852E2C: 815E0078  lwz r10, 0x78(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) } as u64;
	// 82852E30: 817E0070  lwz r11, 0x70(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 82852E34: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82852E38: 419A0014  beq cr6, 0x82852e4c
	if ctx.cr[6].eq {
	pc = 0x82852E4C; continue 'dispatch;
	}
	// 82852E3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852E40: 419A000C  beq cr6, 0x82852e4c
	if ctx.cr[6].eq {
	pc = 0x82852E4C; continue 'dispatch;
	}
	// 82852E44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82852E48: 409A0040  bne cr6, 0x82852e88
	if !ctx.cr[6].eq {
	pc = 0x82852E88; continue 'dispatch;
	}
	pc = 0x82852E4C; continue 'dispatch;
            }
            0x82852E4C => {
    //   block [0x82852E4C..0x82852E70)
	// 82852E4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82852E50: 8B9E004B  lbz r28, 0x4b(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(75 as u32) ) } as u64;
	// 82852E54: 837E0088  lwz r27, 0x88(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 82852E58: 4B921611  bl 0x82174468
	ctx.lr = 0x82852E5C;
	sub_82174468(ctx, base);
	// 82852E5C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82852E60: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82852E64: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82852E68: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82852E6C: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x82852E70; continue 'dispatch;
            }
            0x82852E70 => {
    //   block [0x82852E70..0x82852E88)
	// 82852E70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82852E74: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82852E78: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82852E7C: 387E0080  addi r3, r30, 0x80
	ctx.r[3].s64 = ctx.r[30].s64 + 128;
	// 82852E80: 4BFFB541  bl 0x8284e3c0
	ctx.lr = 0x82852E84;
	sub_8284E3C0(ctx, base);
	// 82852E84: 9BBE0095  stb r29, 0x95(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(149 as u32), ctx.r[29].u8 ) };
	pc = 0x82852E88; continue 'dispatch;
            }
            0x82852E88 => {
    //   block [0x82852E88..0x82852E90)
	// 82852E88: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82852E8C: 484565C8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82852E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82852E90 size=404
    let mut pc: u32 = 0x82852E90;
    'dispatch: loop {
        match pc {
            0x82852E90 => {
    //   block [0x82852E90..0x82852ED0)
	// 82852E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82852E94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82852E98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82852E9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82852EA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82852EA4: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82852EA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82852EAC: 38640004  addi r3, r4, 4
	ctx.r[3].s64 = ctx.r[4].s64 + 4;
	// 82852EB0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82852EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852EB8: 419A001C  beq cr6, 0x82852ed4
	if ctx.cr[6].eq {
	pc = 0x82852ED4; continue 'dispatch;
	}
	// 82852EBC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82852EC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82852EC4: 419A000C  beq cr6, 0x82852ed0
	if ctx.cr[6].eq {
	pc = 0x82852ED0; continue 'dispatch;
	}
	// 82852EC8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82852ECC: 4800000C  b 0x82852ed8
	pc = 0x82852ED8; continue 'dispatch;
            }
            0x82852ED0 => {
    //   block [0x82852ED0..0x82852ED4)
	// 82852ED0: 4B940F69  bl 0x82193e38
	ctx.lr = 0x82852ED4;
	sub_82193E38(ctx, base);
	pc = 0x82852ED4; continue 'dispatch;
            }
            0x82852ED4 => {
    //   block [0x82852ED4..0x82852ED8)
	// 82852ED4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82852ED8; continue 'dispatch;
            }
            0x82852ED8 => {
    //   block [0x82852ED8..0x82852F14)
	// 82852ED8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82852EDC: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 82852EE0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82852EE4: 419A00F4  beq cr6, 0x82852fd8
	if ctx.cr[6].eq {
	pc = 0x82852FD8; continue 'dispatch;
	}
	// 82852EE8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82852EEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82852EF0: 419A0024  beq cr6, 0x82852f14
	if ctx.cr[6].eq {
	pc = 0x82852F14; continue 'dispatch;
	}
	// 82852EF4: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82852EF8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82852EFC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82852F00: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82852F04: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82852F08: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82852F0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82852F10: 480000CC  b 0x82852fdc
	pc = 0x82852FDC; continue 'dispatch;
            }
            0x82852F14 => {
    //   block [0x82852F14..0x82852F30)
	// 82852F14: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82852F18: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82852F1C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82852F20: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82852F24: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82852F28: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82852F2C: 40810054  ble 0x82852f80
	if !ctx.cr[0].gt {
	pc = 0x82852F80; continue 'dispatch;
	}
	pc = 0x82852F30; continue 'dispatch;
            }
            0x82852F30 => {
    //   block [0x82852F30..0x82852F50)
	// 82852F30: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82852F34: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82852F38: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82852F3C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82852F40: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 82852F44: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82852F48: 41980008  blt cr6, 0x82852f50
	if ctx.cr[6].lt {
	pc = 0x82852F50; continue 'dispatch;
	}
	// 82852F4C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82852F50; continue 'dispatch;
            }
            0x82852F50 => {
    //   block [0x82852F50..0x82852F6C)
	// 82852F50: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82852F54: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82852F58: 419A0014  beq cr6, 0x82852f6c
	if ctx.cr[6].eq {
	pc = 0x82852F6C; continue 'dispatch;
	}
	// 82852F5C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82852F60: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82852F64: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82852F68: 4800000C  b 0x82852f74
	pc = 0x82852F74; continue 'dispatch;
            }
            0x82852F6C => {
    //   block [0x82852F6C..0x82852F74)
	// 82852F6C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82852F70: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82852F74; continue 'dispatch;
            }
            0x82852F74 => {
    //   block [0x82852F74..0x82852F80)
	// 82852F74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82852F78: 4199FFB8  bgt cr6, 0x82852f30
	if ctx.cr[6].gt {
	pc = 0x82852F30; continue 'dispatch;
	}
	// 82852F7C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82852F80; continue 'dispatch;
            }
            0x82852F80 => {
    //   block [0x82852F80..0x82852F9C)
	// 82852F80: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82852F84: 419A0040  beq cr6, 0x82852fc4
	if ctx.cr[6].eq {
	pc = 0x82852FC4; continue 'dispatch;
	}
	// 82852F88: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82852F8C: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 82852F90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82852F94: 41990008  bgt cr6, 0x82852f9c
	if ctx.cr[6].gt {
	pc = 0x82852F9C; continue 'dispatch;
	}
	// 82852F98: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82852F9C; continue 'dispatch;
            }
            0x82852F9C => {
    //   block [0x82852F9C..0x82852FC4)
	// 82852F9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82852FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852FA4: 409A0020  bne cr6, 0x82852fc4
	if !ctx.cr[6].eq {
	pc = 0x82852FC4; continue 'dispatch;
	}
	// 82852FA8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82852FAC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82852FB0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82852FB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82852FB8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82852FBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82852FC0: 4800001C  b 0x82852fdc
	pc = 0x82852FDC; continue 'dispatch;
            }
            0x82852FC4 => {
    //   block [0x82852FC4..0x82852FD8)
	// 82852FC4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82852FC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82852FCC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82852FD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82852FD4: 48000008  b 0x82852fdc
	pc = 0x82852FDC; continue 'dispatch;
            }
            0x82852FD8 => {
    //   block [0x82852FD8..0x82852FDC)
	// 82852FD8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82852FDC; continue 'dispatch;
            }
            0x82852FDC => {
    //   block [0x82852FDC..0x82852FFC)
	// 82852FDC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82852FE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82852FE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82852FE8: 419A0014  beq cr6, 0x82852ffc
	if ctx.cr[6].eq {
	pc = 0x82852FFC; continue 'dispatch;
	}
	// 82852FEC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82852FF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82852FF4: 4B987475  bl 0x821da468
	ctx.lr = 0x82852FF8;
	sub_821DA468(ctx, base);
	// 82852FF8: 48000010  b 0x82853008
	pc = 0x82853008; continue 'dispatch;
            }
            0x82852FFC => {
    //   block [0x82852FFC..0x82853008)
	// 82852FFC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82853000: 388B5E78  addi r4, r11, 0x5e78
	ctx.r[4].s64 = ctx.r[11].s64 + 24184;
	// 82853004: 4B99D23D  bl 0x821f0240
	ctx.lr = 0x82853008;
	sub_821F0240(ctx, base);
	pc = 0x82853008; continue 'dispatch;
            }
            0x82853008 => {
    //   block [0x82853008..0x82853024)
	// 82853008: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285300C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82853010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82853014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82853018: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285301C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82853020: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82853028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82853028 size=224
    let mut pc: u32 = 0x82853028;
    'dispatch: loop {
        match pc {
            0x82853028 => {
    //   block [0x82853028..0x8285307C)
	// 82853028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285302C: 484563E1  bl 0x82ca940c
	ctx.lr = 0x82853030;
	sub_82CA93D0(ctx, base);
	// 82853030: 9421F750  stwu r1, -0x8b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-2224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82853034: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82853038: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8285303C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82853040: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 82853044: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853048: 409900B8  ble cr6, 0x82853100
	if !ctx.cr[6].gt {
	pc = 0x82853100; continue 'dispatch;
	}
	// 8285304C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82853054: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853058: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285305C: 4E800421  bctrl
	ctx.lr = 0x82853060;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82853060: 7BC90020  clrldi r9, r30, 0x20
	ctx.r[9].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 82853064: B0610050  sth r3, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u16 ) };
	// 82853068: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 8285306C: 419A0010  beq cr6, 0x8285307c
	if ctx.cr[6].eq {
	pc = 0x8285307C; continue 'dispatch;
	}
	// 82853070: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82853074: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82853078: 48000010  b 0x82853088
	pc = 0x82853088; continue 'dispatch;
            }
            0x8285307C => {
    //   block [0x8285307C..0x82853088)
	// 8285307C: 7BCB0022  rldicl r11, r30, 0x20, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 82853080: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82853084: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x82853088; continue 'dispatch;
            }
            0x82853088 => {
    //   block [0x82853088..0x82853100)
	// 82853088: 38A00800  li r5, 0x800
	ctx.r[5].s64 = 2048;
	// 8285308C: 99410058  stb r10, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 82853090: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 82853094: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82853098: 48434F49  bl 0x82c87fe0
	ctx.lr = 0x8285309C;
	sub_82C87FE0(ctx, base);
	// 8285309C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828530A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828530A4: 394B3D70  addi r10, r11, 0x3d70
	ctx.r[10].s64 = ctx.r[11].s64 + 15728;
	// 828530A8: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 828530AC: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 828530B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828530B4: 48434EED  bl 0x82c87fa0
	ctx.lr = 0x828530B8;
	sub_82C87FA0(ctx, base);
	// 828530B8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828530BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828530C0: 39093C90  addi r8, r9, 0x3c90
	ctx.r[8].s64 = ctx.r[9].s64 + 15504;
	// 828530C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828530C8: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 828530CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828530D0: 4BAB6A69  bl 0x82309b38
	ctx.lr = 0x828530D4;
	sub_82309B38(ctx, base);
	// 828530D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828530D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828530DC: 4800002D  bl 0x82853108
	ctx.lr = 0x828530E0;
	sub_82853108(ctx, base);
	// 828530E0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828530E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828530E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828530EC: 4BAE238D  bl 0x82335478
	ctx.lr = 0x828530F0;
	sub_82335478(ctx, base);
	// 828530F0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828530F4: 48343D85  bl 0x82b96e78
	ctx.lr = 0x828530F8;
	sub_82B96E78(ctx, base);
	// 828530F8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828530FC: 48343D7D  bl 0x82b96e78
	ctx.lr = 0x82853100;
	sub_82B96E78(ctx, base);
	pc = 0x82853100; continue 'dispatch;
            }
            0x82853100 => {
    //   block [0x82853100..0x82853108)
	// 82853100: 382108B0  addi r1, r1, 0x8b0
	ctx.r[1].s64 = ctx.r[1].s64 + 2224;
	// 82853104: 48456358  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82853108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82853108 size=248
    let mut pc: u32 = 0x82853108;
    'dispatch: loop {
        match pc {
            0x82853108 => {
    //   block [0x82853108..0x82853200)
	// 82853108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285310C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82853110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82853114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82853118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285311C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82853120: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82853124: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82853128: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8285312C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853130: E89F0008  ld r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 82853134: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82853138: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285313C: 4E800421  bctrl
	ctx.lr = 0x82853140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82853140: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853144: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82853148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285314C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82853150: 81090070  lwz r8, 0x70(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(112 as u32) ) } as u64;
	// 82853154: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82853158: 4E800421  bctrl
	ctx.lr = 0x8285315C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285315C: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853160: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82853164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82853168: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8285316C: 80C70070  lwz r6, 0x70(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(112 as u32) ) } as u64;
	// 82853170: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82853174: 4E800421  bctrl
	ctx.lr = 0x82853178;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82853178: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285317C: 889F0018  lbz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82853180: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82853184: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82853188: 814B0088  lwz r10, 0x88(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 8285318C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82853190: 4E800421  bctrl
	ctx.lr = 0x82853194;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82853194: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853198: 889F0019  lbz r4, 0x19(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 8285319C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828531A0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828531A4: 81090088  lwz r8, 0x88(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(136 as u32) ) } as u64;
	// 828531A8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828531AC: 4E800421  bctrl
	ctx.lr = 0x828531B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828531B0: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828531B4: C03F001C  lfs f1, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828531B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828531BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828531C0: 80C70064  lwz r6, 0x64(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(100 as u32) ) } as u64;
	// 828531C4: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 828531C8: 4E800421  bctrl
	ctx.lr = 0x828531CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828531CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828531D0: 889F0020  lbz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828531D4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828531D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828531DC: 814B0088  lwz r10, 0x88(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 828531E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828531E4: 4E800421  bctrl
	ctx.lr = 0x828531E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828531E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828531EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828531F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828531F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828531F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828531FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82853200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82853200 size=80
    let mut pc: u32 = 0x82853200;
    'dispatch: loop {
        match pc {
            0x82853200 => {
    //   block [0x82853200..0x82853238)
	// 82853200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82853204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82853208: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285320C: 4BA4552D  bl 0x82298738
	ctx.lr = 0x82853210;
	sub_82298738(ctx, base);
	// 82853210: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82853214: 419A0024  beq cr6, 0x82853238
	if ctx.cr[6].eq {
	pc = 0x82853238; continue 'dispatch;
	}
	// 82853218: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285321C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82853220: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82853224: 4E800421  bctrl
	ctx.lr = 0x82853228;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82853228: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8285322C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82853230: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82853234: 4E800020  blr
	return;
            }
            0x82853238 => {
    //   block [0x82853238..0x82853250)
	// 82853238: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8285323C: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82853240: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82853244: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82853248: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285324C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82853250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82853250 size=100
    let mut pc: u32 = 0x82853250;
    'dispatch: loop {
        match pc {
            0x82853250 => {
    //   block [0x82853250..0x828532B4)
	// 82853250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82853254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82853258: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285325C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82853260: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82853264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82853268: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8285326C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82853270: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82853274: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853278: 80680018  lwz r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 8285327C: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853280: 80C70058  lwz r6, 0x58(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 82853284: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82853288: 4E800421  bctrl
	ctx.lr = 0x8285328C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285328C: 80A30000  lwz r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853290: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82853294: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 82853298: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8285329C: 4E800421  bctrl
	ctx.lr = 0x828532A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828532A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828532A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828532A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828532AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828532B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828532B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828532B8 size=116
    let mut pc: u32 = 0x828532B8;
    'dispatch: loop {
        match pc {
            0x828532B8 => {
    //   block [0x828532B8..0x8285332C)
	// 828532B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828532BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828532C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828532C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828532C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828532CC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828532D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828532D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828532D8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828532DC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828532E0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828532E4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828532E8: 80680018  lwz r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 828532EC: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828532F0: 80C70058  lwz r6, 0x58(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 828532F4: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 828532F8: 4E800421  bctrl
	ctx.lr = 0x828532FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828532FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853300: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82853304: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82853308: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285330C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82853310: 4E800421  bctrl
	ctx.lr = 0x82853314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82853314: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82853318: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285331C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82853320: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82853324: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82853328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82853330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82853330 size=100
    let mut pc: u32 = 0x82853330;
    'dispatch: loop {
        match pc {
            0x82853330 => {
    //   block [0x82853330..0x82853394)
	// 82853330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82853334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82853338: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285333C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82853340: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82853344: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82853348: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 8285334C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82853350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82853354: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82853358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285335C: 4B9C153D  bl 0x82214898
	ctx.lr = 0x82853360;
	sub_82214898(ctx, base);
	// 82853360: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82853364: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82853368: 4BC7EB61  bl 0x824d1ec8
	ctx.lr = 0x8285336C;
	sub_824D1EC8(ctx, base);
	// 8285336C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82853370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82853374: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 82853378: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 8285337C: 4B940ABD  bl 0x82193e38
	ctx.lr = 0x82853380;
	sub_82193E38(ctx, base);
	// 82853380: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82853384: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82853388: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285338C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82853390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82853398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82853398 size=100
    let mut pc: u32 = 0x82853398;
    'dispatch: loop {
        match pc {
            0x82853398 => {
    //   block [0x82853398..0x828533FC)
	// 82853398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285339C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828533A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828533A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828533A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828533AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828533B0: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828533B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828533B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828533BC: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828533C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828533C4: 4B940A75  bl 0x82193e38
	ctx.lr = 0x828533C8;
	sub_82193E38(ctx, base);
	// 828533C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828533CC: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 828533D0: 4BC7EAF9  bl 0x824d1ec8
	ctx.lr = 0x828533D4;
	sub_824D1EC8(ctx, base);
	// 828533D4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828533D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828533DC: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828533E0: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828533E4: 4B940A55  bl 0x82193e38
	ctx.lr = 0x828533E8;
	sub_82193E38(ctx, base);
	// 828533E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828533EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828533F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828533F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828533F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82853400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82853400 size=56
    let mut pc: u32 = 0x82853400;
    'dispatch: loop {
        match pc {
            0x82853400 => {
    //   block [0x82853400..0x82853438)
	// 82853400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82853404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82853408: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285340C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82853410: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82853414: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82853418: C02B92D4  lfs f1, -0x6d2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285341C: 4BA2AA25  bl 0x8227de40
	ctx.lr = 0x82853420;
	sub_8227DE40(ctx, base);
	// 82853420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82853424: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82853428: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285342C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82853430: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82853434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82853438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82853438 size=984
    let mut pc: u32 = 0x82853438;
    'dispatch: loop {
        match pc {
            0x82853438 => {
    //   block [0x82853438..0x82853490)
	// 82853438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285343C: 48455FCD  bl 0x82ca9408
	ctx.lr = 0x82853440;
	sub_82CA93D0(ctx, base);
	// 82853440: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82853444: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82853448: 4BEDEB89  bl 0x82731fd0
	ctx.lr = 0x8285344C;
	sub_82731FD0(ctx, base);
	// 8285344C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82853450: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82853454: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853458: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285345C: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82853460: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82853464: 419A00E8  beq cr6, 0x8285354c
	if ctx.cr[6].eq {
	pc = 0x8285354C; continue 'dispatch;
	}
	// 82853468: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285346C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853470: 419A0020  beq cr6, 0x82853490
	if ctx.cr[6].eq {
	pc = 0x82853490; continue 'dispatch;
	}
	// 82853474: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 82853478: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285347C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82853480: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82853484: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82853488: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285348C: 480000C4  b 0x82853550
	pc = 0x82853550; continue 'dispatch;
            }
            0x82853490 => {
    //   block [0x82853490..0x828534AC)
	// 82853490: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82853494: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82853498: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8285349C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828534A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828534A4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828534A8: 40810054  ble 0x828534fc
	if !ctx.cr[0].gt {
	pc = 0x828534FC; continue 'dispatch;
	}
	pc = 0x828534AC; continue 'dispatch;
            }
            0x828534AC => {
    //   block [0x828534AC..0x828534CC)
	// 828534AC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828534B0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828534B4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828534B8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828534BC: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828534C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828534C4: 41980008  blt cr6, 0x828534cc
	if ctx.cr[6].lt {
	pc = 0x828534CC; continue 'dispatch;
	}
	// 828534C8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x828534CC; continue 'dispatch;
            }
            0x828534CC => {
    //   block [0x828534CC..0x828534E8)
	// 828534CC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828534D0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828534D4: 419A0014  beq cr6, 0x828534e8
	if ctx.cr[6].eq {
	pc = 0x828534E8; continue 'dispatch;
	}
	// 828534D8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828534DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828534E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828534E4: 4800000C  b 0x828534f0
	pc = 0x828534F0; continue 'dispatch;
            }
            0x828534E8 => {
    //   block [0x828534E8..0x828534F0)
	// 828534E8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828534EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828534F0; continue 'dispatch;
            }
            0x828534F0 => {
    //   block [0x828534F0..0x828534FC)
	// 828534F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828534F4: 4199FFB8  bgt cr6, 0x828534ac
	if ctx.cr[6].gt {
	pc = 0x828534AC; continue 'dispatch;
	}
	// 828534F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828534FC; continue 'dispatch;
            }
            0x828534FC => {
    //   block [0x828534FC..0x82853518)
	// 828534FC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82853500: 419A003C  beq cr6, 0x8285353c
	if ctx.cr[6].eq {
	pc = 0x8285353C; continue 'dispatch;
	}
	// 82853504: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853508: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8285350C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82853510: 41990008  bgt cr6, 0x82853518
	if ctx.cr[6].gt {
	pc = 0x82853518; continue 'dispatch;
	}
	// 82853514: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82853518; continue 'dispatch;
            }
            0x82853518 => {
    //   block [0x82853518..0x8285353C)
	// 82853518: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285351C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853520: 409A001C  bne cr6, 0x8285353c
	if !ctx.cr[6].eq {
	pc = 0x8285353C; continue 'dispatch;
	}
	// 82853524: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82853528: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285352C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82853530: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82853534: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853538: 48000018  b 0x82853550
	pc = 0x82853550; continue 'dispatch;
            }
            0x8285353C => {
    //   block [0x8285353C..0x8285354C)
	// 8285353C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82853540: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82853544: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853548: 48000008  b 0x82853550
	pc = 0x82853550; continue 'dispatch;
            }
            0x8285354C => {
    //   block [0x8285354C..0x82853550)
	// 8285354C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x82853550; continue 'dispatch;
            }
            0x82853550 => {
    //   block [0x82853550..0x828535B4)
	// 82853550: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82853554: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82853558: 419A02B0  beq cr6, 0x82853808
	if ctx.cr[6].eq {
	pc = 0x82853808; continue 'dispatch;
	}
	// 8285355C: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82853560: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82853564: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82853568: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8285356C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82853570: 419A0298  beq cr6, 0x82853808
	if ctx.cr[6].eq {
	pc = 0x82853808; continue 'dispatch;
	}
	// 82853574: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 82853578: 3FE0834C  lis r31, -0x7cb4
	ctx.r[31].s64 = -2092171264;
	// 8285357C: 816A3C58  lwz r11, 0x3c58(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15448 as u32) ) } as u64;
	// 82853580: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82853584: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82853588: 409A002C  bne cr6, 0x828535b4
	if !ctx.cr[6].eq {
	pc = 0x828535B4; continue 'dispatch;
	}
	// 8285358C: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 82853590: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82853594: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82853598: 3869EEFC  addi r3, r9, -0x1104
	ctx.r[3].s64 = ctx.r[9].s64 + -4356;
	// 8285359C: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828535A0: 916A3C58  stw r11, 0x3c58(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15448 as u32), ctx.r[11].u32 ) };
	// 828535A4: 4B9A07B5  bl 0x821f3d58
	ctx.lr = 0x828535A8;
	sub_821F3D58(ctx, base);
	// 828535A8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828535AC: 90FF3C54  stw r7, 0x3c54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(15444 as u32), ctx.r[7].u32 ) };
	// 828535B0: 48000008  b 0x828535b8
	pc = 0x828535B8; continue 'dispatch;
            }
            0x828535B4 => {
    //   block [0x828535B4..0x828535B8)
	// 828535B4: 80FF3C54  lwz r7, 0x3c54(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(15444 as u32) ) } as u64;
	pc = 0x828535B8; continue 'dispatch;
            }
            0x828535B8 => {
    //   block [0x828535B8..0x8285360C)
	// 828535B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828535BC: 4B95EF3D  bl 0x821b24f8
	ctx.lr = 0x828535C0;
	sub_821B24F8(ctx, base);
	// 828535C0: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828535C4: 4B9768C5  bl 0x821c9e88
	ctx.lr = 0x828535C8;
	sub_821C9E88(ctx, base);
	// 828535C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828535CC: 409A023C  bne cr6, 0x82853808
	if !ctx.cr[6].eq {
	pc = 0x82853808; continue 'dispatch;
	}
	// 828535D0: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828535D4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828535D8: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828535DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828535E0: 419A00E4  beq cr6, 0x828536c4
	if ctx.cr[6].eq {
	pc = 0x828536C4; continue 'dispatch;
	}
	// 828535E4: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 828535E8: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828535EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828535F0: 419A001C  beq cr6, 0x8285360c
	if ctx.cr[6].eq {
	pc = 0x8285360C; continue 'dispatch;
	}
	// 828535F4: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828535F8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828535FC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82853600: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853604: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82853608: 480000C0  b 0x828536c8
	pc = 0x828536C8; continue 'dispatch;
            }
            0x8285360C => {
    //   block [0x8285360C..0x82853624)
	// 8285360C: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82853610: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82853614: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82853618: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285361C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82853620: 40810054  ble 0x82853674
	if !ctx.cr[0].gt {
	pc = 0x82853674; continue 'dispatch;
	}
	pc = 0x82853624; continue 'dispatch;
            }
            0x82853624 => {
    //   block [0x82853624..0x82853644)
	// 82853624: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82853628: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285362C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82853630: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853634: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 82853638: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285363C: 41980008  blt cr6, 0x82853644
	if ctx.cr[6].lt {
	pc = 0x82853644; continue 'dispatch;
	}
	// 82853640: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82853644; continue 'dispatch;
            }
            0x82853644 => {
    //   block [0x82853644..0x82853660)
	// 82853644: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82853648: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285364C: 419A0014  beq cr6, 0x82853660
	if ctx.cr[6].eq {
	pc = 0x82853660; continue 'dispatch;
	}
	// 82853650: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82853654: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82853658: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285365C: 4800000C  b 0x82853668
	pc = 0x82853668; continue 'dispatch;
            }
            0x82853660 => {
    //   block [0x82853660..0x82853668)
	// 82853660: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82853664: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82853668; continue 'dispatch;
            }
            0x82853668 => {
    //   block [0x82853668..0x82853674)
	// 82853668: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285366C: 4199FFB8  bgt cr6, 0x82853624
	if ctx.cr[6].gt {
	pc = 0x82853624; continue 'dispatch;
	}
	// 82853670: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82853674; continue 'dispatch;
            }
            0x82853674 => {
    //   block [0x82853674..0x82853690)
	// 82853674: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82853678: 419A003C  beq cr6, 0x828536b4
	if ctx.cr[6].eq {
	pc = 0x828536B4; continue 'dispatch;
	}
	// 8285367C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853680: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82853684: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82853688: 41990008  bgt cr6, 0x82853690
	if ctx.cr[6].gt {
	pc = 0x82853690; continue 'dispatch;
	}
	// 8285368C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82853690; continue 'dispatch;
            }
            0x82853690 => {
    //   block [0x82853690..0x828536B4)
	// 82853690: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82853694: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853698: 409A001C  bne cr6, 0x828536b4
	if !ctx.cr[6].eq {
	pc = 0x828536B4; continue 'dispatch;
	}
	// 8285369C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828536A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828536A4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828536A8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828536AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828536B0: 48000018  b 0x828536c8
	pc = 0x828536C8; continue 'dispatch;
            }
            0x828536B4 => {
    //   block [0x828536B4..0x828536C4)
	// 828536B4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828536B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828536BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828536C0: 48000008  b 0x828536c8
	pc = 0x828536C8; continue 'dispatch;
            }
            0x828536C4 => {
    //   block [0x828536C4..0x828536C8)
	// 828536C4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x828536C8; continue 'dispatch;
            }
            0x828536C8 => {
    //   block [0x828536C8..0x828536E0)
	// 828536C8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828536CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828536D0: 419A0010  beq cr6, 0x828536e0
	if ctx.cr[6].eq {
	pc = 0x828536E0; continue 'dispatch;
	}
	// 828536D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828536D8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828536DC: 4BD1EECD  bl 0x825725a8
	ctx.lr = 0x828536E0;
	sub_825725A8(ctx, base);
	pc = 0x828536E0; continue 'dispatch;
            }
            0x828536E0 => {
    //   block [0x828536E0..0x82853724)
	// 828536E0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828536E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828536E8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828536EC: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828536F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828536F4: 419A00F4  beq cr6, 0x828537e8
	if ctx.cr[6].eq {
	pc = 0x828537E8; continue 'dispatch;
	}
	// 828536F8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828536FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82853700: 419A0024  beq cr6, 0x82853724
	if ctx.cr[6].eq {
	pc = 0x82853724; continue 'dispatch;
	}
	// 82853704: 892A001F  lbz r9, 0x1f(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(31 as u32) ) } as u64;
	// 82853708: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285370C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82853710: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82853714: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853718: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285371C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82853720: 480000CC  b 0x828537ec
	pc = 0x828537EC; continue 'dispatch;
            }
            0x82853724 => {
    //   block [0x82853724..0x82853740)
	// 82853724: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82853728: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285372C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82853730: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82853734: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82853738: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285373C: 40810054  ble 0x82853790
	if !ctx.cr[0].gt {
	pc = 0x82853790; continue 'dispatch;
	}
	pc = 0x82853740; continue 'dispatch;
            }
            0x82853740 => {
    //   block [0x82853740..0x82853760)
	// 82853740: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82853744: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82853748: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285374C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853750: 2F07001F  cmpwi cr6, r7, 0x1f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 31, &mut ctx.xer);
	// 82853754: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82853758: 41980008  blt cr6, 0x82853760
	if ctx.cr[6].lt {
	pc = 0x82853760; continue 'dispatch;
	}
	// 8285375C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82853760; continue 'dispatch;
            }
            0x82853760 => {
    //   block [0x82853760..0x8285377C)
	// 82853760: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82853764: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82853768: 419A0014  beq cr6, 0x8285377c
	if ctx.cr[6].eq {
	pc = 0x8285377C; continue 'dispatch;
	}
	// 8285376C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82853770: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82853774: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82853778: 4800000C  b 0x82853784
	pc = 0x82853784; continue 'dispatch;
            }
            0x8285377C => {
    //   block [0x8285377C..0x82853784)
	// 8285377C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82853780: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82853784; continue 'dispatch;
            }
            0x82853784 => {
    //   block [0x82853784..0x82853790)
	// 82853784: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82853788: 4199FFB8  bgt cr6, 0x82853740
	if ctx.cr[6].gt {
	pc = 0x82853740; continue 'dispatch;
	}
	// 8285378C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82853790; continue 'dispatch;
            }
            0x82853790 => {
    //   block [0x82853790..0x828537AC)
	// 82853790: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82853794: 419A0040  beq cr6, 0x828537d4
	if ctx.cr[6].eq {
	pc = 0x828537D4; continue 'dispatch;
	}
	// 82853798: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285379C: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 828537A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828537A4: 41990008  bgt cr6, 0x828537ac
	if ctx.cr[6].gt {
	pc = 0x828537AC; continue 'dispatch;
	}
	// 828537A8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828537AC; continue 'dispatch;
            }
            0x828537AC => {
    //   block [0x828537AC..0x828537D4)
	// 828537AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828537B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828537B4: 409A0020  bne cr6, 0x828537d4
	if !ctx.cr[6].eq {
	pc = 0x828537D4; continue 'dispatch;
	}
	// 828537B8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828537BC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828537C0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828537C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828537C8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828537CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828537D0: 4800001C  b 0x828537ec
	pc = 0x828537EC; continue 'dispatch;
            }
            0x828537D4 => {
    //   block [0x828537D4..0x828537E8)
	// 828537D4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828537D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828537DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828537E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828537E4: 48000008  b 0x828537ec
	pc = 0x828537EC; continue 'dispatch;
            }
            0x828537E8 => {
    //   block [0x828537E8..0x828537EC)
	// 828537E8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828537EC; continue 'dispatch;
            }
            0x828537EC => {
    //   block [0x828537EC..0x82853800)
	// 828537EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828537F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828537F4: 419A000C  beq cr6, 0x82853800
	if ctx.cr[6].eq {
	pc = 0x82853800; continue 'dispatch;
	}
	// 828537F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828537FC: 4BD71895  bl 0x825c5090
	ctx.lr = 0x82853800;
	sub_825C5090(ctx, base);
	pc = 0x82853800; continue 'dispatch;
            }
            0x82853800 => {
    //   block [0x82853800..0x82853808)
	// 82853800: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82853804: 997C002C  stb r11, 0x2c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	pc = 0x82853808; continue 'dispatch;
            }
            0x82853808 => {
    //   block [0x82853808..0x82853810)
	// 82853808: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8285380C: 48455C4C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82853810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82853810 size=648
    let mut pc: u32 = 0x82853810;
    'dispatch: loop {
        match pc {
            0x82853810 => {
    //   block [0x82853810..0x82853880)
	// 82853810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82853814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82853818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285381C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82853820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82853824: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82853828: 4800F359  bl 0x82862b80
	ctx.lr = 0x8285382C;
	sub_82862B80(ctx, base);
	// 8285382C: 897E002C  lbz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82853830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853834: 419A024C  beq cr6, 0x82853a80
	if ctx.cr[6].eq {
	pc = 0x82853A80; continue 'dispatch;
	}
	// 82853838: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285383C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82853840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82853844: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82853848: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 8285384C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82853850: 419A00F4  beq cr6, 0x82853944
	if ctx.cr[6].eq {
	pc = 0x82853944; continue 'dispatch;
	}
	// 82853854: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82853858: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285385C: 419A0024  beq cr6, 0x82853880
	if ctx.cr[6].eq {
	pc = 0x82853880; continue 'dispatch;
	}
	// 82853860: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 82853864: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82853868: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285386C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82853870: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853874: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82853878: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285387C: 480000CC  b 0x82853948
	pc = 0x82853948; continue 'dispatch;
            }
            0x82853880 => {
    //   block [0x82853880..0x8285389C)
	// 82853880: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82853884: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82853888: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8285388C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82853890: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82853894: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82853898: 40810054  ble 0x828538ec
	if !ctx.cr[0].gt {
	pc = 0x828538EC; continue 'dispatch;
	}
	pc = 0x8285389C; continue 'dispatch;
            }
            0x8285389C => {
    //   block [0x8285389C..0x828538BC)
	// 8285389C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828538A0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828538A4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828538A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828538AC: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828538B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828538B4: 41980008  blt cr6, 0x828538bc
	if ctx.cr[6].lt {
	pc = 0x828538BC; continue 'dispatch;
	}
	// 828538B8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x828538BC; continue 'dispatch;
            }
            0x828538BC => {
    //   block [0x828538BC..0x828538D8)
	// 828538BC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828538C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828538C4: 419A0014  beq cr6, 0x828538d8
	if ctx.cr[6].eq {
	pc = 0x828538D8; continue 'dispatch;
	}
	// 828538C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828538CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828538D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828538D4: 4800000C  b 0x828538e0
	pc = 0x828538E0; continue 'dispatch;
            }
            0x828538D8 => {
    //   block [0x828538D8..0x828538E0)
	// 828538D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828538DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828538E0; continue 'dispatch;
            }
            0x828538E0 => {
    //   block [0x828538E0..0x828538EC)
	// 828538E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828538E4: 4199FFB8  bgt cr6, 0x8285389c
	if ctx.cr[6].gt {
	pc = 0x8285389C; continue 'dispatch;
	}
	// 828538E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828538EC; continue 'dispatch;
            }
            0x828538EC => {
    //   block [0x828538EC..0x82853908)
	// 828538EC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828538F0: 419A0040  beq cr6, 0x82853930
	if ctx.cr[6].eq {
	pc = 0x82853930; continue 'dispatch;
	}
	// 828538F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828538F8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828538FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82853900: 41990008  bgt cr6, 0x82853908
	if ctx.cr[6].gt {
	pc = 0x82853908; continue 'dispatch;
	}
	// 82853904: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82853908; continue 'dispatch;
            }
            0x82853908 => {
    //   block [0x82853908..0x82853930)
	// 82853908: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285390C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853910: 409A0020  bne cr6, 0x82853930
	if !ctx.cr[6].eq {
	pc = 0x82853930; continue 'dispatch;
	}
	// 82853914: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82853918: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285391C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82853920: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853924: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82853928: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285392C: 4800001C  b 0x82853948
	pc = 0x82853948; continue 'dispatch;
            }
            0x82853930 => {
    //   block [0x82853930..0x82853944)
	// 82853930: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82853934: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853938: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285393C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82853940: 48000008  b 0x82853948
	pc = 0x82853948; continue 'dispatch;
            }
            0x82853944 => {
    //   block [0x82853944..0x82853948)
	// 82853944: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82853948; continue 'dispatch;
            }
            0x82853948 => {
    //   block [0x82853948..0x8285395C)
	// 82853948: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285394C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853950: 419A000C  beq cr6, 0x8285395c
	if ctx.cr[6].eq {
	pc = 0x8285395C; continue 'dispatch;
	}
	// 82853954: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82853958: 4BD1EC51  bl 0x825725a8
	ctx.lr = 0x8285395C;
	sub_825725A8(ctx, base);
	pc = 0x8285395C; continue 'dispatch;
            }
            0x8285395C => {
    //   block [0x8285395C..0x828539A0)
	// 8285395C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82853964: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82853968: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8285396C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82853970: 419A00F4  beq cr6, 0x82853a64
	if ctx.cr[6].eq {
	pc = 0x82853A64; continue 'dispatch;
	}
	// 82853974: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82853978: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285397C: 419A0024  beq cr6, 0x828539a0
	if ctx.cr[6].eq {
	pc = 0x828539A0; continue 'dispatch;
	}
	// 82853980: 892A001F  lbz r9, 0x1f(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(31 as u32) ) } as u64;
	// 82853984: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82853988: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8285398C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82853990: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853994: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82853998: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285399C: 480000CC  b 0x82853a68
	pc = 0x82853A68; continue 'dispatch;
            }
            0x828539A0 => {
    //   block [0x828539A0..0x828539BC)
	// 828539A0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828539A4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828539A8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828539AC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828539B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828539B4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828539B8: 40810054  ble 0x82853a0c
	if !ctx.cr[0].gt {
	pc = 0x82853A0C; continue 'dispatch;
	}
	pc = 0x828539BC; continue 'dispatch;
            }
            0x828539BC => {
    //   block [0x828539BC..0x828539DC)
	// 828539BC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828539C0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828539C4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828539C8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828539CC: 2F07001F  cmpwi cr6, r7, 0x1f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 31, &mut ctx.xer);
	// 828539D0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828539D4: 41980008  blt cr6, 0x828539dc
	if ctx.cr[6].lt {
	pc = 0x828539DC; continue 'dispatch;
	}
	// 828539D8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x828539DC; continue 'dispatch;
            }
            0x828539DC => {
    //   block [0x828539DC..0x828539F8)
	// 828539DC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828539E0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828539E4: 419A0014  beq cr6, 0x828539f8
	if ctx.cr[6].eq {
	pc = 0x828539F8; continue 'dispatch;
	}
	// 828539E8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828539EC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828539F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828539F4: 4800000C  b 0x82853a00
	pc = 0x82853A00; continue 'dispatch;
            }
            0x828539F8 => {
    //   block [0x828539F8..0x82853A00)
	// 828539F8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828539FC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82853A00; continue 'dispatch;
            }
            0x82853A00 => {
    //   block [0x82853A00..0x82853A0C)
	// 82853A00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82853A04: 4199FFB8  bgt cr6, 0x828539bc
	if ctx.cr[6].gt {
	pc = 0x828539BC; continue 'dispatch;
	}
	// 82853A08: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82853A0C; continue 'dispatch;
            }
            0x82853A0C => {
    //   block [0x82853A0C..0x82853A28)
	// 82853A0C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82853A10: 419A0040  beq cr6, 0x82853a50
	if ctx.cr[6].eq {
	pc = 0x82853A50; continue 'dispatch;
	}
	// 82853A14: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853A18: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 82853A1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82853A20: 41990008  bgt cr6, 0x82853a28
	if ctx.cr[6].gt {
	pc = 0x82853A28; continue 'dispatch;
	}
	// 82853A24: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82853A28; continue 'dispatch;
            }
            0x82853A28 => {
    //   block [0x82853A28..0x82853A50)
	// 82853A28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82853A2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853A30: 409A0020  bne cr6, 0x82853a50
	if !ctx.cr[6].eq {
	pc = 0x82853A50; continue 'dispatch;
	}
	// 82853A34: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82853A38: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82853A3C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82853A40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853A44: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82853A48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82853A4C: 4800001C  b 0x82853a68
	pc = 0x82853A68; continue 'dispatch;
            }
            0x82853A50 => {
    //   block [0x82853A50..0x82853A64)
	// 82853A50: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82853A54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853A58: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82853A5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82853A60: 48000008  b 0x82853a68
	pc = 0x82853A68; continue 'dispatch;
            }
            0x82853A64 => {
    //   block [0x82853A64..0x82853A68)
	// 82853A64: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82853A68; continue 'dispatch;
            }
            0x82853A68 => {
    //   block [0x82853A68..0x82853A7C)
	// 82853A68: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82853A6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853A70: 419A000C  beq cr6, 0x82853a7c
	if ctx.cr[6].eq {
	pc = 0x82853A7C; continue 'dispatch;
	}
	// 82853A74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82853A78: 4BD71619  bl 0x825c5090
	ctx.lr = 0x82853A7C;
	sub_825C5090(ctx, base);
	pc = 0x82853A7C; continue 'dispatch;
            }
            0x82853A7C => {
    //   block [0x82853A7C..0x82853A80)
	// 82853A7C: 9BFE002C  stb r31, 0x2c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[31].u8 ) };
	pc = 0x82853A80; continue 'dispatch;
            }
            0x82853A80 => {
    //   block [0x82853A80..0x82853A98)
	// 82853A80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82853A84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82853A88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82853A8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82853A90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82853A94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82853A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82853A98 size=8
    let mut pc: u32 = 0x82853A98;
    'dispatch: loop {
        match pc {
            0x82853A98 => {
    //   block [0x82853A98..0x82853AA0)
	// 82853A98: 3860002D  li r3, 0x2d
	ctx.r[3].s64 = 45;
	// 82853A9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82853AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82853AA0 size=180
    let mut pc: u32 = 0x82853AA0;
    'dispatch: loop {
        match pc {
            0x82853AA0 => {
    //   block [0x82853AA0..0x82853AD4)
	// 82853AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82853AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82853AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82853AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82853AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82853AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82853AB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82853ABC: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82853AC0: 4B964059  bl 0x821b7b18
	ctx.lr = 0x82853AC4;
	sub_821B7B18(ctx, base);
	// 82853AC4: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82853AC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82853ACC: 419A0044  beq cr6, 0x82853b10
	if ctx.cr[6].eq {
	pc = 0x82853B10; continue 'dispatch;
	}
	// 82853AD0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82853AD4; continue 'dispatch;
            }
            0x82853AD4 => {
    //   block [0x82853AD4..0x82853B08)
	// 82853AD4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82853AD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82853ADC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82853AE0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82853AE4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82853AE8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82853AEC: 4082FFE8  bne 0x82853ad4
	if !ctx.cr[0].eq {
	pc = 0x82853AD4; continue 'dispatch;
	}
	// 82853AF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82853AF4: 409A0014  bne cr6, 0x82853b08
	if !ctx.cr[6].eq {
	pc = 0x82853B08; continue 'dispatch;
	}
	// 82853AF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853AFC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853B00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82853B04: 4E800421  bctrl
	ctx.lr = 0x82853B08;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82853B08 => {
    //   block [0x82853B08..0x82853B10)
	// 82853B08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82853B0C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	pc = 0x82853B10; continue 'dispatch;
            }
            0x82853B10 => {
    //   block [0x82853B10..0x82853B3C)
	// 82853B10: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82853B14: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82853B18: 394BF058  addi r10, r11, -0xfa8
	ctx.r[10].s64 = ctx.r[11].s64 + -4008;
	// 82853B1C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82853B20: 4B9C12B9  bl 0x82214dd8
	ctx.lr = 0x82853B24;
	sub_82214DD8(ctx, base);
	// 82853B24: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82853B28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82853B2C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82853B30: 419A000C  beq cr6, 0x82853b3c
	if ctx.cr[6].eq {
	pc = 0x82853B3C; continue 'dispatch;
	}
	// 82853B34: 4B9C8205  bl 0x8221bd38
	ctx.lr = 0x82853B38;
	sub_8221BD38(ctx, base);
	// 82853B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82853B3C; continue 'dispatch;
            }
            0x82853B3C => {
    //   block [0x82853B3C..0x82853B54)
	// 82853B3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82853B40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82853B44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82853B48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82853B4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82853B50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82853B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82853B58 size=76
    let mut pc: u32 = 0x82853B58;
    'dispatch: loop {
        match pc {
            0x82853B58 => {
    //   block [0x82853B58..0x82853BA4)
	// 82853B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82853B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82853B60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82853B64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82853B68: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82853B6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82853B70: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82853B74: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853B78: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82853B7C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82853B80: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853B84: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853B88: 4B9DEBF1  bl 0x82232778
	ctx.lr = 0x82853B8C;
	sub_82232778(ctx, base);
	// 82853B8C: 987F0010  stb r3, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u8 ) };
	// 82853B90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82853B94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82853B98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82853B9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82853BA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82853BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82853BA8 size=1448
    let mut pc: u32 = 0x82853BA8;
    'dispatch: loop {
        match pc {
            0x82853BA8 => {
    //   block [0x82853BA8..0x82853C2C)
	// 82853BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82853BAC: 48455855  bl 0x82ca9400
	ctx.lr = 0x82853BB0;
	sub_82CA93D0(ctx, base);
	// 82853BB0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82853BB4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82853BB8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82853BBC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82853BC0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82853BC4: 897C0011  lbz r11, 0x11(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(17 as u32) ) } as u64;
	// 82853BC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853BCC: 419A0564  beq cr6, 0x82854130
	if ctx.cr[6].eq {
	pc = 0x82854130; continue 'dispatch;
	}
	// 82853BD0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82853BD4: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853BD8: 9B7C0012  stb r27, 0x12(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(18 as u32), ctx.r[27].u8 ) };
	// 82853BDC: 3BEB9490  addi r31, r11, -0x6b70
	ctx.r[31].s64 = ctx.r[11].s64 + -27504;
	// 82853BE0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82853BE4: C3FFFFF4  lfs f31, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82853BE8: D3FC0014  stfs f31, 0x14(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82853BEC: FD80F890  fmr f12, f31
	ctx.f[12].f64 = ctx.f[31].f64;
	// 82853BF0: D3FC0018  stfs f31, 0x18(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82853BF4: 8143003C  lwz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82853BF8: 55499FFE  rlwinm r9, r10, 0x13, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	// 82853BFC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82853C00: 419A00E8  beq cr6, 0x82853ce8
	if ctx.cr[6].eq {
	pc = 0x82853CE8; continue 'dispatch;
	}
	// 82853C04: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 82853C08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853C0C: 419A0020  beq cr6, 0x82853c2c
	if ctx.cr[6].eq {
	pc = 0x82853C2C; continue 'dispatch;
	}
	// 82853C10: 894B00CD  lbz r10, 0xcd(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(205 as u32) ) } as u64;
	// 82853C14: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82853C18: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82853C1C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82853C20: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82853C24: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853C28: 480000C4  b 0x82853cec
	pc = 0x82853CEC; continue 'dispatch;
            }
            0x82853C2C => {
    //   block [0x82853C2C..0x82853C48)
	// 82853C2C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82853C30: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 82853C34: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82853C38: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82853C3C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82853C40: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82853C44: 40810054  ble 0x82853c98
	if !ctx.cr[0].gt {
	pc = 0x82853C98; continue 'dispatch;
	}
	pc = 0x82853C48; continue 'dispatch;
            }
            0x82853C48 => {
    //   block [0x82853C48..0x82853C68)
	// 82853C48: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82853C4C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82853C50: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82853C54: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853C58: 2F0700CD  cmpwi cr6, r7, 0xcd
	ctx.cr[6].compare_i32(ctx.r[7].s32, 205, &mut ctx.xer);
	// 82853C5C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82853C60: 41980008  blt cr6, 0x82853c68
	if ctx.cr[6].lt {
	pc = 0x82853C68; continue 'dispatch;
	}
	// 82853C64: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x82853C68; continue 'dispatch;
            }
            0x82853C68 => {
    //   block [0x82853C68..0x82853C84)
	// 82853C68: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82853C6C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82853C70: 419A0014  beq cr6, 0x82853c84
	if ctx.cr[6].eq {
	pc = 0x82853C84; continue 'dispatch;
	}
	// 82853C74: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82853C78: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82853C7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82853C80: 4800000C  b 0x82853c8c
	pc = 0x82853C8C; continue 'dispatch;
            }
            0x82853C84 => {
    //   block [0x82853C84..0x82853C8C)
	// 82853C84: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82853C88: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82853C8C; continue 'dispatch;
            }
            0x82853C8C => {
    //   block [0x82853C8C..0x82853C98)
	// 82853C8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82853C90: 4199FFB8  bgt cr6, 0x82853c48
	if ctx.cr[6].gt {
	pc = 0x82853C48; continue 'dispatch;
	}
	// 82853C94: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82853C98; continue 'dispatch;
            }
            0x82853C98 => {
    //   block [0x82853C98..0x82853CB4)
	// 82853C98: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82853C9C: 419A003C  beq cr6, 0x82853cd8
	if ctx.cr[6].eq {
	pc = 0x82853CD8; continue 'dispatch;
	}
	// 82853CA0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853CA4: 2F0B00CD  cmpwi cr6, r11, 0xcd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 205, &mut ctx.xer);
	// 82853CA8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82853CAC: 41990008  bgt cr6, 0x82853cb4
	if ctx.cr[6].gt {
	pc = 0x82853CB4; continue 'dispatch;
	}
	// 82853CB0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82853CB4; continue 'dispatch;
            }
            0x82853CB4 => {
    //   block [0x82853CB4..0x82853CD8)
	// 82853CB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82853CB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853CBC: 409A001C  bne cr6, 0x82853cd8
	if !ctx.cr[6].eq {
	pc = 0x82853CD8; continue 'dispatch;
	}
	// 82853CC0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82853CC4: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82853CC8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82853CCC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82853CD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853CD4: 48000018  b 0x82853cec
	pc = 0x82853CEC; continue 'dispatch;
            }
            0x82853CD8 => {
    //   block [0x82853CD8..0x82853CE8)
	// 82853CD8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82853CDC: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82853CE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853CE4: 48000008  b 0x82853cec
	pc = 0x82853CEC; continue 'dispatch;
            }
            0x82853CE8 => {
    //   block [0x82853CE8..0x82853CEC)
	// 82853CE8: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	pc = 0x82853CEC; continue 'dispatch;
            }
            0x82853CEC => {
    //   block [0x82853CEC..0x82853CFC)
	// 82853CEC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82853CF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82853CF4: 419A0008  beq cr6, 0x82853cfc
	if ctx.cr[6].eq {
	pc = 0x82853CFC; continue 'dispatch;
	}
	// 82853CF8: C18B002C  lfs f12, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82853CFC; continue 'dispatch;
            }
            0x82853CFC => {
    //   block [0x82853CFC..0x82853D60)
	// 82853CFC: 4BDA9E45  bl 0x825fdb40
	ctx.lr = 0x82853D00;
	sub_825FDB40(ctx, base);
	// 82853D00: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82853D04: 409A005C  bne cr6, 0x82853d60
	if !ctx.cr[6].eq {
	pc = 0x82853D60; continue 'dispatch;
	}
	// 82853D08: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82853D0C: C01F22A0  lfs f0, 0x22a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82853D10: C1BF2D90  lfs f13, 0x2d90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(11664 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82853D14: D01C0014  stfs f0, 0x14(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82853D18: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82853D1C: C00B1088  lfs f0, 0x1088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82853D20: D01C0018  stfs f0, 0x18(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82853D24: 4099003C  ble cr6, 0x82853d60
	if !ctx.cr[6].gt {
	pc = 0x82853D60; continue 'dispatch;
	}
	// 82853D28: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82853D2C: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82853D30: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82853D34: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82853D38: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82853D3C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853D40: 388B0078  addi r4, r11, 0x78
	ctx.r[4].s64 = ctx.r[11].s64 + 120;
	// 82853D44: 4B99CC85  bl 0x821f09c8
	ctx.lr = 0x82853D48;
	sub_821F09C8(ctx, base);
	// 82853D48: C01F27D4  lfs f0, 0x27d4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82853D4C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82853D50: 41990010  bgt cr6, 0x82853d60
	if ctx.cr[6].gt {
	pc = 0x82853D60; continue 'dispatch;
	}
	// 82853D54: D3FC0014  stfs f31, 0x14(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82853D58: 9B5C0012  stb r26, 0x12(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(18 as u32), ctx.r[26].u8 ) };
	// 82853D5C: D3FC0018  stfs f31, 0x18(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), tmp.u32 ) };
	pc = 0x82853D60; continue 'dispatch;
            }
            0x82853D60 => {
    //   block [0x82853D60..0x82853DA4)
	// 82853D60: 80DC0004  lwz r6, 4(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853D64: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82853D68: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82853D6C: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 82853D70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82853D74: 419A00F4  beq cr6, 0x82853e68
	if ctx.cr[6].eq {
	pc = 0x82853E68; continue 'dispatch;
	}
	// 82853D78: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82853D7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853D80: 419A0024  beq cr6, 0x82853da4
	if ctx.cr[6].eq {
	pc = 0x82853DA4; continue 'dispatch;
	}
	// 82853D84: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 82853D88: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82853D8C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82853D90: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82853D94: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853D98: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82853D9C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82853DA0: 480000CC  b 0x82853e6c
	pc = 0x82853E6C; continue 'dispatch;
            }
            0x82853DA4 => {
    //   block [0x82853DA4..0x82853DC0)
	// 82853DA4: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82853DA8: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82853DAC: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82853DB0: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82853DB4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82853DB8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82853DBC: 40810054  ble 0x82853e10
	if !ctx.cr[0].gt {
	pc = 0x82853E10; continue 'dispatch;
	}
	pc = 0x82853DC0; continue 'dispatch;
            }
            0x82853DC0 => {
    //   block [0x82853DC0..0x82853DE0)
	// 82853DC0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82853DC4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82853DC8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82853DCC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853DD0: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82853DD4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82853DD8: 41980008  blt cr6, 0x82853de0
	if ctx.cr[6].lt {
	pc = 0x82853DE0; continue 'dispatch;
	}
	// 82853DDC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x82853DE0; continue 'dispatch;
            }
            0x82853DE0 => {
    //   block [0x82853DE0..0x82853DFC)
	// 82853DE0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82853DE4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82853DE8: 419A0014  beq cr6, 0x82853dfc
	if ctx.cr[6].eq {
	pc = 0x82853DFC; continue 'dispatch;
	}
	// 82853DEC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82853DF0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82853DF4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82853DF8: 4800000C  b 0x82853e04
	pc = 0x82853E04; continue 'dispatch;
            }
            0x82853DFC => {
    //   block [0x82853DFC..0x82853E04)
	// 82853DFC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82853E00: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82853E04; continue 'dispatch;
            }
            0x82853E04 => {
    //   block [0x82853E04..0x82853E10)
	// 82853E04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82853E08: 4199FFB8  bgt cr6, 0x82853dc0
	if ctx.cr[6].gt {
	pc = 0x82853DC0; continue 'dispatch;
	}
	// 82853E0C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82853E10; continue 'dispatch;
            }
            0x82853E10 => {
    //   block [0x82853E10..0x82853E2C)
	// 82853E10: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82853E14: 419A0040  beq cr6, 0x82853e54
	if ctx.cr[6].eq {
	pc = 0x82853E54; continue 'dispatch;
	}
	// 82853E18: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853E1C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82853E20: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82853E24: 41990008  bgt cr6, 0x82853e2c
	if ctx.cr[6].gt {
	pc = 0x82853E2C; continue 'dispatch;
	}
	// 82853E28: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82853E2C; continue 'dispatch;
            }
            0x82853E2C => {
    //   block [0x82853E2C..0x82853E54)
	// 82853E2C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82853E30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853E34: 409A0020  bne cr6, 0x82853e54
	if !ctx.cr[6].eq {
	pc = 0x82853E54; continue 'dispatch;
	}
	// 82853E38: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82853E3C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82853E40: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82853E44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853E48: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82853E4C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82853E50: 4800001C  b 0x82853e6c
	pc = 0x82853E6C; continue 'dispatch;
            }
            0x82853E54 => {
    //   block [0x82853E54..0x82853E68)
	// 82853E54: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82853E58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853E5C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82853E60: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82853E64: 48000008  b 0x82853e6c
	pc = 0x82853E6C; continue 'dispatch;
            }
            0x82853E68 => {
    //   block [0x82853E68..0x82853E6C)
	// 82853E68: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82853E6C; continue 'dispatch;
            }
            0x82853E6C => {
    //   block [0x82853E6C..0x82853EB8)
	// 82853E6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82853E70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853E74: 419A02BC  beq cr6, 0x82854130
	if ctx.cr[6].eq {
	pc = 0x82854130; continue 'dispatch;
	}
	// 82853E78: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82853E7C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82853E80: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 82853E84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82853E88: 419A00F4  beq cr6, 0x82853f7c
	if ctx.cr[6].eq {
	pc = 0x82853F7C; continue 'dispatch;
	}
	// 82853E8C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82853E90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853E94: 419A0024  beq cr6, 0x82853eb8
	if ctx.cr[6].eq {
	pc = 0x82853EB8; continue 'dispatch;
	}
	// 82853E98: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82853E9C: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82853EA0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82853EA4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82853EA8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853EAC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82853EB0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82853EB4: 480000CC  b 0x82853f80
	pc = 0x82853F80; continue 'dispatch;
            }
            0x82853EB8 => {
    //   block [0x82853EB8..0x82853ED4)
	// 82853EB8: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82853EBC: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82853EC0: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82853EC4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82853EC8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82853ECC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82853ED0: 40810054  ble 0x82853f24
	if !ctx.cr[0].gt {
	pc = 0x82853F24; continue 'dispatch;
	}
	pc = 0x82853ED4; continue 'dispatch;
            }
            0x82853ED4 => {
    //   block [0x82853ED4..0x82853EF4)
	// 82853ED4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82853ED8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82853EDC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82853EE0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853EE4: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 82853EE8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82853EEC: 41980008  blt cr6, 0x82853ef4
	if ctx.cr[6].lt {
	pc = 0x82853EF4; continue 'dispatch;
	}
	// 82853EF0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x82853EF4; continue 'dispatch;
            }
            0x82853EF4 => {
    //   block [0x82853EF4..0x82853F10)
	// 82853EF4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82853EF8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82853EFC: 419A0014  beq cr6, 0x82853f10
	if ctx.cr[6].eq {
	pc = 0x82853F10; continue 'dispatch;
	}
	// 82853F00: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82853F04: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82853F08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82853F0C: 4800000C  b 0x82853f18
	pc = 0x82853F18; continue 'dispatch;
            }
            0x82853F10 => {
    //   block [0x82853F10..0x82853F18)
	// 82853F10: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82853F14: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82853F18; continue 'dispatch;
            }
            0x82853F18 => {
    //   block [0x82853F18..0x82853F24)
	// 82853F18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82853F1C: 4199FFB8  bgt cr6, 0x82853ed4
	if ctx.cr[6].gt {
	pc = 0x82853ED4; continue 'dispatch;
	}
	// 82853F20: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82853F24; continue 'dispatch;
            }
            0x82853F24 => {
    //   block [0x82853F24..0x82853F40)
	// 82853F24: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82853F28: 419A0040  beq cr6, 0x82853f68
	if ctx.cr[6].eq {
	pc = 0x82853F68; continue 'dispatch;
	}
	// 82853F2C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82853F30: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 82853F34: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82853F38: 41990008  bgt cr6, 0x82853f40
	if ctx.cr[6].gt {
	pc = 0x82853F40; continue 'dispatch;
	}
	// 82853F3C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82853F40; continue 'dispatch;
            }
            0x82853F40 => {
    //   block [0x82853F40..0x82853F68)
	// 82853F40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82853F44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853F48: 409A0020  bne cr6, 0x82853f68
	if !ctx.cr[6].eq {
	pc = 0x82853F68; continue 'dispatch;
	}
	// 82853F4C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82853F50: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82853F54: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82853F58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853F5C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82853F60: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82853F64: 4800001C  b 0x82853f80
	pc = 0x82853F80; continue 'dispatch;
            }
            0x82853F68 => {
    //   block [0x82853F68..0x82853F7C)
	// 82853F68: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82853F6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82853F70: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82853F74: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82853F78: 48000008  b 0x82853f80
	pc = 0x82853F80; continue 'dispatch;
            }
            0x82853F7C => {
    //   block [0x82853F7C..0x82853F80)
	// 82853F7C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82853F80; continue 'dispatch;
            }
            0x82853F80 => {
    //   block [0x82853F80..0x82853FA4)
	// 82853F80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82853F84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853F88: 419A01A8  beq cr6, 0x82854130
	if ctx.cr[6].eq {
	pc = 0x82854130; continue 'dispatch;
	}
	// 82853F8C: 897C0012  lbz r11, 0x12(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(18 as u32) ) } as u64;
	// 82853F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853F94: 409A0010  bne cr6, 0x82853fa4
	if !ctx.cr[6].eq {
	pc = 0x82853FA4; continue 'dispatch;
	}
	// 82853F98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82853F9C: 388B2E24  addi r4, r11, 0x2e24
	ctx.r[4].s64 = ctx.r[11].s64 + 11812;
	// 82853FA0: 4800000C  b 0x82853fac
	pc = 0x82853FAC; continue 'dispatch;
            }
            0x82853FA4 => {
    //   block [0x82853FA4..0x82853FAC)
	// 82853FA4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82853FA8: 388BEF6C  addi r4, r11, -0x1094
	ctx.r[4].s64 = ctx.r[11].s64 + -4244;
	pc = 0x82853FAC; continue 'dispatch;
            }
            0x82853FAC => {
    //   block [0x82853FAC..0x82854004)
	// 82853FAC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82853FB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82853FB4: 4B9D8F1D  bl 0x8222ced0
	ctx.lr = 0x82853FB8;
	sub_8222CED0(ctx, base);
	// 82853FB8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82853FBC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82853FC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82853FC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82853FC8: 4BBCD789  bl 0x82421750
	ctx.lr = 0x82853FCC;
	sub_82421750(ctx, base);
	// 82853FCC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82853FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82853FD4: 419A0150  beq cr6, 0x82854124
	if ctx.cr[6].eq {
	pc = 0x82854124; continue 'dispatch;
	}
	// 82853FD8: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82853FDC: 4B9CB27D  bl 0x8221f258
	ctx.lr = 0x82853FE0;
	sub_8221F258(ctx, base);
	// 82853FE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82853FE4: 419A0020  beq cr6, 0x82854004
	if ctx.cr[6].eq {
	pc = 0x82854004; continue 'dispatch;
	}
	// 82853FE8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82853FEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82853FF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82853FF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82853FF8: 4BA2FC39  bl 0x82283c30
	ctx.lr = 0x82853FFC;
	sub_82283C30(ctx, base);
	// 82853FFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82854000: 48000008  b 0x82854008
	pc = 0x82854008; continue 'dispatch;
            }
            0x82854004 => {
    //   block [0x82854004..0x82854008)
	// 82854004: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	pc = 0x82854008; continue 'dispatch;
            }
            0x82854008 => {
    //   block [0x82854008..0x82854050)
	// 82854008: 3BDC0020  addi r30, r28, 0x20
	ctx.r[30].s64 = ctx.r[28].s64 + 32;
	// 8285400C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82854010: 4BA1F049  bl 0x82273058
	ctx.lr = 0x82854014;
	sub_82273058(ctx, base);
	// 82854014: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82854018: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8285401C: 80BC0020  lwz r5, 0x20(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82854020: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 82854024: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82854028: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8285402C: 4B97A115  bl 0x821ce140
	ctx.lr = 0x82854030;
	sub_821CE140(ctx, base);
	// 82854030: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82854034: 807C001C  lwz r3, 0x1c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82854038: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285403C: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82854040: 419A0078  beq cr6, 0x828540b8
	if ctx.cr[6].eq {
	pc = 0x828540B8; continue 'dispatch;
	}
	// 82854044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82854048: 419A0040  beq cr6, 0x82854088
	if ctx.cr[6].eq {
	pc = 0x82854088; continue 'dispatch;
	}
	// 8285404C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82854050; continue 'dispatch;
            }
            0x82854050 => {
    //   block [0x82854050..0x82854084)
	// 82854050: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82854054: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82854058: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8285405C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82854060: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82854064: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82854068: 4082FFE8  bne 0x82854050
	if !ctx.cr[0].eq {
	pc = 0x82854050; continue 'dispatch;
	}
	// 8285406C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854070: 409A0014  bne cr6, 0x82854084
	if !ctx.cr[6].eq {
	pc = 0x82854084; continue 'dispatch;
	}
	// 82854074: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854078: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285407C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82854080: 4E800421  bctrl
	ctx.lr = 0x82854084;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82854084 => {
    //   block [0x82854084..0x82854088)
	// 82854084: 937C001C  stw r27, 0x1c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	pc = 0x82854088; continue 'dispatch;
            }
            0x82854088 => {
    //   block [0x82854088..0x8285409C)
	// 82854088: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285408C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82854090: 917C001C  stw r11, 0x1c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82854094: 419A0024  beq cr6, 0x828540b8
	if ctx.cr[6].eq {
	pc = 0x828540B8; continue 'dispatch;
	}
	// 82854098: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x8285409C; continue 'dispatch;
            }
            0x8285409C => {
    //   block [0x8285409C..0x828540B8)
	// 8285409C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828540A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828540A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828540A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828540AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828540B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828540B4: 4082FFE8  bne 0x8285409c
	if !ctx.cr[0].eq {
	pc = 0x8285409C; continue 'dispatch;
	}
	pc = 0x828540B8; continue 'dispatch;
            }
            0x828540B8 => {
    //   block [0x828540B8..0x828540CC)
	// 828540B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828540BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828540C0: 419A0048  beq cr6, 0x82854108
	if ctx.cr[6].eq {
	pc = 0x82854108; continue 'dispatch;
	}
	// 828540C4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828540C8: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x828540CC; continue 'dispatch;
            }
            0x828540CC => {
    //   block [0x828540CC..0x82854104)
	// 828540CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828540D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828540D4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828540D8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828540DC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828540E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828540E4: 4082FFE8  bne 0x828540cc
	if !ctx.cr[0].eq {
	pc = 0x828540CC; continue 'dispatch;
	}
	// 828540E8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828540EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828540F0: 409A0014  bne cr6, 0x82854104
	if !ctx.cr[6].eq {
	pc = 0x82854104; continue 'dispatch;
	}
	// 828540F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828540F8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828540FC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82854100: 4E800421  bctrl
	ctx.lr = 0x82854104;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82854104 => {
    //   block [0x82854104..0x82854108)
	// 82854104: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	pc = 0x82854108; continue 'dispatch;
            }
            0x82854108 => {
    //   block [0x82854108..0x82854124)
	// 82854108: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285410C: C03C0014  lfs f1, 0x14(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82854110: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854114: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82854118: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285411C: 4E800421  bctrl
	ctx.lr = 0x82854120;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82854120: 48000008  b 0x82854128
	pc = 0x82854128; continue 'dispatch;
            }
            0x82854124 => {
    //   block [0x82854124..0x82854128)
	// 82854124: 9B7C0011  stb r27, 0x11(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(17 as u32), ctx.r[27].u8 ) };
	pc = 0x82854128; continue 'dispatch;
            }
            0x82854128 => {
    //   block [0x82854128..0x82854130)
	// 82854128: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285412C: 4B9C0CAD  bl 0x82214dd8
	ctx.lr = 0x82854130;
	sub_82214DD8(ctx, base);
	pc = 0x82854130; continue 'dispatch;
            }
            0x82854130 => {
    //   block [0x82854130..0x82854144)
	// 82854130: 897C0011  lbz r11, 0x11(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(17 as u32) ) } as u64;
	// 82854134: 9B7C0013  stb r27, 0x13(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(19 as u32), ctx.r[27].u8 ) };
	// 82854138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285413C: 409A0008  bne cr6, 0x82854144
	if !ctx.cr[6].eq {
	pc = 0x82854144; continue 'dispatch;
	}
	// 82854140: 9B5C0013  stb r26, 0x13(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(19 as u32), ctx.r[26].u8 ) };
	pc = 0x82854144; continue 'dispatch;
            }
            0x82854144 => {
    //   block [0x82854144..0x82854150)
	// 82854144: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82854148: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8285414C: 48455304  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82854150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82854150 size=460
    let mut pc: u32 = 0x82854150;
    'dispatch: loop {
        match pc {
            0x82854150 => {
    //   block [0x82854150..0x828541A4)
	// 82854150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82854154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82854158: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285415C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82854160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82854164: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 82854168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285416C: 419A019C  beq cr6, 0x82854308
	if ctx.cr[6].eq {
	pc = 0x82854308; continue 'dispatch;
	}
	// 82854170: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854174: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82854178: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 8285417C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82854180: 419A0078  beq cr6, 0x828541f8
	if ctx.cr[6].eq {
	pc = 0x828541F8; continue 'dispatch;
	}
	// 82854184: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 82854188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285418C: 409A0064  bne cr6, 0x828541f0
	if !ctx.cr[6].eq {
	pc = 0x828541F0; continue 'dispatch;
	}
	// 82854190: 8163004C  lwz r11, 0x4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 82854194: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82854198: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8285419C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828541A0: 40810050  ble 0x828541f0
	if !ctx.cr[0].gt {
	pc = 0x828541F0; continue 'dispatch;
	}
	pc = 0x828541A4; continue 'dispatch;
            }
            0x828541A4 => {
    //   block [0x828541A4..0x828541C4)
	// 828541A4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828541A8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828541AC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828541B0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828541B4: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828541B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828541BC: 41980008  blt cr6, 0x828541c4
	if ctx.cr[6].lt {
	pc = 0x828541C4; continue 'dispatch;
	}
	// 828541C0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828541C4; continue 'dispatch;
            }
            0x828541C4 => {
    //   block [0x828541C4..0x828541E0)
	// 828541C4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828541C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828541CC: 419A0014  beq cr6, 0x828541e0
	if ctx.cr[6].eq {
	pc = 0x828541E0; continue 'dispatch;
	}
	// 828541D0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828541D4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828541D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828541DC: 4800000C  b 0x828541e8
	pc = 0x828541E8; continue 'dispatch;
            }
            0x828541E0 => {
    //   block [0x828541E0..0x828541E8)
	// 828541E0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828541E4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828541E8; continue 'dispatch;
            }
            0x828541E8 => {
    //   block [0x828541E8..0x828541F0)
	// 828541E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828541EC: 4199FFB8  bgt cr6, 0x828541a4
	if ctx.cr[6].gt {
	pc = 0x828541A4; continue 'dispatch;
	}
	pc = 0x828541F0; continue 'dispatch;
            }
            0x828541F0 => {
    //   block [0x828541F0..0x828541F8)
	// 828541F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828541F4: 48000008  b 0x828541fc
	pc = 0x828541FC; continue 'dispatch;
            }
            0x828541F8 => {
    //   block [0x828541F8..0x828541FC)
	// 828541F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828541FC; continue 'dispatch;
            }
            0x828541FC => {
    //   block [0x828541FC..0x82854238)
	// 828541FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82854200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82854204: 419A0104  beq cr6, 0x82854308
	if ctx.cr[6].eq {
	pc = 0x82854308; continue 'dispatch;
	}
	// 82854208: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285420C: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 82854210: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82854214: 419A0078  beq cr6, 0x8285428c
	if ctx.cr[6].eq {
	pc = 0x8285428C; continue 'dispatch;
	}
	// 82854218: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285421C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82854220: 409A0064  bne cr6, 0x82854284
	if !ctx.cr[6].eq {
	pc = 0x82854284; continue 'dispatch;
	}
	// 82854224: 8163004C  lwz r11, 0x4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 82854228: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285422C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82854230: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854234: 40810050  ble 0x82854284
	if !ctx.cr[0].gt {
	pc = 0x82854284; continue 'dispatch;
	}
	pc = 0x82854238; continue 'dispatch;
            }
            0x82854238 => {
    //   block [0x82854238..0x82854258)
	// 82854238: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285423C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82854240: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82854244: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854248: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 8285424C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82854250: 41980008  blt cr6, 0x82854258
	if ctx.cr[6].lt {
	pc = 0x82854258; continue 'dispatch;
	}
	// 82854254: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82854258; continue 'dispatch;
            }
            0x82854258 => {
    //   block [0x82854258..0x82854274)
	// 82854258: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285425C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82854260: 419A0014  beq cr6, 0x82854274
	if ctx.cr[6].eq {
	pc = 0x82854274; continue 'dispatch;
	}
	// 82854264: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82854268: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285426C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82854270: 4800000C  b 0x8285427c
	pc = 0x8285427C; continue 'dispatch;
            }
            0x82854274 => {
    //   block [0x82854274..0x8285427C)
	// 82854274: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82854278: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285427C; continue 'dispatch;
            }
            0x8285427C => {
    //   block [0x8285427C..0x82854284)
	// 8285427C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854280: 4199FFB8  bgt cr6, 0x82854238
	if ctx.cr[6].gt {
	pc = 0x82854238; continue 'dispatch;
	}
	pc = 0x82854284; continue 'dispatch;
            }
            0x82854284 => {
    //   block [0x82854284..0x8285428C)
	// 82854284: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82854288: 48000008  b 0x82854290
	pc = 0x82854290; continue 'dispatch;
            }
            0x8285428C => {
    //   block [0x8285428C..0x82854290)
	// 8285428C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82854290; continue 'dispatch;
            }
            0x82854290 => {
    //   block [0x82854290..0x828542D4)
	// 82854290: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82854294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82854298: 419A0070  beq cr6, 0x82854308
	if ctx.cr[6].eq {
	pc = 0x82854308; continue 'dispatch;
	}
	// 8285429C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828542A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828542A4: 419A0064  beq cr6, 0x82854308
	if ctx.cr[6].eq {
	pc = 0x82854308; continue 'dispatch;
	}
	// 828542A8: 4B9B3549  bl 0x822077f0
	ctx.lr = 0x828542AC;
	sub_822077F0(ctx, base);
	// 828542AC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828542B0: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828542B4: 895F0013  lbz r10, 0x13(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(19 as u32) ) } as u64;
	// 828542B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828542BC: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 828542C0: FC010024  fdiv f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 828542C4: C0E30020  lfs f7, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828542C8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 828542CC: 409A0008  bne cr6, 0x828542d4
	if !ctx.cr[6].eq {
	pc = 0x828542D4; continue 'dispatch;
	}
	// 828542D0: ECE7002A  fadds f7, f7, f0
	ctx.f[7].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x828542D4; continue 'dispatch;
            }
            0x828542D4 => {
    //   block [0x828542D4..0x828542F0)
	// 828542D4: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828542D8: 4BA7F371  bl 0x822d3648
	ctx.lr = 0x828542DC;
	sub_822D3648(ctx, base);
	// 828542DC: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828542E0: EDA10028  fsubs f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 828542E4: FF076800  fcmpu cr6, f7, f13
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[13].f64);
	// 828542E8: 41980008  blt cr6, 0x828542f0
	if ctx.cr[6].lt {
	pc = 0x828542F0; continue 'dispatch;
	}
	// 828542EC: C0FF0014  lfs f7, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	pc = 0x828542F0; continue 'dispatch;
            }
            0x828542F0 => {
    //   block [0x828542F0..0x82854308)
	// 828542F0: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828542F4: FC203890  fmr f1, f7
	ctx.f[1].f64 = ctx.f[7].f64;
	// 828542F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828542FC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82854300: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82854304: 4E800421  bctrl
	ctx.lr = 0x82854308;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82854308 => {
    //   block [0x82854308..0x8285431C)
	// 82854308: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8285430C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82854310: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82854314: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82854318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82854320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82854320 size=432
    let mut pc: u32 = 0x82854320;
    'dispatch: loop {
        match pc {
            0x82854320 => {
    //   block [0x82854320..0x8285437C)
	// 82854320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82854324: 484550E9  bl 0x82ca940c
	ctx.lr = 0x82854328;
	sub_82CA93D0(ctx, base);
	// 82854328: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285432C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82854330: 809D001C  lwz r4, 0x1c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82854334: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82854338: 419A0190  beq cr6, 0x828544c8
	if ctx.cr[6].eq {
	pc = 0x828544C8; continue 'dispatch;
	}
	// 8285433C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854340: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82854344: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82854348: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 8285434C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82854350: 419A00E8  beq cr6, 0x82854438
	if ctx.cr[6].eq {
	pc = 0x82854438; continue 'dispatch;
	}
	// 82854354: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82854358: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285435C: 419A0020  beq cr6, 0x8285437c
	if ctx.cr[6].eq {
	pc = 0x8285437C; continue 'dispatch;
	}
	// 82854360: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 82854364: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82854368: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285436C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82854370: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82854374: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854378: 480000C8  b 0x82854440
	pc = 0x82854440; continue 'dispatch;
            }
            0x8285437C => {
    //   block [0x8285437C..0x82854398)
	// 8285437C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82854380: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82854384: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82854388: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285438C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82854390: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854394: 40810054  ble 0x828543e8
	if !ctx.cr[0].gt {
	pc = 0x828543E8; continue 'dispatch;
	}
	pc = 0x82854398; continue 'dispatch;
            }
            0x82854398 => {
    //   block [0x82854398..0x828543B8)
	// 82854398: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285439C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828543A0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828543A4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828543A8: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828543AC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828543B0: 41980008  blt cr6, 0x828543b8
	if ctx.cr[6].lt {
	pc = 0x828543B8; continue 'dispatch;
	}
	// 828543B4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x828543B8; continue 'dispatch;
            }
            0x828543B8 => {
    //   block [0x828543B8..0x828543D4)
	// 828543B8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828543BC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828543C0: 419A0014  beq cr6, 0x828543d4
	if ctx.cr[6].eq {
	pc = 0x828543D4; continue 'dispatch;
	}
	// 828543C4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828543C8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828543CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828543D0: 4800000C  b 0x828543dc
	pc = 0x828543DC; continue 'dispatch;
            }
            0x828543D4 => {
    //   block [0x828543D4..0x828543DC)
	// 828543D4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828543D8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828543DC; continue 'dispatch;
            }
            0x828543DC => {
    //   block [0x828543DC..0x828543E8)
	// 828543DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828543E0: 4199FFB8  bgt cr6, 0x82854398
	if ctx.cr[6].gt {
	pc = 0x82854398; continue 'dispatch;
	}
	// 828543E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828543E8; continue 'dispatch;
            }
            0x828543E8 => {
    //   block [0x828543E8..0x82854404)
	// 828543E8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828543EC: 419A003C  beq cr6, 0x82854428
	if ctx.cr[6].eq {
	pc = 0x82854428; continue 'dispatch;
	}
	// 828543F0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828543F4: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 828543F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828543FC: 41990008  bgt cr6, 0x82854404
	if ctx.cr[6].gt {
	pc = 0x82854404; continue 'dispatch;
	}
	// 82854400: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82854404; continue 'dispatch;
            }
            0x82854404 => {
    //   block [0x82854404..0x82854428)
	// 82854404: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82854408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285440C: 409A001C  bne cr6, 0x82854428
	if !ctx.cr[6].eq {
	pc = 0x82854428; continue 'dispatch;
	}
	// 82854410: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82854414: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82854418: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285441C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82854420: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854424: 4800001C  b 0x82854440
	pc = 0x82854440; continue 'dispatch;
            }
            0x82854428 => {
    //   block [0x82854428..0x82854438)
	// 82854428: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285442C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82854430: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854434: 4800000C  b 0x82854440
	pc = 0x82854440; continue 'dispatch;
            }
            0x82854438 => {
    //   block [0x82854438..0x82854440)
	// 82854438: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285443C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x82854440; continue 'dispatch;
            }
            0x82854440 => {
    //   block [0x82854440..0x82854468)
	// 82854440: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82854444: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82854448: 419A0080  beq cr6, 0x828544c8
	if ctx.cr[6].eq {
	pc = 0x828544C8; continue 'dispatch;
	}
	// 8285444C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82854450: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82854454: 4BA59BCD  bl 0x822ae020
	ctx.lr = 0x82854458;
	sub_822AE020(ctx, base);
	// 82854458: 807D001C  lwz r3, 0x1c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 8285445C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82854460: 419A0040  beq cr6, 0x828544a0
	if ctx.cr[6].eq {
	pc = 0x828544A0; continue 'dispatch;
	}
	// 82854464: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82854468; continue 'dispatch;
            }
            0x82854468 => {
    //   block [0x82854468..0x8285449C)
	// 82854468: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8285446C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82854470: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82854474: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82854478: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285447C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82854480: 4082FFE8  bne 0x82854468
	if !ctx.cr[0].eq {
	pc = 0x82854468; continue 'dispatch;
	}
	// 82854484: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854488: 409A0014  bne cr6, 0x8285449c
	if !ctx.cr[6].eq {
	pc = 0x8285449C; continue 'dispatch;
	}
	// 8285448C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854490: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854494: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82854498: 4E800421  bctrl
	ctx.lr = 0x8285449C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285449C => {
    //   block [0x8285449C..0x828544A0)
	// 8285449C: 93DD001C  stw r30, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	pc = 0x828544A0; continue 'dispatch;
            }
            0x828544A0 => {
    //   block [0x828544A0..0x828544C8)
	// 828544A0: 93DD001C  stw r30, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 828544A4: 3BFD0020  addi r31, r29, 0x20
	ctx.r[31].s64 = ctx.r[29].s64 + 32;
	// 828544A8: 807D0020  lwz r3, 0x20(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 828544AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828544B0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828544B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828544B8: 4E800421  bctrl
	ctx.lr = 0x828544BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828544BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828544C0: 4B963659  bl 0x821b7b18
	ctx.lr = 0x828544C4;
	sub_821B7B18(ctx, base);
	// 828544C4: 93DD0020  stw r30, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
            }
            0x828544C8 => {
    //   block [0x828544C8..0x828544D0)
	// 828544C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828544CC: 48454F90  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828544D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828544D0 size=8
    let mut pc: u32 = 0x828544D0;
    'dispatch: loop {
        match pc {
            0x828544D0 => {
    //   block [0x828544D0..0x828544D8)
	// 828544D0: 3860002E  li r3, 0x2e
	ctx.r[3].s64 = 46;
	// 828544D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828544D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828544D8 size=100
    let mut pc: u32 = 0x828544D8;
    'dispatch: loop {
        match pc {
            0x828544D8 => {
    //   block [0x828544D8..0x82854524)
	// 828544D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828544DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828544E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828544E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828544E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828544EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828544F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828544F4: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 828544F8: 4B963621  bl 0x821b7b18
	ctx.lr = 0x828544FC;
	sub_821B7B18(ctx, base);
	// 828544FC: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 82854500: 4B963619  bl 0x821b7b18
	ctx.lr = 0x82854504;
	sub_821B7B18(ctx, base);
	// 82854504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82854508: 48000039  bl 0x82854540
	ctx.lr = 0x8285450C;
	sub_82854540(ctx, base);
	// 8285450C: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82854510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82854514: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82854518: 419A000C  beq cr6, 0x82854524
	if ctx.cr[6].eq {
	pc = 0x82854524; continue 'dispatch;
	}
	// 8285451C: 4B9C781D  bl 0x8221bd38
	ctx.lr = 0x82854520;
	sub_8221BD38(ctx, base);
	// 82854520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82854524; continue 'dispatch;
            }
            0x82854524 => {
    //   block [0x82854524..0x8285453C)
	// 82854524: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82854528: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285452C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82854530: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82854534: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82854538: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82854540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82854540 size=152
    let mut pc: u32 = 0x82854540;
    'dispatch: loop {
        match pc {
            0x82854540 => {
    //   block [0x82854540..0x82854564)
	// 82854540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82854544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82854548: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285454C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82854550: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82854554: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82854558: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285455C: 419A0044  beq cr6, 0x828545a0
	if ctx.cr[6].eq {
	pc = 0x828545A0; continue 'dispatch;
	}
	// 82854560: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82854564; continue 'dispatch;
            }
            0x82854564 => {
    //   block [0x82854564..0x82854598)
	// 82854564: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82854568: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285456C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82854570: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82854574: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82854578: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285457C: 4082FFE8  bne 0x82854564
	if !ctx.cr[0].eq {
	pc = 0x82854564; continue 'dispatch;
	}
	// 82854580: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854584: 409A0014  bne cr6, 0x82854598
	if !ctx.cr[6].eq {
	pc = 0x82854598; continue 'dispatch;
	}
	// 82854588: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285458C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854590: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82854594: 4E800421  bctrl
	ctx.lr = 0x82854598;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82854598 => {
    //   block [0x82854598..0x828545A0)
	// 82854598: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8285459C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	pc = 0x828545A0; continue 'dispatch;
            }
            0x828545A0 => {
    //   block [0x828545A0..0x828545D8)
	// 828545A0: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828545A4: 4B963575  bl 0x821b7b18
	ctx.lr = 0x828545A8;
	sub_821B7B18(ctx, base);
	// 828545A8: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828545AC: 4B96356D  bl 0x821b7b18
	ctx.lr = 0x828545B0;
	sub_821B7B18(ctx, base);
	// 828545B0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828545B4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828545B8: 394BF058  addi r10, r11, -0xfa8
	ctx.r[10].s64 = ctx.r[11].s64 + -4008;
	// 828545BC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828545C0: 4B9C0819  bl 0x82214dd8
	ctx.lr = 0x828545C4;
	sub_82214DD8(ctx, base);
	// 828545C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828545C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828545CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828545D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828545D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828545D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828545D8 size=8
    let mut pc: u32 = 0x828545D8;
    'dispatch: loop {
        match pc {
            0x828545D8 => {
    //   block [0x828545D8..0x828545E0)
	// 828545D8: 88630028  lbz r3, 0x28(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828545DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828545E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828545E0 size=56
    let mut pc: u32 = 0x828545E0;
    'dispatch: loop {
        match pc {
            0x828545E0 => {
    //   block [0x828545E0..0x828545F8)
	// 828545E0: 81640040  lwz r11, 0x40(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 828545E4: 8144003C  lwz r10, 0x3c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 828545E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828545EC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828545F0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828545F4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x828545F8; continue 'dispatch;
            }
            0x828545F8 => {
    //   block [0x828545F8..0x82854618)
	// 828545F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828545FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82854600: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82854604: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82854608: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285460C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82854610: 4082FFE8  bne 0x828545f8
	if !ctx.cr[0].eq {
	pc = 0x828545F8; continue 'dispatch;
	}
	// 82854614: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82854618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82854618 size=228
    let mut pc: u32 = 0x82854618;
    'dispatch: loop {
        match pc {
            0x82854618 => {
    //   block [0x82854618..0x82854668)
	// 82854618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285461C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82854620: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82854624: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82854628: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285462C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82854630: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82854634: 4B9CAC25  bl 0x8221f258
	ctx.lr = 0x82854638;
	sub_8221F258(ctx, base);
	// 82854638: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285463C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82854640: 419A0064  beq cr6, 0x828546a4
	if ctx.cr[6].eq {
	pc = 0x828546A4; continue 'dispatch;
	}
	// 82854644: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82854648: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8285464C: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 82854650: 390B0B7C  addi r8, r11, 0xb7c
	ctx.r[8].s64 = ctx.r[11].s64 + 2940;
	// 82854654: 38C77088  addi r6, r7, 0x7088
	ctx.r[6].s64 = ctx.r[7].s64 + 28808;
	// 82854658: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8285465C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82854660: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82854664: 93E30010  stw r31, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	pc = 0x82854668; continue 'dispatch;
            }
            0x82854668 => {
    //   block [0x82854668..0x828546A4)
	// 82854668: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285466C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82854670: 7D403028  lwarx r10, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82854674: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82854678: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285467C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82854680: 4082FFE8  bne 0x82854668
	if !ctx.cr[0].eq {
	pc = 0x82854668; continue 'dispatch;
	}
	// 82854684: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 82854688: 9BE30014  stb r31, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[31].u8 ) };
	// 8285468C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82854690: 93E30018  stw r31, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 82854694: 81656B38  lwz r11, 0x6b38(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(27448 as u32) ) } as u64;
	// 82854698: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8285469C: 91656B38  stw r11, 0x6b38(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(27448 as u32), ctx.r[11].u32 ) };
	// 828546A0: 48000008  b 0x828546a8
	pc = 0x828546A8; continue 'dispatch;
            }
            0x828546A4 => {
    //   block [0x828546A4..0x828546A8)
	// 828546A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x828546A8; continue 'dispatch;
            }
            0x828546A8 => {
    //   block [0x828546A8..0x828546FC)
	// 828546A8: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 828546AC: 4BD823F5  bl 0x825d6aa0
	ctx.lr = 0x828546B0;
	sub_825D6AA0(ctx, base);
	// 828546B0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828546B4: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828546B8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828546BC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828546C0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828546C4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828546C8: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828546CC: 4B9DE0AD  bl 0x82232778
	ctx.lr = 0x828546D0;
	sub_82232778(ctx, base);
	// 828546D0: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 828546D4: 987E0028  stb r3, 0x28(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[3].u8 ) };
	// 828546D8: 9BFE002A  stb r31, 0x2a(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(42 as u32), ctx.r[31].u8 ) };
	// 828546DC: C0079490  lfs f0, -0x6b70(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828546E0: D01E002C  stfs f0, 0x2c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 828546E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828546E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828546EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828546F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828546F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828546F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82854700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82854700 size=72
    let mut pc: u32 = 0x82854700;
    'dispatch: loop {
        match pc {
            0x82854700 => {
    //   block [0x82854700..0x82854734)
	// 82854700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82854704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82854708: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285470C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82854710: 3BE30034  addi r31, r3, 0x34
	ctx.r[31].s64 = ctx.r[3].s64 + 52;
	// 82854714: 80630034  lwz r3, 0x34(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82854718: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8285471C: 419A0018  beq cr6, 0x82854734
	if ctx.cr[6].eq {
	pc = 0x82854734; continue 'dispatch;
	}
	// 82854720: 480995C1  bl 0x828edce0
	ctx.lr = 0x82854724;
	sub_828EDCE0(ctx, base);
	// 82854724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82854728: 4B9633F1  bl 0x821b7b18
	ctx.lr = 0x8285472C;
	sub_821B7B18(ctx, base);
	// 8285472C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82854730: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82854734; continue 'dispatch;
            }
            0x82854734 => {
    //   block [0x82854734..0x82854748)
	// 82854734: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82854738: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285473C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82854740: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82854744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82854748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82854748 size=1292
    let mut pc: u32 = 0x82854748;
    'dispatch: loop {
        match pc {
            0x82854748 => {
    //   block [0x82854748..0x8285479C)
	// 82854748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285474C: 48454CB9  bl 0x82ca9404
	ctx.lr = 0x82854750;
	sub_82CA93D0(ctx, base);
	// 82854750: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82854754: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82854758: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285475C: 4B9B3095  bl 0x822077f0
	ctx.lr = 0x82854760;
	sub_822077F0(ctx, base);
	// 82854760: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82854764: C1BB002C  lfs f13, 0x2c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82854768: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8285476C: 3B8BCBBC  addi r28, r11, -0x3444
	ctx.r[28].s64 = ctx.r[11].s64 + -13380;
	// 82854770: C80A9660  lfd f0, -0x69a0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 82854774: FD810024  fdiv f12, f1, f0
	ctx.f[12].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 82854778: C01CC8C8  lfs f0, -0x3738(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-14136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285477C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82854780: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82854784: 40990018  ble cr6, 0x8285479c
	if !ctx.cr[6].gt {
	pc = 0x8285479C; continue 'dispatch;
	}
	// 82854788: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8285478C: D1BB002C  stfs f13, 0x2c(r27)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82854790: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82854794: 41990008  bgt cr6, 0x8285479c
	if ctx.cr[6].gt {
	pc = 0x8285479C; continue 'dispatch;
	}
	// 82854798: D01B002C  stfs f0, 0x2c(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), tmp.u32 ) };
	pc = 0x8285479C; continue 'dispatch;
            }
            0x8285479C => {
    //   block [0x8285479C..0x828547EC)
	// 8285479C: 897B0028  lbz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 828547A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828547A4: 409A04A8  bne cr6, 0x82854c4c
	if !ctx.cr[6].eq {
	pc = 0x82854C4C; continue 'dispatch;
	}
	// 828547A8: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828547AC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828547B0: 81660028  lwz r11, 0x28(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(40 as u32) ) } as u64;
	// 828547B4: 556AA7FE  rlwinm r10, r11, 0x14, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 828547B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828547BC: 419A00F4  beq cr6, 0x828548b0
	if ctx.cr[6].eq {
	pc = 0x828548B0; continue 'dispatch;
	}
	// 828547C0: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828547C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828547C8: 419A0024  beq cr6, 0x828547ec
	if ctx.cr[6].eq {
	pc = 0x828547EC; continue 'dispatch;
	}
	// 828547CC: 894B002C  lbz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828547D0: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828547D4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828547D8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828547DC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828547E0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828547E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828547E8: 480000D0  b 0x828548b8
	pc = 0x828548B8; continue 'dispatch;
            }
            0x828547EC => {
    //   block [0x828547EC..0x82854808)
	// 828547EC: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828547F0: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 828547F4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828547F8: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 828547FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82854800: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854804: 40810054  ble 0x82854858
	if !ctx.cr[0].gt {
	pc = 0x82854858; continue 'dispatch;
	}
	pc = 0x82854808; continue 'dispatch;
            }
            0x82854808 => {
    //   block [0x82854808..0x82854828)
	// 82854808: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285480C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82854810: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82854814: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854818: 2F07002C  cmpwi cr6, r7, 0x2c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 44, &mut ctx.xer);
	// 8285481C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82854820: 41980008  blt cr6, 0x82854828
	if ctx.cr[6].lt {
	pc = 0x82854828; continue 'dispatch;
	}
	// 82854824: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82854828; continue 'dispatch;
            }
            0x82854828 => {
    //   block [0x82854828..0x82854844)
	// 82854828: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285482C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82854830: 419A0014  beq cr6, 0x82854844
	if ctx.cr[6].eq {
	pc = 0x82854844; continue 'dispatch;
	}
	// 82854834: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82854838: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285483C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82854840: 4800000C  b 0x8285484c
	pc = 0x8285484C; continue 'dispatch;
            }
            0x82854844 => {
    //   block [0x82854844..0x8285484C)
	// 82854844: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82854848: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285484C; continue 'dispatch;
            }
            0x8285484C => {
    //   block [0x8285484C..0x82854858)
	// 8285484C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854850: 4199FFB8  bgt cr6, 0x82854808
	if ctx.cr[6].gt {
	pc = 0x82854808; continue 'dispatch;
	}
	// 82854854: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82854858; continue 'dispatch;
            }
            0x82854858 => {
    //   block [0x82854858..0x82854874)
	// 82854858: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8285485C: 419A0040  beq cr6, 0x8285489c
	if ctx.cr[6].eq {
	pc = 0x8285489C; continue 'dispatch;
	}
	// 82854860: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854864: 2F0B002C  cmpwi cr6, r11, 0x2c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 44, &mut ctx.xer);
	// 82854868: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285486C: 41990008  bgt cr6, 0x82854874
	if ctx.cr[6].gt {
	pc = 0x82854874; continue 'dispatch;
	}
	// 82854870: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82854874; continue 'dispatch;
            }
            0x82854874 => {
    //   block [0x82854874..0x8285489C)
	// 82854874: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82854878: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285487C: 409A0020  bne cr6, 0x8285489c
	if !ctx.cr[6].eq {
	pc = 0x8285489C; continue 'dispatch;
	}
	// 82854880: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82854884: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82854888: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285488C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854890: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82854894: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82854898: 48000020  b 0x828548b8
	pc = 0x828548B8; continue 'dispatch;
            }
            0x8285489C => {
    //   block [0x8285489C..0x828548B0)
	// 8285489C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828548A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828548A4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828548A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828548AC: 4800000C  b 0x828548b8
	pc = 0x828548B8; continue 'dispatch;
            }
            0x828548B0 => {
    //   block [0x828548B0..0x828548B8)
	// 828548B0: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828548B4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828548B8; continue 'dispatch;
            }
            0x828548B8 => {
    //   block [0x828548B8..0x82854918)
	// 828548B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828548BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828548C0: 419A038C  beq cr6, 0x82854c4c
	if ctx.cr[6].eq {
	pc = 0x82854C4C; continue 'dispatch;
	}
	// 828548C4: C1BB002C  lfs f13, 0x2c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828548C8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828548CC: 41990334  bgt cr6, 0x82854c00
	if ctx.cr[6].gt {
	pc = 0x82854C00; continue 'dispatch;
	}
	// 828548D0: 897B002A  lbz r11, 0x2a(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(42 as u32) ) } as u64;
	// 828548D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828548D8: 409A0374  bne cr6, 0x82854c4c
	if !ctx.cr[6].eq {
	pc = 0x82854C4C; continue 'dispatch;
	}
	// 828548DC: A146003C  lhz r10, 0x3c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(60 as u32) ) } as u64;
	// 828548E0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828548E4: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828548E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828548EC: 419A00E8  beq cr6, 0x828549d4
	if ctx.cr[6].eq {
	pc = 0x828549D4; continue 'dispatch;
	}
	// 828548F0: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828548F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828548F8: 419A0020  beq cr6, 0x82854918
	if ctx.cr[6].eq {
	pc = 0x82854918; continue 'dispatch;
	}
	// 828548FC: 894B00D0  lbz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 82854900: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82854904: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82854908: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285490C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82854910: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854914: 480000C4  b 0x828549d8
	pc = 0x828549D8; continue 'dispatch;
            }
            0x82854918 => {
    //   block [0x82854918..0x82854934)
	// 82854918: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285491C: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82854920: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82854924: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82854928: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285492C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854930: 40810054  ble 0x82854984
	if !ctx.cr[0].gt {
	pc = 0x82854984; continue 'dispatch;
	}
	pc = 0x82854934; continue 'dispatch;
            }
            0x82854934 => {
    //   block [0x82854934..0x82854954)
	// 82854934: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82854938: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285493C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82854940: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854944: 2F0700D0  cmpwi cr6, r7, 0xd0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 208, &mut ctx.xer);
	// 82854948: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285494C: 41980008  blt cr6, 0x82854954
	if ctx.cr[6].lt {
	pc = 0x82854954; continue 'dispatch;
	}
	// 82854950: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82854954; continue 'dispatch;
            }
            0x82854954 => {
    //   block [0x82854954..0x82854970)
	// 82854954: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82854958: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285495C: 419A0014  beq cr6, 0x82854970
	if ctx.cr[6].eq {
	pc = 0x82854970; continue 'dispatch;
	}
	// 82854960: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82854964: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82854968: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285496C: 4800000C  b 0x82854978
	pc = 0x82854978; continue 'dispatch;
            }
            0x82854970 => {
    //   block [0x82854970..0x82854978)
	// 82854970: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82854974: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82854978; continue 'dispatch;
            }
            0x82854978 => {
    //   block [0x82854978..0x82854984)
	// 82854978: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285497C: 4199FFB8  bgt cr6, 0x82854934
	if ctx.cr[6].gt {
	pc = 0x82854934; continue 'dispatch;
	}
	// 82854980: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82854984; continue 'dispatch;
            }
            0x82854984 => {
    //   block [0x82854984..0x828549A0)
	// 82854984: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82854988: 419A003C  beq cr6, 0x828549c4
	if ctx.cr[6].eq {
	pc = 0x828549C4; continue 'dispatch;
	}
	// 8285498C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854990: 2F0B00D0  cmpwi cr6, r11, 0xd0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 208, &mut ctx.xer);
	// 82854994: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82854998: 41990008  bgt cr6, 0x828549a0
	if ctx.cr[6].gt {
	pc = 0x828549A0; continue 'dispatch;
	}
	// 8285499C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828549A0; continue 'dispatch;
            }
            0x828549A0 => {
    //   block [0x828549A0..0x828549C4)
	// 828549A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828549A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828549A8: 409A001C  bne cr6, 0x828549c4
	if !ctx.cr[6].eq {
	pc = 0x828549C4; continue 'dispatch;
	}
	// 828549AC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828549B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828549B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828549B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828549BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828549C0: 48000018  b 0x828549d8
	pc = 0x828549D8; continue 'dispatch;
            }
            0x828549C4 => {
    //   block [0x828549C4..0x828549D4)
	// 828549C4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828549C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828549CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828549D0: 48000008  b 0x828549d8
	pc = 0x828549D8; continue 'dispatch;
            }
            0x828549D4 => {
    //   block [0x828549D4..0x828549D8)
	// 828549D4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x828549D8; continue 'dispatch;
            }
            0x828549D8 => {
    //   block [0x828549D8..0x82854A20)
	// 828549D8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828549DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828549E0: 419A0210  beq cr6, 0x82854bf0
	if ctx.cr[6].eq {
	pc = 0x82854BF0; continue 'dispatch;
	}
	// 828549E4: 386B0074  addi r3, r11, 0x74
	ctx.r[3].s64 = ctx.r[11].s64 + 116;
	// 828549E8: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 828549EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828549F0: 419A00D8  beq cr6, 0x82854ac8
	if ctx.cr[6].eq {
	pc = 0x82854AC8; continue 'dispatch;
	}
	// 828549F4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828549F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828549FC: 419A00C8  beq cr6, 0x82854ac4
	if ctx.cr[6].eq {
	pc = 0x82854AC4; continue 'dispatch;
	}
	// 82854A00: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82854A04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82854A08: 419A0018  beq cr6, 0x82854a20
	if ctx.cr[6].eq {
	pc = 0x82854A20; continue 'dispatch;
	}
	// 82854A0C: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82854A10: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82854A14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82854A18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82854A1C: 409A0008  bne cr6, 0x82854a24
	if !ctx.cr[6].eq {
	pc = 0x82854A24; continue 'dispatch;
	}
	pc = 0x82854A20; continue 'dispatch;
            }
            0x82854A20 => {
    //   block [0x82854A20..0x82854A24)
	// 82854A20: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82854A24; continue 'dispatch;
            }
            0x82854A24 => {
    //   block [0x82854A24..0x82854AC4)
	// 82854A24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82854A28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82854A2C: 419A01C4  beq cr6, 0x82854bf0
	if ctx.cr[6].eq {
	pc = 0x82854BF0; continue 'dispatch;
	}
	// 82854A30: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82854A34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82854A38: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854A3C: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82854A40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82854A44: 4E800421  bctrl
	ctx.lr = 0x82854A48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82854A48: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82854A4C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82854A50: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82854A54: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 82854A58: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82854A5C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82854A60: 38A79190  addi r5, r7, -0x6e70
	ctx.r[5].s64 = ctx.r[7].s64 + -28272;
            }
            0x82854AC4 => {
    //   block [0x82854AC4..0x82854AC8)
	// 82854AC4: 4B93F375  bl 0x82193e38
	ctx.lr = 0x82854AC8;
	sub_82193E38(ctx, base);
	pc = 0x82854AC8; continue 'dispatch;
            }
            0x82854AC8 => {
    //   block [0x82854AC8..0x82854BF0)
	// 82854AC8: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82854ACC: 4BFFFF54  b 0x82854a20
	pc = 0x82854A20; continue 'dispatch;
	// 82854AD0: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82854AD4: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82854AD8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82854ADC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82854AE0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82854AE4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854AE8: 40810054  ble 0x82854b3c
	if !ctx.cr[0].gt {
	pc = 0x82854B3C; continue 'dispatch;
	}
	// 82854AEC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82854AF0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82854AF4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82854AF8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854AFC: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 82854B00: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82854B04: 41980008  blt cr6, 0x82854b0c
	if ctx.cr[6].lt {
	pc = 0x82854B0C; continue 'dispatch;
	}
	// 82854B08: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82854B0C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82854B10: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82854B14: 419A0014  beq cr6, 0x82854b28
	if ctx.cr[6].eq {
	pc = 0x82854B28; continue 'dispatch;
	}
	// 82854B18: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82854B1C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82854B20: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82854B24: 4800000C  b 0x82854b30
	pc = 0x82854B30; continue 'dispatch;
	// 82854B28: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82854B2C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82854B30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854B34: 4199FFB8  bgt cr6, 0x82854aec
	if ctx.cr[6].gt {
	pc = 0x82854AEC; continue 'dispatch;
	}
	// 82854B38: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82854B3C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82854B40: 419A003C  beq cr6, 0x82854b7c
	if ctx.cr[6].eq {
	pc = 0x82854B7C; continue 'dispatch;
	}
	// 82854B44: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854B48: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82854B4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82854B50: 41990008  bgt cr6, 0x82854b58
	if ctx.cr[6].gt {
	pc = 0x82854B58; continue 'dispatch;
	}
	// 82854B54: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82854B58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82854B5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82854B60: 409A001C  bne cr6, 0x82854b7c
	if !ctx.cr[6].eq {
	pc = 0x82854B7C; continue 'dispatch;
	}
	// 82854B64: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82854B68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82854B6C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82854B70: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82854B74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854B78: 48000018  b 0x82854b90
	pc = 0x82854B90; continue 'dispatch;
	// 82854B7C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82854B80: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82854B84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854B88: 48000008  b 0x82854b90
	pc = 0x82854B90; continue 'dispatch;
	// 82854B8C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82854B90: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82854B94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82854B98: 419A0028  beq cr6, 0x82854bc0
	if ctx.cr[6].eq {
	pc = 0x82854BC0; continue 'dispatch;
	}
	// 82854B9C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82854BA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82854BA4: 38AAB7B0  addi r5, r10, -0x4850
	ctx.r[5].s64 = ctx.r[10].s64 + -18512;
	// 82854BA8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82854BAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82854BB0: 4BD1F851  bl 0x82574400
	ctx.lr = 0x82854BB4;
	sub_82574400(ctx, base);
	// 82854BB4: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
            }
            0x82854BF0 => {
    //   block [0x82854BF0..0x82854C00)
	// 82854BF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82854BF4: 997B002A  stb r11, 0x2a(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(42 as u32), ctx.r[11].u8 ) };
	// 82854BF8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82854BFC: 48454858  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82854C00 => {
    //   block [0x82854C00..0x82854C4C)
	// 82854C00: 8086007C  lwz r4, 0x7c(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(124 as u32) ) } as u64;
	// 82854C04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82854C08: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854C0C: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82854C10: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82854C14: 4E800421  bctrl
	ctx.lr = 0x82854C18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82854C18: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82854C1C: 38C0000F  li r6, 0xf
	ctx.r[6].s64 = 15;
	// 82854C20: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82854C24: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82854C28: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
            }
            0x82854C4C => {
    //   block [0x82854C4C..0x82854C54)
	// 82854C4C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82854C50: 48454804  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82854C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82854C68 size=16
    let mut pc: u32 = 0x82854C68;
    'dispatch: loop {
        match pc {
            0x82854C68 => {
    //   block [0x82854C68..0x82854C78)
	// 82854C68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854C6C: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82854C70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82854C74: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82854C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82854C78 size=4
    let mut pc: u32 = 0x82854C78;
    'dispatch: loop {
        match pc {
            0x82854C78 => {
    //   block [0x82854C78..0x82854C7C)
	// 82854C78: 4BA20A70  b 0x822756e8
	sub_822756E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82854C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82854C80 size=412
    let mut pc: u32 = 0x82854C80;
    'dispatch: loop {
        match pc {
            0x82854C80 => {
    //   block [0x82854C80..0x82854CB8)
	// 82854C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82854C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82854C88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82854C8C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82854C90: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82854C94: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82854C98: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 82854C9C: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82854CA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82854CA4: 419A0014  beq cr6, 0x82854cb8
	if ctx.cr[6].eq {
	pc = 0x82854CB8; continue 'dispatch;
	}
	// 82854CA8: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 82854CAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82854CB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82854CB4: 409A0008  bne cr6, 0x82854cbc
	if !ctx.cr[6].eq {
	pc = 0x82854CBC; continue 'dispatch;
	}
	pc = 0x82854CB8; continue 'dispatch;
            }
            0x82854CB8 => {
    //   block [0x82854CB8..0x82854CBC)
	// 82854CB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82854CBC; continue 'dispatch;
            }
            0x82854CBC => {
    //   block [0x82854CBC..0x82854D0C)
	// 82854CBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82854CC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82854CC4: 419A0144  beq cr6, 0x82854e08
	if ctx.cr[6].eq {
	pc = 0x82854E08; continue 'dispatch;
	}
	// 82854CC8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854CCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82854CD0: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82854CD4: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 82854CD8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82854CDC: 419A00F8  beq cr6, 0x82854dd4
	if ctx.cr[6].eq {
	pc = 0x82854DD4; continue 'dispatch;
	}
	// 82854CE0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82854CE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82854CE8: 419A0024  beq cr6, 0x82854d0c
	if ctx.cr[6].eq {
	pc = 0x82854D0C; continue 'dispatch;
	}
	// 82854CEC: 894A005B  lbz r10, 0x5b(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(91 as u32) ) } as u64;
	// 82854CF0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82854CF4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82854CF8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82854CFC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854D00: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82854D04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82854D08: 480000D0  b 0x82854dd8
	pc = 0x82854DD8; continue 'dispatch;
            }
            0x82854D0C => {
    //   block [0x82854D0C..0x82854D2C)
	// 82854D0C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82854D10: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82854D14: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82854D18: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82854D1C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82854D20: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82854D24: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854D28: 40810054  ble 0x82854d7c
	if !ctx.cr[0].gt {
	pc = 0x82854D7C; continue 'dispatch;
	}
	pc = 0x82854D2C; continue 'dispatch;
            }
            0x82854D2C => {
    //   block [0x82854D2C..0x82854D4C)
	// 82854D2C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82854D30: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82854D34: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82854D38: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854D3C: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 82854D40: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82854D44: 41980008  blt cr6, 0x82854d4c
	if ctx.cr[6].lt {
	pc = 0x82854D4C; continue 'dispatch;
	}
	// 82854D48: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82854D4C; continue 'dispatch;
            }
            0x82854D4C => {
    //   block [0x82854D4C..0x82854D68)
	// 82854D4C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82854D50: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82854D54: 419A0014  beq cr6, 0x82854d68
	if ctx.cr[6].eq {
	pc = 0x82854D68; continue 'dispatch;
	}
	// 82854D58: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82854D5C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82854D60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82854D64: 4800000C  b 0x82854d70
	pc = 0x82854D70; continue 'dispatch;
            }
            0x82854D68 => {
    //   block [0x82854D68..0x82854D70)
	// 82854D68: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82854D6C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82854D70; continue 'dispatch;
            }
            0x82854D70 => {
    //   block [0x82854D70..0x82854D7C)
	// 82854D70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854D74: 4199FFB8  bgt cr6, 0x82854d2c
	if ctx.cr[6].gt {
	pc = 0x82854D2C; continue 'dispatch;
	}
	// 82854D78: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82854D7C; continue 'dispatch;
            }
            0x82854D7C => {
    //   block [0x82854D7C..0x82854D98)
	// 82854D7C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82854D80: 419A0040  beq cr6, 0x82854dc0
	if ctx.cr[6].eq {
	pc = 0x82854DC0; continue 'dispatch;
	}
	// 82854D84: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854D88: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 82854D8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82854D90: 41990008  bgt cr6, 0x82854d98
	if ctx.cr[6].gt {
	pc = 0x82854D98; continue 'dispatch;
	}
	// 82854D94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82854D98; continue 'dispatch;
            }
            0x82854D98 => {
    //   block [0x82854D98..0x82854DC0)
	// 82854D98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82854D9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82854DA0: 409A0020  bne cr6, 0x82854dc0
	if !ctx.cr[6].eq {
	pc = 0x82854DC0; continue 'dispatch;
	}
	// 82854DA4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82854DA8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82854DAC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82854DB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854DB4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82854DB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82854DBC: 4800001C  b 0x82854dd8
	pc = 0x82854DD8; continue 'dispatch;
            }
            0x82854DC0 => {
    //   block [0x82854DC0..0x82854DD4)
	// 82854DC0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82854DC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854DC8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82854DCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82854DD0: 48000008  b 0x82854dd8
	pc = 0x82854DD8; continue 'dispatch;
            }
            0x82854DD4 => {
    //   block [0x82854DD4..0x82854DD8)
	// 82854DD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82854DD8; continue 'dispatch;
            }
            0x82854DD8 => {
    //   block [0x82854DD8..0x82854DF4)
	// 82854DD8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82854DDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82854DE0: 419A0014  beq cr6, 0x82854df4
	if ctx.cr[6].eq {
	pc = 0x82854DF4; continue 'dispatch;
	}
	// 82854DE4: 4B9BFD15  bl 0x82214af8
	ctx.lr = 0x82854DE8;
	sub_82214AF8(ctx, base);
	// 82854DE8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82854DEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82854DF0: 409A0018  bne cr6, 0x82854e08
	if !ctx.cr[6].eq {
	pc = 0x82854E08; continue 'dispatch;
	}
	pc = 0x82854DF4; continue 'dispatch;
            }
            0x82854DF4 => {
    //   block [0x82854DF4..0x82854E08)
	// 82854DF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82854DF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82854DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82854E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82854E04: 4E800020  blr
	return;
            }
            0x82854E08 => {
    //   block [0x82854E08..0x82854E1C)
	// 82854E08: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82854E0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82854E10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82854E14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82854E18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82854E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82854E20 size=116
    let mut pc: u32 = 0x82854E20;
    'dispatch: loop {
        match pc {
            0x82854E20 => {
    //   block [0x82854E20..0x82854E80)
	// 82854E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82854E24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82854E28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82854E2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82854E30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82854E34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82854E38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854E3C: 995F000D  stb r10, 0xd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(13 as u32), ctx.r[10].u8 ) };
	// 82854E40: 812B0044  lwz r9, 0x44(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82854E44: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82854E48: 4E800421  bctrl
	ctx.lr = 0x82854E4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82854E4C: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82854E54: 80E8003C  lwz r7, 0x3c(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(60 as u32) ) } as u64;
	// 82854E58: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82854E5C: 4E800421  bctrl
	ctx.lr = 0x82854E60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82854E60: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82854E64: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82854E68: 419A0018  beq cr6, 0x82854e80
	if ctx.cr[6].eq {
	pc = 0x82854E80; continue 'dispatch;
	}
	// 82854E6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854E70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82854E74: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82854E78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82854E7C: 4E800421  bctrl
	ctx.lr = 0x82854E80;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82854E80 => {
    //   block [0x82854E80..0x82854E94)
	// 82854E80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82854E84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82854E88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82854E8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82854E90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82854E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82854E98 size=116
    let mut pc: u32 = 0x82854E98;
    'dispatch: loop {
        match pc {
            0x82854E98 => {
    //   block [0x82854E98..0x82854EF8)
	// 82854E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82854E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82854EA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82854EA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82854EA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82854EAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82854EB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854EB4: 995F000D  stb r10, 0xd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(13 as u32), ctx.r[10].u8 ) };
	// 82854EB8: 812B0048  lwz r9, 0x48(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82854EBC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82854EC0: 4E800421  bctrl
	ctx.lr = 0x82854EC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82854EC4: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82854ECC: 80E8003C  lwz r7, 0x3c(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(60 as u32) ) } as u64;
	// 82854ED0: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82854ED4: 4E800421  bctrl
	ctx.lr = 0x82854ED8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82854ED8: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82854EDC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82854EE0: 419A0018  beq cr6, 0x82854ef8
	if ctx.cr[6].eq {
	pc = 0x82854EF8; continue 'dispatch;
	}
	// 82854EE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82854EEC: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82854EF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82854EF4: 4E800421  bctrl
	ctx.lr = 0x82854EF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82854EF8 => {
    //   block [0x82854EF8..0x82854F0C)
	// 82854EF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82854EFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82854F00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82854F04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82854F08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82854F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82854F10 size=60
    let mut pc: u32 = 0x82854F10;
    'dispatch: loop {
        match pc {
            0x82854F10 => {
    //   block [0x82854F10..0x82854F4C)
	// 82854F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82854F14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82854F18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82854F1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82854F20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82854F24: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82854F28: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82854F2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82854F30: 4B9D7FA1  bl 0x8222ced0
	ctx.lr = 0x82854F34;
	sub_8222CED0(ctx, base);
	// 82854F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82854F38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82854F3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82854F40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82854F44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82854F48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82854F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82854F50 size=300
    let mut pc: u32 = 0x82854F50;
    'dispatch: loop {
        match pc {
            0x82854F50 => {
    //   block [0x82854F50..0x82854F9C)
	// 82854F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82854F54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82854F58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82854F5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82854F60: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854F64: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82854F68: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82854F6C: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 82854F70: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82854F74: 419A00D8  beq cr6, 0x8285504c
	if ctx.cr[6].eq {
	pc = 0x8285504C; continue 'dispatch;
	}
	// 82854F78: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82854F7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82854F80: 419A001C  beq cr6, 0x82854f9c
	if ctx.cr[6].eq {
	pc = 0x82854F9C; continue 'dispatch;
	}
	// 82854F84: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82854F88: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82854F8C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82854F90: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82854F94: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82854F98: 480000B0  b 0x82855048
	pc = 0x82855048; continue 'dispatch;
            }
            0x82854F9C => {
    //   block [0x82854F9C..0x82854FB8)
	// 82854F9C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82854FA0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82854FA4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82854FA8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82854FAC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82854FB0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82854FB4: 40810054  ble 0x82855008
	if !ctx.cr[0].gt {
	pc = 0x82855008; continue 'dispatch;
	}
	pc = 0x82854FB8; continue 'dispatch;
            }
            0x82854FB8 => {
    //   block [0x82854FB8..0x82854FD8)
	// 82854FB8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82854FBC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82854FC0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82854FC4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82854FC8: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 82854FCC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82854FD0: 41980008  blt cr6, 0x82854fd8
	if ctx.cr[6].lt {
	pc = 0x82854FD8; continue 'dispatch;
	}
	// 82854FD4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82854FD8; continue 'dispatch;
            }
            0x82854FD8 => {
    //   block [0x82854FD8..0x82854FF4)
	// 82854FD8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82854FDC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82854FE0: 419A0014  beq cr6, 0x82854ff4
	if ctx.cr[6].eq {
	pc = 0x82854FF4; continue 'dispatch;
	}
	// 82854FE4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82854FE8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82854FEC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82854FF0: 4800000C  b 0x82854ffc
	pc = 0x82854FFC; continue 'dispatch;
            }
            0x82854FF4 => {
    //   block [0x82854FF4..0x82854FFC)
	// 82854FF4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82854FF8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82854FFC; continue 'dispatch;
            }
            0x82854FFC => {
    //   block [0x82854FFC..0x82855008)
	// 82854FFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82855000: 4199FFB8  bgt cr6, 0x82854fb8
	if ctx.cr[6].gt {
	pc = 0x82854FB8; continue 'dispatch;
	}
	// 82855004: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82855008; continue 'dispatch;
            }
            0x82855008 => {
    //   block [0x82855008..0x82855024)
	// 82855008: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285500C: 419A0034  beq cr6, 0x82855040
	if ctx.cr[6].eq {
	pc = 0x82855040; continue 'dispatch;
	}
	// 82855010: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855014: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 82855018: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285501C: 41990008  bgt cr6, 0x82855024
	if ctx.cr[6].gt {
	pc = 0x82855024; continue 'dispatch;
	}
	// 82855020: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82855024; continue 'dispatch;
            }
            0x82855024 => {
    //   block [0x82855024..0x82855040)
	// 82855024: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82855028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285502C: 409A0014  bne cr6, 0x82855040
	if !ctx.cr[6].eq {
	pc = 0x82855040; continue 'dispatch;
	}
	// 82855030: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82855034: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82855038: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285503C: 48000008  b 0x82855044
	pc = 0x82855044; continue 'dispatch;
            }
            0x82855040 => {
    //   block [0x82855040..0x82855044)
	// 82855040: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x82855044; continue 'dispatch;
            }
            0x82855044 => {
    //   block [0x82855044..0x82855048)
	// 82855044: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82855048; continue 'dispatch;
            }
            0x82855048 => {
    //   block [0x82855048..0x8285504C)
	// 82855048: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x8285504C; continue 'dispatch;
            }
            0x8285504C => {
    //   block [0x8285504C..0x8285507C)
	// 8285504C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855050: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855054: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82855058: 4E800421  bctrl
	ctx.lr = 0x8285505C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285505C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82855060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82855064: 4BBCB23D  bl 0x824202a0
	ctx.lr = 0x82855068;
	sub_824202A0(ctx, base);
	// 82855068: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285506C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82855070: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82855074: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82855078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82855080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82855080 size=348
    let mut pc: u32 = 0x82855080;
    'dispatch: loop {
        match pc {
            0x82855080 => {
    //   block [0x82855080..0x828550E8)
	// 82855080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82855084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82855088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285508C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82855090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82855094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82855098: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 8285509C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828550A0: 4BA10101  bl 0x822651a0
	ctx.lr = 0x828550A4;
	sub_822651A0(ctx, base);
	// 828550A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828550A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828550AC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828550B0: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 828550B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828550B8: 419A00F4  beq cr6, 0x828551ac
	if ctx.cr[6].eq {
	pc = 0x828551AC; continue 'dispatch;
	}
	// 828550BC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828550C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828550C4: 419A0024  beq cr6, 0x828550e8
	if ctx.cr[6].eq {
	pc = 0x828550E8; continue 'dispatch;
	}
	// 828550C8: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 828550CC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828550D0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828550D4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828550D8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828550DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828550E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828550E4: 480000CC  b 0x828551b0
	pc = 0x828551B0; continue 'dispatch;
            }
            0x828550E8 => {
    //   block [0x828550E8..0x82855104)
	// 828550E8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828550EC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828550F0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828550F4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828550F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828550FC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82855100: 40810054  ble 0x82855154
	if !ctx.cr[0].gt {
	pc = 0x82855154; continue 'dispatch;
	}
	pc = 0x82855104; continue 'dispatch;
            }
            0x82855104 => {
    //   block [0x82855104..0x82855124)
	// 82855104: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82855108: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285510C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82855110: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855114: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82855118: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285511C: 41980008  blt cr6, 0x82855124
	if ctx.cr[6].lt {
	pc = 0x82855124; continue 'dispatch;
	}
	// 82855120: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82855124; continue 'dispatch;
            }
            0x82855124 => {
    //   block [0x82855124..0x82855140)
	// 82855124: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82855128: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285512C: 419A0014  beq cr6, 0x82855140
	if ctx.cr[6].eq {
	pc = 0x82855140; continue 'dispatch;
	}
	// 82855130: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82855134: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82855138: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285513C: 4800000C  b 0x82855148
	pc = 0x82855148; continue 'dispatch;
            }
            0x82855140 => {
    //   block [0x82855140..0x82855148)
	// 82855140: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82855144: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82855148; continue 'dispatch;
            }
            0x82855148 => {
    //   block [0x82855148..0x82855154)
	// 82855148: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285514C: 4199FFB8  bgt cr6, 0x82855104
	if ctx.cr[6].gt {
	pc = 0x82855104; continue 'dispatch;
	}
	// 82855150: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82855154; continue 'dispatch;
            }
            0x82855154 => {
    //   block [0x82855154..0x82855170)
	// 82855154: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82855158: 419A0040  beq cr6, 0x82855198
	if ctx.cr[6].eq {
	pc = 0x82855198; continue 'dispatch;
	}
	// 8285515C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855160: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82855164: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82855168: 41990008  bgt cr6, 0x82855170
	if ctx.cr[6].gt {
	pc = 0x82855170; continue 'dispatch;
	}
	// 8285516C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82855170; continue 'dispatch;
            }
            0x82855170 => {
    //   block [0x82855170..0x82855198)
	// 82855170: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82855174: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82855178: 409A0020  bne cr6, 0x82855198
	if !ctx.cr[6].eq {
	pc = 0x82855198; continue 'dispatch;
	}
	// 8285517C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82855180: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82855184: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82855188: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285518C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82855190: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82855194: 4800001C  b 0x828551b0
	pc = 0x828551B0; continue 'dispatch;
            }
            0x82855198 => {
    //   block [0x82855198..0x828551AC)
	// 82855198: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285519C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828551A0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828551A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828551A8: 48000008  b 0x828551b0
	pc = 0x828551B0; continue 'dispatch;
            }
            0x828551AC => {
    //   block [0x828551AC..0x828551B0)
	// 828551AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x828551B0; continue 'dispatch;
            }
            0x828551B0 => {
    //   block [0x828551B0..0x828551C4)
	// 828551B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828551B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828551B8: 419A000C  beq cr6, 0x828551c4
	if ctx.cr[6].eq {
	pc = 0x828551C4; continue 'dispatch;
	}
	// 828551BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828551C0: 4BD10179  bl 0x82565338
	ctx.lr = 0x828551C4;
	sub_82565338(ctx, base);
	pc = 0x828551C4; continue 'dispatch;
            }
            0x828551C4 => {
    //   block [0x828551C4..0x828551DC)
	// 828551C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828551C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828551CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828551D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828551D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828551D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828551E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828551E0 size=572
    let mut pc: u32 = 0x828551E0;
    'dispatch: loop {
        match pc {
            0x828551E0 => {
    //   block [0x828551E0..0x8285521C)
	// 828551E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828551E4: 48454211  bl 0x82ca93f4
	ctx.lr = 0x828551E8;
	sub_82CA93D0(ctx, base);
	// 828551E8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828551EC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828551F0: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 828551F4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828551F8: 3BCAFFDF  addi r30, r10, -0x21
	ctx.r[30].s64 = ctx.r[10].s64 + -33;
	// 828551FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82855200: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82855204: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 82855208: 7FF9FB78  mr r25, r31
	ctx.r[25].u64 = ctx.r[31].u64;
	// 8285520C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82855210: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82855214: 419A0008  beq cr6, 0x8285521c
	if ctx.cr[6].eq {
	pc = 0x8285521C; continue 'dispatch;
	}
	// 82855218: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8285521C; continue 'dispatch;
            }
            0x8285521C => {
    //   block [0x8285521C..0x82855268)
	// 8285521C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82855220: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 82855224: 4B99EB35  bl 0x821f3d58
	ctx.lr = 0x82855228;
	sub_821F3D58(ctx, base);
	// 82855228: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8285522C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82855230: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82855234: 419A00A0  beq cr6, 0x828552d4
	if ctx.cr[6].eq {
	pc = 0x828552D4; continue 'dispatch;
	}
	// 82855238: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285523C: 397C0008  addi r11, r28, 8
	ctx.r[11].s64 = ctx.r[28].s64 + 8;
	// 82855240: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82855244: 419A0090  beq cr6, 0x828552d4
	if ctx.cr[6].eq {
	pc = 0x828552D4; continue 'dispatch;
	}
	// 82855248: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285524C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82855250: 419A0084  beq cr6, 0x828552d4
	if ctx.cr[6].eq {
	pc = 0x828552D4; continue 'dispatch;
	}
	// 82855254: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855258: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285525C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82855260: 419A0008  beq cr6, 0x82855268
	if ctx.cr[6].eq {
	pc = 0x82855268; continue 'dispatch;
	}
	// 82855264: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82855268; continue 'dispatch;
            }
            0x82855268 => {
    //   block [0x82855268..0x828552B4)
	// 82855268: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 8285526C: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82855270: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82855274: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 82855278: 4B99EAE1  bl 0x821f3d58
	ctx.lr = 0x8285527C;
	sub_821F3D58(ctx, base);
	// 8285527C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82855280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82855284: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82855288: 4BA26599  bl 0x8227b820
	ctx.lr = 0x8285528C;
	sub_8227B820(ctx, base);
	// 8285528C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82855290: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82855294: 419A0040  beq cr6, 0x828552d4
	if ctx.cr[6].eq {
	pc = 0x828552D4; continue 'dispatch;
	}
	// 82855298: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8285529C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828552A0: 4B974BE9  bl 0x821c9e88
	ctx.lr = 0x828552A4;
	sub_821C9E88(ctx, base);
	// 828552A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828552A8: 419A000C  beq cr6, 0x828552b4
	if ctx.cr[6].eq {
	pc = 0x828552B4; continue 'dispatch;
	}
	// 828552AC: 7FF9FB78  mr r25, r31
	ctx.r[25].u64 = ctx.r[31].u64;
	// 828552B0: 48000024  b 0x828552d4
	pc = 0x828552D4; continue 'dispatch;
            }
            0x828552B4 => {
    //   block [0x828552B4..0x828552D4)
	// 828552B4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828552B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828552BC: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828552C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828552C4: 4E800421  bctrl
	ctx.lr = 0x828552C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828552C8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828552CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828552D0: 409A0130  bne cr6, 0x82855400
	if !ctx.cr[6].eq {
	pc = 0x82855400; continue 'dispatch;
	}
            }
            0x828552D4 => {
    //   block [0x828552D4..0x82855304)
	// 828552D4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828552D8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828552DC: 4B974BAD  bl 0x821c9e88
	ctx.lr = 0x828552E0;
	sub_821C9E88(ctx, base);
	// 828552E0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828552E4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828552E8: 419A0118  beq cr6, 0x82855400
	if ctx.cr[6].eq {
	pc = 0x82855400; continue 'dispatch;
	}
	// 828552EC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828552F0: 419A00C4  beq cr6, 0x828553b4
	if ctx.cr[6].eq {
	pc = 0x828553B4; continue 'dispatch;
	}
	// 828552F4: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 828552F8: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 828552FC: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 82855300: 3B8B3944  addi r28, r11, 0x3944
	ctx.r[28].s64 = ctx.r[11].s64 + 14660;
	pc = 0x82855304; continue 'dispatch;
            }
            0x82855304 => {
    //   block [0x82855304..0x8285534C)
	// 82855304: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855308: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8285530C: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82855310: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82855314: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82855318: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 8285531C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855320: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82855324: 4E800421  bctrl
	ctx.lr = 0x82855328;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82855328: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285532C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82855330: 419A001C  beq cr6, 0x8285534c
	if ctx.cr[6].eq {
	pc = 0x8285534C; continue 'dispatch;
	}
	// 82855334: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82855338: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8285533C: 2B1F0007  cmplwi cr6, r31, 7
	ctx.cr[6].compare_u32(ctx.r[31].u32, 7 as u32, &mut ctx.xer);
	// 82855340: 7FCBE12E  stwx r30, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[30].u32) };
	// 82855344: 41980008  blt cr6, 0x8285534c
	if ctx.cr[6].lt {
	pc = 0x8285534C; continue 'dispatch;
	}
	// 82855348: 3BE00007  li r31, 7
	ctx.r[31].s64 = 7;
            }
            0x8285534C => {
    //   block [0x8285534C..0x828553B4)
	// 8285534C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82855350: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82855354: 409AFFB0  bne cr6, 0x82855304
	if !ctx.cr[6].eq {
	pc = 0x82855304; continue 'dispatch;
	}
	// 82855358: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8285535C: 419A00A4  beq cr6, 0x82855400
	if ctx.cr[6].eq {
	pc = 0x82855400; continue 'dispatch;
	}
	// 82855360: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82855364: 933D0000  stw r25, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82855368: 935D0004  stw r26, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 8285536C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82855370: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82855374: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82855378: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285537C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855380: 810B0078  lwz r8, 0x78(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82855384: 1D4824A1  mulli r10, r8, 0x24a1
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * 9377 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82855388: 38EA24DF  addi r7, r10, 0x24df
	ctx.r[7].s64 = ctx.r[10].s64 + 9439;
	// 8285538C: 54E6983E  rotlwi r6, r7, 0x13
	ctx.r[6].u64 = ((ctx.r[7].u32).rotate_left(19)) as u64;
	// 82855390: 7CA6FB96  divwu r5, r6, r31
	ctx.r[5].u32 = ctx.r[6].u32 / ctx.r[31].u32;
	// 82855394: 90CB0078  stw r6, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[6].u32 ) };
	// 82855398: 7C85F9D6  mullw r4, r5, r31
	ctx.r[4].s32 = ((ctx.r[5].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 8285539C: 7D643050  subf r11, r4, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 828553A0: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828553A4: 7D2AE02E  lwzx r9, r10, r28
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 828553A8: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828553AC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828553B0: 48454094  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x828553B4 => {
    //   block [0x828553B4..0x82855400)
	// 828553B4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828553B8: 933D0000  stw r25, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 828553BC: 935D0004  stw r26, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 828553C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828553C4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828553C8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828553CC: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828553D0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828553D4: 810B0078  lwz r8, 0x78(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 828553D8: 1D4824A1  mulli r10, r8, 0x24a1
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * 9377 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 828553DC: 38EA24DF  addi r7, r10, 0x24df
	ctx.r[7].s64 = ctx.r[10].s64 + 9439;
	// 828553E0: 54E6983E  rotlwi r6, r7, 0x13
	ctx.r[6].u64 = ((ctx.r[7].u32).rotate_left(19)) as u64;
	// 828553E4: 7CA6DB96  divwu r5, r6, r27
	ctx.r[5].u32 = ctx.r[6].u32 / ctx.r[27].u32;
	// 828553E8: 90CB0078  stw r6, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[6].u32 ) };
	// 828553EC: 7C85D9D6  mullw r4, r5, r27
	ctx.r[4].s32 = ((ctx.r[5].s32 as i64 * ctx.r[27].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 828553F0: 7D643050  subf r11, r4, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 828553F4: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828553F8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828553FC: 48454048  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82855400 => {
    //   block [0x82855400..0x8285541C)
	// 82855400: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82855404: 92FD0004  stw r23, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 82855408: 92FD0000  stw r23, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 8285540C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82855410: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82855414: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82855418: 4845402C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82855420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82855420 size=296
    let mut pc: u32 = 0x82855420;
    'dispatch: loop {
        match pc {
            0x82855420 => {
    //   block [0x82855420..0x82855450)
	// 82855420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82855424: 48453FE5  bl 0x82ca9408
	ctx.lr = 0x82855428;
	sub_82CA93D0(ctx, base);
	// 82855428: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285542C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855430: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82855434: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82855438: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8285543C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82855440: 409A0010  bne cr6, 0x82855450
	if !ctx.cr[6].eq {
	pc = 0x82855450; continue 'dispatch;
	}
	// 82855444: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82855448: 386BFFDF  addi r3, r11, -0x21
	ctx.r[3].s64 = ctx.r[11].s64 + -33;
	// 8285544C: 48000008  b 0x82855454
	pc = 0x82855454; continue 'dispatch;
            }
            0x82855450 => {
    //   block [0x82855450..0x82855454)
	// 82855450: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82855454; continue 'dispatch;
            }
            0x82855454 => {
    //   block [0x82855454..0x828554D0)
	// 82855454: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82855458: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 8285545C: 4B99E8FD  bl 0x821f3d58
	ctx.lr = 0x82855460;
	sub_821F3D58(ctx, base);
	// 82855460: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855464: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82855468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285546C: 419A0070  beq cr6, 0x828554dc
	if ctx.cr[6].eq {
	pc = 0x828554DC; continue 'dispatch;
	}
	// 82855470: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855474: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82855478: 419A0064  beq cr6, 0x828554dc
	if ctx.cr[6].eq {
	pc = 0x828554DC; continue 'dispatch;
	}
	// 8285547C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82855480: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855484: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82855488: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 8285548C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82855490: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82855494: 4B99E8C5  bl 0x821f3d58
	ctx.lr = 0x82855498;
	sub_821F3D58(ctx, base);
	// 82855498: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285549C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828554A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828554A4: 4BA2637D  bl 0x8227b820
	ctx.lr = 0x828554A8;
	sub_8227B820(ctx, base);
	// 828554A8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828554AC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828554B0: 419A002C  beq cr6, 0x828554dc
	if ctx.cr[6].eq {
	pc = 0x828554DC; continue 'dispatch;
	}
	// 828554B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828554B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828554BC: 4B9749CD  bl 0x821c9e88
	ctx.lr = 0x828554C0;
	sub_821C9E88(ctx, base);
	// 828554C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828554C4: 419A000C  beq cr6, 0x828554d0
	if ctx.cr[6].eq {
	pc = 0x828554D0; continue 'dispatch;
	}
	// 828554C8: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828554CC: 48000010  b 0x828554dc
	pc = 0x828554DC; continue 'dispatch;
            }
            0x828554D0 => {
    //   block [0x828554D0..0x828554DC)
	// 828554D0: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 828554D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828554D8: 409A0064  bne cr6, 0x8285553c
	if !ctx.cr[6].eq {
	pc = 0x8285553C; continue 'dispatch;
	}
	pc = 0x828554DC; continue 'dispatch;
            }
            0x828554DC => {
    //   block [0x828554DC..0x8285553C)
	// 828554DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828554E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828554E4: 4B9749A5  bl 0x821c9e88
	ctx.lr = 0x828554E8;
	sub_821C9E88(ctx, base);
	// 828554E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828554EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828554F0: 419A004C  beq cr6, 0x8285553c
	if ctx.cr[6].eq {
	pc = 0x8285553C; continue 'dispatch;
	}
	// 828554F4: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828554F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828554FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82855500: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82855504: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82855508: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285550C: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855510: 80EA0078  lwz r7, 0x78(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 82855514: 1D2724A1  mulli r9, r7, 0x24a1
	ctx.r[9].s32 = ((ctx.r[7].s32 as i64 * 9377 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82855518: 38C924DF  addi r6, r9, 0x24df
	ctx.r[6].s64 = ctx.r[9].s64 + 9439;
	// 8285551C: 54C5983E  rotlwi r5, r6, 0x13
	ctx.r[5].u64 = ((ctx.r[6].u32).rotate_left(19)) as u64;
	// 82855520: 90AA0078  stw r5, 0x78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), ctx.r[5].u32 ) };
	// 82855524: 7D455B96  divwu r10, r5, r11
	ctx.r[10].u32 = ctx.r[5].u32 / ctx.r[11].u32;
	// 82855528: 7D2A59D6  mullw r9, r10, r11
	ctx.r[9].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8285552C: 7CA92850  subf r5, r9, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	// 82855530: 4B971331  bl 0x821c6860
	ctx.lr = 0x82855534;
	sub_821C6860(ctx, base);
	// 82855534: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82855538: 48453F20  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x8285553C => {
    //   block [0x8285553C..0x82855548)
	// 8285553C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82855540: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82855544: 48453F14  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82855548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82855548 size=204
    let mut pc: u32 = 0x82855548;
    'dispatch: loop {
        match pc {
            0x82855548 => {
    //   block [0x82855548..0x82855580)
	// 82855548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285554C: 48453EC1  bl 0x82ca940c
	ctx.lr = 0x82855550;
	sub_82CA93D0(ctx, base);
	// 82855550: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82855554: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82855558: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285555C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82855560: 419A00A8  beq cr6, 0x82855608
	if ctx.cr[6].eq {
	pc = 0x82855608; continue 'dispatch;
	}
	// 82855564: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82855568: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285556C: 3BCAFFDF  addi r30, r10, -0x21
	ctx.r[30].s64 = ctx.r[10].s64 + -33;
	// 82855570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82855574: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82855578: 419A0008  beq cr6, 0x82855580
	if ctx.cr[6].eq {
	pc = 0x82855580; continue 'dispatch;
	}
	// 8285557C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82855580; continue 'dispatch;
            }
            0x82855580 => {
    //   block [0x82855580..0x828555C0)
	// 82855580: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82855584: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 82855588: 4B99E7D1  bl 0x821f3d58
	ctx.lr = 0x8285558C;
	sub_821F3D58(ctx, base);
	// 8285558C: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82855590: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82855594: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855598: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285559C: 419A006C  beq cr6, 0x82855608
	if ctx.cr[6].eq {
	pc = 0x82855608; continue 'dispatch;
	}
	// 828555A0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828555A4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828555A8: 419A0060  beq cr6, 0x82855608
	if ctx.cr[6].eq {
	pc = 0x82855608; continue 'dispatch;
	}
	// 828555AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828555B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828555B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828555B8: 419A0008  beq cr6, 0x828555c0
	if ctx.cr[6].eq {
	pc = 0x828555C0; continue 'dispatch;
	}
	// 828555BC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828555C0; continue 'dispatch;
            }
            0x828555C0 => {
    //   block [0x828555C0..0x82855608)
	// 828555C0: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828555C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828555C8: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828555CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828555D0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828555D4: 4B99E785  bl 0x821f3d58
	ctx.lr = 0x828555D8;
	sub_821F3D58(ctx, base);
	// 828555D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828555DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828555E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828555E4: 4BA2623D  bl 0x8227b820
	ctx.lr = 0x828555E8;
	sub_8227B820(ctx, base);
	// 828555E8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828555EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828555F0: 419A0018  beq cr6, 0x82855608
	if ctx.cr[6].eq {
	pc = 0x82855608; continue 'dispatch;
	}
	// 828555F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828555F8: 4B974891  bl 0x821c9e88
	ctx.lr = 0x828555FC;
	sub_821C9E88(ctx, base);
	// 828555FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82855600: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82855604: 409A0008  bne cr6, 0x8285560c
	if !ctx.cr[6].eq {
	pc = 0x8285560C; continue 'dispatch;
	}
	pc = 0x82855608; continue 'dispatch;
            }
            0x82855608 => {
    //   block [0x82855608..0x8285560C)
	// 82855608: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8285560C; continue 'dispatch;
            }
            0x8285560C => {
    //   block [0x8285560C..0x82855614)
	// 8285560C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82855610: 48453E4C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82855618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82855618 size=612
    let mut pc: u32 = 0x82855618;
    'dispatch: loop {
        match pc {
            0x82855618 => {
    //   block [0x82855618..0x82855674)
	// 82855618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285561C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82855620: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82855624: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82855628: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285562C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82855630: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82855634: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855638: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8285563C: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 82855640: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82855644: 419A00F4  beq cr6, 0x82855738
	if ctx.cr[6].eq {
	pc = 0x82855738; continue 'dispatch;
	}
	// 82855648: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285564C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82855650: 419A0024  beq cr6, 0x82855674
	if ctx.cr[6].eq {
	pc = 0x82855674; continue 'dispatch;
	}
	// 82855654: 894A005B  lbz r10, 0x5b(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(91 as u32) ) } as u64;
	// 82855658: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285565C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82855660: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82855664: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855668: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285566C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82855670: 480000CC  b 0x8285573c
	pc = 0x8285573C; continue 'dispatch;
            }
            0x82855674 => {
    //   block [0x82855674..0x82855690)
	// 82855674: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82855678: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285567C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82855680: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82855684: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82855688: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285568C: 40810054  ble 0x828556e0
	if !ctx.cr[0].gt {
	pc = 0x828556E0; continue 'dispatch;
	}
	pc = 0x82855690; continue 'dispatch;
            }
            0x82855690 => {
    //   block [0x82855690..0x828556B0)
	// 82855690: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82855694: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82855698: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285569C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828556A0: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 828556A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828556A8: 41980008  blt cr6, 0x828556b0
	if ctx.cr[6].lt {
	pc = 0x828556B0; continue 'dispatch;
	}
	// 828556AC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x828556B0; continue 'dispatch;
            }
            0x828556B0 => {
    //   block [0x828556B0..0x828556CC)
	// 828556B0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828556B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828556B8: 419A0014  beq cr6, 0x828556cc
	if ctx.cr[6].eq {
	pc = 0x828556CC; continue 'dispatch;
	}
	// 828556BC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828556C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828556C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828556C8: 4800000C  b 0x828556d4
	pc = 0x828556D4; continue 'dispatch;
            }
            0x828556CC => {
    //   block [0x828556CC..0x828556D4)
	// 828556CC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828556D0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828556D4; continue 'dispatch;
            }
            0x828556D4 => {
    //   block [0x828556D4..0x828556E0)
	// 828556D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828556D8: 4199FFB8  bgt cr6, 0x82855690
	if ctx.cr[6].gt {
	pc = 0x82855690; continue 'dispatch;
	}
	// 828556DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828556E0; continue 'dispatch;
            }
            0x828556E0 => {
    //   block [0x828556E0..0x828556FC)
	// 828556E0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828556E4: 419A0040  beq cr6, 0x82855724
	if ctx.cr[6].eq {
	pc = 0x82855724; continue 'dispatch;
	}
	// 828556E8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828556EC: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 828556F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828556F4: 41990008  bgt cr6, 0x828556fc
	if ctx.cr[6].gt {
	pc = 0x828556FC; continue 'dispatch;
	}
	// 828556F8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828556FC; continue 'dispatch;
            }
            0x828556FC => {
    //   block [0x828556FC..0x82855724)
	// 828556FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82855700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82855704: 409A0020  bne cr6, 0x82855724
	if !ctx.cr[6].eq {
	pc = 0x82855724; continue 'dispatch;
	}
	// 82855708: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285570C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82855710: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82855714: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855718: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285571C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82855720: 4800001C  b 0x8285573c
	pc = 0x8285573C; continue 'dispatch;
            }
            0x82855724 => {
    //   block [0x82855724..0x82855738)
	// 82855724: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82855728: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285572C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82855730: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82855734: 48000008  b 0x8285573c
	pc = 0x8285573C; continue 'dispatch;
            }
            0x82855738 => {
    //   block [0x82855738..0x8285573C)
	// 82855738: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8285573C; continue 'dispatch;
            }
            0x8285573C => {
    //   block [0x8285573C..0x828557BC)
	// 8285573C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82855740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82855744: 419A0120  beq cr6, 0x82855864
	if ctx.cr[6].eq {
	pc = 0x82855864; continue 'dispatch;
	}
	// 82855748: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285574C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82855750: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82855754: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82855758: 4E800421  bctrl
	ctx.lr = 0x8285575C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285575C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82855760: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855764: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82855768: 419A00A0  beq cr6, 0x82855808
	if ctx.cr[6].eq {
	pc = 0x82855808; continue 'dispatch;
	}
	// 8285576C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82855770: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82855774: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82855778: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285577C: 4E800421  bctrl
	ctx.lr = 0x82855780;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82855780: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82855784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82855788: 4B9BF371  bl 0x82214af8
	ctx.lr = 0x8285578C;
	sub_82214AF8(ctx, base);
	// 8285578C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82855790: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82855794: 419A0068  beq cr6, 0x828557fc
	if ctx.cr[6].eq {
	pc = 0x828557FC; continue 'dispatch;
	}
	// 82855798: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8285579C: 394B5D20  addi r10, r11, 0x5d20
	ctx.r[10].s64 = ctx.r[11].s64 + 23840;
	// 828557A0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828557A4: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828557A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828557AC: 409A0010  bne cr6, 0x828557bc
	if !ctx.cr[6].eq {
	pc = 0x828557BC; continue 'dispatch;
	}
	// 828557B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828557B4: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 828557B8: 48000008  b 0x828557c0
	pc = 0x828557C0; continue 'dispatch;
            }
            0x828557BC => {
    //   block [0x828557BC..0x828557C0)
	// 828557BC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828557C0; continue 'dispatch;
            }
            0x828557C0 => {
    //   block [0x828557C0..0x828557FC)
	// 828557C0: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 828557C4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828557C8: 4BA778E1  bl 0x822cd0a8
	ctx.lr = 0x828557CC;
	sub_822CD0A8(ctx, base);
	// 828557CC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828557D0: 4B95CBC1  bl 0x821b2390
	ctx.lr = 0x828557D4;
	sub_821B2390(ctx, base);
	// 828557D4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828557D8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828557DC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828557E0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828557E4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828557E8: 806A008C  lwz r3, 0x8c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 828557EC: 4BB4A30D  bl 0x8239faf8
	ctx.lr = 0x828557F0;
	sub_8239FAF8(ctx, base);
	// 828557F0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828557F4: 39092DC8  addi r8, r9, 0x2dc8
	ctx.r[8].s64 = ctx.r[9].s64 + 11720;
	// 828557F8: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	pc = 0x828557FC; continue 'dispatch;
            }
            0x828557FC => {
    //   block [0x828557FC..0x82855808)
	// 828557FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82855800: 4B9BF5D9  bl 0x82214dd8
	ctx.lr = 0x82855804;
	sub_82214DD8(ctx, base);
	// 82855804: 48000060  b 0x82855864
	pc = 0x82855864; continue 'dispatch;
            }
            0x82855808 => {
    //   block [0x82855808..0x82855864)
	// 82855808: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285580C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82855810: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82855814: 4E800421  bctrl
	ctx.lr = 0x82855818;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82855818: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8285581C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82855820: 4B9BF2D9  bl 0x82214af8
	ctx.lr = 0x82855824;
	sub_82214AF8(ctx, base);
	// 82855824: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82855828: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285582C: 419A0038  beq cr6, 0x82855864
	if ctx.cr[6].eq {
	pc = 0x82855864; continue 'dispatch;
	}
	// 82855830: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82855834: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82855838: 394B5D08  addi r10, r11, 0x5d08
	ctx.r[10].s64 = ctx.r[11].s64 + 23816;
	// 8285583C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82855840: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855844: 4B95CB4D  bl 0x821b2390
	ctx.lr = 0x82855848;
	sub_821B2390(ctx, base);
	// 82855848: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 8285584C: 81696AB8  lwz r11, 0x6ab8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82855850: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82855854: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82855858: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8285585C: 8068008C  lwz r3, 0x8c(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(140 as u32) ) } as u64;
	// 82855860: 4BB49F21  bl 0x8239f780
	ctx.lr = 0x82855864;
	sub_8239F780(ctx, base);
            }
            0x82855864 => {
    //   block [0x82855864..0x8285587C)
	// 82855864: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82855868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285586C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82855870: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82855874: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82855878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82855880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82855880 size=360
    let mut pc: u32 = 0x82855880;
    'dispatch: loop {
        match pc {
            0x82855880 => {
    //   block [0x82855880..0x828558D8)
	// 82855880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82855884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82855888: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285588C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82855890: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82855894: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855898: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8285589C: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828558A0: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 828558A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828558A8: 419A00F4  beq cr6, 0x8285599c
	if ctx.cr[6].eq {
	pc = 0x8285599C; continue 'dispatch;
	}
	// 828558AC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828558B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828558B4: 419A0024  beq cr6, 0x828558d8
	if ctx.cr[6].eq {
	pc = 0x828558D8; continue 'dispatch;
	}
	// 828558B8: 892A005B  lbz r9, 0x5b(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(91 as u32) ) } as u64;
	// 828558BC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828558C0: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828558C4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828558C8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828558CC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828558D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828558D4: 480000CC  b 0x828559a0
	pc = 0x828559A0; continue 'dispatch;
            }
            0x828558D8 => {
    //   block [0x828558D8..0x828558F4)
	// 828558D8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828558DC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828558E0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828558E4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828558E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828558EC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828558F0: 40810054  ble 0x82855944
	if !ctx.cr[0].gt {
	pc = 0x82855944; continue 'dispatch;
	}
	pc = 0x828558F4; continue 'dispatch;
            }
            0x828558F4 => {
    //   block [0x828558F4..0x82855914)
	// 828558F4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828558F8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828558FC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82855900: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855904: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 82855908: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285590C: 41980008  blt cr6, 0x82855914
	if ctx.cr[6].lt {
	pc = 0x82855914; continue 'dispatch;
	}
	// 82855910: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82855914; continue 'dispatch;
            }
            0x82855914 => {
    //   block [0x82855914..0x82855930)
	// 82855914: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82855918: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285591C: 419A0014  beq cr6, 0x82855930
	if ctx.cr[6].eq {
	pc = 0x82855930; continue 'dispatch;
	}
	// 82855920: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82855924: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82855928: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285592C: 4800000C  b 0x82855938
	pc = 0x82855938; continue 'dispatch;
            }
            0x82855930 => {
    //   block [0x82855930..0x82855938)
	// 82855930: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82855934: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82855938; continue 'dispatch;
            }
            0x82855938 => {
    //   block [0x82855938..0x82855944)
	// 82855938: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285593C: 4199FFB8  bgt cr6, 0x828558f4
	if ctx.cr[6].gt {
	pc = 0x828558F4; continue 'dispatch;
	}
	// 82855940: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82855944; continue 'dispatch;
            }
            0x82855944 => {
    //   block [0x82855944..0x82855960)
	// 82855944: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82855948: 419A0040  beq cr6, 0x82855988
	if ctx.cr[6].eq {
	pc = 0x82855988; continue 'dispatch;
	}
	// 8285594C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855950: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 82855954: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82855958: 41990008  bgt cr6, 0x82855960
	if ctx.cr[6].gt {
	pc = 0x82855960; continue 'dispatch;
	}
	// 8285595C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82855960; continue 'dispatch;
            }
            0x82855960 => {
    //   block [0x82855960..0x82855988)
	// 82855960: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82855964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82855968: 409A0020  bne cr6, 0x82855988
	if !ctx.cr[6].eq {
	pc = 0x82855988; continue 'dispatch;
	}
	// 8285596C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82855970: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82855974: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82855978: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285597C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82855980: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82855984: 4800001C  b 0x828559a0
	pc = 0x828559A0; continue 'dispatch;
            }
            0x82855988 => {
    //   block [0x82855988..0x8285599C)
	// 82855988: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285598C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855990: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82855994: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82855998: 48000008  b 0x828559a0
	pc = 0x828559A0; continue 'dispatch;
            }
            0x8285599C => {
    //   block [0x8285599C..0x828559A0)
	// 8285599C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828559A0; continue 'dispatch;
            }
            0x828559A0 => {
    //   block [0x828559A0..0x828559D0)
	// 828559A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828559A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828559A8: 419A0028  beq cr6, 0x828559d0
	if ctx.cr[6].eq {
	pc = 0x828559D0; continue 'dispatch;
	}
	// 828559AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828559B0: 3BC30008  addi r30, r3, 8
	ctx.r[30].s64 = ctx.r[3].s64 + 8;
	// 828559B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828559B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828559BC: 4E800421  bctrl
	ctx.lr = 0x828559C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828559C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828559C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828559C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828559CC: 4BB47705  bl 0x8239d0d0
	ctx.lr = 0x828559D0;
	sub_8239D0D0(ctx, base);
            }
            0x828559D0 => {
    //   block [0x828559D0..0x828559E8)
	// 828559D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828559D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828559D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828559DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828559E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828559E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828559E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828559E8 size=360
    let mut pc: u32 = 0x828559E8;
    'dispatch: loop {
        match pc {
            0x828559E8 => {
    //   block [0x828559E8..0x82855A44)
	// 828559E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828559EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828559F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828559F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828559F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828559FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855A00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82855A04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82855A08: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82855A0C: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 82855A10: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82855A14: 419A00F4  beq cr6, 0x82855b08
	if ctx.cr[6].eq {
	pc = 0x82855B08; continue 'dispatch;
	}
	// 82855A18: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82855A1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82855A20: 419A0024  beq cr6, 0x82855a44
	if ctx.cr[6].eq {
	pc = 0x82855A44; continue 'dispatch;
	}
	// 82855A24: 892A005B  lbz r9, 0x5b(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(91 as u32) ) } as u64;
	// 82855A28: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82855A2C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82855A30: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82855A34: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855A38: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82855A3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82855A40: 480000CC  b 0x82855b0c
	pc = 0x82855B0C; continue 'dispatch;
            }
            0x82855A44 => {
    //   block [0x82855A44..0x82855A60)
	// 82855A44: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82855A48: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82855A4C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82855A50: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82855A54: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82855A58: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82855A5C: 40810054  ble 0x82855ab0
	if !ctx.cr[0].gt {
	pc = 0x82855AB0; continue 'dispatch;
	}
	pc = 0x82855A60; continue 'dispatch;
            }
            0x82855A60 => {
    //   block [0x82855A60..0x82855A80)
	// 82855A60: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82855A64: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82855A68: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82855A6C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855A70: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 82855A74: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82855A78: 41980008  blt cr6, 0x82855a80
	if ctx.cr[6].lt {
	pc = 0x82855A80; continue 'dispatch;
	}
	// 82855A7C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82855A80; continue 'dispatch;
            }
            0x82855A80 => {
    //   block [0x82855A80..0x82855A9C)
	// 82855A80: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82855A84: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82855A88: 419A0014  beq cr6, 0x82855a9c
	if ctx.cr[6].eq {
	pc = 0x82855A9C; continue 'dispatch;
	}
	// 82855A8C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82855A90: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82855A94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82855A98: 4800000C  b 0x82855aa4
	pc = 0x82855AA4; continue 'dispatch;
            }
            0x82855A9C => {
    //   block [0x82855A9C..0x82855AA4)
	// 82855A9C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82855AA0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82855AA4; continue 'dispatch;
            }
            0x82855AA4 => {
    //   block [0x82855AA4..0x82855AB0)
	// 82855AA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82855AA8: 4199FFB8  bgt cr6, 0x82855a60
	if ctx.cr[6].gt {
	pc = 0x82855A60; continue 'dispatch;
	}
	// 82855AAC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82855AB0; continue 'dispatch;
            }
            0x82855AB0 => {
    //   block [0x82855AB0..0x82855ACC)
	// 82855AB0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82855AB4: 419A0040  beq cr6, 0x82855af4
	if ctx.cr[6].eq {
	pc = 0x82855AF4; continue 'dispatch;
	}
	// 82855AB8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855ABC: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 82855AC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82855AC4: 41990008  bgt cr6, 0x82855acc
	if ctx.cr[6].gt {
	pc = 0x82855ACC; continue 'dispatch;
	}
	// 82855AC8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82855ACC; continue 'dispatch;
            }
            0x82855ACC => {
    //   block [0x82855ACC..0x82855AF4)
	// 82855ACC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82855AD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82855AD4: 409A0020  bne cr6, 0x82855af4
	if !ctx.cr[6].eq {
	pc = 0x82855AF4; continue 'dispatch;
	}
	// 82855AD8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82855ADC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82855AE0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82855AE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855AE8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82855AEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82855AF0: 4800001C  b 0x82855b0c
	pc = 0x82855B0C; continue 'dispatch;
            }
            0x82855AF4 => {
    //   block [0x82855AF4..0x82855B08)
	// 82855AF4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82855AF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855AFC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82855B00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82855B04: 48000008  b 0x82855b0c
	pc = 0x82855B0C; continue 'dispatch;
            }
            0x82855B08 => {
    //   block [0x82855B08..0x82855B0C)
	// 82855B08: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82855B0C; continue 'dispatch;
            }
            0x82855B0C => {
    //   block [0x82855B0C..0x82855B38)
	// 82855B0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82855B10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82855B14: 419A0024  beq cr6, 0x82855b38
	if ctx.cr[6].eq {
	pc = 0x82855B38; continue 'dispatch;
	}
	// 82855B18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855B1C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855B20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82855B24: 4E800421  bctrl
	ctx.lr = 0x82855B28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82855B28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82855B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82855B30: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82855B34: 4BB4759D  bl 0x8239d0d0
	ctx.lr = 0x82855B38;
	sub_8239D0D0(ctx, base);
            }
            0x82855B38 => {
    //   block [0x82855B38..0x82855B50)
	// 82855B38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82855B3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82855B40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82855B44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82855B48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82855B4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82855B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82855B50 size=8
    let mut pc: u32 = 0x82855B50;
    'dispatch: loop {
        match pc {
            0x82855B50 => {
    //   block [0x82855B50..0x82855B58)
	// 82855B50: 3860002F  li r3, 0x2f
	ctx.r[3].s64 = 47;
	// 82855B54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82855B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82855B58 size=8
    let mut pc: u32 = 0x82855B58;
    'dispatch: loop {
        match pc {
            0x82855B58 => {
    //   block [0x82855B58..0x82855B60)
	// 82855B58: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82855B5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82855B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82855B60 size=252
    let mut pc: u32 = 0x82855B60;
    'dispatch: loop {
        match pc {
            0x82855B60 => {
    //   block [0x82855B60..0x82855B80)
	// 82855B60: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82855B64: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82855B68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82855B6C: 38EAF058  addi r7, r10, -0xfa8
	ctx.r[7].s64 = ctx.r[10].s64 + -4008;
	// 82855B70: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 82855B74: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82855B78: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82855B7C: 38A67088  addi r5, r6, 0x7088
	ctx.r[5].s64 = ctx.r[6].s64 + 28808;
	pc = 0x82855B80; continue 'dispatch;
            }
            0x82855B80 => {
    //   block [0x82855B80..0x82855C5C)
	// 82855B80: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82855B84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82855B88: 7D202828  lwarx r9, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82855B8C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82855B90: 7D20292D  stwcx. r9, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82855B94: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82855B98: 4082FFE8  bne 0x82855b80
	if !ctx.cr[0].eq {
	pc = 0x82855B80; continue 'dispatch;
	}
	// 82855B9C: 3C80820A  lis r4, -0x7df6
	ctx.r[4].s64 = -2113273856;
	// 82855BA0: 9963000D  stb r11, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[11].u8 ) };
	// 82855BA4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82855BA8: 99630010  stb r11, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82855BAC: 39249140  addi r9, r4, -0x6ec0
	ctx.r[9].s64 = ctx.r[4].s64 + -28352;
	// 82855BB0: 99630011  stb r11, 0x11(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(17 as u32), ctx.r[11].u8 ) };
	// 82855BB4: 390AF130  addi r8, r10, -0xed0
	ctx.r[8].s64 = ctx.r[10].s64 + -3792;
	// 82855BB8: 99630012  stb r11, 0x12(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(18 as u32), ctx.r[11].u8 ) };
	// 82855BBC: 99630013  stb r11, 0x13(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(19 as u32), ctx.r[11].u8 ) };
	// 82855BC0: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 82855BC4: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82855BC8: 38C1FFF0  addi r6, r1, -0x10
	ctx.r[6].s64 = ctx.r[1].s64 + -16;
	// 82855BCC: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82855BD0: 38A79484  addi r5, r7, -0x6b7c
	ctx.r[5].s64 = ctx.r[7].s64 + -27516;
	// 82855BD4: 99630015  stb r11, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 82855BD8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82855BDC: 99630016  stb r11, 0x16(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(22 as u32), ctx.r[11].u8 ) };
	// 82855BE0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82855BE4: 99630017  stb r11, 0x17(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(23 as u32), ctx.r[11].u8 ) };
	// 82855BE8: C0079484  lfs f0, -0x6b7c(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82855BEC: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82855C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82855C60 size=220
    let mut pc: u32 = 0x82855C60;
    'dispatch: loop {
        match pc {
            0x82855C60 => {
    //   block [0x82855C60..0x82855C88)
	// 82855C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82855C64: 484537A5  bl 0x82ca9408
	ctx.lr = 0x82855C68;
	sub_82CA93D0(ctx, base);
	// 82855C68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82855C6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82855C70: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82855C74: 3BDF0060  addi r30, r31, 0x60
	ctx.r[30].s64 = ctx.r[31].s64 + 96;
	// 82855C78: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82855C7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82855C80: 419A0008  beq cr6, 0x82855c88
	if ctx.cr[6].eq {
	pc = 0x82855C88; continue 'dispatch;
	}
	// 82855C84: 4B9C60B5  bl 0x8221bd38
	ctx.lr = 0x82855C88;
	sub_8221BD38(ctx, base);
	pc = 0x82855C88; continue 'dispatch;
            }
            0x82855C88 => {
    //   block [0x82855C88..0x82855CD0)
	// 82855C88: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82855C8C: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 82855C90: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82855C94: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82855C98: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82855C9C: 4B961E7D  bl 0x821b7b18
	ctx.lr = 0x82855CA0;
	sub_821B7B18(ctx, base);
	// 82855CA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82855CA4: 387F004C  addi r3, r31, 0x4c
	ctx.r[3].s64 = ctx.r[31].s64 + 76;
	// 82855CA8: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 82855CAC: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 82855CB0: 4B93E189  bl 0x82193e38
	ctx.lr = 0x82855CB4;
	sub_82193E38(ctx, base);
	// 82855CB4: 93BF0050  stw r29, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82855CB8: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 82855CBC: 4B961E5D  bl 0x821b7b18
	ctx.lr = 0x82855CC0;
	sub_821B7B18(ctx, base);
	// 82855CC0: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82855CC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82855CC8: 419A0040  beq cr6, 0x82855d08
	if ctx.cr[6].eq {
	pc = 0x82855D08; continue 'dispatch;
	}
	// 82855CCC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82855CD0; continue 'dispatch;
            }
            0x82855CD0 => {
    //   block [0x82855CD0..0x82855D04)
	// 82855CD0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82855CD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82855CD8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82855CDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82855CE0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82855CE4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82855CE8: 4082FFE8  bne 0x82855cd0
	if !ctx.cr[0].eq {
	pc = 0x82855CD0; continue 'dispatch;
	}
	// 82855CEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82855CF0: 409A0014  bne cr6, 0x82855d04
	if !ctx.cr[6].eq {
	pc = 0x82855D04; continue 'dispatch;
	}
	// 82855CF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855CF8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855CFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82855D00: 4E800421  bctrl
	ctx.lr = 0x82855D04;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82855D04 => {
    //   block [0x82855D04..0x82855D08)
	// 82855D04: 93BF003C  stw r29, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[29].u32 ) };
	pc = 0x82855D08; continue 'dispatch;
            }
            0x82855D08 => {
    //   block [0x82855D08..0x82855D34)
	// 82855D08: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82855D0C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82855D10: 394BF058  addi r10, r11, -0xfa8
	ctx.r[10].s64 = ctx.r[11].s64 + -4008;
	// 82855D14: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82855D18: 4B9BF0C1  bl 0x82214dd8
	ctx.lr = 0x82855D1C;
	sub_82214DD8(ctx, base);
	// 82855D1C: 578907FE  clrlwi r9, r28, 0x1f
	ctx.r[9].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	// 82855D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82855D24: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82855D28: 419A000C  beq cr6, 0x82855d34
	if ctx.cr[6].eq {
	pc = 0x82855D34; continue 'dispatch;
	}
	// 82855D2C: 4B9C600D  bl 0x8221bd38
	ctx.lr = 0x82855D30;
	sub_8221BD38(ctx, base);
	// 82855D30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82855D34; continue 'dispatch;
            }
            0x82855D34 => {
    //   block [0x82855D34..0x82855D3C)
	// 82855D34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82855D38: 48453720  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82855D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82855D40 size=812
    let mut pc: u32 = 0x82855D40;
    'dispatch: loop {
        match pc {
            0x82855D40 => {
    //   block [0x82855D40..0x82855DA0)
	// 82855D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82855D44: 484536C9  bl 0x82ca940c
	ctx.lr = 0x82855D48;
	sub_82CA93D0(ctx, base);
	// 82855D48: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82855D4C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82855D50: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82855D54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82855D58: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82855D5C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82855D60: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82855D64: D3FE0034  stfs f31, 0x34(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82855D68: 9BBE0011  stb r29, 0x11(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(17 as u32), ctx.r[29].u8 ) };
	// 82855D6C: 4B9C94ED  bl 0x8221f258
	ctx.lr = 0x82855D70;
	sub_8221F258(ctx, base);
	// 82855D70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82855D74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82855D78: 419A0064  beq cr6, 0x82855ddc
	if ctx.cr[6].eq {
	pc = 0x82855DDC; continue 'dispatch;
	}
	// 82855D7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82855D80: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82855D84: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 82855D88: 390B0B7C  addi r8, r11, 0xb7c
	ctx.r[8].s64 = ctx.r[11].s64 + 2940;
	// 82855D8C: 38C77088  addi r6, r7, 0x7088
	ctx.r[6].s64 = ctx.r[7].s64 + 28808;
	// 82855D90: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82855D94: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82855D98: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82855D9C: 93E30010  stw r31, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	pc = 0x82855DA0; continue 'dispatch;
            }
            0x82855DA0 => {
    //   block [0x82855DA0..0x82855DDC)
	// 82855DA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82855DA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82855DA8: 7D403028  lwarx r10, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82855DAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82855DB0: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82855DB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82855DB8: 4082FFE8  bne 0x82855da0
	if !ctx.cr[0].eq {
	pc = 0x82855DA0; continue 'dispatch;
	}
	// 82855DBC: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 82855DC0: 9BE30014  stb r31, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[31].u8 ) };
	// 82855DC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82855DC8: 93E30018  stw r31, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 82855DCC: 81656B38  lwz r11, 0x6b38(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(27448 as u32) ) } as u64;
	// 82855DD0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82855DD4: 91656B38  stw r11, 0x6b38(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(27448 as u32), ctx.r[11].u32 ) };
	// 82855DD8: 48000008  b 0x82855de0
	pc = 0x82855DE0; continue 'dispatch;
            }
            0x82855DDC => {
    //   block [0x82855DDC..0x82855DE0)
	// 82855DDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x82855DE0; continue 'dispatch;
            }
            0x82855DE0 => {
    //   block [0x82855DE0..0x82855E64)
	// 82855DE0: 387E0058  addi r3, r30, 0x58
	ctx.r[3].s64 = ctx.r[30].s64 + 88;
	// 82855DE4: 4BD80CBD  bl 0x825d6aa0
	ctx.lr = 0x82855DE8;
	sub_825D6AA0(ctx, base);
	// 82855DE8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82855DEC: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855DF0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82855DF4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82855DF8: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82855DFC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855E00: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855E04: 4B9DC975  bl 0x82232778
	ctx.lr = 0x82855E08;
	sub_82232778(ctx, base);
	// 82855E08: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82855E0C: 9BFE0015  stb r31, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[31].u8 ) };
	// 82855E10: 9BFE0014  stb r31, 0x14(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u8 ) };
	// 82855E14: 987E0012  stb r3, 0x12(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(18 as u32), ctx.r[3].u8 ) };
	// 82855E18: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82855E1C: 409A0244  bne cr6, 0x82856060
	if !ctx.cr[6].eq {
	pc = 0x82856060; continue 'dispatch;
	}
	// 82855E20: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855E24: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82855E28: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82855E2C: 552837FE  rlwinm r8, r9, 6, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x03FFFFFFu64;
	// 82855E30: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82855E34: 419A00F4  beq cr6, 0x82855f28
	if ctx.cr[6].eq {
	pc = 0x82855F28; continue 'dispatch;
	}
	// 82855E38: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82855E3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82855E40: 419A0024  beq cr6, 0x82855e64
	if ctx.cr[6].eq {
	pc = 0x82855E64; continue 'dispatch;
	}
	// 82855E44: 894A003A  lbz r10, 0x3a(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(58 as u32) ) } as u64;
	// 82855E48: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82855E4C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82855E50: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82855E54: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855E58: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82855E5C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82855E60: 480000CC  b 0x82855f2c
	pc = 0x82855F2C; continue 'dispatch;
            }
            0x82855E64 => {
    //   block [0x82855E64..0x82855E80)
	// 82855E64: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82855E68: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82855E6C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82855E70: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82855E74: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82855E78: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82855E7C: 40810054  ble 0x82855ed0
	if !ctx.cr[0].gt {
	pc = 0x82855ED0; continue 'dispatch;
	}
	pc = 0x82855E80; continue 'dispatch;
            }
            0x82855E80 => {
    //   block [0x82855E80..0x82855EA0)
	// 82855E80: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82855E84: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82855E88: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82855E8C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855E90: 2F07003A  cmpwi cr6, r7, 0x3a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 58, &mut ctx.xer);
	// 82855E94: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82855E98: 41980008  blt cr6, 0x82855ea0
	if ctx.cr[6].lt {
	pc = 0x82855EA0; continue 'dispatch;
	}
	// 82855E9C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82855EA0; continue 'dispatch;
            }
            0x82855EA0 => {
    //   block [0x82855EA0..0x82855EBC)
	// 82855EA0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82855EA4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82855EA8: 419A0014  beq cr6, 0x82855ebc
	if ctx.cr[6].eq {
	pc = 0x82855EBC; continue 'dispatch;
	}
	// 82855EAC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82855EB0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82855EB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82855EB8: 4800000C  b 0x82855ec4
	pc = 0x82855EC4; continue 'dispatch;
            }
            0x82855EBC => {
    //   block [0x82855EBC..0x82855EC4)
	// 82855EBC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82855EC0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82855EC4; continue 'dispatch;
            }
            0x82855EC4 => {
    //   block [0x82855EC4..0x82855ED0)
	// 82855EC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82855EC8: 4199FFB8  bgt cr6, 0x82855e80
	if ctx.cr[6].gt {
	pc = 0x82855E80; continue 'dispatch;
	}
	// 82855ECC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82855ED0; continue 'dispatch;
            }
            0x82855ED0 => {
    //   block [0x82855ED0..0x82855EEC)
	// 82855ED0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82855ED4: 419A0040  beq cr6, 0x82855f14
	if ctx.cr[6].eq {
	pc = 0x82855F14; continue 'dispatch;
	}
	// 82855ED8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855EDC: 2F0B003A  cmpwi cr6, r11, 0x3a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 58, &mut ctx.xer);
	// 82855EE0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82855EE4: 41990008  bgt cr6, 0x82855eec
	if ctx.cr[6].gt {
	pc = 0x82855EEC; continue 'dispatch;
	}
	// 82855EE8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82855EEC; continue 'dispatch;
            }
            0x82855EEC => {
    //   block [0x82855EEC..0x82855F14)
	// 82855EEC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82855EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82855EF4: 409A0020  bne cr6, 0x82855f14
	if !ctx.cr[6].eq {
	pc = 0x82855F14; continue 'dispatch;
	}
	// 82855EF8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82855EFC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82855F00: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82855F04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855F08: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82855F0C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82855F10: 4800001C  b 0x82855f2c
	pc = 0x82855F2C; continue 'dispatch;
            }
            0x82855F14 => {
    //   block [0x82855F14..0x82855F28)
	// 82855F14: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82855F18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855F1C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82855F20: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82855F24: 48000008  b 0x82855f2c
	pc = 0x82855F2C; continue 'dispatch;
            }
            0x82855F28 => {
    //   block [0x82855F28..0x82855F2C)
	// 82855F28: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82855F2C; continue 'dispatch;
            }
            0x82855F2C => {
    //   block [0x82855F2C..0x82855F3C)
	// 82855F2C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82855F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82855F34: 419A0008  beq cr6, 0x82855f3c
	if ctx.cr[6].eq {
	pc = 0x82855F3C; continue 'dispatch;
	}
	// 82855F38: 9BAA0072  stb r29, 0x72(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(114 as u32), ctx.r[29].u8 ) };
	pc = 0x82855F3C; continue 'dispatch;
            }
            0x82855F3C => {
    //   block [0x82855F3C..0x82855F80)
	// 82855F3C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855F40: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82855F44: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82855F48: 552827FE  rlwinm r8, r9, 4, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0FFFFFFFu64;
	// 82855F4C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82855F50: 419A00F4  beq cr6, 0x82856044
	if ctx.cr[6].eq {
	pc = 0x82856044; continue 'dispatch;
	}
	// 82855F54: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82855F58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82855F5C: 419A0024  beq cr6, 0x82855f80
	if ctx.cr[6].eq {
	pc = 0x82855F80; continue 'dispatch;
	}
	// 82855F60: 894A003C  lbz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 82855F64: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82855F68: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82855F6C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82855F70: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82855F74: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82855F78: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82855F7C: 480000CC  b 0x82856048
	pc = 0x82856048; continue 'dispatch;
            }
            0x82855F80 => {
    //   block [0x82855F80..0x82855F9C)
	// 82855F80: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82855F84: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82855F88: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82855F8C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82855F90: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82855F94: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82855F98: 40810054  ble 0x82855fec
	if !ctx.cr[0].gt {
	pc = 0x82855FEC; continue 'dispatch;
	}
	pc = 0x82855F9C; continue 'dispatch;
            }
            0x82855F9C => {
    //   block [0x82855F9C..0x82855FBC)
	// 82855F9C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82855FA0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82855FA4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82855FA8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855FAC: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 82855FB0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82855FB4: 41980008  blt cr6, 0x82855fbc
	if ctx.cr[6].lt {
	pc = 0x82855FBC; continue 'dispatch;
	}
	// 82855FB8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82855FBC; continue 'dispatch;
            }
            0x82855FBC => {
    //   block [0x82855FBC..0x82855FD8)
	// 82855FBC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82855FC0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82855FC4: 419A0014  beq cr6, 0x82855fd8
	if ctx.cr[6].eq {
	pc = 0x82855FD8; continue 'dispatch;
	}
	// 82855FC8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82855FCC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82855FD0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82855FD4: 4800000C  b 0x82855fe0
	pc = 0x82855FE0; continue 'dispatch;
            }
            0x82855FD8 => {
    //   block [0x82855FD8..0x82855FE0)
	// 82855FD8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82855FDC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82855FE0; continue 'dispatch;
            }
            0x82855FE0 => {
    //   block [0x82855FE0..0x82855FEC)
	// 82855FE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82855FE4: 4199FFB8  bgt cr6, 0x82855f9c
	if ctx.cr[6].gt {
	pc = 0x82855F9C; continue 'dispatch;
	}
	// 82855FE8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82855FEC; continue 'dispatch;
            }
            0x82855FEC => {
    //   block [0x82855FEC..0x82856008)
	// 82855FEC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82855FF0: 419A0040  beq cr6, 0x82856030
	if ctx.cr[6].eq {
	pc = 0x82856030; continue 'dispatch;
	}
	// 82855FF4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82855FF8: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 82855FFC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82856000: 41990008  bgt cr6, 0x82856008
	if ctx.cr[6].gt {
	pc = 0x82856008; continue 'dispatch;
	}
	// 82856004: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82856008; continue 'dispatch;
            }
            0x82856008 => {
    //   block [0x82856008..0x82856030)
	// 82856008: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285600C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856010: 409A0020  bne cr6, 0x82856030
	if !ctx.cr[6].eq {
	pc = 0x82856030; continue 'dispatch;
	}
	// 82856014: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82856018: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285601C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82856020: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856024: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82856028: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8285602C: 4800001C  b 0x82856048
	pc = 0x82856048; continue 'dispatch;
            }
            0x82856030 => {
    //   block [0x82856030..0x82856044)
	// 82856030: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82856034: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856038: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8285603C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82856040: 48000008  b 0x82856048
	pc = 0x82856048; continue 'dispatch;
            }
            0x82856044 => {
    //   block [0x82856044..0x82856048)
	// 82856044: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82856048; continue 'dispatch;
            }
            0x82856048 => {
    //   block [0x82856048..0x82856060)
	// 82856048: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285604C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856050: 419A0010  beq cr6, 0x82856060
	if ctx.cr[6].eq {
	pc = 0x82856060; continue 'dispatch;
	}
	// 82856054: C00A00F4  lfs f0, 0xf4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82856058: D01E0038  stfs f0, 0x38(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8285605C: D3EA00F4  stfs f31, 0xf4(r10)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(244 as u32), tmp.u32 ) };
	pc = 0x82856060; continue 'dispatch;
            }
            0x82856060 => {
    //   block [0x82856060..0x8285606C)
	// 82856060: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82856064: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82856068: 484533F4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82856070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82856070 size=1076
    let mut pc: u32 = 0x82856070;
    'dispatch: loop {
        match pc {
            0x82856070 => {
    //   block [0x82856070..0x828560A4)
	// 82856070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82856074: 48453395  bl 0x82ca9408
	ctx.lr = 0x82856078;
	sub_82CA93D0(ctx, base);
	// 82856078: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285607C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82856080: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82856084: 3BFC0058  addi r31, r28, 0x58
	ctx.r[31].s64 = ctx.r[28].s64 + 88;
	// 82856088: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285608C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82856090: 419A0014  beq cr6, 0x828560a4
	if ctx.cr[6].eq {
	pc = 0x828560A4; continue 'dispatch;
	}
	// 82856094: 48097C4D  bl 0x828edce0
	ctx.lr = 0x82856098;
	sub_828EDCE0(ctx, base);
	// 82856098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285609C: 4B961A7D  bl 0x821b7b18
	ctx.lr = 0x828560A0;
	sub_821B7B18(ctx, base);
	// 828560A0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x828560A4; continue 'dispatch;
            }
            0x828560A4 => {
    //   block [0x828560A4..0x828560F4)
	// 828560A4: 897C0012  lbz r11, 0x12(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(18 as u32) ) } as u64;
	// 828560A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828560AC: 409A03F0  bne cr6, 0x8285649c
	if !ctx.cr[6].eq {
	pc = 0x8285649C; continue 'dispatch;
	}
	// 828560B0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828560B4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828560B8: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828560BC: 552837FE  rlwinm r8, r9, 6, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x03FFFFFFu64;
	// 828560C0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828560C4: 419A00F4  beq cr6, 0x828561b8
	if ctx.cr[6].eq {
	pc = 0x828561B8; continue 'dispatch;
	}
	// 828560C8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828560CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828560D0: 419A0024  beq cr6, 0x828560f4
	if ctx.cr[6].eq {
	pc = 0x828560F4; continue 'dispatch;
	}
	// 828560D4: 894A003A  lbz r10, 0x3a(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(58 as u32) ) } as u64;
	// 828560D8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828560DC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828560E0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828560E4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828560E8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828560EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828560F0: 480000CC  b 0x828561bc
	pc = 0x828561BC; continue 'dispatch;
            }
            0x828560F4 => {
    //   block [0x828560F4..0x82856110)
	// 828560F4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828560F8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828560FC: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82856100: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82856104: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82856108: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285610C: 40810054  ble 0x82856160
	if !ctx.cr[0].gt {
	pc = 0x82856160; continue 'dispatch;
	}
	pc = 0x82856110; continue 'dispatch;
            }
            0x82856110 => {
    //   block [0x82856110..0x82856130)
	// 82856110: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82856114: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82856118: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285611C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856120: 2F07003A  cmpwi cr6, r7, 0x3a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 58, &mut ctx.xer);
	// 82856124: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82856128: 41980008  blt cr6, 0x82856130
	if ctx.cr[6].lt {
	pc = 0x82856130; continue 'dispatch;
	}
	// 8285612C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82856130; continue 'dispatch;
            }
            0x82856130 => {
    //   block [0x82856130..0x8285614C)
	// 82856130: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82856134: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82856138: 419A0014  beq cr6, 0x8285614c
	if ctx.cr[6].eq {
	pc = 0x8285614C; continue 'dispatch;
	}
	// 8285613C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82856140: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82856144: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82856148: 4800000C  b 0x82856154
	pc = 0x82856154; continue 'dispatch;
            }
            0x8285614C => {
    //   block [0x8285614C..0x82856154)
	// 8285614C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82856150: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82856154; continue 'dispatch;
            }
            0x82856154 => {
    //   block [0x82856154..0x82856160)
	// 82856154: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856158: 4199FFB8  bgt cr6, 0x82856110
	if ctx.cr[6].gt {
	pc = 0x82856110; continue 'dispatch;
	}
	// 8285615C: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	pc = 0x82856160; continue 'dispatch;
            }
            0x82856160 => {
    //   block [0x82856160..0x8285617C)
	// 82856160: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82856164: 419A0040  beq cr6, 0x828561a4
	if ctx.cr[6].eq {
	pc = 0x828561A4; continue 'dispatch;
	}
	// 82856168: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285616C: 2F0B003A  cmpwi cr6, r11, 0x3a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 58, &mut ctx.xer);
	// 82856170: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82856174: 41990008  bgt cr6, 0x8285617c
	if ctx.cr[6].gt {
	pc = 0x8285617C; continue 'dispatch;
	}
	// 82856178: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8285617C; continue 'dispatch;
            }
            0x8285617C => {
    //   block [0x8285617C..0x828561A4)
	// 8285617C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82856180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856184: 409A0020  bne cr6, 0x828561a4
	if !ctx.cr[6].eq {
	pc = 0x828561A4; continue 'dispatch;
	}
	// 82856188: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 8285618C: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82856190: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82856194: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856198: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8285619C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828561A0: 4800001C  b 0x828561bc
	pc = 0x828561BC; continue 'dispatch;
            }
            0x828561A4 => {
    //   block [0x828561A4..0x828561B8)
	// 828561A4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828561A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828561AC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828561B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828561B4: 48000008  b 0x828561bc
	pc = 0x828561BC; continue 'dispatch;
            }
            0x828561B8 => {
    //   block [0x828561B8..0x828561BC)
	// 828561B8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828561BC; continue 'dispatch;
            }
            0x828561BC => {
    //   block [0x828561BC..0x828561CC)
	// 828561BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828561C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828561C4: 419A0008  beq cr6, 0x828561cc
	if ctx.cr[6].eq {
	pc = 0x828561CC; continue 'dispatch;
	}
	// 828561C8: 9BAA0072  stb r29, 0x72(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(114 as u32), ctx.r[29].u8 ) };
	pc = 0x828561CC; continue 'dispatch;
            }
            0x828561CC => {
    //   block [0x828561CC..0x82856210)
	// 828561CC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828561D0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828561D4: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828561D8: 552827FE  rlwinm r8, r9, 4, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0FFFFFFFu64;
	// 828561DC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828561E0: 419A00F4  beq cr6, 0x828562d4
	if ctx.cr[6].eq {
	pc = 0x828562D4; continue 'dispatch;
	}
	// 828561E4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828561E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828561EC: 419A0024  beq cr6, 0x82856210
	if ctx.cr[6].eq {
	pc = 0x82856210; continue 'dispatch;
	}
	// 828561F0: 894A003C  lbz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 828561F4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828561F8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828561FC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82856200: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856204: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82856208: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285620C: 480000CC  b 0x828562d8
	pc = 0x828562D8; continue 'dispatch;
            }
            0x82856210 => {
    //   block [0x82856210..0x8285622C)
	// 82856210: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82856214: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82856218: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 8285621C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82856220: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82856224: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856228: 40810054  ble 0x8285627c
	if !ctx.cr[0].gt {
	pc = 0x8285627C; continue 'dispatch;
	}
	pc = 0x8285622C; continue 'dispatch;
            }
            0x8285622C => {
    //   block [0x8285622C..0x8285624C)
	// 8285622C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82856230: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82856234: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82856238: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285623C: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 82856240: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82856244: 41980008  blt cr6, 0x8285624c
	if ctx.cr[6].lt {
	pc = 0x8285624C; continue 'dispatch;
	}
	// 82856248: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8285624C; continue 'dispatch;
            }
            0x8285624C => {
    //   block [0x8285624C..0x82856268)
	// 8285624C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82856250: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82856254: 419A0014  beq cr6, 0x82856268
	if ctx.cr[6].eq {
	pc = 0x82856268; continue 'dispatch;
	}
	// 82856258: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285625C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82856260: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82856264: 4800000C  b 0x82856270
	pc = 0x82856270; continue 'dispatch;
            }
            0x82856268 => {
    //   block [0x82856268..0x82856270)
	// 82856268: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285626C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82856270; continue 'dispatch;
            }
            0x82856270 => {
    //   block [0x82856270..0x8285627C)
	// 82856270: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856274: 4199FFB8  bgt cr6, 0x8285622c
	if ctx.cr[6].gt {
	pc = 0x8285622C; continue 'dispatch;
	}
	// 82856278: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	pc = 0x8285627C; continue 'dispatch;
            }
            0x8285627C => {
    //   block [0x8285627C..0x82856298)
	// 8285627C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82856280: 419A0040  beq cr6, 0x828562c0
	if ctx.cr[6].eq {
	pc = 0x828562C0; continue 'dispatch;
	}
	// 82856284: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856288: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 8285628C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82856290: 41990008  bgt cr6, 0x82856298
	if ctx.cr[6].gt {
	pc = 0x82856298; continue 'dispatch;
	}
	// 82856294: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82856298; continue 'dispatch;
            }
            0x82856298 => {
    //   block [0x82856298..0x828562C0)
	// 82856298: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285629C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828562A0: 409A0020  bne cr6, 0x828562c0
	if !ctx.cr[6].eq {
	pc = 0x828562C0; continue 'dispatch;
	}
	// 828562A4: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828562A8: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 828562AC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828562B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828562B4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828562B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828562BC: 4800001C  b 0x828562d8
	pc = 0x828562D8; continue 'dispatch;
            }
            0x828562C0 => {
    //   block [0x828562C0..0x828562D4)
	// 828562C0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828562C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828562C8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828562CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828562D0: 48000008  b 0x828562d8
	pc = 0x828562D8; continue 'dispatch;
            }
            0x828562D4 => {
    //   block [0x828562D4..0x828562D8)
	// 828562D4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828562D8; continue 'dispatch;
            }
            0x828562D8 => {
    //   block [0x828562D8..0x828562EC)
	// 828562D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828562DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828562E0: 419A000C  beq cr6, 0x828562ec
	if ctx.cr[6].eq {
	pc = 0x828562EC; continue 'dispatch;
	}
	// 828562E4: C01C0038  lfs f0, 0x38(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828562E8: D00A00F4  stfs f0, 0xf4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(244 as u32), tmp.u32 ) };
	pc = 0x828562EC; continue 'dispatch;
            }
            0x828562EC => {
    //   block [0x828562EC..0x82856330)
	// 828562EC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828562F0: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828562F4: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828562F8: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 828562FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82856300: 419A00F4  beq cr6, 0x828563f4
	if ctx.cr[6].eq {
	pc = 0x828563F4; continue 'dispatch;
	}
	// 82856304: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82856308: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285630C: 419A0024  beq cr6, 0x82856330
	if ctx.cr[6].eq {
	pc = 0x82856330; continue 'dispatch;
	}
	// 82856310: 892A0031  lbz r9, 0x31(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 82856314: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82856318: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8285631C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82856320: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856324: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82856328: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285632C: 480000CC  b 0x828563f8
	pc = 0x828563F8; continue 'dispatch;
            }
            0x82856330 => {
    //   block [0x82856330..0x8285634C)
	// 82856330: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82856334: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82856338: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 8285633C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82856340: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82856344: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856348: 40810054  ble 0x8285639c
	if !ctx.cr[0].gt {
	pc = 0x8285639C; continue 'dispatch;
	}
	pc = 0x8285634C; continue 'dispatch;
            }
            0x8285634C => {
    //   block [0x8285634C..0x8285636C)
	// 8285634C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82856350: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82856354: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82856358: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285635C: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 82856360: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82856364: 41980008  blt cr6, 0x8285636c
	if ctx.cr[6].lt {
	pc = 0x8285636C; continue 'dispatch;
	}
	// 82856368: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8285636C; continue 'dispatch;
            }
            0x8285636C => {
    //   block [0x8285636C..0x82856388)
	// 8285636C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82856370: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82856374: 419A0014  beq cr6, 0x82856388
	if ctx.cr[6].eq {
	pc = 0x82856388; continue 'dispatch;
	}
	// 82856378: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285637C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82856380: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82856384: 4800000C  b 0x82856390
	pc = 0x82856390; continue 'dispatch;
            }
            0x82856388 => {
    //   block [0x82856388..0x82856390)
	// 82856388: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285638C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82856390; continue 'dispatch;
            }
            0x82856390 => {
    //   block [0x82856390..0x8285639C)
	// 82856390: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856394: 4199FFB8  bgt cr6, 0x8285634c
	if ctx.cr[6].gt {
	pc = 0x8285634C; continue 'dispatch;
	}
	// 82856398: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	pc = 0x8285639C; continue 'dispatch;
            }
            0x8285639C => {
    //   block [0x8285639C..0x828563B8)
	// 8285639C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828563A0: 419A0040  beq cr6, 0x828563e0
	if ctx.cr[6].eq {
	pc = 0x828563E0; continue 'dispatch;
	}
	// 828563A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828563A8: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 828563AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828563B0: 41990008  bgt cr6, 0x828563b8
	if ctx.cr[6].gt {
	pc = 0x828563B8; continue 'dispatch;
	}
	// 828563B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828563B8; continue 'dispatch;
            }
            0x828563B8 => {
    //   block [0x828563B8..0x828563E0)
	// 828563B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828563BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828563C0: 409A0020  bne cr6, 0x828563e0
	if !ctx.cr[6].eq {
	pc = 0x828563E0; continue 'dispatch;
	}
	// 828563C4: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828563C8: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 828563CC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828563D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828563D4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828563D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828563DC: 4800001C  b 0x828563f8
	pc = 0x828563F8; continue 'dispatch;
            }
            0x828563E0 => {
    //   block [0x828563E0..0x828563F4)
	// 828563E0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828563E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828563E8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828563EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828563F0: 48000008  b 0x828563f8
	pc = 0x828563F8; continue 'dispatch;
            }
            0x828563F4 => {
    //   block [0x828563F4..0x828563F8)
	// 828563F4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828563F8; continue 'dispatch;
            }
            0x828563F8 => {
    //   block [0x828563F8..0x82856428)
	// 828563F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828563FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856400: 419A0050  beq cr6, 0x82856450
	if ctx.cr[6].eq {
	pc = 0x82856450; continue 'dispatch;
	}
	// 82856404: 817C0054  lwz r11, 0x54(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) } as u64;
	// 82856408: 3BFC004C  addi r31, r28, 0x4c
	ctx.r[31].s64 = ctx.r[28].s64 + 76;
	// 8285640C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856410: 41980018  blt cr6, 0x82856428
	if ctx.cr[6].lt {
	pc = 0x82856428; continue 'dispatch;
	}
	// 82856414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82856418: 4BA42321  bl 0x82298738
	ctx.lr = 0x8285641C;
	sub_82298738(ctx, base);
	// 8285641C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82856420: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82856424: 409A0008  bne cr6, 0x8285642c
	if !ctx.cr[6].eq {
	pc = 0x8285642C; continue 'dispatch;
	}
	pc = 0x82856428; continue 'dispatch;
            }
            0x82856428 => {
    //   block [0x82856428..0x8285642C)
	// 82856428: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8285642C; continue 'dispatch;
            }
            0x8285642C => {
    //   block [0x8285642C..0x82856450)
	// 8285642C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82856430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856434: 419A001C  beq cr6, 0x82856450
	if ctx.cr[6].eq {
	pc = 0x82856450; continue 'dispatch;
	}
	// 82856438: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285643C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82856440: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82856444: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82856448: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285644C: 4E800421  bctrl
	ctx.lr = 0x82856450;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82856450 => {
    //   block [0x82856450..0x8285649C)
	// 82856450: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856454: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82856458: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8285645C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856460: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 82856464: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82856468: 4E800421  bctrl
	ctx.lr = 0x8285646C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285646C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82856470: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 82856474: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856478: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285647C: 39004000  li r8, 0x4000
	ctx.r[8].s64 = 16384;
	// 82856480: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
            }
            0x8285649C => {
    //   block [0x8285649C..0x828564A4)
	// 8285649C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828564A0: 48452FB8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828564A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828564A8 size=1448
    let mut pc: u32 = 0x828564A8;
    'dispatch: loop {
        match pc {
            0x828564A8 => {
    //   block [0x828564A8..0x82856518)
	// 828564A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828564AC: 48452F55  bl 0x82ca9400
	ctx.lr = 0x828564B0;
	sub_82CA93D0(ctx, base);
	// 828564B0: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 828564B4: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 828564B8: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828564BC: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828564C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828564C4: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828564C8: 4B9B1329  bl 0x822077f0
	ctx.lr = 0x828564CC;
	sub_822077F0(ctx, base);
	// 828564CC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828564D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828564D4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828564D8: 3B8BB730  addi r28, r11, -0x48d0
	ctx.r[28].s64 = ctx.r[11].s64 + -18640;
	// 828564DC: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 828564E0: C80A9660  lfd f0, -0x69a0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 828564E4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828564E8: FDA10024  fdiv f13, f1, f0
	ctx.f[13].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 828564EC: C01D0034  lfs f0, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828564F0: C3FCDD54  lfs f31, -0x22ac(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-8876 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828564F4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828564F8: FFA06818  frsp f29, f13
	ctx.f[29].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828564FC: 4099001C  ble cr6, 0x82856518
	if !ctx.cr[6].gt {
	pc = 0x82856518; continue 'dispatch;
	}
	// 82856500: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 82856504: D01D0034  stfs f0, 0x34(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82856508: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8285650C: 4199000C  bgt cr6, 0x82856518
	if ctx.cr[6].gt {
	pc = 0x82856518; continue 'dispatch;
	}
	// 82856510: D3FD0034  stfs f31, 0x34(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82856514: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82856518; continue 'dispatch;
            }
            0x82856518 => {
    //   block [0x82856518..0x8285652C)
	// 82856518: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285651C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856520: 419A000C  beq cr6, 0x8285652c
	if ctx.cr[6].eq {
	pc = 0x8285652C; continue 'dispatch;
	}
	// 82856524: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82856528: 997D0011  stb r11, 0x11(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(17 as u32), ctx.r[11].u8 ) };
	pc = 0x8285652C; continue 'dispatch;
            }
            0x8285652C => {
    //   block [0x8285652C..0x82856598)
	// 8285652C: 897D0011  lbz r11, 0x11(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(17 as u32) ) } as u64;
	// 82856530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856534: 419A02E4  beq cr6, 0x82856818
	if ctx.cr[6].eq {
	pc = 0x82856818; continue 'dispatch;
	}
	// 82856538: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 8285653C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856540: 419A02D8  beq cr6, 0x82856818
	if ctx.cr[6].eq {
	pc = 0x82856818; continue 'dispatch;
	}
	// 82856544: 815D0068  lwz r10, 0x68(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 82856548: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8285654C: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856550: 418202C8  beq 0x82856818
	if ctx.cr[0].eq {
	pc = 0x82856818; continue 'dispatch;
	}
	// 82856554: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856558: 9B7D0011  stb r27, 0x11(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(17 as u32), ctx.r[27].u8 ) };
	// 8285655C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82856560: 5549A7FE  rlwinm r9, r10, 0x14, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000FFFu64;
	// 82856564: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82856568: 419A00F4  beq cr6, 0x8285665c
	if ctx.cr[6].eq {
	pc = 0x8285665C; continue 'dispatch;
	}
	// 8285656C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82856570: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82856574: 419A0024  beq cr6, 0x82856598
	if ctx.cr[6].eq {
	pc = 0x82856598; continue 'dispatch;
	}
	// 82856578: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 8285657C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82856580: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82856584: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82856588: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285658C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82856590: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82856594: 480000D0  b 0x82856664
	pc = 0x82856664; continue 'dispatch;
            }
            0x82856598 => {
    //   block [0x82856598..0x828565B4)
	// 82856598: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285659C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828565A0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828565A4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828565A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828565AC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828565B0: 40810054  ble 0x82856604
	if !ctx.cr[0].gt {
	pc = 0x82856604; continue 'dispatch;
	}
	pc = 0x828565B4; continue 'dispatch;
            }
            0x828565B4 => {
    //   block [0x828565B4..0x828565D4)
	// 828565B4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828565B8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828565BC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828565C0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828565C4: 2F07002C  cmpwi cr6, r7, 0x2c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 44, &mut ctx.xer);
	// 828565C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828565CC: 41980008  blt cr6, 0x828565d4
	if ctx.cr[6].lt {
	pc = 0x828565D4; continue 'dispatch;
	}
	// 828565D0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x828565D4; continue 'dispatch;
            }
            0x828565D4 => {
    //   block [0x828565D4..0x828565F0)
	// 828565D4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828565D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828565DC: 419A0014  beq cr6, 0x828565f0
	if ctx.cr[6].eq {
	pc = 0x828565F0; continue 'dispatch;
	}
	// 828565E0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828565E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828565E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828565EC: 4800000C  b 0x828565f8
	pc = 0x828565F8; continue 'dispatch;
            }
            0x828565F0 => {
    //   block [0x828565F0..0x828565F8)
	// 828565F0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828565F4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828565F8; continue 'dispatch;
            }
            0x828565F8 => {
    //   block [0x828565F8..0x82856604)
	// 828565F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828565FC: 4199FFB8  bgt cr6, 0x828565b4
	if ctx.cr[6].gt {
	pc = 0x828565B4; continue 'dispatch;
	}
	// 82856600: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82856604; continue 'dispatch;
            }
            0x82856604 => {
    //   block [0x82856604..0x82856620)
	// 82856604: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82856608: 419A0040  beq cr6, 0x82856648
	if ctx.cr[6].eq {
	pc = 0x82856648; continue 'dispatch;
	}
	// 8285660C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856610: 2F0B002C  cmpwi cr6, r11, 0x2c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 44, &mut ctx.xer);
	// 82856614: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82856618: 41990008  bgt cr6, 0x82856620
	if ctx.cr[6].gt {
	pc = 0x82856620; continue 'dispatch;
	}
	// 8285661C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82856620; continue 'dispatch;
            }
            0x82856620 => {
    //   block [0x82856620..0x82856648)
	// 82856620: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82856624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856628: 409A0020  bne cr6, 0x82856648
	if !ctx.cr[6].eq {
	pc = 0x82856648; continue 'dispatch;
	}
	// 8285662C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82856630: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82856634: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82856638: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285663C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82856640: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82856644: 48000020  b 0x82856664
	pc = 0x82856664; continue 'dispatch;
            }
            0x82856648 => {
    //   block [0x82856648..0x8285665C)
	// 82856648: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285664C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856650: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82856654: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82856658: 4800000C  b 0x82856664
	pc = 0x82856664; continue 'dispatch;
            }
            0x8285665C => {
    //   block [0x8285665C..0x82856664)
	// 8285665C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82856660: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82856664; continue 'dispatch;
            }
            0x82856664 => {
    //   block [0x82856664..0x828566CC)
	// 82856664: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82856668: C3DCDD60  lfs f30, -0x22a0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-8864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8285666C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856670: 419A0198  beq cr6, 0x82856808
	if ctx.cr[6].eq {
	pc = 0x82856808; continue 'dispatch;
	}
	// 82856674: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82856678: 3D40AAAA  lis r10, -0x5556
	ctx.r[10].s64 = -1431699456;
	// 8285667C: 6149AAAB  ori r9, r10, 0xaaab
	ctx.r[9].u64 = ctx.r[10].u64 | 43691;
	// 82856680: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82856684: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82856688: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285668C: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856690: 80CB0078  lwz r6, 0x78(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82856694: 1D4624A1  mulli r10, r6, 0x24a1
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * 9377 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82856698: 38AA24DF  addi r5, r10, 0x24df
	ctx.r[5].s64 = ctx.r[10].s64 + 9439;
	// 8285669C: 54A4983E  rotlwi r4, r5, 0x13
	ctx.r[4].u64 = ((ctx.r[5].u32).rotate_left(19)) as u64;
	// 828566A0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828566A4: 908B0078  stw r4, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[4].u32 ) };
	// 828566A8: 811D0018  lwz r8, 0x18(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 828566AC: 7CE34816  mulhwu r7, r3, r9
	ctx.r[7].u64 = ((ctx.r[3].u32 as u64 * ctx.r[9].u32 as u64) >> 32);
	// 828566B0: 54EBF87E  srwi r11, r7, 1
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828566B4: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828566B8: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828566BC: 7FE61850  subf r31, r6, r3
	ctx.r[31].s64 = ctx.r[3].s64 - ctx.r[6].s64;
	// 828566C0: 7F1F4000  cmpw cr6, r31, r8
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[8].s32, &mut ctx.xer);
	// 828566C4: 409A0008  bne cr6, 0x828566cc
	if !ctx.cr[6].eq {
	pc = 0x828566CC; continue 'dispatch;
	}
	// 828566C8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	pc = 0x828566CC; continue 'dispatch;
            }
            0x828566CC => {
    //   block [0x828566CC..0x828566D8)
	// 828566CC: 2F1F0002  cmpwi cr6, r31, 2
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2, &mut ctx.xer);
	// 828566D0: 40990008  ble cr6, 0x828566d8
	if !ctx.cr[6].gt {
	pc = 0x828566D8; continue 'dispatch;
	}
	// 828566D4: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	pc = 0x828566D8; continue 'dispatch;
            }
            0x828566D8 => {
    //   block [0x828566D8..0x82856808)
	// 828566D8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828566DC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828566E0: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828566E4: 4B99F4DD  bl 0x821f5bc0
	ctx.lr = 0x828566E8;
	sub_821F5BC0(ctx, base);
	// 828566E8: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828566EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828566F0: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 828566F4: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828566F8: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 828566FC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82856700: 4E800421  bctrl
	ctx.lr = 0x82856704;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82856704: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82856708: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 8285670C: D3C10050  stfs f30, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82856710: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82856714: C01CDBA4  lfs f0, -0x245c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82856718: 38869150  addi r4, r6, -0x6eb0
	ctx.r[4].s64 = ctx.r[6].s64 + -28336;
	// 8285671C: C1BCDD6C  lfs f13, -0x2294(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82856720: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82856724: 2B1F0001  cmplwi cr6, r31, 1
	ctx.cr[6].compare_u32(ctx.r[31].u32, 1 as u32, &mut ctx.xer);
            }
            0x82856808 => {
    //   block [0x82856808..0x82856818)
	// 82856808: C03C0000  lfs f1, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285680C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82856810: 4BDA0781  bl 0x825f6f90
	ctx.lr = 0x82856814;
	sub_825F6F90(ctx, base);
	// 82856814: D03D0034  stfs f1, 0x34(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x82856818; continue 'dispatch;
            }
            0x82856818 => {
    //   block [0x82856818..0x82856A50)
	// 82856818: C01D0030  lfs f0, 0x30(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285681C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82856820: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82856824: 4099001C  ble cr6, 0x82856840
	if !ctx.cr[6].gt {
	pc = 0x82856840; continue 'dispatch;
	}
	// 82856828: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 8285682C: D01D0030  stfs f0, 0x30(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82856830: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82856834: 4199000C  bgt cr6, 0x82856840
	if ctx.cr[6].gt {
	pc = 0x82856840; continue 'dispatch;
	}
	// 82856838: D3FD0030  stfs f31, 0x30(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8285683C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82856840: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82856844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856848: 419A0008  beq cr6, 0x82856850
	if ctx.cr[6].eq {
	pc = 0x82856850; continue 'dispatch;
	}
	// 8285684C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82856850: 897D0017  lbz r11, 0x17(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(23 as u32) ) } as u64;
	// 82856854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856858: 419A01D0  beq cr6, 0x82856a28
	if ctx.cr[6].eq {
	pc = 0x82856A28; continue 'dispatch;
	}
	// 8285685C: 897D0012  lbz r11, 0x12(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82856860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856864: 409A01C4  bne cr6, 0x82856a28
	if !ctx.cr[6].eq {
	pc = 0x82856A28; continue 'dispatch;
	}
	// 82856868: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285686C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82856870: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82856874: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 82856878: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285687C: 419A00E8  beq cr6, 0x82856964
	if ctx.cr[6].eq {
	pc = 0x82856964; continue 'dispatch;
	}
	// 82856880: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82856884: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82856888: 419A0020  beq cr6, 0x828568a8
	if ctx.cr[6].eq {
	pc = 0x828568A8; continue 'dispatch;
	}
	// 8285688C: 894A0031  lbz r10, 0x31(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 82856890: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82856894: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82856898: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285689C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828568A0: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828568A4: 480000C4  b 0x82856968
	pc = 0x82856968; continue 'dispatch;
	// 828568A8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828568AC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828568B0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828568B4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828568B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828568BC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828568C0: 40810054  ble 0x82856914
	if !ctx.cr[0].gt {
	pc = 0x82856914; continue 'dispatch;
	}
	// 828568C4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828568C8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828568CC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828568D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828568D4: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 828568D8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828568DC: 41980008  blt cr6, 0x828568e4
	if ctx.cr[6].lt {
	pc = 0x828568E4; continue 'dispatch;
	}
	// 828568E0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828568E4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828568E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828568EC: 419A0014  beq cr6, 0x82856900
	if ctx.cr[6].eq {
	pc = 0x82856900; continue 'dispatch;
	}
	// 828568F0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828568F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828568F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828568FC: 4800000C  b 0x82856908
	pc = 0x82856908; continue 'dispatch;
	// 82856900: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82856904: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82856908: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285690C: 4199FFB8  bgt cr6, 0x828568c4
	if ctx.cr[6].gt {
	pc = 0x828568C4; continue 'dispatch;
	}
	// 82856910: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82856914: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82856918: 419A003C  beq cr6, 0x82856954
	if ctx.cr[6].eq {
	pc = 0x82856954; continue 'dispatch;
	}
	// 8285691C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856920: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 82856924: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82856928: 41990008  bgt cr6, 0x82856930
	if ctx.cr[6].gt {
	pc = 0x82856930; continue 'dispatch;
	}
	// 8285692C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82856930: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82856934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856938: 409A001C  bne cr6, 0x82856954
	if !ctx.cr[6].eq {
	pc = 0x82856954; continue 'dispatch;
	}
	// 8285693C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82856940: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82856944: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82856948: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285694C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82856950: 48000018  b 0x82856968
	pc = 0x82856968; continue 'dispatch;
	// 82856954: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82856958: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285695C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82856960: 48000008  b 0x82856968
	pc = 0x82856968; continue 'dispatch;
	// 82856964: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82856968: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285696C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856970: 419A00B8  beq cr6, 0x82856a28
	if ctx.cr[6].eq {
	pc = 0x82856A28; continue 'dispatch;
	}
	// 82856974: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285697C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82856980: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82856984: 4E800421  bctrl
	ctx.lr = 0x82856988;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82856988: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285698C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82856990: 409A0098  bne cr6, 0x82856a28
	if !ctx.cr[6].eq {
	pc = 0x82856A28; continue 'dispatch;
	}
	// 82856994: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82856998: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 8285699C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828569A0: 48178391  bl 0x829ced30
	ctx.lr = 0x828569A4;
	sub_829CED30(ctx, base);
	// 828569A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828569A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828569AC: 394B3198  addi r10, r11, 0x3198
	ctx.r[10].s64 = ctx.r[11].s64 + 12696;
	// 828569B0: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 828569B4: 914100B0  stw r10, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 828569B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828569BC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828569C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828569C4: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 828569C8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828569CC: 4E800421  bctrl
	ctx.lr = 0x828569D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828569D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828569D4: 387D004C  addi r3, r29, 0x4c
	ctx.r[3].s64 = ctx.r[29].s64 + 76;
	// 828569D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828569DC: 4BC7B4ED  bl 0x824d1ec8
	ctx.lr = 0x828569E0;
	sub_824D1EC8(ctx, base);
	// 828569E0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828569E4: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 828569E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828569EC: 38C70B7C  addi r6, r7, 0xb7c
	ctx.r[6].s64 = ctx.r[7].s64 + 2940;
	// 828569F0: 90C10060  stw r6, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u32 ) };
	// 828569F4: 90BD0054  stw r5, 0x54(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 828569F8: 4B93D441  bl 0x82193e38
	ctx.lr = 0x828569FC;
	sub_82193E38(ctx, base);
	// 828569FC: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82856A00: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82856A04: 4B961115  bl 0x821b7b18
	ctx.lr = 0x82856A08;
	sub_821B7B18(ctx, base);
	// 82856A08: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82856A0C: 4B96110D  bl 0x821b7b18
	ctx.lr = 0x82856A10;
	sub_821B7B18(ctx, base);
	// 82856A10: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82856A14: 4B961105  bl 0x821b7b18
	ctx.lr = 0x82856A18;
	sub_821B7B18(ctx, base);
	// 82856A18: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82856A1C: 4B9610FD  bl 0x821b7b18
	ctx.lr = 0x82856A20;
	sub_821B7B18(ctx, base);
	// 82856A20: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82856A24: 4B95610D  bl 0x821acb30
	ctx.lr = 0x82856A28;
	sub_821ACB30(ctx, base);
	// 82856A28: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82856A2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856A30: 419A000C  beq cr6, 0x82856a3c
	if ctx.cr[6].eq {
	pc = 0x82856A3C; continue 'dispatch;
	}
	// 82856A34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82856A38: 4BFFE519  bl 0x82854f50
	ctx.lr = 0x82856A3C;
	sub_82854F50(ctx, base);
	// 82856A3C: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 82856A40: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82856A44: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82856A48: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82856A4C: 48452A04  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82856A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82856A50 size=244
    let mut pc: u32 = 0x82856A50;
    'dispatch: loop {
        match pc {
            0x82856A50 => {
    //   block [0x82856A50..0x82856A7C)
	// 82856A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82856A54: 484529B9  bl 0x82ca940c
	ctx.lr = 0x82856A58;
	sub_82CA93D0(ctx, base);
	// 82856A58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82856A5C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82856A60: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82856A64: 3BFD0060  addi r31, r29, 0x60
	ctx.r[31].s64 = ctx.r[29].s64 + 96;
	// 82856A68: 815D0068  lwz r10, 0x68(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 82856A6C: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 82856A70: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82856A74: 40990008  ble cr6, 0x82856a7c
	if !ctx.cr[6].gt {
	pc = 0x82856A7C; continue 'dispatch;
	}
	// 82856A78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82856A7C; continue 'dispatch;
            }
            0x82856A7C => {
    //   block [0x82856A7C..0x82856A90)
	// 82856A7C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856A80: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82856A84: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82856A88: 40990008  ble cr6, 0x82856a90
	if !ctx.cr[6].gt {
	pc = 0x82856A90; continue 'dispatch;
	}
	// 82856A8C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82856A90; continue 'dispatch;
            }
            0x82856A90 => {
    //   block [0x82856A90..0x82856AA8)
	// 82856A90: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82856A94: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82856A98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82856A9C: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82856AA0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82856AA4: 419A001C  beq cr6, 0x82856ac0
	if ctx.cr[6].eq {
	pc = 0x82856AC0; continue 'dispatch;
	}
	pc = 0x82856AA8; continue 'dispatch;
            }
            0x82856AA8 => {
    //   block [0x82856AA8..0x82856AC0)
	// 82856AA8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856AAC: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82856AB0: 419A0010  beq cr6, 0x82856ac0
	if ctx.cr[6].eq {
	pc = 0x82856AC0; continue 'dispatch;
	}
	// 82856AB4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82856AB8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82856ABC: 409AFFEC  bne cr6, 0x82856aa8
	if !ctx.cr[6].eq {
	pc = 0x82856AA8; continue 'dispatch;
	}
	pc = 0x82856AC0; continue 'dispatch;
            }
            0x82856AC0 => {
    //   block [0x82856AC0..0x82856AD8)
	// 82856AC0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82856AC4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856AC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82856ACC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82856AD0: 40990008  ble cr6, 0x82856ad8
	if !ctx.cr[6].gt {
	pc = 0x82856AD8; continue 'dispatch;
	}
	// 82856AD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82856AD8; continue 'dispatch;
            }
            0x82856AD8 => {
    //   block [0x82856AD8..0x82856AEC)
	// 82856AD8: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82856ADC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82856AE0: 419A000C  beq cr6, 0x82856aec
	if ctx.cr[6].eq {
	pc = 0x82856AEC; continue 'dispatch;
	}
	// 82856AE4: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82856AE8: 419A0008  beq cr6, 0x82856af0
	if ctx.cr[6].eq {
	pc = 0x82856AF0; continue 'dispatch;
	}
	pc = 0x82856AEC; continue 'dispatch;
            }
            0x82856AEC => {
    //   block [0x82856AEC..0x82856AF0)
	// 82856AEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82856AF0; continue 'dispatch;
            }
            0x82856AF0 => {
    //   block [0x82856AF0..0x82856B30)
	// 82856AF0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82856AF4: 419A0048  beq cr6, 0x82856b3c
	if ctx.cr[6].eq {
	pc = 0x82856B3C; continue 'dispatch;
	}
	// 82856AF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82856AFC: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82856B00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82856B04: 4BACA595  bl 0x82321098
	ctx.lr = 0x82856B08;
	sub_82321098(ctx, base);
	// 82856B08: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82856B0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856B10: 419A002C  beq cr6, 0x82856b3c
	if ctx.cr[6].eq {
	pc = 0x82856B3C; continue 'dispatch;
	}
	// 82856B14: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856B18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856B1C: 419A0014  beq cr6, 0x82856b30
	if ctx.cr[6].eq {
	pc = 0x82856B30; continue 'dispatch;
	}
	// 82856B20: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82856B24: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82856B28: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856B2C: 40820010  bne 0x82856b3c
	if !ctx.cr[0].eq {
	pc = 0x82856B3C; continue 'dispatch;
	}
	pc = 0x82856B30; continue 'dispatch;
            }
            0x82856B30 => {
    //   block [0x82856B30..0x82856B3C)
	// 82856B30: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82856B34: C00BB650  lfs f0, -0x49b0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82856B38: D01D0030  stfs f0, 0x30(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), tmp.u32 ) };
	pc = 0x82856B3C; continue 'dispatch;
            }
            0x82856B3C => {
    //   block [0x82856B3C..0x82856B44)
	// 82856B3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82856B40: 4845291C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82856B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82856B48 size=1032
    let mut pc: u32 = 0x82856B48;
    'dispatch: loop {
        match pc {
            0x82856B48 => {
    //   block [0x82856B48..0x82856BC4)
	// 82856B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82856B4C: 484528B9  bl 0x82ca9404
	ctx.lr = 0x82856B50;
	sub_82CA93D0(ctx, base);
	// 82856B50: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82856B54: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82856B58: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82856B5C: 897C0014  lbz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82856B60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856B64: 419A03E0  beq cr6, 0x82856f44
	if ctx.cr[6].eq {
	pc = 0x82856F44; continue 'dispatch;
	}
	// 82856B68: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 82856B6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856B70: 409A03D4  bne cr6, 0x82856f44
	if !ctx.cr[6].eq {
	pc = 0x82856F44; continue 'dispatch;
	}
	// 82856B74: 80DC0004  lwz r6, 4(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856B78: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82856B7C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82856B80: 9B7C0014  stb r27, 0x14(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 82856B84: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82856B88: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82856B8C: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 82856B90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82856B94: 419A00F4  beq cr6, 0x82856c88
	if ctx.cr[6].eq {
	pc = 0x82856C88; continue 'dispatch;
	}
	// 82856B98: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82856B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856BA0: 419A0024  beq cr6, 0x82856bc4
	if ctx.cr[6].eq {
	pc = 0x82856BC4; continue 'dispatch;
	}
	// 82856BA4: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 82856BA8: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82856BAC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82856BB0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82856BB4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856BB8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82856BBC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82856BC0: 480000CC  b 0x82856c8c
	pc = 0x82856C8C; continue 'dispatch;
            }
            0x82856BC4 => {
    //   block [0x82856BC4..0x82856BE0)
	// 82856BC4: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82856BC8: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82856BCC: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82856BD0: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82856BD4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82856BD8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856BDC: 40810054  ble 0x82856c30
	if !ctx.cr[0].gt {
	pc = 0x82856C30; continue 'dispatch;
	}
	pc = 0x82856BE0; continue 'dispatch;
            }
            0x82856BE0 => {
    //   block [0x82856BE0..0x82856C00)
	// 82856BE0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82856BE4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82856BE8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82856BEC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856BF0: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82856BF4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82856BF8: 41980008  blt cr6, 0x82856c00
	if ctx.cr[6].lt {
	pc = 0x82856C00; continue 'dispatch;
	}
	// 82856BFC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x82856C00; continue 'dispatch;
            }
            0x82856C00 => {
    //   block [0x82856C00..0x82856C1C)
	// 82856C00: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82856C04: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82856C08: 419A0014  beq cr6, 0x82856c1c
	if ctx.cr[6].eq {
	pc = 0x82856C1C; continue 'dispatch;
	}
	// 82856C0C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82856C10: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82856C14: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82856C18: 4800000C  b 0x82856c24
	pc = 0x82856C24; continue 'dispatch;
            }
            0x82856C1C => {
    //   block [0x82856C1C..0x82856C24)
	// 82856C1C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82856C20: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82856C24; continue 'dispatch;
            }
            0x82856C24 => {
    //   block [0x82856C24..0x82856C30)
	// 82856C24: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856C28: 4199FFB8  bgt cr6, 0x82856be0
	if ctx.cr[6].gt {
	pc = 0x82856BE0; continue 'dispatch;
	}
	// 82856C2C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82856C30; continue 'dispatch;
            }
            0x82856C30 => {
    //   block [0x82856C30..0x82856C4C)
	// 82856C30: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82856C34: 419A0040  beq cr6, 0x82856c74
	if ctx.cr[6].eq {
	pc = 0x82856C74; continue 'dispatch;
	}
	// 82856C38: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856C3C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82856C40: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82856C44: 41990008  bgt cr6, 0x82856c4c
	if ctx.cr[6].gt {
	pc = 0x82856C4C; continue 'dispatch;
	}
	// 82856C48: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82856C4C; continue 'dispatch;
            }
            0x82856C4C => {
    //   block [0x82856C4C..0x82856C74)
	// 82856C4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82856C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856C54: 409A0020  bne cr6, 0x82856c74
	if !ctx.cr[6].eq {
	pc = 0x82856C74; continue 'dispatch;
	}
	// 82856C58: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82856C5C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82856C60: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82856C64: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856C68: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82856C6C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82856C70: 4800001C  b 0x82856c8c
	pc = 0x82856C8C; continue 'dispatch;
            }
            0x82856C74 => {
    //   block [0x82856C74..0x82856C88)
	// 82856C74: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82856C78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856C7C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82856C80: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82856C84: 48000008  b 0x82856c8c
	pc = 0x82856C8C; continue 'dispatch;
            }
            0x82856C88 => {
    //   block [0x82856C88..0x82856C8C)
	// 82856C88: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82856C8C; continue 'dispatch;
            }
            0x82856C8C => {
    //   block [0x82856C8C..0x82856CD8)
	// 82856C8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82856C90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856C94: 419A02B0  beq cr6, 0x82856f44
	if ctx.cr[6].eq {
	pc = 0x82856F44; continue 'dispatch;
	}
	// 82856C98: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82856C9C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82856CA0: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 82856CA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82856CA8: 419A00F4  beq cr6, 0x82856d9c
	if ctx.cr[6].eq {
	pc = 0x82856D9C; continue 'dispatch;
	}
	// 82856CAC: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82856CB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856CB4: 419A0024  beq cr6, 0x82856cd8
	if ctx.cr[6].eq {
	pc = 0x82856CD8; continue 'dispatch;
	}
	// 82856CB8: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82856CBC: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82856CC0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82856CC4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82856CC8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856CCC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82856CD0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82856CD4: 480000CC  b 0x82856da0
	pc = 0x82856DA0; continue 'dispatch;
            }
            0x82856CD8 => {
    //   block [0x82856CD8..0x82856CF4)
	// 82856CD8: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82856CDC: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82856CE0: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82856CE4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82856CE8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82856CEC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856CF0: 40810054  ble 0x82856d44
	if !ctx.cr[0].gt {
	pc = 0x82856D44; continue 'dispatch;
	}
	pc = 0x82856CF4; continue 'dispatch;
            }
            0x82856CF4 => {
    //   block [0x82856CF4..0x82856D14)
	// 82856CF4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82856CF8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82856CFC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82856D00: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856D04: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 82856D08: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82856D0C: 41980008  blt cr6, 0x82856d14
	if ctx.cr[6].lt {
	pc = 0x82856D14; continue 'dispatch;
	}
	// 82856D10: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x82856D14; continue 'dispatch;
            }
            0x82856D14 => {
    //   block [0x82856D14..0x82856D30)
	// 82856D14: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82856D18: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82856D1C: 419A0014  beq cr6, 0x82856d30
	if ctx.cr[6].eq {
	pc = 0x82856D30; continue 'dispatch;
	}
	// 82856D20: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82856D24: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82856D28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82856D2C: 4800000C  b 0x82856d38
	pc = 0x82856D38; continue 'dispatch;
            }
            0x82856D30 => {
    //   block [0x82856D30..0x82856D38)
	// 82856D30: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82856D34: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82856D38; continue 'dispatch;
            }
            0x82856D38 => {
    //   block [0x82856D38..0x82856D44)
	// 82856D38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856D3C: 4199FFB8  bgt cr6, 0x82856cf4
	if ctx.cr[6].gt {
	pc = 0x82856CF4; continue 'dispatch;
	}
	// 82856D40: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82856D44; continue 'dispatch;
            }
            0x82856D44 => {
    //   block [0x82856D44..0x82856D60)
	// 82856D44: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82856D48: 419A0040  beq cr6, 0x82856d88
	if ctx.cr[6].eq {
	pc = 0x82856D88; continue 'dispatch;
	}
	// 82856D4C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856D50: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 82856D54: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82856D58: 41990008  bgt cr6, 0x82856d60
	if ctx.cr[6].gt {
	pc = 0x82856D60; continue 'dispatch;
	}
	// 82856D5C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82856D60; continue 'dispatch;
            }
            0x82856D60 => {
    //   block [0x82856D60..0x82856D88)
	// 82856D60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82856D64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856D68: 409A0020  bne cr6, 0x82856d88
	if !ctx.cr[6].eq {
	pc = 0x82856D88; continue 'dispatch;
	}
	// 82856D6C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82856D70: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82856D74: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82856D78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856D7C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82856D80: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82856D84: 4800001C  b 0x82856da0
	pc = 0x82856DA0; continue 'dispatch;
            }
            0x82856D88 => {
    //   block [0x82856D88..0x82856D9C)
	// 82856D88: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82856D8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856D90: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82856D94: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82856D98: 48000008  b 0x82856da0
	pc = 0x82856DA0; continue 'dispatch;
            }
            0x82856D9C => {
    //   block [0x82856D9C..0x82856DA0)
	// 82856D9C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82856DA0; continue 'dispatch;
            }
            0x82856DA0 => {
    //   block [0x82856DA0..0x82856E24)
	// 82856DA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82856DA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856DA8: 419A019C  beq cr6, 0x82856f44
	if ctx.cr[6].eq {
	pc = 0x82856F44; continue 'dispatch;
	}
	// 82856DAC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82856DB0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82856DB4: 388BF114  addi r4, r11, -0xeec
	ctx.r[4].s64 = ctx.r[11].s64 + -3820;
	// 82856DB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82856DBC: 4B9D6115  bl 0x8222ced0
	ctx.lr = 0x82856DC0;
	sub_8222CED0(ctx, base);
	// 82856DC0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82856DC4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82856DC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82856DCC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82856DD0: 4BBCA981  bl 0x82421750
	ctx.lr = 0x82856DD4;
	sub_82421750(ctx, base);
	// 82856DD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82856DD8: 4B9BE001  bl 0x82214dd8
	ctx.lr = 0x82856DDC;
	sub_82214DD8(ctx, base);
	// 82856DDC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82856DE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82856DE4: 419A0160  beq cr6, 0x82856f44
	if ctx.cr[6].eq {
	pc = 0x82856F44; continue 'dispatch;
	}
	// 82856DE8: 9BDC0014  stb r30, 0x14(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82856DEC: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82856DF0: 9BDC0015  stb r30, 0x15(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(21 as u32), ctx.r[30].u8 ) };
	// 82856DF4: 4B9C8465  bl 0x8221f258
	ctx.lr = 0x82856DF8;
	sub_8221F258(ctx, base);
	// 82856DF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82856DFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82856E00: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82856E04: 419A0020  beq cr6, 0x82856e24
	if ctx.cr[6].eq {
	pc = 0x82856E24; continue 'dispatch;
	}
	// 82856E08: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82856E0C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82856E10: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82856E14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82856E18: 4BA2CE19  bl 0x82283c30
	ctx.lr = 0x82856E1C;
	sub_82283C30(ctx, base);
	// 82856E1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82856E20: 48000008  b 0x82856e28
	pc = 0x82856E28; continue 'dispatch;
            }
            0x82856E24 => {
    //   block [0x82856E24..0x82856E28)
	// 82856E24: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	pc = 0x82856E28; continue 'dispatch;
            }
            0x82856E28 => {
    //   block [0x82856E28..0x82856E74)
	// 82856E28: 3BDC0040  addi r30, r28, 0x40
	ctx.r[30].s64 = ctx.r[28].s64 + 64;
	// 82856E2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82856E30: 4BA1C229  bl 0x82273058
	ctx.lr = 0x82856E34;
	sub_82273058(ctx, base);
	// 82856E34: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82856E38: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82856E3C: 80DC0048  lwz r6, 0x48(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82856E40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82856E44: 80BC0040  lwz r5, 0x40(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 82856E48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82856E4C: 4B9772F5  bl 0x821ce140
	ctx.lr = 0x82856E50;
	sub_821CE140(ctx, base);
	// 82856E50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82856E54: 817C003C  lwz r11, 0x3c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 82856E58: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856E5C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82856E60: 419A007C  beq cr6, 0x82856edc
	if ctx.cr[6].eq {
	pc = 0x82856EDC; continue 'dispatch;
	}
	// 82856E64: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82856E68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82856E6C: 419A0040  beq cr6, 0x82856eac
	if ctx.cr[6].eq {
	pc = 0x82856EAC; continue 'dispatch;
	}
	// 82856E70: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82856E74; continue 'dispatch;
            }
            0x82856E74 => {
    //   block [0x82856E74..0x82856EA8)
	// 82856E74: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82856E78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82856E7C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82856E80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82856E84: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82856E88: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82856E8C: 4082FFE8  bne 0x82856e74
	if !ctx.cr[0].eq {
	pc = 0x82856E74; continue 'dispatch;
	}
	// 82856E90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856E94: 409A0014  bne cr6, 0x82856ea8
	if !ctx.cr[6].eq {
	pc = 0x82856EA8; continue 'dispatch;
	}
	// 82856E98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856E9C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856EA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82856EA4: 4E800421  bctrl
	ctx.lr = 0x82856EA8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82856EA8 => {
    //   block [0x82856EA8..0x82856EAC)
	// 82856EA8: 937C003C  stw r27, 0x3c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), ctx.r[27].u32 ) };
	pc = 0x82856EAC; continue 'dispatch;
            }
            0x82856EAC => {
    //   block [0x82856EAC..0x82856EC0)
	// 82856EAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856EB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856EB4: 917C003C  stw r11, 0x3c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82856EB8: 419A0024  beq cr6, 0x82856edc
	if ctx.cr[6].eq {
	pc = 0x82856EDC; continue 'dispatch;
	}
	// 82856EBC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82856EC0; continue 'dispatch;
            }
            0x82856EC0 => {
    //   block [0x82856EC0..0x82856EDC)
	// 82856EC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82856EC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82856EC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82856ECC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82856ED0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82856ED4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82856ED8: 4082FFE8  bne 0x82856ec0
	if !ctx.cr[0].eq {
	pc = 0x82856EC0; continue 'dispatch;
	}
	pc = 0x82856EDC; continue 'dispatch;
            }
            0x82856EDC => {
    //   block [0x82856EDC..0x82856EF0)
	// 82856EDC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82856EE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856EE4: 419A0048  beq cr6, 0x82856f2c
	if ctx.cr[6].eq {
	pc = 0x82856F2C; continue 'dispatch;
	}
	// 82856EE8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82856EEC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82856EF0; continue 'dispatch;
            }
            0x82856EF0 => {
    //   block [0x82856EF0..0x82856F28)
	// 82856EF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82856EF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82856EF8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82856EFC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82856F00: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82856F04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82856F08: 4082FFE8  bne 0x82856ef0
	if !ctx.cr[0].eq {
	pc = 0x82856EF0; continue 'dispatch;
	}
	// 82856F0C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82856F10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856F14: 409A0014  bne cr6, 0x82856f28
	if !ctx.cr[6].eq {
	pc = 0x82856F28; continue 'dispatch;
	}
	// 82856F18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856F1C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856F20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82856F24: 4E800421  bctrl
	ctx.lr = 0x82856F28;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82856F28 => {
    //   block [0x82856F28..0x82856F2C)
	// 82856F28: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	pc = 0x82856F2C; continue 'dispatch;
            }
            0x82856F2C => {
    //   block [0x82856F2C..0x82856F44)
	// 82856F2C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856F30: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82856F34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856F38: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82856F3C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82856F40: 4E800421  bctrl
	ctx.lr = 0x82856F44;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82856F44 => {
    //   block [0x82856F44..0x82856F50)
	// 82856F44: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82856F48: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82856F4C: 48452508  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82856F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82856F50 size=448
    let mut pc: u32 = 0x82856F50;
    'dispatch: loop {
        match pc {
            0x82856F50 => {
    //   block [0x82856F50..0x82856FC0)
	// 82856F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82856F54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82856F58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82856F5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82856F60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82856F64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82856F68: 897E0015  lbz r11, 0x15(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 82856F6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82856F70: 419A0188  beq cr6, 0x828570f8
	if ctx.cr[6].eq {
	pc = 0x828570F8; continue 'dispatch;
	}
	// 82856F74: 809E003C  lwz r4, 0x3c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82856F78: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82856F7C: 419A017C  beq cr6, 0x828570f8
	if ctx.cr[6].eq {
	pc = 0x828570F8; continue 'dispatch;
	}
	// 82856F80: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856F84: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82856F88: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82856F8C: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82856F90: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82856F94: 419A00E8  beq cr6, 0x8285707c
	if ctx.cr[6].eq {
	pc = 0x8285707C; continue 'dispatch;
	}
	// 82856F98: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82856F9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82856FA0: 419A0020  beq cr6, 0x82856fc0
	if ctx.cr[6].eq {
	pc = 0x82856FC0; continue 'dispatch;
	}
	// 82856FA4: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 82856FA8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82856FAC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82856FB0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82856FB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82856FB8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82856FBC: 480000C8  b 0x82857084
	pc = 0x82857084; continue 'dispatch;
            }
            0x82856FC0 => {
    //   block [0x82856FC0..0x82856FDC)
	// 82856FC0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82856FC4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82856FC8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82856FCC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82856FD0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82856FD4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82856FD8: 40810054  ble 0x8285702c
	if !ctx.cr[0].gt {
	pc = 0x8285702C; continue 'dispatch;
	}
	pc = 0x82856FDC; continue 'dispatch;
            }
            0x82856FDC => {
    //   block [0x82856FDC..0x82856FFC)
	// 82856FDC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82856FE0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82856FE4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82856FE8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82856FEC: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82856FF0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82856FF4: 41980008  blt cr6, 0x82856ffc
	if ctx.cr[6].lt {
	pc = 0x82856FFC; continue 'dispatch;
	}
	// 82856FF8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82856FFC; continue 'dispatch;
            }
            0x82856FFC => {
    //   block [0x82856FFC..0x82857018)
	// 82856FFC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82857000: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82857004: 419A0014  beq cr6, 0x82857018
	if ctx.cr[6].eq {
	pc = 0x82857018; continue 'dispatch;
	}
	// 82857008: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285700C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82857010: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82857014: 4800000C  b 0x82857020
	pc = 0x82857020; continue 'dispatch;
            }
            0x82857018 => {
    //   block [0x82857018..0x82857020)
	// 82857018: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285701C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82857020; continue 'dispatch;
            }
            0x82857020 => {
    //   block [0x82857020..0x8285702C)
	// 82857020: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82857024: 4199FFB8  bgt cr6, 0x82856fdc
	if ctx.cr[6].gt {
	pc = 0x82856FDC; continue 'dispatch;
	}
	// 82857028: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285702C; continue 'dispatch;
            }
            0x8285702C => {
    //   block [0x8285702C..0x82857048)
	// 8285702C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82857030: 419A003C  beq cr6, 0x8285706c
	if ctx.cr[6].eq {
	pc = 0x8285706C; continue 'dispatch;
	}
	// 82857034: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857038: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8285703C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82857040: 41990008  bgt cr6, 0x82857048
	if ctx.cr[6].gt {
	pc = 0x82857048; continue 'dispatch;
	}
	// 82857044: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82857048; continue 'dispatch;
            }
            0x82857048 => {
    //   block [0x82857048..0x8285706C)
	// 82857048: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285704C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82857050: 409A001C  bne cr6, 0x8285706c
	if !ctx.cr[6].eq {
	pc = 0x8285706C; continue 'dispatch;
	}
	// 82857054: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82857058: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285705C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82857060: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82857064: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82857068: 4800001C  b 0x82857084
	pc = 0x82857084; continue 'dispatch;
            }
            0x8285706C => {
    //   block [0x8285706C..0x8285707C)
	// 8285706C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82857070: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82857074: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82857078: 4800000C  b 0x82857084
	pc = 0x82857084; continue 'dispatch;
            }
            0x8285707C => {
    //   block [0x8285707C..0x82857084)
	// 8285707C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857080: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x82857084; continue 'dispatch;
            }
            0x82857084 => {
    //   block [0x82857084..0x828570B0)
	// 82857084: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82857088: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285708C: 419A006C  beq cr6, 0x828570f8
	if ctx.cr[6].eq {
	pc = 0x828570F8; continue 'dispatch;
	}
	// 82857090: 9BFE0015  stb r31, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[31].u8 ) };
	// 82857094: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82857098: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285709C: 4BA56F85  bl 0x822ae020
	ctx.lr = 0x828570A0;
	sub_822AE020(ctx, base);
	// 828570A0: 807E003C  lwz r3, 0x3c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 828570A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828570A8: 419A0040  beq cr6, 0x828570e8
	if ctx.cr[6].eq {
	pc = 0x828570E8; continue 'dispatch;
	}
	// 828570AC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x828570B0; continue 'dispatch;
            }
            0x828570B0 => {
    //   block [0x828570B0..0x828570E4)
	// 828570B0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828570B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828570B8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828570BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828570C0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828570C4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828570C8: 4082FFE8  bne 0x828570b0
	if !ctx.cr[0].eq {
	pc = 0x828570B0; continue 'dispatch;
	}
	// 828570CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828570D0: 409A0014  bne cr6, 0x828570e4
	if !ctx.cr[6].eq {
	pc = 0x828570E4; continue 'dispatch;
	}
	// 828570D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828570D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828570DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828570E0: 4E800421  bctrl
	ctx.lr = 0x828570E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828570E4 => {
    //   block [0x828570E4..0x828570E8)
	// 828570E4: 93FE003C  stw r31, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[31].u32 ) };
	pc = 0x828570E8; continue 'dispatch;
            }
            0x828570E8 => {
    //   block [0x828570E8..0x828570F8)
	// 828570E8: 93FE003C  stw r31, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[31].u32 ) };
	// 828570EC: 387E0040  addi r3, r30, 0x40
	ctx.r[3].s64 = ctx.r[30].s64 + 64;
	// 828570F0: 4B960A29  bl 0x821b7b18
	ctx.lr = 0x828570F4;
	sub_821B7B18(ctx, base);
	// 828570F4: 93FE0040  stw r31, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	pc = 0x828570F8; continue 'dispatch;
            }
            0x828570F8 => {
    //   block [0x828570F8..0x82857110)
	// 828570F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828570FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82857100: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82857104: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82857108: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285710C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82857110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82857110 size=24
    let mut pc: u32 = 0x82857110;
    'dispatch: loop {
        match pc {
            0x82857110 => {
    //   block [0x82857110..0x82857128)
	// 82857110: 89630016  lbz r11, 0x16(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(22 as u32) ) } as u64;
	// 82857114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82857118: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8285711C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82857120: 99630016  stb r11, 0x16(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(22 as u32), ctx.r[11].u8 ) };
	// 82857124: 4BFFFA24  b 0x82856b48
	sub_82856B48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82857130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82857130 size=236
    let mut pc: u32 = 0x82857130;
    'dispatch: loop {
        match pc {
            0x82857130 => {
    //   block [0x82857130..0x8285721C)
	// 82857130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82857134: 484522D9  bl 0x82ca940c
	ctx.lr = 0x82857138;
	sub_82CA93D0(ctx, base);
	// 82857138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285713C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82857140: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82857144: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82857148: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8285714C: 388BC2DC  addi r4, r11, -0x3d24
	ctx.r[4].s64 = ctx.r[11].s64 + -15652;
	// 82857150: 4BA16471  bl 0x8226d5c0
	ctx.lr = 0x82857154;
	sub_8226D5C0(ctx, base);
	// 82857154: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82857158: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8285715C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82857160: 388AC2E0  addi r4, r10, -0x3d20
	ctx.r[4].s64 = ctx.r[10].s64 + -15648;
	// 82857164: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82857168: 4BA16459  bl 0x8226d5c0
	ctx.lr = 0x8285716C;
	sub_8226D5C0(ctx, base);
	// 8285716C: D03F0004  stfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82857170: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82857174: C03D0028  lfs f1, 0x28(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82857178: 4BA7C4D1  bl 0x822d3648
	ctx.lr = 0x8285717C;
	sub_822D3648(ctx, base);
	// 8285717C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82857180: C0099484  lfs f0, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82857184: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82857188: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8285718C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82857190: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 82857194: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 82857198: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 8285719C: 38880E68  addi r4, r8, 0xe68
	ctx.r[4].s64 = ctx.r[8].s64 + 3688;
	// 828571A0: 7CC32B78  or r3, r6, r5
	ctx.r[3].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 828571A4: 7D841C2E  lfsx f12, r4, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828571A8: FD6C036E  fsel f11, f12, f13, f0
	ctx.f[11].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 828571AC: ED4B0828  fsubs f10, f11, f1
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[1].f64) as f32) as f64);
	// 828571B0: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 828571B4: 7D600026  mfcr r11
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[11].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 828571B8: 556ADF7A  rlwinm r10, r11, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828571BC: 5569F77A  rlwinm r9, r11, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 828571C0: 7D484B78  or r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 828571C4: 7D24442E  lfsx f9, r4, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828571C8: FD09586E  fsel f8, f9, f1, f11
	ctx.f[8].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[1].f64 } else { ctx.f[11].f64 };
	// 828571CC: D11F0000  stfs f8, 0(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828571D0: C0FF0004  lfs f7, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828571D4: FF070000  fcmpu cr6, f7, f0
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[0].f64);
	// 828571D8: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 828571DC: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 828571E0: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 828571E4: 7CC32B78  or r3, r6, r5
	ctx.r[3].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 828571E8: 7CC41C2E  lfsx f6, r4, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 828571EC: FCA601EE  fsel f5, f6, f7, f0
	ctx.f[5].f64 = if ctx.f[6].f64 >= 0.0 { ctx.f[7].f64 } else { ctx.f[0].f64 };
	// 828571F0: EC850828  fsubs f4, f5, f1
	ctx.f[4].f64 = (((ctx.f[5].f64 - ctx.f[1].f64) as f32) as f64);
	// 828571F4: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 828571F8: 7D600026  mfcr r11
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[11].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 828571FC: 556ADF7A  rlwinm r10, r11, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82857200: 5569F77A  rlwinm r9, r11, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82857204: 7D484B78  or r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82857208: 7C64442E  lfsx f3, r4, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8285720C: FC43286E  fsel f2, f3, f1, f5
	ctx.f[2].f64 = if ctx.f[3].f64 >= 0.0 { ctx.f[1].f64 } else { ctx.f[5].f64 };
	// 82857210: D05F0004  stfs f2, 4(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82857214: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82857218: 48452244  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82857220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82857220 size=136
    let mut pc: u32 = 0x82857220;
    'dispatch: loop {
        match pc {
            0x82857220 => {
    //   block [0x82857220..0x82857278)
	// 82857220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82857224: 484521E9  bl 0x82ca940c
	ctx.lr = 0x82857228;
	sub_82CA93D0(ctx, base);
	// 82857228: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285722C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82857230: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82857234: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82857238: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285723C: 4BFFFEF5  bl 0x82857130
	ctx.lr = 0x82857240;
	sub_82857130(ctx, base);
	// 82857240: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82857244: C03D0028  lfs f1, 0x28(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82857248: 4BA7C401  bl 0x822d3648
	ctx.lr = 0x8285724C;
	sub_822D3648(ctx, base);
	// 8285724C: D03F0008  stfs f1, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82857250: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82857254: 4BF09DE5  bl 0x82761038
	ctx.lr = 0x82857258;
	sub_82761038(ctx, base);
	// 82857258: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8285725C: D03F000C  stfs f1, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82857260: 396B9484  addi r11, r11, -0x6b7c
	ctx.r[11].s64 = ctx.r[11].s64 + -27516;
	// 82857264: C00B21CC  lfs f0, 0x21cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8652 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82857268: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8285726C: 4098000C  bge cr6, 0x82857278
	if !ctx.cr[6].lt {
	pc = 0x82857278; continue 'dispatch;
	}
	// 82857270: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82857274: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x82857278; continue 'dispatch;
            }
            0x82857278 => {
    //   block [0x82857278..0x82857288)
	// 82857278: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 8285727C: 409A000C  bne cr6, 0x82857288
	if !ctx.cr[6].eq {
	pc = 0x82857288; continue 'dispatch;
	}
	// 82857280: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82857284: 48000008  b 0x8285728c
	pc = 0x8285728C; continue 'dispatch;
            }
            0x82857288 => {
    //   block [0x82857288..0x8285728C)
	// 82857288: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x8285728C; continue 'dispatch;
            }
            0x8285728C => {
    //   block [0x8285728C..0x828572A8)
	// 8285728C: C00B4A14  lfs f0, 0x4a14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18964 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82857290: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82857294: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82857298: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8285729C: D1BF0014  stfs f13, 0x14(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828572A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828572A4: 484521B8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828572A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828572A8 size=360
    let mut pc: u32 = 0x828572A8;
    'dispatch: loop {
        match pc {
            0x828572A8 => {
    //   block [0x828572A8..0x828572C8)
	// 828572A8: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828572AC: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828572B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828572B4: 38EAF058  addi r7, r10, -0xfa8
	ctx.r[7].s64 = ctx.r[10].s64 + -4008;
	// 828572B8: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 828572BC: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828572C0: 38A67088  addi r5, r6, 0x7088
	ctx.r[5].s64 = ctx.r[6].s64 + 28808;
	// 828572C4: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x828572C8; continue 'dispatch;
            }
            0x828572C8 => {
    //   block [0x828572C8..0x82857410)
	// 828572C8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828572CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828572D0: 7D202828  lwarx r9, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828572D4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828572D8: 7D20292D  stwcx. r9, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828572DC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828572E0: 4082FFE8  bne 0x828572c8
	if !ctx.cr[0].eq {
	pc = 0x828572C8; continue 'dispatch;
	}
	// 828572E4: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828572E8: 9963000D  stb r11, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[11].u8 ) };
	// 828572EC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828572F0: 3924F230  addi r9, r4, -0xdd0
	ctx.r[9].s64 = ctx.r[4].s64 + -3536;
	// 828572F4: 390A9490  addi r8, r10, -0x6b70
	ctx.r[8].s64 = ctx.r[10].s64 + -27504;
	// 828572F8: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828572FC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82857300: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82857304: C1AA9490  lfs f13, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82857308: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8285730C: D1A3009C  stfs f13, 0x9c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82857310: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82857314: C008FFF4  lfs f0, -0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82857318: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 8285731C: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82857320: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82857324: D0030098  stfs f0, 0x98(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82857328: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8285732C: D1A300A0  stfs f13, 0xa0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82857330: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82857334: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82857338: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 8285733C: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82857340: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82857344: D00300AC  stfs f0, 0xac(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82857348: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 8285734C: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82857350: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82857354: D1A300B4  stfs f13, 0xb4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82857358: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 8285735C: D1A300B8  stfs f13, 0xb8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82857360: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82857364: D00300BC  stfs f0, 0xbc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82857368: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 8285736C: D00300C0  stfs f0, 0xc0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82857370: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82857374: D00300C4  stfs f0, 0xc4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82857378: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8285737C: D00300C8  stfs f0, 0xc8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82857380: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82857384: D1A300CC  stfs f13, 0xcc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82857388: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8285738C: D1A300D0  stfs f13, 0xd0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82857390: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82857394: D00300D4  stfs f0, 0xd4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82857398: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8285739C: D00300D8  stfs f0, 0xd8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 828573A0: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828573A4: D00300DC  stfs f0, 0xdc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 828573A8: 91630068  stw r11, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828573AC: D00300E0  stfs f0, 0xe0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 828573B0: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828573B4: D1A300E4  stfs f13, 0xe4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 828573B8: 91630070  stw r11, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828573BC: D1A300E8  stfs f13, 0xe8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 828573C0: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828573C4: D00300EC  stfs f0, 0xec(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 828573C8: 91630078  stw r11, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828573CC: D00300F0  stfs f0, 0xf0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 828573D0: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 828573D4: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828573D8: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828573DC: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 828573E0: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 828573E4: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828573E8: 916300F4  stw r11, 0xf4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 828573EC: 916300F8  stw r11, 0xf8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 828573F0: 91630100  stw r11, 0x100(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 828573F4: 91630104  stw r11, 0x104(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 828573F8: 9163010C  stw r11, 0x10c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 828573FC: 91630110  stw r11, 0x110(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82857400: D0030124  stfs f0, 0x124(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82857404: 91630118  stw r11, 0x118(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 82857408: 9963011D  stb r11, 0x11d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(285 as u32), ctx.r[11].u8 ) };
	// 8285740C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82857410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82857410 size=80
    let mut pc: u32 = 0x82857410;
    'dispatch: loop {
        match pc {
            0x82857410 => {
    //   block [0x82857410..0x82857448)
	// 82857410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82857414: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82857418: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285741C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82857420: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82857424: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82857428: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8285742C: 48000035  bl 0x82857460
	ctx.lr = 0x82857430;
	sub_82857460(ctx, base);
	// 82857430: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82857434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285743C: 419A000C  beq cr6, 0x82857448
	if ctx.cr[6].eq {
	pc = 0x82857448; continue 'dispatch;
	}
	// 82857440: 4B9C48F9  bl 0x8221bd38
	ctx.lr = 0x82857444;
	sub_8221BD38(ctx, base);
	// 82857444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82857448; continue 'dispatch;
            }
            0x82857448 => {
    //   block [0x82857448..0x82857460)
	// 82857448: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285744C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82857450: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82857454: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82857458: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285745C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82857460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82857460 size=568
    let mut pc: u32 = 0x82857460;
    'dispatch: loop {
        match pc {
            0x82857460 => {
    //   block [0x82857460..0x828574A4)
	// 82857460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82857464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82857468: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285746C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82857470: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82857474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82857478: 387F010C  addi r3, r31, 0x10c
	ctx.r[3].s64 = ctx.r[31].s64 + 268;
	// 8285747C: 4B96069D  bl 0x821b7b18
	ctx.lr = 0x82857480;
	sub_821B7B18(ctx, base);
	// 82857480: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 82857484: 4B960695  bl 0x821b7b18
	ctx.lr = 0x82857488;
	sub_821B7B18(ctx, base);
	// 82857488: 387F00F4  addi r3, r31, 0xf4
	ctx.r[3].s64 = ctx.r[31].s64 + 244;
	// 8285748C: 4B96068D  bl 0x821b7b18
	ctx.lr = 0x82857490;
	sub_821B7B18(ctx, base);
	// 82857490: 807F0090  lwz r3, 0x90(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82857494: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82857498: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285749C: 419A0040  beq cr6, 0x828574dc
	if ctx.cr[6].eq {
	pc = 0x828574DC; continue 'dispatch;
	}
	// 828574A0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x828574A4; continue 'dispatch;
            }
            0x828574A4 => {
    //   block [0x828574A4..0x828574D8)
	// 828574A4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828574A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828574AC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828574B0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828574B4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828574B8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828574BC: 4082FFE8  bne 0x828574a4
	if !ctx.cr[0].eq {
	pc = 0x828574A4; continue 'dispatch;
	}
	// 828574C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828574C4: 409A0014  bne cr6, 0x828574d8
	if !ctx.cr[6].eq {
	pc = 0x828574D8; continue 'dispatch;
	}
	// 828574C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828574CC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828574D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828574D4: 4E800421  bctrl
	ctx.lr = 0x828574D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828574D8 => {
    //   block [0x828574D8..0x828574DC)
	// 828574D8: 93DF0090  stw r30, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	pc = 0x828574DC; continue 'dispatch;
            }
            0x828574DC => {
    //   block [0x828574DC..0x828574EC)
	// 828574DC: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828574E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828574E4: 419A0040  beq cr6, 0x82857524
	if ctx.cr[6].eq {
	pc = 0x82857524; continue 'dispatch;
	}
	// 828574E8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x828574EC; continue 'dispatch;
            }
            0x828574EC => {
    //   block [0x828574EC..0x82857520)
	// 828574EC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828574F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828574F4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828574F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828574FC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82857500: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82857504: 4082FFE8  bne 0x828574ec
	if !ctx.cr[0].eq {
	pc = 0x828574EC; continue 'dispatch;
	}
	// 82857508: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285750C: 409A0014  bne cr6, 0x82857520
	if !ctx.cr[6].eq {
	pc = 0x82857520; continue 'dispatch;
	}
	// 82857510: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857514: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82857518: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285751C: 4E800421  bctrl
	ctx.lr = 0x82857520;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82857520 => {
    //   block [0x82857520..0x82857524)
	// 82857520: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	pc = 0x82857524; continue 'dispatch;
            }
            0x82857524 => {
    //   block [0x82857524..0x82857534)
	// 82857524: 807F0088  lwz r3, 0x88(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82857528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285752C: 419A0040  beq cr6, 0x8285756c
	if ctx.cr[6].eq {
	pc = 0x8285756C; continue 'dispatch;
	}
	// 82857530: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82857534; continue 'dispatch;
            }
            0x82857534 => {
    //   block [0x82857534..0x82857568)
	// 82857534: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82857538: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285753C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82857540: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82857544: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82857548: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285754C: 4082FFE8  bne 0x82857534
	if !ctx.cr[0].eq {
	pc = 0x82857534; continue 'dispatch;
	}
	// 82857550: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82857554: 409A0014  bne cr6, 0x82857568
	if !ctx.cr[6].eq {
	pc = 0x82857568; continue 'dispatch;
	}
	// 82857558: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285755C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82857560: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82857564: 4E800421  bctrl
	ctx.lr = 0x82857568;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82857568 => {
    //   block [0x82857568..0x8285756C)
	// 82857568: 93DF0088  stw r30, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	pc = 0x8285756C; continue 'dispatch;
            }
            0x8285756C => {
    //   block [0x8285756C..0x8285757C)
	// 8285756C: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82857570: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82857574: 419A0040  beq cr6, 0x828575b4
	if ctx.cr[6].eq {
	pc = 0x828575B4; continue 'dispatch;
	}
	// 82857578: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8285757C; continue 'dispatch;
            }
            0x8285757C => {
    //   block [0x8285757C..0x828575B0)
	// 8285757C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82857580: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82857584: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82857588: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285758C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82857590: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82857594: 4082FFE8  bne 0x8285757c
	if !ctx.cr[0].eq {
	pc = 0x8285757C; continue 'dispatch;
	}
	// 82857598: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285759C: 409A0014  bne cr6, 0x828575b0
	if !ctx.cr[6].eq {
	pc = 0x828575B0; continue 'dispatch;
	}
	// 828575A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828575A4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828575A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828575AC: 4E800421  bctrl
	ctx.lr = 0x828575B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828575B0 => {
    //   block [0x828575B0..0x828575B4)
	// 828575B0: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	pc = 0x828575B4; continue 'dispatch;
            }
            0x828575B4 => {
    //   block [0x828575B4..0x828575C4)
	// 828575B4: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 828575B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828575BC: 419A0040  beq cr6, 0x828575fc
	if ctx.cr[6].eq {
	pc = 0x828575FC; continue 'dispatch;
	}
	// 828575C0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x828575C4; continue 'dispatch;
            }
            0x828575C4 => {
    //   block [0x828575C4..0x828575F8)
	// 828575C4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828575C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828575CC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828575D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828575D4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828575D8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828575DC: 4082FFE8  bne 0x828575c4
	if !ctx.cr[0].eq {
	pc = 0x828575C4; continue 'dispatch;
	}
	// 828575E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828575E4: 409A0014  bne cr6, 0x828575f8
	if !ctx.cr[6].eq {
	pc = 0x828575F8; continue 'dispatch;
	}
	// 828575E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828575EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828575F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828575F4: 4E800421  bctrl
	ctx.lr = 0x828575F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828575F8 => {
    //   block [0x828575F8..0x828575FC)
	// 828575F8: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	pc = 0x828575FC; continue 'dispatch;
            }
            0x828575FC => {
    //   block [0x828575FC..0x82857698)
	// 828575FC: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 82857600: 4B960519  bl 0x821b7b18
	ctx.lr = 0x82857604;
	sub_821B7B18(ctx, base);
	// 82857604: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 82857608: 4B960511  bl 0x821b7b18
	ctx.lr = 0x8285760C;
	sub_821B7B18(ctx, base);
	// 8285760C: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 82857610: 4B960509  bl 0x821b7b18
	ctx.lr = 0x82857614;
	sub_821B7B18(ctx, base);
	// 82857614: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82857618: 4B960501  bl 0x821b7b18
	ctx.lr = 0x8285761C;
	sub_821B7B18(ctx, base);
	// 8285761C: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 82857620: 4B9604F9  bl 0x821b7b18
	ctx.lr = 0x82857624;
	sub_821B7B18(ctx, base);
	// 82857624: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82857628: 4B9604F1  bl 0x821b7b18
	ctx.lr = 0x8285762C;
	sub_821B7B18(ctx, base);
	// 8285762C: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 82857630: 4B9604E9  bl 0x821b7b18
	ctx.lr = 0x82857634;
	sub_821B7B18(ctx, base);
	// 82857634: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 82857638: 4B9604E1  bl 0x821b7b18
	ctx.lr = 0x8285763C;
	sub_821B7B18(ctx, base);
	// 8285763C: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82857640: 4B9604D9  bl 0x821b7b18
	ctx.lr = 0x82857644;
	sub_821B7B18(ctx, base);
	// 82857644: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82857648: 4B9604D1  bl 0x821b7b18
	ctx.lr = 0x8285764C;
	sub_821B7B18(ctx, base);
	// 8285764C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82857650: 4B9604C9  bl 0x821b7b18
	ctx.lr = 0x82857654;
	sub_821B7B18(ctx, base);
	// 82857654: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82857658: 4B9604C1  bl 0x821b7b18
	ctx.lr = 0x8285765C;
	sub_821B7B18(ctx, base);
	// 8285765C: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82857660: 4B9604B9  bl 0x821b7b18
	ctx.lr = 0x82857664;
	sub_821B7B18(ctx, base);
	// 82857664: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82857668: 4B9604B1  bl 0x821b7b18
	ctx.lr = 0x8285766C;
	sub_821B7B18(ctx, base);
	// 8285766C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82857670: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82857674: 394BF058  addi r10, r11, -0xfa8
	ctx.r[10].s64 = ctx.r[11].s64 + -4008;
	// 82857678: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8285767C: 4B9BD75D  bl 0x82214dd8
	ctx.lr = 0x82857680;
	sub_82214DD8(ctx, base);
	// 82857680: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82857684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82857688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285768C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82857690: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82857694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82857698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82857698 size=428
    let mut pc: u32 = 0x82857698;
    'dispatch: loop {
        match pc {
            0x82857698 => {
    //   block [0x82857698..0x828576F4)
	// 82857698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285769C: 48451D71  bl 0x82ca940c
	ctx.lr = 0x828576A0;
	sub_82CA93D0(ctx, base);
	// 828576A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828576A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828576A8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828576AC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828576B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828576B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828576B8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828576BC: 554977FE  rlwinm r9, r10, 0xe, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0003FFFFu64;
	// 828576C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828576C4: 419A00F4  beq cr6, 0x828577b8
	if ctx.cr[6].eq {
	pc = 0x828577B8; continue 'dispatch;
	}
	// 828576C8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828576CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828576D0: 419A0024  beq cr6, 0x828576f4
	if ctx.cr[6].eq {
	pc = 0x828576F4; continue 'dispatch;
	}
	// 828576D4: 892A0012  lbz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 828576D8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828576DC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828576E0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828576E4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828576E8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828576EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828576F0: 480000CC  b 0x828577bc
	pc = 0x828577BC; continue 'dispatch;
            }
            0x828576F4 => {
    //   block [0x828576F4..0x82857710)
	// 828576F4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828576F8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828576FC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82857700: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82857704: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82857708: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285770C: 40810054  ble 0x82857760
	if !ctx.cr[0].gt {
	pc = 0x82857760; continue 'dispatch;
	}
	pc = 0x82857710; continue 'dispatch;
            }
            0x82857710 => {
    //   block [0x82857710..0x82857730)
	// 82857710: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82857714: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82857718: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285771C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857720: 2F070012  cmpwi cr6, r7, 0x12
	ctx.cr[6].compare_i32(ctx.r[7].s32, 18, &mut ctx.xer);
	// 82857724: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82857728: 41980008  blt cr6, 0x82857730
	if ctx.cr[6].lt {
	pc = 0x82857730; continue 'dispatch;
	}
	// 8285772C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82857730; continue 'dispatch;
            }
            0x82857730 => {
    //   block [0x82857730..0x8285774C)
	// 82857730: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82857734: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82857738: 419A0014  beq cr6, 0x8285774c
	if ctx.cr[6].eq {
	pc = 0x8285774C; continue 'dispatch;
	}
	// 8285773C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82857740: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82857744: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82857748: 4800000C  b 0x82857754
	pc = 0x82857754; continue 'dispatch;
            }
            0x8285774C => {
    //   block [0x8285774C..0x82857754)
	// 8285774C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82857750: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82857754; continue 'dispatch;
            }
            0x82857754 => {
    //   block [0x82857754..0x82857760)
	// 82857754: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82857758: 4199FFB8  bgt cr6, 0x82857710
	if ctx.cr[6].gt {
	pc = 0x82857710; continue 'dispatch;
	}
	// 8285775C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82857760; continue 'dispatch;
            }
            0x82857760 => {
    //   block [0x82857760..0x8285777C)
	// 82857760: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82857764: 419A0040  beq cr6, 0x828577a4
	if ctx.cr[6].eq {
	pc = 0x828577A4; continue 'dispatch;
	}
	// 82857768: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285776C: 2F0B0012  cmpwi cr6, r11, 0x12
	ctx.cr[6].compare_i32(ctx.r[11].s32, 18, &mut ctx.xer);
	// 82857770: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82857774: 41990008  bgt cr6, 0x8285777c
	if ctx.cr[6].gt {
	pc = 0x8285777C; continue 'dispatch;
	}
	// 82857778: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8285777C; continue 'dispatch;
            }
            0x8285777C => {
    //   block [0x8285777C..0x828577A4)
	// 8285777C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82857780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82857784: 409A0020  bne cr6, 0x828577a4
	if !ctx.cr[6].eq {
	pc = 0x828577A4; continue 'dispatch;
	}
	// 82857788: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285778C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82857790: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82857794: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82857798: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285779C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828577A0: 4800001C  b 0x828577bc
	pc = 0x828577BC; continue 'dispatch;
            }
            0x828577A4 => {
    //   block [0x828577A4..0x828577B8)
	// 828577A4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828577A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828577AC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828577B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828577B4: 48000008  b 0x828577bc
	pc = 0x828577BC; continue 'dispatch;
            }
            0x828577B8 => {
    //   block [0x828577B8..0x828577BC)
	// 828577B8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828577BC; continue 'dispatch;
            }
            0x828577BC => {
    //   block [0x828577BC..0x828577D0)
	// 828577BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828577C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828577C4: 419A000C  beq cr6, 0x828577d0
	if ctx.cr[6].eq {
	pc = 0x828577D0; continue 'dispatch;
	}
	// 828577C8: 4BEBD2A1  bl 0x82714a68
	ctx.lr = 0x828577CC;
	sub_82714A68(ctx, base);
	// 828577CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	pc = 0x828577D0; continue 'dispatch;
            }
            0x828577D0 => {
    //   block [0x828577D0..0x828577E8)
	// 828577D0: 80BF0050  lwz r5, 0x50(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 828577D4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828577D8: 419A0010  beq cr6, 0x828577e8
	if ctx.cr[6].eq {
	pc = 0x828577E8; continue 'dispatch;
	}
	// 828577DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828577E0: 387F0094  addi r3, r31, 0x94
	ctx.r[3].s64 = ctx.r[31].s64 + 148;
	// 828577E4: 4BFFFA3D  bl 0x82857220
	ctx.lr = 0x828577E8;
	sub_82857220(ctx, base);
	pc = 0x828577E8; continue 'dispatch;
            }
            0x828577E8 => {
    //   block [0x828577E8..0x82857800)
	// 828577E8: 80BF0060  lwz r5, 0x60(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 828577EC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828577F0: 419A0010  beq cr6, 0x82857800
	if ctx.cr[6].eq {
	pc = 0x82857800; continue 'dispatch;
	}
	// 828577F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828577F8: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 828577FC: 4BFFFA25  bl 0x82857220
	ctx.lr = 0x82857800;
	sub_82857220(ctx, base);
	pc = 0x82857800; continue 'dispatch;
            }
            0x82857800 => {
    //   block [0x82857800..0x82857818)
	// 82857800: 80BF0058  lwz r5, 0x58(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82857804: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82857808: 419A0010  beq cr6, 0x82857818
	if ctx.cr[6].eq {
	pc = 0x82857818; continue 'dispatch;
	}
	// 8285780C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82857810: 387F00AC  addi r3, r31, 0xac
	ctx.r[3].s64 = ctx.r[31].s64 + 172;
	// 82857814: 4BFFFA0D  bl 0x82857220
	ctx.lr = 0x82857818;
	sub_82857220(ctx, base);
	pc = 0x82857818; continue 'dispatch;
            }
            0x82857818 => {
    //   block [0x82857818..0x82857830)
	// 82857818: 80BF0068  lwz r5, 0x68(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8285781C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82857820: 419A0010  beq cr6, 0x82857830
	if ctx.cr[6].eq {
	pc = 0x82857830; continue 'dispatch;
	}
	// 82857824: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82857828: 387F00DC  addi r3, r31, 0xdc
	ctx.r[3].s64 = ctx.r[31].s64 + 220;
	// 8285782C: 4BFFF9F5  bl 0x82857220
	ctx.lr = 0x82857830;
	sub_82857220(ctx, base);
	pc = 0x82857830; continue 'dispatch;
            }
            0x82857830 => {
    //   block [0x82857830..0x82857844)
	// 82857830: 387F00F4  addi r3, r31, 0xf4
	ctx.r[3].s64 = ctx.r[31].s64 + 244;
	// 82857834: 4B9602E5  bl 0x821b7b18
	ctx.lr = 0x82857838;
	sub_821B7B18(ctx, base);
	// 82857838: 93BF00F4  stw r29, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[29].u32 ) };
	// 8285783C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82857840: 48451C1C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82857848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82857848 size=2316
    let mut pc: u32 = 0x82857848;
    'dispatch: loop {
        match pc {
            0x82857848 => {
    //   block [0x82857848..0x828578A8)
	// 82857848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285784C: 48451BA9  bl 0x82ca93f4
	ctx.lr = 0x82857850;
	sub_82CA93D0(ctx, base);
	// 82857850: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 82857854: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82857858: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285785C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82857860: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82857864: 7F38CB78  mr r24, r25
	ctx.r[24].u64 = ctx.r[25].u64;
	// 82857868: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285786C: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82857870: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 82857874: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82857878: 419A00F4  beq cr6, 0x8285796c
	if ctx.cr[6].eq {
	pc = 0x8285796C; continue 'dispatch;
	}
	// 8285787C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82857880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82857884: 419A0024  beq cr6, 0x828578a8
	if ctx.cr[6].eq {
	pc = 0x828578A8; continue 'dispatch;
	}
	// 82857888: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 8285788C: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82857890: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82857894: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82857898: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285789C: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 828578A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828578A4: 480000CC  b 0x82857970
	pc = 0x82857970; continue 'dispatch;
            }
            0x828578A8 => {
    //   block [0x828578A8..0x828578C4)
	// 828578A8: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828578AC: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 828578B0: 93210088  stw r25, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[25].u32 ) };
	// 828578B4: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 828578B8: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 828578BC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828578C0: 40810054  ble 0x82857914
	if !ctx.cr[0].gt {
	pc = 0x82857914; continue 'dispatch;
	}
	pc = 0x828578C4; continue 'dispatch;
            }
            0x828578C4 => {
    //   block [0x828578C4..0x828578E4)
	// 828578C4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828578C8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828578CC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828578D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828578D4: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828578D8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828578DC: 41980008  blt cr6, 0x828578e4
	if ctx.cr[6].lt {
	pc = 0x828578E4; continue 'dispatch;
	}
	// 828578E0: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x828578E4; continue 'dispatch;
            }
            0x828578E4 => {
    //   block [0x828578E4..0x82857900)
	// 828578E4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828578E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828578EC: 419A0014  beq cr6, 0x82857900
	if ctx.cr[6].eq {
	pc = 0x82857900; continue 'dispatch;
	}
	// 828578F0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828578F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828578F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828578FC: 4800000C  b 0x82857908
	pc = 0x82857908; continue 'dispatch;
            }
            0x82857900 => {
    //   block [0x82857900..0x82857908)
	// 82857900: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82857904: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82857908; continue 'dispatch;
            }
            0x82857908 => {
    //   block [0x82857908..0x82857914)
	// 82857908: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285790C: 4199FFB8  bgt cr6, 0x828578c4
	if ctx.cr[6].gt {
	pc = 0x828578C4; continue 'dispatch;
	}
	// 82857910: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	pc = 0x82857914; continue 'dispatch;
            }
            0x82857914 => {
    //   block [0x82857914..0x82857930)
	// 82857914: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82857918: 419A0040  beq cr6, 0x82857958
	if ctx.cr[6].eq {
	pc = 0x82857958; continue 'dispatch;
	}
	// 8285791C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857920: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82857924: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82857928: 41990008  bgt cr6, 0x82857930
	if ctx.cr[6].gt {
	pc = 0x82857930; continue 'dispatch;
	}
	// 8285792C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82857930; continue 'dispatch;
            }
            0x82857930 => {
    //   block [0x82857930..0x82857958)
	// 82857930: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82857934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82857938: 409A0020  bne cr6, 0x82857958
	if !ctx.cr[6].eq {
	pc = 0x82857958; continue 'dispatch;
	}
	// 8285793C: E9610088  ld r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82857940: F9610088  std r11, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 82857944: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82857948: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285794C: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 82857950: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82857954: 4800001C  b 0x82857970
	pc = 0x82857970; continue 'dispatch;
            }
            0x82857958 => {
    //   block [0x82857958..0x8285796C)
	// 82857958: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8285795C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82857960: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 82857964: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82857968: 48000008  b 0x82857970
	pc = 0x82857970; continue 'dispatch;
            }
            0x8285796C => {
    //   block [0x8285796C..0x82857970)
	// 8285796C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82857970; continue 'dispatch;
            }
            0x82857970 => {
    //   block [0x82857970..0x828579C8)
	// 82857970: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82857974: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82857978: 3AEAE0E0  addi r23, r10, -0x1f20
	ctx.r[23].s64 = ctx.r[10].s64 + -7968;
	// 8285797C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82857980: C3D7B3B0  lfs f30, -0x4c50(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-19536 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82857984: C3F7B3A4  lfs f31, -0x4c5c(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-19548 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82857988: 419A0638  beq cr6, 0x82857fc0
	if ctx.cr[6].eq {
	pc = 0x82857FC0; continue 'dispatch;
	}
	// 8285798C: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82857990: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82857994: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 82857998: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285799C: 419A00E8  beq cr6, 0x82857a84
	if ctx.cr[6].eq {
	pc = 0x82857A84; continue 'dispatch;
	}
	// 828579A0: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828579A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828579A8: 419A0020  beq cr6, 0x828579c8
	if ctx.cr[6].eq {
	pc = 0x828579C8; continue 'dispatch;
	}
	// 828579AC: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828579B0: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828579B4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828579B8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828579BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828579C0: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828579C4: 480000C4  b 0x82857a88
	pc = 0x82857A88; continue 'dispatch;
            }
            0x828579C8 => {
    //   block [0x828579C8..0x828579E4)
	// 828579C8: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828579CC: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 828579D0: 93210088  stw r25, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[25].u32 ) };
	// 828579D4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828579D8: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 828579DC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828579E0: 40810054  ble 0x82857a34
	if !ctx.cr[0].gt {
	pc = 0x82857A34; continue 'dispatch;
	}
	pc = 0x828579E4; continue 'dispatch;
            }
            0x828579E4 => {
    //   block [0x828579E4..0x82857A04)
	// 828579E4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828579E8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828579EC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828579F0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828579F4: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828579F8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828579FC: 41980008  blt cr6, 0x82857a04
	if ctx.cr[6].lt {
	pc = 0x82857A04; continue 'dispatch;
	}
	// 82857A00: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x82857A04; continue 'dispatch;
            }
            0x82857A04 => {
    //   block [0x82857A04..0x82857A20)
	// 82857A04: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82857A08: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82857A0C: 419A0014  beq cr6, 0x82857a20
	if ctx.cr[6].eq {
	pc = 0x82857A20; continue 'dispatch;
	}
	// 82857A10: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82857A14: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82857A18: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82857A1C: 4800000C  b 0x82857a28
	pc = 0x82857A28; continue 'dispatch;
            }
            0x82857A20 => {
    //   block [0x82857A20..0x82857A28)
	// 82857A20: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82857A24: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82857A28; continue 'dispatch;
            }
            0x82857A28 => {
    //   block [0x82857A28..0x82857A34)
	// 82857A28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82857A2C: 4199FFB8  bgt cr6, 0x828579e4
	if ctx.cr[6].gt {
	pc = 0x828579E4; continue 'dispatch;
	}
	// 82857A30: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	pc = 0x82857A34; continue 'dispatch;
            }
            0x82857A34 => {
    //   block [0x82857A34..0x82857A50)
	// 82857A34: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82857A38: 419A003C  beq cr6, 0x82857a74
	if ctx.cr[6].eq {
	pc = 0x82857A74; continue 'dispatch;
	}
	// 82857A3C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857A40: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 82857A44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82857A48: 41990008  bgt cr6, 0x82857a50
	if ctx.cr[6].gt {
	pc = 0x82857A50; continue 'dispatch;
	}
	// 82857A4C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82857A50; continue 'dispatch;
            }
            0x82857A50 => {
    //   block [0x82857A50..0x82857A74)
	// 82857A50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82857A54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82857A58: 409A001C  bne cr6, 0x82857a74
	if !ctx.cr[6].eq {
	pc = 0x82857A74; continue 'dispatch;
	}
	// 82857A5C: E9610088  ld r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82857A60: F9610088  std r11, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 82857A64: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82857A68: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82857A6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82857A70: 48000018  b 0x82857a88
	pc = 0x82857A88; continue 'dispatch;
            }
            0x82857A74 => {
    //   block [0x82857A74..0x82857A84)
	// 82857A74: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82857A78: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82857A7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82857A80: 48000008  b 0x82857a88
	pc = 0x82857A88; continue 'dispatch;
            }
            0x82857A84 => {
    //   block [0x82857A84..0x82857A88)
	// 82857A84: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82857A88; continue 'dispatch;
            }
            0x82857A88 => {
    //   block [0x82857A88..0x82857E18)
	// 82857A88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82857A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82857A90: 419A0530  beq cr6, 0x82857fc0
	if ctx.cr[6].eq {
	pc = 0x82857FC0; continue 'dispatch;
	}
	// 82857A94: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82857A98: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82857A9C: 388BF1C4  addi r4, r11, -0xe3c
	ctx.r[4].s64 = ctx.r[11].s64 + -3644;
	// 82857AA0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82857AA4: 4B9D542D  bl 0x8222ced0
	ctx.lr = 0x82857AA8;
	sub_8222CED0(ctx, base);
	// 82857AA8: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82857AAC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82857AB0: 388AF1C8  addi r4, r10, -0xe38
	ctx.r[4].s64 = ctx.r[10].s64 + -3640;
	// 82857AB4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82857AB8: 4B9D5419  bl 0x8222ced0
	ctx.lr = 0x82857ABC;
	sub_8222CED0(ctx, base);
	// 82857ABC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82857AC0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82857AC4: 38890E20  addi r4, r9, 0xe20
	ctx.r[4].s64 = ctx.r[9].s64 + 3616;
	// 82857AC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82857ACC: 4B9D5405  bl 0x8222ced0
	ctx.lr = 0x82857AD0;
	sub_8222CED0(ctx, base);
	// 82857AD0: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82857AD4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82857AD8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82857ADC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82857AE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82857AE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857AE8: 4BA2C249  bl 0x82283d30
	ctx.lr = 0x82857AEC;
	sub_82283D30(ctx, base);
	// 82857AEC: 3B5E0010  addi r26, r30, 0x10
	ctx.r[26].s64 = ctx.r[30].s64 + 16;
	// 82857AF0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857AF4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82857AF8: 4BA1B561  bl 0x82273058
	ctx.lr = 0x82857AFC;
	sub_82273058(ctx, base);
	// 82857AFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82857B00: 4B9BD2D9  bl 0x82214dd8
	ctx.lr = 0x82857B04;
	sub_82214DD8(ctx, base);
	// 82857B04: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 82857B08: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82857B0C: 3888F1D0  addi r4, r8, -0xe30
	ctx.r[4].s64 = ctx.r[8].s64 + -3632;
	// 82857B10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82857B14: 4B9D53BD  bl 0x8222ced0
	ctx.lr = 0x82857B18;
	sub_8222CED0(ctx, base);
	// 82857B18: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82857B1C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82857B20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82857B24: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82857B28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82857B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857B30: 4BA2C201  bl 0x82283d30
	ctx.lr = 0x82857B34;
	sub_82283D30(ctx, base);
	// 82857B34: 387E0018  addi r3, r30, 0x18
	ctx.r[3].s64 = ctx.r[30].s64 + 24;
	// 82857B38: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857B3C: 4BA1B51D  bl 0x82273058
	ctx.lr = 0x82857B40;
	sub_82273058(ctx, base);
	// 82857B40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82857B44: 4B9BD295  bl 0x82214dd8
	ctx.lr = 0x82857B48;
	sub_82214DD8(ctx, base);
	// 82857B48: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 82857B4C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82857B50: 3887F1D8  addi r4, r7, -0xe28
	ctx.r[4].s64 = ctx.r[7].s64 + -3624;
	// 82857B54: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82857B58: 4B9D5379  bl 0x8222ced0
	ctx.lr = 0x82857B5C;
	sub_8222CED0(ctx, base);
	// 82857B5C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82857B60: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82857B64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82857B68: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82857B6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82857B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857B74: 4BA2C1BD  bl 0x82283d30
	ctx.lr = 0x82857B78;
	sub_82283D30(ctx, base);
	// 82857B78: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 82857B7C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857B80: 4BA1B4D9  bl 0x82273058
	ctx.lr = 0x82857B84;
	sub_82273058(ctx, base);
	// 82857B84: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82857B88: 4B9BD251  bl 0x82214dd8
	ctx.lr = 0x82857B8C;
	sub_82214DD8(ctx, base);
	// 82857B8C: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 82857B90: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82857B94: 38860EF4  addi r4, r6, 0xef4
	ctx.r[4].s64 = ctx.r[6].s64 + 3828;
	// 82857B98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82857B9C: 4B9D5335  bl 0x8222ced0
	ctx.lr = 0x82857BA0;
	sub_8222CED0(ctx, base);
	// 82857BA0: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82857BA4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82857BA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82857BAC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82857BB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82857BB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857BB8: 4BA2C179  bl 0x82283d30
	ctx.lr = 0x82857BBC;
	sub_82283D30(ctx, base);
	// 82857BBC: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82857BC0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857BC4: 4BA1B495  bl 0x82273058
	ctx.lr = 0x82857BC8;
	sub_82273058(ctx, base);
	// 82857BC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82857BCC: 4B9BD20D  bl 0x82214dd8
	ctx.lr = 0x82857BD0;
	sub_82214DD8(ctx, base);
	// 82857BD0: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 82857BD4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82857BD8: 3884F1E0  addi r4, r4, -0xe20
	ctx.r[4].s64 = ctx.r[4].s64 + -3616;
	// 82857BDC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82857BE0: 4B9D52F1  bl 0x8222ced0
	ctx.lr = 0x82857BE4;
	sub_8222CED0(ctx, base);
	// 82857BE4: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82857BE8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82857BEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82857BF0: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82857BF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82857BF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857BFC: 4BA2C135  bl 0x82283d30
	ctx.lr = 0x82857C00;
	sub_82283D30(ctx, base);
	// 82857C00: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 82857C04: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857C08: 4BA1B451  bl 0x82273058
	ctx.lr = 0x82857C0C;
	sub_82273058(ctx, base);
	// 82857C0C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82857C10: 4B9BD1C9  bl 0x82214dd8
	ctx.lr = 0x82857C14;
	sub_82214DD8(ctx, base);
	// 82857C14: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 82857C18: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82857C1C: 3883F1F0  addi r4, r3, -0xe10
	ctx.r[4].s64 = ctx.r[3].s64 + -3600;
	// 82857C20: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82857C24: 4B9D52AD  bl 0x8222ced0
	ctx.lr = 0x82857C28;
	sub_8222CED0(ctx, base);
	// 82857C28: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82857C2C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82857C30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82857C34: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82857C38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82857C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857C40: 4BA2C0F1  bl 0x82283d30
	ctx.lr = 0x82857C44;
	sub_82283D30(ctx, base);
	// 82857C44: 387E0038  addi r3, r30, 0x38
	ctx.r[3].s64 = ctx.r[30].s64 + 56;
	// 82857C48: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857C4C: 4BA1B40D  bl 0x82273058
	ctx.lr = 0x82857C50;
	sub_82273058(ctx, base);
	// 82857C50: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82857C54: 4B9BD185  bl 0x82214dd8
	ctx.lr = 0x82857C58;
	sub_82214DD8(ctx, base);
	// 82857C58: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82857C5C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82857C60: 388BF204  addi r4, r11, -0xdfc
	ctx.r[4].s64 = ctx.r[11].s64 + -3580;
	// 82857C64: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82857C68: 4B9D5269  bl 0x8222ced0
	ctx.lr = 0x82857C6C;
	sub_8222CED0(ctx, base);
	// 82857C6C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82857C70: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82857C74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82857C78: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82857C7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82857C80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857C84: 4BA2C0AD  bl 0x82283d30
	ctx.lr = 0x82857C88;
	sub_82283D30(ctx, base);
	// 82857C88: 387E0040  addi r3, r30, 0x40
	ctx.r[3].s64 = ctx.r[30].s64 + 64;
	// 82857C8C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857C90: 4BA1B3C9  bl 0x82273058
	ctx.lr = 0x82857C94;
	sub_82273058(ctx, base);
	// 82857C94: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82857C98: 4B9BD141  bl 0x82214dd8
	ctx.lr = 0x82857C9C;
	sub_82214DD8(ctx, base);
	// 82857C9C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82857CA0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82857CA4: 388AF218  addi r4, r10, -0xde8
	ctx.r[4].s64 = ctx.r[10].s64 + -3560;
	// 82857CA8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82857CAC: 4B9D5225  bl 0x8222ced0
	ctx.lr = 0x82857CB0;
	sub_8222CED0(ctx, base);
	// 82857CB0: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82857CB4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82857CB8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82857CBC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82857CC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82857CC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857CC8: 4BA2C069  bl 0x82283d30
	ctx.lr = 0x82857CCC;
	sub_82283D30(ctx, base);
	// 82857CCC: 387E0048  addi r3, r30, 0x48
	ctx.r[3].s64 = ctx.r[30].s64 + 72;
	// 82857CD0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857CD4: 4BA1B385  bl 0x82273058
	ctx.lr = 0x82857CD8;
	sub_82273058(ctx, base);
	// 82857CD8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82857CDC: 4B9BD0FD  bl 0x82214dd8
	ctx.lr = 0x82857CE0;
	sub_82214DD8(ctx, base);
	// 82857CE0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82857CE4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82857CE8: 38890D6C  addi r4, r9, 0xd6c
	ctx.r[4].s64 = ctx.r[9].s64 + 3436;
	// 82857CEC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82857CF0: 4B9D51E1  bl 0x8222ced0
	ctx.lr = 0x82857CF4;
	sub_8222CED0(ctx, base);
	// 82857CF4: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82857CF8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82857CFC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82857D00: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 82857D04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82857D08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857D0C: 4BA2C025  bl 0x82283d30
	ctx.lr = 0x82857D10;
	sub_82283D30(ctx, base);
	// 82857D10: 3BBE0050  addi r29, r30, 0x50
	ctx.r[29].s64 = ctx.r[30].s64 + 80;
	// 82857D14: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857D18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82857D1C: 4BA1B33D  bl 0x82273058
	ctx.lr = 0x82857D20;
	sub_82273058(ctx, base);
	// 82857D20: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82857D24: 4B9BD0B5  bl 0x82214dd8
	ctx.lr = 0x82857D28;
	sub_82214DD8(ctx, base);
	// 82857D28: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82857D2C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82857D30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82857D34: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 82857D38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82857D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857D40: 4BA2BFF1  bl 0x82283d30
	ctx.lr = 0x82857D44;
	sub_82283D30(ctx, base);
	// 82857D44: 3B9E0058  addi r28, r30, 0x58
	ctx.r[28].s64 = ctx.r[30].s64 + 88;
	// 82857D48: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857D4C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82857D50: 4BA1B309  bl 0x82273058
	ctx.lr = 0x82857D54;
	sub_82273058(ctx, base);
	// 82857D54: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82857D58: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82857D5C: 38882228  addi r4, r8, 0x2228
	ctx.r[4].s64 = ctx.r[8].s64 + 8744;
	// 82857D60: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82857D64: 4B9D516D  bl 0x8222ced0
	ctx.lr = 0x82857D68;
	sub_8222CED0(ctx, base);
	// 82857D68: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82857D6C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82857D70: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82857D74: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 82857D78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82857D7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857D80: 4BA2BFB1  bl 0x82283d30
	ctx.lr = 0x82857D84;
	sub_82283D30(ctx, base);
	// 82857D84: 3B7E0060  addi r27, r30, 0x60
	ctx.r[27].s64 = ctx.r[30].s64 + 96;
	// 82857D88: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857D8C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82857D90: 4BA1B2C9  bl 0x82273058
	ctx.lr = 0x82857D94;
	sub_82273058(ctx, base);
	// 82857D94: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82857D98: 4B9BD041  bl 0x82214dd8
	ctx.lr = 0x82857D9C;
	sub_82214DD8(ctx, base);
	// 82857D9C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82857DA0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82857DA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82857DA8: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82857DAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82857DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857DB4: 4BA2BF7D  bl 0x82283d30
	ctx.lr = 0x82857DB8;
	sub_82283D30(ctx, base);
	// 82857DB8: 387E0068  addi r3, r30, 0x68
	ctx.r[3].s64 = ctx.r[30].s64 + 104;
	// 82857DBC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857DC0: 4BA1B299  bl 0x82273058
	ctx.lr = 0x82857DC4;
	sub_82273058(ctx, base);
	// 82857DC4: 80FE0050  lwz r7, 0x50(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82857DC8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82857DCC: 419A00C4  beq cr6, 0x82857e90
	if ctx.cr[6].eq {
	pc = 0x82857E90; continue 'dispatch;
	}
	// 82857DD0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857DD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82857DD8: 419A00B8  beq cr6, 0x82857e90
	if ctx.cr[6].eq {
	pc = 0x82857E90; continue 'dispatch;
	}
	// 82857DDC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857DE0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82857DE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82857DE8: 419A0070  beq cr6, 0x82857e58
	if ctx.cr[6].eq {
	pc = 0x82857E58; continue 'dispatch;
	}
	// 82857DEC: 4B9C746D  bl 0x8221f258
	ctx.lr = 0x82857DF0;
	sub_8221F258(ctx, base);
	// 82857DF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82857DF4: 419A0024  beq cr6, 0x82857e18
	if ctx.cr[6].eq {
	pc = 0x82857E18; continue 'dispatch;
	}
	// 82857DF8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82857DFC: 80FC0000  lwz r7, 0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857E00: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857E04: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82857E08: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82857E0C: 4BF09C95  bl 0x82761aa0
	ctx.lr = 0x82857E10;
	sub_82761AA0(ctx, base);
	// 82857E10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82857E14: 48000008  b 0x82857e1c
	pc = 0x82857E1C; continue 'dispatch;
            }
            0x82857E18 => {
    //   block [0x82857E18..0x82857E1C)
	// 82857E18: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	pc = 0x82857E1C; continue 'dispatch;
            }
            0x82857E1C => {
    //   block [0x82857E1C..0x82857E58)
	// 82857E1C: 3BFE0070  addi r31, r30, 0x70
	ctx.r[31].s64 = ctx.r[30].s64 + 112;
	// 82857E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82857E24: 4BA1B235  bl 0x82273058
	ctx.lr = 0x82857E28;
	sub_82273058(ctx, base);
	// 82857E28: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82857E2C: 4B9C742D  bl 0x8221f258
	ctx.lr = 0x82857E30;
	sub_8221F258(ctx, base);
	// 82857E30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82857E34: 419A0050  beq cr6, 0x82857e84
	if ctx.cr[6].eq {
	pc = 0x82857E84; continue 'dispatch;
	}
	// 82857E38: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82857E3C: 80FB0000  lwz r7, 0(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857E40: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857E44: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82857E48: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82857E4C: 4BF09C55  bl 0x82761aa0
	ctx.lr = 0x82857E50;
	sub_82761AA0(ctx, base);
	// 82857E50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82857E54: 48000034  b 0x82857e88
	pc = 0x82857E88; continue 'dispatch;
            }
            0x82857E58 => {
    //   block [0x82857E58..0x82857E84)
	// 82857E58: 4B9C7401  bl 0x8221f258
	ctx.lr = 0x82857E5C;
	sub_8221F258(ctx, base);
	// 82857E5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82857E60: 419A0024  beq cr6, 0x82857e84
	if ctx.cr[6].eq {
	pc = 0x82857E84; continue 'dispatch;
	}
	// 82857E64: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82857E68: 80FB0000  lwz r7, 0(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857E6C: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857E70: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82857E74: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82857E78: 4BF09C29  bl 0x82761aa0
	ctx.lr = 0x82857E7C;
	sub_82761AA0(ctx, base);
	// 82857E7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82857E80: 48000008  b 0x82857e88
	pc = 0x82857E88; continue 'dispatch;
            }
            0x82857E84 => {
    //   block [0x82857E84..0x82857E88)
	// 82857E84: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	pc = 0x82857E88; continue 'dispatch;
            }
            0x82857E88 => {
    //   block [0x82857E88..0x82857E90)
	// 82857E88: 387E0078  addi r3, r30, 0x78
	ctx.r[3].s64 = ctx.r[30].s64 + 120;
	// 82857E8C: 4BA1B1CD  bl 0x82273058
	ctx.lr = 0x82857E90;
	sub_82273058(ctx, base);
	pc = 0x82857E90; continue 'dispatch;
            }
            0x82857E90 => {
    //   block [0x82857E90..0x82857EBC)
	// 82857E90: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857E94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82857E98: 419A0118  beq cr6, 0x82857fb0
	if ctx.cr[6].eq {
	pc = 0x82857FB0; continue 'dispatch;
	}
	// 82857E9C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82857EA0: 4B9C73B9  bl 0x8221f258
	ctx.lr = 0x82857EA4;
	sub_8221F258(ctx, base);
	// 82857EA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82857EA8: 419A0014  beq cr6, 0x82857ebc
	if ctx.cr[6].eq {
	pc = 0x82857EBC; continue 'dispatch;
	}
	// 82857EAC: C037D650  lfs f1, -0x29b0(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-10672 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82857EB0: 4BA33C91  bl 0x8228bb40
	ctx.lr = 0x82857EB4;
	sub_8228BB40(ctx, base);
	// 82857EB4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82857EB8: 48000008  b 0x82857ec0
	pc = 0x82857EC0; continue 'dispatch;
            }
            0x82857EBC => {
    //   block [0x82857EBC..0x82857EC0)
	// 82857EBC: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x82857EC0; continue 'dispatch;
            }
            0x82857EC0 => {
    //   block [0x82857EC0..0x82857EF8)
	// 82857EC0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82857EC4: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857EC8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82857ECC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82857ED0: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82857ED4: 4B97626D  bl 0x821ce140
	ctx.lr = 0x82857ED8;
	sub_821CE140(ctx, base);
	// 82857ED8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82857EDC: 807E0084  lwz r3, 0x84(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 82857EE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857EE4: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82857EE8: 419A0078  beq cr6, 0x82857f60
	if ctx.cr[6].eq {
	pc = 0x82857F60; continue 'dispatch;
	}
	// 82857EEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82857EF0: 419A0040  beq cr6, 0x82857f30
	if ctx.cr[6].eq {
	pc = 0x82857F30; continue 'dispatch;
	}
	// 82857EF4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82857EF8; continue 'dispatch;
            }
            0x82857EF8 => {
    //   block [0x82857EF8..0x82857F2C)
	// 82857EF8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82857EFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82857F00: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82857F04: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82857F08: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82857F0C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82857F10: 4082FFE8  bne 0x82857ef8
	if !ctx.cr[0].eq {
	pc = 0x82857EF8; continue 'dispatch;
	}
	// 82857F14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82857F18: 409A0014  bne cr6, 0x82857f2c
	if !ctx.cr[6].eq {
	pc = 0x82857F2C; continue 'dispatch;
	}
	// 82857F1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857F20: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82857F24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82857F28: 4E800421  bctrl
	ctx.lr = 0x82857F2C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82857F2C => {
    //   block [0x82857F2C..0x82857F30)
	// 82857F2C: 933E0084  stw r25, 0x84(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[25].u32 ) };
	pc = 0x82857F30; continue 'dispatch;
            }
            0x82857F30 => {
    //   block [0x82857F30..0x82857F44)
	// 82857F30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82857F38: 917E0084  stw r11, 0x84(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82857F3C: 419A0024  beq cr6, 0x82857f60
	if ctx.cr[6].eq {
	pc = 0x82857F60; continue 'dispatch;
	}
	// 82857F40: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82857F44; continue 'dispatch;
            }
            0x82857F44 => {
    //   block [0x82857F44..0x82857F60)
	// 82857F44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82857F48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82857F4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82857F50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82857F54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82857F58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82857F5C: 4082FFE8  bne 0x82857f44
	if !ctx.cr[0].eq {
	pc = 0x82857F44; continue 'dispatch;
	}
	pc = 0x82857F60; continue 'dispatch;
            }
            0x82857F60 => {
    //   block [0x82857F60..0x82857F74)
	// 82857F60: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82857F64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82857F68: 419A0048  beq cr6, 0x82857fb0
	if ctx.cr[6].eq {
	pc = 0x82857FB0; continue 'dispatch;
	}
	// 82857F6C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82857F70: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82857F74; continue 'dispatch;
            }
            0x82857F74 => {
    //   block [0x82857F74..0x82857FAC)
	// 82857F74: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82857F78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82857F7C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82857F80: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82857F84: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82857F88: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82857F8C: 4082FFE8  bne 0x82857f74
	if !ctx.cr[0].eq {
	pc = 0x82857F74; continue 'dispatch;
	}
	// 82857F90: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82857F94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82857F98: 409A0014  bne cr6, 0x82857fac
	if !ctx.cr[6].eq {
	pc = 0x82857FAC; continue 'dispatch;
	}
	// 82857F9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82857FA0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82857FA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82857FA8: 4E800421  bctrl
	ctx.lr = 0x82857FAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82857FAC => {
    //   block [0x82857FAC..0x82857FB0)
	// 82857FAC: 9321007C  stw r25, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[25].u32 ) };
	pc = 0x82857FB0; continue 'dispatch;
            }
            0x82857FB0 => {
    //   block [0x82857FB0..0x82857FC0)
	// 82857FB0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82857FB4: 4B9BCE25  bl 0x82214dd8
	ctx.lr = 0x82857FB8;
	sub_82214DD8(ctx, base);
	// 82857FB8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82857FBC: 4B9BCE1D  bl 0x82214dd8
	ctx.lr = 0x82857FC0;
	sub_82214DD8(ctx, base);
	pc = 0x82857FC0; continue 'dispatch;
            }
            0x82857FC0 => {
    //   block [0x82857FC0..0x8285804C)
	// 82857FC0: D3FE00FC  stfs f31, 0xfc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82857FC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82857FC8: D3FE0108  stfs f31, 0x108(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82857FCC: D3FE0114  stfs f31, 0x114(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82857FD0: 4BFFF6C9  bl 0x82857698
	ctx.lr = 0x82857FD4;
	sub_82857698(ctx, base);
	// 82857FD4: 387E00F4  addi r3, r30, 0xf4
	ctx.r[3].s64 = ctx.r[30].s64 + 244;
	// 82857FD8: 4B95FB41  bl 0x821b7b18
	ctx.lr = 0x82857FDC;
	sub_821B7B18(ctx, base);
	// 82857FDC: 933E00F4  stw r25, 0xf4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(244 as u32), ctx.r[25].u32 ) };
	// 82857FE0: 387E0100  addi r3, r30, 0x100
	ctx.r[3].s64 = ctx.r[30].s64 + 256;
	// 82857FE4: 4B95FB35  bl 0x821b7b18
	ctx.lr = 0x82857FE8;
	sub_821B7B18(ctx, base);
	// 82857FE8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82857FEC: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82857FF0: 933E0100  stw r25, 0x100(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), ctx.r[25].u32 ) };
	// 82857FF4: 9B3E011C  stb r25, 0x11c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(284 as u32), ctx.r[25].u8 ) };
	// 82857FF8: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82857FFC: 915E0120  stw r10, 0x120(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(288 as u32), ctx.r[10].u32 ) };
	// 82858000: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 82858004: 9B3E011D  stb r25, 0x11d(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(285 as u32), ctx.r[25].u8 ) };
	// 82858008: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8285800C: 8149C2D8  lwz r10, -0x3d28(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-15656 as u32) ) } as u64;
	// 82858010: 81089650  lwz r8, -0x69b0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 82858014: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82858018: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8285801C: 80C70058  lwz r6, 0x58(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 82858020: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82858024: 80AB0078  lwz r5, 0x78(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82858028: 1D2524A1  mulli r9, r5, 0x24a1
	ctx.r[9].s32 = ((ctx.r[5].s32 as i64 * 9377 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8285802C: 388924DF  addi r4, r9, 0x24df
	ctx.r[4].s64 = ctx.r[9].s64 + 9439;
	// 82858030: 5489983E  rotlwi r9, r4, 0x13
	ctx.r[9].u64 = ((ctx.r[4].u32).rotate_left(19)) as u64;
	// 82858034: 912B0078  stw r9, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 82858038: 419A0014  beq cr6, 0x8285804c
	if ctx.cr[6].eq {
	pc = 0x8285804C; continue 'dispatch;
	}
	// 8285803C: 7D695396  divwu r11, r9, r10
	ctx.r[11].u32 = ctx.r[9].u32 / ctx.r[10].u32;
	// 82858040: 7D4B51D6  mullw r10, r11, r10
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82858044: 7D6A4850  subf r11, r10, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82858048: 48000008  b 0x82858050
	pc = 0x82858050; continue 'dispatch;
            }
            0x8285804C => {
    //   block [0x8285804C..0x82858050)
	// 8285804C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82858050; continue 'dispatch;
            }
            0x82858050 => {
    //   block [0x82858050..0x82858154)
	// 82858050: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82858054: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82858058: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8285805C: 917E0118  stw r11, 0x118(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 82858060: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 82858064: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82858068: 8109004C  lwz r8, 0x4c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285806C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82858070: 4E800421  bctrl
	ctx.lr = 0x82858074;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82858074: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82858078: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8285807C: 8087007C  lwz r4, 0x7c(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(124 as u32) ) } as u64;
	// 82858080: 80C40000  lwz r6, 0(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82858084: 80A60044  lwz r5, 0x44(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(68 as u32) ) } as u64;
	// 82858088: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 8285808C: 4E800421  bctrl
	ctx.lr = 0x82858090;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82858090: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82858094: E8640000  ld r3, 0(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 82858098: E8840008  ld r4, 8(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	// 8285809C: 4B99DABD  bl 0x821f5b58
	ctx.lr = 0x828580A0;
	sub_821F5B58(ctx, base);
	// 828580A0: 3C60820A  lis r3, -0x7df6
	ctx.r[3].s64 = -2113273856;
	// 828580A4: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 828580A8: 394390F0  addi r10, r3, -0x6f10
	ctx.r[10].s64 = ctx.r[3].s64 + -28432;
	// 828580AC: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 828580B0: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82858158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82858158 size=608
    let mut pc: u32 = 0x82858158;
    'dispatch: loop {
        match pc {
            0x82858158 => {
    //   block [0x82858158..0x828581AC)
	// 82858158: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8285815C: 80C30004  lwz r6, 4(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82858160: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82858164: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82858168: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8285816C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82858170: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82858174: 81460030  lwz r10, 0x30(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(48 as u32) ) } as u64;
	// 82858178: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 8285817C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82858180: 419A00E8  beq cr6, 0x82858268
	if ctx.cr[6].eq {
	pc = 0x82858268; continue 'dispatch;
	}
	// 82858184: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82858188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285818C: 419A0020  beq cr6, 0x828581ac
	if ctx.cr[6].eq {
	pc = 0x828581AC; continue 'dispatch;
	}
	// 82858190: 894B0063  lbz r10, 0x63(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(99 as u32) ) } as u64;
	// 82858194: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82858198: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285819C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828581A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828581A4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828581A8: 480000C4  b 0x8285826c
	pc = 0x8285826C; continue 'dispatch;
            }
            0x828581AC => {
    //   block [0x828581AC..0x828581C8)
	// 828581AC: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828581B0: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 828581B4: 93E1FFF0  stw r31, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u32 ) };
	// 828581B8: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 828581BC: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 828581C0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828581C4: 40810054  ble 0x82858218
	if !ctx.cr[0].gt {
	pc = 0x82858218; continue 'dispatch;
	}
	pc = 0x828581C8; continue 'dispatch;
            }
            0x828581C8 => {
    //   block [0x828581C8..0x828581E8)
	// 828581C8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828581CC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828581D0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828581D4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828581D8: 2F070063  cmpwi cr6, r7, 0x63
	ctx.cr[6].compare_i32(ctx.r[7].s32, 99, &mut ctx.xer);
	// 828581DC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828581E0: 41980008  blt cr6, 0x828581e8
	if ctx.cr[6].lt {
	pc = 0x828581E8; continue 'dispatch;
	}
	// 828581E4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x828581E8; continue 'dispatch;
            }
            0x828581E8 => {
    //   block [0x828581E8..0x82858204)
	// 828581E8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828581EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828581F0: 419A0014  beq cr6, 0x82858204
	if ctx.cr[6].eq {
	pc = 0x82858204; continue 'dispatch;
	}
	// 828581F4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828581F8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828581FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82858200: 4800000C  b 0x8285820c
	pc = 0x8285820C; continue 'dispatch;
            }
            0x82858204 => {
    //   block [0x82858204..0x8285820C)
	// 82858204: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82858208: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285820C; continue 'dispatch;
            }
            0x8285820C => {
    //   block [0x8285820C..0x82858218)
	// 8285820C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82858210: 4199FFB8  bgt cr6, 0x828581c8
	if ctx.cr[6].gt {
	pc = 0x828581C8; continue 'dispatch;
	}
	// 82858214: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x82858218; continue 'dispatch;
            }
            0x82858218 => {
    //   block [0x82858218..0x82858234)
	// 82858218: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8285821C: 419A003C  beq cr6, 0x82858258
	if ctx.cr[6].eq {
	pc = 0x82858258; continue 'dispatch;
	}
	// 82858220: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82858224: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 82858228: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285822C: 41990008  bgt cr6, 0x82858234
	if ctx.cr[6].gt {
	pc = 0x82858234; continue 'dispatch;
	}
	// 82858230: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82858234; continue 'dispatch;
            }
            0x82858234 => {
    //   block [0x82858234..0x82858258)
	// 82858234: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82858238: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285823C: 409A001C  bne cr6, 0x82858258
	if !ctx.cr[6].eq {
	pc = 0x82858258; continue 'dispatch;
	}
	// 82858240: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82858244: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82858248: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 8285824C: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82858250: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82858254: 48000018  b 0x8285826c
	pc = 0x8285826C; continue 'dispatch;
            }
            0x82858258 => {
    //   block [0x82858258..0x82858268)
	// 82858258: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8285825C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82858260: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82858264: 48000008  b 0x8285826c
	pc = 0x8285826C; continue 'dispatch;
            }
            0x82858268 => {
    //   block [0x82858268..0x8285826C)
	// 82858268: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x8285826C; continue 'dispatch;
            }
            0x8285826C => {
    //   block [0x8285826C..0x82858290)
	// 8285826C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82858270: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82858274: 419A001C  beq cr6, 0x82858290
	if ctx.cr[6].eq {
	pc = 0x82858290; continue 'dispatch;
	}
	// 82858278: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285827C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82858280: 7D480034  cntlzw r8, r10
	ctx.r[8].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82858284: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82858288: 68E30001  xori r3, r7, 1
	ctx.r[3].u64 = ctx.r[7].u64 ^ 1;
	// 8285828C: 91240000  stw r9, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x82858290; continue 'dispatch;
            }
            0x82858290 => {
    //   block [0x82858290..0x828582D8)
	// 82858290: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82858294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82858298: 409A0118  bne cr6, 0x828583b0
	if !ctx.cr[6].eq {
	pc = 0x828583B0; continue 'dispatch;
	}
	// 8285829C: 81460030  lwz r10, 0x30(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(48 as u32) ) } as u64;
	// 828582A0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828582A4: 55494FFE  rlwinm r9, r10, 9, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x007FFFFFu64;
	// 828582A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828582AC: 419A00E4  beq cr6, 0x82858390
	if ctx.cr[6].eq {
	pc = 0x82858390; continue 'dispatch;
	}
	// 828582B0: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828582B4: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828582B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828582BC: 419A001C  beq cr6, 0x828582d8
	if ctx.cr[6].eq {
	pc = 0x828582D8; continue 'dispatch;
	}
	// 828582C0: 896B0077  lbz r11, 0x77(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(119 as u32) ) } as u64;
	// 828582C4: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828582C8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828582CC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828582D0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828582D4: 480000C0  b 0x82858394
	pc = 0x82858394; continue 'dispatch;
            }
            0x828582D8 => {
    //   block [0x828582D8..0x828582F0)
	// 828582D8: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 828582DC: 93E1FFF0  stw r31, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u32 ) };
	// 828582E0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828582E4: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 828582E8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828582EC: 40810054  ble 0x82858340
	if !ctx.cr[0].gt {
	pc = 0x82858340; continue 'dispatch;
	}
	pc = 0x828582F0; continue 'dispatch;
            }
            0x828582F0 => {
    //   block [0x828582F0..0x82858310)
	// 828582F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828582F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828582F8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828582FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82858300: 2F070077  cmpwi cr6, r7, 0x77
	ctx.cr[6].compare_i32(ctx.r[7].s32, 119, &mut ctx.xer);
	// 82858304: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82858308: 41980008  blt cr6, 0x82858310
	if ctx.cr[6].lt {
	pc = 0x82858310; continue 'dispatch;
	}
	// 8285830C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82858310; continue 'dispatch;
            }
            0x82858310 => {
    //   block [0x82858310..0x8285832C)
	// 82858310: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82858314: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82858318: 419A0014  beq cr6, 0x8285832c
	if ctx.cr[6].eq {
	pc = 0x8285832C; continue 'dispatch;
	}
	// 8285831C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82858320: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82858324: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82858328: 4800000C  b 0x82858334
	pc = 0x82858334; continue 'dispatch;
            }
            0x8285832C => {
    //   block [0x8285832C..0x82858334)
	// 8285832C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82858330: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82858334; continue 'dispatch;
            }
            0x82858334 => {
    //   block [0x82858334..0x82858340)
	// 82858334: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82858338: 4199FFB8  bgt cr6, 0x828582f0
	if ctx.cr[6].gt {
	pc = 0x828582F0; continue 'dispatch;
	}
	// 8285833C: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x82858340; continue 'dispatch;
            }
            0x82858340 => {
    //   block [0x82858340..0x8285835C)
	// 82858340: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82858344: 419A003C  beq cr6, 0x82858380
	if ctx.cr[6].eq {
	pc = 0x82858380; continue 'dispatch;
	}
	// 82858348: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285834C: 2F0B0077  cmpwi cr6, r11, 0x77
	ctx.cr[6].compare_i32(ctx.r[11].s32, 119, &mut ctx.xer);
	// 82858350: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82858354: 41990008  bgt cr6, 0x8285835c
	if ctx.cr[6].gt {
	pc = 0x8285835C; continue 'dispatch;
	}
	// 82858358: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8285835C; continue 'dispatch;
            }
            0x8285835C => {
    //   block [0x8285835C..0x82858380)
	// 8285835C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82858360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82858364: 409A001C  bne cr6, 0x82858380
	if !ctx.cr[6].eq {
	pc = 0x82858380; continue 'dispatch;
	}
	// 82858368: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285836C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82858370: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82858374: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82858378: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285837C: 48000018  b 0x82858394
	pc = 0x82858394; continue 'dispatch;
            }
            0x82858380 => {
    //   block [0x82858380..0x82858390)
	// 82858380: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82858384: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82858388: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285838C: 48000008  b 0x82858394
	pc = 0x82858394; continue 'dispatch;
            }
            0x82858390 => {
    //   block [0x82858390..0x82858394)
	// 82858390: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x82858394; continue 'dispatch;
            }
            0x82858394 => {
    //   block [0x82858394..0x828583B0)
	// 82858394: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82858398: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285839C: 419A0014  beq cr6, 0x828583b0
	if ctx.cr[6].eq {
	pc = 0x828583B0; continue 'dispatch;
	}
	// 828583A0: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 828583A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828583A8: 419A0008  beq cr6, 0x828583b0
	if ctx.cr[6].eq {
	pc = 0x828583B0; continue 'dispatch;
	}
	// 828583AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x828583B0; continue 'dispatch;
            }
            0x828583B0 => {
    //   block [0x828583B0..0x828583B8)
	// 828583B0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 828583B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828583B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828583B8 size=6528
    let mut pc: u32 = 0x828583B8;
    'dispatch: loop {
        match pc {
            0x828583B8 => {
    //   block [0x828583B8..0x82859D38)
	// 828583B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828583BC: 48451031  bl 0x82ca93ec
	ctx.lr = 0x828583C0;
	sub_82CA93D0(ctx, base);
	// 828583C0: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 828583C4: 48455909  bl 0x82cadccc
	ctx.lr = 0x828583C8;
	sub_82CADCA0(ctx, base);
	// 828583C8: 3980FF40  li r12, -0xc0
	ctx.r[12].s64 = -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82859D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82859D38 size=1492
    let mut pc: u32 = 0x82859D38;
    'dispatch: loop {
        match pc {
            0x82859D38 => {
    //   block [0x82859D38..0x82859D90)
	// 82859D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82859D3C: 4844F6D1  bl 0x82ca940c
	ctx.lr = 0x82859D40;
	sub_82CA93D0(ctx, base);
	// 82859D40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82859D44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82859D48: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82859D4C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82859D50: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82859D54: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82859D58: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82859D5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82859D60: 419A00F4  beq cr6, 0x82859e54
	if ctx.cr[6].eq {
	pc = 0x82859E54; continue 'dispatch;
	}
	// 82859D64: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82859D68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82859D6C: 419A0024  beq cr6, 0x82859d90
	if ctx.cr[6].eq {
	pc = 0x82859D90; continue 'dispatch;
	}
	// 82859D70: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 82859D74: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82859D78: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82859D7C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82859D80: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82859D84: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82859D88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82859D8C: 480000CC  b 0x82859e58
	pc = 0x82859E58; continue 'dispatch;
            }
            0x82859D90 => {
    //   block [0x82859D90..0x82859DAC)
	// 82859D90: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82859D94: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82859D98: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82859D9C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82859DA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82859DA4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82859DA8: 40810054  ble 0x82859dfc
	if !ctx.cr[0].gt {
	pc = 0x82859DFC; continue 'dispatch;
	}
	pc = 0x82859DAC; continue 'dispatch;
            }
            0x82859DAC => {
    //   block [0x82859DAC..0x82859DCC)
	// 82859DAC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82859DB0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82859DB4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82859DB8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82859DBC: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82859DC0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82859DC4: 41980008  blt cr6, 0x82859dcc
	if ctx.cr[6].lt {
	pc = 0x82859DCC; continue 'dispatch;
	}
	// 82859DC8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82859DCC; continue 'dispatch;
            }
            0x82859DCC => {
    //   block [0x82859DCC..0x82859DE8)
	// 82859DCC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82859DD0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82859DD4: 419A0014  beq cr6, 0x82859de8
	if ctx.cr[6].eq {
	pc = 0x82859DE8; continue 'dispatch;
	}
	// 82859DD8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82859DDC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82859DE0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82859DE4: 4800000C  b 0x82859df0
	pc = 0x82859DF0; continue 'dispatch;
            }
            0x82859DE8 => {
    //   block [0x82859DE8..0x82859DF0)
	// 82859DE8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82859DEC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82859DF0; continue 'dispatch;
            }
            0x82859DF0 => {
    //   block [0x82859DF0..0x82859DFC)
	// 82859DF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82859DF4: 4199FFB8  bgt cr6, 0x82859dac
	if ctx.cr[6].gt {
	pc = 0x82859DAC; continue 'dispatch;
	}
	// 82859DF8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82859DFC; continue 'dispatch;
            }
            0x82859DFC => {
    //   block [0x82859DFC..0x82859E18)
	// 82859DFC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82859E00: 419A0040  beq cr6, 0x82859e40
	if ctx.cr[6].eq {
	pc = 0x82859E40; continue 'dispatch;
	}
	// 82859E04: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82859E08: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82859E0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82859E10: 41990008  bgt cr6, 0x82859e18
	if ctx.cr[6].gt {
	pc = 0x82859E18; continue 'dispatch;
	}
	// 82859E14: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82859E18; continue 'dispatch;
            }
            0x82859E18 => {
    //   block [0x82859E18..0x82859E40)
	// 82859E18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82859E1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82859E20: 409A0020  bne cr6, 0x82859e40
	if !ctx.cr[6].eq {
	pc = 0x82859E40; continue 'dispatch;
	}
	// 82859E24: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82859E28: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82859E2C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82859E30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82859E34: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82859E38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82859E3C: 4800001C  b 0x82859e58
	pc = 0x82859E58; continue 'dispatch;
            }
            0x82859E40 => {
    //   block [0x82859E40..0x82859E54)
	// 82859E40: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82859E44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82859E48: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82859E4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82859E50: 48000008  b 0x82859e58
	pc = 0x82859E58; continue 'dispatch;
            }
            0x82859E54 => {
    //   block [0x82859E54..0x82859E58)
	// 82859E54: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82859E58; continue 'dispatch;
            }
            0x82859E58 => {
    //   block [0x82859E58..0x82859E8C)
	// 82859E58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82859E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82859E60: 419A01F8  beq cr6, 0x8285a058
	if ctx.cr[6].eq {
	pc = 0x8285A058; continue 'dispatch;
	}
	// 82859E64: 809E0080  lwz r4, 0x80(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 82859E68: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82859E6C: 419A005C  beq cr6, 0x82859ec8
	if ctx.cr[6].eq {
	pc = 0x82859EC8; continue 'dispatch;
	}
	// 82859E70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82859E74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82859E78: 4BA541A9  bl 0x822ae020
	ctx.lr = 0x82859E7C;
	sub_822AE020(ctx, base);
	// 82859E7C: 807E0080  lwz r3, 0x80(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 82859E80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82859E84: 419A0040  beq cr6, 0x82859ec4
	if ctx.cr[6].eq {
	pc = 0x82859EC4; continue 'dispatch;
	}
	// 82859E88: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82859E8C; continue 'dispatch;
            }
            0x82859E8C => {
    //   block [0x82859E8C..0x82859EC0)
	// 82859E8C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82859E90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82859E94: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82859E98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82859E9C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82859EA0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82859EA4: 4082FFE8  bne 0x82859e8c
	if !ctx.cr[0].eq {
	pc = 0x82859E8C; continue 'dispatch;
	}
	// 82859EA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82859EAC: 409A0014  bne cr6, 0x82859ec0
	if !ctx.cr[6].eq {
	pc = 0x82859EC0; continue 'dispatch;
	}
	// 82859EB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82859EB4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82859EB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82859EBC: 4E800421  bctrl
	ctx.lr = 0x82859EC0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82859EC0 => {
    //   block [0x82859EC0..0x82859EC4)
	// 82859EC0: 93BE0080  stw r29, 0x80(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	pc = 0x82859EC4; continue 'dispatch;
            }
            0x82859EC4 => {
    //   block [0x82859EC4..0x82859EC8)
	// 82859EC4: 93BE0080  stw r29, 0x80(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	pc = 0x82859EC8; continue 'dispatch;
            }
            0x82859EC8 => {
    //   block [0x82859EC8..0x82859EF0)
	// 82859EC8: 809E0084  lwz r4, 0x84(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 82859ECC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82859ED0: 419A005C  beq cr6, 0x82859f2c
	if ctx.cr[6].eq {
	pc = 0x82859F2C; continue 'dispatch;
	}
	// 82859ED4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82859ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82859EDC: 4BA54145  bl 0x822ae020
	ctx.lr = 0x82859EE0;
	sub_822AE020(ctx, base);
	// 82859EE0: 807E0084  lwz r3, 0x84(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 82859EE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82859EE8: 419A0040  beq cr6, 0x82859f28
	if ctx.cr[6].eq {
	pc = 0x82859F28; continue 'dispatch;
	}
	// 82859EEC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82859EF0; continue 'dispatch;
            }
            0x82859EF0 => {
    //   block [0x82859EF0..0x82859F24)
	// 82859EF0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82859EF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82859EF8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82859EFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82859F00: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82859F04: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82859F08: 4082FFE8  bne 0x82859ef0
	if !ctx.cr[0].eq {
	pc = 0x82859EF0; continue 'dispatch;
	}
	// 82859F0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82859F10: 409A0014  bne cr6, 0x82859f24
	if !ctx.cr[6].eq {
	pc = 0x82859F24; continue 'dispatch;
	}
	// 82859F14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82859F18: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82859F1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82859F20: 4E800421  bctrl
	ctx.lr = 0x82859F24;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82859F24 => {
    //   block [0x82859F24..0x82859F28)
	// 82859F24: 93BE0084  stw r29, 0x84(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	pc = 0x82859F28; continue 'dispatch;
            }
            0x82859F28 => {
    //   block [0x82859F28..0x82859F2C)
	// 82859F28: 93BE0084  stw r29, 0x84(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	pc = 0x82859F2C; continue 'dispatch;
            }
            0x82859F2C => {
    //   block [0x82859F2C..0x82859F54)
	// 82859F2C: 809E0088  lwz r4, 0x88(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 82859F30: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82859F34: 419A005C  beq cr6, 0x82859f90
	if ctx.cr[6].eq {
	pc = 0x82859F90; continue 'dispatch;
	}
	// 82859F38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82859F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82859F40: 4BA540E1  bl 0x822ae020
	ctx.lr = 0x82859F44;
	sub_822AE020(ctx, base);
	// 82859F44: 807E0088  lwz r3, 0x88(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 82859F48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82859F4C: 419A0040  beq cr6, 0x82859f8c
	if ctx.cr[6].eq {
	pc = 0x82859F8C; continue 'dispatch;
	}
	// 82859F50: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82859F54; continue 'dispatch;
            }
            0x82859F54 => {
    //   block [0x82859F54..0x82859F88)
	// 82859F54: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82859F58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82859F5C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82859F60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82859F64: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82859F68: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82859F6C: 4082FFE8  bne 0x82859f54
	if !ctx.cr[0].eq {
	pc = 0x82859F54; continue 'dispatch;
	}
	// 82859F70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82859F74: 409A0014  bne cr6, 0x82859f88
	if !ctx.cr[6].eq {
	pc = 0x82859F88; continue 'dispatch;
	}
	// 82859F78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82859F7C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82859F80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82859F84: 4E800421  bctrl
	ctx.lr = 0x82859F88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82859F88 => {
    //   block [0x82859F88..0x82859F8C)
	// 82859F88: 93BE0088  stw r29, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	pc = 0x82859F8C; continue 'dispatch;
            }
            0x82859F8C => {
    //   block [0x82859F8C..0x82859F90)
	// 82859F8C: 93BE0088  stw r29, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	pc = 0x82859F90; continue 'dispatch;
            }
            0x82859F90 => {
    //   block [0x82859F90..0x82859FB8)
	// 82859F90: 809E008C  lwz r4, 0x8c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 82859F94: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82859F98: 419A005C  beq cr6, 0x82859ff4
	if ctx.cr[6].eq {
	pc = 0x82859FF4; continue 'dispatch;
	}
	// 82859F9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82859FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82859FA4: 4BA5407D  bl 0x822ae020
	ctx.lr = 0x82859FA8;
	sub_822AE020(ctx, base);
	// 82859FA8: 807E008C  lwz r3, 0x8c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 82859FAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82859FB0: 419A0040  beq cr6, 0x82859ff0
	if ctx.cr[6].eq {
	pc = 0x82859FF0; continue 'dispatch;
	}
	// 82859FB4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82859FB8; continue 'dispatch;
            }
            0x82859FB8 => {
    //   block [0x82859FB8..0x82859FEC)
	// 82859FB8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82859FBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82859FC0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82859FC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82859FC8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82859FCC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82859FD0: 4082FFE8  bne 0x82859fb8
	if !ctx.cr[0].eq {
	pc = 0x82859FB8; continue 'dispatch;
	}
	// 82859FD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82859FD8: 409A0014  bne cr6, 0x82859fec
	if !ctx.cr[6].eq {
	pc = 0x82859FEC; continue 'dispatch;
	}
	// 82859FDC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82859FE0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82859FE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82859FE8: 4E800421  bctrl
	ctx.lr = 0x82859FEC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82859FEC => {
    //   block [0x82859FEC..0x82859FF0)
	// 82859FEC: 93BE008C  stw r29, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	pc = 0x82859FF0; continue 'dispatch;
            }
            0x82859FF0 => {
    //   block [0x82859FF0..0x82859FF4)
	// 82859FF0: 93BE008C  stw r29, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	pc = 0x82859FF4; continue 'dispatch;
            }
            0x82859FF4 => {
    //   block [0x82859FF4..0x8285A01C)
	// 82859FF4: 809E0090  lwz r4, 0x90(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 82859FF8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82859FFC: 419A005C  beq cr6, 0x8285a058
	if ctx.cr[6].eq {
	pc = 0x8285A058; continue 'dispatch;
	}
	// 8285A000: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8285A004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A008: 4BA54019  bl 0x822ae020
	ctx.lr = 0x8285A00C;
	sub_822AE020(ctx, base);
	// 8285A00C: 807E0090  lwz r3, 0x90(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 8285A010: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A014: 419A0040  beq cr6, 0x8285a054
	if ctx.cr[6].eq {
	pc = 0x8285A054; continue 'dispatch;
	}
	// 8285A018: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8285A01C; continue 'dispatch;
            }
            0x8285A01C => {
    //   block [0x8285A01C..0x8285A050)
	// 8285A01C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8285A020: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285A024: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8285A028: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285A02C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285A030: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285A034: 4082FFE8  bne 0x8285a01c
	if !ctx.cr[0].eq {
	pc = 0x8285A01C; continue 'dispatch;
	}
	// 8285A038: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285A03C: 409A0014  bne cr6, 0x8285a050
	if !ctx.cr[6].eq {
	pc = 0x8285A050; continue 'dispatch;
	}
	// 8285A040: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A044: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A048: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A04C: 4E800421  bctrl
	ctx.lr = 0x8285A050;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285A050 => {
    //   block [0x8285A050..0x8285A054)
	// 8285A050: 93BE0090  stw r29, 0x90(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	pc = 0x8285A054; continue 'dispatch;
            }
            0x8285A054 => {
    //   block [0x8285A054..0x8285A058)
	// 8285A054: 93BE0090  stw r29, 0x90(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	pc = 0x8285A058; continue 'dispatch;
            }
            0x8285A058 => {
    //   block [0x8285A058..0x8285A09C)
	// 8285A058: 387E00F4  addi r3, r30, 0xf4
	ctx.r[3].s64 = ctx.r[30].s64 + 244;
	// 8285A05C: 4B95DABD  bl 0x821b7b18
	ctx.lr = 0x8285A060;
	sub_821B7B18(ctx, base);
	// 8285A060: 93BE00F4  stw r29, 0xf4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(244 as u32), ctx.r[29].u32 ) };
	// 8285A064: 387E0100  addi r3, r30, 0x100
	ctx.r[3].s64 = ctx.r[30].s64 + 256;
	// 8285A068: 4B95DAB1  bl 0x821b7b18
	ctx.lr = 0x8285A06C;
	sub_821B7B18(ctx, base);
	// 8285A06C: 93BE0100  stw r29, 0x100(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), ctx.r[29].u32 ) };
	// 8285A070: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8285A074: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 8285A078: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A07C: 419A0020  beq cr6, 0x8285a09c
	if ctx.cr[6].eq {
	pc = 0x8285A09C; continue 'dispatch;
	}
	// 8285A080: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A084: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A088: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A08C: 4E800421  bctrl
	ctx.lr = 0x8285A090;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A090: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A094: 4B95DA85  bl 0x821b7b18
	ctx.lr = 0x8285A098;
	sub_821B7B18(ctx, base);
	// 8285A098: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A09C => {
    //   block [0x8285A09C..0x8285A0C8)
	// 8285A09C: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8285A0A0: 3BFE0018  addi r31, r30, 0x18
	ctx.r[31].s64 = ctx.r[30].s64 + 24;
	// 8285A0A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A0A8: 419A0020  beq cr6, 0x8285a0c8
	if ctx.cr[6].eq {
	pc = 0x8285A0C8; continue 'dispatch;
	}
	// 8285A0AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A0B0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A0B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A0B8: 4E800421  bctrl
	ctx.lr = 0x8285A0BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A0BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A0C0: 4B95DA59  bl 0x821b7b18
	ctx.lr = 0x8285A0C4;
	sub_821B7B18(ctx, base);
	// 8285A0C4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A0C8 => {
    //   block [0x8285A0C8..0x8285A0F4)
	// 8285A0C8: 807E0020  lwz r3, 0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 8285A0CC: 3BFE0020  addi r31, r30, 0x20
	ctx.r[31].s64 = ctx.r[30].s64 + 32;
	// 8285A0D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A0D4: 419A0020  beq cr6, 0x8285a0f4
	if ctx.cr[6].eq {
	pc = 0x8285A0F4; continue 'dispatch;
	}
	// 8285A0D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A0DC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A0E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A0E4: 4E800421  bctrl
	ctx.lr = 0x8285A0E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A0E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A0EC: 4B95DA2D  bl 0x821b7b18
	ctx.lr = 0x8285A0F0;
	sub_821B7B18(ctx, base);
	// 8285A0F0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A0F4 => {
    //   block [0x8285A0F4..0x8285A120)
	// 8285A0F4: 807E0028  lwz r3, 0x28(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285A0F8: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 8285A0FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A100: 419A0020  beq cr6, 0x8285a120
	if ctx.cr[6].eq {
	pc = 0x8285A120; continue 'dispatch;
	}
	// 8285A104: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A108: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A10C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A110: 4E800421  bctrl
	ctx.lr = 0x8285A114;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A118: 4B95DA01  bl 0x821b7b18
	ctx.lr = 0x8285A11C;
	sub_821B7B18(ctx, base);
	// 8285A11C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A120 => {
    //   block [0x8285A120..0x8285A14C)
	// 8285A120: 807E0030  lwz r3, 0x30(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8285A124: 3BFE0030  addi r31, r30, 0x30
	ctx.r[31].s64 = ctx.r[30].s64 + 48;
	// 8285A128: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A12C: 419A0020  beq cr6, 0x8285a14c
	if ctx.cr[6].eq {
	pc = 0x8285A14C; continue 'dispatch;
	}
	// 8285A130: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A134: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A138: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A13C: 4E800421  bctrl
	ctx.lr = 0x8285A140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A144: 4B95D9D5  bl 0x821b7b18
	ctx.lr = 0x8285A148;
	sub_821B7B18(ctx, base);
	// 8285A148: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A14C => {
    //   block [0x8285A14C..0x8285A178)
	// 8285A14C: 807E0038  lwz r3, 0x38(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 8285A150: 3BFE0038  addi r31, r30, 0x38
	ctx.r[31].s64 = ctx.r[30].s64 + 56;
	// 8285A154: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A158: 419A0020  beq cr6, 0x8285a178
	if ctx.cr[6].eq {
	pc = 0x8285A178; continue 'dispatch;
	}
	// 8285A15C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A160: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A164: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A168: 4E800421  bctrl
	ctx.lr = 0x8285A16C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A16C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A170: 4B95D9A9  bl 0x821b7b18
	ctx.lr = 0x8285A174;
	sub_821B7B18(ctx, base);
	// 8285A174: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A178 => {
    //   block [0x8285A178..0x8285A1A4)
	// 8285A178: 807E010C  lwz r3, 0x10c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(268 as u32) ) } as u64;
	// 8285A17C: 3BFE010C  addi r31, r30, 0x10c
	ctx.r[31].s64 = ctx.r[30].s64 + 268;
	// 8285A180: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A184: 419A0020  beq cr6, 0x8285a1a4
	if ctx.cr[6].eq {
	pc = 0x8285A1A4; continue 'dispatch;
	}
	// 8285A188: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A18C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A190: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A194: 4E800421  bctrl
	ctx.lr = 0x8285A198;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A19C: 4B95D97D  bl 0x821b7b18
	ctx.lr = 0x8285A1A0;
	sub_821B7B18(ctx, base);
	// 8285A1A0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A1A4 => {
    //   block [0x8285A1A4..0x8285A1D0)
	// 8285A1A4: 807E0040  lwz r3, 0x40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 8285A1A8: 3BFE0040  addi r31, r30, 0x40
	ctx.r[31].s64 = ctx.r[30].s64 + 64;
	// 8285A1AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A1B0: 419A0020  beq cr6, 0x8285a1d0
	if ctx.cr[6].eq {
	pc = 0x8285A1D0; continue 'dispatch;
	}
	// 8285A1B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A1B8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A1BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A1C0: 4E800421  bctrl
	ctx.lr = 0x8285A1C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A1C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A1C8: 4B95D951  bl 0x821b7b18
	ctx.lr = 0x8285A1CC;
	sub_821B7B18(ctx, base);
	// 8285A1CC: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A1D0 => {
    //   block [0x8285A1D0..0x8285A1FC)
	// 8285A1D0: 807E0048  lwz r3, 0x48(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285A1D4: 3BFE0048  addi r31, r30, 0x48
	ctx.r[31].s64 = ctx.r[30].s64 + 72;
	// 8285A1D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A1DC: 419A0020  beq cr6, 0x8285a1fc
	if ctx.cr[6].eq {
	pc = 0x8285A1FC; continue 'dispatch;
	}
	// 8285A1E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A1E4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A1E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A1EC: 4E800421  bctrl
	ctx.lr = 0x8285A1F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A1F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A1F4: 4B95D925  bl 0x821b7b18
	ctx.lr = 0x8285A1F8;
	sub_821B7B18(ctx, base);
	// 8285A1F8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A1FC => {
    //   block [0x8285A1FC..0x8285A228)
	// 8285A1FC: 807E0050  lwz r3, 0x50(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285A200: 3BFE0050  addi r31, r30, 0x50
	ctx.r[31].s64 = ctx.r[30].s64 + 80;
	// 8285A204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A208: 419A0020  beq cr6, 0x8285a228
	if ctx.cr[6].eq {
	pc = 0x8285A228; continue 'dispatch;
	}
	// 8285A20C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A210: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A214: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A218: 4E800421  bctrl
	ctx.lr = 0x8285A21C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A21C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A220: 4B95D8F9  bl 0x821b7b18
	ctx.lr = 0x8285A224;
	sub_821B7B18(ctx, base);
	// 8285A224: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A228 => {
    //   block [0x8285A228..0x8285A254)
	// 8285A228: 807E0058  lwz r3, 0x58(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285A22C: 3BFE0058  addi r31, r30, 0x58
	ctx.r[31].s64 = ctx.r[30].s64 + 88;
	// 8285A230: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A234: 419A0020  beq cr6, 0x8285a254
	if ctx.cr[6].eq {
	pc = 0x8285A254; continue 'dispatch;
	}
	// 8285A238: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A23C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A240: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A244: 4E800421  bctrl
	ctx.lr = 0x8285A248;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A24C: 4B95D8CD  bl 0x821b7b18
	ctx.lr = 0x8285A250;
	sub_821B7B18(ctx, base);
	// 8285A250: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A254 => {
    //   block [0x8285A254..0x8285A280)
	// 8285A254: 807E0060  lwz r3, 0x60(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 8285A258: 3BFE0060  addi r31, r30, 0x60
	ctx.r[31].s64 = ctx.r[30].s64 + 96;
	// 8285A25C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A260: 419A0020  beq cr6, 0x8285a280
	if ctx.cr[6].eq {
	pc = 0x8285A280; continue 'dispatch;
	}
	// 8285A264: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A268: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A26C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A270: 4E800421  bctrl
	ctx.lr = 0x8285A274;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A274: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A278: 4B95D8A1  bl 0x821b7b18
	ctx.lr = 0x8285A27C;
	sub_821B7B18(ctx, base);
	// 8285A27C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A280 => {
    //   block [0x8285A280..0x8285A2AC)
	// 8285A280: 807E0070  lwz r3, 0x70(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 8285A284: 3BFE0070  addi r31, r30, 0x70
	ctx.r[31].s64 = ctx.r[30].s64 + 112;
	// 8285A288: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A28C: 419A0020  beq cr6, 0x8285a2ac
	if ctx.cr[6].eq {
	pc = 0x8285A2AC; continue 'dispatch;
	}
	// 8285A290: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A294: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A298: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A29C: 4E800421  bctrl
	ctx.lr = 0x8285A2A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A2A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A2A4: 4B95D875  bl 0x821b7b18
	ctx.lr = 0x8285A2A8;
	sub_821B7B18(ctx, base);
	// 8285A2A8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A2AC => {
    //   block [0x8285A2AC..0x8285A2D8)
	// 8285A2AC: 807E0078  lwz r3, 0x78(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) } as u64;
	// 8285A2B0: 3BFE0078  addi r31, r30, 0x78
	ctx.r[31].s64 = ctx.r[30].s64 + 120;
	// 8285A2B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A2B8: 419A0020  beq cr6, 0x8285a2d8
	if ctx.cr[6].eq {
	pc = 0x8285A2D8; continue 'dispatch;
	}
	// 8285A2BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A2C0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A2C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A2C8: 4E800421  bctrl
	ctx.lr = 0x8285A2CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A2CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A2D0: 4B95D849  bl 0x821b7b18
	ctx.lr = 0x8285A2D4;
	sub_821B7B18(ctx, base);
	// 8285A2D4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A2D8 => {
    //   block [0x8285A2D8..0x8285A304)
	// 8285A2D8: 807E0068  lwz r3, 0x68(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 8285A2DC: 3BFE0068  addi r31, r30, 0x68
	ctx.r[31].s64 = ctx.r[30].s64 + 104;
	// 8285A2E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A2E4: 419A0020  beq cr6, 0x8285a304
	if ctx.cr[6].eq {
	pc = 0x8285A304; continue 'dispatch;
	}
	// 8285A2E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A2EC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285A2F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A2F4: 4E800421  bctrl
	ctx.lr = 0x8285A2F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A2F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A2FC: 4B95D81D  bl 0x821b7b18
	ctx.lr = 0x8285A300;
	sub_821B7B18(ctx, base);
	// 8285A300: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8285A304 => {
    //   block [0x8285A304..0x8285A30C)
	// 8285A304: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8285A308: 4844F154  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285A310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8285A310 size=8
    let mut pc: u32 = 0x8285A310;
    'dispatch: loop {
        match pc {
            0x8285A310 => {
    //   block [0x8285A310..0x8285A318)
	// 8285A310: 38600039  li r3, 0x39
	ctx.r[3].s64 = 57;
	// 8285A314: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285A318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8285A318 size=4
    let mut pc: u32 = 0x8285A318;
    'dispatch: loop {
        match pc {
            0x8285A318 => {
    //   block [0x8285A318..0x8285A31C)
	// 8285A318: 4BFFB300  b 0x82855618
	sub_82855618(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285A320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285A320 size=108
    let mut pc: u32 = 0x8285A320;
    'dispatch: loop {
        match pc {
            0x8285A320 => {
    //   block [0x8285A320..0x8285A370)
	// 8285A320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285A324: 4844F0E5  bl 0x82ca9408
	ctx.lr = 0x8285A328;
	sub_82CA93D0(ctx, base);
	// 8285A328: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285A32C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8285A330: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285A334: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285A338: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8285A33C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8285A340: 388BF28C  addi r4, r11, -0xd74
	ctx.r[4].s64 = ctx.r[11].s64 + -3444;
	// 8285A344: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8285A348: 4BA4F6A1  bl 0x822a99e8
	ctx.lr = 0x8285A34C;
	sub_822A99E8(ctx, base);
	// 8285A34C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8285A350: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8285A354: 419A001C  beq cr6, 0x8285a370
	if ctx.cr[6].eq {
	pc = 0x8285A370; continue 'dispatch;
	}
	// 8285A358: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8285A35C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8285A360: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A364: 4B987B05  bl 0x821e1e68
	ctx.lr = 0x8285A368;
	sub_821E1E68(ctx, base);
	// 8285A368: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285A36C: 409A0018  bne cr6, 0x8285a384
	if !ctx.cr[6].eq {
	pc = 0x8285A384; continue 'dispatch;
	}
	pc = 0x8285A370; continue 'dispatch;
            }
            0x8285A370 => {
    //   block [0x8285A370..0x8285A384)
	// 8285A370: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8285A374: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8285A378: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8285A37C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A380: 4B987AE9  bl 0x821e1e68
	ctx.lr = 0x8285A384;
	sub_821E1E68(ctx, base);
	pc = 0x8285A384; continue 'dispatch;
            }
            0x8285A384 => {
    //   block [0x8285A384..0x8285A38C)
	// 8285A384: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8285A388: 4844F0D0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285A390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8285A390 size=8
    let mut pc: u32 = 0x8285A390;
    'dispatch: loop {
        match pc {
            0x8285A390 => {
    //   block [0x8285A390..0x8285A398)
	// 8285A390: 38600032  li r3, 0x32
	ctx.r[3].s64 = 50;
	// 8285A394: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285A398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285A398 size=80
    let mut pc: u32 = 0x8285A398;
    'dispatch: loop {
        match pc {
            0x8285A398 => {
    //   block [0x8285A398..0x8285A3D0)
	// 8285A398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285A39C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285A3A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285A3A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285A3A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285A3AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285A3B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8285A3B4: 4BBC2455  bl 0x8241c808
	ctx.lr = 0x8285A3B8;
	sub_8241C808(ctx, base);
	// 8285A3B8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8285A3BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A3C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285A3C4: 419A000C  beq cr6, 0x8285a3d0
	if ctx.cr[6].eq {
	pc = 0x8285A3D0; continue 'dispatch;
	}
	// 8285A3C8: 4B9C1971  bl 0x8221bd38
	ctx.lr = 0x8285A3CC;
	sub_8221BD38(ctx, base);
	// 8285A3CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8285A3D0; continue 'dispatch;
            }
            0x8285A3D0 => {
    //   block [0x8285A3D0..0x8285A3E8)
	// 8285A3D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285A3D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285A3D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285A3DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285A3E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285A3E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285A3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285A3E8 size=276
    let mut pc: u32 = 0x8285A3E8;
    'dispatch: loop {
        match pc {
            0x8285A3E8 => {
    //   block [0x8285A3E8..0x8285A414)
	// 8285A3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285A3EC: 4844F019  bl 0x82ca9404
	ctx.lr = 0x8285A3F0;
	sub_82CA93D0(ctx, base);
	// 8285A3F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285A3F4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8285A3F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8285A3FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8285A400: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8285A404: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 8285A408: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 8285A40C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8285A410: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	pc = 0x8285A414; continue 'dispatch;
            }
            0x8285A414 => {
    //   block [0x8285A414..0x8285A45C)
	// 8285A414: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285A418: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285A41C: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285A420: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285A424: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285A428: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285A42C: 4082FFE8  bne 0x8285a414
	if !ctx.cr[0].eq {
	pc = 0x8285A414; continue 'dispatch;
	}
	// 8285A430: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 8285A434: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8285A438: 419A003C  beq cr6, 0x8285a474
	if ctx.cr[6].eq {
	pc = 0x8285A474; continue 'dispatch;
	}
	// 8285A43C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8285A440: 419A0028  beq cr6, 0x8285a468
	if ctx.cr[6].eq {
	pc = 0x8285A468; continue 'dispatch;
	}
	// 8285A444: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8285A448: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285A44C: 419A0010  beq cr6, 0x8285a45c
	if ctx.cr[6].eq {
	pc = 0x8285A45C; continue 'dispatch;
	}
	// 8285A450: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8285A454: 388BCDC4  addi r4, r11, -0x323c
	ctx.r[4].s64 = ctx.r[11].s64 + -12860;
	// 8285A458: 48000028  b 0x8285a480
	pc = 0x8285A480; continue 'dispatch;
            }
            0x8285A45C => {
    //   block [0x8285A45C..0x8285A468)
	// 8285A45C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285A460: 388BF2FC  addi r4, r11, -0xd04
	ctx.r[4].s64 = ctx.r[11].s64 + -3332;
	// 8285A464: 4800001C  b 0x8285a480
	pc = 0x8285A480; continue 'dispatch;
            }
            0x8285A468 => {
    //   block [0x8285A468..0x8285A474)
	// 8285A468: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8285A46C: 388BCC68  addi r4, r11, -0x3398
	ctx.r[4].s64 = ctx.r[11].s64 + -13208;
	// 8285A470: 4800000C  b 0x8285a47c
	pc = 0x8285A47C; continue 'dispatch;
            }
            0x8285A474 => {
    //   block [0x8285A474..0x8285A47C)
	// 8285A474: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8285A478: 388B28D4  addi r4, r11, 0x28d4
	ctx.r[4].s64 = ctx.r[11].s64 + 10452;
	pc = 0x8285A47C; continue 'dispatch;
            }
            0x8285A47C => {
    //   block [0x8285A47C..0x8285A480)
	// 8285A47C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	pc = 0x8285A480; continue 'dispatch;
            }
            0x8285A480 => {
    //   block [0x8285A480..0x8285A49C)
	// 8285A480: 4BA1AFB9  bl 0x82275438
	ctx.lr = 0x8285A484;
	sub_82275438(ctx, base);
	// 8285A484: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285A488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285A48C: 409A0010  bne cr6, 0x8285a49c
	if !ctx.cr[6].eq {
	pc = 0x8285A49C; continue 'dispatch;
	}
	// 8285A490: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8285A494: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8285A498: 48000008  b 0x8285a4a0
	pc = 0x8285A4A0; continue 'dispatch;
            }
            0x8285A49C => {
    //   block [0x8285A49C..0x8285A4A0)
	// 8285A49C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8285A4A0; continue 'dispatch;
            }
            0x8285A4A0 => {
    //   block [0x8285A4A0..0x8285A4D0)
	// 8285A4A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8285A4A4: 4BA4F545  bl 0x822a99e8
	ctx.lr = 0x8285A4A8;
	sub_822A99E8(ctx, base);
	// 8285A4A8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8285A4AC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8285A4B0: 419A0020  beq cr6, 0x8285a4d0
	if ctx.cr[6].eq {
	pc = 0x8285A4D0; continue 'dispatch;
	}
	// 8285A4B4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8285A4B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8285A4BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285A4C0: 4B9879A9  bl 0x821e1e68
	ctx.lr = 0x8285A4C4;
	sub_821E1E68(ctx, base);
	// 8285A4C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285A4C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8285A4CC: 409A001C  bne cr6, 0x8285a4e8
	if !ctx.cr[6].eq {
	pc = 0x8285A4E8; continue 'dispatch;
	}
	pc = 0x8285A4D0; continue 'dispatch;
            }
            0x8285A4D0 => {
    //   block [0x8285A4D0..0x8285A4E8)
	// 8285A4D0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8285A4D4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 8285A4D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8285A4DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285A4E0: 4B987989  bl 0x821e1e68
	ctx.lr = 0x8285A4E4;
	sub_821E1E68(ctx, base);
	// 8285A4E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x8285A4E8; continue 'dispatch;
            }
            0x8285A4E8 => {
    //   block [0x8285A4E8..0x8285A4FC)
	// 8285A4E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285A4EC: 4B9BA8ED  bl 0x82214dd8
	ctx.lr = 0x8285A4F0;
	sub_82214DD8(ctx, base);
	// 8285A4F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A4F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8285A4F8: 4844EF5C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285A500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285A500 size=420
    let mut pc: u32 = 0x8285A500;
    'dispatch: loop {
        match pc {
            0x8285A500 => {
    //   block [0x8285A500..0x8285A590)
	// 8285A500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285A504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285A508: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285A50C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285A510: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285A514: 4BA45C85  bl 0x822a0198
	ctx.lr = 0x8285A518;
	sub_822A0198(ctx, base);
	// 8285A518: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A51C: 4B9AD2D5  bl 0x822077f0
	ctx.lr = 0x8285A520;
	sub_822077F0(ctx, base);
	// 8285A520: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8285A524: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285A528: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 8285A52C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A530: FC010024  fdiv f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 8285A534: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8285A538: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285A53C: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8285A540: EC2D602A  fadds f1, f13, f12
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 8285A544: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8285A548: 4E800421  bctrl
	ctx.lr = 0x8285A54C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A54C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A550: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8285A554: 810B0028  lwz r8, 0x28(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285A558: 550707FE  clrlwi r7, r8, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 8285A55C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285A560: 419A00F8  beq cr6, 0x8285a658
	if ctx.cr[6].eq {
	pc = 0x8285A658; continue 'dispatch;
	}
	// 8285A564: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285A568: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285A56C: 419A0024  beq cr6, 0x8285a590
	if ctx.cr[6].eq {
	pc = 0x8285A590; continue 'dispatch;
	}
	// 8285A570: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 8285A574: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285A578: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285A57C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285A580: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A584: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8285A588: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285A58C: 480000D0  b 0x8285a65c
	pc = 0x8285A65C; continue 'dispatch;
            }
            0x8285A590 => {
    //   block [0x8285A590..0x8285A5B0)
	// 8285A590: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285A594: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8285A598: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285A59C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8285A5A0: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285A5A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285A5A8: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285A5AC: 40810054  ble 0x8285a600
	if !ctx.cr[0].gt {
	pc = 0x8285A600; continue 'dispatch;
	}
	pc = 0x8285A5B0; continue 'dispatch;
            }
            0x8285A5B0 => {
    //   block [0x8285A5B0..0x8285A5D0)
	// 8285A5B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285A5B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285A5B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285A5BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A5C0: 2F070020  cmpwi cr6, r7, 0x20
	ctx.cr[6].compare_i32(ctx.r[7].s32, 32, &mut ctx.xer);
	// 8285A5C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285A5C8: 41980008  blt cr6, 0x8285a5d0
	if ctx.cr[6].lt {
	pc = 0x8285A5D0; continue 'dispatch;
	}
	// 8285A5CC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8285A5D0; continue 'dispatch;
            }
            0x8285A5D0 => {
    //   block [0x8285A5D0..0x8285A5EC)
	// 8285A5D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285A5D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285A5D8: 419A0014  beq cr6, 0x8285a5ec
	if ctx.cr[6].eq {
	pc = 0x8285A5EC; continue 'dispatch;
	}
	// 8285A5DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285A5E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285A5E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285A5E8: 4800000C  b 0x8285a5f4
	pc = 0x8285A5F4; continue 'dispatch;
            }
            0x8285A5EC => {
    //   block [0x8285A5EC..0x8285A5F4)
	// 8285A5EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285A5F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285A5F4; continue 'dispatch;
            }
            0x8285A5F4 => {
    //   block [0x8285A5F4..0x8285A600)
	// 8285A5F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285A5F8: 4199FFB8  bgt cr6, 0x8285a5b0
	if ctx.cr[6].gt {
	pc = 0x8285A5B0; continue 'dispatch;
	}
	// 8285A5FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285A600; continue 'dispatch;
            }
            0x8285A600 => {
    //   block [0x8285A600..0x8285A61C)
	// 8285A600: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285A604: 419A0040  beq cr6, 0x8285a644
	if ctx.cr[6].eq {
	pc = 0x8285A644; continue 'dispatch;
	}
	// 8285A608: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A60C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 8285A610: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285A614: 41990008  bgt cr6, 0x8285a61c
	if ctx.cr[6].gt {
	pc = 0x8285A61C; continue 'dispatch;
	}
	// 8285A618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285A61C; continue 'dispatch;
            }
            0x8285A61C => {
    //   block [0x8285A61C..0x8285A644)
	// 8285A61C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285A620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285A624: 409A0020  bne cr6, 0x8285a644
	if !ctx.cr[6].eq {
	pc = 0x8285A644; continue 'dispatch;
	}
	// 8285A628: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285A62C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285A630: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285A634: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A638: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8285A63C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285A640: 4800001C  b 0x8285a65c
	pc = 0x8285A65C; continue 'dispatch;
            }
            0x8285A644 => {
    //   block [0x8285A644..0x8285A658)
	// 8285A644: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285A648: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A64C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8285A650: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285A654: 48000008  b 0x8285a65c
	pc = 0x8285A65C; continue 'dispatch;
            }
            0x8285A658 => {
    //   block [0x8285A658..0x8285A65C)
	// 8285A658: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285A65C; continue 'dispatch;
            }
            0x8285A65C => {
    //   block [0x8285A65C..0x8285A690)
	// 8285A65C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285A660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285A664: 419A002C  beq cr6, 0x8285a690
	if ctx.cr[6].eq {
	pc = 0x8285A690; continue 'dispatch;
	}
	// 8285A668: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8285A66C: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 8285A670: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8285A674: 419A001C  beq cr6, 0x8285a690
	if ctx.cr[6].eq {
	pc = 0x8285A690; continue 'dispatch;
	}
	// 8285A678: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A67C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A680: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 8285A684: 812A0044  lwz r9, 0x44(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 8285A688: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8285A68C: 4E800421  bctrl
	ctx.lr = 0x8285A690;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285A690 => {
    //   block [0x8285A690..0x8285A6A4)
	// 8285A690: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285A694: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285A698: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285A69C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285A6A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285A6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8285A6A8 size=8
    let mut pc: u32 = 0x8285A6A8;
    'dispatch: loop {
        match pc {
            0x8285A6A8 => {
    //   block [0x8285A6A8..0x8285A6B0)
	// 8285A6A8: 3860000F  li r3, 0xf
	ctx.r[3].s64 = 15;
	// 8285A6AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285A6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8285A6B0 size=8
    let mut pc: u32 = 0x8285A6B0;
    'dispatch: loop {
        match pc {
            0x8285A6B0 => {
    //   block [0x8285A6B0..0x8285A6B8)
	// 8285A6B0: 3860000E  li r3, 0xe
	ctx.r[3].s64 = 14;
	// 8285A6B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285A6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8285A6B8 size=8
    let mut pc: u32 = 0x8285A6B8;
    'dispatch: loop {
        match pc {
            0x8285A6B8 => {
    //   block [0x8285A6B8..0x8285A6C0)
	// 8285A6B8: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 8285A6BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285A6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8285A6C0 size=8
    let mut pc: u32 = 0x8285A6C0;
    'dispatch: loop {
        match pc {
            0x8285A6C0 => {
    //   block [0x8285A6C0..0x8285A6C8)
	// 8285A6C0: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 8285A6C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285A6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285A6C8 size=388
    let mut pc: u32 = 0x8285A6C8;
    'dispatch: loop {
        match pc {
            0x8285A6C8 => {
    //   block [0x8285A6C8..0x8285A71C)
	// 8285A6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285A6CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285A6D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285A6D4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8285A6D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285A6DC: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285A6E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8285A6E4: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8285A6E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285A6EC: 419A00F4  beq cr6, 0x8285a7e0
	if ctx.cr[6].eq {
	pc = 0x8285A7E0; continue 'dispatch;
	}
	// 8285A6F0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285A6F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285A6F8: 419A0024  beq cr6, 0x8285a71c
	if ctx.cr[6].eq {
	pc = 0x8285A71C; continue 'dispatch;
	}
	// 8285A6FC: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 8285A700: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285A704: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285A708: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285A70C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A710: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285A714: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285A718: 480000CC  b 0x8285a7e4
	pc = 0x8285A7E4; continue 'dispatch;
            }
            0x8285A71C => {
    //   block [0x8285A71C..0x8285A738)
	// 8285A71C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285A720: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285A724: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8285A728: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285A72C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285A730: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285A734: 40810054  ble 0x8285a788
	if !ctx.cr[0].gt {
	pc = 0x8285A788; continue 'dispatch;
	}
	pc = 0x8285A738; continue 'dispatch;
            }
            0x8285A738 => {
    //   block [0x8285A738..0x8285A758)
	// 8285A738: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285A73C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285A740: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285A744: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A748: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 8285A74C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285A750: 41980008  blt cr6, 0x8285a758
	if ctx.cr[6].lt {
	pc = 0x8285A758; continue 'dispatch;
	}
	// 8285A754: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x8285A758; continue 'dispatch;
            }
            0x8285A758 => {
    //   block [0x8285A758..0x8285A774)
	// 8285A758: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285A75C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285A760: 419A0014  beq cr6, 0x8285a774
	if ctx.cr[6].eq {
	pc = 0x8285A774; continue 'dispatch;
	}
	// 8285A764: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285A768: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285A76C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285A770: 4800000C  b 0x8285a77c
	pc = 0x8285A77C; continue 'dispatch;
            }
            0x8285A774 => {
    //   block [0x8285A774..0x8285A77C)
	// 8285A774: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285A778: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285A77C; continue 'dispatch;
            }
            0x8285A77C => {
    //   block [0x8285A77C..0x8285A788)
	// 8285A77C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285A780: 4199FFB8  bgt cr6, 0x8285a738
	if ctx.cr[6].gt {
	pc = 0x8285A738; continue 'dispatch;
	}
	// 8285A784: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285A788; continue 'dispatch;
            }
            0x8285A788 => {
    //   block [0x8285A788..0x8285A7A4)
	// 8285A788: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285A78C: 419A0040  beq cr6, 0x8285a7cc
	if ctx.cr[6].eq {
	pc = 0x8285A7CC; continue 'dispatch;
	}
	// 8285A790: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A794: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 8285A798: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285A79C: 41990008  bgt cr6, 0x8285a7a4
	if ctx.cr[6].gt {
	pc = 0x8285A7A4; continue 'dispatch;
	}
	// 8285A7A0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8285A7A4; continue 'dispatch;
            }
            0x8285A7A4 => {
    //   block [0x8285A7A4..0x8285A7CC)
	// 8285A7A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285A7A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285A7AC: 409A0020  bne cr6, 0x8285a7cc
	if !ctx.cr[6].eq {
	pc = 0x8285A7CC; continue 'dispatch;
	}
	// 8285A7B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285A7B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285A7B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285A7BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A7C0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285A7C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285A7C8: 4800001C  b 0x8285a7e4
	pc = 0x8285A7E4; continue 'dispatch;
            }
            0x8285A7CC => {
    //   block [0x8285A7CC..0x8285A7E0)
	// 8285A7CC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285A7D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A7D4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285A7D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285A7DC: 48000008  b 0x8285a7e4
	pc = 0x8285A7E4; continue 'dispatch;
            }
            0x8285A7E0 => {
    //   block [0x8285A7E0..0x8285A7E4)
	// 8285A7E0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8285A7E4; continue 'dispatch;
            }
            0x8285A7E4 => {
    //   block [0x8285A7E4..0x8285A82C)
	// 8285A7E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285A7E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285A7EC: 419A0040  beq cr6, 0x8285a82c
	if ctx.cr[6].eq {
	pc = 0x8285A82C; continue 'dispatch;
	}
	// 8285A7F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8285A7F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285A7F8: 388BEF40  addi r4, r11, -0x10c0
	ctx.r[4].s64 = ctx.r[11].s64 + -4288;
	// 8285A7FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285A800: 4B9D26D1  bl 0x8222ced0
	ctx.lr = 0x8285A804;
	sub_8222CED0(ctx, base);
	// 8285A804: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8285A808: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8285A80C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285A810: C02A92D4  lfs f1, -0x6d2c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285A814: 4BB88C2D  bl 0x823e3440
	ctx.lr = 0x8285A818;
	sub_823E3440(ctx, base);
	// 8285A818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285A81C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8285A820: 4B9BA5B9  bl 0x82214dd8
	ctx.lr = 0x8285A824;
	sub_82214DD8(ctx, base);
	// 8285A824: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285A828: 4800000C  b 0x8285a834
	pc = 0x8285A834; continue 'dispatch;
            }
            0x8285A82C => {
    //   block [0x8285A82C..0x8285A834)
	// 8285A82C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8285A830: C02B92D4  lfs f1, -0x6d2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x8285A834; continue 'dispatch;
            }
            0x8285A834 => {
    //   block [0x8285A834..0x8285A84C)
	// 8285A834: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285A838: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285A83C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285A840: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285A844: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285A848: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285A850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285A850 size=2240
    let mut pc: u32 = 0x8285A850;
    'dispatch: loop {
        match pc {
            0x8285A850 => {
    //   block [0x8285A850..0x8285A8A8)
	// 8285A850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285A854: 4844EBA5  bl 0x82ca93f8
	ctx.lr = 0x8285A858;
	sub_82CA93D0(ctx, base);
	// 8285A858: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 8285A85C: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8285A860: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285A864: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8285A868: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A86C: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 8285A870: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285A874: 4E800421  bctrl
	ctx.lr = 0x8285A878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A878: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A87C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8285A880: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8285A884: 8109006C  lwz r8, 0x6c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(108 as u32) ) } as u64;
	// 8285A888: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8285A88C: 4E800421  bctrl
	ctx.lr = 0x8285A890;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285A890: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A894: 83230000  lwz r25, 0(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285A89C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8285A8A0: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 8285A8A4: 419A0020  beq cr6, 0x8285a8c4
	if ctx.cr[6].eq {
	pc = 0x8285A8C4; continue 'dispatch;
	}
            }
            0x8285A8A8 => {
    //   block [0x8285A8A8..0x8285A8C4)
	// 8285A8A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285A8AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285A8B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285A8B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285A8B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285A8BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285A8C0: 4082FFE8  bne 0x8285a8a8
	if !ctx.cr[0].eq {
	pc = 0x8285A8A8; continue 'dispatch;
	}
	pc = 0x8285A8C4; continue 'dispatch;
            }
            0x8285A8C4 => {
    //   block [0x8285A8C4..0x8285A91C)
	// 8285A8C4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8285A8C8: 4B95D251  bl 0x821b7b18
	ctx.lr = 0x8285A8CC;
	sub_821B7B18(ctx, base);
	// 8285A8CC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8285A8D0: 419A0828  beq cr6, 0x8285b0f8
	if ctx.cr[6].eq {
	pc = 0x8285B0F8; continue 'dispatch;
	}
	// 8285A8D4: 80BA0004  lwz r5, 4(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A8D8: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 8285A8DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8285A8E0: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285A8E4: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 8285A8E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285A8EC: 419A00F4  beq cr6, 0x8285a9e0
	if ctx.cr[6].eq {
	pc = 0x8285A9E0; continue 'dispatch;
	}
	// 8285A8F0: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285A8F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285A8F8: 419A0024  beq cr6, 0x8285a91c
	if ctx.cr[6].eq {
	pc = 0x8285A91C; continue 'dispatch;
	}
	// 8285A8FC: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 8285A900: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285A904: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285A908: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285A90C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A910: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 8285A914: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285A918: 480000D0  b 0x8285a9e8
	pc = 0x8285A9E8; continue 'dispatch;
            }
            0x8285A91C => {
    //   block [0x8285A91C..0x8285A938)
	// 8285A91C: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285A920: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285A924: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8285A928: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285A92C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285A930: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285A934: 40810054  ble 0x8285a988
	if !ctx.cr[0].gt {
	pc = 0x8285A988; continue 'dispatch;
	}
	pc = 0x8285A938; continue 'dispatch;
            }
            0x8285A938 => {
    //   block [0x8285A938..0x8285A958)
	// 8285A938: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285A93C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285A940: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285A944: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A948: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8285A94C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 8285A950: 41980008  blt cr6, 0x8285a958
	if ctx.cr[6].lt {
	pc = 0x8285A958; continue 'dispatch;
	}
	// 8285A954: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8285A958; continue 'dispatch;
            }
            0x8285A958 => {
    //   block [0x8285A958..0x8285A974)
	// 8285A958: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285A95C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285A960: 419A0014  beq cr6, 0x8285a974
	if ctx.cr[6].eq {
	pc = 0x8285A974; continue 'dispatch;
	}
	// 8285A964: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285A968: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285A96C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285A970: 4800000C  b 0x8285a97c
	pc = 0x8285A97C; continue 'dispatch;
            }
            0x8285A974 => {
    //   block [0x8285A974..0x8285A97C)
	// 8285A974: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285A978: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285A97C; continue 'dispatch;
            }
            0x8285A97C => {
    //   block [0x8285A97C..0x8285A988)
	// 8285A97C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285A980: 4199FFB8  bgt cr6, 0x8285a938
	if ctx.cr[6].gt {
	pc = 0x8285A938; continue 'dispatch;
	}
	// 8285A984: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285A988; continue 'dispatch;
            }
            0x8285A988 => {
    //   block [0x8285A988..0x8285A9A4)
	// 8285A988: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285A98C: 419A0040  beq cr6, 0x8285a9cc
	if ctx.cr[6].eq {
	pc = 0x8285A9CC; continue 'dispatch;
	}
	// 8285A990: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285A994: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8285A998: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285A99C: 41990008  bgt cr6, 0x8285a9a4
	if ctx.cr[6].gt {
	pc = 0x8285A9A4; continue 'dispatch;
	}
	// 8285A9A0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285A9A4; continue 'dispatch;
            }
            0x8285A9A4 => {
    //   block [0x8285A9A4..0x8285A9CC)
	// 8285A9A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285A9A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285A9AC: 409A0020  bne cr6, 0x8285a9cc
	if !ctx.cr[6].eq {
	pc = 0x8285A9CC; continue 'dispatch;
	}
	// 8285A9B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285A9B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285A9B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285A9BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A9C0: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 8285A9C4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285A9C8: 48000020  b 0x8285a9e8
	pc = 0x8285A9E8; continue 'dispatch;
            }
            0x8285A9CC => {
    //   block [0x8285A9CC..0x8285A9E0)
	// 8285A9CC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285A9D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285A9D4: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 8285A9D8: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285A9DC: 4800000C  b 0x8285a9e8
	pc = 0x8285A9E8; continue 'dispatch;
            }
            0x8285A9E0 => {
    //   block [0x8285A9E0..0x8285A9E8)
	// 8285A9E0: 83610058  lwz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285A9E4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285A9E8; continue 'dispatch;
            }
            0x8285A9E8 => {
    //   block [0x8285A9E8..0x8285AA30)
	// 8285A9E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285A9EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285A9F0: 419A05B8  beq cr6, 0x8285afa8
	if ctx.cr[6].eq {
	pc = 0x8285AFA8; continue 'dispatch;
	}
	// 8285A9F4: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285A9F8: 556AD7FE  rlwinm r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 8285A9FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285AA00: 419A00F4  beq cr6, 0x8285aaf4
	if ctx.cr[6].eq {
	pc = 0x8285AAF4; continue 'dispatch;
	}
	// 8285AA04: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285AA08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285AA0C: 419A0024  beq cr6, 0x8285aa30
	if ctx.cr[6].eq {
	pc = 0x8285AA30; continue 'dispatch;
	}
	// 8285AA10: 894B0006  lbz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 8285AA14: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285AA18: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285AA1C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285AA20: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285AA24: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285AA28: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285AA2C: 480000D0  b 0x8285aafc
	pc = 0x8285AAFC; continue 'dispatch;
            }
            0x8285AA30 => {
    //   block [0x8285AA30..0x8285AA4C)
	// 8285AA30: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285AA34: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285AA38: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8285AA3C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285AA40: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285AA44: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285AA48: 40810054  ble 0x8285aa9c
	if !ctx.cr[0].gt {
	pc = 0x8285AA9C; continue 'dispatch;
	}
	pc = 0x8285AA4C; continue 'dispatch;
            }
            0x8285AA4C => {
    //   block [0x8285AA4C..0x8285AA6C)
	// 8285AA4C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285AA50: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285AA54: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285AA58: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285AA5C: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 8285AA60: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 8285AA64: 41980008  blt cr6, 0x8285aa6c
	if ctx.cr[6].lt {
	pc = 0x8285AA6C; continue 'dispatch;
	}
	// 8285AA68: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8285AA6C; continue 'dispatch;
            }
            0x8285AA6C => {
    //   block [0x8285AA6C..0x8285AA88)
	// 8285AA6C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285AA70: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285AA74: 419A0014  beq cr6, 0x8285aa88
	if ctx.cr[6].eq {
	pc = 0x8285AA88; continue 'dispatch;
	}
	// 8285AA78: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285AA7C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285AA80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285AA84: 4800000C  b 0x8285aa90
	pc = 0x8285AA90; continue 'dispatch;
            }
            0x8285AA88 => {
    //   block [0x8285AA88..0x8285AA90)
	// 8285AA88: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285AA8C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285AA90; continue 'dispatch;
            }
            0x8285AA90 => {
    //   block [0x8285AA90..0x8285AA9C)
	// 8285AA90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285AA94: 4199FFB8  bgt cr6, 0x8285aa4c
	if ctx.cr[6].gt {
	pc = 0x8285AA4C; continue 'dispatch;
	}
	// 8285AA98: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285AA9C; continue 'dispatch;
            }
            0x8285AA9C => {
    //   block [0x8285AA9C..0x8285AAB8)
	// 8285AA9C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285AAA0: 419A0040  beq cr6, 0x8285aae0
	if ctx.cr[6].eq {
	pc = 0x8285AAE0; continue 'dispatch;
	}
	// 8285AAA4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285AAA8: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 8285AAAC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285AAB0: 41990008  bgt cr6, 0x8285aab8
	if ctx.cr[6].gt {
	pc = 0x8285AAB8; continue 'dispatch;
	}
	// 8285AAB4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285AAB8; continue 'dispatch;
            }
            0x8285AAB8 => {
    //   block [0x8285AAB8..0x8285AAE0)
	// 8285AAB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285AABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285AAC0: 409A0020  bne cr6, 0x8285aae0
	if !ctx.cr[6].eq {
	pc = 0x8285AAE0; continue 'dispatch;
	}
	// 8285AAC4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285AAC8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285AACC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285AAD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285AAD4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285AAD8: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285AADC: 48000020  b 0x8285aafc
	pc = 0x8285AAFC; continue 'dispatch;
            }
            0x8285AAE0 => {
    //   block [0x8285AAE0..0x8285AAF4)
	// 8285AAE0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285AAE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285AAE8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285AAEC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285AAF0: 4800000C  b 0x8285aafc
	pc = 0x8285AAFC; continue 'dispatch;
            }
            0x8285AAF4 => {
    //   block [0x8285AAF4..0x8285AAFC)
	// 8285AAF4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285AAF8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285AAFC; continue 'dispatch;
            }
            0x8285AAFC => {
    //   block [0x8285AAFC..0x8285AB8C)
	// 8285AAFC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285AB00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285AB04: 419A04A4  beq cr6, 0x8285afa8
	if ctx.cr[6].eq {
	pc = 0x8285AFA8; continue 'dispatch;
	}
	// 8285AB08: 89450024  lbz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285AB0C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8285AB10: 80830094  lwz r4, 0x94(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 8285AB14: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 8285AB18: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8285AB1C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8285AB20: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 8285AB24: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 8285AB28: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285AB2C: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 8285AB30: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8285AB34: 9381008C  stw r28, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[28].u32 ) };
	// 8285AB38: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 8285AB3C: 93810094  stw r28, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[28].u32 ) };
	// 8285AB40: 9B810099  stb r28, 0x99(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(153 as u32), ctx.r[28].u8 ) };
	// 8285AB44: 938100A0  stw r28, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[28].u32 ) };
	// 8285AB48: 938100A4  stw r28, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[28].u32 ) };
	// 8285AB4C: 938100A8  stw r28, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[28].u32 ) };
	// 8285AB50: 938100B0  stw r28, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u32 ) };
	// 8285AB54: 938100B4  stw r28, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[28].u32 ) };
	// 8285AB58: 938100B8  stw r28, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u32 ) };
	// 8285AB5C: 419A00F4  beq cr6, 0x8285ac50
	if ctx.cr[6].eq {
	pc = 0x8285AC50; continue 'dispatch;
	}
	// 8285AB60: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285AB64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285AB68: 419A0024  beq cr6, 0x8285ab8c
	if ctx.cr[6].eq {
	pc = 0x8285AB8C; continue 'dispatch;
	}
	// 8285AB6C: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8285AB70: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285AB74: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285AB78: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285AB7C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285AB80: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285AB84: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285AB88: 480000CC  b 0x8285ac54
	pc = 0x8285AC54; continue 'dispatch;
            }
            0x8285AB8C => {
    //   block [0x8285AB8C..0x8285ABA8)
	// 8285AB8C: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285AB90: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285AB94: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8285AB98: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285AB9C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285ABA0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285ABA4: 40810054  ble 0x8285abf8
	if !ctx.cr[0].gt {
	pc = 0x8285ABF8; continue 'dispatch;
	}
	pc = 0x8285ABA8; continue 'dispatch;
            }
            0x8285ABA8 => {
    //   block [0x8285ABA8..0x8285ABC8)
	// 8285ABA8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285ABAC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285ABB0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285ABB4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285ABB8: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 8285ABBC: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 8285ABC0: 41980008  blt cr6, 0x8285abc8
	if ctx.cr[6].lt {
	pc = 0x8285ABC8; continue 'dispatch;
	}
	// 8285ABC4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8285ABC8; continue 'dispatch;
            }
            0x8285ABC8 => {
    //   block [0x8285ABC8..0x8285ABE4)
	// 8285ABC8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285ABCC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285ABD0: 419A0014  beq cr6, 0x8285abe4
	if ctx.cr[6].eq {
	pc = 0x8285ABE4; continue 'dispatch;
	}
	// 8285ABD4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285ABD8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285ABDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285ABE0: 4800000C  b 0x8285abec
	pc = 0x8285ABEC; continue 'dispatch;
            }
            0x8285ABE4 => {
    //   block [0x8285ABE4..0x8285ABEC)
	// 8285ABE4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285ABE8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285ABEC; continue 'dispatch;
            }
            0x8285ABEC => {
    //   block [0x8285ABEC..0x8285ABF8)
	// 8285ABEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285ABF0: 4199FFB8  bgt cr6, 0x8285aba8
	if ctx.cr[6].gt {
	pc = 0x8285ABA8; continue 'dispatch;
	}
	// 8285ABF4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285ABF8; continue 'dispatch;
            }
            0x8285ABF8 => {
    //   block [0x8285ABF8..0x8285AC14)
	// 8285ABF8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285ABFC: 419A0040  beq cr6, 0x8285ac3c
	if ctx.cr[6].eq {
	pc = 0x8285AC3C; continue 'dispatch;
	}
	// 8285AC00: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285AC04: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 8285AC08: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285AC0C: 41990008  bgt cr6, 0x8285ac14
	if ctx.cr[6].gt {
	pc = 0x8285AC14; continue 'dispatch;
	}
	// 8285AC10: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285AC14; continue 'dispatch;
            }
            0x8285AC14 => {
    //   block [0x8285AC14..0x8285AC3C)
	// 8285AC14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285AC18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285AC1C: 409A0020  bne cr6, 0x8285ac3c
	if !ctx.cr[6].eq {
	pc = 0x8285AC3C; continue 'dispatch;
	}
	// 8285AC20: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285AC24: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285AC28: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285AC2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285AC30: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285AC34: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285AC38: 4800001C  b 0x8285ac54
	pc = 0x8285AC54; continue 'dispatch;
            }
            0x8285AC3C => {
    //   block [0x8285AC3C..0x8285AC50)
	// 8285AC3C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285AC40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285AC44: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285AC48: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285AC4C: 48000008  b 0x8285ac54
	pc = 0x8285AC54; continue 'dispatch;
            }
            0x8285AC50 => {
    //   block [0x8285AC50..0x8285AC54)
	// 8285AC50: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285AC54; continue 'dispatch;
            }
            0x8285AC54 => {
    //   block [0x8285AC54..0x8285ACBC)
	// 8285AC54: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285AC58: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8285AC5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285AC60: 3BABB730  addi r29, r11, -0x48d0
	ctx.r[29].s64 = ctx.r[11].s64 + -18640;
	// 8285AC64: 419A0194  beq cr6, 0x8285adf8
	if ctx.cr[6].eq {
	pc = 0x8285ADF8; continue 'dispatch;
	}
	// 8285AC68: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8285AC6C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8285AC70: 48323489  bl 0x82b7e0f8
	ctx.lr = 0x8285AC74;
	sub_82B7E0F8(ctx, base);
	// 8285AC74: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8285AC78: 4BA403C1  bl 0x8229b038
	ctx.lr = 0x8285AC7C;
	sub_8229B038(ctx, base);
	// 8285AC7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285AC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285AC84: 419A0038  beq cr6, 0x8285acbc
	if ctx.cr[6].eq {
	pc = 0x8285ACBC; continue 'dispatch;
	}
	// 8285AC88: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8285AC8C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285AC90: 388B37BC  addi r4, r11, 0x37bc
	ctx.r[4].s64 = ctx.r[11].s64 + 14268;
	// 8285AC94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285AC98: 4B9D2239  bl 0x8222ced0
	ctx.lr = 0x8285AC9C;
	sub_8222CED0(ctx, base);
	// 8285AC9C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8285ACA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8285ACA4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8285ACA8: 48323669  bl 0x82b7e310
	ctx.lr = 0x8285ACAC;
	sub_82B7E310(ctx, base);
	// 8285ACAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285ACB0: 4B9BA129  bl 0x82214dd8
	ctx.lr = 0x8285ACB4;
	sub_82214DD8(ctx, base);
	// 8285ACB4: 9B1A0024  stb r24, 0x24(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(36 as u32), ctx.r[24].u8 ) };
	// 8285ACB8: 48000008  b 0x8285acc0
	pc = 0x8285ACC0; continue 'dispatch;
            }
            0x8285ACBC => {
    //   block [0x8285ACBC..0x8285ACC0)
	// 8285ACBC: 9B9A0024  stb r28, 0x24(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(36 as u32), ctx.r[28].u8 ) };
	pc = 0x8285ACC0; continue 'dispatch;
            }
            0x8285ACC0 => {
    //   block [0x8285ACC0..0x8285AD00)
	// 8285ACC0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285ACC4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8285ACC8: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 8285ACCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285ACD0: 4E800421  bctrl
	ctx.lr = 0x8285ACD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285ACD4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285ACD8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285ACDC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285ACE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285ACE4: 419A001C  beq cr6, 0x8285ad00
	if ctx.cr[6].eq {
	pc = 0x8285AD00; continue 'dispatch;
	}
	// 8285ACE8: 9B1A0025  stb r24, 0x25(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(37 as u32), ctx.r[24].u8 ) };
	// 8285ACEC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285ACF0: 388BDBD8  addi r4, r11, -0x2428
	ctx.r[4].s64 = ctx.r[11].s64 + -9256;
	// 8285ACF4: 4B9D21DD  bl 0x8222ced0
	ctx.lr = 0x8285ACF8;
	sub_8222CED0(ctx, base);
	// 8285ACF8: C03DDD60  lfs f1, -0x22a0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285ACFC: 480000D0  b 0x8285adcc
	pc = 0x8285ADCC; continue 'dispatch;
            }
            0x8285AD00 => {
    //   block [0x8285AD00..0x8285AD8C)
	// 8285AD00: 9B9A0025  stb r28, 0x25(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(37 as u32), ctx.r[28].u8 ) };
	// 8285AD04: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8285AD08: 388B0754  addi r4, r11, 0x754
	ctx.r[4].s64 = ctx.r[11].s64 + 1876;
	// 8285AD0C: 4B9D21C5  bl 0x8222ced0
	ctx.lr = 0x8285AD10;
	sub_8222CED0(ctx, base);
	// 8285AD10: C3FDDD60  lfs f31, -0x22a0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8285AD14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8285AD18: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285AD1C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8285AD20: 483236D9  bl 0x82b7e3f8
	ctx.lr = 0x8285AD24;
	sub_82B7E3F8(ctx, base);
	// 8285AD24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285AD28: 4B9BA0B1  bl 0x82214dd8
	ctx.lr = 0x8285AD2C;
	sub_82214DD8(ctx, base);
	// 8285AD2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8285AD30: C3DDDD54  lfs f30, -0x22ac(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8876 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8285AD34: C01E0040  lfs f0, 0x40(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285AD38: 3BEB131C  addi r31, r11, 0x131c
	ctx.r[31].s64 = ctx.r[11].s64 + 4892;
	// 8285AD3C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 8285AD40: 4198004C  blt cr6, 0x8285ad8c
	if ctx.cr[6].lt {
	pc = 0x8285AD8C; continue 'dispatch;
	}
	// 8285AD44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8285AD48: 387A0008  addi r3, r26, 8
	ctx.r[3].s64 = ctx.r[26].s64 + 8;
	// 8285AD4C: 4BA4046D  bl 0x8229b1b8
	ctx.lr = 0x8285AD50;
	sub_8229B1B8(ctx, base);
	// 8285AD50: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285AD54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285AD58: 419A0034  beq cr6, 0x8285ad8c
	if ctx.cr[6].eq {
	pc = 0x8285AD8C; continue 'dispatch;
	}
	// 8285AD5C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285AD60: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285AD64: 388BF364  addi r4, r11, -0xc9c
	ctx.r[4].s64 = ctx.r[11].s64 + -3228;
	// 8285AD68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285AD6C: 4B9D2165  bl 0x8222ced0
	ctx.lr = 0x8285AD70;
	sub_8222CED0(ctx, base);
	// 8285AD70: C01E0040  lfs f0, 0x40(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285AD74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8285AD78: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8285AD7C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8285AD80: 48323679  bl 0x82b7e3f8
	ctx.lr = 0x8285AD84;
	sub_82B7E3F8(ctx, base);
	// 8285AD84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285AD88: 4B9BA051  bl 0x82214dd8
	ctx.lr = 0x8285AD8C;
	sub_82214DD8(ctx, base);
	pc = 0x8285AD8C; continue 'dispatch;
            }
            0x8285AD8C => {
    //   block [0x8285AD8C..0x8285ADCC)
	// 8285AD8C: C01E0044  lfs f0, 0x44(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285AD90: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 8285AD94: 4198004C  blt cr6, 0x8285ade0
	if ctx.cr[6].lt {
	pc = 0x8285ADE0; continue 'dispatch;
	}
	// 8285AD98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8285AD9C: 387A0008  addi r3, r26, 8
	ctx.r[3].s64 = ctx.r[26].s64 + 8;
	// 8285ADA0: 4BA40419  bl 0x8229b1b8
	ctx.lr = 0x8285ADA4;
	sub_8229B1B8(ctx, base);
	// 8285ADA4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285ADA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285ADAC: 419A0034  beq cr6, 0x8285ade0
	if ctx.cr[6].eq {
	pc = 0x8285ADE0; continue 'dispatch;
	}
	// 8285ADB0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285ADB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285ADB8: 388BDBD8  addi r4, r11, -0x2428
	ctx.r[4].s64 = ctx.r[11].s64 + -9256;
	// 8285ADBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285ADC0: 4B9D2111  bl 0x8222ced0
	ctx.lr = 0x8285ADC4;
	sub_8222CED0(ctx, base);
	// 8285ADC4: C01E0044  lfs f0, 0x44(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285ADC8: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x8285ADCC; continue 'dispatch;
            }
            0x8285ADCC => {
    //   block [0x8285ADCC..0x8285ADE0)
	// 8285ADCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8285ADD0: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8285ADD4: 48323625  bl 0x82b7e3f8
	ctx.lr = 0x8285ADD8;
	sub_82B7E3F8(ctx, base);
	// 8285ADD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285ADDC: 4B9B9FFD  bl 0x82214dd8
	ctx.lr = 0x8285ADE0;
	sub_82214DD8(ctx, base);
	pc = 0x8285ADE0; continue 'dispatch;
            }
            0x8285ADE0 => {
    //   block [0x8285ADE0..0x8285ADF8)
	// 8285ADE0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8285ADE4: 388100AC  addi r4, r1, 0xac
	ctx.r[4].s64 = ctx.r[1].s64 + 172;
	// 8285ADE8: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 8285ADEC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8285ADF0: 4BF078C9  bl 0x827626b8
	ctx.lr = 0x8285ADF4;
	sub_827626B8(ctx, base);
	// 8285ADF4: 48000010  b 0x8285ae04
	pc = 0x8285AE04; continue 'dispatch;
            }
            0x8285ADF8 => {
    //   block [0x8285ADF8..0x8285AE04)
	// 8285ADF8: 38A300CC  addi r5, r3, 0xcc
	ctx.r[5].s64 = ctx.r[3].s64 + 204;
	// 8285ADFC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8285AE00: 4BF06E41  bl 0x82761c40
	ctx.lr = 0x8285AE04;
	sub_82761C40(ctx, base);
	pc = 0x8285AE04; continue 'dispatch;
            }
            0x8285AE04 => {
    //   block [0x8285AE04..0x8285AE2C)
	// 8285AE04: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8285AE08: 4B9C4451  bl 0x8221f258
	ctx.lr = 0x8285AE0C;
	sub_8221F258(ctx, base);
	// 8285AE0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285AE10: 419A001C  beq cr6, 0x8285ae2c
	if ctx.cr[6].eq {
	pc = 0x8285AE2C; continue 'dispatch;
	}
	// 8285AE14: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8285AE18: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8285AE1C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8285AE20: 4BF06FB9  bl 0x82761dd8
	ctx.lr = 0x8285AE24;
	sub_82761DD8(ctx, base);
	// 8285AE24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285AE28: 48000008  b 0x8285ae30
	pc = 0x8285AE30; continue 'dispatch;
            }
            0x8285AE2C => {
    //   block [0x8285AE2C..0x8285AE30)
	// 8285AE2C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x8285AE30; continue 'dispatch;
            }
            0x8285AE30 => {
    //   block [0x8285AE30..0x8285AE60)
	// 8285AE30: 3BDA0018  addi r30, r26, 0x18
	ctx.r[30].s64 = ctx.r[26].s64 + 24;
	// 8285AE34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285AE38: 4BA18221  bl 0x82273058
	ctx.lr = 0x8285AE3C;
	sub_82273058(ctx, base);
	// 8285AE3C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8285AE40: 4B9C4419  bl 0x8221f258
	ctx.lr = 0x8285AE44;
	sub_8221F258(ctx, base);
	// 8285AE44: C3FD0000  lfs f31, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8285AE48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285AE4C: 419A0014  beq cr6, 0x8285ae60
	if ctx.cr[6].eq {
	pc = 0x8285AE60; continue 'dispatch;
	}
	// 8285AE50: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285AE54: 4BA30CED  bl 0x8228bb40
	ctx.lr = 0x8285AE58;
	sub_8228BB40(ctx, base);
	// 8285AE58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8285AE5C: 48000008  b 0x8285ae64
	pc = 0x8285AE64; continue 'dispatch;
            }
            0x8285AE60 => {
    //   block [0x8285AE60..0x8285AE64)
	// 8285AE60: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	pc = 0x8285AE64; continue 'dispatch;
            }
            0x8285AE64 => {
    //   block [0x8285AE64..0x8285AE84)
	// 8285AE64: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8285AE68: 4B9C43F1  bl 0x8221f258
	ctx.lr = 0x8285AE6C;
	sub_8221F258(ctx, base);
	// 8285AE6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285AE70: 419A0014  beq cr6, 0x8285ae84
	if ctx.cr[6].eq {
	pc = 0x8285AE84; continue 'dispatch;
	}
	// 8285AE74: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285AE78: 4B9CE8C1  bl 0x82229738
	ctx.lr = 0x8285AE7C;
	sub_82229738(ctx, base);
	// 8285AE7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285AE80: 48000008  b 0x8285ae88
	pc = 0x8285AE88; continue 'dispatch;
            }
            0x8285AE84 => {
    //   block [0x8285AE84..0x8285AE88)
	// 8285AE84: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x8285AE88; continue 'dispatch;
            }
            0x8285AE88 => {
    //   block [0x8285AE88..0x8285AEE8)
	// 8285AE88: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285AE8C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8285AE90: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285AE94: 814B0070  lwz r10, 0x70(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8285AE98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285AE9C: 4E800421  bctrl
	ctx.lr = 0x8285AEA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285AEA0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8285AEA4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8285AEA8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8285AEAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285AEB0: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8285AEB4: 3900001F  li r8, 0x1f
	ctx.r[8].s64 = 31;
	// 8285AEB8: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 8285AEBC: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 8285AEC0: 4BD081F9  bl 0x825630b8
	ctx.lr = 0x8285AEC4;
	sub_825630B8(ctx, base);
	// 8285AEC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285AEC8: 813A0020  lwz r9, 0x20(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 8285AECC: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285AED0: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 8285AED4: 419A007C  beq cr6, 0x8285af50
	if ctx.cr[6].eq {
	pc = 0x8285AF50; continue 'dispatch;
	}
	// 8285AED8: 5523003E  slwi r3, r9, 0
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8285AEDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285AEE0: 419A0040  beq cr6, 0x8285af20
	if ctx.cr[6].eq {
	pc = 0x8285AF20; continue 'dispatch;
	}
	// 8285AEE4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
            }
            0x8285AEE8 => {
    //   block [0x8285AEE8..0x8285AF1C)
	// 8285AEE8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8285AEEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285AEF0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8285AEF4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285AEF8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285AEFC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285AF00: 4082FFE8  bne 0x8285aee8
	if !ctx.cr[0].eq {
	pc = 0x8285AEE8; continue 'dispatch;
	}
	// 8285AF04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285AF08: 409A0014  bne cr6, 0x8285af1c
	if !ctx.cr[6].eq {
	pc = 0x8285AF1C; continue 'dispatch;
	}
	// 8285AF0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285AF10: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285AF14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285AF18: 4E800421  bctrl
	ctx.lr = 0x8285AF1C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285AF1C => {
    //   block [0x8285AF1C..0x8285AF20)
	// 8285AF1C: 939A0020  stw r28, 0x20(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	pc = 0x8285AF20; continue 'dispatch;
            }
            0x8285AF20 => {
    //   block [0x8285AF20..0x8285AF34)
	// 8285AF20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285AF24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285AF28: 917A0020  stw r11, 0x20(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 8285AF2C: 419A0024  beq cr6, 0x8285af50
	if ctx.cr[6].eq {
	pc = 0x8285AF50; continue 'dispatch;
	}
	// 8285AF30: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x8285AF34; continue 'dispatch;
            }
            0x8285AF34 => {
    //   block [0x8285AF34..0x8285AF50)
	// 8285AF34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285AF38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285AF3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285AF40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285AF44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285AF48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285AF4C: 4082FFE8  bne 0x8285af34
	if !ctx.cr[0].eq {
	pc = 0x8285AF34; continue 'dispatch;
	}
	pc = 0x8285AF50; continue 'dispatch;
            }
            0x8285AF50 => {
    //   block [0x8285AF50..0x8285AF64)
	// 8285AF50: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285AF54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285AF58: 419A0048  beq cr6, 0x8285afa0
	if ctx.cr[6].eq {
	pc = 0x8285AFA0; continue 'dispatch;
	}
	// 8285AF5C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285AF60: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x8285AF64; continue 'dispatch;
            }
            0x8285AF64 => {
    //   block [0x8285AF64..0x8285AF9C)
	// 8285AF64: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285AF68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285AF6C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285AF70: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8285AF74: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285AF78: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285AF7C: 4082FFE8  bne 0x8285af64
	if !ctx.cr[0].eq {
	pc = 0x8285AF64; continue 'dispatch;
	}
	// 8285AF80: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8285AF84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285AF88: 409A0014  bne cr6, 0x8285af9c
	if !ctx.cr[6].eq {
	pc = 0x8285AF9C; continue 'dispatch;
	}
	// 8285AF8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285AF90: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285AF94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285AF98: 4E800421  bctrl
	ctx.lr = 0x8285AF9C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285AF9C => {
    //   block [0x8285AF9C..0x8285AFA0)
	// 8285AF9C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	pc = 0x8285AFA0; continue 'dispatch;
            }
            0x8285AFA0 => {
    //   block [0x8285AFA0..0x8285AFA8)
	// 8285AFA0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8285AFA4: 4BFAC7AD  bl 0x82807750
	ctx.lr = 0x8285AFA8;
	sub_82807750(ctx, base);
	pc = 0x8285AFA8; continue 'dispatch;
            }
            0x8285AFA8 => {
    //   block [0x8285AFA8..0x8285AFFC)
	// 8285AFA8: 3BDA0010  addi r30, r26, 0x10
	ctx.r[30].s64 = ctx.r[26].s64 + 16;
	// 8285AFAC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8285AFB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285AFB4: 4B9203E5  bl 0x8217b398
	ctx.lr = 0x8285AFB8;
	sub_8217B398(ctx, base);
	// 8285AFB8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285AFBC: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 8285AFC0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285AFC4: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 8285AFC8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285AFCC: 419A00F4  beq cr6, 0x8285b0c0
	if ctx.cr[6].eq {
	pc = 0x8285B0C0; continue 'dispatch;
	}
	// 8285AFD0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285AFD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285AFD8: 419A0024  beq cr6, 0x8285affc
	if ctx.cr[6].eq {
	pc = 0x8285AFFC; continue 'dispatch;
	}
	// 8285AFDC: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 8285AFE0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285AFE4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8285AFE8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8285AFEC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285AFF0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285AFF4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285AFF8: 480000CC  b 0x8285b0c4
	pc = 0x8285B0C4; continue 'dispatch;
            }
            0x8285AFFC => {
    //   block [0x8285AFFC..0x8285B018)
	// 8285AFFC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285B000: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285B004: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8285B008: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285B00C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285B010: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285B014: 40810054  ble 0x8285b068
	if !ctx.cr[0].gt {
	pc = 0x8285B068; continue 'dispatch;
	}
	pc = 0x8285B018; continue 'dispatch;
            }
            0x8285B018 => {
    //   block [0x8285B018..0x8285B038)
	// 8285B018: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285B01C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285B020: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285B024: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B028: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 8285B02C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 8285B030: 41980008  blt cr6, 0x8285b038
	if ctx.cr[6].lt {
	pc = 0x8285B038; continue 'dispatch;
	}
	// 8285B034: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8285B038; continue 'dispatch;
            }
            0x8285B038 => {
    //   block [0x8285B038..0x8285B054)
	// 8285B038: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285B03C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285B040: 419A0014  beq cr6, 0x8285b054
	if ctx.cr[6].eq {
	pc = 0x8285B054; continue 'dispatch;
	}
	// 8285B044: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285B048: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285B04C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285B050: 4800000C  b 0x8285b05c
	pc = 0x8285B05C; continue 'dispatch;
            }
            0x8285B054 => {
    //   block [0x8285B054..0x8285B05C)
	// 8285B054: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285B058: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285B05C; continue 'dispatch;
            }
            0x8285B05C => {
    //   block [0x8285B05C..0x8285B068)
	// 8285B05C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285B060: 4199FFB8  bgt cr6, 0x8285b018
	if ctx.cr[6].gt {
	pc = 0x8285B018; continue 'dispatch;
	}
	// 8285B064: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285B068; continue 'dispatch;
            }
            0x8285B068 => {
    //   block [0x8285B068..0x8285B084)
	// 8285B068: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285B06C: 419A0040  beq cr6, 0x8285b0ac
	if ctx.cr[6].eq {
	pc = 0x8285B0AC; continue 'dispatch;
	}
	// 8285B070: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B074: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 8285B078: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285B07C: 41990008  bgt cr6, 0x8285b084
	if ctx.cr[6].gt {
	pc = 0x8285B084; continue 'dispatch;
	}
	// 8285B080: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285B084; continue 'dispatch;
            }
            0x8285B084 => {
    //   block [0x8285B084..0x8285B0AC)
	// 8285B084: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285B088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B08C: 409A0020  bne cr6, 0x8285b0ac
	if !ctx.cr[6].eq {
	pc = 0x8285B0AC; continue 'dispatch;
	}
	// 8285B090: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285B094: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285B098: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285B09C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B0A0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285B0A4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285B0A8: 4800001C  b 0x8285b0c4
	pc = 0x8285B0C4; continue 'dispatch;
            }
            0x8285B0AC => {
    //   block [0x8285B0AC..0x8285B0C0)
	// 8285B0AC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285B0B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B0B4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285B0B8: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 8285B0BC: 48000008  b 0x8285b0c4
	pc = 0x8285B0C4; continue 'dispatch;
            }
            0x8285B0C0 => {
    //   block [0x8285B0C0..0x8285B0C4)
	// 8285B0C0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285B0C4; continue 'dispatch;
            }
            0x8285B0C4 => {
    //   block [0x8285B0C4..0x8285B0F8)
	// 8285B0C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285B0C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B0CC: 419A002C  beq cr6, 0x8285b0f8
	if ctx.cr[6].eq {
	pc = 0x8285B0F8; continue 'dispatch;
	}
	// 8285B0D0: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8285B0D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285B0D8: 4B9A44F1  bl 0x821ff5c8
	ctx.lr = 0x8285B0DC;
	sub_821FF5C8(ctx, base);
	// 8285B0DC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285B0E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B0E4: 409A0014  bne cr6, 0x8285b0f8
	if !ctx.cr[6].eq {
	pc = 0x8285B0F8; continue 'dispatch;
	}
	// 8285B0E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8285B0EC: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B0F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285B0F4: 4BBC6CD5  bl 0x82421dc8
	ctx.lr = 0x8285B0F8;
	sub_82421DC8(ctx, base);
	pc = 0x8285B0F8; continue 'dispatch;
            }
            0x8285B0F8 => {
    //   block [0x8285B0F8..0x8285B110)
	// 8285B0F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8285B0FC: 4B95CA1D  bl 0x821b7b18
	ctx.lr = 0x8285B100;
	sub_821B7B18(ctx, base);
	// 8285B100: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 8285B104: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 8285B108: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8285B10C: 4844E33C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285B110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285B110 size=432
    let mut pc: u32 = 0x8285B110;
    'dispatch: loop {
        match pc {
            0x8285B110 => {
    //   block [0x8285B110..0x8285B174)
	// 8285B110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285B114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285B118: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285B11C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285B120: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285B124: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8285B128: 809E0020  lwz r4, 0x20(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 8285B12C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8285B130: 419A0178  beq cr6, 0x8285b2a8
	if ctx.cr[6].eq {
	pc = 0x8285B2A8; continue 'dispatch;
	}
	// 8285B134: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B138: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8285B13C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285B140: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 8285B144: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285B148: 419A00E8  beq cr6, 0x8285b230
	if ctx.cr[6].eq {
	pc = 0x8285B230; continue 'dispatch;
	}
	// 8285B14C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285B150: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285B154: 419A0020  beq cr6, 0x8285b174
	if ctx.cr[6].eq {
	pc = 0x8285B174; continue 'dispatch;
	}
	// 8285B158: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 8285B15C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285B160: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8285B164: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8285B168: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285B16C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B170: 480000C8  b 0x8285b238
	pc = 0x8285B238; continue 'dispatch;
            }
            0x8285B174 => {
    //   block [0x8285B174..0x8285B190)
	// 8285B174: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285B178: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285B17C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8285B180: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285B184: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285B188: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285B18C: 40810054  ble 0x8285b1e0
	if !ctx.cr[0].gt {
	pc = 0x8285B1E0; continue 'dispatch;
	}
	pc = 0x8285B190; continue 'dispatch;
            }
            0x8285B190 => {
    //   block [0x8285B190..0x8285B1B0)
	// 8285B190: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285B194: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285B198: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285B19C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B1A0: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8285B1A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285B1A8: 41980008  blt cr6, 0x8285b1b0
	if ctx.cr[6].lt {
	pc = 0x8285B1B0; continue 'dispatch;
	}
	// 8285B1AC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x8285B1B0; continue 'dispatch;
            }
            0x8285B1B0 => {
    //   block [0x8285B1B0..0x8285B1CC)
	// 8285B1B0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285B1B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285B1B8: 419A0014  beq cr6, 0x8285b1cc
	if ctx.cr[6].eq {
	pc = 0x8285B1CC; continue 'dispatch;
	}
	// 8285B1BC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285B1C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285B1C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285B1C8: 4800000C  b 0x8285b1d4
	pc = 0x8285B1D4; continue 'dispatch;
            }
            0x8285B1CC => {
    //   block [0x8285B1CC..0x8285B1D4)
	// 8285B1CC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285B1D0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285B1D4; continue 'dispatch;
            }
            0x8285B1D4 => {
    //   block [0x8285B1D4..0x8285B1E0)
	// 8285B1D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285B1D8: 4199FFB8  bgt cr6, 0x8285b190
	if ctx.cr[6].gt {
	pc = 0x8285B190; continue 'dispatch;
	}
	// 8285B1DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285B1E0; continue 'dispatch;
            }
            0x8285B1E0 => {
    //   block [0x8285B1E0..0x8285B1FC)
	// 8285B1E0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285B1E4: 419A003C  beq cr6, 0x8285b220
	if ctx.cr[6].eq {
	pc = 0x8285B220; continue 'dispatch;
	}
	// 8285B1E8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B1EC: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8285B1F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285B1F4: 41990008  bgt cr6, 0x8285b1fc
	if ctx.cr[6].gt {
	pc = 0x8285B1FC; continue 'dispatch;
	}
	// 8285B1F8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8285B1FC; continue 'dispatch;
            }
            0x8285B1FC => {
    //   block [0x8285B1FC..0x8285B220)
	// 8285B1FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285B200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B204: 409A001C  bne cr6, 0x8285b220
	if !ctx.cr[6].eq {
	pc = 0x8285B220; continue 'dispatch;
	}
	// 8285B208: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285B20C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285B210: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285B214: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285B218: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B21C: 4800001C  b 0x8285b238
	pc = 0x8285B238; continue 'dispatch;
            }
            0x8285B220 => {
    //   block [0x8285B220..0x8285B230)
	// 8285B220: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285B224: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285B228: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B22C: 4800000C  b 0x8285b238
	pc = 0x8285B238; continue 'dispatch;
            }
            0x8285B230 => {
    //   block [0x8285B230..0x8285B238)
	// 8285B230: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285B234: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x8285B238; continue 'dispatch;
            }
            0x8285B238 => {
    //   block [0x8285B238..0x8285B250)
	// 8285B238: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8285B23C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285B240: 419A0010  beq cr6, 0x8285b250
	if ctx.cr[6].eq {
	pc = 0x8285B250; continue 'dispatch;
	}
	// 8285B244: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8285B248: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285B24C: 4BD080FD  bl 0x82563348
	ctx.lr = 0x8285B250;
	sub_82563348(ctx, base);
	pc = 0x8285B250; continue 'dispatch;
            }
            0x8285B250 => {
    //   block [0x8285B250..0x8285B260)
	// 8285B250: 807E0020  lwz r3, 0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 8285B254: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285B258: 419A0040  beq cr6, 0x8285b298
	if ctx.cr[6].eq {
	pc = 0x8285B298; continue 'dispatch;
	}
	// 8285B25C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8285B260; continue 'dispatch;
            }
            0x8285B260 => {
    //   block [0x8285B260..0x8285B294)
	// 8285B260: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8285B264: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285B268: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8285B26C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285B270: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285B274: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285B278: 4082FFE8  bne 0x8285b260
	if !ctx.cr[0].eq {
	pc = 0x8285B260; continue 'dispatch;
	}
	// 8285B27C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285B280: 409A0014  bne cr6, 0x8285b294
	if !ctx.cr[6].eq {
	pc = 0x8285B294; continue 'dispatch;
	}
	// 8285B284: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B288: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B28C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285B290: 4E800421  bctrl
	ctx.lr = 0x8285B294;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285B294 => {
    //   block [0x8285B294..0x8285B298)
	// 8285B294: 93FE0020  stw r31, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	pc = 0x8285B298; continue 'dispatch;
            }
            0x8285B298 => {
    //   block [0x8285B298..0x8285B2A8)
	// 8285B298: 93FE0020  stw r31, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 8285B29C: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 8285B2A0: 4B95C879  bl 0x821b7b18
	ctx.lr = 0x8285B2A4;
	sub_821B7B18(ctx, base);
	// 8285B2A4: 93FE0010  stw r31, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	pc = 0x8285B2A8; continue 'dispatch;
            }
            0x8285B2A8 => {
    //   block [0x8285B2A8..0x8285B2C0)
	// 8285B2A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285B2AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285B2B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285B2B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285B2B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285B2BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285B2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285B2C0 size=88
    let mut pc: u32 = 0x8285B2C0;
    'dispatch: loop {
        match pc {
            0x8285B2C0 => {
    //   block [0x8285B2C0..0x8285B304)
	// 8285B2C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285B2C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285B2C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285B2CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285B2D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285B2D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B2D8: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285B2DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285B2E0: 4E800421  bctrl
	ctx.lr = 0x8285B2E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285B2E4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285B2E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285B2EC: 419A0018  beq cr6, 0x8285b304
	if ctx.cr[6].eq {
	pc = 0x8285B304; continue 'dispatch;
	}
	// 8285B2F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B2F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285B2F8: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 8285B2FC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285B300: 4E800421  bctrl
	ctx.lr = 0x8285B304;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285B304 => {
    //   block [0x8285B304..0x8285B318)
	// 8285B304: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8285B308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285B30C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285B310: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285B314: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285B318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285B318 size=76
    let mut pc: u32 = 0x8285B318;
    'dispatch: loop {
        match pc {
            0x8285B318 => {
    //   block [0x8285B318..0x8285B350)
	// 8285B318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285B31C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285B320: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285B324: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 8285B328: 409A0028  bne cr6, 0x8285b350
	if !ctx.cr[6].eq {
	pc = 0x8285B350; continue 'dispatch;
	}
	// 8285B32C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285B330: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 8285B334: 388BF378  addi r4, r11, -0xc88
	ctx.r[4].s64 = ctx.r[11].s64 + -3208;
	// 8285B338: 4BA1A101  bl 0x82275438
	ctx.lr = 0x8285B33C;
	sub_82275438(ctx, base);
	// 8285B33C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8285B340: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8285B344: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285B348: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285B34C: 4E800020  blr
	return;
            }
            0x8285B350 => {
    //   block [0x8285B350..0x8285B364)
	// 8285B350: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8285B354: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8285B358: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285B35C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285B360: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285B368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285B368 size=92
    let mut pc: u32 = 0x8285B368;
    'dispatch: loop {
        match pc {
            0x8285B368 => {
    //   block [0x8285B368..0x8285B3AC)
	// 8285B368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285B36C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285B370: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285B374: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285B378: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285B37C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285B380: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8285B384: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8285B388: 4B95C791  bl 0x821b7b18
	ctx.lr = 0x8285B38C;
	sub_821B7B18(ctx, base);
	// 8285B38C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285B390: 4BFF91B1  bl 0x82854540
	ctx.lr = 0x8285B394;
	sub_82854540(ctx, base);
	// 8285B394: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8285B398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285B39C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B3A0: 419A000C  beq cr6, 0x8285b3ac
	if ctx.cr[6].eq {
	pc = 0x8285B3AC; continue 'dispatch;
	}
	// 8285B3A4: 4B9C0995  bl 0x8221bd38
	ctx.lr = 0x8285B3A8;
	sub_8221BD38(ctx, base);
	// 8285B3A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8285B3AC; continue 'dispatch;
            }
            0x8285B3AC => {
    //   block [0x8285B3AC..0x8285B3C4)
	// 8285B3AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285B3B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285B3B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285B3B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285B3BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285B3C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285B3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8285B3C8 size=56
    let mut pc: u32 = 0x8285B3C8;
    'dispatch: loop {
        match pc {
            0x8285B3C8 => {
    //   block [0x8285B3C8..0x8285B3E0)
	// 8285B3C8: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 8285B3CC: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285B3D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B3D4: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8285B3D8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8285B3DC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x8285B3E0; continue 'dispatch;
            }
            0x8285B3E0 => {
    //   block [0x8285B3E0..0x8285B400)
	// 8285B3E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285B3E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285B3E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285B3EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285B3F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285B3F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285B3F8: 4082FFE8  bne 0x8285b3e0
	if !ctx.cr[0].eq {
	pc = 0x8285B3E0; continue 'dispatch;
	}
	// 8285B3FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285B400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285B400 size=764
    let mut pc: u32 = 0x8285B400;
    'dispatch: loop {
        match pc {
            0x8285B400 => {
    //   block [0x8285B400..0x8285B450)
	// 8285B400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285B404: 4844E009  bl 0x82ca940c
	ctx.lr = 0x8285B408;
	sub_82CA93D0(ctx, base);
	// 8285B408: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285B40C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8285B410: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B414: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285B418: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 8285B41C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285B420: 419A00F8  beq cr6, 0x8285b518
	if ctx.cr[6].eq {
	pc = 0x8285B518; continue 'dispatch;
	}
	// 8285B424: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285B428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B42C: 419A0024  beq cr6, 0x8285b450
	if ctx.cr[6].eq {
	pc = 0x8285B450; continue 'dispatch;
	}
	// 8285B430: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8285B434: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285B438: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285B43C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285B440: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B444: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285B448: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285B44C: 480000D4  b 0x8285b520
	pc = 0x8285B520; continue 'dispatch;
            }
            0x8285B450 => {
    //   block [0x8285B450..0x8285B470)
	// 8285B450: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285B454: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8285B458: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285B45C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8285B460: 7D2A2850  subf r9, r10, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 8285B464: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8285B468: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285B46C: 40810054  ble 0x8285b4c0
	if !ctx.cr[0].gt {
	pc = 0x8285B4C0; continue 'dispatch;
	}
	pc = 0x8285B470; continue 'dispatch;
            }
            0x8285B470 => {
    //   block [0x8285B470..0x8285B490)
	// 8285B470: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285B474: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285B478: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285B47C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B480: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 8285B484: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285B488: 41980008  blt cr6, 0x8285b490
	if ctx.cr[6].lt {
	pc = 0x8285B490; continue 'dispatch;
	}
	// 8285B48C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8285B490; continue 'dispatch;
            }
            0x8285B490 => {
    //   block [0x8285B490..0x8285B4AC)
	// 8285B490: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285B494: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285B498: 419A0014  beq cr6, 0x8285b4ac
	if ctx.cr[6].eq {
	pc = 0x8285B4AC; continue 'dispatch;
	}
	// 8285B49C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285B4A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285B4A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285B4A8: 4800000C  b 0x8285b4b4
	pc = 0x8285B4B4; continue 'dispatch;
            }
            0x8285B4AC => {
    //   block [0x8285B4AC..0x8285B4B4)
	// 8285B4AC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285B4B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285B4B4; continue 'dispatch;
            }
            0x8285B4B4 => {
    //   block [0x8285B4B4..0x8285B4C0)
	// 8285B4B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285B4B8: 4199FFB8  bgt cr6, 0x8285b470
	if ctx.cr[6].gt {
	pc = 0x8285B470; continue 'dispatch;
	}
	// 8285B4BC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8285B4C0; continue 'dispatch;
            }
            0x8285B4C0 => {
    //   block [0x8285B4C0..0x8285B4DC)
	// 8285B4C0: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8285B4C4: 419A0040  beq cr6, 0x8285b504
	if ctx.cr[6].eq {
	pc = 0x8285B504; continue 'dispatch;
	}
	// 8285B4C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B4CC: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 8285B4D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285B4D4: 41990008  bgt cr6, 0x8285b4dc
	if ctx.cr[6].gt {
	pc = 0x8285B4DC; continue 'dispatch;
	}
	// 8285B4D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285B4DC; continue 'dispatch;
            }
            0x8285B4DC => {
    //   block [0x8285B4DC..0x8285B504)
	// 8285B4DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285B4E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B4E4: 409A0020  bne cr6, 0x8285b504
	if !ctx.cr[6].eq {
	pc = 0x8285B504; continue 'dispatch;
	}
	// 8285B4E8: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8285B4EC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285B4F0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285B4F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B4F8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285B4FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285B500: 48000020  b 0x8285b520
	pc = 0x8285B520; continue 'dispatch;
            }
            0x8285B504 => {
    //   block [0x8285B504..0x8285B518)
	// 8285B504: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8285B508: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B50C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285B510: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285B514: 4800000C  b 0x8285b520
	pc = 0x8285B520; continue 'dispatch;
            }
            0x8285B518 => {
    //   block [0x8285B518..0x8285B520)
	// 8285B518: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285B51C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285B520; continue 'dispatch;
            }
            0x8285B520 => {
    //   block [0x8285B520..0x8285B568)
	// 8285B520: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285B524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B528: 419A01C4  beq cr6, 0x8285b6ec
	if ctx.cr[6].eq {
	pc = 0x8285B6EC; continue 'dispatch;
	}
	// 8285B52C: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285B530: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 8285B534: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285B538: 419A00F8  beq cr6, 0x8285b630
	if ctx.cr[6].eq {
	pc = 0x8285B630; continue 'dispatch;
	}
	// 8285B53C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285B540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B544: 419A0024  beq cr6, 0x8285b568
	if ctx.cr[6].eq {
	pc = 0x8285B568; continue 'dispatch;
	}
	// 8285B548: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 8285B54C: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285B550: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285B554: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285B558: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B55C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285B560: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285B564: 480000D4  b 0x8285b638
	pc = 0x8285B638; continue 'dispatch;
            }
            0x8285B568 => {
    //   block [0x8285B568..0x8285B588)
	// 8285B568: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285B56C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8285B570: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285B574: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8285B578: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285B57C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8285B580: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285B584: 40810054  ble 0x8285b5d8
	if !ctx.cr[0].gt {
	pc = 0x8285B5D8; continue 'dispatch;
	}
	pc = 0x8285B588; continue 'dispatch;
            }
            0x8285B588 => {
    //   block [0x8285B588..0x8285B5A8)
	// 8285B588: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285B58C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285B590: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285B594: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B598: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8285B59C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285B5A0: 41980008  blt cr6, 0x8285b5a8
	if ctx.cr[6].lt {
	pc = 0x8285B5A8; continue 'dispatch;
	}
	// 8285B5A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8285B5A8; continue 'dispatch;
            }
            0x8285B5A8 => {
    //   block [0x8285B5A8..0x8285B5C4)
	// 8285B5A8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285B5AC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285B5B0: 419A0014  beq cr6, 0x8285b5c4
	if ctx.cr[6].eq {
	pc = 0x8285B5C4; continue 'dispatch;
	}
	// 8285B5B4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285B5B8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285B5BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285B5C0: 4800000C  b 0x8285b5cc
	pc = 0x8285B5CC; continue 'dispatch;
            }
            0x8285B5C4 => {
    //   block [0x8285B5C4..0x8285B5CC)
	// 8285B5C4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285B5C8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285B5CC; continue 'dispatch;
            }
            0x8285B5CC => {
    //   block [0x8285B5CC..0x8285B5D8)
	// 8285B5CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285B5D0: 4199FFB8  bgt cr6, 0x8285b588
	if ctx.cr[6].gt {
	pc = 0x8285B588; continue 'dispatch;
	}
	// 8285B5D4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8285B5D8; continue 'dispatch;
            }
            0x8285B5D8 => {
    //   block [0x8285B5D8..0x8285B5F4)
	// 8285B5D8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285B5DC: 419A0040  beq cr6, 0x8285b61c
	if ctx.cr[6].eq {
	pc = 0x8285B61C; continue 'dispatch;
	}
	// 8285B5E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B5E4: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8285B5E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285B5EC: 41990008  bgt cr6, 0x8285b5f4
	if ctx.cr[6].gt {
	pc = 0x8285B5F4; continue 'dispatch;
	}
	// 8285B5F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285B5F4; continue 'dispatch;
            }
            0x8285B5F4 => {
    //   block [0x8285B5F4..0x8285B61C)
	// 8285B5F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285B5F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B5FC: 409A0020  bne cr6, 0x8285b61c
	if !ctx.cr[6].eq {
	pc = 0x8285B61C; continue 'dispatch;
	}
	// 8285B600: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8285B604: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285B608: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285B60C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B610: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285B614: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285B618: 48000020  b 0x8285b638
	pc = 0x8285B638; continue 'dispatch;
            }
            0x8285B61C => {
    //   block [0x8285B61C..0x8285B630)
	// 8285B61C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285B620: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B624: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285B628: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285B62C: 4800000C  b 0x8285b638
	pc = 0x8285B638; continue 'dispatch;
            }
            0x8285B630 => {
    //   block [0x8285B630..0x8285B638)
	// 8285B630: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285B634: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285B638; continue 'dispatch;
            }
            0x8285B638 => {
    //   block [0x8285B638..0x8285B6B4)
	// 8285B638: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285B63C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B640: 419A00AC  beq cr6, 0x8285b6ec
	if ctx.cr[6].eq {
	pc = 0x8285B6EC; continue 'dispatch;
	}
	// 8285B644: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8285B648: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285B64C: 388B0E20  addi r4, r11, 0xe20
	ctx.r[4].s64 = ctx.r[11].s64 + 3616;
	// 8285B650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285B654: 4B9D187D  bl 0x8222ced0
	ctx.lr = 0x8285B658;
	sub_8222CED0(ctx, base);
	// 8285B658: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8285B65C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285B660: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8285B664: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285B668: 4BBC60E9  bl 0x82421750
	ctx.lr = 0x8285B66C;
	sub_82421750(ctx, base);
	// 8285B66C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285B670: 4B9B9769  bl 0x82214dd8
	ctx.lr = 0x8285B674;
	sub_82214DD8(ctx, base);
	// 8285B674: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285B678: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285B67C: 419A0070  beq cr6, 0x8285b6ec
	if ctx.cr[6].eq {
	pc = 0x8285B6EC; continue 'dispatch;
	}
	// 8285B680: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 8285B684: 4B9C3BD5  bl 0x8221f258
	ctx.lr = 0x8285B688;
	sub_8221F258(ctx, base);
	// 8285B688: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8285B68C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285B690: 3BEB92D4  addi r31, r11, -0x6d2c
	ctx.r[31].s64 = ctx.r[11].s64 + -27948;
	// 8285B694: 419A0020  beq cr6, 0x8285b6b4
	if ctx.cr[6].eq {
	pc = 0x8285B6B4; continue 'dispatch;
	}
	// 8285B698: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8285B69C: C03F01B0  lfs f1, 0x1b0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285B6A0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8285B6A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8285B6A8: 4BA28589  bl 0x82283c30
	ctx.lr = 0x8285B6AC;
	sub_82283C30(ctx, base);
	// 8285B6AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285B6B0: 48000008  b 0x8285b6b8
	pc = 0x8285B6B8; continue 'dispatch;
            }
            0x8285B6B4 => {
    //   block [0x8285B6B4..0x8285B6B8)
	// 8285B6B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8285B6B8; continue 'dispatch;
            }
            0x8285B6B8 => {
    //   block [0x8285B6B8..0x8285B6EC)
	// 8285B6B8: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 8285B6BC: 4BA1799D  bl 0x82273058
	ctx.lr = 0x8285B6C0;
	sub_82273058(ctx, base);
	// 8285B6C0: 83DD0028  lwz r30, 0x28(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285B6C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285B6C8: C03E0028  lfs f1, 0x28(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285B6CC: 4BA77F7D  bl 0x822d3648
	ctx.lr = 0x8285B6D0;
	sub_822D3648(ctx, base);
	// 8285B6D0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B6D4: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285B6D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285B6DC: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8285B6E0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285B6E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285B6E8: 4E800421  bctrl
	ctx.lr = 0x8285B6EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285B6EC => {
    //   block [0x8285B6EC..0x8285B6FC)
	// 8285B6EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8285B6F0: 4BFFFBD1  bl 0x8285b2c0
	ctx.lr = 0x8285B6F4;
	sub_8285B2C0(ctx, base);
	// 8285B6F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8285B6F8: 4844DD64  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285B700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285B700 size=108
    let mut pc: u32 = 0x8285B700;
    'dispatch: loop {
        match pc {
            0x8285B700 => {
    //   block [0x8285B700..0x8285B76C)
	// 8285B700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285B704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285B708: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285B70C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8285B710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285B714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285B718: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B71C: 4B9AC0D5  bl 0x822077f0
	ctx.lr = 0x8285B720;
	sub_822077F0(ctx, base);
	// 8285B720: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8285B724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285B728: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 8285B72C: FC010024  fdiv f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 8285B730: FFE00018  frsp f31, f0
	ctx.f[31].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8285B734: 4BA19FB5  bl 0x822756e8
	ctx.lr = 0x8285B738;
	sub_822756E8(ctx, base);
	// 8285B738: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285B73C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B740: C1A30020  lfs f13, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8285B744: EC2DF82A  fadds f1, f13, f31
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 8285B748: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285B74C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8285B750: 4E800421  bctrl
	ctx.lr = 0x8285B754;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285B754: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285B758: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285B75C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285B760: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285B764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285B768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285B770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285B770 size=116
    let mut pc: u32 = 0x8285B770;
    'dispatch: loop {
        match pc {
            0x8285B770 => {
    //   block [0x8285B770..0x8285B7CC)
	// 8285B770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285B774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285B778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285B77C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285B780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285B784: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285B788: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8285B78C: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 8285B790: 4B95C389  bl 0x821b7b18
	ctx.lr = 0x8285B794;
	sub_821B7B18(ctx, base);
	// 8285B794: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 8285B798: 4B95C381  bl 0x821b7b18
	ctx.lr = 0x8285B79C;
	sub_821B7B18(ctx, base);
	// 8285B79C: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 8285B7A0: 4B95C379  bl 0x821b7b18
	ctx.lr = 0x8285B7A4;
	sub_821B7B18(ctx, base);
	// 8285B7A4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8285B7A8: 4B95C371  bl 0x821b7b18
	ctx.lr = 0x8285B7AC;
	sub_821B7B18(ctx, base);
	// 8285B7AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285B7B0: 4BFF8D91  bl 0x82854540
	ctx.lr = 0x8285B7B4;
	sub_82854540(ctx, base);
	// 8285B7B4: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8285B7B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285B7BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B7C0: 419A000C  beq cr6, 0x8285b7cc
	if ctx.cr[6].eq {
	pc = 0x8285B7CC; continue 'dispatch;
	}
	// 8285B7C4: 4B9C0575  bl 0x8221bd38
	ctx.lr = 0x8285B7C8;
	sub_8221BD38(ctx, base);
	// 8285B7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8285B7CC; continue 'dispatch;
            }
            0x8285B7CC => {
    //   block [0x8285B7CC..0x8285B7E4)
	// 8285B7CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285B7D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285B7D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285B7D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285B7DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285B7E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285B7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285B7E8 size=424
    let mut pc: u32 = 0x8285B7E8;
    'dispatch: loop {
        match pc {
            0x8285B7E8 => {
    //   block [0x8285B7E8..0x8285B838)
	// 8285B7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285B7EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285B7F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285B7F4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B7F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8285B7FC: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285B800: 552827FE  rlwinm r8, r9, 4, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0FFFFFFFu64;
	// 8285B804: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8285B808: 419A00F8  beq cr6, 0x8285b900
	if ctx.cr[6].eq {
	pc = 0x8285B900; continue 'dispatch;
	}
	// 8285B80C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285B810: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285B814: 419A0024  beq cr6, 0x8285b838
	if ctx.cr[6].eq {
	pc = 0x8285B838; continue 'dispatch;
	}
	// 8285B818: 894A001C  lbz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 8285B81C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285B820: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285B824: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285B828: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B82C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8285B830: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285B834: 480000D0  b 0x8285b904
	pc = 0x8285B904; continue 'dispatch;
            }
            0x8285B838 => {
    //   block [0x8285B838..0x8285B858)
	// 8285B838: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285B83C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8285B840: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285B844: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8285B848: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285B84C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285B850: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285B854: 40810054  ble 0x8285b8a8
	if !ctx.cr[0].gt {
	pc = 0x8285B8A8; continue 'dispatch;
	}
	pc = 0x8285B858; continue 'dispatch;
            }
            0x8285B858 => {
    //   block [0x8285B858..0x8285B878)
	// 8285B858: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285B85C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285B860: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285B864: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B868: 2F07001C  cmpwi cr6, r7, 0x1c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 28, &mut ctx.xer);
	// 8285B86C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285B870: 41980008  blt cr6, 0x8285b878
	if ctx.cr[6].lt {
	pc = 0x8285B878; continue 'dispatch;
	}
	// 8285B874: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8285B878; continue 'dispatch;
            }
            0x8285B878 => {
    //   block [0x8285B878..0x8285B894)
	// 8285B878: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285B87C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285B880: 419A0014  beq cr6, 0x8285b894
	if ctx.cr[6].eq {
	pc = 0x8285B894; continue 'dispatch;
	}
	// 8285B884: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285B888: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285B88C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285B890: 4800000C  b 0x8285b89c
	pc = 0x8285B89C; continue 'dispatch;
            }
            0x8285B894 => {
    //   block [0x8285B894..0x8285B89C)
	// 8285B894: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285B898: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285B89C; continue 'dispatch;
            }
            0x8285B89C => {
    //   block [0x8285B89C..0x8285B8A8)
	// 8285B89C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285B8A0: 4199FFB8  bgt cr6, 0x8285b858
	if ctx.cr[6].gt {
	pc = 0x8285B858; continue 'dispatch;
	}
	// 8285B8A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285B8A8; continue 'dispatch;
            }
            0x8285B8A8 => {
    //   block [0x8285B8A8..0x8285B8C4)
	// 8285B8A8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285B8AC: 419A0040  beq cr6, 0x8285b8ec
	if ctx.cr[6].eq {
	pc = 0x8285B8EC; continue 'dispatch;
	}
	// 8285B8B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285B8B4: 2F0B001C  cmpwi cr6, r11, 0x1c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 28, &mut ctx.xer);
	// 8285B8B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285B8BC: 41990008  bgt cr6, 0x8285b8c4
	if ctx.cr[6].gt {
	pc = 0x8285B8C4; continue 'dispatch;
	}
	// 8285B8C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285B8C4; continue 'dispatch;
            }
            0x8285B8C4 => {
    //   block [0x8285B8C4..0x8285B8EC)
	// 8285B8C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285B8C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B8CC: 409A0020  bne cr6, 0x8285b8ec
	if !ctx.cr[6].eq {
	pc = 0x8285B8EC; continue 'dispatch;
	}
	// 8285B8D0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285B8D4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285B8D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285B8DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B8E0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8285B8E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285B8E8: 4800001C  b 0x8285b904
	pc = 0x8285B904; continue 'dispatch;
            }
            0x8285B8EC => {
    //   block [0x8285B8EC..0x8285B900)
	// 8285B8EC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285B8F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B8F4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8285B8F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285B8FC: 48000008  b 0x8285b904
	pc = 0x8285B904; continue 'dispatch;
            }
            0x8285B900 => {
    //   block [0x8285B900..0x8285B904)
	// 8285B900: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285B904; continue 'dispatch;
            }
            0x8285B904 => {
    //   block [0x8285B904..0x8285B924)
	// 8285B904: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285B908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285B90C: 419A0070  beq cr6, 0x8285b97c
	if ctx.cr[6].eq {
	pc = 0x8285B97C; continue 'dispatch;
	}
	// 8285B910: 816A0048  lwz r11, 0x48(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285B914: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8285B918: 409A005C  bne cr6, 0x8285b974
	if !ctx.cr[6].eq {
	pc = 0x8285B974; continue 'dispatch;
	}
	// 8285B91C: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 8285B920: 409A0028  bne cr6, 0x8285b948
	if !ctx.cr[6].eq {
	pc = 0x8285B948; continue 'dispatch;
	}
	pc = 0x8285B924; continue 'dispatch;
            }
            0x8285B924 => {
    //   block [0x8285B924..0x8285B948)
	// 8285B924: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285B928: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 8285B92C: 388BF378  addi r4, r11, -0xc88
	ctx.r[4].s64 = ctx.r[11].s64 + -3208;
	// 8285B930: 4BA19B09  bl 0x82275438
	ctx.lr = 0x8285B934;
	sub_82275438(ctx, base);
	// 8285B934: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8285B938: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8285B93C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285B940: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285B944: 4E800020  blr
	return;
            }
            0x8285B948 => {
    //   block [0x8285B948..0x8285B974)
	// 8285B948: 2F040002  cmpwi cr6, r4, 2
	ctx.cr[6].compare_i32(ctx.r[4].s32, 2, &mut ctx.xer);
	// 8285B94C: 409A0030  bne cr6, 0x8285b97c
	if !ctx.cr[6].eq {
	pc = 0x8285B97C; continue 'dispatch;
	}
	// 8285B950: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285B954: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 8285B958: 388BF38C  addi r4, r11, -0xc74
	ctx.r[4].s64 = ctx.r[11].s64 + -3188;
	// 8285B95C: 4BA19ADD  bl 0x82275438
	ctx.lr = 0x8285B960;
	sub_82275438(ctx, base);
	// 8285B960: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8285B964: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8285B968: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285B96C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285B970: 4E800020  blr
	return;
            }
            0x8285B974 => {
    //   block [0x8285B974..0x8285B97C)
	// 8285B974: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 8285B978: 419AFFAC  beq cr6, 0x8285b924
	if ctx.cr[6].eq {
	pc = 0x8285B924; continue 'dispatch;
	}
	pc = 0x8285B97C; continue 'dispatch;
            }
            0x8285B97C => {
    //   block [0x8285B97C..0x8285B990)
	// 8285B97C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8285B980: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8285B984: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285B988: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285B98C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285B990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285B990 size=308
    let mut pc: u32 = 0x8285B990;
    'dispatch: loop {
        match pc {
            0x8285B990 => {
    //   block [0x8285B990..0x8285B9D4)
	// 8285B990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285B994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285B998: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285B99C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B9A0: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285B9A4: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8285B9A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285B9AC: 419A0104  beq cr6, 0x8285bab0
	if ctx.cr[6].eq {
	pc = 0x8285BAB0; continue 'dispatch;
	}
	// 8285B9B0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285B9B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285B9B8: 419A001C  beq cr6, 0x8285b9d4
	if ctx.cr[6].eq {
	pc = 0x8285B9D4; continue 'dispatch;
	}
	// 8285B9BC: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 8285B9C0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285B9C4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285B9C8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285B9CC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285B9D0: 480000B4  b 0x8285ba84
	pc = 0x8285BA84; continue 'dispatch;
            }
            0x8285B9D4 => {
    //   block [0x8285B9D4..0x8285B9F4)
	// 8285B9D4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285B9D8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8285B9DC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285B9E0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8285B9E4: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285B9E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285B9EC: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285B9F0: 40810054  ble 0x8285ba44
	if !ctx.cr[0].gt {
	pc = 0x8285BA44; continue 'dispatch;
	}
	pc = 0x8285B9F4; continue 'dispatch;
            }
            0x8285B9F4 => {
    //   block [0x8285B9F4..0x8285BA14)
	// 8285B9F4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285B9F8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285B9FC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285BA00: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285BA04: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 8285BA08: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285BA0C: 41980008  blt cr6, 0x8285ba14
	if ctx.cr[6].lt {
	pc = 0x8285BA14; continue 'dispatch;
	}
	// 8285BA10: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8285BA14; continue 'dispatch;
            }
            0x8285BA14 => {
    //   block [0x8285BA14..0x8285BA30)
	// 8285BA14: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285BA18: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285BA1C: 419A0014  beq cr6, 0x8285ba30
	if ctx.cr[6].eq {
	pc = 0x8285BA30; continue 'dispatch;
	}
	// 8285BA20: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285BA24: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285BA28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285BA2C: 4800000C  b 0x8285ba38
	pc = 0x8285BA38; continue 'dispatch;
            }
            0x8285BA30 => {
    //   block [0x8285BA30..0x8285BA38)
	// 8285BA30: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285BA34: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285BA38; continue 'dispatch;
            }
            0x8285BA38 => {
    //   block [0x8285BA38..0x8285BA44)
	// 8285BA38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285BA3C: 4199FFB8  bgt cr6, 0x8285b9f4
	if ctx.cr[6].gt {
	pc = 0x8285B9F4; continue 'dispatch;
	}
	// 8285BA40: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285BA44; continue 'dispatch;
            }
            0x8285BA44 => {
    //   block [0x8285BA44..0x8285BA60)
	// 8285BA44: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285BA48: 419A0034  beq cr6, 0x8285ba7c
	if ctx.cr[6].eq {
	pc = 0x8285BA7C; continue 'dispatch;
	}
	// 8285BA4C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285BA50: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 8285BA54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285BA58: 41990008  bgt cr6, 0x8285ba60
	if ctx.cr[6].gt {
	pc = 0x8285BA60; continue 'dispatch;
	}
	// 8285BA5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285BA60; continue 'dispatch;
            }
            0x8285BA60 => {
    //   block [0x8285BA60..0x8285BA7C)
	// 8285BA60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285BA64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285BA68: 409A0014  bne cr6, 0x8285ba7c
	if !ctx.cr[6].eq {
	pc = 0x8285BA7C; continue 'dispatch;
	}
	// 8285BA6C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285BA70: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285BA74: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285BA78: 48000008  b 0x8285ba80
	pc = 0x8285BA80; continue 'dispatch;
            }
            0x8285BA7C => {
    //   block [0x8285BA7C..0x8285BA80)
	// 8285BA7C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x8285BA80; continue 'dispatch;
            }
            0x8285BA80 => {
    //   block [0x8285BA80..0x8285BA84)
	// 8285BA80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x8285BA84; continue 'dispatch;
            }
            0x8285BA84 => {
    //   block [0x8285BA84..0x8285BAB0)
	// 8285BA84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285BA88: 419A0028  beq cr6, 0x8285bab0
	if ctx.cr[6].eq {
	pc = 0x8285BAB0; continue 'dispatch;
	}
	// 8285BA8C: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285BA90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285BA94: 419A001C  beq cr6, 0x8285bab0
	if ctx.cr[6].eq {
	pc = 0x8285BAB0; continue 'dispatch;
	}
	// 8285BA98: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 8285BA9C: 4B98D0F5  bl 0x821e8b90
	ctx.lr = 0x8285BAA0;
	sub_821E8B90(ctx, base);
	// 8285BAA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8285BAA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285BAA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285BAAC: 4E800020  blr
	return;
            }
            0x8285BAB0 => {
    //   block [0x8285BAB0..0x8285BAC4)
	// 8285BAB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8285BAB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8285BAB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285BABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285BAC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285BAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285BAC8 size=1252
    let mut pc: u32 = 0x8285BAC8;
    'dispatch: loop {
        match pc {
            0x8285BAC8 => {
    //   block [0x8285BAC8..0x8285BB20)
	// 8285BAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285BACC: 4844D93D  bl 0x82ca9408
	ctx.lr = 0x8285BAD0;
	sub_82CA93D0(ctx, base);
	// 8285BAD0: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 8285BAD4: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8285BAD8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285BADC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8285BAE0: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285BAE4: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285BAE8: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 8285BAEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285BAF0: 419A00F8  beq cr6, 0x8285bbe8
	if ctx.cr[6].eq {
	pc = 0x8285BBE8; continue 'dispatch;
	}
	// 8285BAF4: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285BAF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285BAFC: 419A0024  beq cr6, 0x8285bb20
	if ctx.cr[6].eq {
	pc = 0x8285BB20; continue 'dispatch;
	}
	// 8285BB00: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8285BB04: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285BB08: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285BB0C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285BB10: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285BB14: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285BB18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285BB1C: 480000D4  b 0x8285bbf0
	pc = 0x8285BBF0; continue 'dispatch;
            }
            0x8285BB20 => {
    //   block [0x8285BB20..0x8285BB40)
	// 8285BB20: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285BB24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8285BB28: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285BB2C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8285BB30: 7D2A2850  subf r9, r10, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 8285BB34: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8285BB38: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285BB3C: 40810054  ble 0x8285bb90
	if !ctx.cr[0].gt {
	pc = 0x8285BB90; continue 'dispatch;
	}
	pc = 0x8285BB40; continue 'dispatch;
            }
            0x8285BB40 => {
    //   block [0x8285BB40..0x8285BB60)
	// 8285BB40: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285BB44: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285BB48: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285BB4C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285BB50: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 8285BB54: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285BB58: 41980008  blt cr6, 0x8285bb60
	if ctx.cr[6].lt {
	pc = 0x8285BB60; continue 'dispatch;
	}
	// 8285BB5C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8285BB60; continue 'dispatch;
            }
            0x8285BB60 => {
    //   block [0x8285BB60..0x8285BB7C)
	// 8285BB60: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285BB64: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285BB68: 419A0014  beq cr6, 0x8285bb7c
	if ctx.cr[6].eq {
	pc = 0x8285BB7C; continue 'dispatch;
	}
	// 8285BB6C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285BB70: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285BB74: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285BB78: 4800000C  b 0x8285bb84
	pc = 0x8285BB84; continue 'dispatch;
            }
            0x8285BB7C => {
    //   block [0x8285BB7C..0x8285BB84)
	// 8285BB7C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285BB80: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285BB84; continue 'dispatch;
            }
            0x8285BB84 => {
    //   block [0x8285BB84..0x8285BB90)
	// 8285BB84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285BB88: 4199FFB8  bgt cr6, 0x8285bb40
	if ctx.cr[6].gt {
	pc = 0x8285BB40; continue 'dispatch;
	}
	// 8285BB8C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8285BB90; continue 'dispatch;
            }
            0x8285BB90 => {
    //   block [0x8285BB90..0x8285BBAC)
	// 8285BB90: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8285BB94: 419A0040  beq cr6, 0x8285bbd4
	if ctx.cr[6].eq {
	pc = 0x8285BBD4; continue 'dispatch;
	}
	// 8285BB98: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285BB9C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 8285BBA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285BBA4: 41990008  bgt cr6, 0x8285bbac
	if ctx.cr[6].gt {
	pc = 0x8285BBAC; continue 'dispatch;
	}
	// 8285BBA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285BBAC; continue 'dispatch;
            }
            0x8285BBAC => {
    //   block [0x8285BBAC..0x8285BBD4)
	// 8285BBAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285BBB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285BBB4: 409A0020  bne cr6, 0x8285bbd4
	if !ctx.cr[6].eq {
	pc = 0x8285BBD4; continue 'dispatch;
	}
	// 8285BBB8: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8285BBBC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285BBC0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285BBC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285BBC8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285BBCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285BBD0: 48000020  b 0x8285bbf0
	pc = 0x8285BBF0; continue 'dispatch;
            }
            0x8285BBD4 => {
    //   block [0x8285BBD4..0x8285BBE8)
	// 8285BBD4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8285BBD8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285BBDC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285BBE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285BBE4: 4800000C  b 0x8285bbf0
	pc = 0x8285BBF0; continue 'dispatch;
            }
            0x8285BBE8 => {
    //   block [0x8285BBE8..0x8285BBF0)
	// 8285BBE8: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285BBEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285BBF0; continue 'dispatch;
            }
            0x8285BBF0 => {
    //   block [0x8285BBF0..0x8285BC38)
	// 8285BBF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285BBF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285BBF8: 419A039C  beq cr6, 0x8285bf94
	if ctx.cr[6].eq {
	pc = 0x8285BF94; continue 'dispatch;
	}
	// 8285BBFC: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285BC00: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 8285BC04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285BC08: 419A00F8  beq cr6, 0x8285bd00
	if ctx.cr[6].eq {
	pc = 0x8285BD00; continue 'dispatch;
	}
	// 8285BC0C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285BC10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285BC14: 419A0024  beq cr6, 0x8285bc38
	if ctx.cr[6].eq {
	pc = 0x8285BC38; continue 'dispatch;
	}
	// 8285BC18: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 8285BC1C: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285BC20: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285BC24: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285BC28: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285BC2C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285BC30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285BC34: 480000D4  b 0x8285bd08
	pc = 0x8285BD08; continue 'dispatch;
            }
            0x8285BC38 => {
    //   block [0x8285BC38..0x8285BC58)
	// 8285BC38: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285BC3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8285BC40: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285BC44: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8285BC48: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285BC4C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8285BC50: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285BC54: 40810054  ble 0x8285bca8
	if !ctx.cr[0].gt {
	pc = 0x8285BCA8; continue 'dispatch;
	}
	pc = 0x8285BC58; continue 'dispatch;
            }
            0x8285BC58 => {
    //   block [0x8285BC58..0x8285BC78)
	// 8285BC58: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285BC5C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285BC60: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285BC64: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285BC68: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8285BC6C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285BC70: 41980008  blt cr6, 0x8285bc78
	if ctx.cr[6].lt {
	pc = 0x8285BC78; continue 'dispatch;
	}
	// 8285BC74: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8285BC78; continue 'dispatch;
            }
            0x8285BC78 => {
    //   block [0x8285BC78..0x8285BC94)
	// 8285BC78: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285BC7C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285BC80: 419A0014  beq cr6, 0x8285bc94
	if ctx.cr[6].eq {
	pc = 0x8285BC94; continue 'dispatch;
	}
	// 8285BC84: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285BC88: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285BC8C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285BC90: 4800000C  b 0x8285bc9c
	pc = 0x8285BC9C; continue 'dispatch;
            }
            0x8285BC94 => {
    //   block [0x8285BC94..0x8285BC9C)
	// 8285BC94: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285BC98: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285BC9C; continue 'dispatch;
            }
            0x8285BC9C => {
    //   block [0x8285BC9C..0x8285BCA8)
	// 8285BC9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285BCA0: 4199FFB8  bgt cr6, 0x8285bc58
	if ctx.cr[6].gt {
	pc = 0x8285BC58; continue 'dispatch;
	}
	// 8285BCA4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8285BCA8; continue 'dispatch;
            }
            0x8285BCA8 => {
    //   block [0x8285BCA8..0x8285BCC4)
	// 8285BCA8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285BCAC: 419A0040  beq cr6, 0x8285bcec
	if ctx.cr[6].eq {
	pc = 0x8285BCEC; continue 'dispatch;
	}
	// 8285BCB0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285BCB4: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8285BCB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285BCBC: 41990008  bgt cr6, 0x8285bcc4
	if ctx.cr[6].gt {
	pc = 0x8285BCC4; continue 'dispatch;
	}
	// 8285BCC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285BCC4; continue 'dispatch;
            }
            0x8285BCC4 => {
    //   block [0x8285BCC4..0x8285BCEC)
	// 8285BCC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285BCC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285BCCC: 409A0020  bne cr6, 0x8285bcec
	if !ctx.cr[6].eq {
	pc = 0x8285BCEC; continue 'dispatch;
	}
	// 8285BCD0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8285BCD4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285BCD8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285BCDC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285BCE0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285BCE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285BCE8: 48000020  b 0x8285bd08
	pc = 0x8285BD08; continue 'dispatch;
            }
            0x8285BCEC => {
    //   block [0x8285BCEC..0x8285BD00)
	// 8285BCEC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285BCF0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285BCF4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285BCF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285BCFC: 4800000C  b 0x8285bd08
	pc = 0x8285BD08; continue 'dispatch;
            }
            0x8285BD00 => {
    //   block [0x8285BD00..0x8285BD08)
	// 8285BD00: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285BD04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285BD08; continue 'dispatch;
            }
            0x8285BD08 => {
    //   block [0x8285BD08..0x8285BD8C)
	// 8285BD08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285BD0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285BD10: 419A0284  beq cr6, 0x8285bf94
	if ctx.cr[6].eq {
	pc = 0x8285BF94; continue 'dispatch;
	}
	// 8285BD14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8285BD18: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285BD1C: 388B0EF4  addi r4, r11, 0xef4
	ctx.r[4].s64 = ctx.r[11].s64 + 3828;
	// 8285BD20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285BD24: 4B9D11AD  bl 0x8222ced0
	ctx.lr = 0x8285BD28;
	sub_8222CED0(ctx, base);
	// 8285BD28: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8285BD2C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285BD30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8285BD34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285BD38: 4BBC5A19  bl 0x82421750
	ctx.lr = 0x8285BD3C;
	sub_82421750(ctx, base);
	// 8285BD3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285BD40: 4B9B9099  bl 0x82214dd8
	ctx.lr = 0x8285BD44;
	sub_82214DD8(ctx, base);
	// 8285BD44: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8285BD48: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285BD4C: 390A92D4  addi r8, r10, -0x6d2c
	ctx.r[8].s64 = ctx.r[10].s64 + -27948;
	// 8285BD50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285BD54: C3CA92D4  lfs f30, -0x6d2c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8285BD58: C3E801B0  lfs f31, 0x1b0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(432 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8285BD5C: 419A0064  beq cr6, 0x8285bdc0
	if ctx.cr[6].eq {
	pc = 0x8285BDC0; continue 'dispatch;
	}
	// 8285BD60: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 8285BD64: 4B9C34F5  bl 0x8221f258
	ctx.lr = 0x8285BD68;
	sub_8221F258(ctx, base);
	// 8285BD68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285BD6C: 419A0020  beq cr6, 0x8285bd8c
	if ctx.cr[6].eq {
	pc = 0x8285BD8C; continue 'dispatch;
	}
	// 8285BD70: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8285BD74: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285BD78: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8285BD7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8285BD80: 4BA27EB1  bl 0x82283c30
	ctx.lr = 0x8285BD84;
	sub_82283C30(ctx, base);
	// 8285BD84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285BD88: 48000008  b 0x8285bd90
	pc = 0x8285BD90; continue 'dispatch;
            }
            0x8285BD8C => {
    //   block [0x8285BD8C..0x8285BD90)
	// 8285BD8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8285BD90; continue 'dispatch;
            }
            0x8285BD90 => {
    //   block [0x8285BD90..0x8285BDC0)
	// 8285BD90: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 8285BD94: 4BA172C5  bl 0x82273058
	ctx.lr = 0x8285BD98;
	sub_82273058(ctx, base);
	// 8285BD98: 839D0028  lwz r28, 0x28(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285BD9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8285BDA0: C03C0028  lfs f1, 0x28(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285BDA4: 4BA778A5  bl 0x822d3648
	ctx.lr = 0x8285BDA8;
	sub_822D3648(ctx, base);
	// 8285BDA8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285BDAC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8285BDB0: EC2107B2  fmuls f1, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8285BDB4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285BDB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285BDBC: 4E800421  bctrl
	ctx.lr = 0x8285BDC0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285BDC0 => {
    //   block [0x8285BDC0..0x8285BE28)
	// 8285BDC0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285BDC4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285BDC8: 388BF1E0  addi r4, r11, -0xe20
	ctx.r[4].s64 = ctx.r[11].s64 + -3616;
	// 8285BDCC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285BDD0: 4B9D1101  bl 0x8222ced0
	ctx.lr = 0x8285BDD4;
	sub_8222CED0(ctx, base);
	// 8285BDD4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8285BDD8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8285BDDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8285BDE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285BDE4: 4BBC596D  bl 0x82421750
	ctx.lr = 0x8285BDE8;
	sub_82421750(ctx, base);
	// 8285BDE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285BDEC: 4B9B8FED  bl 0x82214dd8
	ctx.lr = 0x8285BDF0;
	sub_82214DD8(ctx, base);
	// 8285BDF0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285BDF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285BDF8: 419A0064  beq cr6, 0x8285be5c
	if ctx.cr[6].eq {
	pc = 0x8285BE5C; continue 'dispatch;
	}
	// 8285BDFC: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 8285BE00: 4B9C3459  bl 0x8221f258
	ctx.lr = 0x8285BE04;
	sub_8221F258(ctx, base);
	// 8285BE04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285BE08: 419A0020  beq cr6, 0x8285be28
	if ctx.cr[6].eq {
	pc = 0x8285BE28; continue 'dispatch;
	}
	// 8285BE0C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8285BE10: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285BE14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285BE18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8285BE1C: 4BA27E15  bl 0x82283c30
	ctx.lr = 0x8285BE20;
	sub_82283C30(ctx, base);
	// 8285BE20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285BE24: 48000008  b 0x8285be2c
	pc = 0x8285BE2C; continue 'dispatch;
            }
            0x8285BE28 => {
    //   block [0x8285BE28..0x8285BE2C)
	// 8285BE28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8285BE2C; continue 'dispatch;
            }
            0x8285BE2C => {
    //   block [0x8285BE2C..0x8285BE5C)
	// 8285BE2C: 387D0030  addi r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 + 48;
	// 8285BE30: 4BA17229  bl 0x82273058
	ctx.lr = 0x8285BE34;
	sub_82273058(ctx, base);
	// 8285BE34: 839D0030  lwz r28, 0x30(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8285BE38: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8285BE3C: C03C0028  lfs f1, 0x28(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285BE40: 4BA77809  bl 0x822d3648
	ctx.lr = 0x8285BE44;
	sub_822D3648(ctx, base);
	// 8285BE44: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285BE48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8285BE4C: EC2107B2  fmuls f1, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8285BE50: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285BE54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285BE58: 4E800421  bctrl
	ctx.lr = 0x8285BE5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285BE5C => {
    //   block [0x8285BE5C..0x8285BEC4)
	// 8285BE5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8285BE60: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285BE64: 388B0E20  addi r4, r11, 0xe20
	ctx.r[4].s64 = ctx.r[11].s64 + 3616;
	// 8285BE68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285BE6C: 4B9D1065  bl 0x8222ced0
	ctx.lr = 0x8285BE70;
	sub_8222CED0(ctx, base);
	// 8285BE70: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8285BE74: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8285BE78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8285BE7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285BE80: 4BBC58D1  bl 0x82421750
	ctx.lr = 0x8285BE84;
	sub_82421750(ctx, base);
	// 8285BE84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285BE88: 4B9B8F51  bl 0x82214dd8
	ctx.lr = 0x8285BE8C;
	sub_82214DD8(ctx, base);
	// 8285BE8C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285BE90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285BE94: 419A0064  beq cr6, 0x8285bef8
	if ctx.cr[6].eq {
	pc = 0x8285BEF8; continue 'dispatch;
	}
	// 8285BE98: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 8285BE9C: 4B9C33BD  bl 0x8221f258
	ctx.lr = 0x8285BEA0;
	sub_8221F258(ctx, base);
	// 8285BEA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285BEA4: 419A0020  beq cr6, 0x8285bec4
	if ctx.cr[6].eq {
	pc = 0x8285BEC4; continue 'dispatch;
	}
	// 8285BEA8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8285BEAC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285BEB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285BEB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8285BEB8: 4BA27D79  bl 0x82283c30
	ctx.lr = 0x8285BEBC;
	sub_82283C30(ctx, base);
	// 8285BEBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285BEC0: 48000008  b 0x8285bec8
	pc = 0x8285BEC8; continue 'dispatch;
            }
            0x8285BEC4 => {
    //   block [0x8285BEC4..0x8285BEC8)
	// 8285BEC4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8285BEC8; continue 'dispatch;
            }
            0x8285BEC8 => {
    //   block [0x8285BEC8..0x8285BEF8)
	// 8285BEC8: 387D0038  addi r3, r29, 0x38
	ctx.r[3].s64 = ctx.r[29].s64 + 56;
	// 8285BECC: 4BA1718D  bl 0x82273058
	ctx.lr = 0x8285BED0;
	sub_82273058(ctx, base);
	// 8285BED0: 839D0038  lwz r28, 0x38(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 8285BED4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8285BED8: C03C0028  lfs f1, 0x28(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285BEDC: 4BA7776D  bl 0x822d3648
	ctx.lr = 0x8285BEE0;
	sub_822D3648(ctx, base);
	// 8285BEE0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285BEE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8285BEE8: EC2107B2  fmuls f1, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8285BEEC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285BEF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285BEF4: 4E800421  bctrl
	ctx.lr = 0x8285BEF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285BEF8 => {
    //   block [0x8285BEF8..0x8285BF60)
	// 8285BEF8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285BEFC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285BF00: 388BF3A4  addi r4, r11, -0xc5c
	ctx.r[4].s64 = ctx.r[11].s64 + -3164;
	// 8285BF04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285BF08: 4B9D0FC9  bl 0x8222ced0
	ctx.lr = 0x8285BF0C;
	sub_8222CED0(ctx, base);
	// 8285BF0C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8285BF10: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8285BF14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8285BF18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285BF1C: 4BBC5835  bl 0x82421750
	ctx.lr = 0x8285BF20;
	sub_82421750(ctx, base);
	// 8285BF20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285BF24: 4B9B8EB5  bl 0x82214dd8
	ctx.lr = 0x8285BF28;
	sub_82214DD8(ctx, base);
	// 8285BF28: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285BF2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285BF30: 419A0064  beq cr6, 0x8285bf94
	if ctx.cr[6].eq {
	pc = 0x8285BF94; continue 'dispatch;
	}
	// 8285BF34: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 8285BF38: 4B9C3321  bl 0x8221f258
	ctx.lr = 0x8285BF3C;
	sub_8221F258(ctx, base);
	// 8285BF3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285BF40: 419A0020  beq cr6, 0x8285bf60
	if ctx.cr[6].eq {
	pc = 0x8285BF60; continue 'dispatch;
	}
	// 8285BF44: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8285BF48: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285BF4C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285BF50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8285BF54: 4BA27CDD  bl 0x82283c30
	ctx.lr = 0x8285BF58;
	sub_82283C30(ctx, base);
	// 8285BF58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285BF5C: 48000008  b 0x8285bf64
	pc = 0x8285BF64; continue 'dispatch;
            }
            0x8285BF60 => {
    //   block [0x8285BF60..0x8285BF64)
	// 8285BF60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8285BF64; continue 'dispatch;
            }
            0x8285BF64 => {
    //   block [0x8285BF64..0x8285BF94)
	// 8285BF64: 387D0040  addi r3, r29, 0x40
	ctx.r[3].s64 = ctx.r[29].s64 + 64;
	// 8285BF68: 4BA170F1  bl 0x82273058
	ctx.lr = 0x8285BF6C;
	sub_82273058(ctx, base);
	// 8285BF6C: 83FD0040  lwz r31, 0x40(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 8285BF70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285BF74: C03F0028  lfs f1, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285BF78: 4BA776D1  bl 0x822d3648
	ctx.lr = 0x8285BF7C;
	sub_822D3648(ctx, base);
	// 8285BF7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285BF80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285BF84: EC2107B2  fmuls f1, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8285BF88: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285BF8C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285BF90: 4E800421  bctrl
	ctx.lr = 0x8285BF94;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285BF94 => {
    //   block [0x8285BF94..0x8285BFAC)
	// 8285BF94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8285BF98: 4BFFF329  bl 0x8285b2c0
	ctx.lr = 0x8285BF9C;
	sub_8285B2C0(ctx, base);
	// 8285BF9C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8285BFA0: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8285BFA4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8285BFA8: 4844D4B0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285BFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285BFB0 size=216
    let mut pc: u32 = 0x8285BFB0;
    'dispatch: loop {
        match pc {
            0x8285BFB0 => {
    //   block [0x8285BFB0..0x8285BFDC)
	// 8285BFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285BFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285BFB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285BFBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285BFC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285BFC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285BFC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8285BFCC: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8285BFD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285BFD4: 419A0044  beq cr6, 0x8285c018
	if ctx.cr[6].eq {
	pc = 0x8285C018; continue 'dispatch;
	}
	// 8285BFD8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8285BFDC; continue 'dispatch;
            }
            0x8285BFDC => {
    //   block [0x8285BFDC..0x8285C010)
	// 8285BFDC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8285BFE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285BFE4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8285BFE8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285BFEC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285BFF0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285BFF4: 4082FFE8  bne 0x8285bfdc
	if !ctx.cr[0].eq {
	pc = 0x8285BFDC; continue 'dispatch;
	}
	// 8285BFF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285BFFC: 409A0014  bne cr6, 0x8285c010
	if !ctx.cr[6].eq {
	pc = 0x8285C010; continue 'dispatch;
	}
	// 8285C000: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285C004: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285C008: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285C00C: 4E800421  bctrl
	ctx.lr = 0x8285C010;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285C010 => {
    //   block [0x8285C010..0x8285C018)
	// 8285C010: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8285C014: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	pc = 0x8285C018; continue 'dispatch;
            }
            0x8285C018 => {
    //   block [0x8285C018..0x8285C070)
	// 8285C018: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 8285C01C: 4B95BAFD  bl 0x821b7b18
	ctx.lr = 0x8285C020;
	sub_821B7B18(ctx, base);
	// 8285C020: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 8285C024: 4B95BAF5  bl 0x821b7b18
	ctx.lr = 0x8285C028;
	sub_821B7B18(ctx, base);
	// 8285C028: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 8285C02C: 4B95BAED  bl 0x821b7b18
	ctx.lr = 0x8285C030;
	sub_821B7B18(ctx, base);
	// 8285C030: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 8285C034: 4B95BAE5  bl 0x821b7b18
	ctx.lr = 0x8285C038;
	sub_821B7B18(ctx, base);
	// 8285C038: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 8285C03C: 4B95BADD  bl 0x821b7b18
	ctx.lr = 0x8285C040;
	sub_821B7B18(ctx, base);
	// 8285C040: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 8285C044: 4B95BAD5  bl 0x821b7b18
	ctx.lr = 0x8285C048;
	sub_821B7B18(ctx, base);
	// 8285C048: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 8285C04C: 4B95BACD  bl 0x821b7b18
	ctx.lr = 0x8285C050;
	sub_821B7B18(ctx, base);
	// 8285C050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285C054: 4BFF84ED  bl 0x82854540
	ctx.lr = 0x8285C058;
	sub_82854540(ctx, base);
	// 8285C058: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8285C05C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285C060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285C064: 419A000C  beq cr6, 0x8285c070
	if ctx.cr[6].eq {
	pc = 0x8285C070; continue 'dispatch;
	}
	// 8285C068: 4B9BFCD1  bl 0x8221bd38
	ctx.lr = 0x8285C06C;
	sub_8221BD38(ctx, base);
	// 8285C06C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8285C070; continue 'dispatch;
            }
            0x8285C070 => {
    //   block [0x8285C070..0x8285C088)
	// 8285C070: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285C074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285C078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285C07C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285C080: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285C084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285C088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8285C088 size=1568
    let mut pc: u32 = 0x8285C088;
    'dispatch: loop {
        match pc {
            0x8285C088 => {
    //   block [0x8285C088..0x8285C6A8)
	// 8285C088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285C08C: 4844D381  bl 0x82ca940c
	ctx.lr = 0x8285C090;
	sub_82CA93D0(ctx, base);
	// 8285C090: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8285C094: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285C6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285C6A8 size=2968
    let mut pc: u32 = 0x8285C6A8;
    'dispatch: loop {
        match pc {
            0x8285C6A8 => {
    //   block [0x8285C6A8..0x8285C700)
	// 8285C6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285C6AC: 4844CD51  bl 0x82ca93fc
	ctx.lr = 0x8285C6B0;
	sub_82CA93D0(ctx, base);
	// 8285C6B0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 8285C6B4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8285C6B8: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285C6BC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8285C6C0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285C6C4: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 8285C6C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285C6CC: 4E800421  bctrl
	ctx.lr = 0x8285C6D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285C6D0: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285C6D4: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8285C6D8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8285C6DC: 8109006C  lwz r8, 0x6c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(108 as u32) ) } as u64;
	// 8285C6E0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8285C6E4: 4E800421  bctrl
	ctx.lr = 0x8285C6E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285C6E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285C6EC: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285C6F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285C6F4: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 8285C6F8: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 8285C6FC: 419A0020  beq cr6, 0x8285c71c
	if ctx.cr[6].eq {
	pc = 0x8285C71C; continue 'dispatch;
	}
            }
            0x8285C700 => {
    //   block [0x8285C700..0x8285C71C)
	// 8285C700: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285C704: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285C708: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285C70C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285C710: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285C714: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285C718: 4082FFE8  bne 0x8285c700
	if !ctx.cr[0].eq {
	pc = 0x8285C700; continue 'dispatch;
	}
	pc = 0x8285C71C; continue 'dispatch;
            }
            0x8285C71C => {
    //   block [0x8285C71C..0x8285C780)
	// 8285C71C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8285C720: 4B95B3F9  bl 0x821b7b18
	ctx.lr = 0x8285C724;
	sub_821B7B18(ctx, base);
	// 8285C724: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8285C728: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8285C72C: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 8285C730: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8285C734: 3BEBB730  addi r31, r11, -0x48d0
	ctx.r[31].s64 = ctx.r[11].s64 + -18640;
	// 8285C738: C3CBB730  lfs f30, -0x48d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18640 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8285C73C: 419A05C0  beq cr6, 0x8285ccfc
	if ctx.cr[6].eq {
	pc = 0x8285CCFC; continue 'dispatch;
	}
	// 8285C740: 80BA0004  lwz r5, 4(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285C744: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285C748: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 8285C74C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285C750: 419A00F4  beq cr6, 0x8285c844
	if ctx.cr[6].eq {
	pc = 0x8285C844; continue 'dispatch;
	}
	// 8285C754: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285C758: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285C75C: 419A0024  beq cr6, 0x8285c780
	if ctx.cr[6].eq {
	pc = 0x8285C780; continue 'dispatch;
	}
	// 8285C760: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 8285C764: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285C768: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285C76C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285C770: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285C774: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8285C778: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285C77C: 480000D0  b 0x8285c84c
	pc = 0x8285C84C; continue 'dispatch;
            }
            0x8285C780 => {
    //   block [0x8285C780..0x8285C79C)
	// 8285C780: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285C784: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285C788: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 8285C78C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285C790: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285C794: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285C798: 40810054  ble 0x8285c7ec
	if !ctx.cr[0].gt {
	pc = 0x8285C7EC; continue 'dispatch;
	}
	pc = 0x8285C79C; continue 'dispatch;
            }
            0x8285C79C => {
    //   block [0x8285C79C..0x8285C7BC)
	// 8285C79C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285C7A0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285C7A4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285C7A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285C7AC: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8285C7B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285C7B4: 41980008  blt cr6, 0x8285c7bc
	if ctx.cr[6].lt {
	pc = 0x8285C7BC; continue 'dispatch;
	}
	// 8285C7B8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x8285C7BC; continue 'dispatch;
            }
            0x8285C7BC => {
    //   block [0x8285C7BC..0x8285C7D8)
	// 8285C7BC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285C7C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285C7C4: 419A0014  beq cr6, 0x8285c7d8
	if ctx.cr[6].eq {
	pc = 0x8285C7D8; continue 'dispatch;
	}
	// 8285C7C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285C7CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285C7D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285C7D4: 4800000C  b 0x8285c7e0
	pc = 0x8285C7E0; continue 'dispatch;
            }
            0x8285C7D8 => {
    //   block [0x8285C7D8..0x8285C7E0)
	// 8285C7D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285C7DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285C7E0; continue 'dispatch;
            }
            0x8285C7E0 => {
    //   block [0x8285C7E0..0x8285C7EC)
	// 8285C7E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285C7E4: 4199FFB8  bgt cr6, 0x8285c79c
	if ctx.cr[6].gt {
	pc = 0x8285C79C; continue 'dispatch;
	}
	// 8285C7E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285C7EC; continue 'dispatch;
            }
            0x8285C7EC => {
    //   block [0x8285C7EC..0x8285C808)
	// 8285C7EC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285C7F0: 419A0040  beq cr6, 0x8285c830
	if ctx.cr[6].eq {
	pc = 0x8285C830; continue 'dispatch;
	}
	// 8285C7F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285C7F8: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8285C7FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285C800: 41990008  bgt cr6, 0x8285c808
	if ctx.cr[6].gt {
	pc = 0x8285C808; continue 'dispatch;
	}
	// 8285C804: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8285C808; continue 'dispatch;
            }
            0x8285C808 => {
    //   block [0x8285C808..0x8285C830)
	// 8285C808: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285C80C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285C810: 409A0020  bne cr6, 0x8285c830
	if !ctx.cr[6].eq {
	pc = 0x8285C830; continue 'dispatch;
	}
	// 8285C814: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285C818: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8285C81C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8285C820: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285C824: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8285C828: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285C82C: 48000020  b 0x8285c84c
	pc = 0x8285C84C; continue 'dispatch;
            }
            0x8285C830 => {
    //   block [0x8285C830..0x8285C844)
	// 8285C830: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285C834: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285C838: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8285C83C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285C840: 4800000C  b 0x8285c84c
	pc = 0x8285C84C; continue 'dispatch;
            }
            0x8285C844 => {
    //   block [0x8285C844..0x8285C84C)
	// 8285C844: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285C848: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8285C84C; continue 'dispatch;
            }
            0x8285C84C => {
    //   block [0x8285C84C..0x8285C894)
	// 8285C84C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285C850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285C854: 419A049C  beq cr6, 0x8285ccf0
	if ctx.cr[6].eq {
	pc = 0x8285CCF0; continue 'dispatch;
	}
	// 8285C858: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285C85C: 556AD7FE  rlwinm r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 8285C860: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285C864: 419A00F4  beq cr6, 0x8285c958
	if ctx.cr[6].eq {
	pc = 0x8285C958; continue 'dispatch;
	}
	// 8285C868: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285C86C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285C870: 419A0024  beq cr6, 0x8285c894
	if ctx.cr[6].eq {
	pc = 0x8285C894; continue 'dispatch;
	}
	// 8285C874: 894B0006  lbz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 8285C878: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285C87C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285C880: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285C884: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285C888: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 8285C88C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285C890: 480000D0  b 0x8285c960
	pc = 0x8285C960; continue 'dispatch;
            }
            0x8285C894 => {
    //   block [0x8285C894..0x8285C8B0)
	// 8285C894: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285C898: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285C89C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 8285C8A0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285C8A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285C8A8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285C8AC: 40810054  ble 0x8285c900
	if !ctx.cr[0].gt {
	pc = 0x8285C900; continue 'dispatch;
	}
	pc = 0x8285C8B0; continue 'dispatch;
            }
            0x8285C8B0 => {
    //   block [0x8285C8B0..0x8285C8D0)
	// 8285C8B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285C8B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285C8B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285C8BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285C8C0: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 8285C8C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285C8C8: 41980008  blt cr6, 0x8285c8d0
	if ctx.cr[6].lt {
	pc = 0x8285C8D0; continue 'dispatch;
	}
	// 8285C8CC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x8285C8D0; continue 'dispatch;
            }
            0x8285C8D0 => {
    //   block [0x8285C8D0..0x8285C8EC)
	// 8285C8D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285C8D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285C8D8: 419A0014  beq cr6, 0x8285c8ec
	if ctx.cr[6].eq {
	pc = 0x8285C8EC; continue 'dispatch;
	}
	// 8285C8DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285C8E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285C8E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285C8E8: 4800000C  b 0x8285c8f4
	pc = 0x8285C8F4; continue 'dispatch;
            }
            0x8285C8EC => {
    //   block [0x8285C8EC..0x8285C8F4)
	// 8285C8EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285C8F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285C8F4; continue 'dispatch;
            }
            0x8285C8F4 => {
    //   block [0x8285C8F4..0x8285C900)
	// 8285C8F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285C8F8: 4199FFB8  bgt cr6, 0x8285c8b0
	if ctx.cr[6].gt {
	pc = 0x8285C8B0; continue 'dispatch;
	}
	// 8285C8FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285C900; continue 'dispatch;
            }
            0x8285C900 => {
    //   block [0x8285C900..0x8285C91C)
	// 8285C900: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285C904: 419A0040  beq cr6, 0x8285c944
	if ctx.cr[6].eq {
	pc = 0x8285C944; continue 'dispatch;
	}
	// 8285C908: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285C90C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 8285C910: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285C914: 41990008  bgt cr6, 0x8285c91c
	if ctx.cr[6].gt {
	pc = 0x8285C91C; continue 'dispatch;
	}
	// 8285C918: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8285C91C; continue 'dispatch;
            }
            0x8285C91C => {
    //   block [0x8285C91C..0x8285C944)
	// 8285C91C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285C920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285C924: 409A0020  bne cr6, 0x8285c944
	if !ctx.cr[6].eq {
	pc = 0x8285C944; continue 'dispatch;
	}
	// 8285C928: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285C92C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8285C930: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8285C934: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285C938: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 8285C93C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285C940: 48000020  b 0x8285c960
	pc = 0x8285C960; continue 'dispatch;
            }
            0x8285C944 => {
    //   block [0x8285C944..0x8285C958)
	// 8285C944: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285C948: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285C94C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 8285C950: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285C954: 4800000C  b 0x8285c960
	pc = 0x8285C960; continue 'dispatch;
            }
            0x8285C958 => {
    //   block [0x8285C958..0x8285C960)
	// 8285C958: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285C95C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8285C960; continue 'dispatch;
            }
            0x8285C960 => {
    //   block [0x8285C960..0x8285C9DC)
	// 8285C960: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285C964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285C968: 419A0388  beq cr6, 0x8285ccf0
	if ctx.cr[6].eq {
	pc = 0x8285CCF0; continue 'dispatch;
	}
	// 8285C96C: 89650024  lbz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285C970: 80860094  lwz r4, 0x94(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(148 as u32) ) } as u64;
	// 8285C974: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8285C978: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 8285C97C: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 8285C980: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 8285C984: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285C988: 93610080  stw r27, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 8285C98C: 93210084  stw r25, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[25].u32 ) };
	// 8285C990: 9361008C  stw r27, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[27].u32 ) };
	// 8285C994: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	// 8285C998: 93610094  stw r27, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[27].u32 ) };
	// 8285C99C: 9B610099  stb r27, 0x99(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(153 as u32), ctx.r[27].u8 ) };
	// 8285C9A0: 936100A0  stw r27, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[27].u32 ) };
	// 8285C9A4: 936100A4  stw r27, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[27].u32 ) };
	// 8285C9A8: 936100A8  stw r27, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[27].u32 ) };
	// 8285C9AC: 936100B0  stw r27, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u32 ) };
	// 8285C9B0: 936100B4  stw r27, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[27].u32 ) };
	// 8285C9B4: 936100B8  stw r27, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[27].u32 ) };
	// 8285C9B8: 419A0078  beq cr6, 0x8285ca30
	if ctx.cr[6].eq {
	pc = 0x8285CA30; continue 'dispatch;
	}
	// 8285C9BC: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285C9C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285C9C4: 409A0064  bne cr6, 0x8285ca28
	if !ctx.cr[6].eq {
	pc = 0x8285CA28; continue 'dispatch;
	}
	// 8285C9C8: 8165004C  lwz r11, 0x4c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285C9CC: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285C9D0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8285C9D4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285C9D8: 40810050  ble 0x8285ca28
	if !ctx.cr[0].gt {
	pc = 0x8285CA28; continue 'dispatch;
	}
	pc = 0x8285C9DC; continue 'dispatch;
            }
            0x8285C9DC => {
    //   block [0x8285C9DC..0x8285C9FC)
	// 8285C9DC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285C9E0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285C9E4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285C9E8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285C9EC: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 8285C9F0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285C9F4: 41980008  blt cr6, 0x8285c9fc
	if ctx.cr[6].lt {
	pc = 0x8285C9FC; continue 'dispatch;
	}
	// 8285C9F8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x8285C9FC; continue 'dispatch;
            }
            0x8285C9FC => {
    //   block [0x8285C9FC..0x8285CA18)
	// 8285C9FC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285CA00: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285CA04: 419A0014  beq cr6, 0x8285ca18
	if ctx.cr[6].eq {
	pc = 0x8285CA18; continue 'dispatch;
	}
	// 8285CA08: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285CA0C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285CA10: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285CA14: 4800000C  b 0x8285ca20
	pc = 0x8285CA20; continue 'dispatch;
            }
            0x8285CA18 => {
    //   block [0x8285CA18..0x8285CA20)
	// 8285CA18: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285CA1C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285CA20; continue 'dispatch;
            }
            0x8285CA20 => {
    //   block [0x8285CA20..0x8285CA28)
	// 8285CA20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285CA24: 4199FFB8  bgt cr6, 0x8285c9dc
	if ctx.cr[6].gt {
	pc = 0x8285C9DC; continue 'dispatch;
	}
	pc = 0x8285CA28; continue 'dispatch;
            }
            0x8285CA28 => {
    //   block [0x8285CA28..0x8285CA30)
	// 8285CA28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285CA2C: 48000008  b 0x8285ca34
	pc = 0x8285CA34; continue 'dispatch;
            }
            0x8285CA30 => {
    //   block [0x8285CA30..0x8285CA34)
	// 8285CA30: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8285CA34; continue 'dispatch;
            }
            0x8285CA34 => {
    //   block [0x8285CA34..0x8285CA7C)
	// 8285CA34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285CA38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285CA3C: 419A00E4  beq cr6, 0x8285cb20
	if ctx.cr[6].eq {
	pc = 0x8285CB20; continue 'dispatch;
	}
	// 8285CA40: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8285CA44: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8285CA48: 483216B1  bl 0x82b7e0f8
	ctx.lr = 0x8285CA4C;
	sub_82B7E0F8(ctx, base);
	// 8285CA4C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8285CA50: 4BFFF639  bl 0x8285c088
	ctx.lr = 0x8285CA54;
	sub_8285C088(ctx, base);
	// 8285CA54: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285CA58: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285CA5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285CA60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285CA64: 419A0018  beq cr6, 0x8285ca7c
	if ctx.cr[6].eq {
	pc = 0x8285CA7C; continue 'dispatch;
	}
	// 8285CA68: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8285CA6C: 388B0754  addi r4, r11, 0x754
	ctx.r[4].s64 = ctx.r[11].s64 + 1876;
	// 8285CA70: 4B9D0461  bl 0x8222ced0
	ctx.lr = 0x8285CA74;
	sub_8222CED0(ctx, base);
	// 8285CA74: C03FDD60  lfs f1, -0x22a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285CA78: 4800007C  b 0x8285caf4
	pc = 0x8285CAF4; continue 'dispatch;
            }
            0x8285CA7C => {
    //   block [0x8285CA7C..0x8285CADC)
	// 8285CA7C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285CA80: 388BDBD8  addi r4, r11, -0x2428
	ctx.r[4].s64 = ctx.r[11].s64 + -9256;
	// 8285CA84: 4B9D044D  bl 0x8222ced0
	ctx.lr = 0x8285CA88;
	sub_8222CED0(ctx, base);
	// 8285CA88: C3FFDD60  lfs f31, -0x22a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8285CA8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8285CA90: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285CA94: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8285CA98: 48321961  bl 0x82b7e3f8
	ctx.lr = 0x8285CA9C;
	sub_82B7E3F8(ctx, base);
	// 8285CA9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285CAA0: 4B9B8339  bl 0x82214dd8
	ctx.lr = 0x8285CAA4;
	sub_82214DD8(ctx, base);
	// 8285CAA4: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285CAA8: 4801BE21  bl 0x828788c8
	ctx.lr = 0x8285CAAC;
	sub_828788C8(ctx, base);
	// 8285CAAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285CAB0: 419A002C  beq cr6, 0x8285cadc
	if ctx.cr[6].eq {
	pc = 0x8285CADC; continue 'dispatch;
	}
	// 8285CAB4: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8285CAB8: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 8285CABC: 409A0020  bne cr6, 0x8285cadc
	if !ctx.cr[6].eq {
	pc = 0x8285CADC; continue 'dispatch;
	}
	// 8285CAC0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285CAC4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285CAC8: 388BF364  addi r4, r11, -0xc9c
	ctx.r[4].s64 = ctx.r[11].s64 + -3228;
	// 8285CACC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285CAD0: 4B9D0401  bl 0x8222ced0
	ctx.lr = 0x8285CAD4;
	sub_8222CED0(ctx, base);
	// 8285CAD4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8285CAD8: 4800001C  b 0x8285caf4
	pc = 0x8285CAF4; continue 'dispatch;
            }
            0x8285CADC => {
    //   block [0x8285CADC..0x8285CAF4)
	// 8285CADC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285CAE0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285CAE4: 388BF364  addi r4, r11, -0xc9c
	ctx.r[4].s64 = ctx.r[11].s64 + -3228;
	// 8285CAE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285CAEC: 4B9D03E5  bl 0x8222ced0
	ctx.lr = 0x8285CAF0;
	sub_8222CED0(ctx, base);
	// 8285CAF0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x8285CAF4; continue 'dispatch;
            }
            0x8285CAF4 => {
    //   block [0x8285CAF4..0x8285CB20)
	// 8285CAF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8285CAF8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8285CAFC: 483218FD  bl 0x82b7e3f8
	ctx.lr = 0x8285CB00;
	sub_82B7E3F8(ctx, base);
	// 8285CB00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285CB04: 4B9B82D5  bl 0x82214dd8
	ctx.lr = 0x8285CB08;
	sub_82214DD8(ctx, base);
	// 8285CB08: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8285CB0C: 388100AC  addi r4, r1, 0xac
	ctx.r[4].s64 = ctx.r[1].s64 + 172;
	// 8285CB10: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 8285CB14: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8285CB18: 4BF05BA1  bl 0x827626b8
	ctx.lr = 0x8285CB1C;
	sub_827626B8(ctx, base);
	// 8285CB1C: 48000010  b 0x8285cb2c
	pc = 0x8285CB2C; continue 'dispatch;
            }
            0x8285CB20 => {
    //   block [0x8285CB20..0x8285CB2C)
	// 8285CB20: 38A600CC  addi r5, r6, 0xcc
	ctx.r[5].s64 = ctx.r[6].s64 + 204;
	// 8285CB24: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8285CB28: 4BF05119  bl 0x82761c40
	ctx.lr = 0x8285CB2C;
	sub_82761C40(ctx, base);
	pc = 0x8285CB2C; continue 'dispatch;
            }
            0x8285CB2C => {
    //   block [0x8285CB2C..0x8285CB78)
	// 8285CB2C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8285CB30: 4BA3E509  bl 0x8229b038
	ctx.lr = 0x8285CB34;
	sub_8229B038(ctx, base);
	// 8285CB34: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CB38: 987A0024  stb r3, 0x24(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(36 as u32), ctx.r[3].u8 ) };
	// 8285CB3C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8285CB40: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 8285CB44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285CB48: 4E800421  bctrl
	ctx.lr = 0x8285CB4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285CB4C: 987A0025  stb r3, 0x25(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(37 as u32), ctx.r[3].u8 ) };
	// 8285CB50: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8285CB54: 4B9C2705  bl 0x8221f258
	ctx.lr = 0x8285CB58;
	sub_8221F258(ctx, base);
	// 8285CB58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285CB5C: 419A001C  beq cr6, 0x8285cb78
	if ctx.cr[6].eq {
	pc = 0x8285CB78; continue 'dispatch;
	}
	// 8285CB60: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8285CB64: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8285CB68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8285CB6C: 4BF0526D  bl 0x82761dd8
	ctx.lr = 0x8285CB70;
	sub_82761DD8(ctx, base);
	// 8285CB70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285CB74: 48000008  b 0x8285cb7c
	pc = 0x8285CB7C; continue 'dispatch;
            }
            0x8285CB78 => {
    //   block [0x8285CB78..0x8285CB7C)
	// 8285CB78: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	pc = 0x8285CB7C; continue 'dispatch;
            }
            0x8285CB7C => {
    //   block [0x8285CB7C..0x8285CBA8)
	// 8285CB7C: 3BBA0018  addi r29, r26, 0x18
	ctx.r[29].s64 = ctx.r[26].s64 + 24;
	// 8285CB80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8285CB84: 4BA164D5  bl 0x82273058
	ctx.lr = 0x8285CB88;
	sub_82273058(ctx, base);
	// 8285CB88: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8285CB8C: 4B9C26CD  bl 0x8221f258
	ctx.lr = 0x8285CB90;
	sub_8221F258(ctx, base);
	// 8285CB90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285CB94: 419A0014  beq cr6, 0x8285cba8
	if ctx.cr[6].eq {
	pc = 0x8285CBA8; continue 'dispatch;
	}
	// 8285CB98: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8285CB9C: 4BA2EFA5  bl 0x8228bb40
	ctx.lr = 0x8285CBA0;
	sub_8228BB40(ctx, base);
	// 8285CBA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8285CBA4: 48000008  b 0x8285cbac
	pc = 0x8285CBAC; continue 'dispatch;
            }
            0x8285CBA8 => {
    //   block [0x8285CBA8..0x8285CBAC)
	// 8285CBA8: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x8285CBAC; continue 'dispatch;
            }
            0x8285CBAC => {
    //   block [0x8285CBAC..0x8285CBCC)
	// 8285CBAC: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8285CBB0: 4B9C26A9  bl 0x8221f258
	ctx.lr = 0x8285CBB4;
	sub_8221F258(ctx, base);
	// 8285CBB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285CBB8: 419A0014  beq cr6, 0x8285cbcc
	if ctx.cr[6].eq {
	pc = 0x8285CBCC; continue 'dispatch;
	}
	// 8285CBBC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8285CBC0: 4B9CCB79  bl 0x82229738
	ctx.lr = 0x8285CBC4;
	sub_82229738(ctx, base);
	// 8285CBC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285CBC8: 48000008  b 0x8285cbd0
	pc = 0x8285CBD0; continue 'dispatch;
            }
            0x8285CBCC => {
    //   block [0x8285CBCC..0x8285CBD0)
	// 8285CBCC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	pc = 0x8285CBD0; continue 'dispatch;
            }
            0x8285CBD0 => {
    //   block [0x8285CBD0..0x8285CC30)
	// 8285CBD0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CBD4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8285CBD8: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CBDC: 814B0070  lwz r10, 0x70(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8285CBE0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285CBE4: 4E800421  bctrl
	ctx.lr = 0x8285CBE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285CBE8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8285CBEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8285CBF0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8285CBF4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8285CBF8: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8285CBFC: 3900001F  li r8, 0x1f
	ctx.r[8].s64 = 31;
	// 8285CC00: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 8285CC04: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 8285CC08: 4BD064B1  bl 0x825630b8
	ctx.lr = 0x8285CC0C;
	sub_825630B8(ctx, base);
	// 8285CC0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285CC10: 813A0020  lwz r9, 0x20(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 8285CC14: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CC18: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 8285CC1C: 419A007C  beq cr6, 0x8285cc98
	if ctx.cr[6].eq {
	pc = 0x8285CC98; continue 'dispatch;
	}
	// 8285CC20: 5523003E  slwi r3, r9, 0
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8285CC24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285CC28: 419A0040  beq cr6, 0x8285cc68
	if ctx.cr[6].eq {
	pc = 0x8285CC68; continue 'dispatch;
	}
	// 8285CC2C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
            }
            0x8285CC30 => {
    //   block [0x8285CC30..0x8285CC64)
	// 8285CC30: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8285CC34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285CC38: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8285CC3C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285CC40: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285CC44: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285CC48: 4082FFE8  bne 0x8285cc30
	if !ctx.cr[0].eq {
	pc = 0x8285CC30; continue 'dispatch;
	}
	// 8285CC4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285CC50: 409A0014  bne cr6, 0x8285cc64
	if !ctx.cr[6].eq {
	pc = 0x8285CC64; continue 'dispatch;
	}
	// 8285CC54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CC58: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285CC5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285CC60: 4E800421  bctrl
	ctx.lr = 0x8285CC64;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285CC64 => {
    //   block [0x8285CC64..0x8285CC68)
	// 8285CC64: 937A0020  stw r27, 0x20(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[27].u32 ) };
	pc = 0x8285CC68; continue 'dispatch;
            }
            0x8285CC68 => {
    //   block [0x8285CC68..0x8285CC7C)
	// 8285CC68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CC6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285CC70: 917A0020  stw r11, 0x20(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 8285CC74: 419A0024  beq cr6, 0x8285cc98
	if ctx.cr[6].eq {
	pc = 0x8285CC98; continue 'dispatch;
	}
	// 8285CC78: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x8285CC7C; continue 'dispatch;
            }
            0x8285CC7C => {
    //   block [0x8285CC7C..0x8285CC98)
	// 8285CC7C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285CC80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285CC84: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285CC88: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285CC8C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285CC90: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285CC94: 4082FFE8  bne 0x8285cc7c
	if !ctx.cr[0].eq {
	pc = 0x8285CC7C; continue 'dispatch;
	}
	pc = 0x8285CC98; continue 'dispatch;
            }
            0x8285CC98 => {
    //   block [0x8285CC98..0x8285CCAC)
	// 8285CC98: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8285CC9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285CCA0: 419A0048  beq cr6, 0x8285cce8
	if ctx.cr[6].eq {
	pc = 0x8285CCE8; continue 'dispatch;
	}
	// 8285CCA4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285CCA8: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x8285CCAC; continue 'dispatch;
            }
            0x8285CCAC => {
    //   block [0x8285CCAC..0x8285CCE4)
	// 8285CCAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285CCB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285CCB4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285CCB8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8285CCBC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285CCC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285CCC4: 4082FFE8  bne 0x8285ccac
	if !ctx.cr[0].eq {
	pc = 0x8285CCAC; continue 'dispatch;
	}
	// 8285CCC8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8285CCCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285CCD0: 409A0014  bne cr6, 0x8285cce4
	if !ctx.cr[6].eq {
	pc = 0x8285CCE4; continue 'dispatch;
	}
	// 8285CCD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CCD8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285CCDC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285CCE0: 4E800421  bctrl
	ctx.lr = 0x8285CCE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285CCE4 => {
    //   block [0x8285CCE4..0x8285CCE8)
	// 8285CCE4: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	pc = 0x8285CCE8; continue 'dispatch;
            }
            0x8285CCE8 => {
    //   block [0x8285CCE8..0x8285CCF0)
	// 8285CCE8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8285CCEC: 4BFAAA65  bl 0x82807750
	ctx.lr = 0x8285CCF0;
	sub_82807750(ctx, base);
	pc = 0x8285CCF0; continue 'dispatch;
            }
            0x8285CCF0 => {
    //   block [0x8285CCF0..0x8285CCFC)
	// 8285CCF0: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 8285CCF4: 387A0010  addi r3, r26, 0x10
	ctx.r[3].s64 = ctx.r[26].s64 + 16;
	// 8285CCF8: 4B91E6A1  bl 0x8217b398
	ctx.lr = 0x8285CCFC;
	sub_8217B398(ctx, base);
	pc = 0x8285CCFC; continue 'dispatch;
            }
            0x8285CCFC => {
    //   block [0x8285CCFC..0x8285CD40)
	// 8285CCFC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8285CD00: 4BFFF389  bl 0x8285c088
	ctx.lr = 0x8285CD04;
	sub_8285C088(ctx, base);
	// 8285CD04: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285CD08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285CD0C: 419A051C  beq cr6, 0x8285d228
	if ctx.cr[6].eq {
	pc = 0x8285D228; continue 'dispatch;
	}
	// 8285CD10: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CD14: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8285CD18: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 8285CD1C: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 8285CD20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285CD24: 4E800421  bctrl
	ctx.lr = 0x8285CD28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285CD28: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285CD2C: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CD30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285CD34: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8285CD38: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 8285CD3C: 419A0020  beq cr6, 0x8285cd5c
	if ctx.cr[6].eq {
	pc = 0x8285CD5C; continue 'dispatch;
	}
            }
            0x8285CD40 => {
    //   block [0x8285CD40..0x8285CD5C)
	// 8285CD40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285CD44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285CD48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285CD4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285CD50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285CD54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285CD58: 4082FFE8  bne 0x8285cd40
	if !ctx.cr[0].eq {
	pc = 0x8285CD40; continue 'dispatch;
	}
	pc = 0x8285CD5C; continue 'dispatch;
            }
            0x8285CD5C => {
    //   block [0x8285CD5C..0x8285CD94)
	// 8285CD5C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 8285CD60: 4B95ADB9  bl 0x821b7b18
	ctx.lr = 0x8285CD64;
	sub_821B7B18(ctx, base);
	// 8285CD64: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CD68: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8285CD6C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8285CD70: 814B0078  lwz r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 8285CD74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285CD78: 4E800421  bctrl
	ctx.lr = 0x8285CD7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285CD7C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285CD80: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CD84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285CD88: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 8285CD8C: 93C100C8  stw r30, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[30].u32 ) };
	// 8285CD90: 419A0020  beq cr6, 0x8285cdb0
	if ctx.cr[6].eq {
	pc = 0x8285CDB0; continue 'dispatch;
	}
            }
            0x8285CD94 => {
    //   block [0x8285CD94..0x8285CDB0)
	// 8285CD94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285CD98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285CD9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285CDA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285CDA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285CDA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285CDAC: 4082FFE8  bne 0x8285cd94
	if !ctx.cr[0].eq {
	pc = 0x8285CD94; continue 'dispatch;
	}
	pc = 0x8285CDB0; continue 'dispatch;
            }
            0x8285CDB0 => {
    //   block [0x8285CDB0..0x8285CE08)
	// 8285CDB0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8285CDB4: 4B95AD65  bl 0x821b7b18
	ctx.lr = 0x8285CDB8;
	sub_821B7B18(ctx, base);
	// 8285CDB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8285CDBC: 419A045C  beq cr6, 0x8285d218
	if ctx.cr[6].eq {
	pc = 0x8285D218; continue 'dispatch;
	}
	// 8285CDC0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8285CDC4: 419A0454  beq cr6, 0x8285d218
	if ctx.cr[6].eq {
	pc = 0x8285D218; continue 'dispatch;
	}
	// 8285CDC8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285CDCC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285CDD0: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 8285CDD4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285CDD8: 419A00F4  beq cr6, 0x8285cecc
	if ctx.cr[6].eq {
	pc = 0x8285CECC; continue 'dispatch;
	}
	// 8285CDDC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285CDE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285CDE4: 419A0024  beq cr6, 0x8285ce08
	if ctx.cr[6].eq {
	pc = 0x8285CE08; continue 'dispatch;
	}
	// 8285CDE8: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 8285CDEC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285CDF0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285CDF4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285CDF8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285CDFC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8285CE00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285CE04: 480000D0  b 0x8285ced4
	pc = 0x8285CED4; continue 'dispatch;
            }
            0x8285CE08 => {
    //   block [0x8285CE08..0x8285CE24)
	// 8285CE08: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285CE0C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285CE10: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 8285CE14: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285CE18: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285CE1C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285CE20: 40810054  ble 0x8285ce74
	if !ctx.cr[0].gt {
	pc = 0x8285CE74; continue 'dispatch;
	}
	pc = 0x8285CE24; continue 'dispatch;
            }
            0x8285CE24 => {
    //   block [0x8285CE24..0x8285CE44)
	// 8285CE24: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285CE28: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285CE2C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285CE30: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CE34: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8285CE38: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285CE3C: 41980008  blt cr6, 0x8285ce44
	if ctx.cr[6].lt {
	pc = 0x8285CE44; continue 'dispatch;
	}
	// 8285CE40: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x8285CE44; continue 'dispatch;
            }
            0x8285CE44 => {
    //   block [0x8285CE44..0x8285CE60)
	// 8285CE44: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285CE48: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285CE4C: 419A0014  beq cr6, 0x8285ce60
	if ctx.cr[6].eq {
	pc = 0x8285CE60; continue 'dispatch;
	}
	// 8285CE50: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285CE54: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285CE58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285CE5C: 4800000C  b 0x8285ce68
	pc = 0x8285CE68; continue 'dispatch;
            }
            0x8285CE60 => {
    //   block [0x8285CE60..0x8285CE68)
	// 8285CE60: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285CE64: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285CE68; continue 'dispatch;
            }
            0x8285CE68 => {
    //   block [0x8285CE68..0x8285CE74)
	// 8285CE68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285CE6C: 4199FFB8  bgt cr6, 0x8285ce24
	if ctx.cr[6].gt {
	pc = 0x8285CE24; continue 'dispatch;
	}
	// 8285CE70: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285CE74; continue 'dispatch;
            }
            0x8285CE74 => {
    //   block [0x8285CE74..0x8285CE90)
	// 8285CE74: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285CE78: 419A0040  beq cr6, 0x8285ceb8
	if ctx.cr[6].eq {
	pc = 0x8285CEB8; continue 'dispatch;
	}
	// 8285CE7C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CE80: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8285CE84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285CE88: 41990008  bgt cr6, 0x8285ce90
	if ctx.cr[6].gt {
	pc = 0x8285CE90; continue 'dispatch;
	}
	// 8285CE8C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8285CE90; continue 'dispatch;
            }
            0x8285CE90 => {
    //   block [0x8285CE90..0x8285CEB8)
	// 8285CE90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285CE94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285CE98: 409A0020  bne cr6, 0x8285ceb8
	if !ctx.cr[6].eq {
	pc = 0x8285CEB8; continue 'dispatch;
	}
	// 8285CE9C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285CEA0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285CEA4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285CEA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285CEAC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8285CEB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285CEB4: 48000020  b 0x8285ced4
	pc = 0x8285CED4; continue 'dispatch;
            }
            0x8285CEB8 => {
    //   block [0x8285CEB8..0x8285CECC)
	// 8285CEB8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285CEBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285CEC0: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8285CEC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285CEC8: 4800000C  b 0x8285ced4
	pc = 0x8285CED4; continue 'dispatch;
            }
            0x8285CECC => {
    //   block [0x8285CECC..0x8285CED4)
	// 8285CECC: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285CED0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8285CED4; continue 'dispatch;
            }
            0x8285CED4 => {
    //   block [0x8285CED4..0x8285CF30)
	// 8285CED4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285CED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285CEDC: 419A033C  beq cr6, 0x8285d218
	if ctx.cr[6].eq {
	pc = 0x8285D218; continue 'dispatch;
	}
	// 8285CEE0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8285CEE4: 4B9C2375  bl 0x8221f258
	ctx.lr = 0x8285CEE8;
	sub_8221F258(ctx, base);
	// 8285CEE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285CEEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8285CEF0: 419A0040  beq cr6, 0x8285cf30
	if ctx.cr[6].eq {
	pc = 0x8285CF30; continue 'dispatch;
	}
	// 8285CEF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8285CEF8: 4BF03BC9  bl 0x82760ac0
	ctx.lr = 0x8285CEFC;
	sub_82760AC0(ctx, base);
	// 8285CEFC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8285CF00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285CF04: 394B4258  addi r10, r11, 0x4258
	ctx.r[10].s64 = ctx.r[11].s64 + 16984;
	// 8285CF08: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8285CF0C: 4BA2705D  bl 0x82283f68
	ctx.lr = 0x8285CF10;
	sub_82283F68(ctx, base);
	// 8285CF10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8285CF14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285CF18: 4BF050F1  bl 0x82762008
	ctx.lr = 0x8285CF1C;
	sub_82762008(ctx, base);
	// 8285CF1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8285CF20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285CF24: 4BF051FD  bl 0x82762120
	ctx.lr = 0x8285CF28;
	sub_82762120(ctx, base);
	// 8285CF28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8285CF2C: 48000008  b 0x8285cf34
	pc = 0x8285CF34; continue 'dispatch;
            }
            0x8285CF30 => {
    //   block [0x8285CF30..0x8285CF34)
	// 8285CF30: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	pc = 0x8285CF34; continue 'dispatch;
            }
            0x8285CF34 => {
    //   block [0x8285CF34..0x8285CF7C)
	// 8285CF34: 3BDA0058  addi r30, r26, 0x58
	ctx.r[30].s64 = ctx.r[26].s64 + 88;
	// 8285CF38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285CF3C: 4BA1611D  bl 0x82273058
	ctx.lr = 0x8285CF40;
	sub_82273058(ctx, base);
	// 8285CF40: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285CF44: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285CF48: 5549D7FE  rlwinm r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 8285CF4C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285CF50: 419A00E8  beq cr6, 0x8285d038
	if ctx.cr[6].eq {
	pc = 0x8285D038; continue 'dispatch;
	}
	// 8285CF54: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285CF58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285CF5C: 419A0020  beq cr6, 0x8285cf7c
	if ctx.cr[6].eq {
	pc = 0x8285CF7C; continue 'dispatch;
	}
	// 8285CF60: 894A0006  lbz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 8285CF64: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285CF68: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285CF6C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285CF70: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285CF74: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285CF78: 480000C8  b 0x8285d040
	pc = 0x8285D040; continue 'dispatch;
            }
            0x8285CF7C => {
    //   block [0x8285CF7C..0x8285CF98)
	// 8285CF7C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285CF80: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285CF84: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 8285CF88: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285CF8C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285CF90: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285CF94: 40810054  ble 0x8285cfe8
	if !ctx.cr[0].gt {
	pc = 0x8285CFE8; continue 'dispatch;
	}
	pc = 0x8285CF98; continue 'dispatch;
            }
            0x8285CF98 => {
    //   block [0x8285CF98..0x8285CFB8)
	// 8285CF98: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285CF9C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285CFA0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285CFA4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CFA8: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 8285CFAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285CFB0: 41980008  blt cr6, 0x8285cfb8
	if ctx.cr[6].lt {
	pc = 0x8285CFB8; continue 'dispatch;
	}
	// 8285CFB4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x8285CFB8; continue 'dispatch;
            }
            0x8285CFB8 => {
    //   block [0x8285CFB8..0x8285CFD4)
	// 8285CFB8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285CFBC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285CFC0: 419A0014  beq cr6, 0x8285cfd4
	if ctx.cr[6].eq {
	pc = 0x8285CFD4; continue 'dispatch;
	}
	// 8285CFC4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285CFC8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285CFCC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285CFD0: 4800000C  b 0x8285cfdc
	pc = 0x8285CFDC; continue 'dispatch;
            }
            0x8285CFD4 => {
    //   block [0x8285CFD4..0x8285CFDC)
	// 8285CFD4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285CFD8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285CFDC; continue 'dispatch;
            }
            0x8285CFDC => {
    //   block [0x8285CFDC..0x8285CFE8)
	// 8285CFDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285CFE0: 4199FFB8  bgt cr6, 0x8285cf98
	if ctx.cr[6].gt {
	pc = 0x8285CF98; continue 'dispatch;
	}
	// 8285CFE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285CFE8; continue 'dispatch;
            }
            0x8285CFE8 => {
    //   block [0x8285CFE8..0x8285D004)
	// 8285CFE8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285CFEC: 419A003C  beq cr6, 0x8285d028
	if ctx.cr[6].eq {
	pc = 0x8285D028; continue 'dispatch;
	}
	// 8285CFF0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285CFF4: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 8285CFF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285CFFC: 41990008  bgt cr6, 0x8285d004
	if ctx.cr[6].gt {
	pc = 0x8285D004; continue 'dispatch;
	}
	// 8285D000: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8285D004; continue 'dispatch;
            }
            0x8285D004 => {
    //   block [0x8285D004..0x8285D028)
	// 8285D004: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285D008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D00C: 409A001C  bne cr6, 0x8285d028
	if !ctx.cr[6].eq {
	pc = 0x8285D028; continue 'dispatch;
	}
	// 8285D010: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285D014: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285D018: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285D01C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285D020: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D024: 4800001C  b 0x8285d040
	pc = 0x8285D040; continue 'dispatch;
            }
            0x8285D028 => {
    //   block [0x8285D028..0x8285D038)
	// 8285D028: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285D02C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285D030: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D034: 4800000C  b 0x8285d040
	pc = 0x8285D040; continue 'dispatch;
            }
            0x8285D038 => {
    //   block [0x8285D038..0x8285D040)
	// 8285D038: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285D03C: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	pc = 0x8285D040; continue 'dispatch;
            }
            0x8285D040 => {
    //   block [0x8285D040..0x8285D0C0)
	// 8285D040: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8285D044: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285D048: 419A01D0  beq cr6, 0x8285d218
	if ctx.cr[6].eq {
	pc = 0x8285D218; continue 'dispatch;
	}
	// 8285D04C: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 8285D050: 38AB00CC  addi r5, r11, 0xcc
	ctx.r[5].s64 = ctx.r[11].s64 + 204;
	// 8285D054: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 8285D058: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8285D05C: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 8285D060: 93610080  stw r27, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 8285D064: 93210084  stw r25, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[25].u32 ) };
	// 8285D068: 9361008C  stw r27, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[27].u32 ) };
	// 8285D06C: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	// 8285D070: 93610094  stw r27, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[27].u32 ) };
	// 8285D074: 9B610099  stb r27, 0x99(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(153 as u32), ctx.r[27].u8 ) };
	// 8285D078: 936100A0  stw r27, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[27].u32 ) };
	// 8285D07C: 936100A4  stw r27, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[27].u32 ) };
	// 8285D080: 936100A8  stw r27, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[27].u32 ) };
	// 8285D084: 936100B0  stw r27, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u32 ) };
	// 8285D088: 936100B4  stw r27, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[27].u32 ) };
	// 8285D08C: 936100B8  stw r27, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[27].u32 ) };
	// 8285D090: 808B0094  lwz r4, 0x94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 8285D094: 4BF04BAD  bl 0x82761c40
	ctx.lr = 0x8285D098;
	sub_82761C40(ctx, base);
	// 8285D098: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8285D09C: 4B9C21BD  bl 0x8221f258
	ctx.lr = 0x8285D0A0;
	sub_8221F258(ctx, base);
	// 8285D0A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285D0A4: 419A001C  beq cr6, 0x8285d0c0
	if ctx.cr[6].eq {
	pc = 0x8285D0C0; continue 'dispatch;
	}
	// 8285D0A8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8285D0AC: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D0B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8285D0B4: 4BF04D25  bl 0x82761dd8
	ctx.lr = 0x8285D0B8;
	sub_82761DD8(ctx, base);
	// 8285D0B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285D0BC: 48000008  b 0x8285d0c4
	pc = 0x8285D0C4; continue 'dispatch;
            }
            0x8285D0C0 => {
    //   block [0x8285D0C0..0x8285D0C4)
	// 8285D0C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	pc = 0x8285D0C4; continue 'dispatch;
            }
            0x8285D0C4 => {
    //   block [0x8285D0C4..0x8285D0EC)
	// 8285D0C4: 387A0060  addi r3, r26, 0x60
	ctx.r[3].s64 = ctx.r[26].s64 + 96;
	// 8285D0C8: 4BA15F91  bl 0x82273058
	ctx.lr = 0x8285D0CC;
	sub_82273058(ctx, base);
	// 8285D0CC: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8285D0D0: 4B9C2189  bl 0x8221f258
	ctx.lr = 0x8285D0D4;
	sub_8221F258(ctx, base);
	// 8285D0D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285D0D8: 419A0014  beq cr6, 0x8285d0ec
	if ctx.cr[6].eq {
	pc = 0x8285D0EC; continue 'dispatch;
	}
	// 8285D0DC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8285D0E0: 4BA2EA61  bl 0x8228bb40
	ctx.lr = 0x8285D0E4;
	sub_8228BB40(ctx, base);
	// 8285D0E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285D0E8: 48000008  b 0x8285d0f0
	pc = 0x8285D0F0; continue 'dispatch;
            }
            0x8285D0EC => {
    //   block [0x8285D0EC..0x8285D0F0)
	// 8285D0EC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	pc = 0x8285D0F0; continue 'dispatch;
            }
            0x8285D0F0 => {
    //   block [0x8285D0F0..0x8285D110)
	// 8285D0F0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8285D0F4: 4B9C2165  bl 0x8221f258
	ctx.lr = 0x8285D0F8;
	sub_8221F258(ctx, base);
	// 8285D0F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285D0FC: 419A0014  beq cr6, 0x8285d110
	if ctx.cr[6].eq {
	pc = 0x8285D110; continue 'dispatch;
	}
	// 8285D100: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8285D104: 4B9CC635  bl 0x82229738
	ctx.lr = 0x8285D108;
	sub_82229738(ctx, base);
	// 8285D108: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8285D10C: 48000008  b 0x8285d114
	pc = 0x8285D114; continue 'dispatch;
            }
            0x8285D110 => {
    //   block [0x8285D110..0x8285D114)
	// 8285D110: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	pc = 0x8285D114; continue 'dispatch;
            }
            0x8285D114 => {
    //   block [0x8285D114..0x8285D158)
	// 8285D114: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 8285D118: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D11C: 390000DF  li r8, 0xdf
	ctx.r[8].s64 = 223;
	// 8285D120: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 8285D124: 38C00080  li r6, 0x80
	ctx.r[6].s64 = 128;
	// 8285D128: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8285D12C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285D130: 4BD05F89  bl 0x825630b8
	ctx.lr = 0x8285D134;
	sub_825630B8(ctx, base);
	// 8285D134: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285D138: 817A0068  lwz r11, 0x68(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(104 as u32) ) } as u64;
	// 8285D13C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D140: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8285D144: 419A007C  beq cr6, 0x8285d1c0
	if ctx.cr[6].eq {
	pc = 0x8285D1C0; continue 'dispatch;
	}
	// 8285D148: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8285D14C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285D150: 419A0040  beq cr6, 0x8285d190
	if ctx.cr[6].eq {
	pc = 0x8285D190; continue 'dispatch;
	}
	// 8285D154: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8285D158; continue 'dispatch;
            }
            0x8285D158 => {
    //   block [0x8285D158..0x8285D18C)
	// 8285D158: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8285D15C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D160: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8285D164: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285D168: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285D16C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D170: 4082FFE8  bne 0x8285d158
	if !ctx.cr[0].eq {
	pc = 0x8285D158; continue 'dispatch;
	}
	// 8285D174: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285D178: 409A0014  bne cr6, 0x8285d18c
	if !ctx.cr[6].eq {
	pc = 0x8285D18C; continue 'dispatch;
	}
	// 8285D17C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D180: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D184: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285D188: 4E800421  bctrl
	ctx.lr = 0x8285D18C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285D18C => {
    //   block [0x8285D18C..0x8285D190)
	// 8285D18C: 937A0068  stw r27, 0x68(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	pc = 0x8285D190; continue 'dispatch;
            }
            0x8285D190 => {
    //   block [0x8285D190..0x8285D1A4)
	// 8285D190: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D198: 917A0068  stw r11, 0x68(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8285D19C: 419A0024  beq cr6, 0x8285d1c0
	if ctx.cr[6].eq {
	pc = 0x8285D1C0; continue 'dispatch;
	}
	// 8285D1A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x8285D1A4; continue 'dispatch;
            }
            0x8285D1A4 => {
    //   block [0x8285D1A4..0x8285D1C0)
	// 8285D1A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285D1A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D1AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285D1B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285D1B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285D1B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D1BC: 4082FFE8  bne 0x8285d1a4
	if !ctx.cr[0].eq {
	pc = 0x8285D1A4; continue 'dispatch;
	}
	pc = 0x8285D1C0; continue 'dispatch;
            }
            0x8285D1C0 => {
    //   block [0x8285D1C0..0x8285D1D4)
	// 8285D1C0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285D1C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D1C8: 419A0048  beq cr6, 0x8285d210
	if ctx.cr[6].eq {
	pc = 0x8285D210; continue 'dispatch;
	}
	// 8285D1CC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285D1D0: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x8285D1D4; continue 'dispatch;
            }
            0x8285D1D4 => {
    //   block [0x8285D1D4..0x8285D20C)
	// 8285D1D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285D1D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D1DC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285D1E0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8285D1E4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285D1E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D1EC: 4082FFE8  bne 0x8285d1d4
	if !ctx.cr[0].eq {
	pc = 0x8285D1D4; continue 'dispatch;
	}
	// 8285D1F0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8285D1F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285D1F8: 409A0014  bne cr6, 0x8285d20c
	if !ctx.cr[6].eq {
	pc = 0x8285D20C; continue 'dispatch;
	}
	// 8285D1FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D200: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D204: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285D208: 4E800421  bctrl
	ctx.lr = 0x8285D20C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285D20C => {
    //   block [0x8285D20C..0x8285D210)
	// 8285D20C: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	pc = 0x8285D210; continue 'dispatch;
            }
            0x8285D210 => {
    //   block [0x8285D210..0x8285D218)
	// 8285D210: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8285D214: 4BFAA53D  bl 0x82807750
	ctx.lr = 0x8285D218;
	sub_82807750(ctx, base);
	pc = 0x8285D218; continue 'dispatch;
            }
            0x8285D218 => {
    //   block [0x8285D218..0x8285D228)
	// 8285D218: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 8285D21C: 4B95A8FD  bl 0x821b7b18
	ctx.lr = 0x8285D220;
	sub_821B7B18(ctx, base);
	// 8285D220: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8285D224: 4B95A8F5  bl 0x821b7b18
	ctx.lr = 0x8285D228;
	sub_821B7B18(ctx, base);
	pc = 0x8285D228; continue 'dispatch;
            }
            0x8285D228 => {
    //   block [0x8285D228..0x8285D240)
	// 8285D228: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8285D22C: 4B95A8ED  bl 0x821b7b18
	ctx.lr = 0x8285D230;
	sub_821B7B18(ctx, base);
	// 8285D230: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 8285D234: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8285D238: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8285D23C: 4844C210  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285D240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285D240 size=436
    let mut pc: u32 = 0x8285D240;
    'dispatch: loop {
        match pc {
            0x8285D240 => {
    //   block [0x8285D240..0x8285D2A8)
	// 8285D240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285D244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285D248: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285D24C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285D250: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285D254: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8285D258: 4BFFDEB9  bl 0x8285b110
	ctx.lr = 0x8285D25C;
	sub_8285B110(ctx, base);
	// 8285D25C: 809E0068  lwz r4, 0x68(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 8285D260: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8285D264: 419A0178  beq cr6, 0x8285d3dc
	if ctx.cr[6].eq {
	pc = 0x8285D3DC; continue 'dispatch;
	}
	// 8285D268: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D26C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8285D270: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285D274: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 8285D278: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285D27C: 419A00E8  beq cr6, 0x8285d364
	if ctx.cr[6].eq {
	pc = 0x8285D364; continue 'dispatch;
	}
	// 8285D280: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285D284: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285D288: 419A0020  beq cr6, 0x8285d2a8
	if ctx.cr[6].eq {
	pc = 0x8285D2A8; continue 'dispatch;
	}
	// 8285D28C: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 8285D290: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285D294: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8285D298: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8285D29C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285D2A0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D2A4: 480000C8  b 0x8285d36c
	pc = 0x8285D36C; continue 'dispatch;
            }
            0x8285D2A8 => {
    //   block [0x8285D2A8..0x8285D2C4)
	// 8285D2A8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285D2AC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285D2B0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8285D2B4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285D2B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285D2BC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285D2C0: 40810054  ble 0x8285d314
	if !ctx.cr[0].gt {
	pc = 0x8285D314; continue 'dispatch;
	}
	pc = 0x8285D2C4; continue 'dispatch;
            }
            0x8285D2C4 => {
    //   block [0x8285D2C4..0x8285D2E4)
	// 8285D2C4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285D2C8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285D2CC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285D2D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D2D4: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8285D2D8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285D2DC: 41980008  blt cr6, 0x8285d2e4
	if ctx.cr[6].lt {
	pc = 0x8285D2E4; continue 'dispatch;
	}
	// 8285D2E0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x8285D2E4; continue 'dispatch;
            }
            0x8285D2E4 => {
    //   block [0x8285D2E4..0x8285D300)
	// 8285D2E4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285D2E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285D2EC: 419A0014  beq cr6, 0x8285d300
	if ctx.cr[6].eq {
	pc = 0x8285D300; continue 'dispatch;
	}
	// 8285D2F0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285D2F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285D2F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285D2FC: 4800000C  b 0x8285d308
	pc = 0x8285D308; continue 'dispatch;
            }
            0x8285D300 => {
    //   block [0x8285D300..0x8285D308)
	// 8285D300: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285D304: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285D308; continue 'dispatch;
            }
            0x8285D308 => {
    //   block [0x8285D308..0x8285D314)
	// 8285D308: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285D30C: 4199FFB8  bgt cr6, 0x8285d2c4
	if ctx.cr[6].gt {
	pc = 0x8285D2C4; continue 'dispatch;
	}
	// 8285D310: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285D314; continue 'dispatch;
            }
            0x8285D314 => {
    //   block [0x8285D314..0x8285D330)
	// 8285D314: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285D318: 419A003C  beq cr6, 0x8285d354
	if ctx.cr[6].eq {
	pc = 0x8285D354; continue 'dispatch;
	}
	// 8285D31C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D320: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8285D324: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285D328: 41990008  bgt cr6, 0x8285d330
	if ctx.cr[6].gt {
	pc = 0x8285D330; continue 'dispatch;
	}
	// 8285D32C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8285D330; continue 'dispatch;
            }
            0x8285D330 => {
    //   block [0x8285D330..0x8285D354)
	// 8285D330: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285D334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D338: 409A001C  bne cr6, 0x8285d354
	if !ctx.cr[6].eq {
	pc = 0x8285D354; continue 'dispatch;
	}
	// 8285D33C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285D340: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285D344: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285D348: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285D34C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D350: 4800001C  b 0x8285d36c
	pc = 0x8285D36C; continue 'dispatch;
            }
            0x8285D354 => {
    //   block [0x8285D354..0x8285D364)
	// 8285D354: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285D358: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285D35C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D360: 4800000C  b 0x8285d36c
	pc = 0x8285D36C; continue 'dispatch;
            }
            0x8285D364 => {
    //   block [0x8285D364..0x8285D36C)
	// 8285D364: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285D368: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x8285D36C; continue 'dispatch;
            }
            0x8285D36C => {
    //   block [0x8285D36C..0x8285D384)
	// 8285D36C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8285D370: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285D374: 419A0010  beq cr6, 0x8285d384
	if ctx.cr[6].eq {
	pc = 0x8285D384; continue 'dispatch;
	}
	// 8285D378: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8285D37C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285D380: 4BD05FC9  bl 0x82563348
	ctx.lr = 0x8285D384;
	sub_82563348(ctx, base);
	pc = 0x8285D384; continue 'dispatch;
            }
            0x8285D384 => {
    //   block [0x8285D384..0x8285D394)
	// 8285D384: 807E0068  lwz r3, 0x68(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 8285D388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285D38C: 419A0040  beq cr6, 0x8285d3cc
	if ctx.cr[6].eq {
	pc = 0x8285D3CC; continue 'dispatch;
	}
	// 8285D390: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8285D394; continue 'dispatch;
            }
            0x8285D394 => {
    //   block [0x8285D394..0x8285D3C8)
	// 8285D394: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8285D398: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D39C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8285D3A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285D3A4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285D3A8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D3AC: 4082FFE8  bne 0x8285d394
	if !ctx.cr[0].eq {
	pc = 0x8285D394; continue 'dispatch;
	}
	// 8285D3B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285D3B4: 409A0014  bne cr6, 0x8285d3c8
	if !ctx.cr[6].eq {
	pc = 0x8285D3C8; continue 'dispatch;
	}
	// 8285D3B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D3BC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D3C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285D3C4: 4E800421  bctrl
	ctx.lr = 0x8285D3C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285D3C8 => {
    //   block [0x8285D3C8..0x8285D3CC)
	// 8285D3C8: 93FE0068  stw r31, 0x68(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	pc = 0x8285D3CC; continue 'dispatch;
            }
            0x8285D3CC => {
    //   block [0x8285D3CC..0x8285D3DC)
	// 8285D3CC: 93FE0068  stw r31, 0x68(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 8285D3D0: 387E0058  addi r3, r30, 0x58
	ctx.r[3].s64 = ctx.r[30].s64 + 88;
	// 8285D3D4: 4B95A745  bl 0x821b7b18
	ctx.lr = 0x8285D3D8;
	sub_821B7B18(ctx, base);
	// 8285D3D8: 93FE0058  stw r31, 0x58(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	pc = 0x8285D3DC; continue 'dispatch;
            }
            0x8285D3DC => {
    //   block [0x8285D3DC..0x8285D3F4)
	// 8285D3DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285D3E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285D3E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285D3E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285D3EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285D3F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285D3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285D3F8 size=260
    let mut pc: u32 = 0x8285D3F8;
    'dispatch: loop {
        match pc {
            0x8285D3F8 => {
    //   block [0x8285D3F8..0x8285D454)
	// 8285D3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285D3FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285D400: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285D404: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285D408: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285D40C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8285D410: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8285D414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285D418: 4BFFEC71  bl 0x8285c088
	ctx.lr = 0x8285D41C;
	sub_8285C088(ctx, base);
	// 8285D41C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285D420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D424: 419A0088  beq cr6, 0x8285d4ac
	if ctx.cr[6].eq {
	pc = 0x8285D4AC; continue 'dispatch;
	}
	// 8285D428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285D42C: 4800018D  bl 0x8285d5b8
	ctx.lr = 0x8285D430;
	sub_8285D5B8(ctx, base);
	// 8285D430: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285D434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D438: 419A003C  beq cr6, 0x8285d474
	if ctx.cr[6].eq {
	pc = 0x8285D474; continue 'dispatch;
	}
	// 8285D43C: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 8285D440: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8285D444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D448: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8285D44C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8285D450: 419A0090  beq cr6, 0x8285d4e0
	if ctx.cr[6].eq {
	pc = 0x8285D4E0; continue 'dispatch;
	}
	pc = 0x8285D454; continue 'dispatch;
            }
            0x8285D454 => {
    //   block [0x8285D454..0x8285D474)
	// 8285D454: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285D458: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D45C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285D460: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285D464: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285D468: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D46C: 4082FFE8  bne 0x8285d454
	if !ctx.cr[0].eq {
	pc = 0x8285D454; continue 'dispatch;
	}
	// 8285D470: 48000070  b 0x8285d4e0
	pc = 0x8285D4E0; continue 'dispatch;
            }
            0x8285D474 => {
    //   block [0x8285D474..0x8285D48C)
	// 8285D474: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 8285D478: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 8285D47C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D480: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8285D484: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8285D488: 419A0058  beq cr6, 0x8285d4e0
	if ctx.cr[6].eq {
	pc = 0x8285D4E0; continue 'dispatch;
	}
	pc = 0x8285D48C; continue 'dispatch;
            }
            0x8285D48C => {
    //   block [0x8285D48C..0x8285D4AC)
	// 8285D48C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285D490: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D494: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285D498: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285D49C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285D4A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D4A4: 4082FFE8  bne 0x8285d48c
	if !ctx.cr[0].eq {
	pc = 0x8285D48C; continue 'dispatch;
	}
	// 8285D4A8: 48000038  b 0x8285d4e0
	pc = 0x8285D4E0; continue 'dispatch;
            }
            0x8285D4AC => {
    //   block [0x8285D4AC..0x8285D4C4)
	// 8285D4AC: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8285D4B0: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8285D4B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D4B8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8285D4BC: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8285D4C0: 419A0020  beq cr6, 0x8285d4e0
	if ctx.cr[6].eq {
	pc = 0x8285D4E0; continue 'dispatch;
	}
	pc = 0x8285D4C4; continue 'dispatch;
            }
            0x8285D4C4 => {
    //   block [0x8285D4C4..0x8285D4E0)
	// 8285D4C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285D4C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D4CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285D4D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285D4D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285D4D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D4DC: 4082FFE8  bne 0x8285d4c4
	if !ctx.cr[0].eq {
	pc = 0x8285D4C4; continue 'dispatch;
	}
	pc = 0x8285D4E0; continue 'dispatch;
            }
            0x8285D4E0 => {
    //   block [0x8285D4E0..0x8285D4FC)
	// 8285D4E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285D4E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285D4E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285D4EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285D4F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285D4F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285D4F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285D500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285D500 size=184
    let mut pc: u32 = 0x8285D500;
    'dispatch: loop {
        match pc {
            0x8285D500 => {
    //   block [0x8285D500..0x8285D548)
	// 8285D500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285D504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285D508: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285D50C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285D510: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285D514: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8285D518: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8285D51C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285D520: 48000099  bl 0x8285d5b8
	ctx.lr = 0x8285D524;
	sub_8285D5B8(ctx, base);
	// 8285D524: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285D528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D52C: 419A003C  beq cr6, 0x8285d568
	if ctx.cr[6].eq {
	pc = 0x8285D568; continue 'dispatch;
	}
	// 8285D530: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285D534: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285D538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D53C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8285D540: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8285D544: 419A0058  beq cr6, 0x8285d59c
	if ctx.cr[6].eq {
	pc = 0x8285D59C; continue 'dispatch;
	}
	pc = 0x8285D548; continue 'dispatch;
            }
            0x8285D548 => {
    //   block [0x8285D548..0x8285D568)
	// 8285D548: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285D54C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D550: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285D554: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285D558: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285D55C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D560: 4082FFE8  bne 0x8285d548
	if !ctx.cr[0].eq {
	pc = 0x8285D548; continue 'dispatch;
	}
	// 8285D564: 48000038  b 0x8285d59c
	pc = 0x8285D59C; continue 'dispatch;
            }
            0x8285D568 => {
    //   block [0x8285D568..0x8285D580)
	// 8285D568: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285D56C: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285D570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D574: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8285D578: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8285D57C: 419A0020  beq cr6, 0x8285d59c
	if ctx.cr[6].eq {
	pc = 0x8285D59C; continue 'dispatch;
	}
	pc = 0x8285D580; continue 'dispatch;
            }
            0x8285D580 => {
    //   block [0x8285D580..0x8285D59C)
	// 8285D580: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285D584: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D588: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285D58C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285D590: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285D594: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285D598: 4082FFE8  bne 0x8285d580
	if !ctx.cr[0].eq {
	pc = 0x8285D580; continue 'dispatch;
	}
	pc = 0x8285D59C; continue 'dispatch;
            }
            0x8285D59C => {
    //   block [0x8285D59C..0x8285D5B8)
	// 8285D59C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285D5A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285D5A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285D5A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285D5AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285D5B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285D5B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285D5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285D5B8 size=216
    let mut pc: u32 = 0x8285D5B8;
    'dispatch: loop {
        match pc {
            0x8285D5B8 => {
    //   block [0x8285D5B8..0x8285D5EC)
	// 8285D5B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285D5BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285D5C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285D5C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285D5C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285D5CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8285D5D0: 480005D1  bl 0x8285dba0
	ctx.lr = 0x8285D5D4;
	sub_8285DBA0(ctx, base);
	// 8285D5D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285D5D8: 419A0014  beq cr6, 0x8285d5ec
	if ctx.cr[6].eq {
	pc = 0x8285D5EC; continue 'dispatch;
	}
	// 8285D5DC: 89630018  lbz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8285D5E0: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8285D5E4: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 8285D5E8: 48000090  b 0x8285d678
	pc = 0x8285D678; continue 'dispatch;
            }
            0x8285D5EC => {
    //   block [0x8285D5EC..0x8285D674)
	// 8285D5EC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D5F0: 4BA6A951  bl 0x822c7f40
	ctx.lr = 0x8285D5F4;
	sub_822C7F40(ctx, base);
	// 8285D5F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285D5F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8285D5FC: 419A0078  beq cr6, 0x8285d674
	if ctx.cr[6].eq {
	pc = 0x8285D674; continue 'dispatch;
	}
	// 8285D600: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 8285D604: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D608: 409A006C  bne cr6, 0x8285d674
	if !ctx.cr[6].eq {
	pc = 0x8285D674; continue 'dispatch;
	}
	// 8285D60C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D610: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285D614: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8285D618: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D61C: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8285D620: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8285D624: 4E800421  bctrl
	ctx.lr = 0x8285D628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285D628: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 8285D62C: 38E000D0  li r7, 0xd0
	ctx.r[7].s64 = 208;
	// 8285D630: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 8285D634: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285D638: 388690F0  addi r4, r6, -0x6f10
	ctx.r[4].s64 = ctx.r[6].s64 + -28432;
            }
            0x8285D674 => {
    //   block [0x8285D674..0x8285D678)
	// 8285D674: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x8285D678; continue 'dispatch;
            }
            0x8285D678 => {
    //   block [0x8285D678..0x8285D690)
	// 8285D678: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8285D67C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285D680: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285D684: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285D688: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285D68C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285D690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285D690 size=1296
    let mut pc: u32 = 0x8285D690;
    'dispatch: loop {
        match pc {
            0x8285D690 => {
    //   block [0x8285D690..0x8285D6E8)
	// 8285D690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285D694: 4844BD71  bl 0x82ca9404
	ctx.lr = 0x8285D698;
	sub_82CA93D0(ctx, base);
	// 8285D698: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 8285D69C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8285D6A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285D6A4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8285D6A8: 80DC0004  lwz r6, 4(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D6AC: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285D6B0: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 8285D6B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285D6B8: 419A00F8  beq cr6, 0x8285d7b0
	if ctx.cr[6].eq {
	pc = 0x8285D7B0; continue 'dispatch;
	}
	// 8285D6BC: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285D6C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D6C4: 419A0024  beq cr6, 0x8285d6e8
	if ctx.cr[6].eq {
	pc = 0x8285D6E8; continue 'dispatch;
	}
	// 8285D6C8: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8285D6CC: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285D6D0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285D6D4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285D6D8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D6DC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8285D6E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285D6E4: 480000D4  b 0x8285d7b8
	pc = 0x8285D7B8; continue 'dispatch;
            }
            0x8285D6E8 => {
    //   block [0x8285D6E8..0x8285D708)
	// 8285D6E8: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285D6EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8285D6F0: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285D6F4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8285D6F8: 7D2A2850  subf r9, r10, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 8285D6FC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8285D700: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285D704: 40810054  ble 0x8285d758
	if !ctx.cr[0].gt {
	pc = 0x8285D758; continue 'dispatch;
	}
	pc = 0x8285D708; continue 'dispatch;
            }
            0x8285D708 => {
    //   block [0x8285D708..0x8285D728)
	// 8285D708: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285D70C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285D710: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285D714: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D718: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 8285D71C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285D720: 41980008  blt cr6, 0x8285d728
	if ctx.cr[6].lt {
	pc = 0x8285D728; continue 'dispatch;
	}
	// 8285D724: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8285D728; continue 'dispatch;
            }
            0x8285D728 => {
    //   block [0x8285D728..0x8285D744)
	// 8285D728: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285D72C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285D730: 419A0014  beq cr6, 0x8285d744
	if ctx.cr[6].eq {
	pc = 0x8285D744; continue 'dispatch;
	}
	// 8285D734: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285D738: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285D73C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285D740: 4800000C  b 0x8285d74c
	pc = 0x8285D74C; continue 'dispatch;
            }
            0x8285D744 => {
    //   block [0x8285D744..0x8285D74C)
	// 8285D744: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285D748: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285D74C; continue 'dispatch;
            }
            0x8285D74C => {
    //   block [0x8285D74C..0x8285D758)
	// 8285D74C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285D750: 4199FFB8  bgt cr6, 0x8285d708
	if ctx.cr[6].gt {
	pc = 0x8285D708; continue 'dispatch;
	}
	// 8285D754: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8285D758; continue 'dispatch;
            }
            0x8285D758 => {
    //   block [0x8285D758..0x8285D774)
	// 8285D758: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8285D75C: 419A0040  beq cr6, 0x8285d79c
	if ctx.cr[6].eq {
	pc = 0x8285D79C; continue 'dispatch;
	}
	// 8285D760: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D764: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 8285D768: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285D76C: 41990008  bgt cr6, 0x8285d774
	if ctx.cr[6].gt {
	pc = 0x8285D774; continue 'dispatch;
	}
	// 8285D770: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285D774; continue 'dispatch;
            }
            0x8285D774 => {
    //   block [0x8285D774..0x8285D79C)
	// 8285D774: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285D778: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D77C: 409A0020  bne cr6, 0x8285d79c
	if !ctx.cr[6].eq {
	pc = 0x8285D79C; continue 'dispatch;
	}
	// 8285D780: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8285D784: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285D788: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285D78C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D790: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8285D794: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285D798: 48000020  b 0x8285d7b8
	pc = 0x8285D7B8; continue 'dispatch;
            }
            0x8285D79C => {
    //   block [0x8285D79C..0x8285D7B0)
	// 8285D79C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8285D7A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D7A4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8285D7A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285D7AC: 4800000C  b 0x8285d7b8
	pc = 0x8285D7B8; continue 'dispatch;
            }
            0x8285D7B0 => {
    //   block [0x8285D7B0..0x8285D7B8)
	// 8285D7B0: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285D7B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285D7B8; continue 'dispatch;
            }
            0x8285D7B8 => {
    //   block [0x8285D7B8..0x8285D800)
	// 8285D7B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285D7BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D7C0: 419A03C8  beq cr6, 0x8285db88
	if ctx.cr[6].eq {
	pc = 0x8285DB88; continue 'dispatch;
	}
	// 8285D7C4: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285D7C8: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 8285D7CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285D7D0: 419A00F8  beq cr6, 0x8285d8c8
	if ctx.cr[6].eq {
	pc = 0x8285D8C8; continue 'dispatch;
	}
	// 8285D7D4: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285D7D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D7DC: 419A0024  beq cr6, 0x8285d800
	if ctx.cr[6].eq {
	pc = 0x8285D800; continue 'dispatch;
	}
	// 8285D7E0: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 8285D7E4: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285D7E8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285D7EC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285D7F0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D7F4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285D7F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285D7FC: 480000D4  b 0x8285d8d0
	pc = 0x8285D8D0; continue 'dispatch;
            }
            0x8285D800 => {
    //   block [0x8285D800..0x8285D820)
	// 8285D800: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285D804: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8285D808: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285D80C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8285D810: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285D814: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8285D818: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285D81C: 40810054  ble 0x8285d870
	if !ctx.cr[0].gt {
	pc = 0x8285D870; continue 'dispatch;
	}
	pc = 0x8285D820; continue 'dispatch;
            }
            0x8285D820 => {
    //   block [0x8285D820..0x8285D840)
	// 8285D820: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285D824: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285D828: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285D82C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D830: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8285D834: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285D838: 41980008  blt cr6, 0x8285d840
	if ctx.cr[6].lt {
	pc = 0x8285D840; continue 'dispatch;
	}
	// 8285D83C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8285D840; continue 'dispatch;
            }
            0x8285D840 => {
    //   block [0x8285D840..0x8285D85C)
	// 8285D840: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285D844: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285D848: 419A0014  beq cr6, 0x8285d85c
	if ctx.cr[6].eq {
	pc = 0x8285D85C; continue 'dispatch;
	}
	// 8285D84C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285D850: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285D854: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285D858: 4800000C  b 0x8285d864
	pc = 0x8285D864; continue 'dispatch;
            }
            0x8285D85C => {
    //   block [0x8285D85C..0x8285D864)
	// 8285D85C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285D860: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285D864; continue 'dispatch;
            }
            0x8285D864 => {
    //   block [0x8285D864..0x8285D870)
	// 8285D864: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285D868: 4199FFB8  bgt cr6, 0x8285d820
	if ctx.cr[6].gt {
	pc = 0x8285D820; continue 'dispatch;
	}
	// 8285D86C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8285D870; continue 'dispatch;
            }
            0x8285D870 => {
    //   block [0x8285D870..0x8285D88C)
	// 8285D870: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285D874: 419A0040  beq cr6, 0x8285d8b4
	if ctx.cr[6].eq {
	pc = 0x8285D8B4; continue 'dispatch;
	}
	// 8285D878: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D87C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8285D880: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285D884: 41990008  bgt cr6, 0x8285d88c
	if ctx.cr[6].gt {
	pc = 0x8285D88C; continue 'dispatch;
	}
	// 8285D888: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285D88C; continue 'dispatch;
            }
            0x8285D88C => {
    //   block [0x8285D88C..0x8285D8B4)
	// 8285D88C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285D890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D894: 409A0020  bne cr6, 0x8285d8b4
	if !ctx.cr[6].eq {
	pc = 0x8285D8B4; continue 'dispatch;
	}
	// 8285D898: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8285D89C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285D8A0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285D8A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D8A8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285D8AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285D8B0: 48000020  b 0x8285d8d0
	pc = 0x8285D8D0; continue 'dispatch;
            }
            0x8285D8B4 => {
    //   block [0x8285D8B4..0x8285D8C8)
	// 8285D8B4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285D8B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285D8BC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285D8C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285D8C4: 4800000C  b 0x8285d8d0
	pc = 0x8285D8D0; continue 'dispatch;
            }
            0x8285D8C8 => {
    //   block [0x8285D8C8..0x8285D8D0)
	// 8285D8C8: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285D8CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285D8D0; continue 'dispatch;
            }
            0x8285D8D0 => {
    //   block [0x8285D8D0..0x8285D954)
	// 8285D8D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285D8D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285D8D8: 419A02B0  beq cr6, 0x8285db88
	if ctx.cr[6].eq {
	pc = 0x8285DB88; continue 'dispatch;
	}
	// 8285D8DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8285D8E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285D8E4: 388B0E20  addi r4, r11, 0xe20
	ctx.r[4].s64 = ctx.r[11].s64 + 3616;
	// 8285D8E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285D8EC: 4B9CF5E5  bl 0x8222ced0
	ctx.lr = 0x8285D8F0;
	sub_8222CED0(ctx, base);
	// 8285D8F0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8285D8F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285D8F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8285D8FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285D900: 4BBC3E51  bl 0x82421750
	ctx.lr = 0x8285D904;
	sub_82421750(ctx, base);
	// 8285D904: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285D908: 4B9B74D1  bl 0x82214dd8
	ctx.lr = 0x8285D90C;
	sub_82214DD8(ctx, base);
	// 8285D90C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8285D910: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285D914: 390A92D4  addi r8, r10, -0x6d2c
	ctx.r[8].s64 = ctx.r[10].s64 + -27948;
	// 8285D918: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285D91C: C3CA92D4  lfs f30, -0x6d2c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8285D920: C3E801B0  lfs f31, 0x1b0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(432 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8285D924: 419A0064  beq cr6, 0x8285d988
	if ctx.cr[6].eq {
	pc = 0x8285D988; continue 'dispatch;
	}
	// 8285D928: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 8285D92C: 4B9C192D  bl 0x8221f258
	ctx.lr = 0x8285D930;
	sub_8221F258(ctx, base);
	// 8285D930: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285D934: 419A0020  beq cr6, 0x8285d954
	if ctx.cr[6].eq {
	pc = 0x8285D954; continue 'dispatch;
	}
	// 8285D938: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8285D93C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285D940: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8285D944: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8285D948: 4BA262E9  bl 0x82283c30
	ctx.lr = 0x8285D94C;
	sub_82283C30(ctx, base);
	// 8285D94C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285D950: 48000008  b 0x8285d958
	pc = 0x8285D958; continue 'dispatch;
            }
            0x8285D954 => {
    //   block [0x8285D954..0x8285D958)
	// 8285D954: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8285D958; continue 'dispatch;
            }
            0x8285D958 => {
    //   block [0x8285D958..0x8285D988)
	// 8285D958: 387C0030  addi r3, r28, 0x30
	ctx.r[3].s64 = ctx.r[28].s64 + 48;
	// 8285D95C: 4BA156FD  bl 0x82273058
	ctx.lr = 0x8285D960;
	sub_82273058(ctx, base);
	// 8285D960: 83FC0030  lwz r31, 0x30(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 8285D964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285D968: C03F0028  lfs f1, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285D96C: 4BA75CDD  bl 0x822d3648
	ctx.lr = 0x8285D970;
	sub_822D3648(ctx, base);
	// 8285D970: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285D974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285D978: EC2107B2  fmuls f1, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8285D97C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285D980: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285D984: 4E800421  bctrl
	ctx.lr = 0x8285D988;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285D988 => {
    //   block [0x8285D988..0x8285D9F0)
	// 8285D988: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285D98C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285D990: 388BF3B4  addi r4, r11, -0xc4c
	ctx.r[4].s64 = ctx.r[11].s64 + -3148;
	// 8285D994: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285D998: 4B9CF539  bl 0x8222ced0
	ctx.lr = 0x8285D99C;
	sub_8222CED0(ctx, base);
	// 8285D99C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8285D9A0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8285D9A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8285D9A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285D9AC: 4BBC3DA5  bl 0x82421750
	ctx.lr = 0x8285D9B0;
	sub_82421750(ctx, base);
	// 8285D9B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285D9B4: 4B9B7425  bl 0x82214dd8
	ctx.lr = 0x8285D9B8;
	sub_82214DD8(ctx, base);
	// 8285D9B8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285D9BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285D9C0: 419A00C8  beq cr6, 0x8285da88
	if ctx.cr[6].eq {
	pc = 0x8285DA88; continue 'dispatch;
	}
	// 8285D9C4: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 8285D9C8: 4B9C1891  bl 0x8221f258
	ctx.lr = 0x8285D9CC;
	sub_8221F258(ctx, base);
	// 8285D9CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285D9D0: 419A0020  beq cr6, 0x8285d9f0
	if ctx.cr[6].eq {
	pc = 0x8285D9F0; continue 'dispatch;
	}
	// 8285D9D4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8285D9D8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285D9DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285D9E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8285D9E4: 4BA2624D  bl 0x82283c30
	ctx.lr = 0x8285D9E8;
	sub_82283C30(ctx, base);
	// 8285D9E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285D9EC: 48000008  b 0x8285d9f4
	pc = 0x8285D9F4; continue 'dispatch;
            }
            0x8285D9F0 => {
    //   block [0x8285D9F0..0x8285D9F4)
	// 8285D9F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8285D9F4; continue 'dispatch;
            }
            0x8285D9F4 => {
    //   block [0x8285D9F4..0x8285DA54)
	// 8285D9F4: 3BFC0038  addi r31, r28, 0x38
	ctx.r[31].s64 = ctx.r[28].s64 + 56;
	// 8285D9F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285D9FC: 4BA1565D  bl 0x82273058
	ctx.lr = 0x8285DA00;
	sub_82273058(ctx, base);
	// 8285DA00: 837C0038  lwz r27, 0x38(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 8285DA04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8285DA08: C03B0028  lfs f1, 0x28(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285DA0C: 4BA75C3D  bl 0x822d3648
	ctx.lr = 0x8285DA10;
	sub_822D3648(ctx, base);
	// 8285DA10: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285DA14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8285DA18: EC2107B2  fmuls f1, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8285DA1C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285DA20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285DA24: 4E800421  bctrl
	ctx.lr = 0x8285DA28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285DA28: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 8285DA2C: 4B9C182D  bl 0x8221f258
	ctx.lr = 0x8285DA30;
	sub_8221F258(ctx, base);
	// 8285DA30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285DA34: 419A0020  beq cr6, 0x8285da54
	if ctx.cr[6].eq {
	pc = 0x8285DA54; continue 'dispatch;
	}
	// 8285DA38: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8285DA3C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285DA40: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285DA44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8285DA48: 4BA261E9  bl 0x82283c30
	ctx.lr = 0x8285DA4C;
	sub_82283C30(ctx, base);
	// 8285DA4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285DA50: 48000008  b 0x8285da58
	pc = 0x8285DA58; continue 'dispatch;
            }
            0x8285DA54 => {
    //   block [0x8285DA54..0x8285DA58)
	// 8285DA54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8285DA58; continue 'dispatch;
            }
            0x8285DA58 => {
    //   block [0x8285DA58..0x8285DA88)
	// 8285DA58: 387C0048  addi r3, r28, 0x48
	ctx.r[3].s64 = ctx.r[28].s64 + 72;
	// 8285DA5C: 4BA155FD  bl 0x82273058
	ctx.lr = 0x8285DA60;
	sub_82273058(ctx, base);
	// 8285DA60: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285DA64: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285DA68: 83FC0048  lwz r31, 0x48(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285DA6C: 4BA75BDD  bl 0x822d3648
	ctx.lr = 0x8285DA70;
	sub_822D3648(ctx, base);
	// 8285DA70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285DA74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285DA78: EC2107B2  fmuls f1, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8285DA7C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285DA80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285DA84: 4E800421  bctrl
	ctx.lr = 0x8285DA88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285DA88 => {
    //   block [0x8285DA88..0x8285DAF0)
	// 8285DA88: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285DA8C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285DA90: 388BF3C0  addi r4, r11, -0xc40
	ctx.r[4].s64 = ctx.r[11].s64 + -3136;
	// 8285DA94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285DA98: 4B9CF439  bl 0x8222ced0
	ctx.lr = 0x8285DA9C;
	sub_8222CED0(ctx, base);
	// 8285DA9C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8285DAA0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8285DAA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8285DAA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285DAAC: 4BBC3CA5  bl 0x82421750
	ctx.lr = 0x8285DAB0;
	sub_82421750(ctx, base);
	// 8285DAB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285DAB4: 4B9B7325  bl 0x82214dd8
	ctx.lr = 0x8285DAB8;
	sub_82214DD8(ctx, base);
	// 8285DAB8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285DABC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285DAC0: 419A00C8  beq cr6, 0x8285db88
	if ctx.cr[6].eq {
	pc = 0x8285DB88; continue 'dispatch;
	}
	// 8285DAC4: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 8285DAC8: 4B9C1791  bl 0x8221f258
	ctx.lr = 0x8285DACC;
	sub_8221F258(ctx, base);
	// 8285DACC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285DAD0: 419A0020  beq cr6, 0x8285daf0
	if ctx.cr[6].eq {
	pc = 0x8285DAF0; continue 'dispatch;
	}
	// 8285DAD4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8285DAD8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285DADC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285DAE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8285DAE4: 4BA2614D  bl 0x82283c30
	ctx.lr = 0x8285DAE8;
	sub_82283C30(ctx, base);
	// 8285DAE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285DAEC: 48000008  b 0x8285daf4
	pc = 0x8285DAF4; continue 'dispatch;
            }
            0x8285DAF0 => {
    //   block [0x8285DAF0..0x8285DAF4)
	// 8285DAF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8285DAF4; continue 'dispatch;
            }
            0x8285DAF4 => {
    //   block [0x8285DAF4..0x8285DB54)
	// 8285DAF4: 3BFC0040  addi r31, r28, 0x40
	ctx.r[31].s64 = ctx.r[28].s64 + 64;
	// 8285DAF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285DAFC: 4BA1555D  bl 0x82273058
	ctx.lr = 0x8285DB00;
	sub_82273058(ctx, base);
	// 8285DB00: 83BC0040  lwz r29, 0x40(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 8285DB04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8285DB08: C03D0028  lfs f1, 0x28(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285DB0C: 4BA75B3D  bl 0x822d3648
	ctx.lr = 0x8285DB10;
	sub_822D3648(ctx, base);
	// 8285DB10: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285DB14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8285DB18: EC2107B2  fmuls f1, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8285DB1C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285DB20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285DB24: 4E800421  bctrl
	ctx.lr = 0x8285DB28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285DB28: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 8285DB2C: 4B9C172D  bl 0x8221f258
	ctx.lr = 0x8285DB30;
	sub_8221F258(ctx, base);
	// 8285DB30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285DB34: 419A0020  beq cr6, 0x8285db54
	if ctx.cr[6].eq {
	pc = 0x8285DB54; continue 'dispatch;
	}
	// 8285DB38: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8285DB3C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285DB40: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285DB44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8285DB48: 4BA260E9  bl 0x82283c30
	ctx.lr = 0x8285DB4C;
	sub_82283C30(ctx, base);
	// 8285DB4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285DB50: 48000008  b 0x8285db58
	pc = 0x8285DB58; continue 'dispatch;
            }
            0x8285DB54 => {
    //   block [0x8285DB54..0x8285DB58)
	// 8285DB54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8285DB58; continue 'dispatch;
            }
            0x8285DB58 => {
    //   block [0x8285DB58..0x8285DB88)
	// 8285DB58: 387C0050  addi r3, r28, 0x50
	ctx.r[3].s64 = ctx.r[28].s64 + 80;
	// 8285DB5C: 4BA154FD  bl 0x82273058
	ctx.lr = 0x8285DB60;
	sub_82273058(ctx, base);
	// 8285DB60: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285DB64: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285DB68: 83FC0050  lwz r31, 0x50(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285DB6C: 4BA75ADD  bl 0x822d3648
	ctx.lr = 0x8285DB70;
	sub_822D3648(ctx, base);
	// 8285DB70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285DB74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285DB78: EC2107B2  fmuls f1, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8285DB7C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285DB80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285DB84: 4E800421  bctrl
	ctx.lr = 0x8285DB88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285DB88 => {
    //   block [0x8285DB88..0x8285DBA0)
	// 8285DB88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8285DB8C: 4BFFD735  bl 0x8285b2c0
	ctx.lr = 0x8285DB90;
	sub_8285B2C0(ctx, base);
	// 8285DB90: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8285DB94: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8285DB98: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8285DB9C: 4844B8B8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285DBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285DBA0 size=420
    let mut pc: u32 = 0x8285DBA0;
    'dispatch: loop {
        match pc {
            0x8285DBA0 => {
    //   block [0x8285DBA0..0x8285DBF8)
	// 8285DBA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285DBA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285DBA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285DBAC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285DBB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285DBB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8285DBB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8285DBBC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285DBC0: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 8285DBC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285DBC8: 419A00F4  beq cr6, 0x8285dcbc
	if ctx.cr[6].eq {
	pc = 0x8285DCBC; continue 'dispatch;
	}
	// 8285DBCC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285DBD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285DBD4: 419A0024  beq cr6, 0x8285dbf8
	if ctx.cr[6].eq {
	pc = 0x8285DBF8; continue 'dispatch;
	}
	// 8285DBD8: 894A0031  lbz r10, 0x31(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 8285DBDC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285DBE0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285DBE4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285DBE8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285DBEC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8285DBF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285DBF4: 480000CC  b 0x8285dcc0
	pc = 0x8285DCC0; continue 'dispatch;
            }
            0x8285DBF8 => {
    //   block [0x8285DBF8..0x8285DC14)
	// 8285DBF8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285DBFC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285DC00: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8285DC04: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285DC08: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285DC0C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285DC10: 40810054  ble 0x8285dc64
	if !ctx.cr[0].gt {
	pc = 0x8285DC64; continue 'dispatch;
	}
	pc = 0x8285DC14; continue 'dispatch;
            }
            0x8285DC14 => {
    //   block [0x8285DC14..0x8285DC34)
	// 8285DC14: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285DC18: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285DC1C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285DC20: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285DC24: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 8285DC28: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285DC2C: 41980008  blt cr6, 0x8285dc34
	if ctx.cr[6].lt {
	pc = 0x8285DC34; continue 'dispatch;
	}
	// 8285DC30: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x8285DC34; continue 'dispatch;
            }
            0x8285DC34 => {
    //   block [0x8285DC34..0x8285DC50)
	// 8285DC34: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285DC38: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285DC3C: 419A0014  beq cr6, 0x8285dc50
	if ctx.cr[6].eq {
	pc = 0x8285DC50; continue 'dispatch;
	}
	// 8285DC40: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285DC44: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285DC48: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285DC4C: 4800000C  b 0x8285dc58
	pc = 0x8285DC58; continue 'dispatch;
            }
            0x8285DC50 => {
    //   block [0x8285DC50..0x8285DC58)
	// 8285DC50: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285DC54: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285DC58; continue 'dispatch;
            }
            0x8285DC58 => {
    //   block [0x8285DC58..0x8285DC64)
	// 8285DC58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285DC5C: 4199FFB8  bgt cr6, 0x8285dc14
	if ctx.cr[6].gt {
	pc = 0x8285DC14; continue 'dispatch;
	}
	// 8285DC60: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285DC64; continue 'dispatch;
            }
            0x8285DC64 => {
    //   block [0x8285DC64..0x8285DC80)
	// 8285DC64: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285DC68: 419A0040  beq cr6, 0x8285dca8
	if ctx.cr[6].eq {
	pc = 0x8285DCA8; continue 'dispatch;
	}
	// 8285DC6C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285DC70: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 8285DC74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285DC78: 41990008  bgt cr6, 0x8285dc80
	if ctx.cr[6].gt {
	pc = 0x8285DC80; continue 'dispatch;
	}
	// 8285DC7C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8285DC80; continue 'dispatch;
            }
            0x8285DC80 => {
    //   block [0x8285DC80..0x8285DCA8)
	// 8285DC80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285DC84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285DC88: 409A0020  bne cr6, 0x8285dca8
	if !ctx.cr[6].eq {
	pc = 0x8285DCA8; continue 'dispatch;
	}
	// 8285DC8C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285DC90: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285DC94: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285DC98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285DC9C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8285DCA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285DCA4: 4800001C  b 0x8285dcc0
	pc = 0x8285DCC0; continue 'dispatch;
            }
            0x8285DCA8 => {
    //   block [0x8285DCA8..0x8285DCBC)
	// 8285DCA8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285DCAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285DCB0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8285DCB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285DCB8: 48000008  b 0x8285dcc0
	pc = 0x8285DCC0; continue 'dispatch;
            }
            0x8285DCBC => {
    //   block [0x8285DCBC..0x8285DCC0)
	// 8285DCBC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8285DCC0; continue 'dispatch;
            }
            0x8285DCC0 => {
    //   block [0x8285DCC0..0x8285DD28)
	// 8285DCC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285DCC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285DCC8: 419A0064  beq cr6, 0x8285dd2c
	if ctx.cr[6].eq {
	pc = 0x8285DD2C; continue 'dispatch;
	}
	// 8285DCCC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285DCD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285DCD4: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 8285DCD8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285DCDC: 4E800421  bctrl
	ctx.lr = 0x8285DCE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285DCE0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8285DCE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8285DCE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285DCEC: 48105F25  bl 0x82963c10
	ctx.lr = 0x8285DCF0;
	sub_82963C10(ctx, base);
	// 8285DCF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8285DCF4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8285DCF8: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 8285DCFC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285DD00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285DD04: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8285DD08: 419A0020  beq cr6, 0x8285dd28
	if ctx.cr[6].eq {
	pc = 0x8285DD28; continue 'dispatch;
	}
	// 8285DD0C: 4B93612D  bl 0x82193e38
	ctx.lr = 0x8285DD10;
	sub_82193E38(ctx, base);
	// 8285DD10: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285DD14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8285DD18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285DD1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285DD20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285DD24: 4E800020  blr
	return;
            }
            0x8285DD28 => {
    //   block [0x8285DD28..0x8285DD2C)
	// 8285DD28: 4B936111  bl 0x82193e38
	ctx.lr = 0x8285DD2C;
	sub_82193E38(ctx, base);
	pc = 0x8285DD2C; continue 'dispatch;
            }
            0x8285DD2C => {
    //   block [0x8285DD2C..0x8285DD44)
	// 8285DD2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8285DD30: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8285DD34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285DD38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285DD3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285DD40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285DD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8285DD48 size=1292
    let mut pc: u32 = 0x8285DD48;
    'dispatch: loop {
        match pc {
            0x8285DD48 => {
    //   block [0x8285DD48..0x8285E254)
	// 8285DD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285DD4C: 4844B6B9  bl 0x82ca9404
	ctx.lr = 0x8285DD50;
	sub_82CA93D0(ctx, base);
	// 8285DD50: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 8285DD54: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 8285DD58: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8285DD5C: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285E258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285E258 size=196
    let mut pc: u32 = 0x8285E258;
    'dispatch: loop {
        match pc {
            0x8285E258 => {
    //   block [0x8285E258..0x8285E284)
	// 8285E258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285E25C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285E260: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285E264: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285E268: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285E26C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285E270: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8285E274: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285E278: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285E27C: 419A0044  beq cr6, 0x8285e2c0
	if ctx.cr[6].eq {
	pc = 0x8285E2C0; continue 'dispatch;
	}
	// 8285E280: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8285E284; continue 'dispatch;
            }
            0x8285E284 => {
    //   block [0x8285E284..0x8285E2B8)
	// 8285E284: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8285E288: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285E28C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8285E290: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285E294: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285E298: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285E29C: 4082FFE8  bne 0x8285e284
	if !ctx.cr[0].eq {
	pc = 0x8285E284; continue 'dispatch;
	}
	// 8285E2A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285E2A4: 409A0014  bne cr6, 0x8285e2b8
	if !ctx.cr[6].eq {
	pc = 0x8285E2B8; continue 'dispatch;
	}
	// 8285E2A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285E2AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E2B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285E2B4: 4E800421  bctrl
	ctx.lr = 0x8285E2B8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285E2B8 => {
    //   block [0x8285E2B8..0x8285E2C0)
	// 8285E2B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8285E2BC: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	pc = 0x8285E2C0; continue 'dispatch;
            }
            0x8285E2C0 => {
    //   block [0x8285E2C0..0x8285E304)
	// 8285E2C0: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 8285E2C4: 4B959855  bl 0x821b7b18
	ctx.lr = 0x8285E2C8;
	sub_821B7B18(ctx, base);
	// 8285E2C8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 8285E2CC: 4B95984D  bl 0x821b7b18
	ctx.lr = 0x8285E2D0;
	sub_821B7B18(ctx, base);
	// 8285E2D0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 8285E2D4: 4B959845  bl 0x821b7b18
	ctx.lr = 0x8285E2D8;
	sub_821B7B18(ctx, base);
	// 8285E2D8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285E2DC: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 8285E2E0: 394BF058  addi r10, r11, -0xfa8
	ctx.r[10].s64 = ctx.r[11].s64 + -4008;
	// 8285E2E4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8285E2E8: 4B9B6AF1  bl 0x82214dd8
	ctx.lr = 0x8285E2EC;
	sub_82214DD8(ctx, base);
	// 8285E2EC: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8285E2F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285E2F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285E2F8: 419A000C  beq cr6, 0x8285e304
	if ctx.cr[6].eq {
	pc = 0x8285E304; continue 'dispatch;
	}
	// 8285E2FC: 4B9BDA3D  bl 0x8221bd38
	ctx.lr = 0x8285E300;
	sub_8221BD38(ctx, base);
	// 8285E300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8285E304; continue 'dispatch;
            }
            0x8285E304 => {
    //   block [0x8285E304..0x8285E31C)
	// 8285E304: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285E308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285E30C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285E310: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285E314: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285E318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285E320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285E320 size=412
    let mut pc: u32 = 0x8285E320;
    'dispatch: loop {
        match pc {
            0x8285E320 => {
    //   block [0x8285E320..0x8285E384)
	// 8285E320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285E324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285E328: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285E32C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285E330: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285E334: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8285E338: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8285E33C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E340: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285E344: D01E002C  stfs f0, 0x2c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8285E348: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8285E34C: 5528EFFE  rlwinm r8, r9, 0x1d, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 8285E350: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8285E354: 419A00F8  beq cr6, 0x8285e44c
	if ctx.cr[6].eq {
	pc = 0x8285E44C; continue 'dispatch;
	}
	// 8285E358: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285E35C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285E360: 419A0024  beq cr6, 0x8285e384
	if ctx.cr[6].eq {
	pc = 0x8285E384; continue 'dispatch;
	}
	// 8285E364: 894A0063  lbz r10, 0x63(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(99 as u32) ) } as u64;
	// 8285E368: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285E36C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285E370: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285E374: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E378: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285E37C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E380: 480000D4  b 0x8285e454
	pc = 0x8285E454; continue 'dispatch;
            }
            0x8285E384 => {
    //   block [0x8285E384..0x8285E3A4)
	// 8285E384: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285E388: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8285E38C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285E390: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8285E394: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285E398: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285E39C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285E3A0: 40810054  ble 0x8285e3f4
	if !ctx.cr[0].gt {
	pc = 0x8285E3F4; continue 'dispatch;
	}
	pc = 0x8285E3A4; continue 'dispatch;
            }
            0x8285E3A4 => {
    //   block [0x8285E3A4..0x8285E3C4)
	// 8285E3A4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285E3A8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285E3AC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285E3B0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285E3B4: 2F070063  cmpwi cr6, r7, 0x63
	ctx.cr[6].compare_i32(ctx.r[7].s32, 99, &mut ctx.xer);
	// 8285E3B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285E3BC: 41980008  blt cr6, 0x8285e3c4
	if ctx.cr[6].lt {
	pc = 0x8285E3C4; continue 'dispatch;
	}
	// 8285E3C0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8285E3C4; continue 'dispatch;
            }
            0x8285E3C4 => {
    //   block [0x8285E3C4..0x8285E3E0)
	// 8285E3C4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285E3C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285E3CC: 419A0014  beq cr6, 0x8285e3e0
	if ctx.cr[6].eq {
	pc = 0x8285E3E0; continue 'dispatch;
	}
	// 8285E3D0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285E3D4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285E3D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285E3DC: 4800000C  b 0x8285e3e8
	pc = 0x8285E3E8; continue 'dispatch;
            }
            0x8285E3E0 => {
    //   block [0x8285E3E0..0x8285E3E8)
	// 8285E3E0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285E3E4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285E3E8; continue 'dispatch;
            }
            0x8285E3E8 => {
    //   block [0x8285E3E8..0x8285E3F4)
	// 8285E3E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285E3EC: 4199FFB8  bgt cr6, 0x8285e3a4
	if ctx.cr[6].gt {
	pc = 0x8285E3A4; continue 'dispatch;
	}
	// 8285E3F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285E3F4; continue 'dispatch;
            }
            0x8285E3F4 => {
    //   block [0x8285E3F4..0x8285E410)
	// 8285E3F4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285E3F8: 419A0040  beq cr6, 0x8285e438
	if ctx.cr[6].eq {
	pc = 0x8285E438; continue 'dispatch;
	}
	// 8285E3FC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285E400: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 8285E404: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E408: 41990008  bgt cr6, 0x8285e410
	if ctx.cr[6].gt {
	pc = 0x8285E410; continue 'dispatch;
	}
	// 8285E40C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285E410; continue 'dispatch;
            }
            0x8285E410 => {
    //   block [0x8285E410..0x8285E438)
	// 8285E410: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285E414: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285E418: 409A0020  bne cr6, 0x8285e438
	if !ctx.cr[6].eq {
	pc = 0x8285E438; continue 'dispatch;
	}
	// 8285E41C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285E420: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285E424: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285E428: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E42C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285E430: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E434: 48000020  b 0x8285e454
	pc = 0x8285E454; continue 'dispatch;
            }
            0x8285E438 => {
    //   block [0x8285E438..0x8285E44C)
	// 8285E438: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285E43C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E440: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285E444: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E448: 4800000C  b 0x8285e454
	pc = 0x8285E454; continue 'dispatch;
            }
            0x8285E44C => {
    //   block [0x8285E44C..0x8285E454)
	// 8285E44C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285E450: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285E454; continue 'dispatch;
            }
            0x8285E454 => {
    //   block [0x8285E454..0x8285E48C)
	// 8285E454: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285E458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285E45C: 419A0048  beq cr6, 0x8285e4a4
	if ctx.cr[6].eq {
	pc = 0x8285E4A4; continue 'dispatch;
	}
	// 8285E460: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8285E464: 4B9C0DF5  bl 0x8221f258
	ctx.lr = 0x8285E468;
	sub_8221F258(ctx, base);
	// 8285E468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285E46C: 419A0020  beq cr6, 0x8285e48c
	if ctx.cr[6].eq {
	pc = 0x8285E48C; continue 'dispatch;
	}
	// 8285E470: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8285E474: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8285E478: 392B0E0C  addi r9, r11, 0xe0c
	ctx.r[9].s64 = ctx.r[11].s64 + 3596;
	// 8285E47C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8285E480: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285E484: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8285E488: 48000008  b 0x8285e490
	pc = 0x8285E490; continue 'dispatch;
            }
            0x8285E48C => {
    //   block [0x8285E48C..0x8285E490)
	// 8285E48C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8285E490; continue 'dispatch;
            }
            0x8285E490 => {
    //   block [0x8285E490..0x8285E4A4)
	// 8285E490: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 8285E494: 4BA14BC5  bl 0x82273058
	ctx.lr = 0x8285E498;
	sub_82273058(ctx, base);
	// 8285E498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285E49C: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8285E4A0: 4BA558D9  bl 0x822b3d78
	ctx.lr = 0x8285E4A4;
	sub_822B3D78(ctx, base);
	pc = 0x8285E4A4; continue 'dispatch;
            }
            0x8285E4A4 => {
    //   block [0x8285E4A4..0x8285E4BC)
	// 8285E4A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285E4A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285E4AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285E4B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285E4B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285E4B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285E4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285E4C0 size=1472
    let mut pc: u32 = 0x8285E4C0;
    'dispatch: loop {
        match pc {
            0x8285E4C0 => {
    //   block [0x8285E4C0..0x8285E51C)
	// 8285E4C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285E4C4: 4844AF49  bl 0x82ca940c
	ctx.lr = 0x8285E4C8;
	sub_82CA93D0(ctx, base);
	// 8285E4C8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8285E4CC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285E4D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8285E4D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8285E4D8: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 8285E4DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E4E0: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285E4E4: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 8285E4E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285E4EC: 419A00F4  beq cr6, 0x8285e5e0
	if ctx.cr[6].eq {
	pc = 0x8285E5E0; continue 'dispatch;
	}
	// 8285E4F0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285E4F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285E4F8: 419A0024  beq cr6, 0x8285e51c
	if ctx.cr[6].eq {
	pc = 0x8285E51C; continue 'dispatch;
	}
	// 8285E4FC: 894A0039  lbz r10, 0x39(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 8285E500: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285E504: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285E508: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285E50C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E510: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285E514: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E518: 480000CC  b 0x8285e5e4
	pc = 0x8285E5E4; continue 'dispatch;
            }
            0x8285E51C => {
    //   block [0x8285E51C..0x8285E538)
	// 8285E51C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285E520: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285E524: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8285E528: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285E52C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285E530: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285E534: 40810054  ble 0x8285e588
	if !ctx.cr[0].gt {
	pc = 0x8285E588; continue 'dispatch;
	}
	pc = 0x8285E538; continue 'dispatch;
            }
            0x8285E538 => {
    //   block [0x8285E538..0x8285E558)
	// 8285E538: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285E53C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285E540: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285E544: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285E548: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 8285E54C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285E550: 41980008  blt cr6, 0x8285e558
	if ctx.cr[6].lt {
	pc = 0x8285E558; continue 'dispatch;
	}
	// 8285E554: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8285E558; continue 'dispatch;
            }
            0x8285E558 => {
    //   block [0x8285E558..0x8285E574)
	// 8285E558: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285E55C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285E560: 419A0014  beq cr6, 0x8285e574
	if ctx.cr[6].eq {
	pc = 0x8285E574; continue 'dispatch;
	}
	// 8285E564: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285E568: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285E56C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285E570: 4800000C  b 0x8285e57c
	pc = 0x8285E57C; continue 'dispatch;
            }
            0x8285E574 => {
    //   block [0x8285E574..0x8285E57C)
	// 8285E574: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285E578: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285E57C; continue 'dispatch;
            }
            0x8285E57C => {
    //   block [0x8285E57C..0x8285E588)
	// 8285E57C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285E580: 4199FFB8  bgt cr6, 0x8285e538
	if ctx.cr[6].gt {
	pc = 0x8285E538; continue 'dispatch;
	}
	// 8285E584: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285E588; continue 'dispatch;
            }
            0x8285E588 => {
    //   block [0x8285E588..0x8285E5A4)
	// 8285E588: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285E58C: 419A0040  beq cr6, 0x8285e5cc
	if ctx.cr[6].eq {
	pc = 0x8285E5CC; continue 'dispatch;
	}
	// 8285E590: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285E594: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 8285E598: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E59C: 41990008  bgt cr6, 0x8285e5a4
	if ctx.cr[6].gt {
	pc = 0x8285E5A4; continue 'dispatch;
	}
	// 8285E5A0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8285E5A4; continue 'dispatch;
            }
            0x8285E5A4 => {
    //   block [0x8285E5A4..0x8285E5CC)
	// 8285E5A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285E5A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285E5AC: 409A0020  bne cr6, 0x8285e5cc
	if !ctx.cr[6].eq {
	pc = 0x8285E5CC; continue 'dispatch;
	}
	// 8285E5B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285E5B4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285E5B8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285E5BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E5C0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285E5C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E5C8: 4800001C  b 0x8285e5e4
	pc = 0x8285E5E4; continue 'dispatch;
            }
            0x8285E5CC => {
    //   block [0x8285E5CC..0x8285E5E0)
	// 8285E5CC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285E5D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E5D4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285E5D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E5DC: 48000008  b 0x8285e5e4
	pc = 0x8285E5E4; continue 'dispatch;
            }
            0x8285E5E0 => {
    //   block [0x8285E5E0..0x8285E5E4)
	// 8285E5E0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8285E5E4; continue 'dispatch;
            }
            0x8285E5E4 => {
    //   block [0x8285E5E4..0x8285E650)
	// 8285E5E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285E5E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285E5EC: 419A007C  beq cr6, 0x8285e668
	if ctx.cr[6].eq {
	pc = 0x8285E668; continue 'dispatch;
	}
	// 8285E5F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8285E5F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285E5F8: 388BDB00  addi r4, r11, -0x2500
	ctx.r[4].s64 = ctx.r[11].s64 + -9472;
	// 8285E5FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285E600: 4B9CE8D1  bl 0x8222ced0
	ctx.lr = 0x8285E604;
	sub_8222CED0(ctx, base);
	// 8285E604: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8285E608: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285E60C: 4B93DFDD  bl 0x8219c5e8
	ctx.lr = 0x8285E610;
	sub_8219C5E8(ctx, base);
	// 8285E610: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285E614: 4B9B67C5  bl 0x82214dd8
	ctx.lr = 0x8285E618;
	sub_82214DD8(ctx, base);
	// 8285E618: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285E61C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285E620: 419A0038  beq cr6, 0x8285e658
	if ctx.cr[6].eq {
	pc = 0x8285E658; continue 'dispatch;
	}
	// 8285E624: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8285E628: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285E62C: 38EBDB38  addi r7, r11, -0x24c8
	ctx.r[7].s64 = ctx.r[11].s64 + -9416;
	// 8285E630: 4B953EC9  bl 0x821b24f8
	ctx.lr = 0x8285E634;
	sub_821B24F8(ctx, base);
	// 8285E634: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8285E638: 4BB611E9  bl 0x823bf820
	ctx.lr = 0x8285E63C;
	sub_823BF820(ctx, base);
	// 8285E63C: 80DF0114  lwz r6, 0x114(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8285E640: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E644: 7F061800  cmpw cr6, r6, r3
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[3].s32, &mut ctx.xer);
	// 8285E648: 40980008  bge cr6, 0x8285e650
	if !ctx.cr[6].lt {
	pc = 0x8285E650; continue 'dispatch;
	}
	// 8285E64C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8285E650; continue 'dispatch;
            }
            0x8285E650 => {
    //   block [0x8285E650..0x8285E658)
	// 8285E650: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285E654: 48000008  b 0x8285e65c
	pc = 0x8285E65C; continue 'dispatch;
            }
            0x8285E658 => {
    //   block [0x8285E658..0x8285E65C)
	// 8285E658: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x8285E65C; continue 'dispatch;
            }
            0x8285E65C => {
    //   block [0x8285E65C..0x8285E668)
	// 8285E65C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285E660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285E664: 419A0194  beq cr6, 0x8285e7f8
	if ctx.cr[6].eq {
	pc = 0x8285E7F8; continue 'dispatch;
	}
	pc = 0x8285E668; continue 'dispatch;
            }
            0x8285E668 => {
    //   block [0x8285E668..0x8285E6A8)
	// 8285E668: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E66C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8285E670: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8285E674: 554997FE  rlwinm r9, r10, 0x12, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00003FFFu64;
	// 8285E678: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285E67C: 419A00E8  beq cr6, 0x8285e764
	if ctx.cr[6].eq {
	pc = 0x8285E764; continue 'dispatch;
	}
	// 8285E680: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285E684: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285E688: 419A0020  beq cr6, 0x8285e6a8
	if ctx.cr[6].eq {
	pc = 0x8285E6A8; continue 'dispatch;
	}
	// 8285E68C: 894A006E  lbz r10, 0x6e(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(110 as u32) ) } as u64;
	// 8285E690: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285E694: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285E698: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285E69C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E6A0: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E6A4: 480000C4  b 0x8285e768
	pc = 0x8285E768; continue 'dispatch;
            }
            0x8285E6A8 => {
    //   block [0x8285E6A8..0x8285E6C4)
	// 8285E6A8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285E6AC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285E6B0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8285E6B4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285E6B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285E6BC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285E6C0: 40810054  ble 0x8285e714
	if !ctx.cr[0].gt {
	pc = 0x8285E714; continue 'dispatch;
	}
	pc = 0x8285E6C4; continue 'dispatch;
            }
            0x8285E6C4 => {
    //   block [0x8285E6C4..0x8285E6E4)
	// 8285E6C4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285E6C8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285E6CC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285E6D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285E6D4: 2F07006E  cmpwi cr6, r7, 0x6e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 110, &mut ctx.xer);
	// 8285E6D8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285E6DC: 41980008  blt cr6, 0x8285e6e4
	if ctx.cr[6].lt {
	pc = 0x8285E6E4; continue 'dispatch;
	}
	// 8285E6E0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8285E6E4; continue 'dispatch;
            }
            0x8285E6E4 => {
    //   block [0x8285E6E4..0x8285E700)
	// 8285E6E4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285E6E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285E6EC: 419A0014  beq cr6, 0x8285e700
	if ctx.cr[6].eq {
	pc = 0x8285E700; continue 'dispatch;
	}
	// 8285E6F0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285E6F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285E6F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285E6FC: 4800000C  b 0x8285e708
	pc = 0x8285E708; continue 'dispatch;
            }
            0x8285E700 => {
    //   block [0x8285E700..0x8285E708)
	// 8285E700: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285E704: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285E708; continue 'dispatch;
            }
            0x8285E708 => {
    //   block [0x8285E708..0x8285E714)
	// 8285E708: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285E70C: 4199FFB8  bgt cr6, 0x8285e6c4
	if ctx.cr[6].gt {
	pc = 0x8285E6C4; continue 'dispatch;
	}
	// 8285E710: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285E714; continue 'dispatch;
            }
            0x8285E714 => {
    //   block [0x8285E714..0x8285E730)
	// 8285E714: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285E718: 419A003C  beq cr6, 0x8285e754
	if ctx.cr[6].eq {
	pc = 0x8285E754; continue 'dispatch;
	}
	// 8285E71C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285E720: 2F0B006E  cmpwi cr6, r11, 0x6e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 110, &mut ctx.xer);
	// 8285E724: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E728: 41990008  bgt cr6, 0x8285e730
	if ctx.cr[6].gt {
	pc = 0x8285E730; continue 'dispatch;
	}
	// 8285E72C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8285E730; continue 'dispatch;
            }
            0x8285E730 => {
    //   block [0x8285E730..0x8285E754)
	// 8285E730: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285E734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285E738: 409A001C  bne cr6, 0x8285e754
	if !ctx.cr[6].eq {
	pc = 0x8285E754; continue 'dispatch;
	}
	// 8285E73C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285E740: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285E744: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285E748: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E74C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E750: 48000018  b 0x8285e768
	pc = 0x8285E768; continue 'dispatch;
            }
            0x8285E754 => {
    //   block [0x8285E754..0x8285E764)
	// 8285E754: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285E758: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E75C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E760: 48000008  b 0x8285e768
	pc = 0x8285E768; continue 'dispatch;
            }
            0x8285E764 => {
    //   block [0x8285E764..0x8285E768)
	// 8285E764: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8285E768; continue 'dispatch;
            }
            0x8285E768 => {
    //   block [0x8285E768..0x8285E7F0)
	// 8285E768: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285E76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285E770: 419A0088  beq cr6, 0x8285e7f8
	if ctx.cr[6].eq {
	pc = 0x8285E7F8; continue 'dispatch;
	}
	// 8285E774: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285E778: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285E77C: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 8285E780: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285E784: 4E800421  bctrl
	ctx.lr = 0x8285E788;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285E788: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8285E78C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8285E790: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 8285E794: 396B9484  addi r11, r11, -0x6b7c
	ctx.r[11].s64 = ctx.r[11].s64 + -27516;
	// 8285E798: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 8285E79C: C1A10058  lfs f13, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8285E7A0: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 8285E7A4: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8285E7A8: C161005C  lfs f11, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8285E7AC: C1410054  lfs f10, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8285E7B0: ED2B02B2  fmuls f9, f11, f10
	ctx.f[9].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 8285E7B4: ED0C4B7A  fmadds f8, f12, f13, f9
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64);
	// 8285E7B8: C00B22AC  lfs f0, 0x22ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285E7BC: ECE0402C  fsqrts f7, f8
	ctx.f[7].f64 = ((ctx.f[8].f64).sqrt() as f32) as f64;
	// 8285E7C0: FF070000  fcmpu cr6, f7, f0
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[0].f64);
	// 8285E7C4: 4099002C  ble cr6, 0x8285e7f0
	if !ctx.cr[6].gt {
	pc = 0x8285E7F0; continue 'dispatch;
	}
	// 8285E7C8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E7CC: 4B9A9025  bl 0x822077f0
	ctx.lr = 0x8285E7D0;
	sub_822077F0(ctx, base);
	// 8285E7D0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8285E7D4: C1BE002C  lfs f13, 0x2c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8285E7D8: C80B9660  lfd f0, -0x69a0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 8285E7DC: FD810024  fdiv f12, f1, f0
	ctx.f[12].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 8285E7E0: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8285E7E4: ED4D582A  fadds f10, f13, f11
	ctx.f[10].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 8285E7E8: D15E002C  stfs f10, 0x2c(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8285E7EC: 4800000C  b 0x8285e7f8
	pc = 0x8285E7F8; continue 'dispatch;
            }
            0x8285E7F0 => {
    //   block [0x8285E7F0..0x8285E7F8)
	// 8285E7F0: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285E7F4: D01E002C  stfs f0, 0x2c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), tmp.u32 ) };
	pc = 0x8285E7F8; continue 'dispatch;
            }
            0x8285E7F8 => {
    //   block [0x8285E7F8..0x8285E83C)
	// 8285E7F8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E7FC: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 8285E800: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285E804: 5528A7FE  rlwinm r8, r9, 0x14, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000FFFu64;
	// 8285E808: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8285E80C: 419A00F4  beq cr6, 0x8285e900
	if ctx.cr[6].eq {
	pc = 0x8285E900; continue 'dispatch;
	}
	// 8285E810: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285E814: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285E818: 419A0024  beq cr6, 0x8285e83c
	if ctx.cr[6].eq {
	pc = 0x8285E83C; continue 'dispatch;
	}
	// 8285E81C: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 8285E820: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285E824: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285E828: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285E82C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E830: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8285E834: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E838: 480000CC  b 0x8285e904
	pc = 0x8285E904; continue 'dispatch;
            }
            0x8285E83C => {
    //   block [0x8285E83C..0x8285E858)
	// 8285E83C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285E840: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285E844: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8285E848: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285E84C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285E850: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285E854: 40810054  ble 0x8285e8a8
	if !ctx.cr[0].gt {
	pc = 0x8285E8A8; continue 'dispatch;
	}
	pc = 0x8285E858; continue 'dispatch;
            }
            0x8285E858 => {
    //   block [0x8285E858..0x8285E878)
	// 8285E858: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285E85C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285E860: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285E864: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285E868: 2F07002C  cmpwi cr6, r7, 0x2c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 44, &mut ctx.xer);
	// 8285E86C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285E870: 41980008  blt cr6, 0x8285e878
	if ctx.cr[6].lt {
	pc = 0x8285E878; continue 'dispatch;
	}
	// 8285E874: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8285E878; continue 'dispatch;
            }
            0x8285E878 => {
    //   block [0x8285E878..0x8285E894)
	// 8285E878: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285E87C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285E880: 419A0014  beq cr6, 0x8285e894
	if ctx.cr[6].eq {
	pc = 0x8285E894; continue 'dispatch;
	}
	// 8285E884: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285E888: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285E88C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285E890: 4800000C  b 0x8285e89c
	pc = 0x8285E89C; continue 'dispatch;
            }
            0x8285E894 => {
    //   block [0x8285E894..0x8285E89C)
	// 8285E894: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285E898: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285E89C; continue 'dispatch;
            }
            0x8285E89C => {
    //   block [0x8285E89C..0x8285E8A8)
	// 8285E89C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285E8A0: 4199FFB8  bgt cr6, 0x8285e858
	if ctx.cr[6].gt {
	pc = 0x8285E858; continue 'dispatch;
	}
	// 8285E8A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285E8A8; continue 'dispatch;
            }
            0x8285E8A8 => {
    //   block [0x8285E8A8..0x8285E8C4)
	// 8285E8A8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285E8AC: 419A0040  beq cr6, 0x8285e8ec
	if ctx.cr[6].eq {
	pc = 0x8285E8EC; continue 'dispatch;
	}
	// 8285E8B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285E8B4: 2F0B002C  cmpwi cr6, r11, 0x2c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 44, &mut ctx.xer);
	// 8285E8B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E8BC: 41990008  bgt cr6, 0x8285e8c4
	if ctx.cr[6].gt {
	pc = 0x8285E8C4; continue 'dispatch;
	}
	// 8285E8C0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8285E8C4; continue 'dispatch;
            }
            0x8285E8C4 => {
    //   block [0x8285E8C4..0x8285E8EC)
	// 8285E8C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285E8C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285E8CC: 409A0020  bne cr6, 0x8285e8ec
	if !ctx.cr[6].eq {
	pc = 0x8285E8EC; continue 'dispatch;
	}
	// 8285E8D0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285E8D4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285E8D8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285E8DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E8E0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8285E8E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E8E8: 4800001C  b 0x8285e904
	pc = 0x8285E904; continue 'dispatch;
            }
            0x8285E8EC => {
    //   block [0x8285E8EC..0x8285E900)
	// 8285E8EC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285E8F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E8F4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8285E8F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E8FC: 48000008  b 0x8285e904
	pc = 0x8285E904; continue 'dispatch;
            }
            0x8285E900 => {
    //   block [0x8285E900..0x8285E904)
	// 8285E900: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8285E904; continue 'dispatch;
            }
            0x8285E904 => {
    //   block [0x8285E904..0x8285E91C)
	// 8285E904: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285E908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285E90C: 419A0010  beq cr6, 0x8285e91c
	if ctx.cr[6].eq {
	pc = 0x8285E91C; continue 'dispatch;
	}
	// 8285E910: 816A0064  lwz r11, 0x64(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 8285E914: 6169000C  ori r9, r11, 0xc
	ctx.r[9].u64 = ctx.r[11].u64 | 12;
	// 8285E918: 912A0064  stw r9, 0x64(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	pc = 0x8285E91C; continue 'dispatch;
            }
            0x8285E91C => {
    //   block [0x8285E91C..0x8285E938)
	// 8285E91C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E920: C3FE002C  lfs f31, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8285E924: 4BFFBDA5  bl 0x8285a6c8
	ctx.lr = 0x8285E928;
	sub_8285A6C8(ctx, base);
	// 8285E928: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 8285E92C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E930: 41990008  bgt cr6, 0x8285e938
	if ctx.cr[6].gt {
	pc = 0x8285E938; continue 'dispatch;
	}
	// 8285E934: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8285E938; continue 'dispatch;
            }
            0x8285E938 => {
    //   block [0x8285E938..0x8285E994)
	// 8285E938: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285E93C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285E940: 419A0134  beq cr6, 0x8285ea74
	if ctx.cr[6].eq {
	pc = 0x8285EA74; continue 'dispatch;
	}
	// 8285E944: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8285E948: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285E94C: 419A0128  beq cr6, 0x8285ea74
	if ctx.cr[6].eq {
	pc = 0x8285EA74; continue 'dispatch;
	}
	// 8285E950: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E954: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8285E958: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285E95C: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8285E960: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285E964: 419A00F4  beq cr6, 0x8285ea58
	if ctx.cr[6].eq {
	pc = 0x8285EA58; continue 'dispatch;
	}
	// 8285E968: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285E96C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285E970: 419A0024  beq cr6, 0x8285e994
	if ctx.cr[6].eq {
	pc = 0x8285E994; continue 'dispatch;
	}
	// 8285E974: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 8285E978: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285E97C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285E980: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285E984: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285E988: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285E98C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285E990: 480000CC  b 0x8285ea5c
	pc = 0x8285EA5C; continue 'dispatch;
            }
            0x8285E994 => {
    //   block [0x8285E994..0x8285E9B0)
	// 8285E994: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285E998: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285E99C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8285E9A0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285E9A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285E9A8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285E9AC: 40810054  ble 0x8285ea00
	if !ctx.cr[0].gt {
	pc = 0x8285EA00; continue 'dispatch;
	}
	pc = 0x8285E9B0; continue 'dispatch;
            }
            0x8285E9B0 => {
    //   block [0x8285E9B0..0x8285E9D0)
	// 8285E9B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285E9B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285E9B8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285E9BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285E9C0: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 8285E9C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285E9C8: 41980008  blt cr6, 0x8285e9d0
	if ctx.cr[6].lt {
	pc = 0x8285E9D0; continue 'dispatch;
	}
	// 8285E9CC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8285E9D0; continue 'dispatch;
            }
            0x8285E9D0 => {
    //   block [0x8285E9D0..0x8285E9EC)
	// 8285E9D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285E9D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285E9D8: 419A0014  beq cr6, 0x8285e9ec
	if ctx.cr[6].eq {
	pc = 0x8285E9EC; continue 'dispatch;
	}
	// 8285E9DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285E9E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285E9E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285E9E8: 4800000C  b 0x8285e9f4
	pc = 0x8285E9F4; continue 'dispatch;
            }
            0x8285E9EC => {
    //   block [0x8285E9EC..0x8285E9F4)
	// 8285E9EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285E9F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285E9F4; continue 'dispatch;
            }
            0x8285E9F4 => {
    //   block [0x8285E9F4..0x8285EA00)
	// 8285E9F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285E9F8: 4199FFB8  bgt cr6, 0x8285e9b0
	if ctx.cr[6].gt {
	pc = 0x8285E9B0; continue 'dispatch;
	}
	// 8285E9FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285EA00; continue 'dispatch;
            }
            0x8285EA00 => {
    //   block [0x8285EA00..0x8285EA1C)
	// 8285EA00: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285EA04: 419A0040  beq cr6, 0x8285ea44
	if ctx.cr[6].eq {
	pc = 0x8285EA44; continue 'dispatch;
	}
	// 8285EA08: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285EA0C: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 8285EA10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EA14: 41990008  bgt cr6, 0x8285ea1c
	if ctx.cr[6].gt {
	pc = 0x8285EA1C; continue 'dispatch;
	}
	// 8285EA18: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8285EA1C; continue 'dispatch;
            }
            0x8285EA1C => {
    //   block [0x8285EA1C..0x8285EA44)
	// 8285EA1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285EA20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285EA24: 409A0020  bne cr6, 0x8285ea44
	if !ctx.cr[6].eq {
	pc = 0x8285EA44; continue 'dispatch;
	}
	// 8285EA28: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285EA2C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285EA30: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285EA34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EA38: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285EA3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EA40: 4800001C  b 0x8285ea5c
	pc = 0x8285EA5C; continue 'dispatch;
            }
            0x8285EA44 => {
    //   block [0x8285EA44..0x8285EA58)
	// 8285EA44: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285EA48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EA4C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285EA50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EA54: 48000008  b 0x8285ea5c
	pc = 0x8285EA5C; continue 'dispatch;
            }
            0x8285EA58 => {
    //   block [0x8285EA58..0x8285EA5C)
	// 8285EA58: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8285EA5C; continue 'dispatch;
            }
            0x8285EA5C => {
    //   block [0x8285EA5C..0x8285EA74)
	// 8285EA5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285EA60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285EA64: 419A0010  beq cr6, 0x8285ea74
	if ctx.cr[6].eq {
	pc = 0x8285EA74; continue 'dispatch;
	}
	// 8285EA68: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8285EA6C: 38800023  li r4, 0x23
	ctx.r[4].s64 = 35;
	// 8285EA70: 4BB8B041  bl 0x823e9ab0
	ctx.lr = 0x8285EA74;
	sub_823E9AB0(ctx, base);
	pc = 0x8285EA74; continue 'dispatch;
            }
            0x8285EA74 => {
    //   block [0x8285EA74..0x8285EA80)
	// 8285EA74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8285EA78: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8285EA7C: 4844A9E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285EA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285EA80 size=356
    let mut pc: u32 = 0x8285EA80;
    'dispatch: loop {
        match pc {
            0x8285EA80 => {
    //   block [0x8285EA80..0x8285EAD0)
	// 8285EA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285EA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285EA88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285EA8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285EA90: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EA94: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8285EA98: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 8285EA9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285EAA0: 419A00F8  beq cr6, 0x8285eb98
	if ctx.cr[6].eq {
	pc = 0x8285EB98; continue 'dispatch;
	}
	// 8285EAA4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285EAA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285EAAC: 419A0024  beq cr6, 0x8285ead0
	if ctx.cr[6].eq {
	pc = 0x8285EAD0; continue 'dispatch;
	}
	// 8285EAB0: 894A0063  lbz r10, 0x63(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(99 as u32) ) } as u64;
	// 8285EAB4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285EAB8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285EABC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285EAC0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EAC4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285EAC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EACC: 480000D4  b 0x8285eba0
	pc = 0x8285EBA0; continue 'dispatch;
            }
            0x8285EAD0 => {
    //   block [0x8285EAD0..0x8285EAF0)
	// 8285EAD0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285EAD4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8285EAD8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285EADC: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8285EAE0: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285EAE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285EAE8: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285EAEC: 40810054  ble 0x8285eb40
	if !ctx.cr[0].gt {
	pc = 0x8285EB40; continue 'dispatch;
	}
	pc = 0x8285EAF0; continue 'dispatch;
            }
            0x8285EAF0 => {
    //   block [0x8285EAF0..0x8285EB10)
	// 8285EAF0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285EAF4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285EAF8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285EAFC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285EB00: 2F070063  cmpwi cr6, r7, 0x63
	ctx.cr[6].compare_i32(ctx.r[7].s32, 99, &mut ctx.xer);
	// 8285EB04: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285EB08: 41980008  blt cr6, 0x8285eb10
	if ctx.cr[6].lt {
	pc = 0x8285EB10; continue 'dispatch;
	}
	// 8285EB0C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8285EB10; continue 'dispatch;
            }
            0x8285EB10 => {
    //   block [0x8285EB10..0x8285EB2C)
	// 8285EB10: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285EB14: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285EB18: 419A0014  beq cr6, 0x8285eb2c
	if ctx.cr[6].eq {
	pc = 0x8285EB2C; continue 'dispatch;
	}
	// 8285EB1C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285EB20: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285EB24: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285EB28: 4800000C  b 0x8285eb34
	pc = 0x8285EB34; continue 'dispatch;
            }
            0x8285EB2C => {
    //   block [0x8285EB2C..0x8285EB34)
	// 8285EB2C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285EB30: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285EB34; continue 'dispatch;
            }
            0x8285EB34 => {
    //   block [0x8285EB34..0x8285EB40)
	// 8285EB34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285EB38: 4199FFB8  bgt cr6, 0x8285eaf0
	if ctx.cr[6].gt {
	pc = 0x8285EAF0; continue 'dispatch;
	}
	// 8285EB3C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285EB40; continue 'dispatch;
            }
            0x8285EB40 => {
    //   block [0x8285EB40..0x8285EB5C)
	// 8285EB40: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285EB44: 419A0040  beq cr6, 0x8285eb84
	if ctx.cr[6].eq {
	pc = 0x8285EB84; continue 'dispatch;
	}
	// 8285EB48: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285EB4C: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 8285EB50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EB54: 41990008  bgt cr6, 0x8285eb5c
	if ctx.cr[6].gt {
	pc = 0x8285EB5C; continue 'dispatch;
	}
	// 8285EB58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285EB5C; continue 'dispatch;
            }
            0x8285EB5C => {
    //   block [0x8285EB5C..0x8285EB84)
	// 8285EB5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285EB60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285EB64: 409A0020  bne cr6, 0x8285eb84
	if !ctx.cr[6].eq {
	pc = 0x8285EB84; continue 'dispatch;
	}
	// 8285EB68: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285EB6C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285EB70: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285EB74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EB78: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285EB7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EB80: 48000020  b 0x8285eba0
	pc = 0x8285EBA0; continue 'dispatch;
            }
            0x8285EB84 => {
    //   block [0x8285EB84..0x8285EB98)
	// 8285EB84: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285EB88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EB8C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285EB90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EB94: 4800000C  b 0x8285eba0
	pc = 0x8285EBA0; continue 'dispatch;
            }
            0x8285EB98 => {
    //   block [0x8285EB98..0x8285EBA0)
	// 8285EB98: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285EB9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8285EBA0; continue 'dispatch;
            }
            0x8285EBA0 => {
    //   block [0x8285EBA0..0x8285EBC0)
	// 8285EBA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285EBA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285EBA8: 419A0028  beq cr6, 0x8285ebd0
	if ctx.cr[6].eq {
	pc = 0x8285EBD0; continue 'dispatch;
	}
	// 8285EBAC: 80830010  lwz r4, 0x10(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8285EBB0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8285EBB4: 419A000C  beq cr6, 0x8285ebc0
	if ctx.cr[6].eq {
	pc = 0x8285EBC0; continue 'dispatch;
	}
	// 8285EBB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285EBBC: 48065C6D  bl 0x828c4828
	ctx.lr = 0x8285EBC0;
	sub_828C4828(ctx, base);
	pc = 0x8285EBC0; continue 'dispatch;
            }
            0x8285EBC0 => {
    //   block [0x8285EBC0..0x8285EBD0)
	// 8285EBC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8285EBC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285EBC8: C02BB478  lfs f1, -0x4b88(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19336 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285EBCC: 4BA550E5  bl 0x822b3cb0
	ctx.lr = 0x8285EBD0;
	sub_822B3CB0(ctx, base);
	pc = 0x8285EBD0; continue 'dispatch;
            }
            0x8285EBD0 => {
    //   block [0x8285EBD0..0x8285EBE4)
	// 8285EBD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285EBD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285EBD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285EBDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285EBE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285EBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285EBE8 size=1676
    let mut pc: u32 = 0x8285EBE8;
    'dispatch: loop {
        match pc {
            0x8285EBE8 => {
    //   block [0x8285EBE8..0x8285EC3C)
	// 8285EBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285EBEC: 4844A819  bl 0x82ca9404
	ctx.lr = 0x8285EBF0;
	sub_82CA93D0(ctx, base);
	// 8285EBF0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285EBF4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8285EBF8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8285EBFC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8285EC00: 80BB0004  lwz r5, 4(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EC04: 81650030  lwz r11, 0x30(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) } as u64;
	// 8285EC08: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 8285EC0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285EC10: 419A00E8  beq cr6, 0x8285ecf8
	if ctx.cr[6].eq {
	pc = 0x8285ECF8; continue 'dispatch;
	}
	// 8285EC14: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285EC18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285EC1C: 419A0020  beq cr6, 0x8285ec3c
	if ctx.cr[6].eq {
	pc = 0x8285EC3C; continue 'dispatch;
	}
	// 8285EC20: 894B0063  lbz r10, 0x63(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(99 as u32) ) } as u64;
	// 8285EC24: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285EC28: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285EC2C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285EC30: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285EC34: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EC38: 480000C8  b 0x8285ed00
	pc = 0x8285ED00; continue 'dispatch;
            }
            0x8285EC3C => {
    //   block [0x8285EC3C..0x8285EC58)
	// 8285EC3C: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285EC40: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285EC44: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8285EC48: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285EC4C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8285EC50: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285EC54: 40810054  ble 0x8285eca8
	if !ctx.cr[0].gt {
	pc = 0x8285ECA8; continue 'dispatch;
	}
	pc = 0x8285EC58; continue 'dispatch;
            }
            0x8285EC58 => {
    //   block [0x8285EC58..0x8285EC78)
	// 8285EC58: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285EC5C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285EC60: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285EC64: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285EC68: 2F070063  cmpwi cr6, r7, 0x63
	ctx.cr[6].compare_i32(ctx.r[7].s32, 99, &mut ctx.xer);
	// 8285EC6C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285EC70: 41980008  blt cr6, 0x8285ec78
	if ctx.cr[6].lt {
	pc = 0x8285EC78; continue 'dispatch;
	}
	// 8285EC74: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8285EC78; continue 'dispatch;
            }
            0x8285EC78 => {
    //   block [0x8285EC78..0x8285EC94)
	// 8285EC78: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285EC7C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285EC80: 419A0014  beq cr6, 0x8285ec94
	if ctx.cr[6].eq {
	pc = 0x8285EC94; continue 'dispatch;
	}
	// 8285EC84: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285EC88: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285EC8C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285EC90: 4800000C  b 0x8285ec9c
	pc = 0x8285EC9C; continue 'dispatch;
            }
            0x8285EC94 => {
    //   block [0x8285EC94..0x8285EC9C)
	// 8285EC94: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285EC98: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285EC9C; continue 'dispatch;
            }
            0x8285EC9C => {
    //   block [0x8285EC9C..0x8285ECA8)
	// 8285EC9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285ECA0: 4199FFB8  bgt cr6, 0x8285ec58
	if ctx.cr[6].gt {
	pc = 0x8285EC58; continue 'dispatch;
	}
	// 8285ECA4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8285ECA8; continue 'dispatch;
            }
            0x8285ECA8 => {
    //   block [0x8285ECA8..0x8285ECC4)
	// 8285ECA8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285ECAC: 419A003C  beq cr6, 0x8285ece8
	if ctx.cr[6].eq {
	pc = 0x8285ECE8; continue 'dispatch;
	}
	// 8285ECB0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285ECB4: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 8285ECB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285ECBC: 41990008  bgt cr6, 0x8285ecc4
	if ctx.cr[6].gt {
	pc = 0x8285ECC4; continue 'dispatch;
	}
	// 8285ECC0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285ECC4; continue 'dispatch;
            }
            0x8285ECC4 => {
    //   block [0x8285ECC4..0x8285ECE8)
	// 8285ECC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285ECC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285ECCC: 409A001C  bne cr6, 0x8285ece8
	if !ctx.cr[6].eq {
	pc = 0x8285ECE8; continue 'dispatch;
	}
	// 8285ECD0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8285ECD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285ECD8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285ECDC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285ECE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285ECE4: 4800001C  b 0x8285ed00
	pc = 0x8285ED00; continue 'dispatch;
            }
            0x8285ECE8 => {
    //   block [0x8285ECE8..0x8285ECF8)
	// 8285ECE8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285ECEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285ECF0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285ECF4: 4800000C  b 0x8285ed00
	pc = 0x8285ED00; continue 'dispatch;
            }
            0x8285ECF8 => {
    //   block [0x8285ECF8..0x8285ED00)
	// 8285ECF8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285ECFC: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x8285ED00; continue 'dispatch;
            }
            0x8285ED00 => {
    //   block [0x8285ED00..0x8285ED10)
	// 8285ED00: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8285ED04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285ED08: 419A0008  beq cr6, 0x8285ed10
	if ctx.cr[6].eq {
	pc = 0x8285ED10; continue 'dispatch;
	}
	// 8285ED0C: 808B0010  lwz r4, 0x10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	pc = 0x8285ED10; continue 'dispatch;
            }
            0x8285ED10 => {
    //   block [0x8285ED10..0x8285ED58)
	// 8285ED10: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285ED14: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 8285ED18: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 8285ED1C: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 8285ED20: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 8285ED24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285ED28: 419A00F4  beq cr6, 0x8285ee1c
	if ctx.cr[6].eq {
	pc = 0x8285EE1C; continue 'dispatch;
	}
	// 8285ED2C: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285ED30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285ED34: 419A0024  beq cr6, 0x8285ed58
	if ctx.cr[6].eq {
	pc = 0x8285ED58; continue 'dispatch;
	}
	// 8285ED38: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8285ED3C: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285ED40: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285ED44: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285ED48: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285ED4C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285ED50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285ED54: 480000CC  b 0x8285ee20
	pc = 0x8285EE20; continue 'dispatch;
            }
            0x8285ED58 => {
    //   block [0x8285ED58..0x8285ED74)
	// 8285ED58: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285ED5C: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285ED60: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8285ED64: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285ED68: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8285ED6C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285ED70: 40810054  ble 0x8285edc4
	if !ctx.cr[0].gt {
	pc = 0x8285EDC4; continue 'dispatch;
	}
	pc = 0x8285ED74; continue 'dispatch;
            }
            0x8285ED74 => {
    //   block [0x8285ED74..0x8285ED94)
	// 8285ED74: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285ED78: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285ED7C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285ED80: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285ED84: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 8285ED88: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285ED8C: 41980008  blt cr6, 0x8285ed94
	if ctx.cr[6].lt {
	pc = 0x8285ED94; continue 'dispatch;
	}
	// 8285ED90: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8285ED94; continue 'dispatch;
            }
            0x8285ED94 => {
    //   block [0x8285ED94..0x8285EDB0)
	// 8285ED94: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285ED98: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285ED9C: 419A0014  beq cr6, 0x8285edb0
	if ctx.cr[6].eq {
	pc = 0x8285EDB0; continue 'dispatch;
	}
	// 8285EDA0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285EDA4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285EDA8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285EDAC: 4800000C  b 0x8285edb8
	pc = 0x8285EDB8; continue 'dispatch;
            }
            0x8285EDB0 => {
    //   block [0x8285EDB0..0x8285EDB8)
	// 8285EDB0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285EDB4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285EDB8; continue 'dispatch;
            }
            0x8285EDB8 => {
    //   block [0x8285EDB8..0x8285EDC4)
	// 8285EDB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285EDBC: 4199FFB8  bgt cr6, 0x8285ed74
	if ctx.cr[6].gt {
	pc = 0x8285ED74; continue 'dispatch;
	}
	// 8285EDC0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8285EDC4; continue 'dispatch;
            }
            0x8285EDC4 => {
    //   block [0x8285EDC4..0x8285EDE0)
	// 8285EDC4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285EDC8: 419A0040  beq cr6, 0x8285ee08
	if ctx.cr[6].eq {
	pc = 0x8285EE08; continue 'dispatch;
	}
	// 8285EDCC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285EDD0: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 8285EDD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EDD8: 41990008  bgt cr6, 0x8285ede0
	if ctx.cr[6].gt {
	pc = 0x8285EDE0; continue 'dispatch;
	}
	// 8285EDDC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285EDE0; continue 'dispatch;
            }
            0x8285EDE0 => {
    //   block [0x8285EDE0..0x8285EE08)
	// 8285EDE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285EDE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285EDE8: 409A0020  bne cr6, 0x8285ee08
	if !ctx.cr[6].eq {
	pc = 0x8285EE08; continue 'dispatch;
	}
	// 8285EDEC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8285EDF0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285EDF4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285EDF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EDFC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285EE00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EE04: 4800001C  b 0x8285ee20
	pc = 0x8285EE20; continue 'dispatch;
            }
            0x8285EE08 => {
    //   block [0x8285EE08..0x8285EE1C)
	// 8285EE08: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285EE0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EE10: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8285EE14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EE18: 48000008  b 0x8285ee20
	pc = 0x8285EE20; continue 'dispatch;
            }
            0x8285EE1C => {
    //   block [0x8285EE1C..0x8285EE20)
	// 8285EE1C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285EE20; continue 'dispatch;
            }
            0x8285EE20 => {
    //   block [0x8285EE20..0x8285EE68)
	// 8285EE20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285EE24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285EE28: 419A0444  beq cr6, 0x8285f26c
	if ctx.cr[6].eq {
	pc = 0x8285F26C; continue 'dispatch;
	}
	// 8285EE2C: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285EE30: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 8285EE34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285EE38: 419A00F4  beq cr6, 0x8285ef2c
	if ctx.cr[6].eq {
	pc = 0x8285EF2C; continue 'dispatch;
	}
	// 8285EE3C: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285EE40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285EE44: 419A0024  beq cr6, 0x8285ee68
	if ctx.cr[6].eq {
	pc = 0x8285EE68; continue 'dispatch;
	}
	// 8285EE48: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 8285EE4C: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285EE50: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285EE54: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285EE58: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EE5C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8285EE60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EE64: 480000CC  b 0x8285ef30
	pc = 0x8285EF30; continue 'dispatch;
            }
            0x8285EE68 => {
    //   block [0x8285EE68..0x8285EE84)
	// 8285EE68: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285EE6C: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285EE70: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8285EE74: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285EE78: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8285EE7C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285EE80: 40810054  ble 0x8285eed4
	if !ctx.cr[0].gt {
	pc = 0x8285EED4; continue 'dispatch;
	}
	pc = 0x8285EE84; continue 'dispatch;
            }
            0x8285EE84 => {
    //   block [0x8285EE84..0x8285EEA4)
	// 8285EE84: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285EE88: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285EE8C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285EE90: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285EE94: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8285EE98: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285EE9C: 41980008  blt cr6, 0x8285eea4
	if ctx.cr[6].lt {
	pc = 0x8285EEA4; continue 'dispatch;
	}
	// 8285EEA0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8285EEA4; continue 'dispatch;
            }
            0x8285EEA4 => {
    //   block [0x8285EEA4..0x8285EEC0)
	// 8285EEA4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285EEA8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285EEAC: 419A0014  beq cr6, 0x8285eec0
	if ctx.cr[6].eq {
	pc = 0x8285EEC0; continue 'dispatch;
	}
	// 8285EEB0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285EEB4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285EEB8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285EEBC: 4800000C  b 0x8285eec8
	pc = 0x8285EEC8; continue 'dispatch;
            }
            0x8285EEC0 => {
    //   block [0x8285EEC0..0x8285EEC8)
	// 8285EEC0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285EEC4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285EEC8; continue 'dispatch;
            }
            0x8285EEC8 => {
    //   block [0x8285EEC8..0x8285EED4)
	// 8285EEC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285EECC: 4199FFB8  bgt cr6, 0x8285ee84
	if ctx.cr[6].gt {
	pc = 0x8285EE84; continue 'dispatch;
	}
	// 8285EED0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8285EED4; continue 'dispatch;
            }
            0x8285EED4 => {
    //   block [0x8285EED4..0x8285EEF0)
	// 8285EED4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285EED8: 419A0040  beq cr6, 0x8285ef18
	if ctx.cr[6].eq {
	pc = 0x8285EF18; continue 'dispatch;
	}
	// 8285EEDC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285EEE0: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8285EEE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EEE8: 41990008  bgt cr6, 0x8285eef0
	if ctx.cr[6].gt {
	pc = 0x8285EEF0; continue 'dispatch;
	}
	// 8285EEEC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285EEF0; continue 'dispatch;
            }
            0x8285EEF0 => {
    //   block [0x8285EEF0..0x8285EF18)
	// 8285EEF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285EEF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285EEF8: 409A0020  bne cr6, 0x8285ef18
	if !ctx.cr[6].eq {
	pc = 0x8285EF18; continue 'dispatch;
	}
	// 8285EEFC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8285EF00: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285EF04: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285EF08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EF0C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8285EF10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EF14: 4800001C  b 0x8285ef30
	pc = 0x8285EF30; continue 'dispatch;
            }
            0x8285EF18 => {
    //   block [0x8285EF18..0x8285EF2C)
	// 8285EF18: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285EF1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EF20: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8285EF24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EF28: 48000008  b 0x8285ef30
	pc = 0x8285EF30; continue 'dispatch;
            }
            0x8285EF2C => {
    //   block [0x8285EF2C..0x8285EF30)
	// 8285EF2C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285EF30; continue 'dispatch;
            }
            0x8285EF30 => {
    //   block [0x8285EF30..0x8285EF78)
	// 8285EF30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285EF34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285EF38: 419A0334  beq cr6, 0x8285f26c
	if ctx.cr[6].eq {
	pc = 0x8285F26C; continue 'dispatch;
	}
	// 8285EF3C: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285EF40: 556AD7FE  rlwinm r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 8285EF44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285EF48: 419A00F0  beq cr6, 0x8285f038
	if ctx.cr[6].eq {
	pc = 0x8285F038; continue 'dispatch;
	}
	// 8285EF4C: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285EF50: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285EF54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285EF58: 419A0020  beq cr6, 0x8285ef78
	if ctx.cr[6].eq {
	pc = 0x8285EF78; continue 'dispatch;
	}
	// 8285EF5C: 896B0006  lbz r11, 6(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 8285EF60: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8285EF64: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8285EF68: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285EF6C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285EF70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EF74: 480000C8  b 0x8285f03c
	pc = 0x8285F03C; continue 'dispatch;
            }
            0x8285EF78 => {
    //   block [0x8285EF78..0x8285EF90)
	// 8285EF78: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285EF7C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8285EF80: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285EF84: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8285EF88: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285EF8C: 40810054  ble 0x8285efe0
	if !ctx.cr[0].gt {
	pc = 0x8285EFE0; continue 'dispatch;
	}
	pc = 0x8285EF90; continue 'dispatch;
            }
            0x8285EF90 => {
    //   block [0x8285EF90..0x8285EFB0)
	// 8285EF90: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285EF94: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285EF98: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285EF9C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285EFA0: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 8285EFA4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285EFA8: 41980008  blt cr6, 0x8285efb0
	if ctx.cr[6].lt {
	pc = 0x8285EFB0; continue 'dispatch;
	}
	// 8285EFAC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8285EFB0; continue 'dispatch;
            }
            0x8285EFB0 => {
    //   block [0x8285EFB0..0x8285EFCC)
	// 8285EFB0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285EFB4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285EFB8: 419A0014  beq cr6, 0x8285efcc
	if ctx.cr[6].eq {
	pc = 0x8285EFCC; continue 'dispatch;
	}
	// 8285EFBC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285EFC0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285EFC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285EFC8: 4800000C  b 0x8285efd4
	pc = 0x8285EFD4; continue 'dispatch;
            }
            0x8285EFCC => {
    //   block [0x8285EFCC..0x8285EFD4)
	// 8285EFCC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285EFD0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285EFD4; continue 'dispatch;
            }
            0x8285EFD4 => {
    //   block [0x8285EFD4..0x8285EFE0)
	// 8285EFD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285EFD8: 4199FFB8  bgt cr6, 0x8285ef90
	if ctx.cr[6].gt {
	pc = 0x8285EF90; continue 'dispatch;
	}
	// 8285EFDC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8285EFE0; continue 'dispatch;
            }
            0x8285EFE0 => {
    //   block [0x8285EFE0..0x8285EFFC)
	// 8285EFE0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285EFE4: 419A0040  beq cr6, 0x8285f024
	if ctx.cr[6].eq {
	pc = 0x8285F024; continue 'dispatch;
	}
	// 8285EFE8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285EFEC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 8285EFF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285EFF4: 41990008  bgt cr6, 0x8285effc
	if ctx.cr[6].gt {
	pc = 0x8285EFFC; continue 'dispatch;
	}
	// 8285EFF8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285EFFC; continue 'dispatch;
            }
            0x8285EFFC => {
    //   block [0x8285EFFC..0x8285F024)
	// 8285EFFC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285F000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285F004: 409A0020  bne cr6, 0x8285f024
	if !ctx.cr[6].eq {
	pc = 0x8285F024; continue 'dispatch;
	}
	// 8285F008: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8285F00C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8285F010: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285F014: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285F018: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285F01C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285F020: 4800001C  b 0x8285f03c
	pc = 0x8285F03C; continue 'dispatch;
            }
            0x8285F024 => {
    //   block [0x8285F024..0x8285F038)
	// 8285F024: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285F028: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285F02C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285F030: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285F034: 48000008  b 0x8285f03c
	pc = 0x8285F03C; continue 'dispatch;
            }
            0x8285F038 => {
    //   block [0x8285F038..0x8285F03C)
	// 8285F038: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285F03C; continue 'dispatch;
            }
            0x8285F03C => {
    //   block [0x8285F03C..0x8285F05C)
	// 8285F03C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285F040: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285F044: 419A0228  beq cr6, 0x8285f26c
	if ctx.cr[6].eq {
	pc = 0x8285F26C; continue 'dispatch;
	}
	// 8285F048: 2F040003  cmpwi cr6, r4, 3
	ctx.cr[6].compare_i32(ctx.r[4].s32, 3, &mut ctx.xer);
	// 8285F04C: 409A0010  bne cr6, 0x8285f05c
	if !ctx.cr[6].eq {
	pc = 0x8285F05C; continue 'dispatch;
	}
	// 8285F050: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285F054: 388BF3CC  addi r4, r11, -0xc34
	ctx.r[4].s64 = ctx.r[11].s64 + -3124;
	// 8285F058: 4800000C  b 0x8285f064
	pc = 0x8285F064; continue 'dispatch;
            }
            0x8285F05C => {
    //   block [0x8285F05C..0x8285F064)
	// 8285F05C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285F060: 388BF3DC  addi r4, r11, -0xc24
	ctx.r[4].s64 = ctx.r[11].s64 + -3108;
	pc = 0x8285F064; continue 'dispatch;
            }
            0x8285F064 => {
    //   block [0x8285F064..0x8285F158)
	// 8285F064: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285F068: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8285F06C: 4B9CDE65  bl 0x8222ced0
	ctx.lr = 0x8285F070;
	sub_8222CED0(ctx, base);
	// 8285F070: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8285F074: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8285F078: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8285F07C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8285F080: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8285F084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285F088: 4BA24CA9  bl 0x82283d30
	ctx.lr = 0x8285F08C;
	sub_82283D30(ctx, base);
	// 8285F08C: 3BFB0018  addi r31, r27, 0x18
	ctx.r[31].s64 = ctx.r[27].s64 + 24;
	// 8285F090: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285F094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285F098: 4BA13FC1  bl 0x82273058
	ctx.lr = 0x8285F09C;
	sub_82273058(ctx, base);
	// 8285F09C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8285F0A0: 4B9B5D39  bl 0x82214dd8
	ctx.lr = 0x8285F0A4;
	sub_82214DD8(ctx, base);
	// 8285F0A4: 807B0018  lwz r3, 0x18(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 8285F0A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285F0AC: 419A01C0  beq cr6, 0x8285f26c
	if ctx.cr[6].eq {
	pc = 0x8285F26C; continue 'dispatch;
	}
	// 8285F0B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F0B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8285F0B8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8285F0BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285F0C0: 4E800421  bctrl
	ctx.lr = 0x8285F0C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285F0C4: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 8285F0C8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8285F0CC: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 8285F0D0: 38890754  addi r4, r9, 0x754
	ctx.r[4].s64 = ctx.r[9].s64 + 1876;
	// 8285F0D4: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 8285F0D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8285F0DC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8285F0E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285F0E4: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 8285F0E8: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8285F0EC: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 8285F0F0: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 8285F0F4: 93810084  stw r28, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[28].u32 ) };
	// 8285F0F8: 9B810089  stb r28, 0x89(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(137 as u32), ctx.r[28].u8 ) };
	// 8285F0FC: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 8285F100: 93810094  stw r28, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[28].u32 ) };
	// 8285F104: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 8285F108: 938100A0  stw r28, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[28].u32 ) };
	// 8285F10C: 938100A4  stw r28, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[28].u32 ) };
	// 8285F110: 938100A8  stw r28, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[28].u32 ) };
	// 8285F114: 4B9CDDBD  bl 0x8222ced0
	ctx.lr = 0x8285F118;
	sub_8222CED0(ctx, base);
	// 8285F118: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285F11C: 809E0094  lwz r4, 0x94(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 8285F120: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8285F124: 4BF02B1D  bl 0x82761c40
	ctx.lr = 0x8285F128;
	sub_82761C40(ctx, base);
	// 8285F128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285F12C: 4B9B5CAD  bl 0x82214dd8
	ctx.lr = 0x8285F130;
	sub_82214DD8(ctx, base);
	// 8285F130: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8285F134: 4B9C0125  bl 0x8221f258
	ctx.lr = 0x8285F138;
	sub_8221F258(ctx, base);
	// 8285F138: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285F13C: 419A001C  beq cr6, 0x8285f158
	if ctx.cr[6].eq {
	pc = 0x8285F158; continue 'dispatch;
	}
	// 8285F140: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8285F144: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F148: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8285F14C: 4BF02C8D  bl 0x82761dd8
	ctx.lr = 0x8285F150;
	sub_82761DD8(ctx, base);
	// 8285F150: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285F154: 48000008  b 0x8285f15c
	pc = 0x8285F15C; continue 'dispatch;
            }
            0x8285F158 => {
    //   block [0x8285F158..0x8285F15C)
	// 8285F158: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x8285F15C; continue 'dispatch;
            }
            0x8285F15C => {
    //   block [0x8285F15C..0x8285F1AC)
	// 8285F15C: 387B0020  addi r3, r27, 0x20
	ctx.r[3].s64 = ctx.r[27].s64 + 32;
	// 8285F160: 4BA13EF9  bl 0x82273058
	ctx.lr = 0x8285F164;
	sub_82273058(ctx, base);
	// 8285F164: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8285F168: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8285F16C: 80BB0020  lwz r5, 0x20(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 8285F170: 3900000B  li r8, 0xb
	ctx.r[8].s64 = 11;
	// 8285F174: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8285F178: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 8285F17C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8285F180: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8285F184: 4BD03F35  bl 0x825630b8
	ctx.lr = 0x8285F188;
	sub_825630B8(ctx, base);
	// 8285F188: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285F18C: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285F190: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F194: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8285F198: 419A007C  beq cr6, 0x8285f214
	if ctx.cr[6].eq {
	pc = 0x8285F214; continue 'dispatch;
	}
	// 8285F19C: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8285F1A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285F1A4: 419A0040  beq cr6, 0x8285f1e4
	if ctx.cr[6].eq {
	pc = 0x8285F1E4; continue 'dispatch;
	}
	// 8285F1A8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8285F1AC; continue 'dispatch;
            }
            0x8285F1AC => {
    //   block [0x8285F1AC..0x8285F1E0)
	// 8285F1AC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8285F1B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285F1B4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8285F1B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285F1BC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285F1C0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285F1C4: 4082FFE8  bne 0x8285f1ac
	if !ctx.cr[0].eq {
	pc = 0x8285F1AC; continue 'dispatch;
	}
	// 8285F1C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285F1CC: 409A0014  bne cr6, 0x8285f1e0
	if !ctx.cr[6].eq {
	pc = 0x8285F1E0; continue 'dispatch;
	}
	// 8285F1D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F1D4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285F1D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285F1DC: 4E800421  bctrl
	ctx.lr = 0x8285F1E0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285F1E0 => {
    //   block [0x8285F1E0..0x8285F1E4)
	// 8285F1E0: 939B0028  stw r28, 0x28(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(40 as u32), ctx.r[28].u32 ) };
	pc = 0x8285F1E4; continue 'dispatch;
            }
            0x8285F1E4 => {
    //   block [0x8285F1E4..0x8285F1F8)
	// 8285F1E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F1E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285F1EC: 917B0028  stw r11, 0x28(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8285F1F0: 419A0024  beq cr6, 0x8285f214
	if ctx.cr[6].eq {
	pc = 0x8285F214; continue 'dispatch;
	}
	// 8285F1F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x8285F1F8; continue 'dispatch;
            }
            0x8285F1F8 => {
    //   block [0x8285F1F8..0x8285F214)
	// 8285F1F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285F1FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285F200: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285F204: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285F208: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285F20C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285F210: 4082FFE8  bne 0x8285f1f8
	if !ctx.cr[0].eq {
	pc = 0x8285F1F8; continue 'dispatch;
	}
	pc = 0x8285F214; continue 'dispatch;
            }
            0x8285F214 => {
    //   block [0x8285F214..0x8285F228)
	// 8285F214: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285F218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285F21C: 419A0048  beq cr6, 0x8285f264
	if ctx.cr[6].eq {
	pc = 0x8285F264; continue 'dispatch;
	}
	// 8285F220: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285F224: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x8285F228; continue 'dispatch;
            }
            0x8285F228 => {
    //   block [0x8285F228..0x8285F260)
	// 8285F228: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285F22C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285F230: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285F234: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8285F238: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285F23C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285F240: 4082FFE8  bne 0x8285f228
	if !ctx.cr[0].eq {
	pc = 0x8285F228; continue 'dispatch;
	}
	// 8285F244: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8285F248: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285F24C: 409A0014  bne cr6, 0x8285f260
	if !ctx.cr[6].eq {
	pc = 0x8285F260; continue 'dispatch;
	}
	// 8285F250: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F254: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285F258: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285F25C: 4E800421  bctrl
	ctx.lr = 0x8285F260;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285F260 => {
    //   block [0x8285F260..0x8285F264)
	// 8285F260: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	pc = 0x8285F264; continue 'dispatch;
            }
            0x8285F264 => {
    //   block [0x8285F264..0x8285F26C)
	// 8285F264: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8285F268: 4BFA84E9  bl 0x82807750
	ctx.lr = 0x8285F26C;
	sub_82807750(ctx, base);
	pc = 0x8285F26C; continue 'dispatch;
            }
            0x8285F26C => {
    //   block [0x8285F26C..0x8285F274)
	// 8285F26C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8285F270: 4844A1E4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285F278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285F278 size=168
    let mut pc: u32 = 0x8285F278;
    'dispatch: loop {
        match pc {
            0x8285F278 => {
    //   block [0x8285F278..0x8285F30C)
	// 8285F278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285F27C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285F280: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285F284: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285F288: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285F28C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8285F290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285F294: 419A0078  beq cr6, 0x8285f30c
	if ctx.cr[6].eq {
	pc = 0x8285F30C; continue 'dispatch;
	}
	// 8285F298: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285F29C: 4BFFB42D  bl 0x8285a6c8
	ctx.lr = 0x8285F2A0;
	sub_8285A6C8(ctx, base);
	// 8285F2A0: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8285F2A4: C01F002C  lfs f0, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285F2A8: ECE00824  fdivs f7, f0, f1
	ctx.f[7].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 8285F2AC: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8285F2B0: 4BA74399  bl 0x822d3648
	ctx.lr = 0x8285F2B4;
	sub_822D3648(ctx, base);
	// 8285F2B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8285F2B8: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8285F2BC: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 8285F2C0: 392B9484  addi r9, r11, -0x6b7c
	ctx.r[9].s64 = ctx.r[11].s64 + -27516;
	// 8285F2C4: 390A0E68  addi r8, r10, 0xe68
	ctx.r[8].s64 = ctx.r[10].s64 + 3688;
	// 8285F2C8: C1AB9484  lfs f13, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8285F2CC: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F2D0: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285F2D4: ECC70028  fsubs f6, f7, f0
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 8285F2D8: C1893710  lfs f12, 0x3710(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(14096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8285F2DC: ECA16028  fsubs f5, f1, f12
	ctx.f[5].f64 = (((ctx.f[1].f64 - ctx.f[12].f64) as f32) as f64);
	// 8285F2E0: 80C70014  lwz r6, 0x14(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 8285F2E4: FF066800  fcmpu cr6, f6, f13
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[13].f64);
	// 8285F2E8: 7CA00026  mfcr r5
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[5].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 8285F2EC: 54A4DF7A  rlwinm r4, r5, 0x1b, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 8285F2F0: 54ABF77A  rlwinm r11, r5, 0x1e, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x00000003u64;
	// 8285F2F4: 7C8A5B78  or r10, r4, r11
	ctx.r[10].u64 = ctx.r[4].u64 | ctx.r[11].u64;
	// 8285F2F8: 7C88542E  lfsx f4, r8, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8285F2FC: FC64382E  fsel f3, f4, f0, f7
	ctx.f[3].f64 = if ctx.f[4].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[7].f64 };
	// 8285F300: EC230172  fmuls f1, f3, f5
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[5].f64) as f32) as f64);
	// 8285F304: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 8285F308: 4E800421  bctrl
	ctx.lr = 0x8285F30C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285F30C => {
    //   block [0x8285F30C..0x8285F320)
	// 8285F30C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8285F310: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285F314: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285F318: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285F31C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285F320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285F320 size=480
    let mut pc: u32 = 0x8285F320;
    'dispatch: loop {
        match pc {
            0x8285F320 => {
    //   block [0x8285F320..0x8285F37C)
	// 8285F320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285F324: 4844A0E5  bl 0x82ca9408
	ctx.lr = 0x8285F328;
	sub_82CA93D0(ctx, base);
	// 8285F328: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285F32C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8285F330: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8285F334: 809D0028  lwz r4, 0x28(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285F338: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8285F33C: 419A0168  beq cr6, 0x8285f4a4
	if ctx.cr[6].eq {
	pc = 0x8285F4A4; continue 'dispatch;
	}
	// 8285F340: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285F344: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285F348: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 8285F34C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285F350: 419A00E8  beq cr6, 0x8285f438
	if ctx.cr[6].eq {
	pc = 0x8285F438; continue 'dispatch;
	}
	// 8285F354: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285F358: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285F35C: 419A0020  beq cr6, 0x8285f37c
	if ctx.cr[6].eq {
	pc = 0x8285F37C; continue 'dispatch;
	}
	// 8285F360: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 8285F364: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285F368: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285F36C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285F370: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285F374: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285F378: 480000C8  b 0x8285f440
	pc = 0x8285F440; continue 'dispatch;
            }
            0x8285F37C => {
    //   block [0x8285F37C..0x8285F398)
	// 8285F37C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285F380: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285F384: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8285F388: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285F38C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8285F390: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285F394: 40810054  ble 0x8285f3e8
	if !ctx.cr[0].gt {
	pc = 0x8285F3E8; continue 'dispatch;
	}
	pc = 0x8285F398; continue 'dispatch;
            }
            0x8285F398 => {
    //   block [0x8285F398..0x8285F3B8)
	// 8285F398: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285F39C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285F3A0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8285F3A4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F3A8: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8285F3AC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285F3B0: 41980008  blt cr6, 0x8285f3b8
	if ctx.cr[6].lt {
	pc = 0x8285F3B8; continue 'dispatch;
	}
	// 8285F3B4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8285F3B8; continue 'dispatch;
            }
            0x8285F3B8 => {
    //   block [0x8285F3B8..0x8285F3D4)
	// 8285F3B8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285F3BC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285F3C0: 419A0014  beq cr6, 0x8285f3d4
	if ctx.cr[6].eq {
	pc = 0x8285F3D4; continue 'dispatch;
	}
	// 8285F3C4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285F3C8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285F3CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285F3D0: 4800000C  b 0x8285f3dc
	pc = 0x8285F3DC; continue 'dispatch;
            }
            0x8285F3D4 => {
    //   block [0x8285F3D4..0x8285F3DC)
	// 8285F3D4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285F3D8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285F3DC; continue 'dispatch;
            }
            0x8285F3DC => {
    //   block [0x8285F3DC..0x8285F3E8)
	// 8285F3DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285F3E0: 4199FFB8  bgt cr6, 0x8285f398
	if ctx.cr[6].gt {
	pc = 0x8285F398; continue 'dispatch;
	}
	// 8285F3E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8285F3E8; continue 'dispatch;
            }
            0x8285F3E8 => {
    //   block [0x8285F3E8..0x8285F404)
	// 8285F3E8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285F3EC: 419A003C  beq cr6, 0x8285f428
	if ctx.cr[6].eq {
	pc = 0x8285F428; continue 'dispatch;
	}
	// 8285F3F0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F3F4: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8285F3F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285F3FC: 41990008  bgt cr6, 0x8285f404
	if ctx.cr[6].gt {
	pc = 0x8285F404; continue 'dispatch;
	}
	// 8285F400: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8285F404; continue 'dispatch;
            }
            0x8285F404 => {
    //   block [0x8285F404..0x8285F428)
	// 8285F404: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285F408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285F40C: 409A001C  bne cr6, 0x8285f428
	if !ctx.cr[6].eq {
	pc = 0x8285F428; continue 'dispatch;
	}
	// 8285F410: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8285F414: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285F418: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8285F41C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8285F420: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285F424: 4800001C  b 0x8285f440
	pc = 0x8285F440; continue 'dispatch;
            }
            0x8285F428 => {
    //   block [0x8285F428..0x8285F438)
	// 8285F428: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285F42C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8285F430: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285F434: 4800000C  b 0x8285f440
	pc = 0x8285F440; continue 'dispatch;
            }
            0x8285F438 => {
    //   block [0x8285F438..0x8285F440)
	// 8285F438: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285F43C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x8285F440; continue 'dispatch;
            }
            0x8285F440 => {
    //   block [0x8285F440..0x8285F468)
	// 8285F440: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8285F444: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285F448: 419A005C  beq cr6, 0x8285f4a4
	if ctx.cr[6].eq {
	pc = 0x8285F4A4; continue 'dispatch;
	}
	// 8285F44C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8285F450: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8285F454: 4BD03EF5  bl 0x82563348
	ctx.lr = 0x8285F458;
	sub_82563348(ctx, base);
	// 8285F458: 807D0028  lwz r3, 0x28(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8285F45C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285F460: 419A0040  beq cr6, 0x8285f4a0
	if ctx.cr[6].eq {
	pc = 0x8285F4A0; continue 'dispatch;
	}
	// 8285F464: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8285F468; continue 'dispatch;
            }
            0x8285F468 => {
    //   block [0x8285F468..0x8285F49C)
	// 8285F468: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8285F46C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285F470: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8285F474: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285F478: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285F47C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285F480: 4082FFE8  bne 0x8285f468
	if !ctx.cr[0].eq {
	pc = 0x8285F468; continue 'dispatch;
	}
	// 8285F484: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285F488: 409A0014  bne cr6, 0x8285f49c
	if !ctx.cr[6].eq {
	pc = 0x8285F49C; continue 'dispatch;
	}
	// 8285F48C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F490: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285F494: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285F498: 4E800421  bctrl
	ctx.lr = 0x8285F49C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285F49C => {
    //   block [0x8285F49C..0x8285F4A0)
	// 8285F49C: 939D0028  stw r28, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[28].u32 ) };
	pc = 0x8285F4A0; continue 'dispatch;
            }
            0x8285F4A0 => {
    //   block [0x8285F4A0..0x8285F4A4)
	// 8285F4A0: 939D0028  stw r28, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[28].u32 ) };
	pc = 0x8285F4A4; continue 'dispatch;
            }
            0x8285F4A4 => {
    //   block [0x8285F4A4..0x8285F4F8)
	// 8285F4A4: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 8285F4A8: 3BFD0018  addi r31, r29, 0x18
	ctx.r[31].s64 = ctx.r[29].s64 + 24;
	// 8285F4AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285F4B0: 419A0048  beq cr6, 0x8285f4f8
	if ctx.cr[6].eq {
	pc = 0x8285F4F8; continue 'dispatch;
	}
	// 8285F4B4: 807D0020  lwz r3, 0x20(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 8285F4B8: 3BDD0020  addi r30, r29, 0x20
	ctx.r[30].s64 = ctx.r[29].s64 + 32;
	// 8285F4BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F4C0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285F4C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285F4C8: 4E800421  bctrl
	ctx.lr = 0x8285F4CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285F4CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285F4D0: 4B958649  bl 0x821b7b18
	ctx.lr = 0x8285F4D4;
	sub_821B7B18(ctx, base);
	// 8285F4D4: 939D0020  stw r28, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	// 8285F4D8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F4DC: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F4E0: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285F4E4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8285F4E8: 4E800421  bctrl
	ctx.lr = 0x8285F4EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285F4EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285F4F0: 4B958629  bl 0x821b7b18
	ctx.lr = 0x8285F4F4;
	sub_821B7B18(ctx, base);
	// 8285F4F4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
            }
            0x8285F4F8 => {
    //   block [0x8285F4F8..0x8285F500)
	// 8285F4F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8285F4FC: 48449F5C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285F500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285F500 size=188
    let mut pc: u32 = 0x8285F500;
    'dispatch: loop {
        match pc {
            0x8285F500 => {
    //   block [0x8285F500..0x8285F534)
	// 8285F500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285F504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285F508: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285F50C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285F510: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285F514: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285F518: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8285F51C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8285F520: 4B9585F9  bl 0x821b7b18
	ctx.lr = 0x8285F524;
	sub_821B7B18(ctx, base);
	// 8285F524: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8285F528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285F52C: 419A0044  beq cr6, 0x8285f570
	if ctx.cr[6].eq {
	pc = 0x8285F570; continue 'dispatch;
	}
	// 8285F530: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8285F534; continue 'dispatch;
            }
            0x8285F534 => {
    //   block [0x8285F534..0x8285F568)
	// 8285F534: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8285F538: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285F53C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8285F540: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285F544: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285F548: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285F54C: 4082FFE8  bne 0x8285f534
	if !ctx.cr[0].eq {
	pc = 0x8285F534; continue 'dispatch;
	}
	// 8285F550: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285F554: 409A0014  bne cr6, 0x8285f568
	if !ctx.cr[6].eq {
	pc = 0x8285F568; continue 'dispatch;
	}
	// 8285F558: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F55C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285F560: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285F564: 4E800421  bctrl
	ctx.lr = 0x8285F568;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8285F568 => {
    //   block [0x8285F568..0x8285F570)
	// 8285F568: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8285F56C: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x8285F570; continue 'dispatch;
            }
            0x8285F570 => {
    //   block [0x8285F570..0x8285F5A4)
	// 8285F570: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 8285F574: 4B9585A5  bl 0x821b7b18
	ctx.lr = 0x8285F578;
	sub_821B7B18(ctx, base);
	// 8285F578: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8285F57C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 8285F580: 394BF058  addi r10, r11, -0xfa8
	ctx.r[10].s64 = ctx.r[11].s64 + -4008;
	// 8285F584: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8285F588: 4B9B5851  bl 0x82214dd8
	ctx.lr = 0x8285F58C;
	sub_82214DD8(ctx, base);
	// 8285F58C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8285F590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285F594: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285F598: 419A000C  beq cr6, 0x8285f5a4
	if ctx.cr[6].eq {
	pc = 0x8285F5A4; continue 'dispatch;
	}
	// 8285F59C: 4B9BC79D  bl 0x8221bd38
	ctx.lr = 0x8285F5A0;
	sub_8221BD38(ctx, base);
	// 8285F5A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8285F5A4; continue 'dispatch;
            }
            0x8285F5A4 => {
    //   block [0x8285F5A4..0x8285F5BC)
	// 8285F5A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285F5A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285F5AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285F5B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285F5B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285F5B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285F5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285F5C0 size=1152
    let mut pc: u32 = 0x8285F5C0;
    'dispatch: loop {
        match pc {
            0x8285F5C0 => {
    //   block [0x8285F5C0..0x8285FA40)
	// 8285F5C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285F5C4: 48449E11  bl 0x82ca93d4
	ctx.lr = 0x8285F5C8;
	sub_82CA93D0(ctx, base);
	// 8285F5C8: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 8285F5CC: 4844E709  bl 0x82cadcd4
	ctx.lr = 0x8285F5D0;
	sub_82CADCA0(ctx, base);
	// 8285F5D0: 3981FF40  addi r12, r1, -0xc0
	ctx.r[12].s64 = ctx.r[1].s64 + -192;
	// 8285F5D4: 487A7401  bl 0x830069d4
	ctx.lr = 0x8285F5D8;
	sub_83006760(ctx, base);
	// 8285F5D8: 9421FC80  stwu r1, -0x380(r1)
	ea = ctx.r[1].u32.wrapping_add(-896 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285F5DC: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 8285F5E0: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 8285F5E4: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 8285F5E8: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 8285F5EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8285F5F0: 7CB02B78  mr r16, r5
	ctx.r[16].u64 = ctx.r[5].u64;
	// 8285F5F4: 3A8BB480  addi r20, r11, -0x4b80
	ctx.r[20].s64 = ctx.r[11].s64 + -19328;
	// 8285F5F8: 8092007C  lwz r4, 0x7c(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(124 as u32) ) } as u64;
	// 8285F5FC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8285F600: C3F4E004  lfs f31, -0x1ffc(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-8188 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8285F604: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285F608: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8285F60C: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 8285F610: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285F614: 4E800421  bctrl
	ctx.lr = 0x8285F618;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285F618: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8285F61C: E8690000  ld r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 8285F620: E8890008  ld r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 8285F624: 4B996535  bl 0x821f5b58
	ctx.lr = 0x8285F628;
	sub_821F5B58(ctx, base);
	// 8285F628: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 8285F62C: C0142148  lfs f0, 0x2148(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285F630: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 8285F634: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8285F638: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 8285F63C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8285F640: 3BE79190  addi r31, r7, -0x6e70
	ctx.r[31].s64 = ctx.r[7].s64 + -28272;
	// 8285F644: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285FA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285FA40 size=596
    let mut pc: u32 = 0x8285FA40;
    'dispatch: loop {
        match pc {
            0x8285FA40 => {
    //   block [0x8285FA40..0x8285FAAC)
	// 8285FA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285FA44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285FA48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285FA4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285FA50: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8285FA54: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285FA58: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 8285FA5C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8285FA60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8285FA64: 892BEBAC  lbz r9, -0x1454(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5204 as u32) ) } as u64;
	// 8285FA68: C3EA9484  lfs f31, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8285FA6C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8285FA70: 419A00EC  beq cr6, 0x8285fb5c
	if ctx.cr[6].eq {
	pc = 0x8285FB5C; continue 'dispatch;
	}
	// 8285FA74: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285FA78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8285FA7C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8285FA80: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285FA84: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8285FA88: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8285FA8C: 4E800421  bctrl
	ctx.lr = 0x8285FA90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285FA90: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8285FA94: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8285FA98: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8285FA9C: 419A0010  beq cr6, 0x8285faac
	if ctx.cr[6].eq {
	pc = 0x8285FAAC; continue 'dispatch;
	}
	// 8285FAA0: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8285FAA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285FAA8: 419A0010  beq cr6, 0x8285fab8
	if ctx.cr[6].eq {
	pc = 0x8285FAB8; continue 'dispatch;
	}
            }
            0x8285FAAC => {
    //   block [0x8285FAAC..0x8285FAB8)
	// 8285FAAC: 556B06F6  rlwinm r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8285FAB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285FAB4: 419A00A8  beq cr6, 0x8285fb5c
	if ctx.cr[6].eq {
	pc = 0x8285FB5C; continue 'dispatch;
	}
	pc = 0x8285FAB8; continue 'dispatch;
            }
            0x8285FAB8 => {
    //   block [0x8285FAB8..0x8285FB0C)
	// 8285FAB8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8285FABC: C1BE0020  lfs f13, 0x20(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8285FAC0: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 8285FAC4: 3BFE0020  addi r31, r30, 0x20
	ctx.r[31].s64 = ctx.r[30].s64 + 32;
	// 8285FAC8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8285FACC: C00A0EEC  lfs f0, 0xeec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3820 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285FAD0: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8285FAD4: D19E0020  stfs f12, 0x20(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8285FAD8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8285FADC: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285FAE0: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285FAE4: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 8285FAE8: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285FAEC: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285FAF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285FAF4: 419A0018  beq cr6, 0x8285fb0c
	if ctx.cr[6].eq {
	pc = 0x8285FB0C; continue 'dispatch;
	}
	// 8285FAF8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8285FAFC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x8285FB0C; continue 'dispatch;
            }
            0x8285FB0C => {
    //   block [0x8285FB0C..0x8285FB5C)
	// 8285FB0C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8285FB10: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285FB14: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 8285FB18: 40980008  bge cr6, 0x8285fb20
	if !ctx.cr[6].lt {
	pc = 0x8285FB20; continue 'dispatch;
	}
	// 8285FB1C: D03F0000  stfs f1, 0(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8285FB20: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	pc = 0x8285FB5C; continue 'dispatch;
            }
            0x8285FB5C => {
    //   block [0x8285FB5C..0x8285FC94)
	// 8285FB5C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8285FB60: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8285FB64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285FB68: 409A0090  bne cr6, 0x8285fbf8
	if !ctx.cr[6].eq {
	pc = 0x8285FBF8; continue 'dispatch;
	}
	// 8285FB6C: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8285FB70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285FB74: 419A0010  beq cr6, 0x8285fb84
	if ctx.cr[6].eq {
	pc = 0x8285FB84; continue 'dispatch;
	}
	// 8285FB78: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8285FB7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285FB80: 409A0078  bne cr6, 0x8285fbf8
	if !ctx.cr[6].eq {
	pc = 0x8285FBF8; continue 'dispatch;
	}
	// 8285FB84: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285FB88: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8285FB8C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285FB90: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285FB94: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8285FB98: 4E800421  bctrl
	ctx.lr = 0x8285FB9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285FB9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285FBA0: 419A0058  beq cr6, 0x8285fbf8
	if ctx.cr[6].eq {
	pc = 0x8285FBF8; continue 'dispatch;
	}
	// 8285FBA4: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 8285FBA8: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8285FBAC: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8285FBB0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8285FBB4: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 8285FBB8: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8285FBBC: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 8285FBC0: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285FBC4: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 8285FBC8: C0091090  lfs f0, 0x1090(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285FBCC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8285FBD0: 80A70040  lwz r5, 0x40(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(64 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285FC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285FC98 size=2232
    let mut pc: u32 = 0x8285FC98;
    'dispatch: loop {
        match pc {
            0x8285FC98 => {
    //   block [0x8285FC98..0x8285FCF4)
	// 8285FC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285FC9C: 48449761  bl 0x82ca93fc
	ctx.lr = 0x8285FCA0;
	sub_82CA93D0(ctx, base);
	// 8285FCA0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8285FCA4: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285FCA8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8285FCAC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8285FCB0: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 8285FCB4: 80BA0004  lwz r5, 4(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285FCB8: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285FCBC: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 8285FCC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285FCC4: 419A00F4  beq cr6, 0x8285fdb8
	if ctx.cr[6].eq {
	pc = 0x8285FDB8; continue 'dispatch;
	}
	// 8285FCC8: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285FCCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285FCD0: 419A0024  beq cr6, 0x8285fcf4
	if ctx.cr[6].eq {
	pc = 0x8285FCF4; continue 'dispatch;
	}
	// 8285FCD4: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8285FCD8: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285FCDC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285FCE0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285FCE4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285FCE8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285FCEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285FCF0: 480000CC  b 0x8285fdbc
	pc = 0x8285FDBC; continue 'dispatch;
            }
            0x8285FCF4 => {
    //   block [0x8285FCF4..0x8285FD10)
	// 8285FCF4: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285FCF8: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285FCFC: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 8285FD00: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285FD04: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 8285FD08: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285FD0C: 40810054  ble 0x8285fd60
	if !ctx.cr[0].gt {
	pc = 0x8285FD60; continue 'dispatch;
	}
	pc = 0x8285FD10; continue 'dispatch;
            }
            0x8285FD10 => {
    //   block [0x8285FD10..0x8285FD30)
	// 8285FD10: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285FD14: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285FD18: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285FD1C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285FD20: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 8285FD24: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285FD28: 41980008  blt cr6, 0x8285fd30
	if ctx.cr[6].lt {
	pc = 0x8285FD30; continue 'dispatch;
	}
	// 8285FD2C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x8285FD30; continue 'dispatch;
            }
            0x8285FD30 => {
    //   block [0x8285FD30..0x8285FD4C)
	// 8285FD30: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285FD34: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285FD38: 419A0014  beq cr6, 0x8285fd4c
	if ctx.cr[6].eq {
	pc = 0x8285FD4C; continue 'dispatch;
	}
	// 8285FD3C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285FD40: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285FD44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285FD48: 4800000C  b 0x8285fd54
	pc = 0x8285FD54; continue 'dispatch;
            }
            0x8285FD4C => {
    //   block [0x8285FD4C..0x8285FD54)
	// 8285FD4C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285FD50: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285FD54; continue 'dispatch;
            }
            0x8285FD54 => {
    //   block [0x8285FD54..0x8285FD60)
	// 8285FD54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285FD58: 4199FFB8  bgt cr6, 0x8285fd10
	if ctx.cr[6].gt {
	pc = 0x8285FD10; continue 'dispatch;
	}
	// 8285FD5C: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	pc = 0x8285FD60; continue 'dispatch;
            }
            0x8285FD60 => {
    //   block [0x8285FD60..0x8285FD7C)
	// 8285FD60: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285FD64: 419A0040  beq cr6, 0x8285fda4
	if ctx.cr[6].eq {
	pc = 0x8285FDA4; continue 'dispatch;
	}
	// 8285FD68: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285FD6C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 8285FD70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285FD74: 41990008  bgt cr6, 0x8285fd7c
	if ctx.cr[6].gt {
	pc = 0x8285FD7C; continue 'dispatch;
	}
	// 8285FD78: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x8285FD7C; continue 'dispatch;
            }
            0x8285FD7C => {
    //   block [0x8285FD7C..0x8285FDA4)
	// 8285FD7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285FD80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285FD84: 409A0020  bne cr6, 0x8285fda4
	if !ctx.cr[6].eq {
	pc = 0x8285FDA4; continue 'dispatch;
	}
	// 8285FD88: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 8285FD8C: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 8285FD90: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8285FD94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285FD98: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285FD9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285FDA0: 4800001C  b 0x8285fdbc
	pc = 0x8285FDBC; continue 'dispatch;
            }
            0x8285FDA4 => {
    //   block [0x8285FDA4..0x8285FDB8)
	// 8285FDA4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285FDA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285FDAC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8285FDB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285FDB4: 48000008  b 0x8285fdbc
	pc = 0x8285FDBC; continue 'dispatch;
            }
            0x8285FDB8 => {
    //   block [0x8285FDB8..0x8285FDBC)
	// 8285FDB8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x8285FDBC; continue 'dispatch;
            }
            0x8285FDBC => {
    //   block [0x8285FDBC..0x8285FE08)
	// 8285FDBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285FDC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285FDC4: 419A0664  beq cr6, 0x82860428
	if ctx.cr[6].eq {
	pc = 0x82860428; continue 'dispatch;
	}
	// 8285FDC8: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 8285FDCC: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 8285FDD0: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 8285FDD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8285FDD8: 419A00F4  beq cr6, 0x8285fecc
	if ctx.cr[6].eq {
	pc = 0x8285FECC; continue 'dispatch;
	}
	// 8285FDDC: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8285FDE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285FDE4: 419A0024  beq cr6, 0x8285fe08
	if ctx.cr[6].eq {
	pc = 0x8285FE08; continue 'dispatch;
	}
	// 8285FDE8: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 8285FDEC: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285FDF0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8285FDF4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8285FDF8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285FDFC: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 8285FE00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285FE04: 480000CC  b 0x8285fed0
	pc = 0x8285FED0; continue 'dispatch;
            }
            0x8285FE08 => {
    //   block [0x8285FE08..0x8285FE24)
	// 8285FE08: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8285FE0C: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8285FE10: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 8285FE14: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8285FE18: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 8285FE1C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285FE20: 40810054  ble 0x8285fe74
	if !ctx.cr[0].gt {
	pc = 0x8285FE74; continue 'dispatch;
	}
	pc = 0x8285FE24; continue 'dispatch;
            }
            0x8285FE24 => {
    //   block [0x8285FE24..0x8285FE44)
	// 8285FE24: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8285FE28: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8285FE2C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8285FE30: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285FE34: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8285FE38: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8285FE3C: 41980008  blt cr6, 0x8285fe44
	if ctx.cr[6].lt {
	pc = 0x8285FE44; continue 'dispatch;
	}
	// 8285FE40: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x8285FE44; continue 'dispatch;
            }
            0x8285FE44 => {
    //   block [0x8285FE44..0x8285FE60)
	// 8285FE44: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8285FE48: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8285FE4C: 419A0014  beq cr6, 0x8285fe60
	if ctx.cr[6].eq {
	pc = 0x8285FE60; continue 'dispatch;
	}
	// 8285FE50: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8285FE54: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8285FE58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8285FE5C: 4800000C  b 0x8285fe68
	pc = 0x8285FE68; continue 'dispatch;
            }
            0x8285FE60 => {
    //   block [0x8285FE60..0x8285FE68)
	// 8285FE60: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8285FE64: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8285FE68; continue 'dispatch;
            }
            0x8285FE68 => {
    //   block [0x8285FE68..0x8285FE74)
	// 8285FE68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285FE6C: 4199FFB8  bgt cr6, 0x8285fe24
	if ctx.cr[6].gt {
	pc = 0x8285FE24; continue 'dispatch;
	}
	// 8285FE70: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	pc = 0x8285FE74; continue 'dispatch;
            }
            0x8285FE74 => {
    //   block [0x8285FE74..0x8285FE90)
	// 8285FE74: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8285FE78: 419A0040  beq cr6, 0x8285feb8
	if ctx.cr[6].eq {
	pc = 0x8285FEB8; continue 'dispatch;
	}
	// 8285FE7C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285FE80: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8285FE84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285FE88: 41990008  bgt cr6, 0x8285fe90
	if ctx.cr[6].gt {
	pc = 0x8285FE90; continue 'dispatch;
	}
	// 8285FE8C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x8285FE90; continue 'dispatch;
            }
            0x8285FE90 => {
    //   block [0x8285FE90..0x8285FEB8)
	// 8285FE90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285FE94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285FE98: 409A0020  bne cr6, 0x8285feb8
	if !ctx.cr[6].eq {
	pc = 0x8285FEB8; continue 'dispatch;
	}
	// 8285FE9C: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 8285FEA0: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 8285FEA4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8285FEA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285FEAC: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 8285FEB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285FEB4: 4800001C  b 0x8285fed0
	pc = 0x8285FED0; continue 'dispatch;
            }
            0x8285FEB8 => {
    //   block [0x8285FEB8..0x8285FECC)
	// 8285FEB8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8285FEBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285FEC0: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 8285FEC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8285FEC8: 48000008  b 0x8285fed0
	pc = 0x8285FED0; continue 'dispatch;
            }
            0x8285FECC => {
    //   block [0x8285FECC..0x8285FED0)
	// 8285FECC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x8285FED0; continue 'dispatch;
            }
            0x8285FED0 => {
    //   block [0x8285FED0..0x82860428)
	// 8285FED0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8285FED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285FED8: 419A0550  beq cr6, 0x82860428
	if ctx.cr[6].eq {
	pc = 0x82860428; continue 'dispatch;
	}
	// 8285FEDC: 8085007C  lwz r4, 0x7c(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(124 as u32) ) } as u64;
	// 8285FEE0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8285FEE4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285FEE8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8285FEEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8285FEF0: 4E800421  bctrl
	ctx.lr = 0x8285FEF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8285FEF4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8285FEF8: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 8285FEFC: C0010088  lfs f0, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285FF00: 3B8BC2F0  addi r28, r11, -0x3d10
	ctx.r[28].s64 = ctx.r[11].s64 + -15632;
	// 8285FF04: D01A0020  stfs f0, 0x20(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8285FF08: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
            }
            0x82860428 => {
    //   block [0x82860428..0x82860550)
	// 82860428: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286042C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 82860430: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82860434: 5528FFFE  rlwinm r8, r9, 0x1f, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82860438: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8286043C: 419A00F4  beq cr6, 0x82860530
	if ctx.cr[6].eq {
	pc = 0x82860530; continue 'dispatch;
	}
	// 82860440: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82860444: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82860448: 419A0024  beq cr6, 0x8286046c
	if ctx.cr[6].eq {
	pc = 0x8286046C; continue 'dispatch;
	}
	// 8286044C: 894A0061  lbz r10, 0x61(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(97 as u32) ) } as u64;
	// 82860450: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82860454: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82860458: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286045C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860460: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82860464: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860468: 480000CC  b 0x82860534
	pc = 0x82860534; continue 'dispatch;
	// 8286046C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82860470: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82860474: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 82860478: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8286047C: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82860480: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860484: 40810054  ble 0x828604d8
	if !ctx.cr[0].gt {
	pc = 0x828604D8; continue 'dispatch;
	}
	// 82860488: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286048C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82860490: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82860494: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860498: 2F070061  cmpwi cr6, r7, 0x61
	ctx.cr[6].compare_i32(ctx.r[7].s32, 97, &mut ctx.xer);
	// 8286049C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828604A0: 41980008  blt cr6, 0x828604a8
	if ctx.cr[6].lt {
	pc = 0x828604A8; continue 'dispatch;
	}
	// 828604A4: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828604A8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828604AC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828604B0: 419A0014  beq cr6, 0x828604c4
	if ctx.cr[6].eq {
	pc = 0x828604C4; continue 'dispatch;
	}
	// 828604B4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828604B8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828604BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828604C0: 4800000C  b 0x828604cc
	pc = 0x828604CC; continue 'dispatch;
	// 828604C4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828604C8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828604CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828604D0: 4199FFB8  bgt cr6, 0x82860488
	if ctx.cr[6].gt {
	pc = 0x82860488; continue 'dispatch;
	}
	// 828604D4: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 828604D8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828604DC: 419A0040  beq cr6, 0x8286051c
	if ctx.cr[6].eq {
	pc = 0x8286051C; continue 'dispatch;
	}
	// 828604E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828604E4: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 828604E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828604EC: 41990008  bgt cr6, 0x828604f4
	if ctx.cr[6].gt {
	pc = 0x828604F4; continue 'dispatch;
	}
	// 828604F0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828604F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828604F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828604FC: 409A0020  bne cr6, 0x8286051c
	if !ctx.cr[6].eq {
	pc = 0x8286051C; continue 'dispatch;
	}
	// 82860500: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82860504: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82860508: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8286050C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860510: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82860514: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860518: 4800001C  b 0x82860534
	pc = 0x82860534; continue 'dispatch;
	// 8286051C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82860520: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860524: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82860528: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286052C: 48000008  b 0x82860534
	pc = 0x82860534; continue 'dispatch;
	// 82860530: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82860534: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82860538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286053C: 419A0008  beq cr6, 0x82860544
	if ctx.cr[6].eq {
	pc = 0x82860544; continue 'dispatch;
	}
	// 82860540: 9B2A001D  stb r25, 0x1d(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(29 as u32), ctx.r[25].u8 ) };
	// 82860544: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82860548: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8286054C: 48448F00  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82860550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82860550 size=216
    let mut pc: u32 = 0x82860550;
    'dispatch: loop {
        match pc {
            0x82860550 => {
    //   block [0x82860550..0x82860628)
	// 82860550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82860554: 48448EB9  bl 0x82ca940c
	ctx.lr = 0x82860558;
	sub_82CA93D0(ctx, base);
	// 82860558: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286055C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82860560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860564: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860568: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8286056C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860570: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 82860574: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82860578: 4E800421  bctrl
	ctx.lr = 0x8286057C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286057C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82860580: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82860584: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82860588: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8286058C: 3FC0820A  lis r30, -0x7df6
	ctx.r[30].s64 = -2113273856;
	// 82860590: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82860594: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82860598: 38BE9490  addi r5, r30, -0x6b70
	ctx.r[5].s64 = ctx.r[30].s64 + -27504;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82860628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82860628 size=1516
    let mut pc: u32 = 0x82860628;
    'dispatch: loop {
        match pc {
            0x82860628 => {
    //   block [0x82860628..0x8286067C)
	// 82860628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286062C: 48448DE1  bl 0x82ca940c
	ctx.lr = 0x82860630;
	sub_82CA93D0(ctx, base);
	// 82860630: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82860634: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82860638: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8286063C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82860640: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860644: 81650030  lwz r11, 0x30(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) } as u64;
	// 82860648: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8286064C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82860650: 419A00E8  beq cr6, 0x82860738
	if ctx.cr[6].eq {
	pc = 0x82860738; continue 'dispatch;
	}
	// 82860654: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 82860658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286065C: 419A0020  beq cr6, 0x8286067c
	if ctx.cr[6].eq {
	pc = 0x8286067C; continue 'dispatch;
	}
	// 82860660: 894B0061  lbz r10, 0x61(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(97 as u32) ) } as u64;
	// 82860664: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 82860668: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8286066C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82860670: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82860674: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860678: 480000C8  b 0x82860740
	pc = 0x82860740; continue 'dispatch;
            }
            0x8286067C => {
    //   block [0x8286067C..0x82860698)
	// 8286067C: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 82860680: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 82860684: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82860688: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8286068C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82860690: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860694: 40810054  ble 0x828606e8
	if !ctx.cr[0].gt {
	pc = 0x828606E8; continue 'dispatch;
	}
	pc = 0x82860698; continue 'dispatch;
            }
            0x82860698 => {
    //   block [0x82860698..0x828606B8)
	// 82860698: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286069C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828606A0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828606A4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828606A8: 2F070061  cmpwi cr6, r7, 0x61
	ctx.cr[6].compare_i32(ctx.r[7].s32, 97, &mut ctx.xer);
	// 828606AC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828606B0: 41980008  blt cr6, 0x828606b8
	if ctx.cr[6].lt {
	pc = 0x828606B8; continue 'dispatch;
	}
	// 828606B4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x828606B8; continue 'dispatch;
            }
            0x828606B8 => {
    //   block [0x828606B8..0x828606D4)
	// 828606B8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828606BC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828606C0: 419A0014  beq cr6, 0x828606d4
	if ctx.cr[6].eq {
	pc = 0x828606D4; continue 'dispatch;
	}
	// 828606C4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828606C8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828606CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828606D0: 4800000C  b 0x828606dc
	pc = 0x828606DC; continue 'dispatch;
            }
            0x828606D4 => {
    //   block [0x828606D4..0x828606DC)
	// 828606D4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828606D8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828606DC; continue 'dispatch;
            }
            0x828606DC => {
    //   block [0x828606DC..0x828606E8)
	// 828606DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828606E0: 4199FFB8  bgt cr6, 0x82860698
	if ctx.cr[6].gt {
	pc = 0x82860698; continue 'dispatch;
	}
	// 828606E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828606E8; continue 'dispatch;
            }
            0x828606E8 => {
    //   block [0x828606E8..0x82860704)
	// 828606E8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828606EC: 419A003C  beq cr6, 0x82860728
	if ctx.cr[6].eq {
	pc = 0x82860728; continue 'dispatch;
	}
	// 828606F0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828606F4: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 828606F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828606FC: 41990008  bgt cr6, 0x82860704
	if ctx.cr[6].gt {
	pc = 0x82860704; continue 'dispatch;
	}
	// 82860700: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82860704; continue 'dispatch;
            }
            0x82860704 => {
    //   block [0x82860704..0x82860728)
	// 82860704: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82860708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286070C: 409A001C  bne cr6, 0x82860728
	if !ctx.cr[6].eq {
	pc = 0x82860728; continue 'dispatch;
	}
	// 82860710: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82860714: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82860718: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8286071C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82860720: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860724: 4800001C  b 0x82860740
	pc = 0x82860740; continue 'dispatch;
            }
            0x82860728 => {
    //   block [0x82860728..0x82860738)
	// 82860728: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286072C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82860730: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860734: 4800000C  b 0x82860740
	pc = 0x82860740; continue 'dispatch;
            }
            0x82860738 => {
    //   block [0x82860738..0x82860740)
	// 82860738: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286073C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x82860740; continue 'dispatch;
            }
            0x82860740 => {
    //   block [0x82860740..0x82860754)
	// 82860740: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82860744: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82860748: 419A000C  beq cr6, 0x82860754
	if ctx.cr[6].eq {
	pc = 0x82860754; continue 'dispatch;
	}
	// 8286074C: C3EB0084  lfs f31, 0x84(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82860750: 4800011C  b 0x8286086c
	pc = 0x8286086C; continue 'dispatch;
            }
            0x82860754 => {
    //   block [0x82860754..0x82860790)
	// 82860754: A1450030  lhz r10, 0x30(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) } as u64;
	// 82860758: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8286075C: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82860760: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82860764: 419A00E8  beq cr6, 0x8286084c
	if ctx.cr[6].eq {
	pc = 0x8286084C; continue 'dispatch;
	}
	// 82860768: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286076C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860770: 419A0020  beq cr6, 0x82860790
	if ctx.cr[6].eq {
	pc = 0x82860790; continue 'dispatch;
	}
	// 82860774: 894B0070  lbz r10, 0x70(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82860778: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286077C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82860780: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82860784: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82860788: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286078C: 480000C4  b 0x82860850
	pc = 0x82860850; continue 'dispatch;
            }
            0x82860790 => {
    //   block [0x82860790..0x828607AC)
	// 82860790: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 82860794: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 82860798: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8286079C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828607A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828607A4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828607A8: 40810054  ble 0x828607fc
	if !ctx.cr[0].gt {
	pc = 0x828607FC; continue 'dispatch;
	}
	pc = 0x828607AC; continue 'dispatch;
            }
            0x828607AC => {
    //   block [0x828607AC..0x828607CC)
	// 828607AC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828607B0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828607B4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828607B8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828607BC: 2F070070  cmpwi cr6, r7, 0x70
	ctx.cr[6].compare_i32(ctx.r[7].s32, 112, &mut ctx.xer);
	// 828607C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828607C4: 41980008  blt cr6, 0x828607cc
	if ctx.cr[6].lt {
	pc = 0x828607CC; continue 'dispatch;
	}
	// 828607C8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x828607CC; continue 'dispatch;
            }
            0x828607CC => {
    //   block [0x828607CC..0x828607E8)
	// 828607CC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828607D0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828607D4: 419A0014  beq cr6, 0x828607e8
	if ctx.cr[6].eq {
	pc = 0x828607E8; continue 'dispatch;
	}
	// 828607D8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828607DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828607E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828607E4: 4800000C  b 0x828607f0
	pc = 0x828607F0; continue 'dispatch;
            }
            0x828607E8 => {
    //   block [0x828607E8..0x828607F0)
	// 828607E8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828607EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828607F0; continue 'dispatch;
            }
            0x828607F0 => {
    //   block [0x828607F0..0x828607FC)
	// 828607F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828607F4: 4199FFB8  bgt cr6, 0x828607ac
	if ctx.cr[6].gt {
	pc = 0x828607AC; continue 'dispatch;
	}
	// 828607F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828607FC; continue 'dispatch;
            }
            0x828607FC => {
    //   block [0x828607FC..0x82860818)
	// 828607FC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82860800: 419A003C  beq cr6, 0x8286083c
	if ctx.cr[6].eq {
	pc = 0x8286083C; continue 'dispatch;
	}
	// 82860804: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860808: 2F0B0070  cmpwi cr6, r11, 0x70
	ctx.cr[6].compare_i32(ctx.r[11].s32, 112, &mut ctx.xer);
	// 8286080C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860810: 41990008  bgt cr6, 0x82860818
	if ctx.cr[6].gt {
	pc = 0x82860818; continue 'dispatch;
	}
	// 82860814: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82860818; continue 'dispatch;
            }
            0x82860818 => {
    //   block [0x82860818..0x8286083C)
	// 82860818: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286081C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860820: 409A001C  bne cr6, 0x8286083c
	if !ctx.cr[6].eq {
	pc = 0x8286083C; continue 'dispatch;
	}
	// 82860824: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82860828: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8286082C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82860830: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82860834: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860838: 48000018  b 0x82860850
	pc = 0x82860850; continue 'dispatch;
            }
            0x8286083C => {
    //   block [0x8286083C..0x8286084C)
	// 8286083C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82860840: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82860844: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860848: 48000008  b 0x82860850
	pc = 0x82860850; continue 'dispatch;
            }
            0x8286084C => {
    //   block [0x8286084C..0x82860850)
	// 8286084C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x82860850; continue 'dispatch;
            }
            0x82860850 => {
    //   block [0x82860850..0x8286086C)
	// 82860850: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82860854: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82860858: 419A0054  beq cr6, 0x828608ac
	if ctx.cr[6].eq {
	pc = 0x828608AC; continue 'dispatch;
	}
	// 8286085C: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82860860: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82860864: 419A0048  beq cr6, 0x828608ac
	if ctx.cr[6].eq {
	pc = 0x828608AC; continue 'dispatch;
	}
	// 82860868: C3EB0010  lfs f31, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x8286086C; continue 'dispatch;
            }
            0x8286086C => {
    //   block [0x8286086C..0x828608AC)
	// 8286086C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82860870: 8085007C  lwz r4, 0x7c(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(124 as u32) ) } as u64;
	// 82860874: 4B99534D  bl 0x821f5bc0
	ctx.lr = 0x82860878;
	sub_821F5BC0(ctx, base);
	// 82860878: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828608AC; continue 'dispatch;
            }
            0x828608AC => {
    //   block [0x828608AC..0x82860C14)
	// 828608AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828608B0: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828608B4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828608B8: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 828608BC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828608C0: 4E800421  bctrl
	ctx.lr = 0x828608C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828608C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828608C8: 419A0340  beq cr6, 0x82860c08
	if ctx.cr[6].eq {
	pc = 0x82860C08; continue 'dispatch;
	}
	// 828608CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828608D0: 4B92D431  bl 0x8218dd00
	ctx.lr = 0x828608D4;
	sub_8218DD00(ctx, base);
	// 828608D4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828608D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828608DC: 419A032C  beq cr6, 0x82860c08
	if ctx.cr[6].eq {
	pc = 0x82860C08; continue 'dispatch;
	}
	// 828608E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828608E4: 83EB0038  lwz r31, 0x38(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828608E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828608EC: 419A031C  beq cr6, 0x82860c08
	if ctx.cr[6].eq {
	pc = 0x82860C08; continue 'dispatch;
	}
	// 828608F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828608F4: 4BBBB92D  bl 0x8241c220
	ctx.lr = 0x828608F8;
	sub_8241C220(ctx, base);
	// 828608F8: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 828608FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860900: 409A0308  bne cr6, 0x82860c08
	if !ctx.cr[6].eq {
	pc = 0x82860C08; continue 'dispatch;
	}
	// 82860904: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860908: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8286090C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82860910: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860914: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 82860918: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8286091C: 4E800421  bctrl
	ctx.lr = 0x82860920;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82860920: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82860924: 81686AB8  lwz r11, 0x6ab8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82860928: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8286092C: 80C70058  lwz r6, 0x58(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 82860930: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860934: 80850008  lwz r4, 8(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82860938: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286093C: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82860940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860944: 419A0018  beq cr6, 0x8286095c
	if ctx.cr[6].eq {
	pc = 0x8286095C; continue 'dispatch;
	}
	// 82860948: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8286094C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82860C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82860C18 size=728
    let mut pc: u32 = 0x82860C18;
    'dispatch: loop {
        match pc {
            0x82860C18 => {
    //   block [0x82860C18..0x82860C84)
	// 82860C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82860C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82860C20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82860C24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82860C28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82860C2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82860C30: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82860C34: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82860C38: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82860C3C: 419A017C  beq cr6, 0x82860db8
	if ctx.cr[6].eq {
	pc = 0x82860DB8; continue 'dispatch;
	}
	// 82860C40: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860C44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82860C48: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82860C4C: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82860C50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82860C54: 419A00F4  beq cr6, 0x82860d48
	if ctx.cr[6].eq {
	pc = 0x82860D48; continue 'dispatch;
	}
	// 82860C58: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82860C5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82860C60: 419A0024  beq cr6, 0x82860c84
	if ctx.cr[6].eq {
	pc = 0x82860C84; continue 'dispatch;
	}
	// 82860C64: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 82860C68: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82860C6C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82860C70: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82860C74: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860C78: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82860C7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860C80: 480000CC  b 0x82860d4c
	pc = 0x82860D4C; continue 'dispatch;
            }
            0x82860C84 => {
    //   block [0x82860C84..0x82860CA0)
	// 82860C84: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82860C88: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82860C8C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82860C90: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82860C94: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82860C98: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860C9C: 40810054  ble 0x82860cf0
	if !ctx.cr[0].gt {
	pc = 0x82860CF0; continue 'dispatch;
	}
	pc = 0x82860CA0; continue 'dispatch;
            }
            0x82860CA0 => {
    //   block [0x82860CA0..0x82860CC0)
	// 82860CA0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82860CA4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82860CA8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82860CAC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860CB0: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82860CB4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82860CB8: 41980008  blt cr6, 0x82860cc0
	if ctx.cr[6].lt {
	pc = 0x82860CC0; continue 'dispatch;
	}
	// 82860CBC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82860CC0; continue 'dispatch;
            }
            0x82860CC0 => {
    //   block [0x82860CC0..0x82860CDC)
	// 82860CC0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82860CC4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82860CC8: 419A0014  beq cr6, 0x82860cdc
	if ctx.cr[6].eq {
	pc = 0x82860CDC; continue 'dispatch;
	}
	// 82860CCC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82860CD0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82860CD4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82860CD8: 4800000C  b 0x82860ce4
	pc = 0x82860CE4; continue 'dispatch;
            }
            0x82860CDC => {
    //   block [0x82860CDC..0x82860CE4)
	// 82860CDC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82860CE0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82860CE4; continue 'dispatch;
            }
            0x82860CE4 => {
    //   block [0x82860CE4..0x82860CF0)
	// 82860CE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860CE8: 4199FFB8  bgt cr6, 0x82860ca0
	if ctx.cr[6].gt {
	pc = 0x82860CA0; continue 'dispatch;
	}
	// 82860CEC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82860CF0; continue 'dispatch;
            }
            0x82860CF0 => {
    //   block [0x82860CF0..0x82860D0C)
	// 82860CF0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82860CF4: 419A0040  beq cr6, 0x82860d34
	if ctx.cr[6].eq {
	pc = 0x82860D34; continue 'dispatch;
	}
	// 82860CF8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860CFC: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82860D00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860D04: 41990008  bgt cr6, 0x82860d0c
	if ctx.cr[6].gt {
	pc = 0x82860D0C; continue 'dispatch;
	}
	// 82860D08: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82860D0C; continue 'dispatch;
            }
            0x82860D0C => {
    //   block [0x82860D0C..0x82860D34)
	// 82860D0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82860D10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860D14: 409A0020  bne cr6, 0x82860d34
	if !ctx.cr[6].eq {
	pc = 0x82860D34; continue 'dispatch;
	}
	// 82860D18: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82860D1C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82860D20: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82860D24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860D28: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82860D2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860D30: 4800001C  b 0x82860d4c
	pc = 0x82860D4C; continue 'dispatch;
            }
            0x82860D34 => {
    //   block [0x82860D34..0x82860D48)
	// 82860D34: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82860D38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860D3C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82860D40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860D44: 48000008  b 0x82860d4c
	pc = 0x82860D4C; continue 'dispatch;
            }
            0x82860D48 => {
    //   block [0x82860D48..0x82860D4C)
	// 82860D48: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82860D4C; continue 'dispatch;
            }
            0x82860D4C => {
    //   block [0x82860D4C..0x82860D70)
	// 82860D4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82860D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860D54: 419A0064  beq cr6, 0x82860db8
	if ctx.cr[6].eq {
	pc = 0x82860DB8; continue 'dispatch;
	}
	// 82860D58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82860D5C: 4BA4D2C5  bl 0x822ae020
	ctx.lr = 0x82860D60;
	sub_822AE020(ctx, base);
	// 82860D60: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82860D64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860D68: 419A0040  beq cr6, 0x82860da8
	if ctx.cr[6].eq {
	pc = 0x82860DA8; continue 'dispatch;
	}
	// 82860D6C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82860D70; continue 'dispatch;
            }
            0x82860D70 => {
    //   block [0x82860D70..0x82860DA4)
	// 82860D70: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82860D74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860D78: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82860D7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82860D80: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82860D84: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860D88: 4082FFE8  bne 0x82860d70
	if !ctx.cr[0].eq {
	pc = 0x82860D70; continue 'dispatch;
	}
	// 82860D8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860D90: 409A0014  bne cr6, 0x82860da4
	if !ctx.cr[6].eq {
	pc = 0x82860DA4; continue 'dispatch;
	}
	// 82860D94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860D98: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860D9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82860DA0: 4E800421  bctrl
	ctx.lr = 0x82860DA4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82860DA4 => {
    //   block [0x82860DA4..0x82860DA8)
	// 82860DA4: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	pc = 0x82860DA8; continue 'dispatch;
            }
            0x82860DA8 => {
    //   block [0x82860DA8..0x82860DB8)
	// 82860DA8: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82860DAC: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82860DB0: 4B956D69  bl 0x821b7b18
	ctx.lr = 0x82860DB4;
	sub_821B7B18(ctx, base);
	// 82860DB4: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	pc = 0x82860DB8; continue 'dispatch;
            }
            0x82860DB8 => {
    //   block [0x82860DB8..0x82860DFC)
	// 82860DB8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860DBC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82860DC0: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82860DC4: 5528FFFE  rlwinm r8, r9, 0x1f, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82860DC8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82860DCC: 419A00F4  beq cr6, 0x82860ec0
	if ctx.cr[6].eq {
	pc = 0x82860EC0; continue 'dispatch;
	}
	// 82860DD0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82860DD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82860DD8: 419A0024  beq cr6, 0x82860dfc
	if ctx.cr[6].eq {
	pc = 0x82860DFC; continue 'dispatch;
	}
	// 82860DDC: 892A0061  lbz r9, 0x61(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(97 as u32) ) } as u64;
	// 82860DE0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82860DE4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82860DE8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82860DEC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860DF0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82860DF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860DF8: 480000CC  b 0x82860ec4
	pc = 0x82860EC4; continue 'dispatch;
            }
            0x82860DFC => {
    //   block [0x82860DFC..0x82860E18)
	// 82860DFC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82860E00: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82860E04: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82860E08: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82860E0C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82860E10: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860E14: 40810054  ble 0x82860e68
	if !ctx.cr[0].gt {
	pc = 0x82860E68; continue 'dispatch;
	}
	pc = 0x82860E18; continue 'dispatch;
            }
            0x82860E18 => {
    //   block [0x82860E18..0x82860E38)
	// 82860E18: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82860E1C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82860E20: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82860E24: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860E28: 2F070061  cmpwi cr6, r7, 0x61
	ctx.cr[6].compare_i32(ctx.r[7].s32, 97, &mut ctx.xer);
	// 82860E2C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82860E30: 41980008  blt cr6, 0x82860e38
	if ctx.cr[6].lt {
	pc = 0x82860E38; continue 'dispatch;
	}
	// 82860E34: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82860E38; continue 'dispatch;
            }
            0x82860E38 => {
    //   block [0x82860E38..0x82860E54)
	// 82860E38: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82860E3C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82860E40: 419A0014  beq cr6, 0x82860e54
	if ctx.cr[6].eq {
	pc = 0x82860E54; continue 'dispatch;
	}
	// 82860E44: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82860E48: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82860E4C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82860E50: 4800000C  b 0x82860e5c
	pc = 0x82860E5C; continue 'dispatch;
            }
            0x82860E54 => {
    //   block [0x82860E54..0x82860E5C)
	// 82860E54: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82860E58: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82860E5C; continue 'dispatch;
            }
            0x82860E5C => {
    //   block [0x82860E5C..0x82860E68)
	// 82860E5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860E60: 4199FFB8  bgt cr6, 0x82860e18
	if ctx.cr[6].gt {
	pc = 0x82860E18; continue 'dispatch;
	}
	// 82860E64: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82860E68; continue 'dispatch;
            }
            0x82860E68 => {
    //   block [0x82860E68..0x82860E84)
	// 82860E68: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82860E6C: 419A0040  beq cr6, 0x82860eac
	if ctx.cr[6].eq {
	pc = 0x82860EAC; continue 'dispatch;
	}
	// 82860E70: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860E74: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 82860E78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860E7C: 41990008  bgt cr6, 0x82860e84
	if ctx.cr[6].gt {
	pc = 0x82860E84; continue 'dispatch;
	}
	// 82860E80: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82860E84; continue 'dispatch;
            }
            0x82860E84 => {
    //   block [0x82860E84..0x82860EAC)
	// 82860E84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82860E88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860E8C: 409A0020  bne cr6, 0x82860eac
	if !ctx.cr[6].eq {
	pc = 0x82860EAC; continue 'dispatch;
	}
	// 82860E90: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82860E94: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82860E98: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82860E9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860EA0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82860EA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860EA8: 4800001C  b 0x82860ec4
	pc = 0x82860EC4; continue 'dispatch;
            }
            0x82860EAC => {
    //   block [0x82860EAC..0x82860EC0)
	// 82860EAC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82860EB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860EB4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82860EB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860EBC: 48000008  b 0x82860ec4
	pc = 0x82860EC4; continue 'dispatch;
            }
            0x82860EC0 => {
    //   block [0x82860EC0..0x82860EC4)
	// 82860EC0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82860EC4; continue 'dispatch;
            }
            0x82860EC4 => {
    //   block [0x82860EC4..0x82860ED8)
	// 82860EC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82860EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860ECC: 419A000C  beq cr6, 0x82860ed8
	if ctx.cr[6].eq {
	pc = 0x82860ED8; continue 'dispatch;
	}
	// 82860ED0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860ED4: 996A001D  stb r11, 0x1d(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(29 as u32), ctx.r[11].u8 ) };
	pc = 0x82860ED8; continue 'dispatch;
            }
            0x82860ED8 => {
    //   block [0x82860ED8..0x82860EF0)
	// 82860ED8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82860EDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82860EE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82860EE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82860EE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82860EEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82860EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82860EF0 size=512
    let mut pc: u32 = 0x82860EF0;
    'dispatch: loop {
        match pc {
            0x82860EF0 => {
    //   block [0x82860EF0..0x82860F6C)
	// 82860EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82860EF4: 48448515  bl 0x82ca9408
	ctx.lr = 0x82860EF8;
	sub_82CA93D0(ctx, base);
	// 82860EF8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82860EFC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82860F00: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82860F04: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82860F08: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82860F0C: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 82860F10: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82860F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860F18: 419A01CC  beq cr6, 0x828610e4
	if ctx.cr[6].eq {
	pc = 0x828610E4; continue 'dispatch;
	}
	// 82860F1C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860F20: C01C0020  lfs f0, 0x20(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82860F24: C1BC0024  lfs f13, 0x24(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82860F28: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82860F2C: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82860F30: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82860F34: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 82860F38: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82860F3C: 419A00F4  beq cr6, 0x82861030
	if ctx.cr[6].eq {
	pc = 0x82861030; continue 'dispatch;
	}
	// 82860F40: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82860F44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82860F48: 419A0024  beq cr6, 0x82860f6c
	if ctx.cr[6].eq {
	pc = 0x82860F6C; continue 'dispatch;
	}
	// 82860F4C: 894A0039  lbz r10, 0x39(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 82860F50: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82860F54: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82860F58: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82860F5C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860F60: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82860F64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860F68: 480000CC  b 0x82861034
	pc = 0x82861034; continue 'dispatch;
            }
            0x82860F6C => {
    //   block [0x82860F6C..0x82860F88)
	// 82860F6C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82860F70: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82860F74: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82860F78: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82860F7C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82860F80: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860F84: 40810054  ble 0x82860fd8
	if !ctx.cr[0].gt {
	pc = 0x82860FD8; continue 'dispatch;
	}
	pc = 0x82860F88; continue 'dispatch;
            }
            0x82860F88 => {
    //   block [0x82860F88..0x82860FA8)
	// 82860F88: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82860F8C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82860F90: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82860F94: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860F98: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 82860F9C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82860FA0: 41980008  blt cr6, 0x82860fa8
	if ctx.cr[6].lt {
	pc = 0x82860FA8; continue 'dispatch;
	}
	// 82860FA4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82860FA8; continue 'dispatch;
            }
            0x82860FA8 => {
    //   block [0x82860FA8..0x82860FC4)
	// 82860FA8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82860FAC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82860FB0: 419A0014  beq cr6, 0x82860fc4
	if ctx.cr[6].eq {
	pc = 0x82860FC4; continue 'dispatch;
	}
	// 82860FB4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82860FB8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82860FBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82860FC0: 4800000C  b 0x82860fcc
	pc = 0x82860FCC; continue 'dispatch;
            }
            0x82860FC4 => {
    //   block [0x82860FC4..0x82860FCC)
	// 82860FC4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82860FC8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82860FCC; continue 'dispatch;
            }
            0x82860FCC => {
    //   block [0x82860FCC..0x82860FD8)
	// 82860FCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860FD0: 4199FFB8  bgt cr6, 0x82860f88
	if ctx.cr[6].gt {
	pc = 0x82860F88; continue 'dispatch;
	}
	// 82860FD4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82860FD8; continue 'dispatch;
            }
            0x82860FD8 => {
    //   block [0x82860FD8..0x82860FF4)
	// 82860FD8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82860FDC: 419A0040  beq cr6, 0x8286101c
	if ctx.cr[6].eq {
	pc = 0x8286101C; continue 'dispatch;
	}
	// 82860FE0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860FE4: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 82860FE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860FEC: 41990008  bgt cr6, 0x82860ff4
	if ctx.cr[6].gt {
	pc = 0x82860FF4; continue 'dispatch;
	}
	// 82860FF0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82860FF4; continue 'dispatch;
            }
            0x82860FF4 => {
    //   block [0x82860FF4..0x8286101C)
	// 82860FF4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82860FF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860FFC: 409A0020  bne cr6, 0x8286101c
	if !ctx.cr[6].eq {
	pc = 0x8286101C; continue 'dispatch;
	}
	// 82861000: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82861004: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82861008: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286100C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861010: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82861014: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861018: 4800001C  b 0x82861034
	pc = 0x82861034; continue 'dispatch;
            }
            0x8286101C => {
    //   block [0x8286101C..0x82861030)
	// 8286101C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82861020: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861024: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82861028: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286102C: 48000008  b 0x82861034
	pc = 0x82861034; continue 'dispatch;
            }
            0x82861030 => {
    //   block [0x82861030..0x82861034)
	// 82861030: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82861034; continue 'dispatch;
            }
            0x82861034 => {
    //   block [0x82861034..0x8286106C)
	// 82861034: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82861038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286103C: 419A0030  beq cr6, 0x8286106c
	if ctx.cr[6].eq {
	pc = 0x8286106C; continue 'dispatch;
	}
	// 82861040: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82861044: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82861048: 388BF5BC  addi r4, r11, -0xa44
	ctx.r[4].s64 = ctx.r[11].s64 + -2628;
	// 8286104C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82861050: 4B9CBE81  bl 0x8222ced0
	ctx.lr = 0x82861054;
	sub_8222CED0(ctx, base);
	// 82861054: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82861058: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 8286105C: 4B93B655  bl 0x8219c6b0
	ctx.lr = 0x82861060;
	sub_8219C6B0(ctx, base);
	// 82861060: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 82861064: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861068: 40980008  bge cr6, 0x82861070
	if !ctx.cr[6].lt {
	pc = 0x82861070; continue 'dispatch;
	}
	pc = 0x8286106C; continue 'dispatch;
            }
            0x8286106C => {
    //   block [0x8286106C..0x82861070)
	// 8286106C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82861070; continue 'dispatch;
            }
            0x82861070 => {
    //   block [0x82861070..0x82861088)
	// 82861070: 57EA07FE  clrlwi r10, r31, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 82861074: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82861078: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8286107C: 419A000C  beq cr6, 0x82861088
	if ctx.cr[6].eq {
	pc = 0x82861088; continue 'dispatch;
	}
	// 82861080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82861084: 4B9B3D55  bl 0x82214dd8
	ctx.lr = 0x82861088;
	sub_82214DD8(ctx, base);
	pc = 0x82861088; continue 'dispatch;
            }
            0x82861088 => {
    //   block [0x82861088..0x828610A0)
	// 82861088: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 8286108C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861090: 419A0010  beq cr6, 0x828610a0
	if ctx.cr[6].eq {
	pc = 0x828610A0; continue 'dispatch;
	}
	// 82861094: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 82861098: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286109C: 4BC77EED  bl 0x824d8f88
	ctx.lr = 0x828610A0;
	sub_824D8F88(ctx, base);
	pc = 0x828610A0; continue 'dispatch;
            }
            0x828610A0 => {
    //   block [0x828610A0..0x828610E4)
	// 828610A0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828610A4: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828610A8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828610AC: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 828610B0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828610B4: 4E800421  bctrl
	ctx.lr = 0x828610B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828610B8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828610BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828610C0: 419A0024  beq cr6, 0x828610e4
	if ctx.cr[6].eq {
	pc = 0x828610E4; continue 'dispatch;
	}
	// 828610C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828610C8: 4B92CC39  bl 0x8218dd00
	ctx.lr = 0x828610CC;
	sub_8218DD00(ctx, base);
	// 828610CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828610D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828610D4: 419A0010  beq cr6, 0x828610e4
	if ctx.cr[6].eq {
	pc = 0x828610E4; continue 'dispatch;
	}
	// 828610D8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828610DC: 809C0028  lwz r4, 0x28(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 828610E0: 4BA33BB1  bl 0x82294c90
	ctx.lr = 0x828610E4;
	sub_82294C90(ctx, base);
            }
            0x828610E4 => {
    //   block [0x828610E4..0x828610F0)
	// 828610E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828610E8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828610EC: 4844836C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828610F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828610F0 size=400
    let mut pc: u32 = 0x828610F0;
    'dispatch: loop {
        match pc {
            0x828610F0 => {
    //   block [0x828610F0..0x82861144)
	// 828610F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828610F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828610F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828610FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82861100: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82861104: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861108: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8286110C: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 82861110: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82861114: 419A00F8  beq cr6, 0x8286120c
	if ctx.cr[6].eq {
	pc = 0x8286120C; continue 'dispatch;
	}
	// 82861118: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286111C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82861120: 419A0024  beq cr6, 0x82861144
	if ctx.cr[6].eq {
	pc = 0x82861144; continue 'dispatch;
	}
	// 82861124: 894A005B  lbz r10, 0x5b(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(91 as u32) ) } as u64;
	// 82861128: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286112C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82861130: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82861134: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861138: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 8286113C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861140: 480000D0  b 0x82861210
	pc = 0x82861210; continue 'dispatch;
            }
            0x82861144 => {
    //   block [0x82861144..0x82861164)
	// 82861144: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82861148: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8286114C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82861150: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82861154: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82861158: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286115C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861160: 40810054  ble 0x828611b4
	if !ctx.cr[0].gt {
	pc = 0x828611B4; continue 'dispatch;
	}
	pc = 0x82861164; continue 'dispatch;
            }
            0x82861164 => {
    //   block [0x82861164..0x82861184)
	// 82861164: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82861168: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286116C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82861170: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861174: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 82861178: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286117C: 41980008  blt cr6, 0x82861184
	if ctx.cr[6].lt {
	pc = 0x82861184; continue 'dispatch;
	}
	// 82861180: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82861184; continue 'dispatch;
            }
            0x82861184 => {
    //   block [0x82861184..0x828611A0)
	// 82861184: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82861188: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286118C: 419A0014  beq cr6, 0x828611a0
	if ctx.cr[6].eq {
	pc = 0x828611A0; continue 'dispatch;
	}
	// 82861190: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82861194: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82861198: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286119C: 4800000C  b 0x828611a8
	pc = 0x828611A8; continue 'dispatch;
            }
            0x828611A0 => {
    //   block [0x828611A0..0x828611A8)
	// 828611A0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828611A4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828611A8; continue 'dispatch;
            }
            0x828611A8 => {
    //   block [0x828611A8..0x828611B4)
	// 828611A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828611AC: 4199FFB8  bgt cr6, 0x82861164
	if ctx.cr[6].gt {
	pc = 0x82861164; continue 'dispatch;
	}
	// 828611B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828611B4; continue 'dispatch;
            }
            0x828611B4 => {
    //   block [0x828611B4..0x828611D0)
	// 828611B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828611B8: 419A0040  beq cr6, 0x828611f8
	if ctx.cr[6].eq {
	pc = 0x828611F8; continue 'dispatch;
	}
	// 828611BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828611C0: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 828611C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828611C8: 41990008  bgt cr6, 0x828611d0
	if ctx.cr[6].gt {
	pc = 0x828611D0; continue 'dispatch;
	}
	// 828611CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828611D0; continue 'dispatch;
            }
            0x828611D0 => {
    //   block [0x828611D0..0x828611F8)
	// 828611D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828611D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828611D8: 409A0020  bne cr6, 0x828611f8
	if !ctx.cr[6].eq {
	pc = 0x828611F8; continue 'dispatch;
	}
	// 828611DC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828611E0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828611E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828611E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828611EC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 828611F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828611F4: 4800001C  b 0x82861210
	pc = 0x82861210; continue 'dispatch;
            }
            0x828611F8 => {
    //   block [0x828611F8..0x8286120C)
	// 828611F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828611FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861200: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82861204: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861208: 48000008  b 0x82861210
	pc = 0x82861210; continue 'dispatch;
            }
            0x8286120C => {
    //   block [0x8286120C..0x82861210)
	// 8286120C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82861210; continue 'dispatch;
            }
            0x82861210 => {
    //   block [0x82861210..0x82861270)
	// 82861210: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82861214: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861218: 419A0058  beq cr6, 0x82861270
	if ctx.cr[6].eq {
	pc = 0x82861270; continue 'dispatch;
	}
	// 8286121C: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 82861220: 4B9B38D9  bl 0x82214af8
	ctx.lr = 0x82861224;
	sub_82214AF8(ctx, base);
	// 82861224: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82861228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286122C: 419A0044  beq cr6, 0x82861270
	if ctx.cr[6].eq {
	pc = 0x82861270; continue 'dispatch;
	}
	// 82861230: 8165001C  lwz r11, 0x1c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 82861234: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82861238: 39200012  li r9, 0x12
	ctx.r[9].s64 = 18;
	// 8286123C: 38EA5D38  addi r7, r10, 0x5d38
	ctx.r[7].s64 = ctx.r[10].s64 + 23864;
	// 82861240: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82861244: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82861248: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8286124C: 80680004  lwz r3, 4(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861250: 4B951141  bl 0x821b2390
	ctx.lr = 0x82861254;
	sub_821B2390(ctx, base);
	// 82861254: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 82861258: 81666AB8  lwz r11, 0x6ab8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8286125C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82861260: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82861264: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82861268: 806B008C  lwz r3, 0x8c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286126C: 4BB3E3FD  bl 0x8239f668
	ctx.lr = 0x82861270;
	sub_8239F668(ctx, base);
	pc = 0x82861270; continue 'dispatch;
            }
            0x82861270 => {
    //   block [0x82861270..0x82861280)
	// 82861270: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82861274: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82861278: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286127C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82861280 size=8
    let mut pc: u32 = 0x82861280;
    'dispatch: loop {
        match pc {
            0x82861280 => {
    //   block [0x82861280..0x82861288)
	// 82861280: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82861284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82861288 size=672
    let mut pc: u32 = 0x82861288;
    'dispatch: loop {
        match pc {
            0x82861288 => {
    //   block [0x82861288..0x828612E0)
	// 82861288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286128C: 48448179  bl 0x82ca9404
	ctx.lr = 0x82861290;
	sub_82CA93D0(ctx, base);
	// 82861290: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82861294: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82861298: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8286129C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828612A0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828612A4: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828612A8: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 828612AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828612B0: 419A00F4  beq cr6, 0x828613a4
	if ctx.cr[6].eq {
	pc = 0x828613A4; continue 'dispatch;
	}
	// 828612B4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828612B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828612BC: 419A0024  beq cr6, 0x828612e0
	if ctx.cr[6].eq {
	pc = 0x828612E0; continue 'dispatch;
	}
	// 828612C0: 894A003A  lbz r10, 0x3a(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(58 as u32) ) } as u64;
	// 828612C4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828612C8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828612CC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828612D0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828612D4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828612D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828612DC: 480000CC  b 0x828613a8
	pc = 0x828613A8; continue 'dispatch;
            }
            0x828612E0 => {
    //   block [0x828612E0..0x828612FC)
	// 828612E0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828612E4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828612E8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828612EC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828612F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828612F4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828612F8: 40810054  ble 0x8286134c
	if !ctx.cr[0].gt {
	pc = 0x8286134C; continue 'dispatch;
	}
	pc = 0x828612FC; continue 'dispatch;
            }
            0x828612FC => {
    //   block [0x828612FC..0x8286131C)
	// 828612FC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82861300: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82861304: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82861308: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286130C: 2F07003A  cmpwi cr6, r7, 0x3a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 58, &mut ctx.xer);
	// 82861310: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82861314: 41980008  blt cr6, 0x8286131c
	if ctx.cr[6].lt {
	pc = 0x8286131C; continue 'dispatch;
	}
	// 82861318: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8286131C; continue 'dispatch;
            }
            0x8286131C => {
    //   block [0x8286131C..0x82861338)
	// 8286131C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82861320: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82861324: 419A0014  beq cr6, 0x82861338
	if ctx.cr[6].eq {
	pc = 0x82861338; continue 'dispatch;
	}
	// 82861328: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286132C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82861330: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82861334: 4800000C  b 0x82861340
	pc = 0x82861340; continue 'dispatch;
            }
            0x82861338 => {
    //   block [0x82861338..0x82861340)
	// 82861338: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286133C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82861340; continue 'dispatch;
            }
            0x82861340 => {
    //   block [0x82861340..0x8286134C)
	// 82861340: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861344: 4199FFB8  bgt cr6, 0x828612fc
	if ctx.cr[6].gt {
	pc = 0x828612FC; continue 'dispatch;
	}
	// 82861348: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8286134C; continue 'dispatch;
            }
            0x8286134C => {
    //   block [0x8286134C..0x82861368)
	// 8286134C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82861350: 419A0040  beq cr6, 0x82861390
	if ctx.cr[6].eq {
	pc = 0x82861390; continue 'dispatch;
	}
	// 82861354: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861358: 2F0B003A  cmpwi cr6, r11, 0x3a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 58, &mut ctx.xer);
	// 8286135C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861360: 41990008  bgt cr6, 0x82861368
	if ctx.cr[6].gt {
	pc = 0x82861368; continue 'dispatch;
	}
	// 82861364: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82861368; continue 'dispatch;
            }
            0x82861368 => {
    //   block [0x82861368..0x82861390)
	// 82861368: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286136C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861370: 409A0020  bne cr6, 0x82861390
	if !ctx.cr[6].eq {
	pc = 0x82861390; continue 'dispatch;
	}
	// 82861374: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82861378: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8286137C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82861380: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861384: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82861388: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286138C: 4800001C  b 0x828613a8
	pc = 0x828613A8; continue 'dispatch;
            }
            0x82861390 => {
    //   block [0x82861390..0x828613A4)
	// 82861390: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82861394: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861398: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8286139C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828613A0: 48000008  b 0x828613a8
	pc = 0x828613A8; continue 'dispatch;
            }
            0x828613A4 => {
    //   block [0x828613A4..0x828613A8)
	// 828613A4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828613A8; continue 'dispatch;
            }
            0x828613A8 => {
    //   block [0x828613A8..0x8286140C)
	// 828613A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828613AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828613B0: 419A0170  beq cr6, 0x82861520
	if ctx.cr[6].eq {
	pc = 0x82861520; continue 'dispatch;
	}
	// 828613B4: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 828613B8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828613BC: 409A0164  bne cr6, 0x82861520
	if !ctx.cr[6].eq {
	pc = 0x82861520; continue 'dispatch;
	}
	// 828613C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828613C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828613C8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828613CC: 4B986195  bl 0x821e7560
	ctx.lr = 0x828613D0;
	sub_821E7560(ctx, base);
	// 828613D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828613D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828613D8: 419A0034  beq cr6, 0x8286140c
	if ctx.cr[6].eq {
	pc = 0x8286140C; continue 'dispatch;
	}
	// 828613DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828613E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828613E4: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 828613E8: 4B986179  bl 0x821e7560
	ctx.lr = 0x828613EC;
	sub_821E7560(ctx, base);
	// 828613EC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828613F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828613F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828613F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828613FC: 4E800421  bctrl
	ctx.lr = 0x82861400;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82861400: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82861404: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82861408: 419A0008  beq cr6, 0x82861410
	if ctx.cr[6].eq {
	pc = 0x82861410; continue 'dispatch;
	}
            }
            0x8286140C => {
    //   block [0x8286140C..0x82861410)
	// 8286140C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82861410; continue 'dispatch;
            }
            0x82861410 => {
    //   block [0x82861410..0x8286142C)
	// 82861410: 57EA07BC  rlwinm r10, r31, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82861414: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82861418: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8286141C: 419A0010  beq cr6, 0x8286142c
	if ctx.cr[6].eq {
	pc = 0x8286142C; continue 'dispatch;
	}
	// 82861420: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82861424: 57FF07FA  rlwinm r31, r31, 0, 0x1f, 0x1d
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82861428: 4B9566F1  bl 0x821b7b18
	ctx.lr = 0x8286142C;
	sub_821B7B18(ctx, base);
	pc = 0x8286142C; continue 'dispatch;
            }
            0x8286142C => {
    //   block [0x8286142C..0x82861440)
	// 8286142C: 57EB07FE  clrlwi r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 82861430: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861434: 419A000C  beq cr6, 0x82861440
	if ctx.cr[6].eq {
	pc = 0x82861440; continue 'dispatch;
	}
	// 82861438: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286143C: 4B9566DD  bl 0x821b7b18
	ctx.lr = 0x82861440;
	sub_821B7B18(ctx, base);
	pc = 0x82861440; continue 'dispatch;
            }
            0x82861440 => {
    //   block [0x82861440..0x82861498)
	// 82861440: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82861444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861448: 419A00D8  beq cr6, 0x82861520
	if ctx.cr[6].eq {
	pc = 0x82861520; continue 'dispatch;
	}
	// 8286144C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861450: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82861454: 5549C7FE  rlwinm r9, r10, 0x18, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82861458: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8286145C: 419A003C  beq cr6, 0x82861498
	if ctx.cr[6].eq {
	pc = 0x82861498; continue 'dispatch;
	}
	// 82861460: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82861464: 4B9BDDF5  bl 0x8221f258
	ctx.lr = 0x82861468;
	sub_8221F258(ctx, base);
	// 82861468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286146C: 419A0078  beq cr6, 0x828614e4
	if ctx.cr[6].eq {
	pc = 0x828614E4; continue 'dispatch;
	}
	// 82861470: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82861474: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861478: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 8286147C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82861480: 38E8F654  addi r7, r8, -0x9ac
	ctx.r[7].s64 = ctx.r[8].s64 + -2476;
	// 82861484: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82861488: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8286148C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82861490: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82861494: 48000054  b 0x828614e8
	pc = 0x828614E8; continue 'dispatch;
            }
            0x82861498 => {
    //   block [0x82861498..0x828614E4)
	// 82861498: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 8286149C: 4B9BDDBD  bl 0x8221f258
	ctx.lr = 0x828614A0;
	sub_8221F258(ctx, base);
	// 828614A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828614A4: 419A0040  beq cr6, 0x828614e4
	if ctx.cr[6].eq {
	pc = 0x828614E4; continue 'dispatch;
	}
	// 828614A8: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828614AC: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828614B0: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 828614B4: 9B830008  stb r28, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[28].u8 ) };
	// 828614B8: 38E9E858  addi r7, r9, -0x17a8
	ctx.r[7].s64 = ctx.r[9].s64 + -6056;
	// 828614BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828614C0: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828614C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828614C8: C0089484  lfs f0, -0x6b7c(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828614CC: 9383000C  stw r28, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 828614D0: 93830010  stw r28, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	// 828614D4: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828614D8: 93830018  stw r28, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 828614DC: 9B83001C  stb r28, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[28].u8 ) };
	// 828614E0: 48000008  b 0x828614e8
	pc = 0x828614E8; continue 'dispatch;
            }
            0x828614E4 => {
    //   block [0x828614E4..0x828614E8)
	// 828614E4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828614E8; continue 'dispatch;
            }
            0x828614E8 => {
    //   block [0x828614E8..0x82861510)
	// 828614E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828614EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828614F0: 419A0020  beq cr6, 0x82861510
	if ctx.cr[6].eq {
	pc = 0x82861510; continue 'dispatch;
	}
	// 828614F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828614F8: 481A37C9  bl 0x82a04cc0
	ctx.lr = 0x828614FC;
	sub_82A04CC0(ctx, base);
	// 828614FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82861500: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82861504: 4BFE5AAD  bl 0x82846fb0
	ctx.lr = 0x82861508;
	sub_82846FB0(ctx, base);
	// 82861508: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8286150C: 48447F48  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82861510 => {
    //   block [0x82861510..0x82861520)
	// 82861510: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82861514: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82861518: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286151C: 4BFE5A95  bl 0x82846fb0
	ctx.lr = 0x82861520;
	sub_82846FB0(ctx, base);
	pc = 0x82861520; continue 'dispatch;
            }
            0x82861520 => {
    //   block [0x82861520..0x82861528)
	// 82861520: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82861524: 48447F30  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82861528 size=316
    let mut pc: u32 = 0x82861528;
    'dispatch: loop {
        match pc {
            0x82861528 => {
    //   block [0x82861528..0x82861578)
	// 82861528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286152C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82861530: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82861534: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861538: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8286153C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82861540: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 82861544: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82861548: 419A00F4  beq cr6, 0x8286163c
	if ctx.cr[6].eq {
	pc = 0x8286163C; continue 'dispatch;
	}
	// 8286154C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82861550: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82861554: 419A0024  beq cr6, 0x82861578
	if ctx.cr[6].eq {
	pc = 0x82861578; continue 'dispatch;
	}
	// 82861558: 894A003A  lbz r10, 0x3a(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(58 as u32) ) } as u64;
	// 8286155C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82861560: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82861564: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82861568: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286156C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82861570: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861574: 480000CC  b 0x82861640
	pc = 0x82861640; continue 'dispatch;
            }
            0x82861578 => {
    //   block [0x82861578..0x82861594)
	// 82861578: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286157C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82861580: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82861584: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82861588: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286158C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861590: 40810054  ble 0x828615e4
	if !ctx.cr[0].gt {
	pc = 0x828615E4; continue 'dispatch;
	}
	pc = 0x82861594; continue 'dispatch;
            }
            0x82861594 => {
    //   block [0x82861594..0x828615B4)
	// 82861594: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82861598: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286159C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828615A0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828615A4: 2F07003A  cmpwi cr6, r7, 0x3a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 58, &mut ctx.xer);
	// 828615A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828615AC: 41980008  blt cr6, 0x828615b4
	if ctx.cr[6].lt {
	pc = 0x828615B4; continue 'dispatch;
	}
	// 828615B0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x828615B4; continue 'dispatch;
            }
            0x828615B4 => {
    //   block [0x828615B4..0x828615D0)
	// 828615B4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828615B8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828615BC: 419A0014  beq cr6, 0x828615d0
	if ctx.cr[6].eq {
	pc = 0x828615D0; continue 'dispatch;
	}
	// 828615C0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828615C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828615C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828615CC: 4800000C  b 0x828615d8
	pc = 0x828615D8; continue 'dispatch;
            }
            0x828615D0 => {
    //   block [0x828615D0..0x828615D8)
	// 828615D0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828615D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828615D8; continue 'dispatch;
            }
            0x828615D8 => {
    //   block [0x828615D8..0x828615E4)
	// 828615D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828615DC: 4199FFB8  bgt cr6, 0x82861594
	if ctx.cr[6].gt {
	pc = 0x82861594; continue 'dispatch;
	}
	// 828615E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828615E4; continue 'dispatch;
            }
            0x828615E4 => {
    //   block [0x828615E4..0x82861600)
	// 828615E4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828615E8: 419A0040  beq cr6, 0x82861628
	if ctx.cr[6].eq {
	pc = 0x82861628; continue 'dispatch;
	}
	// 828615EC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828615F0: 2F0B003A  cmpwi cr6, r11, 0x3a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 58, &mut ctx.xer);
	// 828615F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828615F8: 41990008  bgt cr6, 0x82861600
	if ctx.cr[6].gt {
	pc = 0x82861600; continue 'dispatch;
	}
	// 828615FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82861600; continue 'dispatch;
            }
            0x82861600 => {
    //   block [0x82861600..0x82861628)
	// 82861600: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82861604: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861608: 409A0020  bne cr6, 0x82861628
	if !ctx.cr[6].eq {
	pc = 0x82861628; continue 'dispatch;
	}
	// 8286160C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82861610: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82861614: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82861618: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286161C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82861620: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861624: 4800001C  b 0x82861640
	pc = 0x82861640; continue 'dispatch;
            }
            0x82861628 => {
    //   block [0x82861628..0x8286163C)
	// 82861628: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286162C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861630: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82861634: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861638: 48000008  b 0x82861640
	pc = 0x82861640; continue 'dispatch;
            }
            0x8286163C => {
    //   block [0x8286163C..0x82861640)
	// 8286163C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82861640; continue 'dispatch;
            }
            0x82861640 => {
    //   block [0x82861640..0x82861654)
	// 82861640: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82861644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861648: 419A000C  beq cr6, 0x82861654
	if ctx.cr[6].eq {
	pc = 0x82861654; continue 'dispatch;
	}
	// 8286164C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82861650: 4BFE5A71  bl 0x828470c0
	ctx.lr = 0x82861654;
	sub_828470C0(ctx, base);
	pc = 0x82861654; continue 'dispatch;
            }
            0x82861654 => {
    //   block [0x82861654..0x82861664)
	// 82861654: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82861658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286165C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82861660: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82861668 size=108
    let mut pc: u32 = 0x82861668;
    'dispatch: loop {
        match pc {
            0x82861668 => {
    //   block [0x82861668..0x828616B8)
	// 82861668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286166C: 48447D9D  bl 0x82ca9408
	ctx.lr = 0x82861670;
	sub_82CA93D0(ctx, base);
	// 82861670: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82861674: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82861678: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8286167C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82861680: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82861684: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82861688: 388BF63C  addi r4, r11, -0x9c4
	ctx.r[4].s64 = ctx.r[11].s64 + -2500;
	// 8286168C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82861690: 4BA48359  bl 0x822a99e8
	ctx.lr = 0x82861694;
	sub_822A99E8(ctx, base);
	// 82861694: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82861698: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8286169C: 419A001C  beq cr6, 0x828616b8
	if ctx.cr[6].eq {
	pc = 0x828616B8; continue 'dispatch;
	}
	// 828616A0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828616A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828616A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828616AC: 4B9807BD  bl 0x821e1e68
	ctx.lr = 0x828616B0;
	sub_821E1E68(ctx, base);
	// 828616B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828616B4: 409A0018  bne cr6, 0x828616cc
	if !ctx.cr[6].eq {
	pc = 0x828616CC; continue 'dispatch;
	}
	pc = 0x828616B8; continue 'dispatch;
            }
            0x828616B8 => {
    //   block [0x828616B8..0x828616CC)
	// 828616B8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828616BC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828616C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828616C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828616C8: 4B9807A1  bl 0x821e1e68
	ctx.lr = 0x828616CC;
	sub_821E1E68(ctx, base);
	pc = 0x828616CC; continue 'dispatch;
            }
            0x828616CC => {
    //   block [0x828616CC..0x828616D4)
	// 828616CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828616D0: 48447D88  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828616D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828616D8 size=8
    let mut pc: u32 = 0x828616D8;
    'dispatch: loop {
        match pc {
            0x828616D8 => {
    //   block [0x828616D8..0x828616E0)
	// 828616D8: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 828616DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828616E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828616E0 size=8
    let mut pc: u32 = 0x828616E0;
    'dispatch: loop {
        match pc {
            0x828616E0 => {
    //   block [0x828616E0..0x828616E8)
	// 828616E0: 38600021  li r3, 0x21
	ctx.r[3].s64 = 33;
	// 828616E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828616E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828616E8 size=8
    let mut pc: u32 = 0x828616E8;
    'dispatch: loop {
        match pc {
            0x828616E8 => {
    //   block [0x828616E8..0x828616F0)
	// 828616E8: 38600027  li r3, 0x27
	ctx.r[3].s64 = 39;
	// 828616EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828616F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828616F0 size=188
    let mut pc: u32 = 0x828616F0;
    'dispatch: loop {
        match pc {
            0x828616F0 => {
    //   block [0x828616F0..0x8286172C)
	// 828616F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828616F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828616F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828616FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82861700: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82861704: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82861708: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8286170C: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82861710: 4B956409  bl 0x821b7b18
	ctx.lr = 0x82861714;
	sub_821B7B18(ctx, base);
	// 82861714: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82861718: 4B956401  bl 0x821b7b18
	ctx.lr = 0x8286171C;
	sub_821B7B18(ctx, base);
	// 8286171C: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82861720: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82861724: 419A0044  beq cr6, 0x82861768
	if ctx.cr[6].eq {
	pc = 0x82861768; continue 'dispatch;
	}
	// 82861728: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8286172C; continue 'dispatch;
            }
            0x8286172C => {
    //   block [0x8286172C..0x82861760)
	// 8286172C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82861730: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861734: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82861738: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286173C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82861740: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861744: 4082FFE8  bne 0x8286172c
	if !ctx.cr[0].eq {
	pc = 0x8286172C; continue 'dispatch;
	}
	// 82861748: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286174C: 409A0014  bne cr6, 0x82861760
	if !ctx.cr[6].eq {
	pc = 0x82861760; continue 'dispatch;
	}
	// 82861750: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861754: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861758: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286175C: 4E800421  bctrl
	ctx.lr = 0x82861760;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82861760 => {
    //   block [0x82861760..0x82861768)
	// 82861760: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82861764: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82861768; continue 'dispatch;
            }
            0x82861768 => {
    //   block [0x82861768..0x82861794)
	// 82861768: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8286176C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82861770: 394BF058  addi r10, r11, -0xfa8
	ctx.r[10].s64 = ctx.r[11].s64 + -4008;
	// 82861774: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82861778: 4B9B3661  bl 0x82214dd8
	ctx.lr = 0x8286177C;
	sub_82214DD8(ctx, base);
	// 8286177C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82861780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82861784: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82861788: 419A000C  beq cr6, 0x82861794
	if ctx.cr[6].eq {
	pc = 0x82861794; continue 'dispatch;
	}
	// 8286178C: 4B9BA5AD  bl 0x8221bd38
	ctx.lr = 0x82861790;
	sub_8221BD38(ctx, base);
	// 82861790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82861794; continue 'dispatch;
            }
            0x82861794 => {
    //   block [0x82861794..0x828617AC)
	// 82861794: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82861798: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286179C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828617A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828617A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828617A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828617B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828617B0 size=964
    let mut pc: u32 = 0x828617B0;
    'dispatch: loop {
        match pc {
            0x828617B0 => {
    //   block [0x828617B0..0x82861814)
	// 828617B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828617B4: 48447C55  bl 0x82ca9408
	ctx.lr = 0x828617B8;
	sub_82CA93D0(ctx, base);
	// 828617B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828617BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828617C0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 828617C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828617C8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828617CC: 480004ED  bl 0x82861cb8
	ctx.lr = 0x828617D0;
	sub_82861CB8(ctx, base);
	// 828617D0: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828617D4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828617D8: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 828617DC: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 828617E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828617E4: 419A00F4  beq cr6, 0x828618d8
	if ctx.cr[6].eq {
	pc = 0x828618D8; continue 'dispatch;
	}
	// 828617E8: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828617EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828617F0: 419A0024  beq cr6, 0x82861814
	if ctx.cr[6].eq {
	pc = 0x82861814; continue 'dispatch;
	}
	// 828617F4: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 828617F8: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828617FC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82861800: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82861804: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861808: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8286180C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861810: 480000D0  b 0x828618e0
	pc = 0x828618E0; continue 'dispatch;
            }
            0x82861814 => {
    //   block [0x82861814..0x82861830)
	// 82861814: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82861818: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286181C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82861820: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82861824: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82861828: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286182C: 40810054  ble 0x82861880
	if !ctx.cr[0].gt {
	pc = 0x82861880; continue 'dispatch;
	}
	pc = 0x82861830; continue 'dispatch;
            }
            0x82861830 => {
    //   block [0x82861830..0x82861850)
	// 82861830: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82861834: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82861838: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286183C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861840: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82861844: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82861848: 41980008  blt cr6, 0x82861850
	if ctx.cr[6].lt {
	pc = 0x82861850; continue 'dispatch;
	}
	// 8286184C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x82861850; continue 'dispatch;
            }
            0x82861850 => {
    //   block [0x82861850..0x8286186C)
	// 82861850: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82861854: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82861858: 419A0014  beq cr6, 0x8286186c
	if ctx.cr[6].eq {
	pc = 0x8286186C; continue 'dispatch;
	}
	// 8286185C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82861860: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82861864: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82861868: 4800000C  b 0x82861874
	pc = 0x82861874; continue 'dispatch;
            }
            0x8286186C => {
    //   block [0x8286186C..0x82861874)
	// 8286186C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82861870: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82861874; continue 'dispatch;
            }
            0x82861874 => {
    //   block [0x82861874..0x82861880)
	// 82861874: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861878: 4199FFB8  bgt cr6, 0x82861830
	if ctx.cr[6].gt {
	pc = 0x82861830; continue 'dispatch;
	}
	// 8286187C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82861880; continue 'dispatch;
            }
            0x82861880 => {
    //   block [0x82861880..0x8286189C)
	// 82861880: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82861884: 419A0040  beq cr6, 0x828618c4
	if ctx.cr[6].eq {
	pc = 0x828618C4; continue 'dispatch;
	}
	// 82861888: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286188C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82861890: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861894: 41990008  bgt cr6, 0x8286189c
	if ctx.cr[6].gt {
	pc = 0x8286189C; continue 'dispatch;
	}
	// 82861898: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8286189C; continue 'dispatch;
            }
            0x8286189C => {
    //   block [0x8286189C..0x828618C4)
	// 8286189C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828618A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828618A4: 409A0020  bne cr6, 0x828618c4
	if !ctx.cr[6].eq {
	pc = 0x828618C4; continue 'dispatch;
	}
	// 828618A8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828618AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828618B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828618B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828618B8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828618BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828618C0: 48000020  b 0x828618e0
	pc = 0x828618E0; continue 'dispatch;
            }
            0x828618C4 => {
    //   block [0x828618C4..0x828618D8)
	// 828618C4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828618C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828618CC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828618D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828618D4: 4800000C  b 0x828618e0
	pc = 0x828618E0; continue 'dispatch;
            }
            0x828618D8 => {
    //   block [0x828618D8..0x828618E0)
	// 828618D8: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828618DC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828618E0; continue 'dispatch;
            }
            0x828618E0 => {
    //   block [0x828618E0..0x82861924)
	// 828618E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828618E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828618E8: 419A027C  beq cr6, 0x82861b64
	if ctx.cr[6].eq {
	pc = 0x82861B64; continue 'dispatch;
	}
	// 828618EC: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 828618F0: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 828618F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828618F8: 419A00E8  beq cr6, 0x828619e0
	if ctx.cr[6].eq {
	pc = 0x828619E0; continue 'dispatch;
	}
	// 828618FC: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82861900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861904: 419A0020  beq cr6, 0x82861924
	if ctx.cr[6].eq {
	pc = 0x82861924; continue 'dispatch;
	}
	// 82861908: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8286190C: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82861910: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82861914: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82861918: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8286191C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861920: 480000C8  b 0x828619e8
	pc = 0x828619E8; continue 'dispatch;
            }
            0x82861924 => {
    //   block [0x82861924..0x82861940)
	// 82861924: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82861928: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286192C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82861930: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82861934: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82861938: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286193C: 40810054  ble 0x82861990
	if !ctx.cr[0].gt {
	pc = 0x82861990; continue 'dispatch;
	}
	pc = 0x82861940; continue 'dispatch;
            }
            0x82861940 => {
    //   block [0x82861940..0x82861960)
	// 82861940: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82861944: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82861948: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286194C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861950: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 82861954: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82861958: 41980008  blt cr6, 0x82861960
	if ctx.cr[6].lt {
	pc = 0x82861960; continue 'dispatch;
	}
	// 8286195C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x82861960; continue 'dispatch;
            }
            0x82861960 => {
    //   block [0x82861960..0x8286197C)
	// 82861960: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82861964: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82861968: 419A0014  beq cr6, 0x8286197c
	if ctx.cr[6].eq {
	pc = 0x8286197C; continue 'dispatch;
	}
	// 8286196C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82861970: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82861974: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82861978: 4800000C  b 0x82861984
	pc = 0x82861984; continue 'dispatch;
            }
            0x8286197C => {
    //   block [0x8286197C..0x82861984)
	// 8286197C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82861980: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82861984; continue 'dispatch;
            }
            0x82861984 => {
    //   block [0x82861984..0x82861990)
	// 82861984: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861988: 4199FFB8  bgt cr6, 0x82861940
	if ctx.cr[6].gt {
	pc = 0x82861940; continue 'dispatch;
	}
	// 8286198C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82861990; continue 'dispatch;
            }
            0x82861990 => {
    //   block [0x82861990..0x828619AC)
	// 82861990: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82861994: 419A003C  beq cr6, 0x828619d0
	if ctx.cr[6].eq {
	pc = 0x828619D0; continue 'dispatch;
	}
	// 82861998: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286199C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828619A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828619A4: 41990008  bgt cr6, 0x828619ac
	if ctx.cr[6].gt {
	pc = 0x828619AC; continue 'dispatch;
	}
	// 828619A8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828619AC; continue 'dispatch;
            }
            0x828619AC => {
    //   block [0x828619AC..0x828619D0)
	// 828619AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828619B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828619B4: 409A001C  bne cr6, 0x828619d0
	if !ctx.cr[6].eq {
	pc = 0x828619D0; continue 'dispatch;
	}
	// 828619B8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828619BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828619C0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828619C4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828619C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828619CC: 4800001C  b 0x828619e8
	pc = 0x828619E8; continue 'dispatch;
            }
            0x828619D0 => {
    //   block [0x828619D0..0x828619E0)
	// 828619D0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828619D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828619D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828619DC: 4800000C  b 0x828619e8
	pc = 0x828619E8; continue 'dispatch;
            }
            0x828619E0 => {
    //   block [0x828619E0..0x828619E8)
	// 828619E0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828619E4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x828619E8; continue 'dispatch;
            }
            0x828619E8 => {
    //   block [0x828619E8..0x82861A30)
	// 828619E8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828619EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828619F0: 419A0174  beq cr6, 0x82861b64
	if ctx.cr[6].eq {
	pc = 0x82861B64; continue 'dispatch;
	}
	// 828619F4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828619F8: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 828619FC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82861A00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82861A04: 4BBBFD4D  bl 0x82421750
	ctx.lr = 0x82861A08;
	sub_82421750(ctx, base);
	// 82861A08: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82861A0C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82861A10: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82861A14: 419A0150  beq cr6, 0x82861b64
	if ctx.cr[6].eq {
	pc = 0x82861B64; continue 'dispatch;
	}
	// 82861A18: 809D0010  lwz r4, 0x10(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82861A1C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82861A20: 419A0010  beq cr6, 0x82861a30
	if ctx.cr[6].eq {
	pc = 0x82861A30; continue 'dispatch;
	}
	// 82861A24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82861A28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82861A2C: 4BA4C5F5  bl 0x822ae020
	ctx.lr = 0x82861A30;
	sub_822AE020(ctx, base);
	pc = 0x82861A30; continue 'dispatch;
            }
            0x82861A30 => {
    //   block [0x82861A30..0x82861A60)
	// 82861A30: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82861A34: 4B9BD825  bl 0x8221f258
	ctx.lr = 0x82861A38;
	sub_8221F258(ctx, base);
	// 82861A38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82861A3C: 419A0024  beq cr6, 0x82861a60
	if ctx.cr[6].eq {
	pc = 0x82861A60; continue 'dispatch;
	}
	// 82861A40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82861A44: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82861A48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82861A4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82861A50: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82861A54: 4BA221DD  bl 0x82283c30
	ctx.lr = 0x82861A58;
	sub_82283C30(ctx, base);
	// 82861A58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82861A5C: 48000008  b 0x82861a64
	pc = 0x82861A64; continue 'dispatch;
            }
            0x82861A60 => {
    //   block [0x82861A60..0x82861A64)
	// 82861A60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x82861A64; continue 'dispatch;
            }
            0x82861A64 => {
    //   block [0x82861A64..0x82861AA8)
	// 82861A64: 387D0014  addi r3, r29, 0x14
	ctx.r[3].s64 = ctx.r[29].s64 + 20;
	// 82861A68: 4BA115F1  bl 0x82273058
	ctx.lr = 0x82861A6C;
	sub_82273058(ctx, base);
	// 82861A6C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82861A70: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82861A74: 80BD0014  lwz r5, 0x14(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82861A78: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 82861A7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82861A80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82861A84: 4B96C6BD  bl 0x821ce140
	ctx.lr = 0x82861A88;
	sub_821CE140(ctx, base);
	// 82861A88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82861A8C: 807D0010  lwz r3, 0x10(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82861A90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861A94: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82861A98: 419A0078  beq cr6, 0x82861b10
	if ctx.cr[6].eq {
	pc = 0x82861B10; continue 'dispatch;
	}
	// 82861A9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82861AA0: 419A0040  beq cr6, 0x82861ae0
	if ctx.cr[6].eq {
	pc = 0x82861AE0; continue 'dispatch;
	}
	// 82861AA4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82861AA8; continue 'dispatch;
            }
            0x82861AA8 => {
    //   block [0x82861AA8..0x82861ADC)
	// 82861AA8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82861AAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861AB0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82861AB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82861AB8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82861ABC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861AC0: 4082FFE8  bne 0x82861aa8
	if !ctx.cr[0].eq {
	pc = 0x82861AA8; continue 'dispatch;
	}
	// 82861AC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861AC8: 409A0014  bne cr6, 0x82861adc
	if !ctx.cr[6].eq {
	pc = 0x82861ADC; continue 'dispatch;
	}
	// 82861ACC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861AD0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861AD4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82861AD8: 4E800421  bctrl
	ctx.lr = 0x82861ADC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82861ADC => {
    //   block [0x82861ADC..0x82861AE0)
	// 82861ADC: 939D0010  stw r28, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	pc = 0x82861AE0; continue 'dispatch;
            }
            0x82861AE0 => {
    //   block [0x82861AE0..0x82861AF4)
	// 82861AE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861AE8: 917D0010  stw r11, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82861AEC: 419A0024  beq cr6, 0x82861b10
	if ctx.cr[6].eq {
	pc = 0x82861B10; continue 'dispatch;
	}
	// 82861AF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82861AF4; continue 'dispatch;
            }
            0x82861AF4 => {
    //   block [0x82861AF4..0x82861B10)
	// 82861AF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82861AF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861AFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82861B00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82861B04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82861B08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861B0C: 4082FFE8  bne 0x82861af4
	if !ctx.cr[0].eq {
	pc = 0x82861AF4; continue 'dispatch;
	}
	pc = 0x82861B10; continue 'dispatch;
            }
            0x82861B10 => {
    //   block [0x82861B10..0x82861B24)
	// 82861B10: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82861B14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861B18: 419A0048  beq cr6, 0x82861b60
	if ctx.cr[6].eq {
	pc = 0x82861B60; continue 'dispatch;
	}
	// 82861B1C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82861B20: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82861B24; continue 'dispatch;
            }
            0x82861B24 => {
    //   block [0x82861B24..0x82861B5C)
	// 82861B24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82861B28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861B2C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82861B30: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82861B34: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82861B38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861B3C: 4082FFE8  bne 0x82861b24
	if !ctx.cr[0].eq {
	pc = 0x82861B24; continue 'dispatch;
	}
	// 82861B40: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82861B44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861B48: 409A0014  bne cr6, 0x82861b5c
	if !ctx.cr[6].eq {
	pc = 0x82861B5C; continue 'dispatch;
	}
	// 82861B4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861B50: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861B54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82861B58: 4E800421  bctrl
	ctx.lr = 0x82861B5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82861B5C => {
    //   block [0x82861B5C..0x82861B60)
	// 82861B5C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	pc = 0x82861B60; continue 'dispatch;
            }
            0x82861B60 => {
    //   block [0x82861B60..0x82861B64)
	// 82861B60: 93DD0024  stw r30, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	pc = 0x82861B64; continue 'dispatch;
            }
            0x82861B64 => {
    //   block [0x82861B64..0x82861B74)
	// 82861B64: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82861B68: 4B9B3271  bl 0x82214dd8
	ctx.lr = 0x82861B6C;
	sub_82214DD8(ctx, base);
	// 82861B6C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82861B70: 484478E8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82861B78 size=316
    let mut pc: u32 = 0x82861B78;
    'dispatch: loop {
        match pc {
            0x82861B78 => {
    //   block [0x82861B78..0x82861BB8)
	// 82861B78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82861B7C: 48447891  bl 0x82ca940c
	ctx.lr = 0x82861B80;
	sub_82CA93D0(ctx, base);
	// 82861B80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82861B84: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82861B88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82861B8C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82861B90: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82861B94: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82861B98: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 82861B9C: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82861BA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82861BA4: 419A0014  beq cr6, 0x82861bb8
	if ctx.cr[6].eq {
	pc = 0x82861BB8; continue 'dispatch;
	}
	// 82861BA8: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 82861BAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861BB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861BB4: 409A0008  bne cr6, 0x82861bbc
	if !ctx.cr[6].eq {
	pc = 0x82861BBC; continue 'dispatch;
	}
	pc = 0x82861BB8; continue 'dispatch;
            }
            0x82861BB8 => {
    //   block [0x82861BB8..0x82861BBC)
	// 82861BB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82861BBC; continue 'dispatch;
            }
            0x82861BBC => {
    //   block [0x82861BBC..0x82861C00)
	// 82861BBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82861BC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861BC4: 419A003C  beq cr6, 0x82861c00
	if ctx.cr[6].eq {
	pc = 0x82861C00; continue 'dispatch;
	}
	// 82861BC8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82861BCC: 9BA1005C  stb r29, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u8 ) };
	// 82861BD0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861BD4: 392B5DC0  addi r9, r11, 0x5dc0
	ctx.r[9].s64 = ctx.r[11].s64 + 24000;
	// 82861BD8: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82861BDC: 83CA008C  lwz r30, 0x8c(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 82861BE0: 4B9507B1  bl 0x821b2390
	ctx.lr = 0x82861BE4;
	sub_821B2390(ctx, base);
	// 82861BE4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82861BE8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82861BEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82861BF0: 4BD4AE41  bl 0x825aca30
	ctx.lr = 0x82861BF4;
	sub_825ACA30(ctx, base);
	// 82861BF4: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82861BF8: 38E82DC8  addi r7, r8, 0x2dc8
	ctx.r[7].s64 = ctx.r[8].s64 + 11720;
	// 82861BFC: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	pc = 0x82861C00; continue 'dispatch;
            }
            0x82861C00 => {
    //   block [0x82861C00..0x82861C5C)
	// 82861C00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861C04: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82861C08: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861C0C: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 82861C10: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82861C14: 4E800421  bctrl
	ctx.lr = 0x82861C18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82861C18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82861C1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82861C20: 419A008C  beq cr6, 0x82861cac
	if ctx.cr[6].eq {
	pc = 0x82861CAC; continue 'dispatch;
	}
	// 82861C24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82861C28: 4BEBADC9  bl 0x8271c9f0
	ctx.lr = 0x82861C2C;
	sub_8271C9F0(ctx, base);
	// 82861C2C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82861C30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861C34: 419A0044  beq cr6, 0x82861c78
	if ctx.cr[6].eq {
	pc = 0x82861C78; continue 'dispatch;
	}
	// 82861C38: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82861C3C: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82861C40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82861C44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861C48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82861C4C: 419A0010  beq cr6, 0x82861c5c
	if ctx.cr[6].eq {
	pc = 0x82861C5C; continue 'dispatch;
	}
	// 82861C50: 4BE8F431  bl 0x826f1080
	ctx.lr = 0x82861C54;
	sub_826F1080(ctx, base);
	// 82861C54: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82861C58: 4800000C  b 0x82861c64
	pc = 0x82861C64; continue 'dispatch;
            }
            0x82861C5C => {
    //   block [0x82861C5C..0x82861C64)
	// 82861C5C: 4BE8F425  bl 0x826f1080
	ctx.lr = 0x82861C60;
	sub_826F1080(ctx, base);
	// 82861C60: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	pc = 0x82861C64; continue 'dispatch;
            }
            0x82861C64 => {
    //   block [0x82861C64..0x82861C78)
	// 82861C64: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861C68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82861C6C: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82861C70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82861C74: 4E800421  bctrl
	ctx.lr = 0x82861C78;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82861C78 => {
    //   block [0x82861C78..0x82861CAC)
	// 82861C78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82861C7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82861C80: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82861C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82861C88: 4B92C079  bl 0x8218dd00
	ctx.lr = 0x82861C8C;
	sub_8218DD00(ctx, base);
	// 82861C8C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82861C90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82861C94: 419A0018  beq cr6, 0x82861cac
	if ctx.cr[6].eq {
	pc = 0x82861CAC; continue 'dispatch;
	}
	// 82861C98: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82861C9C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82861CA0: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82861CA4: 5544DFFE  rlwinm r4, r10, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82861CA8: 4BECB441  bl 0x8272d0e8
	ctx.lr = 0x82861CAC;
	sub_8272D0E8(ctx, base);
	pc = 0x82861CAC; continue 'dispatch;
            }
            0x82861CAC => {
    //   block [0x82861CAC..0x82861CB4)
	// 82861CAC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82861CB0: 484477AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82861CB8 size=448
    let mut pc: u32 = 0x82861CB8;
    'dispatch: loop {
        match pc {
            0x82861CB8 => {
    //   block [0x82861CB8..0x82861D24)
	// 82861CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82861CBC: 48447751  bl 0x82ca940c
	ctx.lr = 0x82861CC0;
	sub_82CA93D0(ctx, base);
	// 82861CC0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82861CC4: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82861CC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82861CCC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82861CD0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82861CD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861CD8: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82861CDC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861CE0: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 82861CE4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82861CE8: 4E800421  bctrl
	ctx.lr = 0x82861CEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82861CEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82861CF0: 419A0164  beq cr6, 0x82861e54
	if ctx.cr[6].eq {
	pc = 0x82861E54; continue 'dispatch;
	}
	// 82861CF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82861CF8: 4BEBACF9  bl 0x8271c9f0
	ctx.lr = 0x82861CFC;
	sub_8271C9F0(ctx, base);
	// 82861CFC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82861D00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861D04: 419A0150  beq cr6, 0x82861e54
	if ctx.cr[6].eq {
	pc = 0x82861E54; continue 'dispatch;
	}
	// 82861D08: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82861D0C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82861D10: 4BE8F7F1  bl 0x826f1500
	ctx.lr = 0x82861D14;
	sub_826F1500(ctx, base);
	// 82861D14: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82861D18: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82861D1C: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 82861D20: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
            }
            0x82861D24 => {
    //   block [0x82861D24..0x82861E54)
	// 82861D24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82861D28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861D2C: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82861D30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82861D34: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82861D38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861D3C: 4082FFE8  bne 0x82861d24
	if !ctx.cr[0].eq {
	pc = 0x82861D24; continue 'dispatch;
	}
	// 82861D40: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 82861D44: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82861D48: 38869484  addi r4, r6, -0x6b7c
	ctx.r[4].s64 = ctx.r[6].s64 + -27516;
	// 82861D4C: 3C60820A  lis r3, -0x7df6
	ctx.r[3].s64 = -2113273856;
	// 82861D50: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82861D54: 39439150  addi r10, r3, -0x6eb0
	ctx.r[10].s64 = ctx.r[3].s64 + -28336;
	// 82861D58: C1A69484  lfs f13, -0x6b7c(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82861D5C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82861D60: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82861D64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82861D68: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x82861E54; continue 'dispatch;
            }
            0x82861E54 => {
    //   block [0x82861E54..0x82861E78)
	// 82861E54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82861E58: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82861E5C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82861E60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82861E64: 4B9CB06D  bl 0x8222ced0
	ctx.lr = 0x82861E68;
	sub_8222CED0(ctx, base);
	// 82861E68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82861E6C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82861E70: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82861E74: 484475E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82861E78 size=92
    let mut pc: u32 = 0x82861E78;
    'dispatch: loop {
        match pc {
            0x82861E78 => {
    //   block [0x82861E78..0x82861EB4)
	// 82861E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82861E7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82861E80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82861E84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82861E88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82861E8C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82861E90: 4B9BD3C9  bl 0x8221f258
	ctx.lr = 0x82861E94;
	sub_8221F258(ctx, base);
	// 82861E94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82861E98: 419A001C  beq cr6, 0x82861eb4
	if ctx.cr[6].eq {
	pc = 0x82861EB4; continue 'dispatch;
	}
	// 82861E9C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82861EA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82861EA4: C00BB480  lfs f0, -0x4b80(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82861EA8: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82861EAC: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82861EB0: 48000008  b 0x82861eb8
	pc = 0x82861EB8; continue 'dispatch;
            }
            0x82861EB4 => {
    //   block [0x82861EB4..0x82861EB8)
	// 82861EB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82861EB8; continue 'dispatch;
            }
            0x82861EB8 => {
    //   block [0x82861EB8..0x82861ED4)
	// 82861EB8: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82861EBC: 4BEB024D  bl 0x82712108
	ctx.lr = 0x82861EC0;
	sub_82712108(ctx, base);
	// 82861EC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82861EC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82861EC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82861ECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82861ED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82861ED8 size=484
    let mut pc: u32 = 0x82861ED8;
    'dispatch: loop {
        match pc {
            0x82861ED8 => {
    //   block [0x82861ED8..0x82861F30)
	// 82861ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82861EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82861EE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82861EE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82861EE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82861EEC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82861EF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82861EF4: 4BFFFC85  bl 0x82861b78
	ctx.lr = 0x82861EF8;
	sub_82861B78(ctx, base);
	// 82861EF8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82861EFC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861F00: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82861F04: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82861F08: 83CA008C  lwz r30, 0x8c(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 82861F0C: 4B950485  bl 0x821b2390
	ctx.lr = 0x82861F10;
	sub_821B2390(ctx, base);
	// 82861F10: 893E0034  lbz r9, 0x34(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82861F14: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82861F18: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82861F1C: 419A0014  beq cr6, 0x82861f30
	if ctx.cr[6].eq {
	pc = 0x82861F30; continue 'dispatch;
	}
	// 82861F20: 897E0035  lbz r11, 0x35(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(53 as u32) ) } as u64;
	// 82861F24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861F28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861F2C: 409A0008  bne cr6, 0x82861f34
	if !ctx.cr[6].eq {
	pc = 0x82861F34; continue 'dispatch;
	}
	pc = 0x82861F30; continue 'dispatch;
            }
            0x82861F30 => {
    //   block [0x82861F30..0x82861F34)
	// 82861F30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82861F34; continue 'dispatch;
            }
            0x82861F34 => {
    //   block [0x82861F34..0x82861F64)
	// 82861F34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82861F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861F3C: 419A0028  beq cr6, 0x82861f64
	if ctx.cr[6].eq {
	pc = 0x82861F64; continue 'dispatch;
	}
	// 82861F40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82861F44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82861F48: 394B5DFC  addi r10, r11, 0x5dfc
	ctx.r[10].s64 = ctx.r[11].s64 + 24060;
	// 82861F4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82861F50: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82861F54: 4BCE3DCD  bl 0x82545d20
	ctx.lr = 0x82861F58;
	sub_82545D20(ctx, base);
	// 82861F58: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82861F5C: 39092DC8  addi r8, r9, 0x2dc8
	ctx.r[8].s64 = ctx.r[9].s64 + 11720;
	// 82861F60: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	pc = 0x82861F64; continue 'dispatch;
            }
            0x82861F64 => {
    //   block [0x82861F64..0x82861FA4)
	// 82861F64: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861F68: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82861F6C: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 82861F70: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82861F74: 419A00F8  beq cr6, 0x8286206c
	if ctx.cr[6].eq {
	pc = 0x8286206C; continue 'dispatch;
	}
	// 82861F78: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82861F7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82861F80: 419A0024  beq cr6, 0x82861fa4
	if ctx.cr[6].eq {
	pc = 0x82861FA4; continue 'dispatch;
	}
	// 82861F84: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82861F88: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82861F8C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82861F90: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82861F94: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861F98: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82861F9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861FA0: 480000D4  b 0x82862074
	pc = 0x82862074; continue 'dispatch;
            }
            0x82861FA4 => {
    //   block [0x82861FA4..0x82861FC4)
	// 82861FA4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82861FA8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82861FAC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82861FB0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82861FB4: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82861FB8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82861FBC: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861FC0: 40810054  ble 0x82862014
	if !ctx.cr[0].gt {
	pc = 0x82862014; continue 'dispatch;
	}
	pc = 0x82861FC4; continue 'dispatch;
            }
            0x82861FC4 => {
    //   block [0x82861FC4..0x82861FE4)
	// 82861FC4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82861FC8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82861FCC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82861FD0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861FD4: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 82861FD8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82861FDC: 41980008  blt cr6, 0x82861fe4
	if ctx.cr[6].lt {
	pc = 0x82861FE4; continue 'dispatch;
	}
	// 82861FE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82861FE4; continue 'dispatch;
            }
            0x82861FE4 => {
    //   block [0x82861FE4..0x82862000)
	// 82861FE4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82861FE8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82861FEC: 419A0014  beq cr6, 0x82862000
	if ctx.cr[6].eq {
	pc = 0x82862000; continue 'dispatch;
	}
	// 82861FF0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82861FF4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82861FF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82861FFC: 4800000C  b 0x82862008
	pc = 0x82862008; continue 'dispatch;
            }
            0x82862000 => {
    //   block [0x82862000..0x82862008)
	// 82862000: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82862004: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82862008; continue 'dispatch;
            }
            0x82862008 => {
    //   block [0x82862008..0x82862014)
	// 82862008: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286200C: 4199FFB8  bgt cr6, 0x82861fc4
	if ctx.cr[6].gt {
	pc = 0x82861FC4; continue 'dispatch;
	}
	// 82862010: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82862014; continue 'dispatch;
            }
            0x82862014 => {
    //   block [0x82862014..0x82862030)
	// 82862014: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82862018: 419A0040  beq cr6, 0x82862058
	if ctx.cr[6].eq {
	pc = 0x82862058; continue 'dispatch;
	}
	// 8286201C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862020: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 82862024: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862028: 41990008  bgt cr6, 0x82862030
	if ctx.cr[6].gt {
	pc = 0x82862030; continue 'dispatch;
	}
	// 8286202C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82862030; continue 'dispatch;
            }
            0x82862030 => {
    //   block [0x82862030..0x82862058)
	// 82862030: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82862034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862038: 409A0020  bne cr6, 0x82862058
	if !ctx.cr[6].eq {
	pc = 0x82862058; continue 'dispatch;
	}
	// 8286203C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82862040: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82862044: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82862048: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286204C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82862050: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862054: 48000020  b 0x82862074
	pc = 0x82862074; continue 'dispatch;
            }
            0x82862058 => {
    //   block [0x82862058..0x8286206C)
	// 82862058: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286205C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862060: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82862064: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862068: 4800000C  b 0x82862074
	pc = 0x82862074; continue 'dispatch;
            }
            0x8286206C => {
    //   block [0x8286206C..0x82862074)
	// 8286206C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82862070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82862074; continue 'dispatch;
            }
            0x82862074 => {
    //   block [0x82862074..0x828620A4)
	// 82862074: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82862078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286207C: 419A0028  beq cr6, 0x828620a4
	if ctx.cr[6].eq {
	pc = 0x828620A4; continue 'dispatch;
	}
	// 82862080: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82862084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862088: 4B99D541  bl 0x821ff5c8
	ctx.lr = 0x8286208C;
	sub_821FF5C8(ctx, base);
	// 8286208C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82862090: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862094: 419A0010  beq cr6, 0x828620a4
	if ctx.cr[6].eq {
	pc = 0x828620A4; continue 'dispatch;
	}
	// 82862098: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8286209C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828620A0: 4BBBE201  bl 0x824202a0
	ctx.lr = 0x828620A4;
	sub_824202A0(ctx, base);
	pc = 0x828620A4; continue 'dispatch;
            }
            0x828620A4 => {
    //   block [0x828620A4..0x828620BC)
	// 828620A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828620A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828620AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828620B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828620B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828620B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828620C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828620C0 size=160
    let mut pc: u32 = 0x828620C0;
    'dispatch: loop {
        match pc {
            0x828620C0 => {
    //   block [0x828620C0..0x82862150)
	// 828620C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828620C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828620C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828620CC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828620D0: 8165001C  lwz r11, 0x1c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 828620D4: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828620D8: C16B0000  lfs f11, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828620DC: 4B9A5715  bl 0x822077f0
	ctx.lr = 0x828620E0;
	sub_822077F0(ctx, base);
	// 828620E0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828620E4: 8125001C  lwz r9, 0x1c(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 828620E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828620EC: 396BBE04  addi r11, r11, -0x41fc
	ctx.r[11].s64 = ctx.r[11].s64 + -16892;
	// 828620F0: C80A9660  lfd f0, -0x69a0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 828620F4: FC010024  fdiv f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 828620F8: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828620FC: C1ABD4D0  lfs f13, -0x2b30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11056 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82862100: FD400018  frsp f10, f0
	ctx.f[10].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82862104: EC0B5028  fsubs f0, f11, f10
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 82862108: ED2C5028  fsubs f9, f12, f10
	ctx.f[9].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 8286210C: D1290000  stfs f9, 0(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82862110: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82862114: 4199003C  bgt cr6, 0x82862150
	if ctx.cr[6].gt {
	pc = 0x82862150; continue 'dispatch;
	}
	// 82862118: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8286211C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82862120: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82862124: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82862128: D9810050  stfd f12, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[12].u64 ) };
	// 8286212C: FD606E5E  fctidz f11, f13
	ctx.f[11].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 82862130: D9610060  stfd f11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[11].u64 ) };
	// 82862134: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82862138: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8286213C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82862140: 419A0010  beq cr6, 0x82862150
	if ctx.cr[6].eq {
	pc = 0x82862150; continue 'dispatch;
	}
	// 82862144: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82862148: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 8286214C: 4BFFF665  bl 0x828617b0
	ctx.lr = 0x82862150;
	sub_828617B0(ctx, base);
	pc = 0x82862150; continue 'dispatch;
            }
            0x82862150 => {
    //   block [0x82862150..0x82862160)
	// 82862150: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82862154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286215C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862160 size=448
    let mut pc: u32 = 0x82862160;
    'dispatch: loop {
        match pc {
            0x82862160 => {
    //   block [0x82862160..0x828621C4)
	// 82862160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286216C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862170: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862174: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82862178: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8286217C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82862180: 419A0180  beq cr6, 0x82862300
	if ctx.cr[6].eq {
	pc = 0x82862300; continue 'dispatch;
	}
	// 82862184: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862188: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8286218C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82862190: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82862194: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82862198: 419A00E8  beq cr6, 0x82862280
	if ctx.cr[6].eq {
	pc = 0x82862280; continue 'dispatch;
	}
	// 8286219C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828621A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828621A4: 419A0020  beq cr6, 0x828621c4
	if ctx.cr[6].eq {
	pc = 0x828621C4; continue 'dispatch;
	}
	// 828621A8: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 828621AC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828621B0: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828621B4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828621B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828621BC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828621C0: 480000C8  b 0x82862288
	pc = 0x82862288; continue 'dispatch;
            }
            0x828621C4 => {
    //   block [0x828621C4..0x828621E0)
	// 828621C4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828621C8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828621CC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828621D0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828621D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828621D8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828621DC: 40810054  ble 0x82862230
	if !ctx.cr[0].gt {
	pc = 0x82862230; continue 'dispatch;
	}
	pc = 0x828621E0; continue 'dispatch;
            }
            0x828621E0 => {
    //   block [0x828621E0..0x82862200)
	// 828621E0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828621E4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828621E8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828621EC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828621F0: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828621F4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828621F8: 41980008  blt cr6, 0x82862200
	if ctx.cr[6].lt {
	pc = 0x82862200; continue 'dispatch;
	}
	// 828621FC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82862200; continue 'dispatch;
            }
            0x82862200 => {
    //   block [0x82862200..0x8286221C)
	// 82862200: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82862204: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82862208: 419A0014  beq cr6, 0x8286221c
	if ctx.cr[6].eq {
	pc = 0x8286221C; continue 'dispatch;
	}
	// 8286220C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82862210: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82862214: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82862218: 4800000C  b 0x82862224
	pc = 0x82862224; continue 'dispatch;
            }
            0x8286221C => {
    //   block [0x8286221C..0x82862224)
	// 8286221C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82862220: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82862224; continue 'dispatch;
            }
            0x82862224 => {
    //   block [0x82862224..0x82862230)
	// 82862224: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862228: 4199FFB8  bgt cr6, 0x828621e0
	if ctx.cr[6].gt {
	pc = 0x828621E0; continue 'dispatch;
	}
	// 8286222C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82862230; continue 'dispatch;
            }
            0x82862230 => {
    //   block [0x82862230..0x8286224C)
	// 82862230: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82862234: 419A003C  beq cr6, 0x82862270
	if ctx.cr[6].eq {
	pc = 0x82862270; continue 'dispatch;
	}
	// 82862238: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286223C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82862240: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862244: 41990008  bgt cr6, 0x8286224c
	if ctx.cr[6].gt {
	pc = 0x8286224C; continue 'dispatch;
	}
	// 82862248: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8286224C; continue 'dispatch;
            }
            0x8286224C => {
    //   block [0x8286224C..0x82862270)
	// 8286224C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82862250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862254: 409A001C  bne cr6, 0x82862270
	if !ctx.cr[6].eq {
	pc = 0x82862270; continue 'dispatch;
	}
	// 82862258: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8286225C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82862260: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82862264: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82862268: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286226C: 4800001C  b 0x82862288
	pc = 0x82862288; continue 'dispatch;
            }
            0x82862270 => {
    //   block [0x82862270..0x82862280)
	// 82862270: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82862274: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82862278: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286227C: 4800000C  b 0x82862288
	pc = 0x82862288; continue 'dispatch;
            }
            0x82862280 => {
    //   block [0x82862280..0x82862288)
	// 82862280: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82862284: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x82862288; continue 'dispatch;
            }
            0x82862288 => {
    //   block [0x82862288..0x828622B0)
	// 82862288: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8286228C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82862290: 419A0068  beq cr6, 0x828622f8
	if ctx.cr[6].eq {
	pc = 0x828622F8; continue 'dispatch;
	}
	// 82862294: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82862298: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286229C: 4BA4BD85  bl 0x822ae020
	ctx.lr = 0x828622A0;
	sub_822AE020(ctx, base);
	// 828622A0: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828622A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828622A8: 419A0040  beq cr6, 0x828622e8
	if ctx.cr[6].eq {
	pc = 0x828622E8; continue 'dispatch;
	}
	// 828622AC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x828622B0; continue 'dispatch;
            }
            0x828622B0 => {
    //   block [0x828622B0..0x828622E4)
	// 828622B0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828622B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828622B8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828622BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828622C0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828622C4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828622C8: 4082FFE8  bne 0x828622b0
	if !ctx.cr[0].eq {
	pc = 0x828622B0; continue 'dispatch;
	}
	// 828622CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828622D0: 409A0014  bne cr6, 0x828622e4
	if !ctx.cr[6].eq {
	pc = 0x828622E4; continue 'dispatch;
	}
	// 828622D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828622D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828622DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828622E0: 4E800421  bctrl
	ctx.lr = 0x828622E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828622E4 => {
    //   block [0x828622E4..0x828622E8)
	// 828622E4: 93FE0010  stw r31, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	pc = 0x828622E8; continue 'dispatch;
            }
            0x828622E8 => {
    //   block [0x828622E8..0x828622F8)
	// 828622E8: 93FE0010  stw r31, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 828622EC: 387E0014  addi r3, r30, 0x14
	ctx.r[3].s64 = ctx.r[30].s64 + 20;
	// 828622F0: 4B955829  bl 0x821b7b18
	ctx.lr = 0x828622F4;
	sub_821B7B18(ctx, base);
	// 828622F4: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	pc = 0x828622F8; continue 'dispatch;
            }
            0x828622F8 => {
    //   block [0x828622F8..0x82862300)
	// 828622F8: 93FE0024  stw r31, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 828622FC: 4800000C  b 0x82862308
	pc = 0x82862308; continue 'dispatch;
            }
            0x82862300 => {
    //   block [0x82862300..0x82862308)
	// 82862300: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82862304: 917E0024  stw r11, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	pc = 0x82862308; continue 'dispatch;
            }
            0x82862308 => {
    //   block [0x82862308..0x82862320)
	// 82862308: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286230C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862310: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862314: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82862318: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286231C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82862320 size=8
    let mut pc: u32 = 0x82862320;
    'dispatch: loop {
        match pc {
            0x82862320 => {
    //   block [0x82862320..0x82862328)
	// 82862320: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82862324: 4BFFF854  b 0x82861b78
	sub_82861B78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862328 size=260
    let mut pc: u32 = 0x82862328;
    'dispatch: loop {
        match pc {
            0x82862328 => {
    //   block [0x82862328..0x8286236C)
	// 82862328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286232C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862330: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82862334: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862338: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286233C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82862340: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862344: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82862348: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8286234C: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 82862350: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82862354: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82862358: 419A0014  beq cr6, 0x8286236c
	if ctx.cr[6].eq {
	pc = 0x8286236C; continue 'dispatch;
	}
	// 8286235C: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 82862360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862364: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862368: 409A0008  bne cr6, 0x82862370
	if !ctx.cr[6].eq {
	pc = 0x82862370; continue 'dispatch;
	}
	pc = 0x8286236C; continue 'dispatch;
            }
            0x8286236C => {
    //   block [0x8286236C..0x82862370)
	// 8286236C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82862370; continue 'dispatch;
            }
            0x82862370 => {
    //   block [0x82862370..0x828623B8)
	// 82862370: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82862374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862378: 419A0040  beq cr6, 0x828623b8
	if ctx.cr[6].eq {
	pc = 0x828623B8; continue 'dispatch;
	}
	// 8286237C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82862380: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862384: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82862388: 390B5DC0  addi r8, r11, 0x5dc0
	ctx.r[8].s64 = ctx.r[11].s64 + 24000;
	// 8286238C: 9921005C  stb r9, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u8 ) };
	// 82862390: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82862394: 83CA008C  lwz r30, 0x8c(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 82862398: 4B94FFF9  bl 0x821b2390
	ctx.lr = 0x8286239C;
	sub_821B2390(ctx, base);
	// 8286239C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828623A0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828623A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828623A8: 4BD4A689  bl 0x825aca30
	ctx.lr = 0x828623AC;
	sub_825ACA30(ctx, base);
	// 828623AC: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 828623B0: 38C72DC8  addi r6, r7, 0x2dc8
	ctx.r[6].s64 = ctx.r[7].s64 + 11720;
	// 828623B4: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	pc = 0x828623B8; continue 'dispatch;
            }
            0x828623B8 => {
    //   block [0x828623B8..0x82862414)
	// 828623B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828623BC: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828623C0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828623C4: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 828623C8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828623CC: 4E800421  bctrl
	ctx.lr = 0x828623D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828623D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828623D4: 419A0040  beq cr6, 0x82862414
	if ctx.cr[6].eq {
	pc = 0x82862414; continue 'dispatch;
	}
	// 828623D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828623DC: 4BEBA615  bl 0x8271c9f0
	ctx.lr = 0x828623E0;
	sub_8271C9F0(ctx, base);
	// 828623E0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828623E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828623E8: 419A002C  beq cr6, 0x82862414
	if ctx.cr[6].eq {
	pc = 0x82862414; continue 'dispatch;
	}
	// 828623EC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828623F0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828623F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828623F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828623FC: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82862400: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82862404: 4E800421  bctrl
	ctx.lr = 0x82862408;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82862408: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8286240C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862410: 4BE8EC71  bl 0x826f1080
	ctx.lr = 0x82862414;
	sub_826F1080(ctx, base);
            }
            0x82862414 => {
    //   block [0x82862414..0x8286242C)
	// 82862414: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82862418: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286241C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862420: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82862424: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862430 size=304
    let mut pc: u32 = 0x82862430;
    'dispatch: loop {
        match pc {
            0x82862430 => {
    //   block [0x82862430..0x82862474)
	// 82862430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862438: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286243C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862440: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862444: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82862448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286244C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82862450: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82862454: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 82862458: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8286245C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82862460: 419A0014  beq cr6, 0x82862474
	if ctx.cr[6].eq {
	pc = 0x82862474; continue 'dispatch;
	}
	// 82862464: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 82862468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286246C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862470: 409A0008  bne cr6, 0x82862478
	if !ctx.cr[6].eq {
	pc = 0x82862478; continue 'dispatch;
	}
	pc = 0x82862474; continue 'dispatch;
            }
            0x82862474 => {
    //   block [0x82862474..0x82862478)
	// 82862474: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82862478; continue 'dispatch;
            }
            0x82862478 => {
    //   block [0x82862478..0x828624C0)
	// 82862478: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286247C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862480: 419A0040  beq cr6, 0x828624c0
	if ctx.cr[6].eq {
	pc = 0x828624C0; continue 'dispatch;
	}
	// 82862484: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82862488: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286248C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82862490: 390B5DC0  addi r8, r11, 0x5dc0
	ctx.r[8].s64 = ctx.r[11].s64 + 24000;
	// 82862494: 9921005C  stb r9, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u8 ) };
	// 82862498: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 8286249C: 83CA008C  lwz r30, 0x8c(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 828624A0: 4B94FEF1  bl 0x821b2390
	ctx.lr = 0x828624A4;
	sub_821B2390(ctx, base);
	// 828624A4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828624A8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828624AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828624B0: 4BD4A581  bl 0x825aca30
	ctx.lr = 0x828624B4;
	sub_825ACA30(ctx, base);
	// 828624B4: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 828624B8: 38C72DC8  addi r6, r7, 0x2dc8
	ctx.r[6].s64 = ctx.r[7].s64 + 11720;
	// 828624BC: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	pc = 0x828624C0; continue 'dispatch;
            }
            0x828624C0 => {
    //   block [0x828624C0..0x828624E0)
	// 828624C0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828624C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828624C8: 419A0018  beq cr6, 0x828624e0
	if ctx.cr[6].eq {
	pc = 0x828624E0; continue 'dispatch;
	}
	// 828624CC: 896A0090  lbz r11, 0x90(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 828624D0: 55690672  rlwinm r9, r11, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828624D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828624D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828624DC: 409A0008  bne cr6, 0x828624e4
	if !ctx.cr[6].eq {
	pc = 0x828624E4; continue 'dispatch;
	}
	pc = 0x828624E0; continue 'dispatch;
            }
            0x828624E0 => {
    //   block [0x828624E0..0x828624E4)
	// 828624E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828624E4; continue 'dispatch;
            }
            0x828624E4 => {
    //   block [0x828624E4..0x82862548)
	// 828624E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828624E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828624EC: 419A005C  beq cr6, 0x82862548
	if ctx.cr[6].eq {
	pc = 0x82862548; continue 'dispatch;
	}
	// 828624F0: 806A007C  lwz r3, 0x7c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 828624F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828624F8: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828624FC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82862500: 4E800421  bctrl
	ctx.lr = 0x82862504;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82862504: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82862508: 419A0040  beq cr6, 0x82862548
	if ctx.cr[6].eq {
	pc = 0x82862548; continue 'dispatch;
	}
	// 8286250C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82862510: 4BEBA4E1  bl 0x8271c9f0
	ctx.lr = 0x82862514;
	sub_8271C9F0(ctx, base);
	// 82862514: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82862518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286251C: 419A002C  beq cr6, 0x82862548
	if ctx.cr[6].eq {
	pc = 0x82862548; continue 'dispatch;
	}
	// 82862520: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82862524: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82862528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286252C: 4BE8EB55  bl 0x826f1080
	ctx.lr = 0x82862530;
	sub_826F1080(ctx, base);
	// 82862530: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862534: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82862538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286253C: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82862540: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82862544: 4E800421  bctrl
	ctx.lr = 0x82862548;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82862548 => {
    //   block [0x82862548..0x82862560)
	// 82862548: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8286254C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862550: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862554: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82862558: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286255C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862560 size=500
    let mut pc: u32 = 0x82862560;
    'dispatch: loop {
        match pc {
            0x82862560 => {
    //   block [0x82862560..0x8286259C)
	// 82862560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286256C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862570: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82862574: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862578: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8286257C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82862580: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82862584: 390BF058  addi r8, r11, -0xfa8
	ctx.r[8].s64 = ctx.r[11].s64 + -4008;
	// 82862588: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 8286258C: 909E0004  stw r4, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82862590: 911E0000  stw r8, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82862594: 38C77088  addi r6, r7, 0x7088
	ctx.r[6].s64 = ctx.r[7].s64 + 28808;
	// 82862598: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x8286259C; continue 'dispatch;
            }
            0x8286259C => {
    //   block [0x8286259C..0x82862624)
	// 8286259C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828625A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828625A4: 7D403028  lwarx r10, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828625A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828625AC: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828625B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828625B4: 4082FFE8  bne 0x8286259c
	if !ctx.cr[0].eq {
	pc = 0x8286259C; continue 'dispatch;
	}
	// 828625B8: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 828625BC: 9BFE000D  stb r31, 0xd(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(13 as u32), ctx.r[31].u8 ) };
	// 828625C0: 3C80820A  lis r4, -0x7df6
	ctx.r[4].s64 = -2113273856;
	// 828625C4: 3865F7A0  addi r3, r5, -0x860
	ctx.r[3].s64 = ctx.r[5].s64 + -2144;
	// 828625C8: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828625CC: 93FE0010  stw r31, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 828625D0: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 828625D4: C3E4B46C  lfs f31, -0x4b94(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-19348 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828625D8: 93FE0018  stw r31, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 828625DC: 93FE001C  stw r31, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 828625E0: 93FE0020  stw r31, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 828625E4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828625E8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828625EC: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 828625F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828625F4: 419A00F4  beq cr6, 0x828626e8
	if ctx.cr[6].eq {
	pc = 0x828626E8; continue 'dispatch;
	}
	// 828625F8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828625FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82862600: 419A0024  beq cr6, 0x82862624
	if ctx.cr[6].eq {
	pc = 0x82862624; continue 'dispatch;
	}
	// 82862604: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82862608: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286260C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82862610: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82862614: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862618: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8286261C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862620: 480000CC  b 0x828626ec
	pc = 0x828626EC; continue 'dispatch;
            }
            0x82862624 => {
    //   block [0x82862624..0x82862640)
	// 82862624: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82862628: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286262C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82862630: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82862634: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82862638: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286263C: 40810054  ble 0x82862690
	if !ctx.cr[0].gt {
	pc = 0x82862690; continue 'dispatch;
	}
	pc = 0x82862640; continue 'dispatch;
            }
            0x82862640 => {
    //   block [0x82862640..0x82862660)
	// 82862640: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82862644: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82862648: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286264C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862650: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 82862654: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82862658: 41980008  blt cr6, 0x82862660
	if ctx.cr[6].lt {
	pc = 0x82862660; continue 'dispatch;
	}
	// 8286265C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82862660; continue 'dispatch;
            }
            0x82862660 => {
    //   block [0x82862660..0x8286267C)
	// 82862660: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82862664: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82862668: 419A0014  beq cr6, 0x8286267c
	if ctx.cr[6].eq {
	pc = 0x8286267C; continue 'dispatch;
	}
	// 8286266C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82862670: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82862674: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82862678: 4800000C  b 0x82862684
	pc = 0x82862684; continue 'dispatch;
            }
            0x8286267C => {
    //   block [0x8286267C..0x82862684)
	// 8286267C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82862680: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82862684; continue 'dispatch;
            }
            0x82862684 => {
    //   block [0x82862684..0x82862690)
	// 82862684: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862688: 4199FFB8  bgt cr6, 0x82862640
	if ctx.cr[6].gt {
	pc = 0x82862640; continue 'dispatch;
	}
	// 8286268C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82862690; continue 'dispatch;
            }
            0x82862690 => {
    //   block [0x82862690..0x828626AC)
	// 82862690: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82862694: 419A0040  beq cr6, 0x828626d4
	if ctx.cr[6].eq {
	pc = 0x828626D4; continue 'dispatch;
	}
	// 82862698: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286269C: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 828626A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828626A4: 41990008  bgt cr6, 0x828626ac
	if ctx.cr[6].gt {
	pc = 0x828626AC; continue 'dispatch;
	}
	// 828626A8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828626AC; continue 'dispatch;
            }
            0x828626AC => {
    //   block [0x828626AC..0x828626D4)
	// 828626AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828626B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828626B4: 409A0020  bne cr6, 0x828626d4
	if !ctx.cr[6].eq {
	pc = 0x828626D4; continue 'dispatch;
	}
	// 828626B8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828626BC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828626C0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828626C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828626C8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828626CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828626D0: 4800001C  b 0x828626ec
	pc = 0x828626EC; continue 'dispatch;
            }
            0x828626D4 => {
    //   block [0x828626D4..0x828626E8)
	// 828626D4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828626D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828626DC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828626E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828626E4: 48000008  b 0x828626ec
	pc = 0x828626EC; continue 'dispatch;
            }
            0x828626E8 => {
    //   block [0x828626E8..0x828626EC)
	// 828626E8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828626EC; continue 'dispatch;
            }
            0x828626EC => {
    //   block [0x828626EC..0x82862728)
	// 828626EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828626F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828626F4: 419A0034  beq cr6, 0x82862728
	if ctx.cr[6].eq {
	pc = 0x82862728; continue 'dispatch;
	}
	// 828626F8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828626FC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82862700: 388B4418  addi r4, r11, 0x4418
	ctx.r[4].s64 = ctx.r[11].s64 + 17432;
	// 82862704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82862708: 4B9CA7C9  bl 0x8222ced0
	ctx.lr = 0x8286270C;
	sub_8222CED0(ctx, base);
	// 8286270C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82862710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862714: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82862718: 4BB479A9  bl 0x823aa0c0
	ctx.lr = 0x8286271C;
	sub_823AA0C0(ctx, base);
	// 8286271C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82862720: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82862724: 4B9B26B5  bl 0x82214dd8
	ctx.lr = 0x82862728;
	sub_82214DD8(ctx, base);
	pc = 0x82862728; continue 'dispatch;
            }
            0x82862728 => {
    //   block [0x82862728..0x82862754)
	// 82862728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286272C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82862730: 48000029  bl 0x82862758
	ctx.lr = 0x82862734;
	sub_82862758(ctx, base);
	// 82862734: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862738: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8286273C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862744: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82862748: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286274C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862758 size=96
    let mut pc: u32 = 0x82862758;
    'dispatch: loop {
        match pc {
            0x82862758 => {
    //   block [0x82862758..0x82862794)
	// 82862758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286275C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862760: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862764: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82862768: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286276C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862770: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82862774: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82862778: 4B9BCAE1  bl 0x8221f258
	ctx.lr = 0x8286277C;
	sub_8221F258(ctx, base);
	// 8286277C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82862780: 419A0014  beq cr6, 0x82862794
	if ctx.cr[6].eq {
	pc = 0x82862794; continue 'dispatch;
	}
	// 82862784: D3E30000  stfs f31, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82862788: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286278C: D3E30004  stfs f31, 4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82862790: 48000008  b 0x82862798
	pc = 0x82862798; continue 'dispatch;
            }
            0x82862794 => {
    //   block [0x82862794..0x82862798)
	// 82862794: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82862798; continue 'dispatch;
            }
            0x82862798 => {
    //   block [0x82862798..0x828627B8)
	// 82862798: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 8286279C: 4BEAF96D  bl 0x82712108
	ctx.lr = 0x828627A0;
	sub_82712108(ctx, base);
	// 828627A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828627A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828627A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828627AC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828627B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828627B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828627B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828627B8 size=968
    let mut pc: u32 = 0x828627B8;
    'dispatch: loop {
        match pc {
            0x828627B8 => {
    //   block [0x828627B8..0x82862810)
	// 828627B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828627BC: 48446C49  bl 0x82ca9404
	ctx.lr = 0x828627C0;
	sub_82CA93D0(ctx, base);
	// 828627C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828627C4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828627C8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828627CC: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828627D0: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828627D4: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 828627D8: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 828627DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828627E0: 419A00F4  beq cr6, 0x828628d4
	if ctx.cr[6].eq {
	pc = 0x828628D4; continue 'dispatch;
	}
	// 828627E4: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828627E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828627EC: 419A0024  beq cr6, 0x82862810
	if ctx.cr[6].eq {
	pc = 0x82862810; continue 'dispatch;
	}
	// 828627F0: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 828627F4: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828627F8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828627FC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82862800: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862804: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82862808: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286280C: 480000CC  b 0x828628d8
	pc = 0x828628D8; continue 'dispatch;
            }
            0x82862810 => {
    //   block [0x82862810..0x8286282C)
	// 82862810: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82862814: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82862818: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8286281C: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82862820: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82862824: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862828: 40810054  ble 0x8286287c
	if !ctx.cr[0].gt {
	pc = 0x8286287C; continue 'dispatch;
	}
	pc = 0x8286282C; continue 'dispatch;
            }
            0x8286282C => {
    //   block [0x8286282C..0x8286284C)
	// 8286282C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82862830: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82862834: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82862838: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286283C: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82862840: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82862844: 41980008  blt cr6, 0x8286284c
	if ctx.cr[6].lt {
	pc = 0x8286284C; continue 'dispatch;
	}
	// 82862848: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8286284C; continue 'dispatch;
            }
            0x8286284C => {
    //   block [0x8286284C..0x82862868)
	// 8286284C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82862850: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82862854: 419A0014  beq cr6, 0x82862868
	if ctx.cr[6].eq {
	pc = 0x82862868; continue 'dispatch;
	}
	// 82862858: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286285C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82862860: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82862864: 4800000C  b 0x82862870
	pc = 0x82862870; continue 'dispatch;
            }
            0x82862868 => {
    //   block [0x82862868..0x82862870)
	// 82862868: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286286C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82862870; continue 'dispatch;
            }
            0x82862870 => {
    //   block [0x82862870..0x8286287C)
	// 82862870: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862874: 4199FFB8  bgt cr6, 0x8286282c
	if ctx.cr[6].gt {
	pc = 0x8286282C; continue 'dispatch;
	}
	// 82862878: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8286287C; continue 'dispatch;
            }
            0x8286287C => {
    //   block [0x8286287C..0x82862898)
	// 8286287C: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82862880: 419A0040  beq cr6, 0x828628c0
	if ctx.cr[6].eq {
	pc = 0x828628C0; continue 'dispatch;
	}
	// 82862884: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862888: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8286288C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862890: 41990008  bgt cr6, 0x82862898
	if ctx.cr[6].gt {
	pc = 0x82862898; continue 'dispatch;
	}
	// 82862894: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82862898; continue 'dispatch;
            }
            0x82862898 => {
    //   block [0x82862898..0x828628C0)
	// 82862898: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286289C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828628A0: 409A0020  bne cr6, 0x828628c0
	if !ctx.cr[6].eq {
	pc = 0x828628C0; continue 'dispatch;
	}
	// 828628A4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828628A8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828628AC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828628B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828628B4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828628B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828628BC: 4800001C  b 0x828628d8
	pc = 0x828628D8; continue 'dispatch;
            }
            0x828628C0 => {
    //   block [0x828628C0..0x828628D4)
	// 828628C0: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828628C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828628C8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828628CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828628D0: 48000008  b 0x828628d8
	pc = 0x828628D8; continue 'dispatch;
            }
            0x828628D4 => {
    //   block [0x828628D4..0x828628D8)
	// 828628D4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828628D8; continue 'dispatch;
            }
            0x828628D8 => {
    //   block [0x828628D8..0x82862924)
	// 828628D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828628DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828628E0: 419A0298  beq cr6, 0x82862b78
	if ctx.cr[6].eq {
	pc = 0x82862B78; continue 'dispatch;
	}
	// 828628E4: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 828628E8: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828628EC: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 828628F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828628F4: 419A00F4  beq cr6, 0x828629e8
	if ctx.cr[6].eq {
	pc = 0x828629E8; continue 'dispatch;
	}
	// 828628F8: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828628FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862900: 419A0024  beq cr6, 0x82862924
	if ctx.cr[6].eq {
	pc = 0x82862924; continue 'dispatch;
	}
	// 82862904: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82862908: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286290C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82862910: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82862914: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862918: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8286291C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862920: 480000CC  b 0x828629ec
	pc = 0x828629EC; continue 'dispatch;
            }
            0x82862924 => {
    //   block [0x82862924..0x82862940)
	// 82862924: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82862928: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286292C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82862930: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82862934: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82862938: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286293C: 40810054  ble 0x82862990
	if !ctx.cr[0].gt {
	pc = 0x82862990; continue 'dispatch;
	}
	pc = 0x82862940; continue 'dispatch;
            }
            0x82862940 => {
    //   block [0x82862940..0x82862960)
	// 82862940: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82862944: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82862948: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286294C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862950: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 82862954: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82862958: 41980008  blt cr6, 0x82862960
	if ctx.cr[6].lt {
	pc = 0x82862960; continue 'dispatch;
	}
	// 8286295C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x82862960; continue 'dispatch;
            }
            0x82862960 => {
    //   block [0x82862960..0x8286297C)
	// 82862960: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82862964: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82862968: 419A0014  beq cr6, 0x8286297c
	if ctx.cr[6].eq {
	pc = 0x8286297C; continue 'dispatch;
	}
	// 8286296C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82862970: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82862974: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82862978: 4800000C  b 0x82862984
	pc = 0x82862984; continue 'dispatch;
            }
            0x8286297C => {
    //   block [0x8286297C..0x82862984)
	// 8286297C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82862980: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82862984; continue 'dispatch;
            }
            0x82862984 => {
    //   block [0x82862984..0x82862990)
	// 82862984: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862988: 4199FFB8  bgt cr6, 0x82862940
	if ctx.cr[6].gt {
	pc = 0x82862940; continue 'dispatch;
	}
	// 8286298C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82862990; continue 'dispatch;
            }
            0x82862990 => {
    //   block [0x82862990..0x828629AC)
	// 82862990: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82862994: 419A0040  beq cr6, 0x828629d4
	if ctx.cr[6].eq {
	pc = 0x828629D4; continue 'dispatch;
	}
	// 82862998: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286299C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828629A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828629A4: 41990008  bgt cr6, 0x828629ac
	if ctx.cr[6].gt {
	pc = 0x828629AC; continue 'dispatch;
	}
	// 828629A8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828629AC; continue 'dispatch;
            }
            0x828629AC => {
    //   block [0x828629AC..0x828629D4)
	// 828629AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828629B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828629B4: 409A0020  bne cr6, 0x828629d4
	if !ctx.cr[6].eq {
	pc = 0x828629D4; continue 'dispatch;
	}
	// 828629B8: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828629BC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828629C0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828629C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828629C8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828629CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828629D0: 4800001C  b 0x828629ec
	pc = 0x828629EC; continue 'dispatch;
            }
            0x828629D4 => {
    //   block [0x828629D4..0x828629E8)
	// 828629D4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828629D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828629DC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828629E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828629E4: 48000008  b 0x828629ec
	pc = 0x828629EC; continue 'dispatch;
            }
            0x828629E8 => {
    //   block [0x828629E8..0x828629EC)
	// 828629E8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828629EC; continue 'dispatch;
            }
            0x828629EC => {
    //   block [0x828629EC..0x82862A58)
	// 828629EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828629F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828629F4: 419A0184  beq cr6, 0x82862b78
	if ctx.cr[6].eq {
	pc = 0x82862B78; continue 'dispatch;
	}
	// 828629F8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828629FC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82862A00: 388BF678  addi r4, r11, -0x988
	ctx.r[4].s64 = ctx.r[11].s64 + -2440;
	// 82862A04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82862A08: 4B9CA4C9  bl 0x8222ced0
	ctx.lr = 0x82862A0C;
	sub_8222CED0(ctx, base);
	// 82862A0C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82862A10: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82862A14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82862A18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82862A1C: 4BBBED35  bl 0x82421750
	ctx.lr = 0x82862A20;
	sub_82421750(ctx, base);
	// 82862A20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82862A24: 4B9B23B5  bl 0x82214dd8
	ctx.lr = 0x82862A28;
	sub_82214DD8(ctx, base);
	// 82862A28: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82862A2C: 4B9BC82D  bl 0x8221f258
	ctx.lr = 0x82862A30;
	sub_8221F258(ctx, base);
	// 82862A30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82862A34: 419A0024  beq cr6, 0x82862a58
	if ctx.cr[6].eq {
	pc = 0x82862A58; continue 'dispatch;
	}
	// 82862A38: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82862A3C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82862A40: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82862A44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82862A48: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82862A4C: 4BA211E5  bl 0x82283c30
	ctx.lr = 0x82862A50;
	sub_82283C30(ctx, base);
	// 82862A50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82862A54: 48000008  b 0x82862a5c
	pc = 0x82862A5C; continue 'dispatch;
            }
            0x82862A58 => {
    //   block [0x82862A58..0x82862A5C)
	// 82862A58: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x82862A5C; continue 'dispatch;
            }
            0x82862A5C => {
    //   block [0x82862A5C..0x82862AA8)
	// 82862A5C: 3BDB0014  addi r30, r27, 0x14
	ctx.r[30].s64 = ctx.r[27].s64 + 20;
	// 82862A60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862A64: 4BA105F5  bl 0x82273058
	ctx.lr = 0x82862A68;
	sub_82273058(ctx, base);
	// 82862A68: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82862A6C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82862A70: 80BB0014  lwz r5, 0x14(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82862A74: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 82862A78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82862A7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82862A80: 4B96B6C1  bl 0x821ce140
	ctx.lr = 0x82862A84;
	sub_821CE140(ctx, base);
	// 82862A84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862A88: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 82862A8C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862A90: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82862A94: 419A007C  beq cr6, 0x82862b10
	if ctx.cr[6].eq {
	pc = 0x82862B10; continue 'dispatch;
	}
	// 82862A98: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82862A9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82862AA0: 419A0040  beq cr6, 0x82862ae0
	if ctx.cr[6].eq {
	pc = 0x82862AE0; continue 'dispatch;
	}
	// 82862AA4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82862AA8; continue 'dispatch;
            }
            0x82862AA8 => {
    //   block [0x82862AA8..0x82862ADC)
	// 82862AA8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82862AAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82862AB0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82862AB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82862AB8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82862ABC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82862AC0: 4082FFE8  bne 0x82862aa8
	if !ctx.cr[0].eq {
	pc = 0x82862AA8; continue 'dispatch;
	}
	// 82862AC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862AC8: 409A0014  bne cr6, 0x82862adc
	if !ctx.cr[6].eq {
	pc = 0x82862ADC; continue 'dispatch;
	}
	// 82862ACC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862AD0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862AD4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82862AD8: 4E800421  bctrl
	ctx.lr = 0x82862ADC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82862ADC => {
    //   block [0x82862ADC..0x82862AE0)
	// 82862ADC: 939B0010  stw r28, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	pc = 0x82862AE0; continue 'dispatch;
            }
            0x82862AE0 => {
    //   block [0x82862AE0..0x82862AF4)
	// 82862AE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862AE8: 917B0010  stw r11, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82862AEC: 419A0024  beq cr6, 0x82862b10
	if ctx.cr[6].eq {
	pc = 0x82862B10; continue 'dispatch;
	}
	// 82862AF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82862AF4; continue 'dispatch;
            }
            0x82862AF4 => {
    //   block [0x82862AF4..0x82862B10)
	// 82862AF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82862AF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82862AFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82862B00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82862B04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82862B08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82862B0C: 4082FFE8  bne 0x82862af4
	if !ctx.cr[0].eq {
	pc = 0x82862AF4; continue 'dispatch;
	}
	pc = 0x82862B10; continue 'dispatch;
            }
            0x82862B10 => {
    //   block [0x82862B10..0x82862B24)
	// 82862B10: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82862B14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862B18: 419A0048  beq cr6, 0x82862b60
	if ctx.cr[6].eq {
	pc = 0x82862B60; continue 'dispatch;
	}
	// 82862B1C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82862B20: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82862B24; continue 'dispatch;
            }
            0x82862B24 => {
    //   block [0x82862B24..0x82862B5C)
	// 82862B24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82862B28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82862B2C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82862B30: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82862B34: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82862B38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82862B3C: 4082FFE8  bne 0x82862b24
	if !ctx.cr[0].eq {
	pc = 0x82862B24; continue 'dispatch;
	}
	// 82862B40: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82862B44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862B48: 409A0014  bne cr6, 0x82862b5c
	if !ctx.cr[6].eq {
	pc = 0x82862B5C; continue 'dispatch;
	}
	// 82862B4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862B50: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862B54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82862B58: 4E800421  bctrl
	ctx.lr = 0x82862B5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82862B5C => {
    //   block [0x82862B5C..0x82862B60)
	// 82862B5C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x82862B60; continue 'dispatch;
            }
            0x82862B60 => {
    //   block [0x82862B60..0x82862B78)
	// 82862B60: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862B64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82862B68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862B6C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82862B70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82862B74: 4E800421  bctrl
	ctx.lr = 0x82862B78;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82862B78 => {
    //   block [0x82862B78..0x82862B80)
	// 82862B78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82862B7C: 484468D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862B80 size=432
    let mut pc: u32 = 0x82862B80;
    'dispatch: loop {
        match pc {
            0x82862B80 => {
    //   block [0x82862B80..0x82862BE4)
	// 82862B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862B84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862B88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82862B8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862B90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862B94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82862B98: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82862B9C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82862BA0: 419A0178  beq cr6, 0x82862d18
	if ctx.cr[6].eq {
	pc = 0x82862D18; continue 'dispatch;
	}
	// 82862BA4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862BA8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82862BAC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82862BB0: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82862BB4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82862BB8: 419A00E8  beq cr6, 0x82862ca0
	if ctx.cr[6].eq {
	pc = 0x82862CA0; continue 'dispatch;
	}
	// 82862BBC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82862BC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82862BC4: 419A0020  beq cr6, 0x82862be4
	if ctx.cr[6].eq {
	pc = 0x82862BE4; continue 'dispatch;
	}
	// 82862BC8: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 82862BCC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82862BD0: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82862BD4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82862BD8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82862BDC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862BE0: 480000C8  b 0x82862ca8
	pc = 0x82862CA8; continue 'dispatch;
            }
            0x82862BE4 => {
    //   block [0x82862BE4..0x82862C00)
	// 82862BE4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82862BE8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82862BEC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82862BF0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82862BF4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82862BF8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862BFC: 40810054  ble 0x82862c50
	if !ctx.cr[0].gt {
	pc = 0x82862C50; continue 'dispatch;
	}
	pc = 0x82862C00; continue 'dispatch;
            }
            0x82862C00 => {
    //   block [0x82862C00..0x82862C20)
	// 82862C00: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82862C04: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82862C08: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82862C0C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862C10: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82862C14: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82862C18: 41980008  blt cr6, 0x82862c20
	if ctx.cr[6].lt {
	pc = 0x82862C20; continue 'dispatch;
	}
	// 82862C1C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82862C20; continue 'dispatch;
            }
            0x82862C20 => {
    //   block [0x82862C20..0x82862C3C)
	// 82862C20: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82862C24: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82862C28: 419A0014  beq cr6, 0x82862c3c
	if ctx.cr[6].eq {
	pc = 0x82862C3C; continue 'dispatch;
	}
	// 82862C2C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82862C30: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82862C34: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82862C38: 4800000C  b 0x82862c44
	pc = 0x82862C44; continue 'dispatch;
            }
            0x82862C3C => {
    //   block [0x82862C3C..0x82862C44)
	// 82862C3C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82862C40: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82862C44; continue 'dispatch;
            }
            0x82862C44 => {
    //   block [0x82862C44..0x82862C50)
	// 82862C44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862C48: 4199FFB8  bgt cr6, 0x82862c00
	if ctx.cr[6].gt {
	pc = 0x82862C00; continue 'dispatch;
	}
	// 82862C4C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82862C50; continue 'dispatch;
            }
            0x82862C50 => {
    //   block [0x82862C50..0x82862C6C)
	// 82862C50: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82862C54: 419A003C  beq cr6, 0x82862c90
	if ctx.cr[6].eq {
	pc = 0x82862C90; continue 'dispatch;
	}
	// 82862C58: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862C5C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82862C60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862C64: 41990008  bgt cr6, 0x82862c6c
	if ctx.cr[6].gt {
	pc = 0x82862C6C; continue 'dispatch;
	}
	// 82862C68: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82862C6C; continue 'dispatch;
            }
            0x82862C6C => {
    //   block [0x82862C6C..0x82862C90)
	// 82862C6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82862C70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862C74: 409A001C  bne cr6, 0x82862c90
	if !ctx.cr[6].eq {
	pc = 0x82862C90; continue 'dispatch;
	}
	// 82862C78: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82862C7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82862C80: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82862C84: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82862C88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862C8C: 4800001C  b 0x82862ca8
	pc = 0x82862CA8; continue 'dispatch;
            }
            0x82862C90 => {
    //   block [0x82862C90..0x82862CA0)
	// 82862C90: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82862C94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82862C98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862C9C: 4800000C  b 0x82862ca8
	pc = 0x82862CA8; continue 'dispatch;
            }
            0x82862CA0 => {
    //   block [0x82862CA0..0x82862CA8)
	// 82862CA0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82862CA4: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x82862CA8; continue 'dispatch;
            }
            0x82862CA8 => {
    //   block [0x82862CA8..0x82862CD0)
	// 82862CA8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82862CAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82862CB0: 419A0068  beq cr6, 0x82862d18
	if ctx.cr[6].eq {
	pc = 0x82862D18; continue 'dispatch;
	}
	// 82862CB4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82862CB8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82862CBC: 4BA4B365  bl 0x822ae020
	ctx.lr = 0x82862CC0;
	sub_822AE020(ctx, base);
	// 82862CC0: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82862CC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82862CC8: 419A0040  beq cr6, 0x82862d08
	if ctx.cr[6].eq {
	pc = 0x82862D08; continue 'dispatch;
	}
	// 82862CCC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82862CD0; continue 'dispatch;
            }
            0x82862CD0 => {
    //   block [0x82862CD0..0x82862D04)
	// 82862CD0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82862CD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82862CD8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82862CDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82862CE0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82862CE4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82862CE8: 4082FFE8  bne 0x82862cd0
	if !ctx.cr[0].eq {
	pc = 0x82862CD0; continue 'dispatch;
	}
	// 82862CEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862CF0: 409A0014  bne cr6, 0x82862d04
	if !ctx.cr[6].eq {
	pc = 0x82862D04; continue 'dispatch;
	}
	// 82862CF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862CF8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862CFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82862D00: 4E800421  bctrl
	ctx.lr = 0x82862D04;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82862D04 => {
    //   block [0x82862D04..0x82862D08)
	// 82862D04: 93FE0010  stw r31, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	pc = 0x82862D08; continue 'dispatch;
            }
            0x82862D08 => {
    //   block [0x82862D08..0x82862D18)
	// 82862D08: 93FE0010  stw r31, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82862D0C: 387E0014  addi r3, r30, 0x14
	ctx.r[3].s64 = ctx.r[30].s64 + 20;
	// 82862D10: 4B954E09  bl 0x821b7b18
	ctx.lr = 0x82862D14;
	sub_821B7B18(ctx, base);
	// 82862D14: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	pc = 0x82862D18; continue 'dispatch;
            }
            0x82862D18 => {
    //   block [0x82862D18..0x82862D30)
	// 82862D18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82862D1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862D20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862D24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82862D28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862D2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862D30 size=96
    let mut pc: u32 = 0x82862D30;
    'dispatch: loop {
        match pc {
            0x82862D30 => {
    //   block [0x82862D30..0x82862D80)
	// 82862D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862D38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862D3C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82862D40: 81650014  lwz r11, 0x14(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 82862D44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862D48: 419A0038  beq cr6, 0x82862d80
	if ctx.cr[6].eq {
	pc = 0x82862D80; continue 'dispatch;
	}
	// 82862D4C: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862D50: 4B9A4AA1  bl 0x822077f0
	ctx.lr = 0x82862D54;
	sub_822077F0(ctx, base);
	// 82862D54: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82862D58: 80650014  lwz r3, 0x14(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 82862D5C: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 82862D60: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862D64: FC010024  fdiv f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 82862D68: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82862D6C: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82862D70: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82862D74: EC2D602A  fadds f1, f13, f12
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82862D78: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82862D7C: 4E800421  bctrl
	ctx.lr = 0x82862D80;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82862D80 => {
    //   block [0x82862D80..0x82862D90)
	// 82862D80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82862D84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862D88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862D8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862D90 size=420
    let mut pc: u32 = 0x82862D90;
    'dispatch: loop {
        match pc {
            0x82862D90 => {
    //   block [0x82862D90..0x82862E0C)
	// 82862D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862D98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862D9C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82862DA0: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862DA4: 4B9A4A4D  bl 0x822077f0
	ctx.lr = 0x82862DA8;
	sub_822077F0(ctx, base);
	// 82862DA8: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 82862DAC: 8105001C  lwz r8, 0x1c(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 82862DB0: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862DB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82862DB8: C8099660  lfd f0, -0x69a0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27040 as u32) ) };
	// 82862DBC: FC010024  fdiv f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 82862DC0: C1A80000  lfs f13, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82862DC4: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82862DC8: ED6D6028  fsubs f11, f13, f12
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82862DCC: D1680000  stfs f11, 0(r8)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82862DD0: 80EB0028  lwz r7, 0x28(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82862DD4: 54E6A7FE  rlwinm r6, r7, 0x14, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x00000FFFu64;
	// 82862DD8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82862DDC: 419A00F8  beq cr6, 0x82862ed4
	if ctx.cr[6].eq {
	pc = 0x82862ED4; continue 'dispatch;
	}
	// 82862DE0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82862DE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82862DE8: 419A0024  beq cr6, 0x82862e0c
	if ctx.cr[6].eq {
	pc = 0x82862E0C; continue 'dispatch;
	}
	// 82862DEC: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82862DF0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82862DF4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82862DF8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82862DFC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862E00: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82862E04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862E08: 480000D0  b 0x82862ed8
	pc = 0x82862ED8; continue 'dispatch;
            }
            0x82862E0C => {
    //   block [0x82862E0C..0x82862E2C)
	// 82862E0C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82862E10: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82862E14: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82862E18: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82862E1C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82862E20: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82862E24: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862E28: 40810054  ble 0x82862e7c
	if !ctx.cr[0].gt {
	pc = 0x82862E7C; continue 'dispatch;
	}
	pc = 0x82862E2C; continue 'dispatch;
            }
            0x82862E2C => {
    //   block [0x82862E2C..0x82862E4C)
	// 82862E2C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82862E30: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82862E34: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82862E38: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862E3C: 2F07002C  cmpwi cr6, r7, 0x2c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 44, &mut ctx.xer);
	// 82862E40: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82862E44: 41980008  blt cr6, 0x82862e4c
	if ctx.cr[6].lt {
	pc = 0x82862E4C; continue 'dispatch;
	}
	// 82862E48: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82862E4C; continue 'dispatch;
            }
            0x82862E4C => {
    //   block [0x82862E4C..0x82862E68)
	// 82862E4C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82862E50: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82862E54: 419A0014  beq cr6, 0x82862e68
	if ctx.cr[6].eq {
	pc = 0x82862E68; continue 'dispatch;
	}
	// 82862E58: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82862E5C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82862E60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82862E64: 4800000C  b 0x82862e70
	pc = 0x82862E70; continue 'dispatch;
            }
            0x82862E68 => {
    //   block [0x82862E68..0x82862E70)
	// 82862E68: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82862E6C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82862E70; continue 'dispatch;
            }
            0x82862E70 => {
    //   block [0x82862E70..0x82862E7C)
	// 82862E70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862E74: 4199FFB8  bgt cr6, 0x82862e2c
	if ctx.cr[6].gt {
	pc = 0x82862E2C; continue 'dispatch;
	}
	// 82862E78: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82862E7C; continue 'dispatch;
            }
            0x82862E7C => {
    //   block [0x82862E7C..0x82862E98)
	// 82862E7C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82862E80: 419A0040  beq cr6, 0x82862ec0
	if ctx.cr[6].eq {
	pc = 0x82862EC0; continue 'dispatch;
	}
	// 82862E84: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862E88: 2F0B002C  cmpwi cr6, r11, 0x2c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 44, &mut ctx.xer);
	// 82862E8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862E90: 41990008  bgt cr6, 0x82862e98
	if ctx.cr[6].gt {
	pc = 0x82862E98; continue 'dispatch;
	}
	// 82862E94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82862E98; continue 'dispatch;
            }
            0x82862E98 => {
    //   block [0x82862E98..0x82862EC0)
	// 82862E98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82862E9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862EA0: 409A0020  bne cr6, 0x82862ec0
	if !ctx.cr[6].eq {
	pc = 0x82862EC0; continue 'dispatch;
	}
	// 82862EA4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82862EA8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82862EAC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82862EB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862EB4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82862EB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862EBC: 4800001C  b 0x82862ed8
	pc = 0x82862ED8; continue 'dispatch;
            }
            0x82862EC0 => {
    //   block [0x82862EC0..0x82862ED4)
	// 82862EC0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82862EC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862EC8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82862ECC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862ED0: 48000008  b 0x82862ed8
	pc = 0x82862ED8; continue 'dispatch;
            }
            0x82862ED4 => {
    //   block [0x82862ED4..0x82862ED8)
	// 82862ED4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82862ED8; continue 'dispatch;
            }
            0x82862ED8 => {
    //   block [0x82862ED8..0x82862EF0)
	// 82862ED8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82862EDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862EE0: 419A0010  beq cr6, 0x82862ef0
	if ctx.cr[6].eq {
	pc = 0x82862EF0; continue 'dispatch;
	}
	// 82862EE4: 816A0064  lwz r11, 0x64(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 82862EE8: 6169000F  ori r9, r11, 0xf
	ctx.r[9].u64 = ctx.r[11].u64 | 15;
	// 82862EEC: 912A0064  stw r9, 0x64(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	pc = 0x82862EF0; continue 'dispatch;
            }
            0x82862EF0 => {
    //   block [0x82862EF0..0x82862F10)
	// 82862EF0: 8165001C  lwz r11, 0x1c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 82862EF4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82862EF8: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82862EFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862F00: C00A9484  lfs f0, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82862F04: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82862F08: 41980008  blt cr6, 0x82862f10
	if ctx.cr[6].lt {
	pc = 0x82862F10; continue 'dispatch;
	}
	// 82862F0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82862F10; continue 'dispatch;
            }
            0x82862F10 => {
    //   block [0x82862F10..0x82862F24)
	// 82862F10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82862F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862F18: 419A000C  beq cr6, 0x82862f24
	if ctx.cr[6].eq {
	pc = 0x82862F24; continue 'dispatch;
	}
	// 82862F1C: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82862F20: 4BFF2031  bl 0x82854f50
	ctx.lr = 0x82862F24;
	sub_82854F50(ctx, base);
	pc = 0x82862F24; continue 'dispatch;
            }
            0x82862F24 => {
    //   block [0x82862F24..0x82862F34)
	// 82862F24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82862F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82862F38 size=8
    let mut pc: u32 = 0x82862F38;
    'dispatch: loop {
        match pc {
            0x82862F38 => {
    //   block [0x82862F38..0x82862F40)
	// 82862F38: 3860001D  li r3, 0x1d
	ctx.r[3].s64 = 29;
	// 82862F3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82862F40 size=8
    let mut pc: u32 = 0x82862F40;
    'dispatch: loop {
        match pc {
            0x82862F40 => {
    //   block [0x82862F40..0x82862F48)
	// 82862F40: 3860001F  li r3, 0x1f
	ctx.r[3].s64 = 31;
	// 82862F44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862F48 size=412
    let mut pc: u32 = 0x82862F48;
    'dispatch: loop {
        match pc {
            0x82862F48 => {
    //   block [0x82862F48..0x82862FB0)
	// 82862F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862F4C: 484464C1  bl 0x82ca940c
	ctx.lr = 0x82862F50;
	sub_82CA93D0(ctx, base);
	// 82862F50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862F54: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862F58: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82862F5C: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82862F60: 554917FE  rlwinm r9, r10, 2, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 82862F64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82862F68: 409A0174  bne cr6, 0x828630dc
	if !ctx.cr[6].eq {
	pc = 0x828630DC; continue 'dispatch;
	}
	// 82862F6C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82862F70: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82862F74: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 82862F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862F7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82862F80: 419A00F4  beq cr6, 0x82863074
	if ctx.cr[6].eq {
	pc = 0x82863074; continue 'dispatch;
	}
	// 82862F84: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82862F88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82862F8C: 419A0024  beq cr6, 0x82862fb0
	if ctx.cr[6].eq {
	pc = 0x82862FB0; continue 'dispatch;
	}
	// 82862F90: 894A0002  lbz r10, 2(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 82862F94: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82862F98: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82862F9C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82862FA0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862FA4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82862FA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862FAC: 480000CC  b 0x82863078
	pc = 0x82863078; continue 'dispatch;
            }
            0x82862FB0 => {
    //   block [0x82862FB0..0x82862FCC)
	// 82862FB0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82862FB4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82862FB8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82862FBC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82862FC0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82862FC4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862FC8: 40810054  ble 0x8286301c
	if !ctx.cr[0].gt {
	pc = 0x8286301C; continue 'dispatch;
	}
	pc = 0x82862FCC; continue 'dispatch;
            }
            0x82862FCC => {
    //   block [0x82862FCC..0x82862FEC)
	// 82862FCC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82862FD0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82862FD4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82862FD8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862FDC: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 82862FE0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82862FE4: 41980008  blt cr6, 0x82862fec
	if ctx.cr[6].lt {
	pc = 0x82862FEC; continue 'dispatch;
	}
	// 82862FE8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82862FEC; continue 'dispatch;
            }
            0x82862FEC => {
    //   block [0x82862FEC..0x82863008)
	// 82862FEC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82862FF0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82862FF4: 419A0014  beq cr6, 0x82863008
	if ctx.cr[6].eq {
	pc = 0x82863008; continue 'dispatch;
	}
	// 82862FF8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82862FFC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82863000: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82863004: 4800000C  b 0x82863010
	pc = 0x82863010; continue 'dispatch;
            }
            0x82863008 => {
    //   block [0x82863008..0x82863010)
	// 82863008: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286300C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82863010; continue 'dispatch;
            }
            0x82863010 => {
    //   block [0x82863010..0x8286301C)
	// 82863010: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863014: 4199FFB8  bgt cr6, 0x82862fcc
	if ctx.cr[6].gt {
	pc = 0x82862FCC; continue 'dispatch;
	}
	// 82863018: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8286301C; continue 'dispatch;
            }
            0x8286301C => {
    //   block [0x8286301C..0x82863038)
	// 8286301C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82863020: 419A0040  beq cr6, 0x82863060
	if ctx.cr[6].eq {
	pc = 0x82863060; continue 'dispatch;
	}
	// 82863024: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863028: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8286302C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863030: 41990008  bgt cr6, 0x82863038
	if ctx.cr[6].gt {
	pc = 0x82863038; continue 'dispatch;
	}
	// 82863034: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82863038; continue 'dispatch;
            }
            0x82863038 => {
    //   block [0x82863038..0x82863060)
	// 82863038: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286303C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863040: 409A0020  bne cr6, 0x82863060
	if !ctx.cr[6].eq {
	pc = 0x82863060; continue 'dispatch;
	}
	// 82863044: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82863048: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8286304C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82863050: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863054: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863058: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286305C: 4800001C  b 0x82863078
	pc = 0x82863078; continue 'dispatch;
            }
            0x82863060 => {
    //   block [0x82863060..0x82863074)
	// 82863060: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82863064: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863068: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286306C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863070: 48000008  b 0x82863078
	pc = 0x82863078; continue 'dispatch;
            }
            0x82863074 => {
    //   block [0x82863074..0x82863078)
	// 82863074: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82863078; continue 'dispatch;
            }
            0x82863078 => {
    //   block [0x82863078..0x828630DC)
	// 82863078: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286307C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863080: 419A005C  beq cr6, 0x828630dc
	if ctx.cr[6].eq {
	pc = 0x828630DC; continue 'dispatch;
	}
	// 82863084: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863088: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 8286308C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82863090: 4E800421  bctrl
	ctx.lr = 0x82863094;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82863094: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82863098: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286309C: 4B92AC65  bl 0x8218dd00
	ctx.lr = 0x828630A0;
	sub_8218DD00(ctx, base);
	// 828630A0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828630A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828630A8: 419A0034  beq cr6, 0x828630dc
	if ctx.cr[6].eq {
	pc = 0x828630DC; continue 'dispatch;
	}
	// 828630AC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828630B0: 3BDF0074  addi r30, r31, 0x74
	ctx.r[30].s64 = ctx.r[31].s64 + 116;
	// 828630B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828630B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828630BC: 4BA31BD5  bl 0x82294c90
	ctx.lr = 0x828630C0;
	sub_82294C90(ctx, base);
	// 828630C0: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828630C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828630C8: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828630CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828630D0: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828630D4: 38AB000E  addi r5, r11, 0xe
	ctx.r[5].s64 = ctx.r[11].s64 + 14;
	// 828630D8: 4B977A71  bl 0x821dab48
	ctx.lr = 0x828630DC;
	sub_821DAB48(ctx, base);
            }
            0x828630DC => {
    //   block [0x828630DC..0x828630E4)
	// 828630DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828630E0: 4844637C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828630E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828630E8 size=924
    let mut pc: u32 = 0x828630E8;
    'dispatch: loop {
        match pc {
            0x828630E8 => {
    //   block [0x828630E8..0x82863150)
	// 828630E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828630EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828630F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828630F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828630F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828630FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82863100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863104: 4BFFFE45  bl 0x82862f48
	ctx.lr = 0x82863108;
	sub_82862F48(ctx, base);
	// 82863108: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286310C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82863110: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863114: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82863118: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 8286311C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82863120: 419A00F4  beq cr6, 0x82863214
	if ctx.cr[6].eq {
	pc = 0x82863214; continue 'dispatch;
	}
	// 82863124: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82863128: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286312C: 419A0024  beq cr6, 0x82863150
	if ctx.cr[6].eq {
	pc = 0x82863150; continue 'dispatch;
	}
	// 82863130: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 82863134: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82863138: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8286313C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82863140: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863144: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863148: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286314C: 480000CC  b 0x82863218
	pc = 0x82863218; continue 'dispatch;
            }
            0x82863150 => {
    //   block [0x82863150..0x8286316C)
	// 82863150: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82863154: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82863158: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8286315C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82863160: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82863164: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863168: 40810054  ble 0x828631bc
	if !ctx.cr[0].gt {
	pc = 0x828631BC; continue 'dispatch;
	}
	pc = 0x8286316C; continue 'dispatch;
            }
            0x8286316C => {
    //   block [0x8286316C..0x8286318C)
	// 8286316C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82863170: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82863174: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82863178: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286317C: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 82863180: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82863184: 41980008  blt cr6, 0x8286318c
	if ctx.cr[6].lt {
	pc = 0x8286318C; continue 'dispatch;
	}
	// 82863188: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x8286318C; continue 'dispatch;
            }
            0x8286318C => {
    //   block [0x8286318C..0x828631A8)
	// 8286318C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82863190: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82863194: 419A0014  beq cr6, 0x828631a8
	if ctx.cr[6].eq {
	pc = 0x828631A8; continue 'dispatch;
	}
	// 82863198: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286319C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828631A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828631A4: 4800000C  b 0x828631b0
	pc = 0x828631B0; continue 'dispatch;
            }
            0x828631A8 => {
    //   block [0x828631A8..0x828631B0)
	// 828631A8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828631AC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828631B0; continue 'dispatch;
            }
            0x828631B0 => {
    //   block [0x828631B0..0x828631BC)
	// 828631B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828631B4: 4199FFB8  bgt cr6, 0x8286316c
	if ctx.cr[6].gt {
	pc = 0x8286316C; continue 'dispatch;
	}
	// 828631B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828631BC; continue 'dispatch;
            }
            0x828631BC => {
    //   block [0x828631BC..0x828631D8)
	// 828631BC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828631C0: 419A0040  beq cr6, 0x82863200
	if ctx.cr[6].eq {
	pc = 0x82863200; continue 'dispatch;
	}
	// 828631C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828631C8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828631CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828631D0: 41990008  bgt cr6, 0x828631d8
	if ctx.cr[6].gt {
	pc = 0x828631D8; continue 'dispatch;
	}
	// 828631D4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828631D8; continue 'dispatch;
            }
            0x828631D8 => {
    //   block [0x828631D8..0x82863200)
	// 828631D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828631DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828631E0: 409A0020  bne cr6, 0x82863200
	if !ctx.cr[6].eq {
	pc = 0x82863200; continue 'dispatch;
	}
	// 828631E4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828631E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828631EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828631F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828631F4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828631F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828631FC: 4800001C  b 0x82863218
	pc = 0x82863218; continue 'dispatch;
            }
            0x82863200 => {
    //   block [0x82863200..0x82863214)
	// 82863200: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82863204: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863208: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286320C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863210: 48000008  b 0x82863218
	pc = 0x82863218; continue 'dispatch;
            }
            0x82863214 => {
    //   block [0x82863214..0x82863218)
	// 82863214: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82863218; continue 'dispatch;
            }
            0x82863218 => {
    //   block [0x82863218..0x8286322C)
	// 82863218: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286321C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863220: 419A000C  beq cr6, 0x8286322c
	if ctx.cr[6].eq {
	pc = 0x8286322C; continue 'dispatch;
	}
	// 82863224: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82863228: 4BD0F381  bl 0x825725a8
	ctx.lr = 0x8286322C;
	sub_825725A8(ctx, base);
	pc = 0x8286322C; continue 'dispatch;
            }
            0x8286322C => {
    //   block [0x8286322C..0x82863270)
	// 8286322C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863230: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863234: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82863238: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8286323C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82863240: 419A00F4  beq cr6, 0x82863334
	if ctx.cr[6].eq {
	pc = 0x82863334; continue 'dispatch;
	}
	// 82863244: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82863248: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286324C: 419A0024  beq cr6, 0x82863270
	if ctx.cr[6].eq {
	pc = 0x82863270; continue 'dispatch;
	}
	// 82863250: 892A001F  lbz r9, 0x1f(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(31 as u32) ) } as u64;
	// 82863254: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82863258: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8286325C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82863260: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863264: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863268: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286326C: 480000CC  b 0x82863338
	pc = 0x82863338; continue 'dispatch;
            }
            0x82863270 => {
    //   block [0x82863270..0x8286328C)
	// 82863270: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82863274: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82863278: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8286327C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82863280: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82863284: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863288: 40810054  ble 0x828632dc
	if !ctx.cr[0].gt {
	pc = 0x828632DC; continue 'dispatch;
	}
	pc = 0x8286328C; continue 'dispatch;
            }
            0x8286328C => {
    //   block [0x8286328C..0x828632AC)
	// 8286328C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82863290: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82863294: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82863298: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286329C: 2F07001F  cmpwi cr6, r7, 0x1f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 31, &mut ctx.xer);
	// 828632A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828632A4: 41980008  blt cr6, 0x828632ac
	if ctx.cr[6].lt {
	pc = 0x828632AC; continue 'dispatch;
	}
	// 828632A8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x828632AC; continue 'dispatch;
            }
            0x828632AC => {
    //   block [0x828632AC..0x828632C8)
	// 828632AC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828632B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828632B4: 419A0014  beq cr6, 0x828632c8
	if ctx.cr[6].eq {
	pc = 0x828632C8; continue 'dispatch;
	}
	// 828632B8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828632BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828632C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828632C4: 4800000C  b 0x828632d0
	pc = 0x828632D0; continue 'dispatch;
            }
            0x828632C8 => {
    //   block [0x828632C8..0x828632D0)
	// 828632C8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828632CC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828632D0; continue 'dispatch;
            }
            0x828632D0 => {
    //   block [0x828632D0..0x828632DC)
	// 828632D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828632D4: 4199FFB8  bgt cr6, 0x8286328c
	if ctx.cr[6].gt {
	pc = 0x8286328C; continue 'dispatch;
	}
	// 828632D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828632DC; continue 'dispatch;
            }
            0x828632DC => {
    //   block [0x828632DC..0x828632F8)
	// 828632DC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828632E0: 419A0040  beq cr6, 0x82863320
	if ctx.cr[6].eq {
	pc = 0x82863320; continue 'dispatch;
	}
	// 828632E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828632E8: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 828632EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828632F0: 41990008  bgt cr6, 0x828632f8
	if ctx.cr[6].gt {
	pc = 0x828632F8; continue 'dispatch;
	}
	// 828632F4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828632F8; continue 'dispatch;
            }
            0x828632F8 => {
    //   block [0x828632F8..0x82863320)
	// 828632F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828632FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863300: 409A0020  bne cr6, 0x82863320
	if !ctx.cr[6].eq {
	pc = 0x82863320; continue 'dispatch;
	}
	// 82863304: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82863308: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8286330C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82863310: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863314: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863318: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286331C: 4800001C  b 0x82863338
	pc = 0x82863338; continue 'dispatch;
            }
            0x82863320 => {
    //   block [0x82863320..0x82863334)
	// 82863320: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82863324: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863328: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286332C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863330: 48000008  b 0x82863338
	pc = 0x82863338; continue 'dispatch;
            }
            0x82863334 => {
    //   block [0x82863334..0x82863338)
	// 82863334: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82863338; continue 'dispatch;
            }
            0x82863338 => {
    //   block [0x82863338..0x8286334C)
	// 82863338: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286333C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863340: 419A000C  beq cr6, 0x8286334c
	if ctx.cr[6].eq {
	pc = 0x8286334C; continue 'dispatch;
	}
	// 82863344: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82863348: 4BD61D49  bl 0x825c5090
	ctx.lr = 0x8286334C;
	sub_825C5090(ctx, base);
	pc = 0x8286334C; continue 'dispatch;
            }
            0x8286334C => {
    //   block [0x8286334C..0x82863390)
	// 8286334C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863350: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863354: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82863358: 554917FE  rlwinm r9, r10, 2, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 8286335C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82863360: 419A00F4  beq cr6, 0x82863454
	if ctx.cr[6].eq {
	pc = 0x82863454; continue 'dispatch;
	}
	// 82863364: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82863368: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286336C: 419A0024  beq cr6, 0x82863390
	if ctx.cr[6].eq {
	pc = 0x82863390; continue 'dispatch;
	}
	// 82863370: 892A009E  lbz r9, 0x9e(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(158 as u32) ) } as u64;
	// 82863374: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82863378: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8286337C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82863380: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863384: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863388: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286338C: 480000CC  b 0x82863458
	pc = 0x82863458; continue 'dispatch;
            }
            0x82863390 => {
    //   block [0x82863390..0x828633AC)
	// 82863390: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82863394: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82863398: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8286339C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828633A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828633A4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828633A8: 40810054  ble 0x828633fc
	if !ctx.cr[0].gt {
	pc = 0x828633FC; continue 'dispatch;
	}
	pc = 0x828633AC; continue 'dispatch;
            }
            0x828633AC => {
    //   block [0x828633AC..0x828633CC)
	// 828633AC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828633B0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828633B4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828633B8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828633BC: 2F07009E  cmpwi cr6, r7, 0x9e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 158, &mut ctx.xer);
	// 828633C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828633C4: 41980008  blt cr6, 0x828633cc
	if ctx.cr[6].lt {
	pc = 0x828633CC; continue 'dispatch;
	}
	// 828633C8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x828633CC; continue 'dispatch;
            }
            0x828633CC => {
    //   block [0x828633CC..0x828633E8)
	// 828633CC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828633D0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828633D4: 419A0014  beq cr6, 0x828633e8
	if ctx.cr[6].eq {
	pc = 0x828633E8; continue 'dispatch;
	}
	// 828633D8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828633DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828633E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828633E4: 4800000C  b 0x828633f0
	pc = 0x828633F0; continue 'dispatch;
            }
            0x828633E8 => {
    //   block [0x828633E8..0x828633F0)
	// 828633E8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828633EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828633F0; continue 'dispatch;
            }
            0x828633F0 => {
    //   block [0x828633F0..0x828633FC)
	// 828633F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828633F4: 4199FFB8  bgt cr6, 0x828633ac
	if ctx.cr[6].gt {
	pc = 0x828633AC; continue 'dispatch;
	}
	// 828633F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828633FC; continue 'dispatch;
            }
            0x828633FC => {
    //   block [0x828633FC..0x82863418)
	// 828633FC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82863400: 419A0040  beq cr6, 0x82863440
	if ctx.cr[6].eq {
	pc = 0x82863440; continue 'dispatch;
	}
	// 82863404: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863408: 2F0B009E  cmpwi cr6, r11, 0x9e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 158, &mut ctx.xer);
	// 8286340C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863410: 41990008  bgt cr6, 0x82863418
	if ctx.cr[6].gt {
	pc = 0x82863418; continue 'dispatch;
	}
	// 82863414: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82863418; continue 'dispatch;
            }
            0x82863418 => {
    //   block [0x82863418..0x82863440)
	// 82863418: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286341C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863420: 409A0020  bne cr6, 0x82863440
	if !ctx.cr[6].eq {
	pc = 0x82863440; continue 'dispatch;
	}
	// 82863424: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82863428: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8286342C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82863430: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863434: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863438: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286343C: 4800001C  b 0x82863458
	pc = 0x82863458; continue 'dispatch;
            }
            0x82863440 => {
    //   block [0x82863440..0x82863454)
	// 82863440: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82863444: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863448: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286344C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863450: 48000008  b 0x82863458
	pc = 0x82863458; continue 'dispatch;
            }
            0x82863454 => {
    //   block [0x82863454..0x82863458)
	// 82863454: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82863458; continue 'dispatch;
            }
            0x82863458 => {
    //   block [0x82863458..0x8286346C)
	// 82863458: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286345C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863460: 419A000C  beq cr6, 0x8286346c
	if ctx.cr[6].eq {
	pc = 0x8286346C; continue 'dispatch;
	}
	// 82863464: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82863468: 4BD6DA69  bl 0x825d0ed0
	ctx.lr = 0x8286346C;
	sub_825D0ED0(ctx, base);
	pc = 0x8286346C; continue 'dispatch;
            }
            0x8286346C => {
    //   block [0x8286346C..0x82863484)
	// 8286346C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863470: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863474: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863478: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286347C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863488 size=912
    let mut pc: u32 = 0x82863488;
    'dispatch: loop {
        match pc {
            0x82863488 => {
    //   block [0x82863488..0x828634E8)
	// 82863488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286348C: 48445F81  bl 0x82ca940c
	ctx.lr = 0x82863490;
	sub_82CA93D0(ctx, base);
	// 82863490: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863494: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82863498: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8286349C: 4BFFFAAD  bl 0x82862f48
	ctx.lr = 0x828634A0;
	sub_82862F48(ctx, base);
	// 828634A0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828634A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828634A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828634AC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828634B0: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828634B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828634B8: 419A00F4  beq cr6, 0x828635ac
	if ctx.cr[6].eq {
	pc = 0x828635AC; continue 'dispatch;
	}
	// 828634BC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828634C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828634C4: 419A0024  beq cr6, 0x828634e8
	if ctx.cr[6].eq {
	pc = 0x828634E8; continue 'dispatch;
	}
	// 828634C8: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828634CC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828634D0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828634D4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828634D8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828634DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828634E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828634E4: 480000CC  b 0x828635b0
	pc = 0x828635B0; continue 'dispatch;
            }
            0x828634E8 => {
    //   block [0x828634E8..0x82863504)
	// 828634E8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828634EC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828634F0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828634F4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828634F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828634FC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863500: 40810054  ble 0x82863554
	if !ctx.cr[0].gt {
	pc = 0x82863554; continue 'dispatch;
	}
	pc = 0x82863504; continue 'dispatch;
            }
            0x82863504 => {
    //   block [0x82863504..0x82863524)
	// 82863504: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82863508: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286350C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82863510: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863514: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 82863518: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286351C: 41980008  blt cr6, 0x82863524
	if ctx.cr[6].lt {
	pc = 0x82863524; continue 'dispatch;
	}
	// 82863520: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82863524; continue 'dispatch;
            }
            0x82863524 => {
    //   block [0x82863524..0x82863540)
	// 82863524: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82863528: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286352C: 419A0014  beq cr6, 0x82863540
	if ctx.cr[6].eq {
	pc = 0x82863540; continue 'dispatch;
	}
	// 82863530: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82863534: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82863538: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286353C: 4800000C  b 0x82863548
	pc = 0x82863548; continue 'dispatch;
            }
            0x82863540 => {
    //   block [0x82863540..0x82863548)
	// 82863540: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82863544: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82863548; continue 'dispatch;
            }
            0x82863548 => {
    //   block [0x82863548..0x82863554)
	// 82863548: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286354C: 4199FFB8  bgt cr6, 0x82863504
	if ctx.cr[6].gt {
	pc = 0x82863504; continue 'dispatch;
	}
	// 82863550: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82863554; continue 'dispatch;
            }
            0x82863554 => {
    //   block [0x82863554..0x82863570)
	// 82863554: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82863558: 419A0040  beq cr6, 0x82863598
	if ctx.cr[6].eq {
	pc = 0x82863598; continue 'dispatch;
	}
	// 8286355C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863560: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82863564: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863568: 41990008  bgt cr6, 0x82863570
	if ctx.cr[6].gt {
	pc = 0x82863570; continue 'dispatch;
	}
	// 8286356C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82863570; continue 'dispatch;
            }
            0x82863570 => {
    //   block [0x82863570..0x82863598)
	// 82863570: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82863574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863578: 409A0020  bne cr6, 0x82863598
	if !ctx.cr[6].eq {
	pc = 0x82863598; continue 'dispatch;
	}
	// 8286357C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82863580: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82863584: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82863588: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286358C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863590: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863594: 4800001C  b 0x828635b0
	pc = 0x828635B0; continue 'dispatch;
            }
            0x82863598 => {
    //   block [0x82863598..0x828635AC)
	// 82863598: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286359C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828635A0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828635A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828635A8: 48000008  b 0x828635b0
	pc = 0x828635B0; continue 'dispatch;
            }
            0x828635AC => {
    //   block [0x828635AC..0x828635B0)
	// 828635AC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828635B0; continue 'dispatch;
            }
            0x828635B0 => {
    //   block [0x828635B0..0x828635C4)
	// 828635B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828635B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828635B8: 419A000C  beq cr6, 0x828635c4
	if ctx.cr[6].eq {
	pc = 0x828635C4; continue 'dispatch;
	}
	// 828635BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828635C0: 4BD0EFE9  bl 0x825725a8
	ctx.lr = 0x828635C4;
	sub_825725A8(ctx, base);
	pc = 0x828635C4; continue 'dispatch;
            }
            0x828635C4 => {
    //   block [0x828635C4..0x82863608)
	// 828635C4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828635C8: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828635CC: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828635D0: 554917FE  rlwinm r9, r10, 2, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 828635D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828635D8: 419A00F4  beq cr6, 0x828636cc
	if ctx.cr[6].eq {
	pc = 0x828636CC; continue 'dispatch;
	}
	// 828635DC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828635E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828635E4: 419A0024  beq cr6, 0x82863608
	if ctx.cr[6].eq {
	pc = 0x82863608; continue 'dispatch;
	}
	// 828635E8: 892A009E  lbz r9, 0x9e(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(158 as u32) ) } as u64;
	// 828635EC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828635F0: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828635F4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828635F8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828635FC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82863600: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863604: 480000CC  b 0x828636d0
	pc = 0x828636D0; continue 'dispatch;
            }
            0x82863608 => {
    //   block [0x82863608..0x82863624)
	// 82863608: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286360C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82863610: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82863614: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82863618: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286361C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863620: 40810054  ble 0x82863674
	if !ctx.cr[0].gt {
	pc = 0x82863674; continue 'dispatch;
	}
	pc = 0x82863624; continue 'dispatch;
            }
            0x82863624 => {
    //   block [0x82863624..0x82863644)
	// 82863624: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82863628: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286362C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82863630: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863634: 2F07009E  cmpwi cr6, r7, 0x9e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 158, &mut ctx.xer);
	// 82863638: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286363C: 41980008  blt cr6, 0x82863644
	if ctx.cr[6].lt {
	pc = 0x82863644; continue 'dispatch;
	}
	// 82863640: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82863644; continue 'dispatch;
            }
            0x82863644 => {
    //   block [0x82863644..0x82863660)
	// 82863644: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82863648: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286364C: 419A0014  beq cr6, 0x82863660
	if ctx.cr[6].eq {
	pc = 0x82863660; continue 'dispatch;
	}
	// 82863650: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82863654: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82863658: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286365C: 4800000C  b 0x82863668
	pc = 0x82863668; continue 'dispatch;
            }
            0x82863660 => {
    //   block [0x82863660..0x82863668)
	// 82863660: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82863664: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82863668; continue 'dispatch;
            }
            0x82863668 => {
    //   block [0x82863668..0x82863674)
	// 82863668: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286366C: 4199FFB8  bgt cr6, 0x82863624
	if ctx.cr[6].gt {
	pc = 0x82863624; continue 'dispatch;
	}
	// 82863670: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82863674; continue 'dispatch;
            }
            0x82863674 => {
    //   block [0x82863674..0x82863690)
	// 82863674: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82863678: 419A0040  beq cr6, 0x828636b8
	if ctx.cr[6].eq {
	pc = 0x828636B8; continue 'dispatch;
	}
	// 8286367C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863680: 2F0B009E  cmpwi cr6, r11, 0x9e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 158, &mut ctx.xer);
	// 82863684: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863688: 41990008  bgt cr6, 0x82863690
	if ctx.cr[6].gt {
	pc = 0x82863690; continue 'dispatch;
	}
	// 8286368C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82863690; continue 'dispatch;
            }
            0x82863690 => {
    //   block [0x82863690..0x828636B8)
	// 82863690: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82863694: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863698: 409A0020  bne cr6, 0x828636b8
	if !ctx.cr[6].eq {
	pc = 0x828636B8; continue 'dispatch;
	}
	// 8286369C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828636A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828636A4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828636A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828636AC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828636B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828636B4: 4800001C  b 0x828636d0
	pc = 0x828636D0; continue 'dispatch;
            }
            0x828636B8 => {
    //   block [0x828636B8..0x828636CC)
	// 828636B8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828636BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828636C0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828636C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828636C8: 48000008  b 0x828636d0
	pc = 0x828636D0; continue 'dispatch;
            }
            0x828636CC => {
    //   block [0x828636CC..0x828636D0)
	// 828636CC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828636D0; continue 'dispatch;
            }
            0x828636D0 => {
    //   block [0x828636D0..0x828636E8)
	// 828636D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828636D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828636D8: 419A0010  beq cr6, 0x828636e8
	if ctx.cr[6].eq {
	pc = 0x828636E8; continue 'dispatch;
	}
	// 828636DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828636E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828636E4: 4BD6D7ED  bl 0x825d0ed0
	ctx.lr = 0x828636E8;
	sub_825D0ED0(ctx, base);
	pc = 0x828636E8; continue 'dispatch;
            }
            0x828636E8 => {
    //   block [0x828636E8..0x8286372C)
	// 828636E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828636EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828636F0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828636F4: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828636F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828636FC: 419A00F4  beq cr6, 0x828637f0
	if ctx.cr[6].eq {
	pc = 0x828637F0; continue 'dispatch;
	}
	// 82863700: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82863704: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82863708: 419A0024  beq cr6, 0x8286372c
	if ctx.cr[6].eq {
	pc = 0x8286372C; continue 'dispatch;
	}
	// 8286370C: 892A001F  lbz r9, 0x1f(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(31 as u32) ) } as u64;
	// 82863710: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82863714: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82863718: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8286371C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863720: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863724: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863728: 480000CC  b 0x828637f4
	pc = 0x828637F4; continue 'dispatch;
            }
            0x8286372C => {
    //   block [0x8286372C..0x82863748)
	// 8286372C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82863730: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82863734: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82863738: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8286373C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82863740: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863744: 40810054  ble 0x82863798
	if !ctx.cr[0].gt {
	pc = 0x82863798; continue 'dispatch;
	}
	pc = 0x82863748; continue 'dispatch;
            }
            0x82863748 => {
    //   block [0x82863748..0x82863768)
	// 82863748: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286374C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82863750: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82863754: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863758: 2F07001F  cmpwi cr6, r7, 0x1f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 31, &mut ctx.xer);
	// 8286375C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82863760: 41980008  blt cr6, 0x82863768
	if ctx.cr[6].lt {
	pc = 0x82863768; continue 'dispatch;
	}
	// 82863764: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82863768; continue 'dispatch;
            }
            0x82863768 => {
    //   block [0x82863768..0x82863784)
	// 82863768: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286376C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82863770: 419A0014  beq cr6, 0x82863784
	if ctx.cr[6].eq {
	pc = 0x82863784; continue 'dispatch;
	}
	// 82863774: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82863778: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286377C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82863780: 4800000C  b 0x8286378c
	pc = 0x8286378C; continue 'dispatch;
            }
            0x82863784 => {
    //   block [0x82863784..0x8286378C)
	// 82863784: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82863788: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286378C; continue 'dispatch;
            }
            0x8286378C => {
    //   block [0x8286378C..0x82863798)
	// 8286378C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863790: 4199FFB8  bgt cr6, 0x82863748
	if ctx.cr[6].gt {
	pc = 0x82863748; continue 'dispatch;
	}
	// 82863794: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82863798; continue 'dispatch;
            }
            0x82863798 => {
    //   block [0x82863798..0x828637B4)
	// 82863798: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8286379C: 419A0040  beq cr6, 0x828637dc
	if ctx.cr[6].eq {
	pc = 0x828637DC; continue 'dispatch;
	}
	// 828637A0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828637A4: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 828637A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828637AC: 41990008  bgt cr6, 0x828637b4
	if ctx.cr[6].gt {
	pc = 0x828637B4; continue 'dispatch;
	}
	// 828637B0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828637B4; continue 'dispatch;
            }
            0x828637B4 => {
    //   block [0x828637B4..0x828637DC)
	// 828637B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828637B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828637BC: 409A0020  bne cr6, 0x828637dc
	if !ctx.cr[6].eq {
	pc = 0x828637DC; continue 'dispatch;
	}
	// 828637C0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828637C4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828637C8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828637CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828637D0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828637D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828637D8: 4800001C  b 0x828637f4
	pc = 0x828637F4; continue 'dispatch;
            }
            0x828637DC => {
    //   block [0x828637DC..0x828637F0)
	// 828637DC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828637E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828637E4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828637E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828637EC: 48000008  b 0x828637f4
	pc = 0x828637F4; continue 'dispatch;
            }
            0x828637F0 => {
    //   block [0x828637F0..0x828637F4)
	// 828637F0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828637F4; continue 'dispatch;
            }
            0x828637F4 => {
    //   block [0x828637F4..0x82863810)
	// 828637F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828637F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828637FC: 419A0014  beq cr6, 0x82863810
	if ctx.cr[6].eq {
	pc = 0x82863810; continue 'dispatch;
	}
	// 82863800: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82863804: 409A000C  bne cr6, 0x82863810
	if !ctx.cr[6].eq {
	pc = 0x82863810; continue 'dispatch;
	}
	// 82863808: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8286380C: 4BD61885  bl 0x825c5090
	ctx.lr = 0x82863810;
	sub_825C5090(ctx, base);
	pc = 0x82863810; continue 'dispatch;
            }
            0x82863810 => {
    //   block [0x82863810..0x82863818)
	// 82863810: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82863814: 48445C48  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863818 size=316
    let mut pc: u32 = 0x82863818;
    'dispatch: loop {
        match pc {
            0x82863818 => {
    //   block [0x82863818..0x82863868)
	// 82863818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286381C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863820: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863824: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863828: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8286382C: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82863830: 554917FE  rlwinm r9, r10, 2, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 82863834: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82863838: 419A00F4  beq cr6, 0x8286392c
	if ctx.cr[6].eq {
	pc = 0x8286392C; continue 'dispatch;
	}
	// 8286383C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82863840: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82863844: 419A0024  beq cr6, 0x82863868
	if ctx.cr[6].eq {
	pc = 0x82863868; continue 'dispatch;
	}
	// 82863848: 894A009E  lbz r10, 0x9e(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(158 as u32) ) } as u64;
	// 8286384C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82863850: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82863854: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82863858: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286385C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863860: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863864: 480000CC  b 0x82863930
	pc = 0x82863930; continue 'dispatch;
            }
            0x82863868 => {
    //   block [0x82863868..0x82863884)
	// 82863868: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286386C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82863870: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82863874: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82863878: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286387C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863880: 40810054  ble 0x828638d4
	if !ctx.cr[0].gt {
	pc = 0x828638D4; continue 'dispatch;
	}
	pc = 0x82863884; continue 'dispatch;
            }
            0x82863884 => {
    //   block [0x82863884..0x828638A4)
	// 82863884: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82863888: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286388C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82863890: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863894: 2F07009E  cmpwi cr6, r7, 0x9e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 158, &mut ctx.xer);
	// 82863898: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286389C: 41980008  blt cr6, 0x828638a4
	if ctx.cr[6].lt {
	pc = 0x828638A4; continue 'dispatch;
	}
	// 828638A0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x828638A4; continue 'dispatch;
            }
            0x828638A4 => {
    //   block [0x828638A4..0x828638C0)
	// 828638A4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828638A8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828638AC: 419A0014  beq cr6, 0x828638c0
	if ctx.cr[6].eq {
	pc = 0x828638C0; continue 'dispatch;
	}
	// 828638B0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828638B4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828638B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828638BC: 4800000C  b 0x828638c8
	pc = 0x828638C8; continue 'dispatch;
            }
            0x828638C0 => {
    //   block [0x828638C0..0x828638C8)
	// 828638C0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828638C4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828638C8; continue 'dispatch;
            }
            0x828638C8 => {
    //   block [0x828638C8..0x828638D4)
	// 828638C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828638CC: 4199FFB8  bgt cr6, 0x82863884
	if ctx.cr[6].gt {
	pc = 0x82863884; continue 'dispatch;
	}
	// 828638D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828638D4; continue 'dispatch;
            }
            0x828638D4 => {
    //   block [0x828638D4..0x828638F0)
	// 828638D4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828638D8: 419A0040  beq cr6, 0x82863918
	if ctx.cr[6].eq {
	pc = 0x82863918; continue 'dispatch;
	}
	// 828638DC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828638E0: 2F0B009E  cmpwi cr6, r11, 0x9e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 158, &mut ctx.xer);
	// 828638E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828638E8: 41990008  bgt cr6, 0x828638f0
	if ctx.cr[6].gt {
	pc = 0x828638F0; continue 'dispatch;
	}
	// 828638EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x828638F0; continue 'dispatch;
            }
            0x828638F0 => {
    //   block [0x828638F0..0x82863918)
	// 828638F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828638F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828638F8: 409A0020  bne cr6, 0x82863918
	if !ctx.cr[6].eq {
	pc = 0x82863918; continue 'dispatch;
	}
	// 828638FC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82863900: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82863904: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82863908: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286390C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863910: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863914: 4800001C  b 0x82863930
	pc = 0x82863930; continue 'dispatch;
            }
            0x82863918 => {
    //   block [0x82863918..0x8286392C)
	// 82863918: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286391C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863920: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863924: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863928: 48000008  b 0x82863930
	pc = 0x82863930; continue 'dispatch;
            }
            0x8286392C => {
    //   block [0x8286392C..0x82863930)
	// 8286392C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82863930; continue 'dispatch;
            }
            0x82863930 => {
    //   block [0x82863930..0x82863944)
	// 82863930: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82863934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863938: 419A000C  beq cr6, 0x82863944
	if ctx.cr[6].eq {
	pc = 0x82863944; continue 'dispatch;
	}
	// 8286393C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82863940: 4BD6D591  bl 0x825d0ed0
	ctx.lr = 0x82863944;
	sub_825D0ED0(ctx, base);
	pc = 0x82863944; continue 'dispatch;
            }
            0x82863944 => {
    //   block [0x82863944..0x82863954)
	// 82863944: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82863948: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286394C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863950: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863958 size=316
    let mut pc: u32 = 0x82863958;
    'dispatch: loop {
        match pc {
            0x82863958 => {
    //   block [0x82863958..0x828639A8)
	// 82863958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286395C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863960: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863964: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863968: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8286396C: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82863970: 554917FE  rlwinm r9, r10, 2, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 82863974: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82863978: 419A00F4  beq cr6, 0x82863a6c
	if ctx.cr[6].eq {
	pc = 0x82863A6C; continue 'dispatch;
	}
	// 8286397C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82863980: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82863984: 419A0024  beq cr6, 0x828639a8
	if ctx.cr[6].eq {
	pc = 0x828639A8; continue 'dispatch;
	}
	// 82863988: 894A009E  lbz r10, 0x9e(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(158 as u32) ) } as u64;
	// 8286398C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82863990: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82863994: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82863998: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286399C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828639A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828639A4: 480000CC  b 0x82863a70
	pc = 0x82863A70; continue 'dispatch;
            }
            0x828639A8 => {
    //   block [0x828639A8..0x828639C4)
	// 828639A8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828639AC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828639B0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828639B4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828639B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828639BC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828639C0: 40810054  ble 0x82863a14
	if !ctx.cr[0].gt {
	pc = 0x82863A14; continue 'dispatch;
	}
	pc = 0x828639C4; continue 'dispatch;
            }
            0x828639C4 => {
    //   block [0x828639C4..0x828639E4)
	// 828639C4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828639C8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828639CC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828639D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828639D4: 2F07009E  cmpwi cr6, r7, 0x9e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 158, &mut ctx.xer);
	// 828639D8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828639DC: 41980008  blt cr6, 0x828639e4
	if ctx.cr[6].lt {
	pc = 0x828639E4; continue 'dispatch;
	}
	// 828639E0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x828639E4; continue 'dispatch;
            }
            0x828639E4 => {
    //   block [0x828639E4..0x82863A00)
	// 828639E4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828639E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828639EC: 419A0014  beq cr6, 0x82863a00
	if ctx.cr[6].eq {
	pc = 0x82863A00; continue 'dispatch;
	}
	// 828639F0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828639F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828639F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828639FC: 4800000C  b 0x82863a08
	pc = 0x82863A08; continue 'dispatch;
            }
            0x82863A00 => {
    //   block [0x82863A00..0x82863A08)
	// 82863A00: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82863A04: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82863A08; continue 'dispatch;
            }
            0x82863A08 => {
    //   block [0x82863A08..0x82863A14)
	// 82863A08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863A0C: 4199FFB8  bgt cr6, 0x828639c4
	if ctx.cr[6].gt {
	pc = 0x828639C4; continue 'dispatch;
	}
	// 82863A10: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82863A14; continue 'dispatch;
            }
            0x82863A14 => {
    //   block [0x82863A14..0x82863A30)
	// 82863A14: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82863A18: 419A0040  beq cr6, 0x82863a58
	if ctx.cr[6].eq {
	pc = 0x82863A58; continue 'dispatch;
	}
	// 82863A1C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863A20: 2F0B009E  cmpwi cr6, r11, 0x9e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 158, &mut ctx.xer);
	// 82863A24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863A28: 41990008  bgt cr6, 0x82863a30
	if ctx.cr[6].gt {
	pc = 0x82863A30; continue 'dispatch;
	}
	// 82863A2C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82863A30; continue 'dispatch;
            }
            0x82863A30 => {
    //   block [0x82863A30..0x82863A58)
	// 82863A30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82863A34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863A38: 409A0020  bne cr6, 0x82863a58
	if !ctx.cr[6].eq {
	pc = 0x82863A58; continue 'dispatch;
	}
	// 82863A3C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82863A40: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82863A44: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82863A48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863A4C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863A50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863A54: 4800001C  b 0x82863a70
	pc = 0x82863A70; continue 'dispatch;
            }
            0x82863A58 => {
    //   block [0x82863A58..0x82863A6C)
	// 82863A58: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82863A5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863A60: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863A64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863A68: 48000008  b 0x82863a70
	pc = 0x82863A70; continue 'dispatch;
            }
            0x82863A6C => {
    //   block [0x82863A6C..0x82863A70)
	// 82863A6C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82863A70; continue 'dispatch;
            }
            0x82863A70 => {
    //   block [0x82863A70..0x82863A84)
	// 82863A70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82863A74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863A78: 419A000C  beq cr6, 0x82863a84
	if ctx.cr[6].eq {
	pc = 0x82863A84; continue 'dispatch;
	}
	// 82863A7C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82863A80: 4BD6D451  bl 0x825d0ed0
	ctx.lr = 0x82863A84;
	sub_825D0ED0(ctx, base);
	pc = 0x82863A84; continue 'dispatch;
            }
            0x82863A84 => {
    //   block [0x82863A84..0x82863A94)
	// 82863A84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82863A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863A90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863A98 size=128
    let mut pc: u32 = 0x82863A98;
    'dispatch: loop {
        match pc {
            0x82863A98 => {
    //   block [0x82863A98..0x82863AF8)
	// 82863A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863AA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82863AA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863AA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863AAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82863AB0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82863AB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82863AB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82863ABC: 38ABC3B0  addi r5, r11, -0x3c50
	ctx.r[5].s64 = ctx.r[11].s64 + -15440;
	// 82863AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863AC4: 4B9C4505  bl 0x82227fc8
	ctx.lr = 0x82863AC8;
	sub_82227FC8(ctx, base);
	// 82863AC8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82863ACC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82863AD0: 409A0028  bne cr6, 0x82863af8
	if !ctx.cr[6].eq {
	pc = 0x82863AF8; continue 'dispatch;
	}
	// 82863AD4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82863AD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82863ADC: 38ABC3B4  addi r5, r11, -0x3c4c
	ctx.r[5].s64 = ctx.r[11].s64 + -15436;
	// 82863AE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863AE4: 4B9C44E5  bl 0x82227fc8
	ctx.lr = 0x82863AE8;
	sub_82227FC8(ctx, base);
	// 82863AE8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82863AEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82863AF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82863AF4: 419A0008  beq cr6, 0x82863afc
	if ctx.cr[6].eq {
	pc = 0x82863AFC; continue 'dispatch;
	}
	pc = 0x82863AF8; continue 'dispatch;
            }
            0x82863AF8 => {
    //   block [0x82863AF8..0x82863AFC)
	// 82863AF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82863AFC; continue 'dispatch;
            }
            0x82863AFC => {
    //   block [0x82863AFC..0x82863B18)
	// 82863AFC: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82863B00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863B04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863B08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863B0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82863B10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863B14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863B18 size=436
    let mut pc: u32 = 0x82863B18;
    'dispatch: loop {
        match pc {
            0x82863B18 => {
    //   block [0x82863B18..0x82863B8C)
	// 82863B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863B20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82863B24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863B28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863B2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82863B30: 389E0044  addi r4, r30, 0x44
	ctx.r[4].s64 = ctx.r[30].s64 + 68;
	// 82863B34: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 82863B38: 4B936C21  bl 0x8219a758
	ctx.lr = 0x82863B3C;
	sub_8219A758(ctx, base);
	// 82863B3C: 809E0054  lwz r4, 0x54(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82863B40: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82863B44: 419A0170  beq cr6, 0x82863cb4
	if ctx.cr[6].eq {
	pc = 0x82863CB4; continue 'dispatch;
	}
	// 82863B48: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82863B4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82863B50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863B54: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82863B58: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82863B5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82863B60: 419A00E8  beq cr6, 0x82863c48
	if ctx.cr[6].eq {
	pc = 0x82863C48; continue 'dispatch;
	}
	// 82863B64: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82863B68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82863B6C: 419A0020  beq cr6, 0x82863b8c
	if ctx.cr[6].eq {
	pc = 0x82863B8C; continue 'dispatch;
	}
	// 82863B70: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 82863B74: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82863B78: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82863B7C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82863B80: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82863B84: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863B88: 480000C8  b 0x82863c50
	pc = 0x82863C50; continue 'dispatch;
            }
            0x82863B8C => {
    //   block [0x82863B8C..0x82863BA8)
	// 82863B8C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82863B90: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82863B94: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82863B98: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82863B9C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82863BA0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863BA4: 40810054  ble 0x82863bf8
	if !ctx.cr[0].gt {
	pc = 0x82863BF8; continue 'dispatch;
	}
	pc = 0x82863BA8; continue 'dispatch;
            }
            0x82863BA8 => {
    //   block [0x82863BA8..0x82863BC8)
	// 82863BA8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82863BAC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82863BB0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82863BB4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863BB8: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82863BBC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82863BC0: 41980008  blt cr6, 0x82863bc8
	if ctx.cr[6].lt {
	pc = 0x82863BC8; continue 'dispatch;
	}
	// 82863BC4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82863BC8; continue 'dispatch;
            }
            0x82863BC8 => {
    //   block [0x82863BC8..0x82863BE4)
	// 82863BC8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82863BCC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82863BD0: 419A0014  beq cr6, 0x82863be4
	if ctx.cr[6].eq {
	pc = 0x82863BE4; continue 'dispatch;
	}
	// 82863BD4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82863BD8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82863BDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82863BE0: 4800000C  b 0x82863bec
	pc = 0x82863BEC; continue 'dispatch;
            }
            0x82863BE4 => {
    //   block [0x82863BE4..0x82863BEC)
	// 82863BE4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82863BE8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82863BEC; continue 'dispatch;
            }
            0x82863BEC => {
    //   block [0x82863BEC..0x82863BF8)
	// 82863BEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863BF0: 4199FFB8  bgt cr6, 0x82863ba8
	if ctx.cr[6].gt {
	pc = 0x82863BA8; continue 'dispatch;
	}
	// 82863BF4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82863BF8; continue 'dispatch;
            }
            0x82863BF8 => {
    //   block [0x82863BF8..0x82863C14)
	// 82863BF8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82863BFC: 419A003C  beq cr6, 0x82863c38
	if ctx.cr[6].eq {
	pc = 0x82863C38; continue 'dispatch;
	}
	// 82863C00: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863C04: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82863C08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863C0C: 41990008  bgt cr6, 0x82863c14
	if ctx.cr[6].gt {
	pc = 0x82863C14; continue 'dispatch;
	}
	// 82863C10: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82863C14; continue 'dispatch;
            }
            0x82863C14 => {
    //   block [0x82863C14..0x82863C38)
	// 82863C14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82863C18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863C1C: 409A001C  bne cr6, 0x82863c38
	if !ctx.cr[6].eq {
	pc = 0x82863C38; continue 'dispatch;
	}
	// 82863C20: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82863C24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82863C28: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82863C2C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82863C30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863C34: 4800001C  b 0x82863c50
	pc = 0x82863C50; continue 'dispatch;
            }
            0x82863C38 => {
    //   block [0x82863C38..0x82863C48)
	// 82863C38: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82863C3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82863C40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863C44: 4800000C  b 0x82863c50
	pc = 0x82863C50; continue 'dispatch;
            }
            0x82863C48 => {
    //   block [0x82863C48..0x82863C50)
	// 82863C48: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82863C4C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x82863C50; continue 'dispatch;
            }
            0x82863C50 => {
    //   block [0x82863C50..0x82863C78)
	// 82863C50: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82863C54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82863C58: 419A005C  beq cr6, 0x82863cb4
	if ctx.cr[6].eq {
	pc = 0x82863CB4; continue 'dispatch;
	}
	// 82863C5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82863C60: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863C64: 4BA4A3BD  bl 0x822ae020
	ctx.lr = 0x82863C68;
	sub_822AE020(ctx, base);
	// 82863C68: 807E0054  lwz r3, 0x54(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82863C6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82863C70: 419A0040  beq cr6, 0x82863cb0
	if ctx.cr[6].eq {
	pc = 0x82863CB0; continue 'dispatch;
	}
	// 82863C74: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82863C78; continue 'dispatch;
            }
            0x82863C78 => {
    //   block [0x82863C78..0x82863CAC)
	// 82863C78: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82863C7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863C80: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82863C84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82863C88: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82863C8C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863C90: 4082FFE8  bne 0x82863c78
	if !ctx.cr[0].eq {
	pc = 0x82863C78; continue 'dispatch;
	}
	// 82863C94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863C98: 409A0014  bne cr6, 0x82863cac
	if !ctx.cr[6].eq {
	pc = 0x82863CAC; continue 'dispatch;
	}
	// 82863C9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863CA0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863CA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82863CA8: 4E800421  bctrl
	ctx.lr = 0x82863CAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82863CAC => {
    //   block [0x82863CAC..0x82863CB0)
	// 82863CAC: 93FE0054  stw r31, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	pc = 0x82863CB0; continue 'dispatch;
            }
            0x82863CB0 => {
    //   block [0x82863CB0..0x82863CB4)
	// 82863CB0: 93FE0054  stw r31, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	pc = 0x82863CB4; continue 'dispatch;
            }
            0x82863CB4 => {
    //   block [0x82863CB4..0x82863CCC)
	// 82863CB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863CB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863CBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863CC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82863CC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863CC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863CD0 size=312
    let mut pc: u32 = 0x82863CD0;
    'dispatch: loop {
        match pc {
            0x82863CD0 => {
    //   block [0x82863CD0..0x82863D04)
	// 82863CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863CD4: 48445735  bl 0x82ca9408
	ctx.lr = 0x82863CD8;
	sub_82CA93D0(ctx, base);
	// 82863CD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863CDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863CE0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82863CE4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82863CE8: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 82863CEC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82863CF0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82863CF4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82863CF8: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82863CFC: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82863D00: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x82863D04; continue 'dispatch;
            }
            0x82863D04 => {
    //   block [0x82863D04..0x82863D30)
	// 82863D04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82863D08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863D0C: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82863D10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82863D14: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82863D18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863D1C: 4082FFE8  bne 0x82863d04
	if !ctx.cr[0].eq {
	pc = 0x82863D04; continue 'dispatch;
	}
	// 82863D20: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82863D24: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 82863D28: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82863D2C: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	pc = 0x82863D30; continue 'dispatch;
            }
            0x82863D30 => {
    //   block [0x82863D30..0x82863D5C)
	// 82863D30: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 82863D34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863D38: 7CC01828  lwarx r6, 0, r3
	// lwarx
	let ea = ctx.r[3].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[6].u64 = ctx.reserved.u32 as u64;
	// 82863D3C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82863D40: 7CC0192D  stwcx. r6, 0, r3
	// stwcx.
	let addr = ctx.r[3].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[6].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82863D44: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863D48: 4082FFE8  bne 0x82863d30
	if !ctx.cr[0].eq {
	pc = 0x82863D30; continue 'dispatch;
	}
	// 82863D4C: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82863D50: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82863D54: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82863D58: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	pc = 0x82863D5C; continue 'dispatch;
            }
            0x82863D5C => {
    //   block [0x82863D5C..0x82863D88)
	// 82863D5C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82863D60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863D64: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82863D68: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82863D6C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82863D70: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863D74: 4082FFE8  bne 0x82863d5c
	if !ctx.cr[0].eq {
	pc = 0x82863D5C; continue 'dispatch;
	}
	// 82863D78: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82863D7C: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82863D80: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82863D84: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	pc = 0x82863D88; continue 'dispatch;
            }
            0x82863D88 => {
    //   block [0x82863D88..0x82863DB0)
	// 82863D88: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 82863D8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863D90: 7CE02028  lwarx r7, 0, r4
	// lwarx
	let ea = ctx.r[4].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 82863D94: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82863D98: 7CE0212D  stwcx. r7, 0, r4
	// stwcx.
	let addr = ctx.r[4].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82863D9C: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863DA0: 4082FFE8  bne 0x82863d88
	if !ctx.cr[0].eq {
	pc = 0x82863D88; continue 'dispatch;
	}
	// 82863DA4: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82863DA8: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82863DAC: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	pc = 0x82863DB0; continue 'dispatch;
            }
            0x82863DB0 => {
    //   block [0x82863DB0..0x82863E08)
	// 82863DB0: 7D6000A6  mfmsr r11
	ctx.r[11].u64 = ctx.msr;
	// 82863DB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863DB8: 7C604028  lwarx r3, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[3].u64 = ctx.reserved.u32 as u64;
	// 82863DBC: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82863DC0: 7C60412D  stwcx. r3, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[3].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82863DC4: 7D610164  mtmsrd r11, 1
	ctx.msr = (ctx.r[11].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863DC8: 4082FFE8  bne 0x82863db0
	if !ctx.cr[0].eq {
	pc = 0x82863DB0; continue 'dispatch;
	}
	// 82863DCC: 939F003C  stw r28, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[28].u32 ) };
	// 82863DD0: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 82863DD4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82863DD8: 4B98C469  bl 0x821f0240
	ctx.lr = 0x82863DDC;
	sub_821F0240(ctx, base);
	// 82863DDC: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82863DE0: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82863DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863DE8: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 82863DEC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82863DF0: 93BF0050  stw r29, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82863DF4: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82863DF8: 48000011  bl 0x82863e08
	ctx.lr = 0x82863DFC;
	sub_82863E08(ctx, base);
	// 82863DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863E00: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82863E04: 48445654  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863E08 size=520
    let mut pc: u32 = 0x82863E08;
    'dispatch: loop {
        match pc {
            0x82863E08 => {
    //   block [0x82863E08..0x82863E38)
	// 82863E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863E0C: 484455FD  bl 0x82ca9408
	ctx.lr = 0x82863E10;
	sub_82CA93D0(ctx, base);
	// 82863E10: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863E14: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82863E18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82863E1C: 4BB6A7A5  bl 0x823ce5c0
	ctx.lr = 0x82863E20;
	sub_823CE5C0(ctx, base);
	// 82863E20: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 82863E24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863E28: 409A0010  bne cr6, 0x82863e38
	if !ctx.cr[6].eq {
	pc = 0x82863E38; continue 'dispatch;
	}
	// 82863E2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82863E30: 38ABFFDF  addi r5, r11, -0x21
	ctx.r[5].s64 = ctx.r[11].s64 + -33;
	// 82863E34: 48000008  b 0x82863e3c
	pc = 0x82863E3C; continue 'dispatch;
            }
            0x82863E38 => {
    //   block [0x82863E38..0x82863E3C)
	// 82863E38: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82863E3C; continue 'dispatch;
            }
            0x82863E3C => {
    //   block [0x82863E3C..0x82863EAC)
	// 82863E3C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82863E40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82863E44: 4BB6A2CD  bl 0x823ce110
	ctx.lr = 0x82863E48;
	sub_823CE110(ctx, base);
	// 82863E48: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82863E4C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82863E50: 38CBF8CC  addi r6, r11, -0x734
	ctx.r[6].s64 = ctx.r[11].s64 + -1844;
	// 82863E54: 38AAF19C  addi r5, r10, -0xe64
	ctx.r[5].s64 = ctx.r[10].s64 + -3684;
	// 82863E58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82863E5C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82863E60: 4BB49679  bl 0x823ad4d8
	ctx.lr = 0x82863E64;
	sub_823AD4D8(ctx, base);
	// 82863E64: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82863E68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82863E6C: 4BBF45B5  bl 0x82458420
	ctx.lr = 0x82863E70;
	sub_82458420(ctx, base);
	// 82863E70: 813C0048  lwz r9, 0x48(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82863E74: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863E78: 3BFC0044  addi r31, r28, 0x44
	ctx.r[31].s64 = ctx.r[28].s64 + 68;
	// 82863E7C: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863E80: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82863E84: 419A0028  beq cr6, 0x82863eac
	if ctx.cr[6].eq {
	pc = 0x82863EAC; continue 'dispatch;
	}
	// 82863E88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863E8C: 4B953C8D  bl 0x821b7b18
	ctx.lr = 0x82863E90;
	sub_821B7B18(ctx, base);
	// 82863E90: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82863E94: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82863E98: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82863E9C: 419A0010  beq cr6, 0x82863eac
	if ctx.cr[6].eq {
	pc = 0x82863EAC; continue 'dispatch;
	}
	// 82863EA0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863EA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82863EA8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82863EAC; continue 'dispatch;
            }
            0x82863EAC => {
    //   block [0x82863EAC..0x82863EC8)
	// 82863EAC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82863EB0: 4B953C69  bl 0x821b7b18
	ctx.lr = 0x82863EB4;
	sub_821B7B18(ctx, base);
	// 82863EB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863EB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863EBC: 419A000C  beq cr6, 0x82863ec8
	if ctx.cr[6].eq {
	pc = 0x82863EC8; continue 'dispatch;
	}
	// 82863EC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82863EC4: 994B000C  stb r10, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	pc = 0x82863EC8; continue 'dispatch;
            }
            0x82863EC8 => {
    //   block [0x82863EC8..0x82864010)
	// 82863EC8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82863ECC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82863ED0: 38CBF8E0  addi r6, r11, -0x720
	ctx.r[6].s64 = ctx.r[11].s64 + -1824;
	// 82863ED4: 38AAF8F8  addi r5, r10, -0x708
	ctx.r[5].s64 = ctx.r[10].s64 + -1800;
	// 82863ED8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82863EDC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82863EE0: 4BC009B1  bl 0x82464890
	ctx.lr = 0x82863EE4;
	sub_82464890(ctx, base);
	// 82863EE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82863EE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82863EEC: 4BBF9B45  bl 0x8245da30
	ctx.lr = 0x82863EF0;
	sub_8245DA30(ctx, base);
	// 82863EF0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82863EF4: 4B9B0EE5  bl 0x82214dd8
	ctx.lr = 0x82863EF8;
	sub_82214DD8(ctx, base);
	// 82863EF8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82863EFC: 4B953C1D  bl 0x821b7b18
	ctx.lr = 0x82863F00;
	sub_821B7B18(ctx, base);
	// 82863F00: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 82863F04: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 82863F08: 38C9F904  addi r6, r9, -0x6fc
	ctx.r[6].s64 = ctx.r[9].s64 + -1788;
	// 82863F0C: 38A8F924  addi r5, r8, -0x6dc
	ctx.r[5].s64 = ctx.r[8].s64 + -1756;
	// 82863F10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82863F14: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82863F18: 4BC00979  bl 0x82464890
	ctx.lr = 0x82863F1C;
	sub_82464890(ctx, base);
	// 82863F1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82863F20: 387C000C  addi r3, r28, 0xc
	ctx.r[3].s64 = ctx.r[28].s64 + 12;
	// 82863F24: 4BBF9B0D  bl 0x8245da30
	ctx.lr = 0x82863F28;
	sub_8245DA30(ctx, base);
	// 82863F28: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82863F2C: 4B9B0EAD  bl 0x82214dd8
	ctx.lr = 0x82863F30;
	sub_82214DD8(ctx, base);
	// 82863F30: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82863F34: 4B953BE5  bl 0x821b7b18
	ctx.lr = 0x82863F38;
	sub_821B7B18(ctx, base);
	// 82863F38: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 82863F3C: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 82863F40: 38C7F938  addi r6, r7, -0x6c8
	ctx.r[6].s64 = ctx.r[7].s64 + -1736;
	// 82863F44: 38A5F950  addi r5, r5, -0x6b0
	ctx.r[5].s64 = ctx.r[5].s64 + -1712;
	// 82863F48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82863F4C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82863F50: 4BBFF451  bl 0x824633a0
	ctx.lr = 0x82863F54;
	sub_824633A0(ctx, base);
	// 82863F54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82863F58: 387C0018  addi r3, r28, 0x18
	ctx.r[3].s64 = ctx.r[28].s64 + 24;
	// 82863F5C: 4BBF9AD5  bl 0x8245da30
	ctx.lr = 0x82863F60;
	sub_8245DA30(ctx, base);
	// 82863F60: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82863F64: 4B9B0E75  bl 0x82214dd8
	ctx.lr = 0x82863F68;
	sub_82214DD8(ctx, base);
	// 82863F68: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82863F6C: 4B953BAD  bl 0x821b7b18
	ctx.lr = 0x82863F70;
	sub_821B7B18(ctx, base);
	// 82863F70: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 82863F74: 3C60820B  lis r3, -0x7df5
	ctx.r[3].s64 = -2113208320;
	// 82863F78: 38C4F95C  addi r6, r4, -0x6a4
	ctx.r[6].s64 = ctx.r[4].s64 + -1700;
	// 82863F7C: 38A37A3C  addi r5, r3, 0x7a3c
	ctx.r[5].s64 = ctx.r[3].s64 + 31292;
	// 82863F80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82863F84: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82863F88: 4BBFF419  bl 0x824633a0
	ctx.lr = 0x82863F8C;
	sub_824633A0(ctx, base);
	// 82863F8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82863F90: 387C0024  addi r3, r28, 0x24
	ctx.r[3].s64 = ctx.r[28].s64 + 36;
	// 82863F94: 4BBF9A9D  bl 0x8245da30
	ctx.lr = 0x82863F98;
	sub_8245DA30(ctx, base);
	// 82863F98: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82863F9C: 4B9B0E3D  bl 0x82214dd8
	ctx.lr = 0x82863FA0;
	sub_82214DD8(ctx, base);
	// 82863FA0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82863FA4: 4B953B75  bl 0x821b7b18
	ctx.lr = 0x82863FA8;
	sub_821B7B18(ctx, base);
	// 82863FA8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82863FAC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82863FB0: 38CBF970  addi r6, r11, -0x690
	ctx.r[6].s64 = ctx.r[11].s64 + -1680;
	// 82863FB4: 38AAF98C  addi r5, r10, -0x674
	ctx.r[5].s64 = ctx.r[10].s64 + -1652;
	// 82863FB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82863FBC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82863FC0: 4BBFF3E1  bl 0x824633a0
	ctx.lr = 0x82863FC4;
	sub_824633A0(ctx, base);
	// 82863FC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82863FC8: 387C0030  addi r3, r28, 0x30
	ctx.r[3].s64 = ctx.r[28].s64 + 48;
	// 82863FCC: 4BBF9A65  bl 0x8245da30
	ctx.lr = 0x82863FD0;
	sub_8245DA30(ctx, base);
	// 82863FD0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82863FD4: 4B9B0E05  bl 0x82214dd8
	ctx.lr = 0x82863FD8;
	sub_82214DD8(ctx, base);
	// 82863FD8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82863FDC: 4B953B3D  bl 0x821b7b18
	ctx.lr = 0x82863FE0;
	sub_821B7B18(ctx, base);
	// 82863FE0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82863FE4: 4800002D  bl 0x82864010
	ctx.lr = 0x82863FE8;
	sub_82864010(ctx, base);
	// 82863FE8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82863FEC: 4B9B0DED  bl 0x82214dd8
	ctx.lr = 0x82863FF0;
	sub_82214DD8(ctx, base);
	// 82863FF0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82863FF4: 4B953B25  bl 0x821b7b18
	ctx.lr = 0x82863FF8;
	sub_821B7B18(ctx, base);
	// 82863FF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82863FFC: 4B953B1D  bl 0x821b7b18
	ctx.lr = 0x82864000;
	sub_821B7B18(ctx, base);
	// 82864000: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82864004: 4B953B15  bl 0x821b7b18
	ctx.lr = 0x82864008;
	sub_821B7B18(ctx, base);
	// 82864008: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8286400C: 4844544C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864010 size=688
    let mut pc: u32 = 0x82864010;
    'dispatch: loop {
        match pc {
            0x82864010 => {
    //   block [0x82864010..0x828640AC)
	// 82864010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864014: 484453F5  bl 0x82ca9408
	ctx.lr = 0x82864018;
	sub_82CA93D0(ctx, base);
	// 82864018: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286401C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82864020: 3BFE0044  addi r31, r30, 0x44
	ctx.r[31].s64 = ctx.r[30].s64 + 68;
	// 82864024: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 82864028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286402C: 419A0080  beq cr6, 0x828640ac
	if ctx.cr[6].eq {
	pc = 0x828640AC; continue 'dispatch;
	}
	// 82864030: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864034: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82864038: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286403C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82864040: 4B9C50C9  bl 0x82229108
	ctx.lr = 0x82864044;
	sub_82229108(ctx, base);
	// 82864044: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82864048: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8286404C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82864050: 3BAB42F8  addi r29, r11, 0x42f8
	ctx.r[29].s64 = ctx.r[11].s64 + 17144;
	// 82864054: 4B9C382D  bl 0x82227880
	ctx.lr = 0x82864058;
	sub_82227880(ctx, base);
	// 82864058: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8286405C: 3D408222  lis r10, -0x7dde
	ctx.r[10].s64 = -2111700992;
	// 82864060: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82864064: 388A79A8  addi r4, r10, 0x79a8
	ctx.r[4].s64 = ctx.r[10].s64 + 31144;
	// 82864068: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286406C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82864070: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82864074: 4B936A0D  bl 0x8219aa80
	ctx.lr = 0x82864078;
	sub_8219AA80(ctx, base);
	// 82864078: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 8286407C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82864080: 3BA9F99C  addi r29, r9, -0x664
	ctx.r[29].s64 = ctx.r[9].s64 + -1636;
	// 82864084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864088: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8286408C: 4BB6A395  bl 0x823ce420
	ctx.lr = 0x82864090;
	sub_823CE420(ctx, base);
	// 82864090: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82864094: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82864098: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286409C: 481C062D  bl 0x82a246c8
	ctx.lr = 0x828640A0;
	sub_82A246C8(ctx, base);
	// 828640A0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828640A4: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828640A8: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x828640AC; continue 'dispatch;
            }
            0x828640AC => {
    //   block [0x828640AC..0x828641C0)
	// 828640AC: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 828640B0: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828640B4: 38CB42C0  addi r6, r11, 0x42c0
	ctx.r[6].s64 = ctx.r[11].s64 + 17088;
	// 828640B8: 388AF9A8  addi r4, r10, -0x658
	ctx.r[4].s64 = ctx.r[10].s64 + -1624;
	// 828640BC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828640C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828640C4: 4BAEFED5  bl 0x82353f98
	ctx.lr = 0x828640C8;
	sub_82353F98(ctx, base);
	// 828640C8: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 828640CC: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 828640D0: 38C94468  addi r6, r9, 0x4468
	ctx.r[6].s64 = ctx.r[9].s64 + 17512;
	// 828640D4: 38880C7C  addi r4, r8, 0xc7c
	ctx.r[4].s64 = ctx.r[8].s64 + 3196;
	// 828640D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828640DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828640E0: 480012E9  bl 0x828653c8
	ctx.lr = 0x828640E4;
	sub_828653C8(ctx, base);
	// 828640E4: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 828640E8: 3CE08286  lis r7, -0x7d7a
	ctx.r[7].s64 = -2105147392;
	// 828640EC: 3885F9B8  addi r4, r5, -0x648
	ctx.r[4].s64 = ctx.r[5].s64 + -1608;
	// 828640F0: 38C74468  addi r6, r7, 0x4468
	ctx.r[6].s64 = ctx.r[7].s64 + 17512;
	// 828640F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828640F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828640FC: 480012CD  bl 0x828653c8
	ctx.lr = 0x82864100;
	sub_828653C8(ctx, base);
	// 82864100: 3C808286  lis r4, -0x7d7a
	ctx.r[4].s64 = -2105147392;
	// 82864104: 3C60820B  lis r3, -0x7df5
	ctx.r[3].s64 = -2113208320;
	// 82864108: 38C44468  addi r6, r4, 0x4468
	ctx.r[6].s64 = ctx.r[4].s64 + 17512;
	// 8286410C: 3883AA98  addi r4, r3, -0x5568
	ctx.r[4].s64 = ctx.r[3].s64 + -21864;
	// 82864110: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82864114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864118: 480012B1  bl 0x828653c8
	ctx.lr = 0x8286411C;
	sub_828653C8(ctx, base);
	// 8286411C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82864120: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82864124: 38CB4478  addi r6, r11, 0x4478
	ctx.r[6].s64 = ctx.r[11].s64 + 17528;
	// 82864128: 388AF9C8  addi r4, r10, -0x638
	ctx.r[4].s64 = ctx.r[10].s64 + -1592;
	// 8286412C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82864130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864134: 4BAEFE65  bl 0x82353f98
	ctx.lr = 0x82864138;
	sub_82353F98(ctx, base);
	// 82864138: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286413C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864140: 419A0080  beq cr6, 0x828641c0
	if ctx.cr[6].eq {
	pc = 0x828641C0; continue 'dispatch;
	}
	// 82864144: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864148: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8286414C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864150: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82864154: 4B9C4FB5  bl 0x82229108
	ctx.lr = 0x82864158;
	sub_82229108(ctx, base);
	// 82864158: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8286415C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82864160: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82864164: 3BAB4488  addi r29, r11, 0x4488
	ctx.r[29].s64 = ctx.r[11].s64 + 17544;
	// 82864168: 4B9C3719  bl 0x82227880
	ctx.lr = 0x8286416C;
	sub_82227880(ctx, base);
	// 8286416C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82864170: 3D408255  lis r10, -0x7dab
	ctx.r[10].s64 = -2108358656;
	// 82864174: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82864178: 388AB670  addi r4, r10, -0x4990
	ctx.r[4].s64 = ctx.r[10].s64 + -18832;
	// 8286417C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82864180: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82864184: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82864188: 4B9368F9  bl 0x8219aa80
	ctx.lr = 0x8286418C;
	sub_8219AA80(ctx, base);
	// 8286418C: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 82864190: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82864194: 3BA9F9DC  addi r29, r9, -0x624
	ctx.r[29].s64 = ctx.r[9].s64 + -1572;
	// 82864198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286419C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828641A0: 4BB6A281  bl 0x823ce420
	ctx.lr = 0x828641A4;
	sub_823CE420(ctx, base);
	// 828641A4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828641A8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828641AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828641B0: 481C0519  bl 0x82a246c8
	ctx.lr = 0x828641B4;
	sub_82A246C8(ctx, base);
	// 828641B4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828641B8: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828641BC: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x828641C0; continue 'dispatch;
            }
            0x828641C0 => {
    //   block [0x828641C0..0x82864248)
	// 828641C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828641C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828641C8: 419A0080  beq cr6, 0x82864248
	if ctx.cr[6].eq {
	pc = 0x82864248; continue 'dispatch;
	}
	// 828641CC: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828641D0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828641D4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828641D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828641DC: 4B9C4F2D  bl 0x82229108
	ctx.lr = 0x828641E0;
	sub_82229108(ctx, base);
	// 828641E0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 828641E4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828641E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828641EC: 3BAB4308  addi r29, r11, 0x4308
	ctx.r[29].s64 = ctx.r[11].s64 + 17160;
	// 828641F0: 4B9C3691  bl 0x82227880
	ctx.lr = 0x828641F4;
	sub_82227880(ctx, base);
	// 828641F4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828641F8: 3D408245  lis r10, -0x7dbb
	ctx.r[10].s64 = -2109407232;
	// 828641FC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82864200: 388A1240  addi r4, r10, 0x1240
	ctx.r[4].s64 = ctx.r[10].s64 + 4672;
	// 82864204: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82864208: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8286420C: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82864210: 4B936871  bl 0x8219aa80
	ctx.lr = 0x82864214;
	sub_8219AA80(ctx, base);
	// 82864214: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 82864218: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8286421C: 3BA9F9F4  addi r29, r9, -0x60c
	ctx.r[29].s64 = ctx.r[9].s64 + -1548;
	// 82864220: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864224: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82864228: 4BB6A1F9  bl 0x823ce420
	ctx.lr = 0x8286422C;
	sub_823CE420(ctx, base);
	// 8286422C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82864230: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82864234: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82864238: 481C0491  bl 0x82a246c8
	ctx.lr = 0x8286423C;
	sub_82A246C8(ctx, base);
	// 8286423C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82864240: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82864244: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x82864248; continue 'dispatch;
            }
            0x82864248 => {
    //   block [0x82864248..0x828642C0)
	// 82864248: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8286424C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82864250: 38CB44A0  addi r6, r11, 0x44a0
	ctx.r[6].s64 = ctx.r[11].s64 + 17568;
	// 82864254: 388AFA04  addi r4, r10, -0x5fc
	ctx.r[4].s64 = ctx.r[10].s64 + -1532;
	// 82864258: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8286425C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864260: 4BC1C711  bl 0x82480970
	ctx.lr = 0x82864264;
	sub_82480970(ctx, base);
	// 82864264: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 82864268: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 8286426C: 38C947B8  addi r6, r9, 0x47b8
	ctx.r[6].s64 = ctx.r[9].s64 + 18360;
	// 82864270: 3888FA20  addi r4, r8, -0x5e0
	ctx.r[4].s64 = ctx.r[8].s64 + -1504;
	// 82864274: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82864278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286427C: 4BC1C6F5  bl 0x82480970
	ctx.lr = 0x82864280;
	sub_82480970(ctx, base);
	// 82864280: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 82864284: 3CE08286  lis r7, -0x7d7a
	ctx.r[7].s64 = -2105147392;
	// 82864288: 3885FA3C  addi r4, r5, -0x5c4
	ctx.r[4].s64 = ctx.r[5].s64 + -1476;
	// 8286428C: 38C74A70  addi r6, r7, 0x4a70
	ctx.r[6].s64 = ctx.r[7].s64 + 19056;
	// 82864290: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82864294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864298: 4BC1C6D9  bl 0x82480970
	ctx.lr = 0x8286429C;
	sub_82480970(ctx, base);
	// 8286429C: 3C808286  lis r4, -0x7d7a
	ctx.r[4].s64 = -2105147392;
	// 828642A0: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828642A4: 38C44F68  addi r6, r4, 0x4f68
	ctx.r[6].s64 = ctx.r[4].s64 + 20328;
	// 828642A8: 3883FA60  addi r4, r3, -0x5a0
	ctx.r[4].s64 = ctx.r[3].s64 + -1440;
	// 828642AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828642B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828642B4: 4BC1C6BD  bl 0x82480970
	ctx.lr = 0x828642B8;
	sub_82480970(ctx, base);
	// 828642B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828642BC: 4844519C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828642C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828642C0 size=56
    let mut pc: u32 = 0x828642C0;
    'dispatch: loop {
        match pc {
            0x828642C0 => {
    //   block [0x828642C0..0x828642F8)
	// 828642C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828642C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828642C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828642CC: 81630050  lwz r11, 0x50(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 828642D0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828642D4: 4B9A351D  bl 0x822077f0
	ctx.lr = 0x828642D8;
	sub_822077F0(ctx, base);
	// 828642D8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828642DC: C80A9660  lfd f0, -0x69a0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 828642E0: FC010024  fdiv f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 828642E4: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 828642E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828642EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828642F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828642F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828642F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828642F8 size=12
    let mut pc: u32 = 0x828642F8;
    'dispatch: loop {
        match pc {
            0x828642F8 => {
    //   block [0x828642F8..0x82864304)
	// 828642F8: 81630050  lwz r11, 0x50(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 828642FC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82864308 size=348
    let mut pc: u32 = 0x82864308;
    'dispatch: loop {
        match pc {
            0x82864308 => {
    //   block [0x82864308..0x8286432C)
	// 82864308: 81630050  lwz r11, 0x50(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286430C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864314: 419A0018  beq cr6, 0x8286432c
	if ctx.cr[6].eq {
	pc = 0x8286432C; continue 'dispatch;
	}
	// 82864318: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8286431C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82864320: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82864324: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82864328: 409A0008  bne cr6, 0x82864330
	if !ctx.cr[6].eq {
	pc = 0x82864330; continue 'dispatch;
	}
	pc = 0x8286432C; continue 'dispatch;
            }
            0x8286432C => {
    //   block [0x8286432C..0x82864330)
	// 8286432C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82864330; continue 'dispatch;
            }
            0x82864330 => {
    //   block [0x82864330..0x8286437C)
	// 82864330: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82864334: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82864338: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8286433C: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82864340: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82864344: 5528A7FE  rlwinm r8, r9, 0x14, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000FFFu64;
	// 82864348: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8286434C: 419A00F8  beq cr6, 0x82864444
	if ctx.cr[6].eq {
	pc = 0x82864444; continue 'dispatch;
	}
	// 82864350: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82864354: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82864358: 419A0024  beq cr6, 0x8286437c
	if ctx.cr[6].eq {
	pc = 0x8286437C; continue 'dispatch;
	}
	// 8286435C: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82864360: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82864364: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82864368: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286436C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864370: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82864374: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82864378: 480000D0  b 0x82864448
	pc = 0x82864448; continue 'dispatch;
            }
            0x8286437C => {
    //   block [0x8286437C..0x8286439C)
	// 8286437C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82864380: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82864384: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82864388: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 8286438C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82864390: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 82864394: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82864398: 40810054  ble 0x828643ec
	if !ctx.cr[0].gt {
	pc = 0x828643EC; continue 'dispatch;
	}
	pc = 0x8286439C; continue 'dispatch;
            }
            0x8286439C => {
    //   block [0x8286439C..0x828643BC)
	// 8286439C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828643A0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828643A4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828643A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828643AC: 2F07002C  cmpwi cr6, r7, 0x2c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 44, &mut ctx.xer);
	// 828643B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828643B4: 41980008  blt cr6, 0x828643bc
	if ctx.cr[6].lt {
	pc = 0x828643BC; continue 'dispatch;
	}
	// 828643B8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828643BC; continue 'dispatch;
            }
            0x828643BC => {
    //   block [0x828643BC..0x828643D8)
	// 828643BC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828643C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828643C4: 419A0014  beq cr6, 0x828643d8
	if ctx.cr[6].eq {
	pc = 0x828643D8; continue 'dispatch;
	}
	// 828643C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828643CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828643D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828643D4: 4800000C  b 0x828643e0
	pc = 0x828643E0; continue 'dispatch;
            }
            0x828643D8 => {
    //   block [0x828643D8..0x828643E0)
	// 828643D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828643DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828643E0; continue 'dispatch;
            }
            0x828643E0 => {
    //   block [0x828643E0..0x828643EC)
	// 828643E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828643E4: 4199FFB8  bgt cr6, 0x8286439c
	if ctx.cr[6].gt {
	pc = 0x8286439C; continue 'dispatch;
	}
	// 828643E8: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x828643EC; continue 'dispatch;
            }
            0x828643EC => {
    //   block [0x828643EC..0x82864408)
	// 828643EC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828643F0: 419A0040  beq cr6, 0x82864430
	if ctx.cr[6].eq {
	pc = 0x82864430; continue 'dispatch;
	}
	// 828643F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828643F8: 2F0B002C  cmpwi cr6, r11, 0x2c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 44, &mut ctx.xer);
	// 828643FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82864400: 41990008  bgt cr6, 0x82864408
	if ctx.cr[6].gt {
	pc = 0x82864408; continue 'dispatch;
	}
	// 82864404: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82864408; continue 'dispatch;
            }
            0x82864408 => {
    //   block [0x82864408..0x82864430)
	// 82864408: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286440C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864410: 409A0020  bne cr6, 0x82864430
	if !ctx.cr[6].eq {
	pc = 0x82864430; continue 'dispatch;
	}
	// 82864414: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82864418: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 8286441C: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82864420: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864424: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82864428: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286442C: 4800001C  b 0x82864448
	pc = 0x82864448; continue 'dispatch;
            }
            0x82864430 => {
    //   block [0x82864430..0x82864444)
	// 82864430: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82864434: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864438: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8286443C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82864440: 48000008  b 0x82864448
	pc = 0x82864448; continue 'dispatch;
            }
            0x82864444 => {
    //   block [0x82864444..0x82864448)
	// 82864444: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82864448; continue 'dispatch;
            }
            0x82864448 => {
    //   block [0x82864448..0x82864464)
	// 82864448: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286444C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864450: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82864454: 816A0064  lwz r11, 0x64(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 82864458: 6169000F  ori r9, r11, 0xf
	ctx.r[9].u64 = ctx.r[11].u64 | 15;
	// 8286445C: 912A0064  stw r9, 0x64(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82864460: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82864468 size=12
    let mut pc: u32 = 0x82864468;
    'dispatch: loop {
        match pc {
            0x82864468 => {
    //   block [0x82864468..0x82864474)
	// 82864468: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8286446C: 386BC320  addi r3, r11, -0x3ce0
	ctx.r[3].s64 = ctx.r[11].s64 + -15584;
	// 82864470: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82864478 size=12
    let mut pc: u32 = 0x82864478;
    'dispatch: loop {
        match pc {
            0x82864478 => {
    //   block [0x82864478..0x82864484)
	// 82864478: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8286447C: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82864480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82864488 size=20
    let mut pc: u32 = 0x82864488;
    'dispatch: loop {
        match pc {
            0x82864488 => {
    //   block [0x82864488..0x8286449C)
	// 82864488: 80630050  lwz r3, 0x50(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286448C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864490: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82864494: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82864498: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828644A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828644A0 size=792
    let mut pc: u32 = 0x828644A0;
    'dispatch: loop {
        match pc {
            0x828644A0 => {
    //   block [0x828644A0..0x82864510)
	// 828644A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828644A4: 48444F59  bl 0x82ca93fc
	ctx.lr = 0x828644A8;
	sub_82CA93D0(ctx, base);
	// 828644A8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828644AC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828644B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828644B4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828644B8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828644BC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828644C0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828644C4: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828644C8: 2F080018  cmpwi cr6, r8, 0x18
	ctx.cr[6].compare_i32(ctx.r[8].s32, 24, &mut ctx.xer);
	// 828644CC: 409A02DC  bne cr6, 0x828647a8
	if !ctx.cr[6].eq {
	pc = 0x828647A8; continue 'dispatch;
	}
	// 828644D0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828644D4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828644D8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828644DC: 9B2B0000  stb r25, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 828644E0: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828644E4: 4BFFF5B5  bl 0x82863a98
	ctx.lr = 0x828644E8;
	sub_82863A98(ctx, base);
	// 828644E8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828644EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828644F0: 419A02B8  beq cr6, 0x828647a8
	if ctx.cr[6].eq {
	pc = 0x828647A8; continue 'dispatch;
	}
	// 828644F4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828644F8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828644FC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82864500: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82864504: 4198000C  blt cr6, 0x82864510
	if ctx.cr[6].lt {
	pc = 0x82864510; continue 'dispatch;
	}
	// 82864508: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8286450C: 396B9700  addi r11, r11, -0x6900
	ctx.r[11].s64 = ctx.r[11].s64 + -26880;
	pc = 0x82864510; continue 'dispatch;
            }
            0x82864510 => {
    //   block [0x82864510..0x82864530)
	// 82864510: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864514: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 82864518: 419A0018  beq cr6, 0x82864530
	if ctx.cr[6].eq {
	pc = 0x82864530; continue 'dispatch;
	}
	// 8286451C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82864520: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82864524: 4B9C9015  bl 0x8222d538
	ctx.lr = 0x82864528;
	sub_8222D538(ctx, base);
	// 82864528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286452C: 419A027C  beq cr6, 0x828647a8
	if ctx.cr[6].eq {
	pc = 0x828647A8; continue 'dispatch;
	}
	pc = 0x82864530; continue 'dispatch;
            }
            0x82864530 => {
    //   block [0x82864530..0x8286459C)
	// 82864530: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82864534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864538: 4B9C3BC1  bl 0x822280f8
	ctx.lr = 0x8286453C;
	sub_822280F8(ctx, base);
	// 8286453C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82864540: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82864544: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864548: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286454C: 4B9C34AD  bl 0x822279f8
	ctx.lr = 0x82864550;
	sub_822279F8(ctx, base);
	// 82864550: 815A0050  lwz r10, 0x50(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(80 as u32) ) } as u64;
	// 82864554: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82864558: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 8286455C: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82864560: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82864564: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864568: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8286456C: 55286FFE  rlwinm r8, r9, 0xd, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0007FFFFu64;
	// 82864570: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82864574: 419A00D8  beq cr6, 0x8286464c
	if ctx.cr[6].eq {
	pc = 0x8286464C; continue 'dispatch;
	}
	// 82864578: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286457C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82864580: 419A001C  beq cr6, 0x8286459c
	if ctx.cr[6].eq {
	pc = 0x8286459C; continue 'dispatch;
	}
	// 82864584: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 82864588: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286458C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82864590: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82864594: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864598: 480000B0  b 0x82864648
	pc = 0x82864648; continue 'dispatch;
            }
            0x8286459C => {
    //   block [0x8286459C..0x828645B8)
	// 8286459C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828645A0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828645A4: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 828645A8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828645AC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828645B0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828645B4: 40810054  ble 0x82864608
	if !ctx.cr[0].gt {
	pc = 0x82864608; continue 'dispatch;
	}
	pc = 0x828645B8; continue 'dispatch;
            }
            0x828645B8 => {
    //   block [0x828645B8..0x828645D8)
	// 828645B8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828645BC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828645C0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828645C4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828645C8: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828645CC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828645D0: 41980008  blt cr6, 0x828645d8
	if ctx.cr[6].lt {
	pc = 0x828645D8; continue 'dispatch;
	}
	// 828645D4: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x828645D8; continue 'dispatch;
            }
            0x828645D8 => {
    //   block [0x828645D8..0x828645F4)
	// 828645D8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828645DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828645E0: 419A0014  beq cr6, 0x828645f4
	if ctx.cr[6].eq {
	pc = 0x828645F4; continue 'dispatch;
	}
	// 828645E4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828645E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828645EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828645F0: 4800000C  b 0x828645fc
	pc = 0x828645FC; continue 'dispatch;
            }
            0x828645F4 => {
    //   block [0x828645F4..0x828645FC)
	// 828645F4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828645F8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828645FC; continue 'dispatch;
            }
            0x828645FC => {
    //   block [0x828645FC..0x82864608)
	// 828645FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82864600: 4199FFB8  bgt cr6, 0x828645b8
	if ctx.cr[6].gt {
	pc = 0x828645B8; continue 'dispatch;
	}
	// 82864604: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82864608; continue 'dispatch;
            }
            0x82864608 => {
    //   block [0x82864608..0x82864624)
	// 82864608: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8286460C: 419A0034  beq cr6, 0x82864640
	if ctx.cr[6].eq {
	pc = 0x82864640; continue 'dispatch;
	}
	// 82864610: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864614: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82864618: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286461C: 41990008  bgt cr6, 0x82864624
	if ctx.cr[6].gt {
	pc = 0x82864624; continue 'dispatch;
	}
	// 82864620: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82864624; continue 'dispatch;
            }
            0x82864624 => {
    //   block [0x82864624..0x82864640)
	// 82864624: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82864628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286462C: 409A0014  bne cr6, 0x82864640
	if !ctx.cr[6].eq {
	pc = 0x82864640; continue 'dispatch;
	}
	// 82864630: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82864634: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82864638: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8286463C: 48000008  b 0x82864644
	pc = 0x82864644; continue 'dispatch;
            }
            0x82864640 => {
    //   block [0x82864640..0x82864644)
	// 82864640: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x82864644; continue 'dispatch;
            }
            0x82864644 => {
    //   block [0x82864644..0x82864648)
	// 82864644: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82864648; continue 'dispatch;
            }
            0x82864648 => {
    //   block [0x82864648..0x8286464C)
	// 82864648: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	pc = 0x8286464C; continue 'dispatch;
            }
            0x8286464C => {
    //   block [0x8286464C..0x82864674)
	// 8286464C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82864650: 4B9BAC09  bl 0x8221f258
	ctx.lr = 0x82864654;
	sub_8221F258(ctx, base);
	// 82864654: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82864658: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286465C: C3EB92CC  lfs f31, -0x6d34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27956 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82864660: 419A0014  beq cr6, 0x82864674
	if ctx.cr[6].eq {
	pc = 0x82864674; continue 'dispatch;
	}
	// 82864664: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82864668: 4BA274D9  bl 0x8228bb40
	ctx.lr = 0x8286466C;
	sub_8228BB40(ctx, base);
	// 8286466C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82864670: 48000008  b 0x82864678
	pc = 0x82864678; continue 'dispatch;
            }
            0x82864674 => {
    //   block [0x82864674..0x82864678)
	// 82864674: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	pc = 0x82864678; continue 'dispatch;
            }
            0x82864678 => {
    //   block [0x82864678..0x82864698)
	// 82864678: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8286467C: 4B9BABDD  bl 0x8221f258
	ctx.lr = 0x82864680;
	sub_8221F258(ctx, base);
	// 82864680: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864684: 419A0014  beq cr6, 0x82864698
	if ctx.cr[6].eq {
	pc = 0x82864698; continue 'dispatch;
	}
	// 82864688: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286468C: 4B9C50AD  bl 0x82229738
	ctx.lr = 0x82864690;
	sub_82229738(ctx, base);
	// 82864690: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82864694: 48000008  b 0x8286469c
	pc = 0x8286469C; continue 'dispatch;
            }
            0x82864698 => {
    //   block [0x82864698..0x8286469C)
	// 82864698: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	pc = 0x8286469C; continue 'dispatch;
            }
            0x8286469C => {
    //   block [0x8286469C..0x828646B4)
	// 8286469C: 809A0054  lwz r4, 0x54(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(84 as u32) ) } as u64;
	// 828646A0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828646A4: 419A0010  beq cr6, 0x828646b4
	if ctx.cr[6].eq {
	pc = 0x828646B4; continue 'dispatch;
	}
	// 828646A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828646AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828646B0: 4BA49971  bl 0x822ae020
	ctx.lr = 0x828646B4;
	sub_822AE020(ctx, base);
	pc = 0x828646B4; continue 'dispatch;
            }
            0x828646B4 => {
    //   block [0x828646B4..0x828646F4)
	// 828646B4: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 828646B8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828646BC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828646C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828646C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828646C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828646CC: 4B969A75  bl 0x821ce140
	ctx.lr = 0x828646D0;
	sub_821CE140(ctx, base);
	// 828646D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828646D4: 817A0054  lwz r11, 0x54(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(84 as u32) ) } as u64;
	// 828646D8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828646DC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 828646E0: 419A007C  beq cr6, 0x8286475c
	if ctx.cr[6].eq {
	pc = 0x8286475C; continue 'dispatch;
	}
	// 828646E4: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828646E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828646EC: 419A0040  beq cr6, 0x8286472c
	if ctx.cr[6].eq {
	pc = 0x8286472C; continue 'dispatch;
	}
	// 828646F0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x828646F4; continue 'dispatch;
            }
            0x828646F4 => {
    //   block [0x828646F4..0x82864728)
	// 828646F4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828646F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828646FC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82864700: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82864704: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82864708: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286470C: 4082FFE8  bne 0x828646f4
	if !ctx.cr[0].eq {
	pc = 0x828646F4; continue 'dispatch;
	}
	// 82864710: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82864714: 409A0014  bne cr6, 0x82864728
	if !ctx.cr[6].eq {
	pc = 0x82864728; continue 'dispatch;
	}
	// 82864718: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286471C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864720: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82864724: 4E800421  bctrl
	ctx.lr = 0x82864728;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82864728 => {
    //   block [0x82864728..0x8286472C)
	// 82864728: 933A0054  stw r25, 0x54(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	pc = 0x8286472C; continue 'dispatch;
            }
            0x8286472C => {
    //   block [0x8286472C..0x82864740)
	// 8286472C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864730: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864734: 917A0054  stw r11, 0x54(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82864738: 419A0024  beq cr6, 0x8286475c
	if ctx.cr[6].eq {
	pc = 0x8286475C; continue 'dispatch;
	}
	// 8286473C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82864740; continue 'dispatch;
            }
            0x82864740 => {
    //   block [0x82864740..0x8286475C)
	// 82864740: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82864744: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82864748: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286474C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82864750: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82864754: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82864758: 4082FFE8  bne 0x82864740
	if !ctx.cr[0].eq {
	pc = 0x82864740; continue 'dispatch;
	}
	pc = 0x8286475C; continue 'dispatch;
            }
            0x8286475C => {
    //   block [0x8286475C..0x82864770)
	// 8286475C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82864760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864764: 419A0044  beq cr6, 0x828647a8
	if ctx.cr[6].eq {
	pc = 0x828647A8; continue 'dispatch;
	}
	// 82864768: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286476C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82864770; continue 'dispatch;
            }
            0x82864770 => {
    //   block [0x82864770..0x828647A8)
	// 82864770: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82864774: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82864778: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286477C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82864780: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82864784: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82864788: 4082FFE8  bne 0x82864770
	if !ctx.cr[0].eq {
	pc = 0x82864770; continue 'dispatch;
	}
	// 8286478C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82864790: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82864794: 409A0014  bne cr6, 0x828647a8
	if !ctx.cr[6].eq {
	pc = 0x828647A8; continue 'dispatch;
	}
	// 82864798: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286479C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828647A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828647A4: 4E800421  bctrl
	ctx.lr = 0x828647A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828647A8 => {
    //   block [0x828647A8..0x828647B8)
	// 828647A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828647AC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828647B0: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 828647B4: 48444C98  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828647B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828647B8 size=696
    let mut pc: u32 = 0x828647B8;
    'dispatch: loop {
        match pc {
            0x828647B8 => {
    //   block [0x828647B8..0x82864828)
	// 828647B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828647BC: 48444C49  bl 0x82ca9404
	ctx.lr = 0x828647C0;
	sub_82CA93D0(ctx, base);
	// 828647C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828647C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828647C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828647CC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828647D0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828647D4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828647D8: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828647DC: 2F080028  cmpwi cr6, r8, 0x28
	ctx.cr[6].compare_i32(ctx.r[8].s32, 40, &mut ctx.xer);
	// 828647E0: 409A0284  bne cr6, 0x82864a64
	if !ctx.cr[6].eq {
	pc = 0x82864A64; continue 'dispatch;
	}
	// 828647E4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828647E8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828647EC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828647F0: 9B6B0000  stb r27, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	// 828647F4: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828647F8: 4BFFF2A1  bl 0x82863a98
	ctx.lr = 0x828647FC;
	sub_82863A98(ctx, base);
	// 828647FC: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82864800: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82864804: 419A0260  beq cr6, 0x82864a64
	if ctx.cr[6].eq {
	pc = 0x82864A64; continue 'dispatch;
	}
	// 82864808: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8286480C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82864810: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82864814: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82864818: 3BCA9700  addi r30, r10, -0x6900
	ctx.r[30].s64 = ctx.r[10].s64 + -26880;
	// 8286481C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82864820: 41980008  blt cr6, 0x82864828
	if ctx.cr[6].lt {
	pc = 0x82864828; continue 'dispatch;
	}
	// 82864824: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82864828; continue 'dispatch;
            }
            0x82864828 => {
    //   block [0x82864828..0x82864848)
	// 82864828: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286482C: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 82864830: 419A0018  beq cr6, 0x82864848
	if ctx.cr[6].eq {
	pc = 0x82864848; continue 'dispatch;
	}
	// 82864834: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82864838: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286483C: 4B9C8CFD  bl 0x8222d538
	ctx.lr = 0x82864840;
	sub_8222D538(ctx, base);
	// 82864840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864844: 419A0220  beq cr6, 0x82864a64
	if ctx.cr[6].eq {
	pc = 0x82864A64; continue 'dispatch;
	}
	pc = 0x82864848; continue 'dispatch;
            }
            0x82864848 => {
    //   block [0x82864848..0x82864860)
	// 82864848: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8286484C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82864850: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82864854: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82864858: 41980008  blt cr6, 0x82864860
	if ctx.cr[6].lt {
	pc = 0x82864860; continue 'dispatch;
	}
	// 8286485C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82864860; continue 'dispatch;
            }
            0x82864860 => {
    //   block [0x82864860..0x82864880)
	// 82864860: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864864: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 82864868: 419A0018  beq cr6, 0x82864880
	if ctx.cr[6].eq {
	pc = 0x82864880; continue 'dispatch;
	}
	// 8286486C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82864870: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82864874: 4B9C8CC5  bl 0x8222d538
	ctx.lr = 0x82864878;
	sub_8222D538(ctx, base);
	// 82864878: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286487C: 419A01E8  beq cr6, 0x82864a64
	if ctx.cr[6].eq {
	pc = 0x82864A64; continue 'dispatch;
	}
	pc = 0x82864880; continue 'dispatch;
            }
            0x82864880 => {
    //   block [0x82864880..0x82864898)
	// 82864880: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82864884: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82864888: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 8286488C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82864890: 41980008  blt cr6, 0x82864898
	if ctx.cr[6].lt {
	pc = 0x82864898; continue 'dispatch;
	}
	// 82864894: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82864898; continue 'dispatch;
            }
            0x82864898 => {
    //   block [0x82864898..0x828648B8)
	// 82864898: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286489C: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 828648A0: 419A0018  beq cr6, 0x828648b8
	if ctx.cr[6].eq {
	pc = 0x828648B8; continue 'dispatch;
	}
	// 828648A4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828648A8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828648AC: 4B9C8C8D  bl 0x8222d538
	ctx.lr = 0x828648B0;
	sub_8222D538(ctx, base);
	// 828648B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828648B4: 419A01B0  beq cr6, 0x82864a64
	if ctx.cr[6].eq {
	pc = 0x82864A64; continue 'dispatch;
	}
	pc = 0x828648B8; continue 'dispatch;
            }
            0x828648B8 => {
    //   block [0x828648B8..0x82864954)
	// 828648B8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828648BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828648C0: 4B9C3839  bl 0x822280f8
	ctx.lr = 0x828648C4;
	sub_822280F8(ctx, base);
	// 828648C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828648C8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828648CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828648D0: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828648D4: 4B9C3125  bl 0x822279f8
	ctx.lr = 0x828648D8;
	sub_822279F8(ctx, base);
	// 828648D8: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 828648DC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828648E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828648E4: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 828648E8: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828648EC: 4B9C310D  bl 0x822279f8
	ctx.lr = 0x828648F0;
	sub_822279F8(ctx, base);
	// 828648F0: FDA0081E  fctiwz f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 828648F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828648F8: D9A10058  stfd f13, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[13].u64 ) };
	// 828648FC: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82864900: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82864904: 4B9C30F5  bl 0x822279f8
	ctx.lr = 0x82864908;
	sub_822279F8(ctx, base);
	// 82864908: 815D0050  lwz r10, 0x50(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286490C: FD80081E  fctiwz f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82864910: D9810058  stfd f12, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[12].u64 ) };
	// 82864914: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82864918: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8286491C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864920: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82864924: 55276FFE  rlwinm r7, r9, 0xd, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x0007FFFFu64;
	// 82864928: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286492C: 419A00D4  beq cr6, 0x82864a00
	if ctx.cr[6].eq {
	pc = 0x82864A00; continue 'dispatch;
	}
	// 82864930: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82864934: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82864938: 419A001C  beq cr6, 0x82864954
	if ctx.cr[6].eq {
	pc = 0x82864954; continue 'dispatch;
	}
	// 8286493C: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 82864940: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82864944: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82864948: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286494C: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864950: 480000B0  b 0x82864a00
	pc = 0x82864A00; continue 'dispatch;
            }
            0x82864954 => {
    //   block [0x82864954..0x82864970)
	// 82864954: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82864958: 80AB004C  lwz r5, 0x4c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286495C: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82864960: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82864964: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82864968: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286496C: 40810054  ble 0x828649c0
	if !ctx.cr[0].gt {
	pc = 0x828649C0; continue 'dispatch;
	}
	pc = 0x82864970; continue 'dispatch;
            }
            0x82864970 => {
    //   block [0x82864970..0x82864990)
	// 82864970: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82864974: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82864978: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 8286497C: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864980: 2F060013  cmpwi cr6, r6, 0x13
	ctx.cr[6].compare_i32(ctx.r[6].s32, 19, &mut ctx.xer);
	// 82864984: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82864988: 41980008  blt cr6, 0x82864990
	if ctx.cr[6].lt {
	pc = 0x82864990; continue 'dispatch;
	}
	// 8286498C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82864990; continue 'dispatch;
            }
            0x82864990 => {
    //   block [0x82864990..0x828649AC)
	// 82864990: 54C6063E  clrlwi r6, r6, 0x18
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82864994: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82864998: 419A0014  beq cr6, 0x828649ac
	if ctx.cr[6].eq {
	pc = 0x828649AC; continue 'dispatch;
	}
	// 8286499C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828649A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828649A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828649A8: 4800000C  b 0x828649b4
	pc = 0x828649B4; continue 'dispatch;
            }
            0x828649AC => {
    //   block [0x828649AC..0x828649B4)
	// 828649AC: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 828649B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828649B4; continue 'dispatch;
            }
            0x828649B4 => {
    //   block [0x828649B4..0x828649C0)
	// 828649B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828649B8: 4199FFB8  bgt cr6, 0x82864970
	if ctx.cr[6].gt {
	pc = 0x82864970; continue 'dispatch;
	}
	// 828649BC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x828649C0; continue 'dispatch;
            }
            0x828649C0 => {
    //   block [0x828649C0..0x828649DC)
	// 828649C0: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828649C4: 419A0034  beq cr6, 0x828649f8
	if ctx.cr[6].eq {
	pc = 0x828649F8; continue 'dispatch;
	}
	// 828649C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828649CC: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 828649D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828649D4: 41990008  bgt cr6, 0x828649dc
	if ctx.cr[6].gt {
	pc = 0x828649DC; continue 'dispatch;
	}
	// 828649D8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x828649DC; continue 'dispatch;
            }
            0x828649DC => {
    //   block [0x828649DC..0x828649F8)
	// 828649DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828649E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828649E4: 409A0014  bne cr6, 0x828649f8
	if !ctx.cr[6].eq {
	pc = 0x828649F8; continue 'dispatch;
	}
	// 828649E8: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828649EC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828649F0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828649F4: 48000008  b 0x828649fc
	pc = 0x828649FC; continue 'dispatch;
            }
            0x828649F8 => {
    //   block [0x828649F8..0x828649FC)
	// 828649F8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x828649FC; continue 'dispatch;
            }
            0x828649FC => {
    //   block [0x828649FC..0x82864A00)
	// 828649FC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82864A00; continue 'dispatch;
            }
            0x82864A00 => {
    //   block [0x82864A00..0x82864A2C)
	// 82864A00: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82864A04: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82864A08: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82864A0C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82864A10: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82864A14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82864A18: 4BCFE6A1  bl 0x825630b8
	ctx.lr = 0x82864A1C;
	sub_825630B8(ctx, base);
	// 82864A1C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82864A20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864A24: 419A0040  beq cr6, 0x82864a64
	if ctx.cr[6].eq {
	pc = 0x82864A64; continue 'dispatch;
	}
	// 82864A28: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	pc = 0x82864A2C; continue 'dispatch;
            }
            0x82864A2C => {
    //   block [0x82864A2C..0x82864A64)
	// 82864A2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82864A30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82864A34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82864A38: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82864A3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82864A40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82864A44: 4082FFE8  bne 0x82864a2c
	if !ctx.cr[0].eq {
	pc = 0x82864A2C; continue 'dispatch;
	}
	// 82864A48: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82864A4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82864A50: 409A0014  bne cr6, 0x82864a64
	if !ctx.cr[6].eq {
	pc = 0x82864A64; continue 'dispatch;
	}
	// 82864A54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864A58: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864A5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82864A60: 4E800421  bctrl
	ctx.lr = 0x82864A64;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82864A64 => {
    //   block [0x82864A64..0x82864A70)
	// 82864A64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82864A68: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82864A6C: 484449E8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864A70 size=1272
    let mut pc: u32 = 0x82864A70;
    'dispatch: loop {
        match pc {
            0x82864A70 => {
    //   block [0x82864A70..0x82864AE0)
	// 82864A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864A74: 48444985  bl 0x82ca93f8
	ctx.lr = 0x82864A78;
	sub_82CA93D0(ctx, base);
	// 82864A78: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82864A7C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82864A80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82864A84: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82864A88: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82864A8C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82864A90: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82864A94: 2F080030  cmpwi cr6, r8, 0x30
	ctx.cr[6].compare_i32(ctx.r[8].s32, 48, &mut ctx.xer);
	// 82864A98: 409A04C4  bne cr6, 0x82864f5c
	if !ctx.cr[6].eq {
	pc = 0x82864F5C; continue 'dispatch;
	}
	// 82864A9C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82864AA0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82864AA4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82864AA8: 9B8B0000  stb r28, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 82864AAC: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82864AB0: 4BFFEFE9  bl 0x82863a98
	ctx.lr = 0x82864AB4;
	sub_82863A98(ctx, base);
	// 82864AB4: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82864AB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82864ABC: 419A04A0  beq cr6, 0x82864f5c
	if ctx.cr[6].eq {
	pc = 0x82864F5C; continue 'dispatch;
	}
	// 82864AC0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82864AC4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82864AC8: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82864ACC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82864AD0: 3BCA9700  addi r30, r10, -0x6900
	ctx.r[30].s64 = ctx.r[10].s64 + -26880;
	// 82864AD4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82864AD8: 41980008  blt cr6, 0x82864ae0
	if ctx.cr[6].lt {
	pc = 0x82864AE0; continue 'dispatch;
	}
	// 82864ADC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82864AE0; continue 'dispatch;
            }
            0x82864AE0 => {
    //   block [0x82864AE0..0x82864B00)
	// 82864AE0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864AE4: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 82864AE8: 419A0018  beq cr6, 0x82864b00
	if ctx.cr[6].eq {
	pc = 0x82864B00; continue 'dispatch;
	}
	// 82864AEC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82864AF0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82864AF4: 4B9C8A45  bl 0x8222d538
	ctx.lr = 0x82864AF8;
	sub_8222D538(ctx, base);
	// 82864AF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864AFC: 419A0460  beq cr6, 0x82864f5c
	if ctx.cr[6].eq {
	pc = 0x82864F5C; continue 'dispatch;
	}
	pc = 0x82864B00; continue 'dispatch;
            }
            0x82864B00 => {
    //   block [0x82864B00..0x82864B18)
	// 82864B00: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82864B04: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82864B08: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82864B0C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82864B10: 41980008  blt cr6, 0x82864b18
	if ctx.cr[6].lt {
	pc = 0x82864B18; continue 'dispatch;
	}
	// 82864B14: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82864B18; continue 'dispatch;
            }
            0x82864B18 => {
    //   block [0x82864B18..0x82864B38)
	// 82864B18: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864B1C: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 82864B20: 419A0018  beq cr6, 0x82864b38
	if ctx.cr[6].eq {
	pc = 0x82864B38; continue 'dispatch;
	}
	// 82864B24: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82864B28: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82864B2C: 4B9C8A0D  bl 0x8222d538
	ctx.lr = 0x82864B30;
	sub_8222D538(ctx, base);
	// 82864B30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864B34: 419A0428  beq cr6, 0x82864f5c
	if ctx.cr[6].eq {
	pc = 0x82864F5C; continue 'dispatch;
	}
	pc = 0x82864B38; continue 'dispatch;
            }
            0x82864B38 => {
    //   block [0x82864B38..0x82864B50)
	// 82864B38: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82864B3C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82864B40: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82864B44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82864B48: 41980008  blt cr6, 0x82864b50
	if ctx.cr[6].lt {
	pc = 0x82864B50; continue 'dispatch;
	}
	// 82864B4C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82864B50; continue 'dispatch;
            }
            0x82864B50 => {
    //   block [0x82864B50..0x82864B70)
	// 82864B50: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864B54: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 82864B58: 419A0018  beq cr6, 0x82864b70
	if ctx.cr[6].eq {
	pc = 0x82864B70; continue 'dispatch;
	}
	// 82864B5C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82864B60: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82864B64: 4B9C89D5  bl 0x8222d538
	ctx.lr = 0x82864B68;
	sub_8222D538(ctx, base);
	// 82864B68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864B6C: 419A03F0  beq cr6, 0x82864f5c
	if ctx.cr[6].eq {
	pc = 0x82864F5C; continue 'dispatch;
	}
	pc = 0x82864B70; continue 'dispatch;
            }
            0x82864B70 => {
    //   block [0x82864B70..0x82864BF8)
	// 82864B70: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82864B74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864B78: 481BF839  bl 0x82a243b0
	ctx.lr = 0x82864B7C;
	sub_82A243B0(ctx, base);
	// 82864B7C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82864B80: 419A03DC  beq cr6, 0x82864f5c
	if ctx.cr[6].eq {
	pc = 0x82864F5C; continue 'dispatch;
	}
	// 82864B84: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82864B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864B8C: 4B9C356D  bl 0x822280f8
	ctx.lr = 0x82864B90;
	sub_822280F8(ctx, base);
	// 82864B90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82864B94: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82864B98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864B9C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864BA0: 4B9C2E59  bl 0x822279f8
	ctx.lr = 0x82864BA4;
	sub_822279F8(ctx, base);
	// 82864BA4: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82864BA8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82864BAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864BB0: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82864BB4: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82864BB8: 4B9C2E41  bl 0x822279f8
	ctx.lr = 0x82864BBC;
	sub_822279F8(ctx, base);
	// 82864BBC: FDA0081E  fctiwz f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82864BC0: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82864BC4: D9A10058  stfd f13, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[13].u64 ) };
	// 82864BC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864BCC: 8321005C  lwz r25, 0x5c(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82864BD0: 4B9C2E29  bl 0x822279f8
	ctx.lr = 0x82864BD4;
	sub_822279F8(ctx, base);
	// 82864BD4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82864BD8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82864BDC: FD80081E  fctiwz f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82864BE0: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 82864BE4: D9810058  stfd f12, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[12].u64 ) };
	// 82864BE8: 8301005C  lwz r24, 0x5c(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82864BEC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82864BF0: 41980008  blt cr6, 0x82864bf8
	if ctx.cr[6].lt {
	pc = 0x82864BF8; continue 'dispatch;
	}
	// 82864BF4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82864BF8; continue 'dispatch;
            }
            0x82864BF8 => {
    //   block [0x82864BF8..0x82864C20)
	// 82864BF8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864BFC: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 82864C00: 419A0054  beq cr6, 0x82864c54
	if ctx.cr[6].eq {
	pc = 0x82864C54; continue 'dispatch;
	}
	// 82864C04: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82864C08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864C0C: 4BA3A14D  bl 0x8229ed58
	ctx.lr = 0x82864C10;
	sub_8229ED58(ctx, base);
	// 82864C10: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82864C14: 409A000C  bne cr6, 0x82864c20
	if !ctx.cr[6].eq {
	pc = 0x82864C20; continue 'dispatch;
	}
	// 82864C18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82864C1C: 48000040  b 0x82864c5c
	pc = 0x82864C5C; continue 'dispatch;
            }
            0x82864C20 => {
    //   block [0x82864C20..0x82864C3C)
	// 82864C20: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82864C24: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82864C28: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82864C2C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82864C30: 4198000C  blt cr6, 0x82864c3c
	if ctx.cr[6].lt {
	pc = 0x82864C3C; continue 'dispatch;
	}
	// 82864C34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864C38: 4B914949  bl 0x82179580
	ctx.lr = 0x82864C3C;
	sub_82179580(ctx, base);
	pc = 0x82864C3C; continue 'dispatch;
            }
            0x82864C3C => {
    //   block [0x82864C3C..0x82864C54)
	// 82864C3C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82864C40: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82864C44: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 82864C48: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82864C4C: 41980008  blt cr6, 0x82864c54
	if ctx.cr[6].lt {
	pc = 0x82864C54; continue 'dispatch;
	}
	// 82864C50: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82864C54; continue 'dispatch;
            }
            0x82864C54 => {
    //   block [0x82864C54..0x82864C5C)
	// 82864C54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864C58: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	pc = 0x82864C5C; continue 'dispatch;
            }
            0x82864C5C => {
    //   block [0x82864C5C..0x82864CA8)
	// 82864C5C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82864C60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82864C64: 4B9C826D  bl 0x8222ced0
	ctx.lr = 0x82864C68;
	sub_8222CED0(ctx, base);
	// 82864C68: 817D0050  lwz r11, 0x50(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 82864C6C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82864C70: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864C74: 81460024  lwz r10, 0x24(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82864C78: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82864C7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82864C80: 419A00D8  beq cr6, 0x82864d58
	if ctx.cr[6].eq {
	pc = 0x82864D58; continue 'dispatch;
	}
	// 82864C84: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82864C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864C8C: 419A001C  beq cr6, 0x82864ca8
	if ctx.cr[6].eq {
	pc = 0x82864CA8; continue 'dispatch;
	}
	// 82864C90: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 82864C94: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82864C98: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82864C9C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82864CA0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864CA4: 480000B0  b 0x82864d54
	pc = 0x82864D54; continue 'dispatch;
            }
            0x82864CA8 => {
    //   block [0x82864CA8..0x82864CC4)
	// 82864CA8: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82864CAC: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82864CB0: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82864CB4: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82864CB8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82864CBC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82864CC0: 40810054  ble 0x82864d14
	if !ctx.cr[0].gt {
	pc = 0x82864D14; continue 'dispatch;
	}
	pc = 0x82864CC4; continue 'dispatch;
            }
            0x82864CC4 => {
    //   block [0x82864CC4..0x82864CE4)
	// 82864CC4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82864CC8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82864CCC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82864CD0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864CD4: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82864CD8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82864CDC: 41980008  blt cr6, 0x82864ce4
	if ctx.cr[6].lt {
	pc = 0x82864CE4; continue 'dispatch;
	}
	// 82864CE0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x82864CE4; continue 'dispatch;
            }
            0x82864CE4 => {
    //   block [0x82864CE4..0x82864D00)
	// 82864CE4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82864CE8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82864CEC: 419A0014  beq cr6, 0x82864d00
	if ctx.cr[6].eq {
	pc = 0x82864D00; continue 'dispatch;
	}
	// 82864CF0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82864CF4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82864CF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82864CFC: 4800000C  b 0x82864d08
	pc = 0x82864D08; continue 'dispatch;
            }
            0x82864D00 => {
    //   block [0x82864D00..0x82864D08)
	// 82864D00: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82864D04: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82864D08; continue 'dispatch;
            }
            0x82864D08 => {
    //   block [0x82864D08..0x82864D14)
	// 82864D08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82864D0C: 4199FFB8  bgt cr6, 0x82864cc4
	if ctx.cr[6].gt {
	pc = 0x82864CC4; continue 'dispatch;
	}
	// 82864D10: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82864D14; continue 'dispatch;
            }
            0x82864D14 => {
    //   block [0x82864D14..0x82864D30)
	// 82864D14: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82864D18: 419A0034  beq cr6, 0x82864d4c
	if ctx.cr[6].eq {
	pc = 0x82864D4C; continue 'dispatch;
	}
	// 82864D1C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864D20: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82864D24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82864D28: 41990008  bgt cr6, 0x82864d30
	if ctx.cr[6].gt {
	pc = 0x82864D30; continue 'dispatch;
	}
	// 82864D2C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82864D30; continue 'dispatch;
            }
            0x82864D30 => {
    //   block [0x82864D30..0x82864D4C)
	// 82864D30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82864D34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864D38: 409A0014  bne cr6, 0x82864d4c
	if !ctx.cr[6].eq {
	pc = 0x82864D4C; continue 'dispatch;
	}
	// 82864D3C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82864D40: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82864D44: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82864D48: 48000008  b 0x82864d50
	pc = 0x82864D50; continue 'dispatch;
            }
            0x82864D4C => {
    //   block [0x82864D4C..0x82864D50)
	// 82864D4C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x82864D50; continue 'dispatch;
            }
            0x82864D50 => {
    //   block [0x82864D50..0x82864D54)
	// 82864D50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82864D54; continue 'dispatch;
            }
            0x82864D54 => {
    //   block [0x82864D54..0x82864D58)
	// 82864D54: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x82864D58; continue 'dispatch;
            }
            0x82864D58 => {
    //   block [0x82864D58..0x82864D98)
	// 82864D58: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82864D5C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82864D60: 5569D7FE  rlwinm r9, r11, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82864D64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82864D68: 419A00F0  beq cr6, 0x82864e58
	if ctx.cr[6].eq {
	pc = 0x82864E58; continue 'dispatch;
	}
	// 82864D6C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82864D70: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82864D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864D78: 419A0020  beq cr6, 0x82864d98
	if ctx.cr[6].eq {
	pc = 0x82864D98; continue 'dispatch;
	}
	// 82864D7C: 896B0006  lbz r11, 6(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82864D80: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 82864D84: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82864D88: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864D8C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82864D90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82864D94: 480000C8  b 0x82864e5c
	pc = 0x82864E5C; continue 'dispatch;
            }
            0x82864D98 => {
    //   block [0x82864D98..0x82864DB0)
	// 82864D98: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82864D9C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82864DA0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82864DA4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82864DA8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82864DAC: 40810054  ble 0x82864e00
	if !ctx.cr[0].gt {
	pc = 0x82864E00; continue 'dispatch;
	}
	pc = 0x82864DB0; continue 'dispatch;
            }
            0x82864DB0 => {
    //   block [0x82864DB0..0x82864DD0)
	// 82864DB0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82864DB4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82864DB8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82864DBC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864DC0: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 82864DC4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82864DC8: 41980008  blt cr6, 0x82864dd0
	if ctx.cr[6].lt {
	pc = 0x82864DD0; continue 'dispatch;
	}
	// 82864DCC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x82864DD0; continue 'dispatch;
            }
            0x82864DD0 => {
    //   block [0x82864DD0..0x82864DEC)
	// 82864DD0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82864DD4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82864DD8: 419A0014  beq cr6, 0x82864dec
	if ctx.cr[6].eq {
	pc = 0x82864DEC; continue 'dispatch;
	}
	// 82864DDC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82864DE0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82864DE4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82864DE8: 4800000C  b 0x82864df4
	pc = 0x82864DF4; continue 'dispatch;
            }
            0x82864DEC => {
    //   block [0x82864DEC..0x82864DF4)
	// 82864DEC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82864DF0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82864DF4; continue 'dispatch;
            }
            0x82864DF4 => {
    //   block [0x82864DF4..0x82864E00)
	// 82864DF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82864DF8: 4199FFB8  bgt cr6, 0x82864db0
	if ctx.cr[6].gt {
	pc = 0x82864DB0; continue 'dispatch;
	}
	// 82864DFC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82864E00; continue 'dispatch;
            }
            0x82864E00 => {
    //   block [0x82864E00..0x82864E1C)
	// 82864E00: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82864E04: 419A0040  beq cr6, 0x82864e44
	if ctx.cr[6].eq {
	pc = 0x82864E44; continue 'dispatch;
	}
	// 82864E08: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864E0C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82864E10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82864E14: 41990008  bgt cr6, 0x82864e1c
	if ctx.cr[6].gt {
	pc = 0x82864E1C; continue 'dispatch;
	}
	// 82864E18: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82864E1C; continue 'dispatch;
            }
            0x82864E1C => {
    //   block [0x82864E1C..0x82864E44)
	// 82864E1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82864E20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864E24: 409A0020  bne cr6, 0x82864e44
	if !ctx.cr[6].eq {
	pc = 0x82864E44; continue 'dispatch;
	}
	// 82864E28: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82864E2C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82864E30: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82864E34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864E38: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82864E3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82864E40: 4800001C  b 0x82864e5c
	pc = 0x82864E5C; continue 'dispatch;
            }
            0x82864E44 => {
    //   block [0x82864E44..0x82864E58)
	// 82864E44: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82864E48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864E4C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82864E50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82864E54: 48000008  b 0x82864e5c
	pc = 0x82864E5C; continue 'dispatch;
            }
            0x82864E58 => {
    //   block [0x82864E58..0x82864E5C)
	// 82864E58: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82864E5C; continue 'dispatch;
            }
            0x82864E5C => {
    //   block [0x82864E5C..0x82864EE0)
	// 82864E5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82864E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864E64: 419A00F0  beq cr6, 0x82864f54
	if ctx.cr[6].eq {
	pc = 0x82864F54; continue 'dispatch;
	}
	// 82864E68: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82864E6C: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82864E70: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 82864E74: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82864E78: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82864E7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82864E80: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82864E84: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82864E88: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 82864E8C: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 82864E90: 93810084  stw r28, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[28].u32 ) };
	// 82864E94: 9B810089  stb r28, 0x89(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(137 as u32), ctx.r[28].u8 ) };
	// 82864E98: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 82864E9C: 93810094  stw r28, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[28].u32 ) };
	// 82864EA0: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 82864EA4: 938100A0  stw r28, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[28].u32 ) };
	// 82864EA8: 938100A4  stw r28, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[28].u32 ) };
	// 82864EAC: 938100A8  stw r28, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[28].u32 ) };
	// 82864EB0: 808A0094  lwz r4, 0x94(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(148 as u32) ) } as u64;
	// 82864EB4: 4BEFCD8D  bl 0x82761c40
	ctx.lr = 0x82864EB8;
	sub_82761C40(ctx, base);
	// 82864EB8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82864EBC: 4B9BA39D  bl 0x8221f258
	ctx.lr = 0x82864EC0;
	sub_8221F258(ctx, base);
	// 82864EC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864EC4: 419A001C  beq cr6, 0x82864ee0
	if ctx.cr[6].eq {
	pc = 0x82864EE0; continue 'dispatch;
	}
	// 82864EC8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82864ECC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82864ED0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82864ED4: 4BEFCF05  bl 0x82761dd8
	ctx.lr = 0x82864ED8;
	sub_82761DD8(ctx, base);
	// 82864ED8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82864EDC: 48000008  b 0x82864ee4
	pc = 0x82864EE4; continue 'dispatch;
            }
            0x82864EE0 => {
    //   block [0x82864EE0..0x82864EE4)
	// 82864EE0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	pc = 0x82864EE4; continue 'dispatch;
            }
            0x82864EE4 => {
    //   block [0x82864EE4..0x82864F14)
	// 82864EE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82864EE8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82864EEC: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 82864EF0: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82864EF4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82864EF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82864EFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82864F00: 4BCFE1B9  bl 0x825630b8
	ctx.lr = 0x82864F04;
	sub_825630B8(ctx, base);
	// 82864F04: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82864F08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864F0C: 419A0040  beq cr6, 0x82864f4c
	if ctx.cr[6].eq {
	pc = 0x82864F4C; continue 'dispatch;
	}
	// 82864F10: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	pc = 0x82864F14; continue 'dispatch;
            }
            0x82864F14 => {
    //   block [0x82864F14..0x82864F4C)
	// 82864F14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82864F18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82864F1C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82864F20: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82864F24: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82864F28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82864F2C: 4082FFE8  bne 0x82864f14
	if !ctx.cr[0].eq {
	pc = 0x82864F14; continue 'dispatch;
	}
	// 82864F30: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82864F34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82864F38: 409A0014  bne cr6, 0x82864f4c
	if !ctx.cr[6].eq {
	pc = 0x82864F4C; continue 'dispatch;
	}
	// 82864F3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864F40: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864F44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82864F48: 4E800421  bctrl
	ctx.lr = 0x82864F4C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82864F4C => {
    //   block [0x82864F4C..0x82864F54)
	// 82864F4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82864F50: 4BFA2801  bl 0x82807750
	ctx.lr = 0x82864F54;
	sub_82807750(ctx, base);
	pc = 0x82864F54; continue 'dispatch;
            }
            0x82864F54 => {
    //   block [0x82864F54..0x82864F5C)
	// 82864F54: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82864F58: 4B9AFE81  bl 0x82214dd8
	ctx.lr = 0x82864F5C;
	sub_82214DD8(ctx, base);
	pc = 0x82864F5C; continue 'dispatch;
            }
            0x82864F5C => {
    //   block [0x82864F5C..0x82864F68)
	// 82864F5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82864F60: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82864F64: 484444E4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864F68 size=428
    let mut pc: u32 = 0x82864F68;
    'dispatch: loop {
        match pc {
            0x82864F68 => {
    //   block [0x82864F68..0x82864FD0)
	// 82864F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82864F70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82864F74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82864F78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82864F7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82864F80: 809E0054  lwz r4, 0x54(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82864F84: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82864F88: 419A0170  beq cr6, 0x828650f8
	if ctx.cr[6].eq {
	pc = 0x828650F8; continue 'dispatch;
	}
	// 82864F8C: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82864F90: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82864F94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864F98: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82864F9C: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82864FA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82864FA4: 419A00E8  beq cr6, 0x8286508c
	if ctx.cr[6].eq {
	pc = 0x8286508C; continue 'dispatch;
	}
	// 82864FA8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82864FAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82864FB0: 419A0020  beq cr6, 0x82864fd0
	if ctx.cr[6].eq {
	pc = 0x82864FD0; continue 'dispatch;
	}
	// 82864FB4: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 82864FB8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82864FBC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82864FC0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82864FC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82864FC8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864FCC: 480000C8  b 0x82865094
	pc = 0x82865094; continue 'dispatch;
            }
            0x82864FD0 => {
    //   block [0x82864FD0..0x82864FEC)
	// 82864FD0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82864FD4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82864FD8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82864FDC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82864FE0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82864FE4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82864FE8: 40810054  ble 0x8286503c
	if !ctx.cr[0].gt {
	pc = 0x8286503C; continue 'dispatch;
	}
	pc = 0x82864FEC; continue 'dispatch;
            }
            0x82864FEC => {
    //   block [0x82864FEC..0x8286500C)
	// 82864FEC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82864FF0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82864FF4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82864FF8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864FFC: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82865000: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82865004: 41980008  blt cr6, 0x8286500c
	if ctx.cr[6].lt {
	pc = 0x8286500C; continue 'dispatch;
	}
	// 82865008: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x8286500C; continue 'dispatch;
            }
            0x8286500C => {
    //   block [0x8286500C..0x82865028)
	// 8286500C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82865010: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82865014: 419A0014  beq cr6, 0x82865028
	if ctx.cr[6].eq {
	pc = 0x82865028; continue 'dispatch;
	}
	// 82865018: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286501C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82865020: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82865024: 4800000C  b 0x82865030
	pc = 0x82865030; continue 'dispatch;
            }
            0x82865028 => {
    //   block [0x82865028..0x82865030)
	// 82865028: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286502C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82865030; continue 'dispatch;
            }
            0x82865030 => {
    //   block [0x82865030..0x8286503C)
	// 82865030: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865034: 4199FFB8  bgt cr6, 0x82864fec
	if ctx.cr[6].gt {
	pc = 0x82864FEC; continue 'dispatch;
	}
	// 82865038: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8286503C; continue 'dispatch;
            }
            0x8286503C => {
    //   block [0x8286503C..0x82865058)
	// 8286503C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82865040: 419A003C  beq cr6, 0x8286507c
	if ctx.cr[6].eq {
	pc = 0x8286507C; continue 'dispatch;
	}
	// 82865044: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865048: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8286504C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82865050: 41990008  bgt cr6, 0x82865058
	if ctx.cr[6].gt {
	pc = 0x82865058; continue 'dispatch;
	}
	// 82865054: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82865058; continue 'dispatch;
            }
            0x82865058 => {
    //   block [0x82865058..0x8286507C)
	// 82865058: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286505C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865060: 409A001C  bne cr6, 0x8286507c
	if !ctx.cr[6].eq {
	pc = 0x8286507C; continue 'dispatch;
	}
	// 82865064: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82865068: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8286506C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82865070: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82865074: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865078: 4800001C  b 0x82865094
	pc = 0x82865094; continue 'dispatch;
            }
            0x8286507C => {
    //   block [0x8286507C..0x8286508C)
	// 8286507C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82865080: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82865084: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865088: 4800000C  b 0x82865094
	pc = 0x82865094; continue 'dispatch;
            }
            0x8286508C => {
    //   block [0x8286508C..0x82865094)
	// 8286508C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82865090: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x82865094; continue 'dispatch;
            }
            0x82865094 => {
    //   block [0x82865094..0x828650BC)
	// 82865094: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82865098: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286509C: 419A005C  beq cr6, 0x828650f8
	if ctx.cr[6].eq {
	pc = 0x828650F8; continue 'dispatch;
	}
	// 828650A0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828650A4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828650A8: 4BA48F79  bl 0x822ae020
	ctx.lr = 0x828650AC;
	sub_822AE020(ctx, base);
	// 828650AC: 807E0054  lwz r3, 0x54(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 828650B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828650B4: 419A0040  beq cr6, 0x828650f4
	if ctx.cr[6].eq {
	pc = 0x828650F4; continue 'dispatch;
	}
	// 828650B8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x828650BC; continue 'dispatch;
            }
            0x828650BC => {
    //   block [0x828650BC..0x828650F0)
	// 828650BC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828650C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828650C4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828650C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828650CC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828650D0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828650D4: 4082FFE8  bne 0x828650bc
	if !ctx.cr[0].eq {
	pc = 0x828650BC; continue 'dispatch;
	}
	// 828650D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828650DC: 409A0014  bne cr6, 0x828650f0
	if !ctx.cr[6].eq {
	pc = 0x828650F0; continue 'dispatch;
	}
	// 828650E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828650E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828650E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828650EC: 4E800421  bctrl
	ctx.lr = 0x828650F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828650F0 => {
    //   block [0x828650F0..0x828650F4)
	// 828650F0: 93FE0054  stw r31, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	pc = 0x828650F4; continue 'dispatch;
            }
            0x828650F4 => {
    //   block [0x828650F4..0x828650F8)
	// 828650F4: 93FE0054  stw r31, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	pc = 0x828650F8; continue 'dispatch;
            }
            0x828650F8 => {
    //   block [0x828650F8..0x82865114)
	// 828650F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828650FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865100: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865104: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865108: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286510C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82865110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865118 size=232
    let mut pc: u32 = 0x82865118;
    'dispatch: loop {
        match pc {
            0x82865118 => {
    //   block [0x82865118..0x8286514C)
	// 82865118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286511C: 484442ED  bl 0x82ca9408
	ctx.lr = 0x82865120;
	sub_82CA93D0(ctx, base);
	// 82865120: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865124: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865128: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8286512C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82865130: 390BF058  addi r8, r11, -0xfa8
	ctx.r[8].s64 = ctx.r[11].s64 + -4008;
	// 82865134: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 82865138: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 8286513C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82865140: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82865144: 38C77088  addi r6, r7, 0x7088
	ctx.r[6].s64 = ctx.r[7].s64 + 28808;
	// 82865148: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x8286514C; continue 'dispatch;
            }
            0x8286514C => {
    //   block [0x8286514C..0x828651D4)
	// 8286514C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82865150: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865154: 7D403028  lwarx r10, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82865158: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8286515C: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82865160: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865164: 4082FFE8  bne 0x8286514c
	if !ctx.cr[0].eq {
	pc = 0x8286514C; continue 'dispatch;
	}
	// 82865168: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 8286516C: 9BDF000D  stb r30, 0xd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(13 as u32), ctx.r[30].u8 ) };
	// 82865170: 3C80820F  lis r4, -0x7df1
	ctx.r[4].s64 = -2112946176;
	// 82865174: 3C608200  lis r3, -0x7e00
	ctx.r[3].s64 = -2113929216;
	// 82865178: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8286517C: 39242B90  addi r9, r4, 0x2b90
	ctx.r[9].s64 = ctx.r[4].s64 + 11152;
	// 82865180: 81456AB8  lwz r10, 0x6ab8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82865184: 39035A68  addi r8, r3, 0x5a68
	ctx.r[8].s64 = ctx.r[3].s64 + 23144;
	// 82865188: 38EB0E00  addi r7, r11, 0xe00
	ctx.r[7].s64 = ctx.r[11].s64 + 3584;
	// 8286518C: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82865190: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82865194: 38600058  li r3, 0x58
	ctx.r[3].s64 = 88;
	// 82865198: 90FF0010  stw r7, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 8286519C: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828651A0: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 828651A4: 80CA000C  lwz r6, 0xc(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828651A8: 80A60078  lwz r5, 0x78(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(120 as u32) ) } as u64;
	// 828651AC: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828651B0: 83840000  lwz r28, 0(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828651B4: 4B9BA0A5  bl 0x8221f258
	ctx.lr = 0x828651B8;
	sub_8221F258(ctx, base);
	// 828651B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828651BC: 419A0018  beq cr6, 0x828651d4
	if ctx.cr[6].eq {
	pc = 0x828651D4; continue 'dispatch;
	}
	// 828651C0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828651C4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828651C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828651CC: 4BFFEB05  bl 0x82863cd0
	ctx.lr = 0x828651D0;
	sub_82863CD0(ctx, base);
	// 828651D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	pc = 0x828651D4; continue 'dispatch;
            }
            0x828651D4 => {
    //   block [0x828651D4..0x828651F0)
	// 828651D4: 83BF0014  lwz r29, 0x14(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828651D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828651DC: 419A0014  beq cr6, 0x828651f0
	if ctx.cr[6].eq {
	pc = 0x828651F0; continue 'dispatch;
	}
	// 828651E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828651E4: 480000F5  bl 0x828652d8
	ctx.lr = 0x828651E8;
	sub_828652D8(ctx, base);
	// 828651E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828651EC: 4B9B6B4D  bl 0x8221bd38
	ctx.lr = 0x828651F0;
	sub_8221BD38(ctx, base);
	pc = 0x828651F0; continue 'dispatch;
            }
            0x828651F0 => {
    //   block [0x828651F0..0x82865200)
	// 828651F0: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 828651F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828651F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828651FC: 4844425C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865200 size=132
    let mut pc: u32 = 0x82865200;
    'dispatch: loop {
        match pc {
            0x82865200 => {
    //   block [0x82865200..0x82865230)
	// 82865200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865204: 48444209  bl 0x82ca940c
	ctx.lr = 0x82865208;
	sub_82CA93D0(ctx, base);
	// 82865208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286520C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865210: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82865214: 83DF0014  lwz r30, 0x14(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82865218: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8286521C: 419A0014  beq cr6, 0x82865230
	if ctx.cr[6].eq {
	pc = 0x82865230; continue 'dispatch;
	}
	// 82865220: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865224: 480000B5  bl 0x828652d8
	ctx.lr = 0x82865228;
	sub_828652D8(ctx, base);
	// 82865228: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286522C: 4B9B6B0D  bl 0x8221bd38
	ctx.lr = 0x82865230;
	sub_8221BD38(ctx, base);
	pc = 0x82865230; continue 'dispatch;
            }
            0x82865230 => {
    //   block [0x82865230..0x82865244)
	// 82865230: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82865234: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82865238: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 8286523C: 419A0008  beq cr6, 0x82865244
	if ctx.cr[6].eq {
	pc = 0x82865244; continue 'dispatch;
	}
	// 82865240: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	pc = 0x82865244; continue 'dispatch;
            }
            0x82865244 => {
    //   block [0x82865244..0x8286527C)
	// 82865244: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82865248: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 8286524C: 390A2B90  addi r8, r10, 0x2b90
	ctx.r[8].s64 = ctx.r[10].s64 + 11152;
	// 82865250: 38E9F058  addi r7, r9, -0xfa8
	ctx.r[7].s64 = ctx.r[9].s64 + -4008;
	// 82865254: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82865258: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 8286525C: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82865260: 4B9AFB79  bl 0x82214dd8
	ctx.lr = 0x82865264;
	sub_82214DD8(ctx, base);
	// 82865264: 57A607FE  clrlwi r6, r29, 0x1f
	ctx.r[6].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 82865268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286526C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82865270: 419A000C  beq cr6, 0x8286527c
	if ctx.cr[6].eq {
	pc = 0x8286527C; continue 'dispatch;
	}
	// 82865274: 4B9B6AC5  bl 0x8221bd38
	ctx.lr = 0x82865278;
	sub_8221BD38(ctx, base);
	// 82865278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8286527C; continue 'dispatch;
            }
            0x8286527C => {
    //   block [0x8286527C..0x82865284)
	// 8286527C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865280: 484441DC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82865288 size=16
    let mut pc: u32 = 0x82865288;
    'dispatch: loop {
        match pc {
            0x82865288 => {
    //   block [0x82865288..0x82865298)
	// 82865288: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8286528C: 388B0044  addi r4, r11, 0x44
	ctx.r[4].s64 = ctx.r[11].s64 + 68;
	// 82865290: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 82865294: 4B9354C4  b 0x8219a758
	sub_8219A758(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82865298 size=8
    let mut pc: u32 = 0x82865298;
    'dispatch: loop {
        match pc {
            0x82865298 => {
    //   block [0x82865298..0x828652A0)
	// 82865298: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8286529C: 4BFFE87C  b 0x82863b18
	sub_82863B18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828652A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828652A0 size=56
    let mut pc: u32 = 0x828652A0;
    'dispatch: loop {
        match pc {
            0x828652A0 => {
    //   block [0x828652A0..0x828652D8)
	// 828652A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828652A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828652A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828652AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828652B0: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 828652B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828652B8: 388B0040  addi r4, r11, 0x40
	ctx.r[4].s64 = ctx.r[11].s64 + 64;
	// 828652BC: 4B98AF85  bl 0x821f0240
	ctx.lr = 0x828652C0;
	sub_821F0240(ctx, base);
	// 828652C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828652C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828652C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828652CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828652D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828652D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828652D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828652D8 size=236
    let mut pc: u32 = 0x828652D8;
    'dispatch: loop {
        match pc {
            0x828652D8 => {
    //   block [0x828652D8..0x82865300)
	// 828652D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828652DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828652E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828652E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828652E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828652EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828652F0: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 828652F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828652F8: 419A0044  beq cr6, 0x8286533c
	if ctx.cr[6].eq {
	pc = 0x8286533C; continue 'dispatch;
	}
	// 828652FC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82865300; continue 'dispatch;
            }
            0x82865300 => {
    //   block [0x82865300..0x82865334)
	// 82865300: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82865304: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865308: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8286530C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82865310: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82865314: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865318: 4082FFE8  bne 0x82865300
	if !ctx.cr[0].eq {
	pc = 0x82865300; continue 'dispatch;
	}
	// 8286531C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865320: 409A0014  bne cr6, 0x82865334
	if !ctx.cr[6].eq {
	pc = 0x82865334; continue 'dispatch;
	}
	// 82865324: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865328: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286532C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82865330: 4E800421  bctrl
	ctx.lr = 0x82865334;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82865334 => {
    //   block [0x82865334..0x8286533C)
	// 82865334: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82865338: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x8286533C; continue 'dispatch;
            }
            0x8286533C => {
    //   block [0x8286533C..0x828653C4)
	// 8286533C: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 82865340: 4B9527D9  bl 0x821b7b18
	ctx.lr = 0x82865344;
	sub_821B7B18(ctx, base);
	// 82865344: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 82865348: 4B9AFA91  bl 0x82214dd8
	ctx.lr = 0x8286534C;
	sub_82214DD8(ctx, base);
	// 8286534C: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 82865350: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82865354: 4B9AFA85  bl 0x82214dd8
	ctx.lr = 0x82865358;
	sub_82214DD8(ctx, base);
	// 82865358: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286535C: 4B9527BD  bl 0x821b7b18
	ctx.lr = 0x82865360;
	sub_821B7B18(ctx, base);
	// 82865360: 3BDF0024  addi r30, r31, 0x24
	ctx.r[30].s64 = ctx.r[31].s64 + 36;
	// 82865364: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82865368: 4B9AFA71  bl 0x82214dd8
	ctx.lr = 0x8286536C;
	sub_82214DD8(ctx, base);
	// 8286536C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865370: 4B9527A9  bl 0x821b7b18
	ctx.lr = 0x82865374;
	sub_821B7B18(ctx, base);
	// 82865374: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	// 82865378: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 8286537C: 4B9AFA5D  bl 0x82214dd8
	ctx.lr = 0x82865380;
	sub_82214DD8(ctx, base);
	// 82865380: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865384: 4B952795  bl 0x821b7b18
	ctx.lr = 0x82865388;
	sub_821B7B18(ctx, base);
	// 82865388: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 8286538C: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82865390: 4B9AFA49  bl 0x82214dd8
	ctx.lr = 0x82865394;
	sub_82214DD8(ctx, base);
	// 82865394: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865398: 4B952781  bl 0x821b7b18
	ctx.lr = 0x8286539C;
	sub_821B7B18(ctx, base);
	// 8286539C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828653A0: 4B9AFA39  bl 0x82214dd8
	ctx.lr = 0x828653A4;
	sub_82214DD8(ctx, base);
	// 828653A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828653A8: 4B952771  bl 0x821b7b18
	ctx.lr = 0x828653AC;
	sub_821B7B18(ctx, base);
	// 828653AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828653B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828653B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828653B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828653BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828653C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828653C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828653C8 size=156
    let mut pc: u32 = 0x828653C8;
    'dispatch: loop {
        match pc {
            0x828653C8 => {
    //   block [0x828653C8..0x8286545C)
	// 828653C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828653CC: 48444039  bl 0x82ca9404
	ctx.lr = 0x828653D0;
	sub_82CA93D0(ctx, base);
	// 828653D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828653D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828653D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828653DC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828653E0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 828653E4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828653E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828653EC: 419A0070  beq cr6, 0x8286545c
	if ctx.cr[6].eq {
	pc = 0x8286545C; continue 'dispatch;
	}
	// 828653F0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828653F4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828653F8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828653FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82865400: 4B9C3D09  bl 0x82229108
	ctx.lr = 0x82865404;
	sub_82229108(ctx, base);
	// 82865404: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82865408: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286540C: 4B9C2475  bl 0x82227880
	ctx.lr = 0x82865410;
	sub_82227880(ctx, base);
	// 82865410: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82865414: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 82865418: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286541C: 388A5468  addi r4, r10, 0x5468
	ctx.r[4].s64 = ctx.r[10].s64 + 21608;
	// 82865420: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82865424: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82865428: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 8286542C: 4B935655  bl 0x8219aa80
	ctx.lr = 0x82865430;
	sub_8219AA80(ctx, base);
	// 82865430: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82865434: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82865438: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286543C: 4BB68FE5  bl 0x823ce420
	ctx.lr = 0x82865440;
	sub_823CE420(ctx, base);
	// 82865440: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82865444: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82865448: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286544C: 481BF27D  bl 0x82a246c8
	ctx.lr = 0x82865450;
	sub_82A246C8(ctx, base);
	// 82865450: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82865454: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82865458: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x8286545C; continue 'dispatch;
            }
            0x8286545C => {
    //   block [0x8286545C..0x82865464)
	// 8286545C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82865460: 48443FF4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865468 size=84
    let mut pc: u32 = 0x82865468;
    'dispatch: loop {
        match pc {
            0x82865468 => {
    //   block [0x82865468..0x828654BC)
	// 82865468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286546C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865470: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82865474: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865478: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 8286547C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865480: 4B9C2C79  bl 0x822280f8
	ctx.lr = 0x82865484;
	sub_822280F8(ctx, base);
	// 82865484: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865488: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286548C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82865490: 4E800421  bctrl
	ctx.lr = 0x82865494;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82865494: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82865498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828654C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828654C0 size=8
    let mut pc: u32 = 0x828654C0;
    'dispatch: loop {
        match pc {
            0x828654C0 => {
    //   block [0x828654C0..0x828654C8)
	// 828654C0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828654C4: 4BFFFD3C  b 0x82865200
	sub_82865200(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828654C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828654C8 size=244
    let mut pc: u32 = 0x828654C8;
    'dispatch: loop {
        match pc {
            0x828654C8 => {
    //   block [0x828654C8..0x8286550C)
	// 828654C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828654CC: 48443F3D  bl 0x82ca9408
	ctx.lr = 0x828654D0;
	sub_82CA93D0(ctx, base);
	// 828654D0: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 828654D4: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828654D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828654DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828654E0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828654E4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828654E8: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 828654EC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828654F0: 390BF058  addi r8, r11, -0xfa8
	ctx.r[8].s64 = ctx.r[11].s64 + -4008;
	// 828654F4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828654F8: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 828654FC: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82865500: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82865504: 38C77088  addi r6, r7, 0x7088
	ctx.r[6].s64 = ctx.r[7].s64 + 28808;
	// 82865508: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x8286550C; continue 'dispatch;
            }
            0x8286550C => {
    //   block [0x8286550C..0x8286559C)
	// 8286550C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82865510: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865514: 7D403028  lwarx r10, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82865518: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8286551C: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82865520: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865524: 4082FFE8  bne 0x8286550c
	if !ctx.cr[0].eq {
	pc = 0x8286550C; continue 'dispatch;
	}
	// 82865528: 3C60820B  lis r3, -0x7df5
	ctx.r[3].s64 = -2113208320;
	// 8286552C: 9BDF000D  stb r30, 0xd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(13 as u32), ctx.r[30].u8 ) };
	// 82865530: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82865534: 39632298  addi r11, r3, 0x2298
	ctx.r[11].s64 = ctx.r[3].s64 + 8856;
	// 82865538: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 8286553C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82865540: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82865544: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82865548: 4B98ACF9  bl 0x821f0240
	ctx.lr = 0x8286554C;
	sub_821F0240(ctx, base);
	// 8286554C: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82865550: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82865554: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82865558: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 8286555C: 3BBF0044  addi r29, r31, 0x44
	ctx.r[29].s64 = ctx.r[31].s64 + 68;
	// 82865560: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82865564: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82865568: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 8286556C: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82865570: D3DF0040  stfs f30, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82865574: 9B9F003C  stb r28, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[28].u8 ) };
	// 82865578: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 8286557C: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82865580: 4B9B9CD9  bl 0x8221f258
	ctx.lr = 0x82865584;
	sub_8221F258(ctx, base);
	// 82865584: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82865588: 419A0014  beq cr6, 0x8286559c
	if ctx.cr[6].eq {
	pc = 0x8286559C; continue 'dispatch;
	}
	// 8286558C: D3E30000  stfs f31, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82865590: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82865594: D3E30004  stfs f31, 4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82865598: 48000008  b 0x828655a0
	pc = 0x828655A0; continue 'dispatch;
            }
            0x8286559C => {
    //   block [0x8286559C..0x828655A0)
	// 8286559C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x828655A0; continue 'dispatch;
            }
            0x828655A0 => {
    //   block [0x828655A0..0x828655BC)
	// 828655A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828655A4: 4BEACB65  bl 0x82712108
	ctx.lr = 0x828655A8;
	sub_82712108(ctx, base);
	// 828655A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828655AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828655B0: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828655B4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828655B8: 48443EA0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828655C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828655C0 size=2108
    let mut pc: u32 = 0x828655C0;
    'dispatch: loop {
        match pc {
            0x828655C0 => {
    //   block [0x828655C0..0x82865624)
	// 828655C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828655C4: 48443E41  bl 0x82ca9404
	ctx.lr = 0x828655C8;
	sub_82CA93D0(ctx, base);
	// 828655C8: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 828655CC: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828655D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828655D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828655D8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828655DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828655E0: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828655E4: 917B0034  stw r11, 0x34(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 828655E8: 81460024  lwz r10, 0x24(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 828655EC: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 828655F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828655F4: 419A00F4  beq cr6, 0x828656e8
	if ctx.cr[6].eq {
	pc = 0x828656E8; continue 'dispatch;
	}
	// 828655F8: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828655FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865600: 419A0024  beq cr6, 0x82865624
	if ctx.cr[6].eq {
	pc = 0x82865624; continue 'dispatch;
	}
	// 82865604: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82865608: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286560C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82865610: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82865614: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865618: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8286561C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82865620: 480000D0  b 0x828656f0
	pc = 0x828656F0; continue 'dispatch;
            }
            0x82865624 => {
    //   block [0x82865624..0x82865640)
	// 82865624: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82865628: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286562C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82865630: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82865634: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82865638: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286563C: 40810054  ble 0x82865690
	if !ctx.cr[0].gt {
	pc = 0x82865690; continue 'dispatch;
	}
	pc = 0x82865640; continue 'dispatch;
            }
            0x82865640 => {
    //   block [0x82865640..0x82865660)
	// 82865640: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82865644: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82865648: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8286564C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865650: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 82865654: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82865658: 41980008  blt cr6, 0x82865660
	if ctx.cr[6].lt {
	pc = 0x82865660; continue 'dispatch;
	}
	// 8286565C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x82865660; continue 'dispatch;
            }
            0x82865660 => {
    //   block [0x82865660..0x8286567C)
	// 82865660: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82865664: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82865668: 419A0014  beq cr6, 0x8286567c
	if ctx.cr[6].eq {
	pc = 0x8286567C; continue 'dispatch;
	}
	// 8286566C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82865670: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82865674: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82865678: 4800000C  b 0x82865684
	pc = 0x82865684; continue 'dispatch;
            }
            0x8286567C => {
    //   block [0x8286567C..0x82865684)
	// 8286567C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82865680: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82865684; continue 'dispatch;
            }
            0x82865684 => {
    //   block [0x82865684..0x82865690)
	// 82865684: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865688: 4199FFB8  bgt cr6, 0x82865640
	if ctx.cr[6].gt {
	pc = 0x82865640; continue 'dispatch;
	}
	// 8286568C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x82865690; continue 'dispatch;
            }
            0x82865690 => {
    //   block [0x82865690..0x828656AC)
	// 82865690: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82865694: 419A0040  beq cr6, 0x828656d4
	if ctx.cr[6].eq {
	pc = 0x828656D4; continue 'dispatch;
	}
	// 82865698: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286569C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828656A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828656A4: 41990008  bgt cr6, 0x828656ac
	if ctx.cr[6].gt {
	pc = 0x828656AC; continue 'dispatch;
	}
	// 828656A8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828656AC; continue 'dispatch;
            }
            0x828656AC => {
    //   block [0x828656AC..0x828656D4)
	// 828656AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828656B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828656B4: 409A0020  bne cr6, 0x828656d4
	if !ctx.cr[6].eq {
	pc = 0x828656D4; continue 'dispatch;
	}
	// 828656B8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828656BC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828656C0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828656C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828656C8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828656CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828656D0: 48000020  b 0x828656f0
	pc = 0x828656F0; continue 'dispatch;
            }
            0x828656D4 => {
    //   block [0x828656D4..0x828656E8)
	// 828656D4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828656D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828656DC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828656E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828656E4: 4800000C  b 0x828656f0
	pc = 0x828656F0; continue 'dispatch;
            }
            0x828656E8 => {
    //   block [0x828656E8..0x828656F0)
	// 828656E8: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828656EC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828656F0; continue 'dispatch;
            }
            0x828656F0 => {
    //   block [0x828656F0..0x82865738)
	// 828656F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828656F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828656F8: 419A06F4  beq cr6, 0x82865dec
	if ctx.cr[6].eq {
	pc = 0x82865DEC; continue 'dispatch;
	}
	// 828656FC: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82865700: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 82865704: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82865708: 419A00F4  beq cr6, 0x828657fc
	if ctx.cr[6].eq {
	pc = 0x828657FC; continue 'dispatch;
	}
	// 8286570C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82865710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865714: 419A0024  beq cr6, 0x82865738
	if ctx.cr[6].eq {
	pc = 0x82865738; continue 'dispatch;
	}
	// 82865718: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 8286571C: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82865720: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82865724: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82865728: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286572C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82865730: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82865734: 480000D0  b 0x82865804
	pc = 0x82865804; continue 'dispatch;
            }
            0x82865738 => {
    //   block [0x82865738..0x82865754)
	// 82865738: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286573C: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82865740: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82865744: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82865748: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 8286574C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865750: 40810054  ble 0x828657a4
	if !ctx.cr[0].gt {
	pc = 0x828657A4; continue 'dispatch;
	}
	pc = 0x82865754; continue 'dispatch;
            }
            0x82865754 => {
    //   block [0x82865754..0x82865774)
	// 82865754: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82865758: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286575C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82865760: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865764: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82865768: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286576C: 41980008  blt cr6, 0x82865774
	if ctx.cr[6].lt {
	pc = 0x82865774; continue 'dispatch;
	}
	// 82865770: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x82865774; continue 'dispatch;
            }
            0x82865774 => {
    //   block [0x82865774..0x82865790)
	// 82865774: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82865778: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286577C: 419A0014  beq cr6, 0x82865790
	if ctx.cr[6].eq {
	pc = 0x82865790; continue 'dispatch;
	}
	// 82865780: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82865784: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82865788: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286578C: 4800000C  b 0x82865798
	pc = 0x82865798; continue 'dispatch;
            }
            0x82865790 => {
    //   block [0x82865790..0x82865798)
	// 82865790: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82865794: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82865798; continue 'dispatch;
            }
            0x82865798 => {
    //   block [0x82865798..0x828657A4)
	// 82865798: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286579C: 4199FFB8  bgt cr6, 0x82865754
	if ctx.cr[6].gt {
	pc = 0x82865754; continue 'dispatch;
	}
	// 828657A0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x828657A4; continue 'dispatch;
            }
            0x828657A4 => {
    //   block [0x828657A4..0x828657C0)
	// 828657A4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828657A8: 419A0040  beq cr6, 0x828657e8
	if ctx.cr[6].eq {
	pc = 0x828657E8; continue 'dispatch;
	}
	// 828657AC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828657B0: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 828657B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828657B8: 41990008  bgt cr6, 0x828657c0
	if ctx.cr[6].gt {
	pc = 0x828657C0; continue 'dispatch;
	}
	// 828657BC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828657C0; continue 'dispatch;
            }
            0x828657C0 => {
    //   block [0x828657C0..0x828657E8)
	// 828657C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828657C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828657C8: 409A0020  bne cr6, 0x828657e8
	if !ctx.cr[6].eq {
	pc = 0x828657E8; continue 'dispatch;
	}
	// 828657CC: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828657D0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828657D4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828657D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828657DC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828657E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828657E4: 48000020  b 0x82865804
	pc = 0x82865804; continue 'dispatch;
            }
            0x828657E8 => {
    //   block [0x828657E8..0x828657FC)
	// 828657E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828657EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828657F0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828657F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828657F8: 4800000C  b 0x82865804
	pc = 0x82865804; continue 'dispatch;
            }
            0x828657FC => {
    //   block [0x828657FC..0x82865804)
	// 828657FC: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82865800: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82865804; continue 'dispatch;
            }
            0x82865804 => {
    //   block [0x82865804..0x8286588C)
	// 82865804: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82865808: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286580C: 419A05E0  beq cr6, 0x82865dec
	if ctx.cr[6].eq {
	pc = 0x82865DEC; continue 'dispatch;
	}
	// 82865810: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82865814: 3BFB0018  addi r31, r27, 0x18
	ctx.r[31].s64 = ctx.r[27].s64 + 24;
	// 82865818: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8286581C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865820: 4BA35999  bl 0x8229b1b8
	ctx.lr = 0x82865824;
	sub_8229B1B8(ctx, base);
	// 82865824: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82865828: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8286582C: 390A92D4  addi r8, r10, -0x6d2c
	ctx.r[8].s64 = ctx.r[10].s64 + -27948;
	// 82865830: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82865834: C3CA92D4  lfs f30, -0x6d2c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82865838: C3E801B0  lfs f31, 0x1b0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(432 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8286583C: 419A0074  beq cr6, 0x828658b0
	if ctx.cr[6].eq {
	pc = 0x828658B0; continue 'dispatch;
	}
	// 82865840: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82865844: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82865848: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8286584C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82865850: 4BBBBF01  bl 0x82421750
	ctx.lr = 0x82865854;
	sub_82421750(ctx, base);
	// 82865854: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82865858: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286585C: 419A0054  beq cr6, 0x828658b0
	if ctx.cr[6].eq {
	pc = 0x828658B0; continue 'dispatch;
	}
	// 82865860: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82865864: 4B9B99F5  bl 0x8221f258
	ctx.lr = 0x82865868;
	sub_8221F258(ctx, base);
	// 82865868: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286586C: 419A0020  beq cr6, 0x8286588c
	if ctx.cr[6].eq {
	pc = 0x8286588C; continue 'dispatch;
	}
	// 82865870: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82865874: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82865878: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8286587C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82865880: 4BA1E3B1  bl 0x82283c30
	ctx.lr = 0x82865884;
	sub_82283C30(ctx, base);
	// 82865884: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82865888: 48000008  b 0x82865890
	pc = 0x82865890; continue 'dispatch;
            }
            0x8286588C => {
    //   block [0x8286588C..0x82865890)
	// 8286588C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x82865890; continue 'dispatch;
            }
            0x82865890 => {
    //   block [0x82865890..0x828658B0)
	// 82865890: 387B002C  addi r3, r27, 0x2c
	ctx.r[3].s64 = ctx.r[27].s64 + 44;
	// 82865894: 4BA0D7C5  bl 0x82273058
	ctx.lr = 0x82865898;
	sub_82273058(ctx, base);
	// 82865898: 807B002C  lwz r3, 0x2c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 8286589C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828658A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828658A4: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828658A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828658AC: 4E800421  bctrl
	ctx.lr = 0x828658B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828658B0 => {
    //   block [0x828658B0..0x8286591C)
	// 828658B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828658B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828658B8: 388B1888  addi r4, r11, 0x1888
	ctx.r[4].s64 = ctx.r[11].s64 + 6280;
	// 828658BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828658C0: 4B9C7611  bl 0x8222ced0
	ctx.lr = 0x828658C4;
	sub_8222CED0(ctx, base);
	// 828658C4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828658C8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828658CC: 388AFA7C  addi r4, r10, -0x584
	ctx.r[4].s64 = ctx.r[10].s64 + -1412;
	// 828658D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828658D4: 4B9C75FD  bl 0x8222ced0
	ctx.lr = 0x828658D8;
	sub_8222CED0(ctx, base);
	// 828658D8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828658DC: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828658E0: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828658E4: 552827FE  rlwinm r8, r9, 4, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0FFFFFFFu64;
	// 828658E8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828658EC: 419A00F4  beq cr6, 0x828659e0
	if ctx.cr[6].eq {
	pc = 0x828659E0; continue 'dispatch;
	}
	// 828658F0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828658F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828658F8: 419A0024  beq cr6, 0x8286591c
	if ctx.cr[6].eq {
	pc = 0x8286591C; continue 'dispatch;
	}
	// 828658FC: 894A001C  lbz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82865900: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82865904: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82865908: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286590C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865910: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82865914: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82865918: 480000CC  b 0x828659e4
	pc = 0x828659E4; continue 'dispatch;
            }
            0x8286591C => {
    //   block [0x8286591C..0x82865938)
	// 8286591C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82865920: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82865924: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82865928: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8286592C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82865930: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865934: 40810054  ble 0x82865988
	if !ctx.cr[0].gt {
	pc = 0x82865988; continue 'dispatch;
	}
	pc = 0x82865938; continue 'dispatch;
            }
            0x82865938 => {
    //   block [0x82865938..0x82865958)
	// 82865938: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286593C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82865940: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82865944: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865948: 2F07001C  cmpwi cr6, r7, 0x1c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 28, &mut ctx.xer);
	// 8286594C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82865950: 41980008  blt cr6, 0x82865958
	if ctx.cr[6].lt {
	pc = 0x82865958; continue 'dispatch;
	}
	// 82865954: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x82865958; continue 'dispatch;
            }
            0x82865958 => {
    //   block [0x82865958..0x82865974)
	// 82865958: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286595C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82865960: 419A0014  beq cr6, 0x82865974
	if ctx.cr[6].eq {
	pc = 0x82865974; continue 'dispatch;
	}
	// 82865964: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82865968: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286596C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82865970: 4800000C  b 0x8286597c
	pc = 0x8286597C; continue 'dispatch;
            }
            0x82865974 => {
    //   block [0x82865974..0x8286597C)
	// 82865974: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82865978: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286597C; continue 'dispatch;
            }
            0x8286597C => {
    //   block [0x8286597C..0x82865988)
	// 8286597C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865980: 4199FFB8  bgt cr6, 0x82865938
	if ctx.cr[6].gt {
	pc = 0x82865938; continue 'dispatch;
	}
	// 82865984: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82865988; continue 'dispatch;
            }
            0x82865988 => {
    //   block [0x82865988..0x828659A4)
	// 82865988: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8286598C: 419A0040  beq cr6, 0x828659cc
	if ctx.cr[6].eq {
	pc = 0x828659CC; continue 'dispatch;
	}
	// 82865990: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865994: 2F0B001C  cmpwi cr6, r11, 0x1c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 28, &mut ctx.xer);
	// 82865998: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286599C: 41990008  bgt cr6, 0x828659a4
	if ctx.cr[6].gt {
	pc = 0x828659A4; continue 'dispatch;
	}
	// 828659A0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828659A4; continue 'dispatch;
            }
            0x828659A4 => {
    //   block [0x828659A4..0x828659CC)
	// 828659A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828659A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828659AC: 409A0020  bne cr6, 0x828659cc
	if !ctx.cr[6].eq {
	pc = 0x828659CC; continue 'dispatch;
	}
	// 828659B0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828659B4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828659B8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828659BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828659C0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828659C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828659C8: 4800001C  b 0x828659e4
	pc = 0x828659E4; continue 'dispatch;
            }
            0x828659CC => {
    //   block [0x828659CC..0x828659E0)
	// 828659CC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828659D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828659D4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828659D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828659DC: 48000008  b 0x828659e4
	pc = 0x828659E4; continue 'dispatch;
            }
            0x828659E0 => {
    //   block [0x828659E0..0x828659E4)
	// 828659E0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828659E4; continue 'dispatch;
            }
            0x828659E4 => {
    //   block [0x828659E4..0x82865A44)
	// 828659E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828659E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828659EC: 419A01D4  beq cr6, 0x82865bc0
	if ctx.cr[6].eq {
	pc = 0x82865BC0; continue 'dispatch;
	}
	// 828659F0: 816A0054  lwz r11, 0x54(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(84 as u32) ) } as u64;
	// 828659F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828659F8: 409A01C8  bne cr6, 0x82865bc0
	if !ctx.cr[6].eq {
	pc = 0x82865BC0; continue 'dispatch;
	}
	// 828659FC: 816A0064  lwz r11, 0x64(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 82865A00: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82865A04: 419A01BC  beq cr6, 0x82865bc0
	if ctx.cr[6].eq {
	pc = 0x82865BC0; continue 'dispatch;
	}
	// 82865A08: 816A006C  lwz r11, 0x6c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(108 as u32) ) } as u64;
	// 82865A0C: 386A0068  addi r3, r10, 0x68
	ctx.r[3].s64 = ctx.r[10].s64 + 104;
	// 82865A10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865A14: 419A0084  beq cr6, 0x82865a98
	if ctx.cr[6].eq {
	pc = 0x82865A98; continue 'dispatch;
	}
	// 82865A18: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865A1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82865A20: 419A0074  beq cr6, 0x82865a94
	if ctx.cr[6].eq {
	pc = 0x82865A94; continue 'dispatch;
	}
	// 82865A24: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82865A28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865A2C: 419A0018  beq cr6, 0x82865a44
	if ctx.cr[6].eq {
	pc = 0x82865A44; continue 'dispatch;
	}
	// 82865A30: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82865A34: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82865A38: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82865A3C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82865A40: 409A0008  bne cr6, 0x82865a48
	if !ctx.cr[6].eq {
	pc = 0x82865A48; continue 'dispatch;
	}
	pc = 0x82865A44; continue 'dispatch;
            }
            0x82865A44 => {
    //   block [0x82865A44..0x82865A48)
	// 82865A44: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x82865A48; continue 'dispatch;
            }
            0x82865A48 => {
    //   block [0x82865A48..0x82865A94)
	// 82865A48: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82865A4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82865A50: 419A0170  beq cr6, 0x82865bc0
	if ctx.cr[6].eq {
	pc = 0x82865BC0; continue 'dispatch;
	}
	// 82865A54: 812B0038  lwz r9, 0x38(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82865A58: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82865A5C: 55286FFE  rlwinm r8, r9, 0xd, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0007FFFFu64;
	// 82865A60: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82865A64: 419A0100  beq cr6, 0x82865b64
	if ctx.cr[6].eq {
	pc = 0x82865B64; continue 'dispatch;
	}
	// 82865A68: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82865A6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82865A70: 419A0030  beq cr6, 0x82865aa0
	if ctx.cr[6].eq {
	pc = 0x82865AA0; continue 'dispatch;
	}
	// 82865A74: 894A00B3  lbz r10, 0xb3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(179 as u32) ) } as u64;
	// 82865A78: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82865A7C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82865A80: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82865A84: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865A88: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82865A8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82865A90: 480000D8  b 0x82865b68
	pc = 0x82865B68; continue 'dispatch;
            }
            0x82865A94 => {
    //   block [0x82865A94..0x82865A98)
	// 82865A94: 4B92E3A5  bl 0x82193e38
	ctx.lr = 0x82865A98;
	sub_82193E38(ctx, base);
	pc = 0x82865A98; continue 'dispatch;
            }
            0x82865A98 => {
    //   block [0x82865A98..0x82865AA0)
	// 82865A98: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82865A9C: 4BFFFFA8  b 0x82865a44
	pc = 0x82865A44; continue 'dispatch;
            }
            0x82865AA0 => {
    //   block [0x82865AA0..0x82865ABC)
	// 82865AA0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82865AA4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82865AA8: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82865AAC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82865AB0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82865AB4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865AB8: 40810054  ble 0x82865b0c
	if !ctx.cr[0].gt {
	pc = 0x82865B0C; continue 'dispatch;
	}
	pc = 0x82865ABC; continue 'dispatch;
            }
            0x82865ABC => {
    //   block [0x82865ABC..0x82865ADC)
	// 82865ABC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82865AC0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82865AC4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82865AC8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865ACC: 2F0700B3  cmpwi cr6, r7, 0xb3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 179, &mut ctx.xer);
	// 82865AD0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82865AD4: 41980008  blt cr6, 0x82865adc
	if ctx.cr[6].lt {
	pc = 0x82865ADC; continue 'dispatch;
	}
	// 82865AD8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x82865ADC; continue 'dispatch;
            }
            0x82865ADC => {
    //   block [0x82865ADC..0x82865AF8)
	// 82865ADC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82865AE0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82865AE4: 419A0014  beq cr6, 0x82865af8
	if ctx.cr[6].eq {
	pc = 0x82865AF8; continue 'dispatch;
	}
	// 82865AE8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82865AEC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82865AF0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82865AF4: 4800000C  b 0x82865b00
	pc = 0x82865B00; continue 'dispatch;
            }
            0x82865AF8 => {
    //   block [0x82865AF8..0x82865B00)
	// 82865AF8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82865AFC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82865B00; continue 'dispatch;
            }
            0x82865B00 => {
    //   block [0x82865B00..0x82865B0C)
	// 82865B00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865B04: 4199FFB8  bgt cr6, 0x82865abc
	if ctx.cr[6].gt {
	pc = 0x82865ABC; continue 'dispatch;
	}
	// 82865B08: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82865B0C; continue 'dispatch;
            }
            0x82865B0C => {
    //   block [0x82865B0C..0x82865B28)
	// 82865B0C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82865B10: 419A0040  beq cr6, 0x82865b50
	if ctx.cr[6].eq {
	pc = 0x82865B50; continue 'dispatch;
	}
	// 82865B14: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865B18: 2F0B00B3  cmpwi cr6, r11, 0xb3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 179, &mut ctx.xer);
	// 82865B1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82865B20: 41990008  bgt cr6, 0x82865b28
	if ctx.cr[6].gt {
	pc = 0x82865B28; continue 'dispatch;
	}
	// 82865B24: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82865B28; continue 'dispatch;
            }
            0x82865B28 => {
    //   block [0x82865B28..0x82865B50)
	// 82865B28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82865B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865B30: 409A0020  bne cr6, 0x82865b50
	if !ctx.cr[6].eq {
	pc = 0x82865B50; continue 'dispatch;
	}
	// 82865B34: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82865B38: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82865B3C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82865B40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865B44: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82865B48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82865B4C: 4800001C  b 0x82865b68
	pc = 0x82865B68; continue 'dispatch;
            }
            0x82865B50 => {
    //   block [0x82865B50..0x82865B64)
	// 82865B50: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82865B54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865B58: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82865B5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82865B60: 48000008  b 0x82865b68
	pc = 0x82865B68; continue 'dispatch;
            }
            0x82865B64 => {
    //   block [0x82865B64..0x82865B68)
	// 82865B64: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82865B68; continue 'dispatch;
            }
            0x82865B68 => {
    //   block [0x82865B68..0x82865B8C)
	// 82865B68: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82865B6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865B70: 419A0050  beq cr6, 0x82865bc0
	if ctx.cr[6].eq {
	pc = 0x82865BC0; continue 'dispatch;
	}
	// 82865B74: 83EA000C  lwz r31, 0xc(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82865B78: 2F1F0003  cmpwi cr6, r31, 3
	ctx.cr[6].compare_i32(ctx.r[31].s32, 3, &mut ctx.xer);
	// 82865B7C: 409A0010  bne cr6, 0x82865b8c
	if !ctx.cr[6].eq {
	pc = 0x82865B8C; continue 'dispatch;
	}
	// 82865B80: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82865B84: 388BFA88  addi r4, r11, -0x578
	ctx.r[4].s64 = ctx.r[11].s64 + -1400;
	// 82865B88: 4800000C  b 0x82865b94
	pc = 0x82865B94; continue 'dispatch;
            }
            0x82865B8C => {
    //   block [0x82865B8C..0x82865B94)
	// 82865B8C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82865B90: 388BFA9C  addi r4, r11, -0x564
	ctx.r[4].s64 = ctx.r[11].s64 + -1380;
	pc = 0x82865B94; continue 'dispatch;
            }
            0x82865B94 => {
    //   block [0x82865B94..0x82865BB0)
	// 82865B94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82865B98: 4BA0F8A1  bl 0x82275438
	ctx.lr = 0x82865B9C;
	sub_82275438(ctx, base);
	// 82865B9C: 2F1F0003  cmpwi cr6, r31, 3
	ctx.cr[6].compare_i32(ctx.r[31].s32, 3, &mut ctx.xer);
	// 82865BA0: 409A0010  bne cr6, 0x82865bb0
	if !ctx.cr[6].eq {
	pc = 0x82865BB0; continue 'dispatch;
	}
	// 82865BA4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82865BA8: 388BFAB4  addi r4, r11, -0x54c
	ctx.r[4].s64 = ctx.r[11].s64 + -1356;
	// 82865BAC: 4800000C  b 0x82865bb8
	pc = 0x82865BB8; continue 'dispatch;
            }
            0x82865BB0 => {
    //   block [0x82865BB0..0x82865BB8)
	// 82865BB0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82865BB4: 388BFAC8  addi r4, r11, -0x538
	ctx.r[4].s64 = ctx.r[11].s64 + -1336;
	pc = 0x82865BB8; continue 'dispatch;
            }
            0x82865BB8 => {
    //   block [0x82865BB8..0x82865BC0)
	// 82865BB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82865BBC: 4BA0F87D  bl 0x82275438
	ctx.lr = 0x82865BC0;
	sub_82275438(ctx, base);
	pc = 0x82865BC0; continue 'dispatch;
            }
            0x82865BC0 => {
    //   block [0x82865BC0..0x82865C0C)
	// 82865BC0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82865BC4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82865BC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82865BCC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82865BD0: 4BBBBB81  bl 0x82421750
	ctx.lr = 0x82865BD4;
	sub_82421750(ctx, base);
	// 82865BD4: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82865BD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82865BDC: 419A0054  beq cr6, 0x82865c30
	if ctx.cr[6].eq {
	pc = 0x82865C30; continue 'dispatch;
	}
	// 82865BE0: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82865BE4: 4B9B9675  bl 0x8221f258
	ctx.lr = 0x82865BE8;
	sub_8221F258(ctx, base);
	// 82865BE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82865BEC: 419A0020  beq cr6, 0x82865c0c
	if ctx.cr[6].eq {
	pc = 0x82865C0C; continue 'dispatch;
	}
	// 82865BF0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82865BF4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82865BF8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82865BFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82865C00: 4BA1E031  bl 0x82283c30
	ctx.lr = 0x82865C04;
	sub_82283C30(ctx, base);
	// 82865C04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82865C08: 48000008  b 0x82865c10
	pc = 0x82865C10; continue 'dispatch;
            }
            0x82865C0C => {
    //   block [0x82865C0C..0x82865C10)
	// 82865C0C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x82865C10; continue 'dispatch;
            }
            0x82865C10 => {
    //   block [0x82865C10..0x82865C30)
	// 82865C10: 387B001C  addi r3, r27, 0x1c
	ctx.r[3].s64 = ctx.r[27].s64 + 28;
	// 82865C14: 4BA0D445  bl 0x82273058
	ctx.lr = 0x82865C18;
	sub_82273058(ctx, base);
	// 82865C18: 807B001C  lwz r3, 0x1c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 82865C1C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82865C20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865C24: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82865C28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82865C2C: 4E800421  bctrl
	ctx.lr = 0x82865C30;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82865C30 => {
    //   block [0x82865C30..0x82865C78)
	// 82865C30: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82865C34: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82865C38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82865C3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82865C40: 4BBBBB11  bl 0x82421750
	ctx.lr = 0x82865C44;
	sub_82421750(ctx, base);
	// 82865C44: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82865C48: 419A0054  beq cr6, 0x82865c9c
	if ctx.cr[6].eq {
	pc = 0x82865C9C; continue 'dispatch;
	}
	// 82865C4C: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82865C50: 4B9B9609  bl 0x8221f258
	ctx.lr = 0x82865C54;
	sub_8221F258(ctx, base);
	// 82865C54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82865C58: 419A0020  beq cr6, 0x82865c78
	if ctx.cr[6].eq {
	pc = 0x82865C78; continue 'dispatch;
	}
	// 82865C5C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82865C60: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82865C64: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82865C68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82865C6C: 4BA1DFC5  bl 0x82283c30
	ctx.lr = 0x82865C70;
	sub_82283C30(ctx, base);
	// 82865C70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82865C74: 48000008  b 0x82865c7c
	pc = 0x82865C7C; continue 'dispatch;
            }
            0x82865C78 => {
    //   block [0x82865C78..0x82865C7C)
	// 82865C78: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x82865C7C; continue 'dispatch;
            }
            0x82865C7C => {
    //   block [0x82865C7C..0x82865C9C)
	// 82865C7C: 387B0024  addi r3, r27, 0x24
	ctx.r[3].s64 = ctx.r[27].s64 + 36;
	// 82865C80: 4BA0D3D9  bl 0x82273058
	ctx.lr = 0x82865C84;
	sub_82273058(ctx, base);
	// 82865C84: 807B0024  lwz r3, 0x24(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 82865C88: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82865C8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865C90: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82865C94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82865C98: 4E800421  bctrl
	ctx.lr = 0x82865C9C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82865C9C => {
    //   block [0x82865C9C..0x82865CB4)
	// 82865C9C: 815B002C  lwz r10, 0x2c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 82865CA0: 397B002C  addi r11, r27, 0x2c
	ctx.r[11].s64 = ctx.r[27].s64 + 44;
	// 82865CA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82865CA8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82865CAC: 409A0008  bne cr6, 0x82865cb4
	if !ctx.cr[6].eq {
	pc = 0x82865CB4; continue 'dispatch;
	}
	// 82865CB0: 3BFB001C  addi r31, r27, 0x1c
	ctx.r[31].s64 = ctx.r[27].s64 + 28;
	pc = 0x82865CB4; continue 'dispatch;
            }
            0x82865CB4 => {
    //   block [0x82865CB4..0x82865CE8)
	// 82865CB4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82865CB8: C1BB0040  lfs f13, 0x40(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82865CBC: C00B9A80  lfs f0, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82865CC0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82865CC4: 40990024  ble cr6, 0x82865ce8
	if !ctx.cr[6].gt {
	pc = 0x82865CE8; continue 'dispatch;
	}
	// 82865CC8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82865CCC: 4B9B958D  bl 0x8221f258
	ctx.lr = 0x82865CD0;
	sub_8221F258(ctx, base);
	// 82865CD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82865CD4: 419A0014  beq cr6, 0x82865ce8
	if ctx.cr[6].eq {
	pc = 0x82865CE8; continue 'dispatch;
	}
	// 82865CD8: C03B0040  lfs f1, 0x40(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82865CDC: 4BA25E65  bl 0x8228bb40
	ctx.lr = 0x82865CE0;
	sub_8228BB40(ctx, base);
	// 82865CE0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82865CE4: 48000008  b 0x82865cec
	pc = 0x82865CEC; continue 'dispatch;
            }
            0x82865CE8 => {
    //   block [0x82865CE8..0x82865CEC)
	// 82865CE8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x82865CEC; continue 'dispatch;
            }
            0x82865CEC => {
    //   block [0x82865CEC..0x82865D24)
	// 82865CEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82865CF0: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865CF4: 38C00040  li r6, 0x40
	ctx.r[6].s64 = 64;
	// 82865CF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82865CFC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82865D00: 4B968441  bl 0x821ce140
	ctx.lr = 0x82865D04;
	sub_821CE140(ctx, base);
	// 82865D04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865D08: 807B0038  lwz r3, 0x38(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 82865D0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865D10: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82865D14: 419A0078  beq cr6, 0x82865d8c
	if ctx.cr[6].eq {
	pc = 0x82865D8C; continue 'dispatch;
	}
	// 82865D18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82865D1C: 419A0040  beq cr6, 0x82865d5c
	if ctx.cr[6].eq {
	pc = 0x82865D5C; continue 'dispatch;
	}
	// 82865D20: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82865D24; continue 'dispatch;
            }
            0x82865D24 => {
    //   block [0x82865D24..0x82865D58)
	// 82865D24: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82865D28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865D2C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82865D30: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82865D34: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82865D38: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865D3C: 4082FFE8  bne 0x82865d24
	if !ctx.cr[0].eq {
	pc = 0x82865D24; continue 'dispatch;
	}
	// 82865D40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865D44: 409A0014  bne cr6, 0x82865d58
	if !ctx.cr[6].eq {
	pc = 0x82865D58; continue 'dispatch;
	}
	// 82865D48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865D4C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865D50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82865D54: 4E800421  bctrl
	ctx.lr = 0x82865D58;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82865D58 => {
    //   block [0x82865D58..0x82865D5C)
	// 82865D58: 939B0038  stw r28, 0x38(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(56 as u32), ctx.r[28].u32 ) };
	pc = 0x82865D5C; continue 'dispatch;
            }
            0x82865D5C => {
    //   block [0x82865D5C..0x82865D70)
	// 82865D5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865D64: 917B0038  stw r11, 0x38(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82865D68: 419A0024  beq cr6, 0x82865d8c
	if ctx.cr[6].eq {
	pc = 0x82865D8C; continue 'dispatch;
	}
	// 82865D6C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82865D70; continue 'dispatch;
            }
            0x82865D70 => {
    //   block [0x82865D70..0x82865D8C)
	// 82865D70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82865D74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865D78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82865D7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82865D80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82865D84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865D88: 4082FFE8  bne 0x82865d70
	if !ctx.cr[0].eq {
	pc = 0x82865D70; continue 'dispatch;
	}
	pc = 0x82865D8C; continue 'dispatch;
            }
            0x82865D8C => {
    //   block [0x82865D8C..0x82865DA0)
	// 82865D8C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82865D90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865D94: 419A0048  beq cr6, 0x82865ddc
	if ctx.cr[6].eq {
	pc = 0x82865DDC; continue 'dispatch;
	}
	// 82865D98: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82865D9C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82865DA0; continue 'dispatch;
            }
            0x82865DA0 => {
    //   block [0x82865DA0..0x82865DD8)
	// 82865DA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82865DA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865DA8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82865DAC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82865DB0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82865DB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865DB8: 4082FFE8  bne 0x82865da0
	if !ctx.cr[0].eq {
	pc = 0x82865DA0; continue 'dispatch;
	}
	// 82865DBC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82865DC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865DC4: 409A0014  bne cr6, 0x82865dd8
	if !ctx.cr[6].eq {
	pc = 0x82865DD8; continue 'dispatch;
	}
	// 82865DC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865DCC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865DD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82865DD4: 4E800421  bctrl
	ctx.lr = 0x82865DD8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82865DD8 => {
    //   block [0x82865DD8..0x82865DDC)
	// 82865DD8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	pc = 0x82865DDC; continue 'dispatch;
            }
            0x82865DDC => {
    //   block [0x82865DDC..0x82865DEC)
	// 82865DDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82865DE0: 4B9AEFF9  bl 0x82214dd8
	ctx.lr = 0x82865DE4;
	sub_82214DD8(ctx, base);
	// 82865DE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82865DE8: 4B9AEFF1  bl 0x82214dd8
	ctx.lr = 0x82865DEC;
	sub_82214DD8(ctx, base);
	pc = 0x82865DEC; continue 'dispatch;
            }
            0x82865DEC => {
    //   block [0x82865DEC..0x82865DFC)
	// 82865DEC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82865DF0: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82865DF4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82865DF8: 4844365C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865E00 size=628
    let mut pc: u32 = 0x82865E00;
    'dispatch: loop {
        match pc {
            0x82865E00 => {
    //   block [0x82865E00..0x82865E6C)
	// 82865E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865E04: 48443605  bl 0x82ca9408
	ctx.lr = 0x82865E08;
	sub_82CA93D0(ctx, base);
	// 82865E08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865E0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82865E10: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82865E14: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82865E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865E1C: 409A0250  bne cr6, 0x8286606c
	if !ctx.cr[6].eq {
	pc = 0x8286606C; continue 'dispatch;
	}
	// 82865E20: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865E24: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82865E28: 80BE0034  lwz r5, 0x34(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82865E2C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82865E30: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82865E34: 5528EFFE  rlwinm r8, r9, 0x1d, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 82865E38: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82865E3C: 419A00F4  beq cr6, 0x82865f30
	if ctx.cr[6].eq {
	pc = 0x82865F30; continue 'dispatch;
	}
	// 82865E40: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82865E44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82865E48: 419A0024  beq cr6, 0x82865e6c
	if ctx.cr[6].eq {
	pc = 0x82865E6C; continue 'dispatch;
	}
	// 82865E4C: 894A0063  lbz r10, 0x63(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(99 as u32) ) } as u64;
	// 82865E50: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82865E54: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82865E58: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82865E5C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865E60: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82865E64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82865E68: 480000CC  b 0x82865f34
	pc = 0x82865F34; continue 'dispatch;
            }
            0x82865E6C => {
    //   block [0x82865E6C..0x82865E88)
	// 82865E6C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82865E70: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82865E74: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82865E78: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82865E7C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82865E80: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865E84: 40810054  ble 0x82865ed8
	if !ctx.cr[0].gt {
	pc = 0x82865ED8; continue 'dispatch;
	}
	pc = 0x82865E88; continue 'dispatch;
            }
            0x82865E88 => {
    //   block [0x82865E88..0x82865EA8)
	// 82865E88: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82865E8C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82865E90: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82865E94: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865E98: 2F070063  cmpwi cr6, r7, 0x63
	ctx.cr[6].compare_i32(ctx.r[7].s32, 99, &mut ctx.xer);
	// 82865E9C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82865EA0: 41980008  blt cr6, 0x82865ea8
	if ctx.cr[6].lt {
	pc = 0x82865EA8; continue 'dispatch;
	}
	// 82865EA4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82865EA8; continue 'dispatch;
            }
            0x82865EA8 => {
    //   block [0x82865EA8..0x82865EC4)
	// 82865EA8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82865EAC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82865EB0: 419A0014  beq cr6, 0x82865ec4
	if ctx.cr[6].eq {
	pc = 0x82865EC4; continue 'dispatch;
	}
	// 82865EB4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82865EB8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82865EBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82865EC0: 4800000C  b 0x82865ecc
	pc = 0x82865ECC; continue 'dispatch;
            }
            0x82865EC4 => {
    //   block [0x82865EC4..0x82865ECC)
	// 82865EC4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82865EC8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82865ECC; continue 'dispatch;
            }
            0x82865ECC => {
    //   block [0x82865ECC..0x82865ED8)
	// 82865ECC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865ED0: 4199FFB8  bgt cr6, 0x82865e88
	if ctx.cr[6].gt {
	pc = 0x82865E88; continue 'dispatch;
	}
	// 82865ED4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82865ED8; continue 'dispatch;
            }
            0x82865ED8 => {
    //   block [0x82865ED8..0x82865EF4)
	// 82865ED8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82865EDC: 419A0040  beq cr6, 0x82865f1c
	if ctx.cr[6].eq {
	pc = 0x82865F1C; continue 'dispatch;
	}
	// 82865EE0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865EE4: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 82865EE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82865EEC: 41990008  bgt cr6, 0x82865ef4
	if ctx.cr[6].gt {
	pc = 0x82865EF4; continue 'dispatch;
	}
	// 82865EF0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82865EF4; continue 'dispatch;
            }
            0x82865EF4 => {
    //   block [0x82865EF4..0x82865F1C)
	// 82865EF4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82865EF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865EFC: 409A0020  bne cr6, 0x82865f1c
	if !ctx.cr[6].eq {
	pc = 0x82865F1C; continue 'dispatch;
	}
	// 82865F00: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82865F04: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82865F08: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82865F0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865F10: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82865F14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82865F18: 4800001C  b 0x82865f34
	pc = 0x82865F34; continue 'dispatch;
            }
            0x82865F1C => {
    //   block [0x82865F1C..0x82865F30)
	// 82865F1C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82865F20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865F24: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82865F28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82865F2C: 48000008  b 0x82865f34
	pc = 0x82865F34; continue 'dispatch;
            }
            0x82865F30 => {
    //   block [0x82865F30..0x82865F34)
	// 82865F30: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82865F34; continue 'dispatch;
            }
            0x82865F34 => {
    //   block [0x82865F34..0x82865F44)
	// 82865F34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82865F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865F3C: 419A0008  beq cr6, 0x82865f44
	if ctx.cr[6].eq {
	pc = 0x82865F44; continue 'dispatch;
	}
	// 82865F40: 838A0010  lwz r28, 0x10(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	pc = 0x82865F44; continue 'dispatch;
            }
            0x82865F44 => {
    //   block [0x82865F44..0x82865F64)
	// 82865F44: 7F1C2800  cmpw cr6, r28, r5
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82865F48: 419A0124  beq cr6, 0x8286606c
	if ctx.cr[6].eq {
	pc = 0x8286606C; continue 'dispatch;
	}
	// 82865F4C: 2F1C0003  cmpwi cr6, r28, 3
	ctx.cr[6].compare_i32(ctx.r[28].s32, 3, &mut ctx.xer);
	// 82865F50: 409A0014  bne cr6, 0x82865f64
	if !ctx.cr[6].eq {
	pc = 0x82865F64; continue 'dispatch;
	}
	// 82865F54: 809E0024  lwz r4, 0x24(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82865F58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82865F5C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82865F60: 48000010  b 0x82865f70
	pc = 0x82865F70; continue 'dispatch;
            }
            0x82865F64 => {
    //   block [0x82865F64..0x82865F70)
	// 82865F64: 809E001C  lwz r4, 0x1c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82865F68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82865F6C: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	pc = 0x82865F70; continue 'dispatch;
            }
            0x82865F70 => {
    //   block [0x82865F70..0x82865F88)
	// 82865F70: 4B9F9BF1  bl 0x8225fb60
	ctx.lr = 0x82865F74;
	sub_8225FB60(ctx, base);
	// 82865F74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865F78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865F7C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82865F80: 419A0024  beq cr6, 0x82865fa4
	if ctx.cr[6].eq {
	pc = 0x82865FA4; continue 'dispatch;
	}
	// 82865F84: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82865F88; continue 'dispatch;
            }
            0x82865F88 => {
    //   block [0x82865F88..0x82865FA4)
	// 82865F88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82865F8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865F90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82865F94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82865F98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82865F9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865FA0: 4082FFE8  bne 0x82865f88
	if !ctx.cr[0].eq {
	pc = 0x82865F88; continue 'dispatch;
	}
	pc = 0x82865FA4; continue 'dispatch;
            }
            0x82865FA4 => {
    //   block [0x82865FA4..0x82865FD4)
	// 82865FA4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82865FA8: 807E0038  lwz r3, 0x38(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82865FAC: 4BCFCC2D  bl 0x82562bd8
	ctx.lr = 0x82865FB0;
	sub_82562BD8(ctx, base);
	// 82865FB0: 57EB07BC  rlwinm r11, r31, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82865FB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865FB8: 419A0058  beq cr6, 0x82866010
	if ctx.cr[6].eq {
	pc = 0x82866010; continue 'dispatch;
	}
	// 82865FBC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82865FC0: 57FF07FA  rlwinm r31, r31, 0, 0x1f, 0x1d
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82865FC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865FC8: 419A0048  beq cr6, 0x82866010
	if ctx.cr[6].eq {
	pc = 0x82866010; continue 'dispatch;
	}
	// 82865FCC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82865FD0: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82865FD4; continue 'dispatch;
            }
            0x82865FD4 => {
    //   block [0x82865FD4..0x8286600C)
	// 82865FD4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82865FD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865FDC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82865FE0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82865FE4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82865FE8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82865FEC: 4082FFE8  bne 0x82865fd4
	if !ctx.cr[0].eq {
	pc = 0x82865FD4; continue 'dispatch;
	}
	// 82865FF0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82865FF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865FF8: 409A0014  bne cr6, 0x8286600c
	if !ctx.cr[6].eq {
	pc = 0x8286600C; continue 'dispatch;
	}
	// 82865FFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866000: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866004: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82866008: 4E800421  bctrl
	ctx.lr = 0x8286600C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8286600C => {
    //   block [0x8286600C..0x82866010)
	// 8286600C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	pc = 0x82866010; continue 'dispatch;
            }
            0x82866010 => {
    //   block [0x82866010..0x82866030)
	// 82866010: 57EB07FE  clrlwi r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 82866014: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866018: 419A0050  beq cr6, 0x82866068
	if ctx.cr[6].eq {
	pc = 0x82866068; continue 'dispatch;
	}
	// 8286601C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82866020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866024: 419A0044  beq cr6, 0x82866068
	if ctx.cr[6].eq {
	pc = 0x82866068; continue 'dispatch;
	}
	// 82866028: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286602C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82866030; continue 'dispatch;
            }
            0x82866030 => {
    //   block [0x82866030..0x82866068)
	// 82866030: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82866034: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82866038: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286603C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82866040: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82866044: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82866048: 4082FFE8  bne 0x82866030
	if !ctx.cr[0].eq {
	pc = 0x82866030; continue 'dispatch;
	}
	// 8286604C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82866050: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866054: 409A0014  bne cr6, 0x82866068
	if !ctx.cr[6].eq {
	pc = 0x82866068; continue 'dispatch;
	}
	// 82866058: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286605C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866060: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82866064: 4E800421  bctrl
	ctx.lr = 0x82866068;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82866068 => {
    //   block [0x82866068..0x8286606C)
	// 82866068: 939E0034  stw r28, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[28].u32 ) };
	pc = 0x8286606C; continue 'dispatch;
            }
            0x8286606C => {
    //   block [0x8286606C..0x82866074)
	// 8286606C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82866070: 484433E8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82866078 size=812
    let mut pc: u32 = 0x82866078;
    'dispatch: loop {
        match pc {
            0x82866078 => {
    //   block [0x82866078..0x828660C8)
	// 82866078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286607C: 48443391  bl 0x82ca940c
	ctx.lr = 0x82866080;
	sub_82CA93D0(ctx, base);
	// 82866080: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866084: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82866088: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8286608C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866090: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82866094: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 82866098: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8286609C: 419A00E8  beq cr6, 0x82866184
	if ctx.cr[6].eq {
	pc = 0x82866184; continue 'dispatch;
	}
	// 828660A0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828660A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828660A8: 419A0020  beq cr6, 0x828660c8
	if ctx.cr[6].eq {
	pc = 0x828660C8; continue 'dispatch;
	}
	// 828660AC: 894A0063  lbz r10, 0x63(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(99 as u32) ) } as u64;
	// 828660B0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828660B4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828660B8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828660BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828660C0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828660C4: 480000C8  b 0x8286618c
	pc = 0x8286618C; continue 'dispatch;
            }
            0x828660C8 => {
    //   block [0x828660C8..0x828660E4)
	// 828660C8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828660CC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828660D0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828660D4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828660D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828660DC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828660E0: 40810054  ble 0x82866134
	if !ctx.cr[0].gt {
	pc = 0x82866134; continue 'dispatch;
	}
	pc = 0x828660E4; continue 'dispatch;
            }
            0x828660E4 => {
    //   block [0x828660E4..0x82866104)
	// 828660E4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828660E8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828660EC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828660F0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828660F4: 2F070063  cmpwi cr6, r7, 0x63
	ctx.cr[6].compare_i32(ctx.r[7].s32, 99, &mut ctx.xer);
	// 828660F8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828660FC: 41980008  blt cr6, 0x82866104
	if ctx.cr[6].lt {
	pc = 0x82866104; continue 'dispatch;
	}
	// 82866100: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82866104; continue 'dispatch;
            }
            0x82866104 => {
    //   block [0x82866104..0x82866120)
	// 82866104: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82866108: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286610C: 419A0014  beq cr6, 0x82866120
	if ctx.cr[6].eq {
	pc = 0x82866120; continue 'dispatch;
	}
	// 82866110: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82866114: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82866118: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286611C: 4800000C  b 0x82866128
	pc = 0x82866128; continue 'dispatch;
            }
            0x82866120 => {
    //   block [0x82866120..0x82866128)
	// 82866120: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82866124: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82866128; continue 'dispatch;
            }
            0x82866128 => {
    //   block [0x82866128..0x82866134)
	// 82866128: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286612C: 4199FFB8  bgt cr6, 0x828660e4
	if ctx.cr[6].gt {
	pc = 0x828660E4; continue 'dispatch;
	}
	// 82866130: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82866134; continue 'dispatch;
            }
            0x82866134 => {
    //   block [0x82866134..0x82866150)
	// 82866134: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82866138: 419A003C  beq cr6, 0x82866174
	if ctx.cr[6].eq {
	pc = 0x82866174; continue 'dispatch;
	}
	// 8286613C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866140: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 82866144: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866148: 41990008  bgt cr6, 0x82866150
	if ctx.cr[6].gt {
	pc = 0x82866150; continue 'dispatch;
	}
	// 8286614C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82866150; continue 'dispatch;
            }
            0x82866150 => {
    //   block [0x82866150..0x82866174)
	// 82866150: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82866154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866158: 409A001C  bne cr6, 0x82866174
	if !ctx.cr[6].eq {
	pc = 0x82866174; continue 'dispatch;
	}
	// 8286615C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82866160: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82866164: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82866168: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286616C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866170: 4800001C  b 0x8286618c
	pc = 0x8286618C; continue 'dispatch;
            }
            0x82866174 => {
    //   block [0x82866174..0x82866184)
	// 82866174: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82866178: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8286617C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866180: 4800000C  b 0x8286618c
	pc = 0x8286618C; continue 'dispatch;
            }
            0x82866184 => {
    //   block [0x82866184..0x8286618C)
	// 82866184: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82866188: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x8286618C; continue 'dispatch;
            }
            0x8286618C => {
    //   block [0x8286618C..0x828661A8)
	// 8286618C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82866190: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82866194: 419A0014  beq cr6, 0x828661a8
	if ctx.cr[6].eq {
	pc = 0x828661A8; continue 'dispatch;
	}
	// 82866198: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8286619C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828661A0: C02AB478  lfs f1, -0x4b88(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19336 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828661A4: 4BA4DB0D  bl 0x822b3cb0
	ctx.lr = 0x828661A8;
	sub_822B3CB0(ctx, base);
	pc = 0x828661A8; continue 'dispatch;
            }
            0x828661A8 => {
    //   block [0x828661A8..0x828661E4)
	// 828661A8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828661AC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828661B0: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 828661B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828661B8: 419A00E8  beq cr6, 0x828662a0
	if ctx.cr[6].eq {
	pc = 0x828662A0; continue 'dispatch;
	}
	// 828661BC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828661C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828661C4: 419A0020  beq cr6, 0x828661e4
	if ctx.cr[6].eq {
	pc = 0x828661E4; continue 'dispatch;
	}
	// 828661C8: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 828661CC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828661D0: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828661D4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828661D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828661DC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828661E0: 480000C8  b 0x828662a8
	pc = 0x828662A8; continue 'dispatch;
            }
            0x828661E4 => {
    //   block [0x828661E4..0x82866200)
	// 828661E4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828661E8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828661EC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828661F0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828661F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828661F8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828661FC: 40810054  ble 0x82866250
	if !ctx.cr[0].gt {
	pc = 0x82866250; continue 'dispatch;
	}
	pc = 0x82866200; continue 'dispatch;
            }
            0x82866200 => {
    //   block [0x82866200..0x82866220)
	// 82866200: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82866204: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82866208: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286620C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866210: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82866214: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82866218: 41980008  blt cr6, 0x82866220
	if ctx.cr[6].lt {
	pc = 0x82866220; continue 'dispatch;
	}
	// 8286621C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82866220; continue 'dispatch;
            }
            0x82866220 => {
    //   block [0x82866220..0x8286623C)
	// 82866220: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82866224: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82866228: 419A0014  beq cr6, 0x8286623c
	if ctx.cr[6].eq {
	pc = 0x8286623C; continue 'dispatch;
	}
	// 8286622C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82866230: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82866234: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82866238: 4800000C  b 0x82866244
	pc = 0x82866244; continue 'dispatch;
            }
            0x8286623C => {
    //   block [0x8286623C..0x82866244)
	// 8286623C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82866240: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82866244; continue 'dispatch;
            }
            0x82866244 => {
    //   block [0x82866244..0x82866250)
	// 82866244: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866248: 4199FFB8  bgt cr6, 0x82866200
	if ctx.cr[6].gt {
	pc = 0x82866200; continue 'dispatch;
	}
	// 8286624C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82866250; continue 'dispatch;
            }
            0x82866250 => {
    //   block [0x82866250..0x8286626C)
	// 82866250: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82866254: 419A003C  beq cr6, 0x82866290
	if ctx.cr[6].eq {
	pc = 0x82866290; continue 'dispatch;
	}
	// 82866258: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286625C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82866260: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866264: 41990008  bgt cr6, 0x8286626c
	if ctx.cr[6].gt {
	pc = 0x8286626C; continue 'dispatch;
	}
	// 82866268: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8286626C; continue 'dispatch;
            }
            0x8286626C => {
    //   block [0x8286626C..0x82866290)
	// 8286626C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82866270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866274: 409A001C  bne cr6, 0x82866290
	if !ctx.cr[6].eq {
	pc = 0x82866290; continue 'dispatch;
	}
	// 82866278: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8286627C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82866280: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82866284: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82866288: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286628C: 4800001C  b 0x828662a8
	pc = 0x828662A8; continue 'dispatch;
            }
            0x82866290 => {
    //   block [0x82866290..0x828662A0)
	// 82866290: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82866294: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82866298: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286629C: 4800000C  b 0x828662a8
	pc = 0x828662A8; continue 'dispatch;
            }
            0x828662A0 => {
    //   block [0x828662A0..0x828662A8)
	// 828662A0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828662A4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x828662A8; continue 'dispatch;
            }
            0x828662A8 => {
    //   block [0x828662A8..0x828662DC)
	// 828662A8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828662AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828662B0: 419A00EC  beq cr6, 0x8286639c
	if ctx.cr[6].eq {
	pc = 0x8286639C; continue 'dispatch;
	}
	// 828662B4: 809D0038  lwz r4, 0x38(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 828662B8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828662BC: 419A005C  beq cr6, 0x82866318
	if ctx.cr[6].eq {
	pc = 0x82866318; continue 'dispatch;
	}
	// 828662C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828662C4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828662C8: 4BA47D59  bl 0x822ae020
	ctx.lr = 0x828662CC;
	sub_822AE020(ctx, base);
	// 828662CC: 807D0038  lwz r3, 0x38(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 828662D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828662D4: 419A0040  beq cr6, 0x82866314
	if ctx.cr[6].eq {
	pc = 0x82866314; continue 'dispatch;
	}
	// 828662D8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x828662DC; continue 'dispatch;
            }
            0x828662DC => {
    //   block [0x828662DC..0x82866310)
	// 828662DC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828662E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828662E4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828662E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828662EC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828662F0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828662F4: 4082FFE8  bne 0x828662dc
	if !ctx.cr[0].eq {
	pc = 0x828662DC; continue 'dispatch;
	}
	// 828662F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828662FC: 409A0014  bne cr6, 0x82866310
	if !ctx.cr[6].eq {
	pc = 0x82866310; continue 'dispatch;
	}
	// 82866300: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866304: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866308: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286630C: 4E800421  bctrl
	ctx.lr = 0x82866310;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82866310 => {
    //   block [0x82866310..0x82866314)
	// 82866310: 93DD0038  stw r30, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	pc = 0x82866314; continue 'dispatch;
            }
            0x82866314 => {
    //   block [0x82866314..0x82866318)
	// 82866314: 93DD0038  stw r30, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	pc = 0x82866318; continue 'dispatch;
            }
            0x82866318 => {
    //   block [0x82866318..0x82866344)
	// 82866318: 807D002C  lwz r3, 0x2c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 8286631C: 3BFD002C  addi r31, r29, 0x2c
	ctx.r[31].s64 = ctx.r[29].s64 + 44;
	// 82866320: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82866324: 419A0020  beq cr6, 0x82866344
	if ctx.cr[6].eq {
	pc = 0x82866344; continue 'dispatch;
	}
	// 82866328: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286632C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82866330: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82866334: 4E800421  bctrl
	ctx.lr = 0x82866338;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82866338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286633C: 4B9517DD  bl 0x821b7b18
	ctx.lr = 0x82866340;
	sub_821B7B18(ctx, base);
	// 82866340: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
            }
            0x82866344 => {
    //   block [0x82866344..0x82866370)
	// 82866344: 807D001C  lwz r3, 0x1c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82866348: 3BFD001C  addi r31, r29, 0x1c
	ctx.r[31].s64 = ctx.r[29].s64 + 28;
	// 8286634C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82866350: 419A0020  beq cr6, 0x82866370
	if ctx.cr[6].eq {
	pc = 0x82866370; continue 'dispatch;
	}
	// 82866354: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866358: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286635C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82866360: 4E800421  bctrl
	ctx.lr = 0x82866364;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82866364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866368: 4B9517B1  bl 0x821b7b18
	ctx.lr = 0x8286636C;
	sub_821B7B18(ctx, base);
	// 8286636C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
            }
            0x82866370 => {
    //   block [0x82866370..0x8286639C)
	// 82866370: 807D0024  lwz r3, 0x24(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82866374: 3BFD0024  addi r31, r29, 0x24
	ctx.r[31].s64 = ctx.r[29].s64 + 36;
	// 82866378: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286637C: 419A0020  beq cr6, 0x8286639c
	if ctx.cr[6].eq {
	pc = 0x8286639C; continue 'dispatch;
	}
	// 82866380: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866384: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82866388: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286638C: 4E800421  bctrl
	ctx.lr = 0x82866390;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82866390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866394: 4B951785  bl 0x821b7b18
	ctx.lr = 0x82866398;
	sub_821B7B18(ctx, base);
	// 82866398: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
            }
            0x8286639C => {
    //   block [0x8286639C..0x828663A4)
	// 8286639C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828663A0: 484430BC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828663A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828663A8 size=52
    let mut pc: u32 = 0x828663A8;
    'dispatch: loop {
        match pc {
            0x828663A8 => {
    //   block [0x828663A8..0x828663DC)
	// 828663A8: 80830010  lwz r4, 0x10(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828663AC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828663B0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 828663B4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828663B8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828663BC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828663C0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828663C4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828663C8: 80680018  lwz r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 828663CC: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828663D0: 80C70030  lwz r6, 0x30(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) } as u64;
	// 828663D4: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 828663D8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828663DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828663DC size=4
    let mut pc: u32 = 0x828663DC;
    'dispatch: loop {
        match pc {
            0x828663DC => {
    //   block [0x828663DC..0x828663E0)
	// 828663DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828663E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828663E0 size=300
    let mut pc: u32 = 0x828663E0;
    'dispatch: loop {
        match pc {
            0x828663E0 => {
    //   block [0x828663E0..0x82866424)
	// 828663E0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828663E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828663E8: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828663EC: 5528A7FE  rlwinm r8, r9, 0x14, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000FFFu64;
	// 828663F0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828663F4: 419A00F8  beq cr6, 0x828664ec
	if ctx.cr[6].eq {
	pc = 0x828664EC; continue 'dispatch;
	}
	// 828663F8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828663FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82866400: 419A0024  beq cr6, 0x82866424
	if ctx.cr[6].eq {
	pc = 0x82866424; continue 'dispatch;
	}
	// 82866404: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82866408: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286640C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82866410: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82866414: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866418: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8286641C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866420: 480000D0  b 0x828664f0
	pc = 0x828664F0; continue 'dispatch;
            }
            0x82866424 => {
    //   block [0x82866424..0x82866444)
	// 82866424: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82866428: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8286642C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82866430: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 82866434: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82866438: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 8286643C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866440: 40810054  ble 0x82866494
	if !ctx.cr[0].gt {
	pc = 0x82866494; continue 'dispatch;
	}
	pc = 0x82866444; continue 'dispatch;
            }
            0x82866444 => {
    //   block [0x82866444..0x82866464)
	// 82866444: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82866448: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286644C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82866450: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866454: 2F07002C  cmpwi cr6, r7, 0x2c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 44, &mut ctx.xer);
	// 82866458: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286645C: 41980008  blt cr6, 0x82866464
	if ctx.cr[6].lt {
	pc = 0x82866464; continue 'dispatch;
	}
	// 82866460: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82866464; continue 'dispatch;
            }
            0x82866464 => {
    //   block [0x82866464..0x82866480)
	// 82866464: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82866468: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286646C: 419A0014  beq cr6, 0x82866480
	if ctx.cr[6].eq {
	pc = 0x82866480; continue 'dispatch;
	}
	// 82866470: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82866474: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82866478: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286647C: 4800000C  b 0x82866488
	pc = 0x82866488; continue 'dispatch;
            }
            0x82866480 => {
    //   block [0x82866480..0x82866488)
	// 82866480: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82866484: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82866488; continue 'dispatch;
            }
            0x82866488 => {
    //   block [0x82866488..0x82866494)
	// 82866488: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286648C: 4199FFB8  bgt cr6, 0x82866444
	if ctx.cr[6].gt {
	pc = 0x82866444; continue 'dispatch;
	}
	// 82866490: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x82866494; continue 'dispatch;
            }
            0x82866494 => {
    //   block [0x82866494..0x828664B0)
	// 82866494: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82866498: 419A0040  beq cr6, 0x828664d8
	if ctx.cr[6].eq {
	pc = 0x828664D8; continue 'dispatch;
	}
	// 8286649C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828664A0: 2F0B002C  cmpwi cr6, r11, 0x2c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 44, &mut ctx.xer);
	// 828664A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828664A8: 41990008  bgt cr6, 0x828664b0
	if ctx.cr[6].gt {
	pc = 0x828664B0; continue 'dispatch;
	}
	// 828664AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828664B0; continue 'dispatch;
            }
            0x828664B0 => {
    //   block [0x828664B0..0x828664D8)
	// 828664B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828664B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828664B8: 409A0020  bne cr6, 0x828664d8
	if !ctx.cr[6].eq {
	pc = 0x828664D8; continue 'dispatch;
	}
	// 828664BC: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828664C0: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 828664C4: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828664C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828664CC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828664D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828664D4: 4800001C  b 0x828664f0
	pc = 0x828664F0; continue 'dispatch;
            }
            0x828664D8 => {
    //   block [0x828664D8..0x828664EC)
	// 828664D8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828664DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828664E0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828664E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828664E8: 48000008  b 0x828664f0
	pc = 0x828664F0; continue 'dispatch;
            }
            0x828664EC => {
    //   block [0x828664EC..0x828664F0)
	// 828664EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828664F0; continue 'dispatch;
            }
            0x828664F0 => {
    //   block [0x828664F0..0x8286650C)
	// 828664F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828664F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828664F8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 828664FC: 816A0064  lwz r11, 0x64(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 82866500: 6169000C  ori r9, r11, 0xc
	ctx.r[9].u64 = ctx.r[11].u64 | 12;
	// 82866504: 912A0064  stw r9, 0x64(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82866508: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866510 size=56
    let mut pc: u32 = 0x82866510;
    'dispatch: loop {
        match pc {
            0x82866510 => {
    //   block [0x82866510..0x82866528)
	// 82866510: 81640020  lwz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82866514: 8144001C  lwz r10, 0x1c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82866518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286651C: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82866520: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82866524: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x82866528; continue 'dispatch;
            }
            0x82866528 => {
    //   block [0x82866528..0x82866548)
	// 82866528: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8286652C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82866530: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82866534: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82866538: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286653C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82866540: 4082FFE8  bne 0x82866528
	if !ctx.cr[0].eq {
	pc = 0x82866528; continue 'dispatch;
	}
	// 82866544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866548 size=8
    let mut pc: u32 = 0x82866548;
    'dispatch: loop {
        match pc {
            0x82866548 => {
    //   block [0x82866548..0x82866550)
	// 82866548: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 8286654C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866550 size=460
    let mut pc: u32 = 0x82866550;
    'dispatch: loop {
        match pc {
            0x82866550 => {
    //   block [0x82866550..0x828665A4)
	// 82866550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866554: 48442EB9  bl 0x82ca940c
	ctx.lr = 0x82866558;
	sub_82CA93D0(ctx, base);
	// 82866558: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286655C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82866560: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82866564: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866568: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8286656C: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 82866570: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82866574: 419A00F4  beq cr6, 0x82866668
	if ctx.cr[6].eq {
	pc = 0x82866668; continue 'dispatch;
	}
	// 82866578: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286657C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82866580: 419A0024  beq cr6, 0x828665a4
	if ctx.cr[6].eq {
	pc = 0x828665A4; continue 'dispatch;
	}
	// 82866584: 894A005B  lbz r10, 0x5b(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(91 as u32) ) } as u64;
	// 82866588: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286658C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82866590: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82866594: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866598: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8286659C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828665A0: 480000CC  b 0x8286666c
	pc = 0x8286666C; continue 'dispatch;
            }
            0x828665A4 => {
    //   block [0x828665A4..0x828665C0)
	// 828665A4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828665A8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828665AC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828665B0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828665B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828665B8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828665BC: 40810054  ble 0x82866610
	if !ctx.cr[0].gt {
	pc = 0x82866610; continue 'dispatch;
	}
	pc = 0x828665C0; continue 'dispatch;
            }
            0x828665C0 => {
    //   block [0x828665C0..0x828665E0)
	// 828665C0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828665C4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828665C8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828665CC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828665D0: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 828665D4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828665D8: 41980008  blt cr6, 0x828665e0
	if ctx.cr[6].lt {
	pc = 0x828665E0; continue 'dispatch;
	}
	// 828665DC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x828665E0; continue 'dispatch;
            }
            0x828665E0 => {
    //   block [0x828665E0..0x828665FC)
	// 828665E0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828665E4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828665E8: 419A0014  beq cr6, 0x828665fc
	if ctx.cr[6].eq {
	pc = 0x828665FC; continue 'dispatch;
	}
	// 828665EC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828665F0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828665F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828665F8: 4800000C  b 0x82866604
	pc = 0x82866604; continue 'dispatch;
            }
            0x828665FC => {
    //   block [0x828665FC..0x82866604)
	// 828665FC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82866600: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82866604; continue 'dispatch;
            }
            0x82866604 => {
    //   block [0x82866604..0x82866610)
	// 82866604: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866608: 4199FFB8  bgt cr6, 0x828665c0
	if ctx.cr[6].gt {
	pc = 0x828665C0; continue 'dispatch;
	}
	// 8286660C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82866610; continue 'dispatch;
            }
            0x82866610 => {
    //   block [0x82866610..0x8286662C)
	// 82866610: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82866614: 419A0040  beq cr6, 0x82866654
	if ctx.cr[6].eq {
	pc = 0x82866654; continue 'dispatch;
	}
	// 82866618: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286661C: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 82866620: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866624: 41990008  bgt cr6, 0x8286662c
	if ctx.cr[6].gt {
	pc = 0x8286662C; continue 'dispatch;
	}
	// 82866628: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8286662C; continue 'dispatch;
            }
            0x8286662C => {
    //   block [0x8286662C..0x82866654)
	// 8286662C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82866630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866634: 409A0020  bne cr6, 0x82866654
	if !ctx.cr[6].eq {
	pc = 0x82866654; continue 'dispatch;
	}
	// 82866638: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8286663C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82866640: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82866644: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866648: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8286664C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866650: 4800001C  b 0x8286666c
	pc = 0x8286666C; continue 'dispatch;
            }
            0x82866654 => {
    //   block [0x82866654..0x82866668)
	// 82866654: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82866658: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286665C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82866660: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866664: 48000008  b 0x8286666c
	pc = 0x8286666C; continue 'dispatch;
            }
            0x82866668 => {
    //   block [0x82866668..0x8286666C)
	// 82866668: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8286666C; continue 'dispatch;
            }
            0x8286666C => {
    //   block [0x8286666C..0x828666C4)
	// 8286666C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82866670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866674: 419A00A0  beq cr6, 0x82866714
	if ctx.cr[6].eq {
	pc = 0x82866714; continue 'dispatch;
	}
	// 82866678: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286667C: 4B9AE47D  bl 0x82214af8
	ctx.lr = 0x82866680;
	sub_82214AF8(ctx, base);
	// 82866680: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82866684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866688: 419A008C  beq cr6, 0x82866714
	if ctx.cr[6].eq {
	pc = 0x82866714; continue 'dispatch;
	}
	// 8286668C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82866690: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82866694: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82866698: 390A5D2C  addi r8, r10, 0x5d2c
	ctx.r[8].s64 = ctx.r[10].s64 + 23852;
	// 8286669C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828666A0: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 828666A4: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 828666A8: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 828666AC: 3BEAFFDF  addi r31, r10, -0x21
	ctx.r[31].s64 = ctx.r[10].s64 + -33;
	// 828666B0: 90E10168  stw r7, 0x168(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), ctx.r[7].u32 ) };
	// 828666B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828666B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828666BC: 419A0008  beq cr6, 0x828666c4
	if ctx.cr[6].eq {
	pc = 0x828666C4; continue 'dispatch;
	}
	// 828666C0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828666C4; continue 'dispatch;
            }
            0x828666C4 => {
    //   block [0x828666C4..0x828666E4)
	// 828666C4: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 828666C8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828666CC: 4BA669DD  bl 0x822cd0a8
	ctx.lr = 0x828666D0;
	sub_822CD0A8(ctx, base);
	// 828666D0: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 828666D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828666D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828666DC: 419A0008  beq cr6, 0x828666e4
	if ctx.cr[6].eq {
	pc = 0x828666E4; continue 'dispatch;
	}
	// 828666E0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828666E4; continue 'dispatch;
            }
            0x828666E4 => {
    //   block [0x828666E4..0x82866714)
	// 828666E4: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 828666E8: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828666EC: 4BA669BD  bl 0x822cd0a8
	ctx.lr = 0x828666F0;
	sub_822CD0A8(ctx, base);
	// 828666F0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828666F4: 4B94BC9D  bl 0x821b2390
	ctx.lr = 0x828666F8;
	sub_821B2390(ctx, base);
	// 828666F8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828666FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82866700: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82866704: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82866708: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8286670C: 806A008C  lwz r3, 0x8c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 82866710: 4BB38E01  bl 0x8239f510
	ctx.lr = 0x82866714;
	sub_8239F510(ctx, base);
	pc = 0x82866714; continue 'dispatch;
            }
            0x82866714 => {
    //   block [0x82866714..0x8286671C)
	// 82866714: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82866718: 48442D44  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866720 size=8
    let mut pc: u32 = 0x82866720;
    'dispatch: loop {
        match pc {
            0x82866720 => {
    //   block [0x82866720..0x82866728)
	// 82866720: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82866724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866728 size=8
    let mut pc: u32 = 0x82866728;
    'dispatch: loop {
        match pc {
            0x82866728 => {
    //   block [0x82866728..0x82866730)
	// 82866728: 38600019  li r3, 0x19
	ctx.r[3].s64 = 25;
	// 8286672C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866730 size=8
    let mut pc: u32 = 0x82866730;
    'dispatch: loop {
        match pc {
            0x82866730 => {
    //   block [0x82866730..0x82866738)
	// 82866730: 3860001A  li r3, 0x1a
	ctx.r[3].s64 = 26;
	// 82866734: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866738 size=8
    let mut pc: u32 = 0x82866738;
    'dispatch: loop {
        match pc {
            0x82866738 => {
    //   block [0x82866738..0x82866740)
	// 82866738: 3860001B  li r3, 0x1b
	ctx.r[3].s64 = 27;
	// 8286673C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866740 size=8
    let mut pc: u32 = 0x82866740;
    'dispatch: loop {
        match pc {
            0x82866740 => {
    //   block [0x82866740..0x82866748)
	// 82866740: 38600031  li r3, 0x31
	ctx.r[3].s64 = 49;
	// 82866744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866748 size=8
    let mut pc: u32 = 0x82866748;
    'dispatch: loop {
        match pc {
            0x82866748 => {
    //   block [0x82866748..0x82866750)
	// 82866748: 38600036  li r3, 0x36
	ctx.r[3].s64 = 54;
	// 8286674C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866750 size=192
    let mut pc: u32 = 0x82866750;
    'dispatch: loop {
        match pc {
            0x82866750 => {
    //   block [0x82866750..0x82866784)
	// 82866750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866754: 48442CB9  bl 0x82ca940c
	ctx.lr = 0x82866758;
	sub_82CA93D0(ctx, base);
	// 82866758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286675C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82866760: 3BFE0054  addi r31, r30, 0x54
	ctx.r[31].s64 = ctx.r[30].s64 + 84;
	// 82866764: 809E0058  lwz r4, 0x58(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82866768: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8286676C: 419A0018  beq cr6, 0x82866784
	if ctx.cr[6].eq {
	pc = 0x82866784; continue 'dispatch;
	}
	// 82866770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866774: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82866778: 48001529  bl 0x82867ca0
	ctx.lr = 0x8286677C;
	sub_82867CA0(ctx, base);
	// 8286677C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866780: 4B9B55B9  bl 0x8221bd38
	ctx.lr = 0x82866784;
	sub_8221BD38(ctx, base);
	pc = 0x82866784; continue 'dispatch;
            }
            0x82866784 => {
    //   block [0x82866784..0x828667A4)
	// 82866784: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82866788: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8286678C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82866790: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82866794: 807E0050  lwz r3, 0x50(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82866798: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286679C: 419A0040  beq cr6, 0x828667dc
	if ctx.cr[6].eq {
	pc = 0x828667DC; continue 'dispatch;
	}
	// 828667A0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x828667A4; continue 'dispatch;
            }
            0x828667A4 => {
    //   block [0x828667A4..0x828667D8)
	// 828667A4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828667A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828667AC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828667B0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828667B4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828667B8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828667BC: 4082FFE8  bne 0x828667a4
	if !ctx.cr[0].eq {
	pc = 0x828667A4; continue 'dispatch;
	}
	// 828667C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828667C4: 409A0014  bne cr6, 0x828667d8
	if !ctx.cr[6].eq {
	pc = 0x828667D8; continue 'dispatch;
	}
	// 828667C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828667CC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828667D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828667D4: 4E800421  bctrl
	ctx.lr = 0x828667D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828667D8 => {
    //   block [0x828667D8..0x828667DC)
	// 828667D8: 93BE0050  stw r29, 0x50(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	pc = 0x828667DC; continue 'dispatch;
            }
            0x828667DC => {
    //   block [0x828667DC..0x828667E8)
	// 828667DC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828667E0: 419A0008  beq cr6, 0x828667e8
	if ctx.cr[6].eq {
	pc = 0x828667E8; continue 'dispatch;
	}
	// 828667E4: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	pc = 0x828667E8; continue 'dispatch;
            }
            0x828667E8 => {
    //   block [0x828667E8..0x82866810)
	// 828667E8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828667EC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828667F0: 392B2B90  addi r9, r11, 0x2b90
	ctx.r[9].s64 = ctx.r[11].s64 + 11152;
	// 828667F4: 390AF058  addi r8, r10, -0xfa8
	ctx.r[8].s64 = ctx.r[10].s64 + -4008;
	// 828667F8: 913D0000  stw r9, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828667FC: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82866800: 911E0000  stw r8, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82866804: 4B9AE5D5  bl 0x82214dd8
	ctx.lr = 0x82866808;
	sub_82214DD8(ctx, base);
	// 82866808: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286680C: 48442C50  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866810 size=80
    let mut pc: u32 = 0x82866810;
    'dispatch: loop {
        match pc {
            0x82866810 => {
    //   block [0x82866810..0x82866848)
	// 82866810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286681C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82866828: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8286682C: 4BFFFF25  bl 0x82866750
	ctx.lr = 0x82866830;
	sub_82866750(ctx, base);
	// 82866830: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82866834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286683C: 419A000C  beq cr6, 0x82866848
	if ctx.cr[6].eq {
	pc = 0x82866848; continue 'dispatch;
	}
	// 82866840: 4B9B54F9  bl 0x8221bd38
	ctx.lr = 0x82866844;
	sub_8221BD38(ctx, base);
	// 82866844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82866848; continue 'dispatch;
            }
            0x82866848 => {
    //   block [0x82866848..0x82866860)
	// 82866848: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286684C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866854: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866858: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286685C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82866860 size=184
    let mut pc: u32 = 0x82866860;
    'dispatch: loop {
        match pc {
            0x82866860 => {
    //   block [0x82866860..0x82866884)
	// 82866860: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82866864: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82866868: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 8286686C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866870: 38EAF058  addi r7, r10, -0xfa8
	ctx.r[7].s64 = ctx.r[10].s64 + -4008;
	// 82866874: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 82866878: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8286687C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82866880: 39447088  addi r10, r4, 0x7088
	ctx.r[10].s64 = ctx.r[4].s64 + 28808;
	pc = 0x82866884; continue 'dispatch;
            }
            0x82866884 => {
    //   block [0x82866884..0x82866918)
	// 82866884: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82866888: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286688C: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82866890: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82866894: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82866898: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286689C: 4082FFE8  bne 0x82866884
	if !ctx.cr[0].eq {
	pc = 0x82866884; continue 'dispatch;
	}
	// 828668A0: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 828668A4: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 828668A8: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 828668AC: 9963000D  stb r11, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[11].u8 ) };
	// 828668B0: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828668B4: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828668B8: 3BE00040  li r31, 0x40
	ctx.r[31].s64 = 64;
	// 828668BC: C0089484  lfs f0, -0x6b7c(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828668C0: 39492B90  addi r10, r9, 0x2b90
	ctx.r[10].s64 = ctx.r[9].s64 + 11152;
	// 828668C4: 3927FB40  addi r9, r7, -0x4c0
	ctx.r[9].s64 = ctx.r[7].s64 + -1216;
	// 828668C8: 3904FC00  addi r8, r4, -0x400
	ctx.r[8].s64 = ctx.r[4].s64 + -1024;
	// 828668CC: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828668D0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828668D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828668D8: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828668DC: 91030010  stw r8, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 828668E0: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 828668E4: 90A30014  stw r5, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 828668E8: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 828668EC: 90C30018  stw r6, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 828668F0: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 828668F4: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 828668F8: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866918 size=384
    let mut pc: u32 = 0x82866918;
    'dispatch: loop {
        match pc {
            0x82866918 => {
    //   block [0x82866918..0x82866994)
	// 82866918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286691C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286692C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82866930: 48000359  bl 0x82866c88
	ctx.lr = 0x82866934;
	sub_82866C88(ctx, base);
	// 82866934: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82866938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286693C: 419A0144  beq cr6, 0x82866a80
	if ctx.cr[6].eq {
	pc = 0x82866A80; continue 'dispatch;
	}
	// 82866940: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82866944: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82866948: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286694C: 4B934C4D  bl 0x8219b598
	ctx.lr = 0x82866950;
	sub_8219B598(ctx, base);
	// 82866950: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866954: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82866958: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8286695C: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82866960: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82866964: 419A00F4  beq cr6, 0x82866a58
	if ctx.cr[6].eq {
	pc = 0x82866A58; continue 'dispatch;
	}
	// 82866968: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286696C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82866970: 419A0024  beq cr6, 0x82866994
	if ctx.cr[6].eq {
	pc = 0x82866994; continue 'dispatch;
	}
	// 82866974: 892A0061  lbz r9, 0x61(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(97 as u32) ) } as u64;
	// 82866978: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286697C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82866980: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82866984: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866988: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8286698C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866990: 480000CC  b 0x82866a5c
	pc = 0x82866A5C; continue 'dispatch;
            }
            0x82866994 => {
    //   block [0x82866994..0x828669B0)
	// 82866994: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82866998: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286699C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828669A0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828669A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828669A8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828669AC: 40810054  ble 0x82866a00
	if !ctx.cr[0].gt {
	pc = 0x82866A00; continue 'dispatch;
	}
	pc = 0x828669B0; continue 'dispatch;
            }
            0x828669B0 => {
    //   block [0x828669B0..0x828669D0)
	// 828669B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828669B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828669B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828669BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828669C0: 2F070061  cmpwi cr6, r7, 0x61
	ctx.cr[6].compare_i32(ctx.r[7].s32, 97, &mut ctx.xer);
	// 828669C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828669C8: 41980008  blt cr6, 0x828669d0
	if ctx.cr[6].lt {
	pc = 0x828669D0; continue 'dispatch;
	}
	// 828669CC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x828669D0; continue 'dispatch;
            }
            0x828669D0 => {
    //   block [0x828669D0..0x828669EC)
	// 828669D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828669D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828669D8: 419A0014  beq cr6, 0x828669ec
	if ctx.cr[6].eq {
	pc = 0x828669EC; continue 'dispatch;
	}
	// 828669DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828669E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828669E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828669E8: 4800000C  b 0x828669f4
	pc = 0x828669F4; continue 'dispatch;
            }
            0x828669EC => {
    //   block [0x828669EC..0x828669F4)
	// 828669EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828669F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828669F4; continue 'dispatch;
            }
            0x828669F4 => {
    //   block [0x828669F4..0x82866A00)
	// 828669F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828669F8: 4199FFB8  bgt cr6, 0x828669b0
	if ctx.cr[6].gt {
	pc = 0x828669B0; continue 'dispatch;
	}
	// 828669FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82866A00; continue 'dispatch;
            }
            0x82866A00 => {
    //   block [0x82866A00..0x82866A1C)
	// 82866A00: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82866A04: 419A0040  beq cr6, 0x82866a44
	if ctx.cr[6].eq {
	pc = 0x82866A44; continue 'dispatch;
	}
	// 82866A08: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866A0C: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 82866A10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866A14: 41990008  bgt cr6, 0x82866a1c
	if ctx.cr[6].gt {
	pc = 0x82866A1C; continue 'dispatch;
	}
	// 82866A18: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82866A1C; continue 'dispatch;
            }
            0x82866A1C => {
    //   block [0x82866A1C..0x82866A44)
	// 82866A1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82866A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866A24: 409A0020  bne cr6, 0x82866a44
	if !ctx.cr[6].eq {
	pc = 0x82866A44; continue 'dispatch;
	}
	// 82866A28: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82866A2C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82866A30: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82866A34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866A38: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82866A3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866A40: 4800001C  b 0x82866a5c
	pc = 0x82866A5C; continue 'dispatch;
            }
            0x82866A44 => {
    //   block [0x82866A44..0x82866A58)
	// 82866A44: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82866A48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866A4C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82866A50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866A54: 48000008  b 0x82866a5c
	pc = 0x82866A5C; continue 'dispatch;
            }
            0x82866A58 => {
    //   block [0x82866A58..0x82866A5C)
	// 82866A58: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82866A5C; continue 'dispatch;
            }
            0x82866A5C => {
    //   block [0x82866A5C..0x82866A80)
	// 82866A5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82866A60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866A64: 419A001C  beq cr6, 0x82866a80
	if ctx.cr[6].eq {
	pc = 0x82866A80; continue 'dispatch;
	}
	// 82866A68: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866A6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82866A70: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82866A74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82866A78: 4E800421  bctrl
	ctx.lr = 0x82866A7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82866A7C: 987F0019  stb r3, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[3].u8 ) };
            }
            0x82866A80 => {
    //   block [0x82866A80..0x82866A98)
	// 82866A80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866A84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866A88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866A8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866A90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866A94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866A98 size=496
    let mut pc: u32 = 0x82866A98;
    'dispatch: loop {
        match pc {
            0x82866A98 => {
    //   block [0x82866A98..0x82866AC8)
	// 82866A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866AA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866AA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866AA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866AAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82866AB0: 389F0054  addi r4, r31, 0x54
	ctx.r[4].s64 = ctx.r[31].s64 + 84;
	// 82866AB4: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82866AB8: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82866ABC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82866AC0: 40990008  ble cr6, 0x82866ac8
	if !ctx.cr[6].gt {
	pc = 0x82866AC8; continue 'dispatch;
	}
	// 82866AC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82866AC8; continue 'dispatch;
            }
            0x82866AC8 => {
    //   block [0x82866AC8..0x82866ADC)
	// 82866AC8: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82866ACC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82866AD0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82866AD4: 40990008  ble cr6, 0x82866adc
	if !ctx.cr[6].gt {
	pc = 0x82866ADC; continue 'dispatch;
	}
	// 82866AD8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82866ADC; continue 'dispatch;
            }
            0x82866ADC => {
    //   block [0x82866ADC..0x82866B48)
	// 82866ADC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82866AE0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82866AE4: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 82866AE8: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82866AEC: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82866AF0: 48001101  bl 0x82867bf0
	ctx.lr = 0x82866AF4;
	sub_82867BF0(ctx, base);
	// 82866AF4: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82866AF8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82866AFC: 419A0174  beq cr6, 0x82866c70
	if ctx.cr[6].eq {
	pc = 0x82866C70; continue 'dispatch;
	}
	// 82866B00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866B04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82866B08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82866B0C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82866B10: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82866B14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82866B18: 419A00F4  beq cr6, 0x82866c0c
	if ctx.cr[6].eq {
	pc = 0x82866C0C; continue 'dispatch;
	}
	// 82866B1C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82866B20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82866B24: 419A0024  beq cr6, 0x82866b48
	if ctx.cr[6].eq {
	pc = 0x82866B48; continue 'dispatch;
	}
	// 82866B28: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 82866B2C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82866B30: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82866B34: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82866B38: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866B3C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82866B40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866B44: 480000CC  b 0x82866c10
	pc = 0x82866C10; continue 'dispatch;
            }
            0x82866B48 => {
    //   block [0x82866B48..0x82866B64)
	// 82866B48: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82866B4C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82866B50: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82866B54: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82866B58: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82866B5C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866B60: 40810054  ble 0x82866bb4
	if !ctx.cr[0].gt {
	pc = 0x82866BB4; continue 'dispatch;
	}
	pc = 0x82866B64; continue 'dispatch;
            }
            0x82866B64 => {
    //   block [0x82866B64..0x82866B84)
	// 82866B64: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82866B68: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82866B6C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82866B70: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866B74: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82866B78: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82866B7C: 41980008  blt cr6, 0x82866b84
	if ctx.cr[6].lt {
	pc = 0x82866B84; continue 'dispatch;
	}
	// 82866B80: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82866B84; continue 'dispatch;
            }
            0x82866B84 => {
    //   block [0x82866B84..0x82866BA0)
	// 82866B84: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82866B88: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82866B8C: 419A0014  beq cr6, 0x82866ba0
	if ctx.cr[6].eq {
	pc = 0x82866BA0; continue 'dispatch;
	}
	// 82866B90: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82866B94: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82866B98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82866B9C: 4800000C  b 0x82866ba8
	pc = 0x82866BA8; continue 'dispatch;
            }
            0x82866BA0 => {
    //   block [0x82866BA0..0x82866BA8)
	// 82866BA0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82866BA4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82866BA8; continue 'dispatch;
            }
            0x82866BA8 => {
    //   block [0x82866BA8..0x82866BB4)
	// 82866BA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866BAC: 4199FFB8  bgt cr6, 0x82866b64
	if ctx.cr[6].gt {
	pc = 0x82866B64; continue 'dispatch;
	}
	// 82866BB0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82866BB4; continue 'dispatch;
            }
            0x82866BB4 => {
    //   block [0x82866BB4..0x82866BD0)
	// 82866BB4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82866BB8: 419A0040  beq cr6, 0x82866bf8
	if ctx.cr[6].eq {
	pc = 0x82866BF8; continue 'dispatch;
	}
	// 82866BBC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866BC0: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82866BC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866BC8: 41990008  bgt cr6, 0x82866bd0
	if ctx.cr[6].gt {
	pc = 0x82866BD0; continue 'dispatch;
	}
	// 82866BCC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82866BD0; continue 'dispatch;
            }
            0x82866BD0 => {
    //   block [0x82866BD0..0x82866BF8)
	// 82866BD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82866BD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866BD8: 409A0020  bne cr6, 0x82866bf8
	if !ctx.cr[6].eq {
	pc = 0x82866BF8; continue 'dispatch;
	}
	// 82866BDC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82866BE0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82866BE4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82866BE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866BEC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82866BF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866BF4: 4800001C  b 0x82866c10
	pc = 0x82866C10; continue 'dispatch;
            }
            0x82866BF8 => {
    //   block [0x82866BF8..0x82866C0C)
	// 82866BF8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82866BFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866C00: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82866C04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866C08: 48000008  b 0x82866c10
	pc = 0x82866C10; continue 'dispatch;
            }
            0x82866C0C => {
    //   block [0x82866C0C..0x82866C10)
	// 82866C0C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82866C10; continue 'dispatch;
            }
            0x82866C10 => {
    //   block [0x82866C10..0x82866C34)
	// 82866C10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82866C14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866C18: 419A0058  beq cr6, 0x82866c70
	if ctx.cr[6].eq {
	pc = 0x82866C70; continue 'dispatch;
	}
	// 82866C1C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82866C20: 4BA47401  bl 0x822ae020
	ctx.lr = 0x82866C24;
	sub_822AE020(ctx, base);
	// 82866C24: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82866C28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82866C2C: 419A0040  beq cr6, 0x82866c6c
	if ctx.cr[6].eq {
	pc = 0x82866C6C; continue 'dispatch;
	}
	// 82866C30: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82866C34; continue 'dispatch;
            }
            0x82866C34 => {
    //   block [0x82866C34..0x82866C68)
	// 82866C34: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82866C38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82866C3C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82866C40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82866C44: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82866C48: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82866C4C: 4082FFE8  bne 0x82866c34
	if !ctx.cr[0].eq {
	pc = 0x82866C34; continue 'dispatch;
	}
	// 82866C50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866C54: 409A0014  bne cr6, 0x82866c68
	if !ctx.cr[6].eq {
	pc = 0x82866C68; continue 'dispatch;
	}
	// 82866C58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866C5C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866C60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82866C64: 4E800421  bctrl
	ctx.lr = 0x82866C68;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82866C68 => {
    //   block [0x82866C68..0x82866C6C)
	// 82866C68: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	pc = 0x82866C6C; continue 'dispatch;
            }
            0x82866C6C => {
    //   block [0x82866C6C..0x82866C70)
	// 82866C6C: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	pc = 0x82866C70; continue 'dispatch;
            }
            0x82866C70 => {
    //   block [0x82866C70..0x82866C88)
	// 82866C70: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82866C74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866C78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866C7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866C80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866C84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82866C88 size=2532
    let mut pc: u32 = 0x82866C88;
    'dispatch: loop {
        match pc {
            0x82866C88 => {
    //   block [0x82866C88..0x82866CEC)
	// 82866C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866C8C: 4844274D  bl 0x82ca93d8
	ctx.lr = 0x82866C90;
	sub_82CA93D0(ctx, base);
	// 82866C90: DBC1FF68  stfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[30].u64 ) };
	// 82866C94: DBE1FF70  stfd f31, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 82866C98: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866C9C: 7C711B78  mr r17, r3
	ctx.r[17].u64 = ctx.r[3].u64;
	// 82866CA0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82866CA4: 7F36CB78  mr r22, r25
	ctx.r[22].u64 = ctx.r[25].u64;
	// 82866CA8: 7F30CB78  mr r16, r25
	ctx.r[16].u64 = ctx.r[25].u64;
	// 82866CAC: 80D10004  lwz r6, 4(r17)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866CB0: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82866CB4: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 82866CB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82866CBC: 419A00F4  beq cr6, 0x82866db0
	if ctx.cr[6].eq {
	pc = 0x82866DB0; continue 'dispatch;
	}
	// 82866CC0: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82866CC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866CC8: 419A0024  beq cr6, 0x82866cec
	if ctx.cr[6].eq {
	pc = 0x82866CEC; continue 'dispatch;
	}
	// 82866CCC: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82866CD0: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82866CD4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82866CD8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82866CDC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866CE0: 7D765B78  mr r22, r11
	ctx.r[22].u64 = ctx.r[11].u64;
	// 82866CE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866CE8: 480000CC  b 0x82866db4
	pc = 0x82866DB4; continue 'dispatch;
            }
            0x82866CEC => {
    //   block [0x82866CEC..0x82866D08)
	// 82866CEC: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82866CF0: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82866CF4: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82866CF8: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82866CFC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82866D00: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866D04: 40810054  ble 0x82866d58
	if !ctx.cr[0].gt {
	pc = 0x82866D58; continue 'dispatch;
	}
	pc = 0x82866D08; continue 'dispatch;
            }
            0x82866D08 => {
    //   block [0x82866D08..0x82866D28)
	// 82866D08: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82866D0C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82866D10: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82866D14: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866D18: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 82866D1C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82866D20: 41980008  blt cr6, 0x82866d28
	if ctx.cr[6].lt {
	pc = 0x82866D28; continue 'dispatch;
	}
	// 82866D24: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x82866D28; continue 'dispatch;
            }
            0x82866D28 => {
    //   block [0x82866D28..0x82866D44)
	// 82866D28: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82866D2C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82866D30: 419A0014  beq cr6, 0x82866d44
	if ctx.cr[6].eq {
	pc = 0x82866D44; continue 'dispatch;
	}
	// 82866D34: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82866D38: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82866D3C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82866D40: 4800000C  b 0x82866d4c
	pc = 0x82866D4C; continue 'dispatch;
            }
            0x82866D44 => {
    //   block [0x82866D44..0x82866D4C)
	// 82866D44: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82866D48: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82866D4C; continue 'dispatch;
            }
            0x82866D4C => {
    //   block [0x82866D4C..0x82866D58)
	// 82866D4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866D50: 4199FFB8  bgt cr6, 0x82866d08
	if ctx.cr[6].gt {
	pc = 0x82866D08; continue 'dispatch;
	}
	// 82866D54: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82866D58; continue 'dispatch;
            }
            0x82866D58 => {
    //   block [0x82866D58..0x82866D74)
	// 82866D58: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82866D5C: 419A0040  beq cr6, 0x82866d9c
	if ctx.cr[6].eq {
	pc = 0x82866D9C; continue 'dispatch;
	}
	// 82866D60: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866D64: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 82866D68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866D6C: 41990008  bgt cr6, 0x82866d74
	if ctx.cr[6].gt {
	pc = 0x82866D74; continue 'dispatch;
	}
	// 82866D70: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82866D74; continue 'dispatch;
            }
            0x82866D74 => {
    //   block [0x82866D74..0x82866D9C)
	// 82866D74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82866D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866D7C: 409A0020  bne cr6, 0x82866d9c
	if !ctx.cr[6].eq {
	pc = 0x82866D9C; continue 'dispatch;
	}
	// 82866D80: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82866D84: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82866D88: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82866D8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866D90: 7D765B78  mr r22, r11
	ctx.r[22].u64 = ctx.r[11].u64;
	// 82866D94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866D98: 4800001C  b 0x82866db4
	pc = 0x82866DB4; continue 'dispatch;
            }
            0x82866D9C => {
    //   block [0x82866D9C..0x82866DB0)
	// 82866D9C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82866DA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866DA4: 7D765B78  mr r22, r11
	ctx.r[22].u64 = ctx.r[11].u64;
	// 82866DA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866DAC: 48000008  b 0x82866db4
	pc = 0x82866DB4; continue 'dispatch;
            }
            0x82866DB0 => {
    //   block [0x82866DB0..0x82866DB4)
	// 82866DB0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82866DB4; continue 'dispatch;
            }
            0x82866DB4 => {
    //   block [0x82866DB4..0x82866DFC)
	// 82866DB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82866DB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866DBC: 419A089C  beq cr6, 0x82867658
	if ctx.cr[6].eq {
	pc = 0x82867658; continue 'dispatch;
	}
	// 82866DC0: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82866DC4: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 82866DC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82866DCC: 419A00F4  beq cr6, 0x82866ec0
	if ctx.cr[6].eq {
	pc = 0x82866EC0; continue 'dispatch;
	}
	// 82866DD0: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82866DD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866DD8: 419A0024  beq cr6, 0x82866dfc
	if ctx.cr[6].eq {
	pc = 0x82866DFC; continue 'dispatch;
	}
	// 82866DDC: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 82866DE0: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82866DE4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82866DE8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82866DEC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866DF0: 7D705B78  mr r16, r11
	ctx.r[16].u64 = ctx.r[11].u64;
	// 82866DF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866DF8: 480000CC  b 0x82866ec4
	pc = 0x82866EC4; continue 'dispatch;
            }
            0x82866DFC => {
    //   block [0x82866DFC..0x82866E18)
	// 82866DFC: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82866E00: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82866E04: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82866E08: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82866E0C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82866E10: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866E14: 40810054  ble 0x82866e68
	if !ctx.cr[0].gt {
	pc = 0x82866E68; continue 'dispatch;
	}
	pc = 0x82866E18; continue 'dispatch;
            }
            0x82866E18 => {
    //   block [0x82866E18..0x82866E38)
	// 82866E18: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82866E1C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82866E20: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82866E24: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866E28: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82866E2C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82866E30: 41980008  blt cr6, 0x82866e38
	if ctx.cr[6].lt {
	pc = 0x82866E38; continue 'dispatch;
	}
	// 82866E34: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x82866E38; continue 'dispatch;
            }
            0x82866E38 => {
    //   block [0x82866E38..0x82866E54)
	// 82866E38: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82866E3C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82866E40: 419A0014  beq cr6, 0x82866e54
	if ctx.cr[6].eq {
	pc = 0x82866E54; continue 'dispatch;
	}
	// 82866E44: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82866E48: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82866E4C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82866E50: 4800000C  b 0x82866e5c
	pc = 0x82866E5C; continue 'dispatch;
            }
            0x82866E54 => {
    //   block [0x82866E54..0x82866E5C)
	// 82866E54: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82866E58: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82866E5C; continue 'dispatch;
            }
            0x82866E5C => {
    //   block [0x82866E5C..0x82866E68)
	// 82866E5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866E60: 4199FFB8  bgt cr6, 0x82866e18
	if ctx.cr[6].gt {
	pc = 0x82866E18; continue 'dispatch;
	}
	// 82866E64: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82866E68; continue 'dispatch;
            }
            0x82866E68 => {
    //   block [0x82866E68..0x82866E84)
	// 82866E68: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82866E6C: 419A0040  beq cr6, 0x82866eac
	if ctx.cr[6].eq {
	pc = 0x82866EAC; continue 'dispatch;
	}
	// 82866E70: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866E74: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82866E78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866E7C: 41990008  bgt cr6, 0x82866e84
	if ctx.cr[6].gt {
	pc = 0x82866E84; continue 'dispatch;
	}
	// 82866E80: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82866E84; continue 'dispatch;
            }
            0x82866E84 => {
    //   block [0x82866E84..0x82866EAC)
	// 82866E84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82866E88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866E8C: 409A0020  bne cr6, 0x82866eac
	if !ctx.cr[6].eq {
	pc = 0x82866EAC; continue 'dispatch;
	}
	// 82866E90: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82866E94: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82866E98: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82866E9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866EA0: 7D705B78  mr r16, r11
	ctx.r[16].u64 = ctx.r[11].u64;
	// 82866EA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866EA8: 4800001C  b 0x82866ec4
	pc = 0x82866EC4; continue 'dispatch;
            }
            0x82866EAC => {
    //   block [0x82866EAC..0x82866EC0)
	// 82866EAC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82866EB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866EB4: 7D705B78  mr r16, r11
	ctx.r[16].u64 = ctx.r[11].u64;
	// 82866EB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82866EBC: 48000008  b 0x82866ec4
	pc = 0x82866EC4; continue 'dispatch;
            }
            0x82866EC0 => {
    //   block [0x82866EC0..0x82866EC4)
	// 82866EC0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82866EC4; continue 'dispatch;
            }
            0x82866EC4 => {
    //   block [0x82866EC4..0x82866F68)
	// 82866EC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82866EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866ECC: 419A078C  beq cr6, 0x82867658
	if ctx.cr[6].eq {
	pc = 0x82867658; continue 'dispatch;
	}
	// 82866ED0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82866ED4: 932100A0  stw r25, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[25].u32 ) };
	// 82866ED8: 932100A4  stw r25, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[25].u32 ) };
	// 82866EDC: 3BF10054  addi r31, r17, 0x54
	ctx.r[31].s64 = ctx.r[17].s64 + 84;
	// 82866EE0: 3BCB9490  addi r30, r11, -0x6b70
	ctx.r[30].s64 = ctx.r[11].s64 + -27504;
	// 82866EE4: 932100A8  stw r25, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[25].u32 ) };
	// 82866EE8: 932100AC  stw r25, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[25].u32 ) };
	// 82866EEC: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82866EF0: 932100B0  stw r25, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[25].u32 ) };
	// 82866EF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866EF8: 932100B4  stw r25, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[25].u32 ) };
	// 82866EFC: 932100B8  stw r25, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[25].u32 ) };
	// 82866F00: C3DEFFF4  lfs f30, -0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82866F04: 932100BC  stw r25, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[25].u32 ) };
	// 82866F08: D3C100D8  stfs f30, 0xd8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82866F0C: 932100C0  stw r25, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[25].u32 ) };
	// 82866F10: 932100C4  stw r25, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[25].u32 ) };
	// 82866F14: 932100CC  stw r25, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[25].u32 ) };
	// 82866F18: 932100D0  stw r25, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[25].u32 ) };
	// 82866F1C: 932100D4  stw r25, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[25].u32 ) };
	// 82866F20: 80910018  lwz r4, 0x18(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(24 as u32) ) } as u64;
	// 82866F24: 48000B9D  bl 0x82867ac0
	ctx.lr = 0x82866F28;
	sub_82867AC0(ctx, base);
	// 82866F28: 81710018  lwz r11, 0x18(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(24 as u32) ) } as u64;
	// 82866F2C: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 82866F30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866F34: 40990710  ble cr6, 0x82867644
	if !ctx.cr[6].gt {
	pc = 0x82867644; continue 'dispatch;
	}
	// 82866F38: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82866F3C: C3FE0000  lfs f31, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82866F40: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82866F44: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 82866F48: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 82866F4C: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 82866F50: 7F37CB78  mr r23, r25
	ctx.r[23].u64 = ctx.r[25].u64;
	// 82866F54: 3B00003C  li r24, 0x3c
	ctx.r[24].s64 = 60;
	// 82866F58: 3AABFB30  addi r21, r11, -0x4d0
	ctx.r[21].s64 = ctx.r[11].s64 + -1232;
	// 82866F5C: 3A8AFB24  addi r20, r10, -0x4dc
	ctx.r[20].s64 = ctx.r[10].s64 + -1244;
	// 82866F60: 3A69FB18  addi r19, r9, -0x4e8
	ctx.r[19].s64 = ctx.r[9].s64 + -1256;
	// 82866F64: 3A48FB0C  addi r18, r8, -0x4f4
	ctx.r[18].s64 = ctx.r[8].s64 + -1268;
	pc = 0x82866F68; continue 'dispatch;
            }
            0x82866F68 => {
    //   block [0x82866F68..0x82866FB0)
	// 82866F68: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 82866F6C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82866F70: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 82866F74: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82866F78: 81710014  lwz r11, 0x14(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(20 as u32) ) } as u64;
	// 82866F7C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 82866F80: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 82866F84: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866F88: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866F8C: 480006E5  bl 0x82867670
	ctx.lr = 0x82866F90;
	sub_82867670(ctx, base);
	// 82866F90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866F98: 419A0018  beq cr6, 0x82866fb0
	if ctx.cr[6].eq {
	pc = 0x82866FB0; continue 'dispatch;
	}
	// 82866F9C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82866FA0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82866FA4: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 82866FA8: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82866FAC: 41980008  blt cr6, 0x82866fb4
	if ctx.cr[6].lt {
	pc = 0x82866FB4; continue 'dispatch;
	}
	pc = 0x82866FB0; continue 'dispatch;
            }
            0x82866FB0 => {
    //   block [0x82866FB0..0x82866FB4)
	// 82866FB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82866FB4; continue 'dispatch;
            }
            0x82866FB4 => {
    //   block [0x82866FB4..0x82866FE4)
	// 82866FB4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82866FB8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82866FBC: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82866FC0: 4BA8E989  bl 0x822f5948
	ctx.lr = 0x82866FC4;
	sub_822F5948(ctx, base);
	// 82866FC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866FC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866FCC: 419A0018  beq cr6, 0x82866fe4
	if ctx.cr[6].eq {
	pc = 0x82866FE4; continue 'dispatch;
	}
	// 82866FD0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82866FD4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82866FD8: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 82866FDC: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82866FE0: 41980008  blt cr6, 0x82866fe8
	if ctx.cr[6].lt {
	pc = 0x82866FE8; continue 'dispatch;
	}
	pc = 0x82866FE4; continue 'dispatch;
            }
            0x82866FE4 => {
    //   block [0x82866FE4..0x82866FE8)
	// 82866FE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82866FE8; continue 'dispatch;
            }
            0x82866FE8 => {
    //   block [0x82866FE8..0x82867024)
	// 82866FE8: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82866FEC: 83A10074  lwz r29, 0x74(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82866FF0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82866FF4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82866FF8: 419A002C  beq cr6, 0x82867024
	if ctx.cr[6].eq {
	pc = 0x82867024; continue 'dispatch;
	}
	// 82866FFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82867000: 4B950B19  bl 0x821b7b18
	ctx.lr = 0x82867004;
	sub_821B7B18(ctx, base);
	// 82867004: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82867008: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8286700C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82867010: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82867014: 419A0010  beq cr6, 0x82867024
	if ctx.cr[6].eq {
	pc = 0x82867024; continue 'dispatch;
	}
	// 82867018: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286701C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82867020: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82867024; continue 'dispatch;
            }
            0x82867024 => {
    //   block [0x82867024..0x82867130)
	// 82867024: 81710014  lwz r11, 0x14(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(20 as u32) ) } as u64;
	// 82867028: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 8286702C: 894B0009  lbz r10, 9(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(9 as u32) ) } as u64;
	// 82867030: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82867034: 419A02F0  beq cr6, 0x82867324
	if ctx.cr[6].eq {
	pc = 0x82867324; continue 'dispatch;
	}
	// 82867038: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286703C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867040: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82867044: 93210078  stw r25, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[25].u32 ) };
	// 82867048: 9321007C  stw r25, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[25].u32 ) };
	// 8286704C: 93210080  stw r25, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[25].u32 ) };
	// 82867050: 93210084  stw r25, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[25].u32 ) };
	// 82867054: 4B9C5E7D  bl 0x8222ced0
	ctx.lr = 0x82867058;
	sub_8222CED0(ctx, base);
	// 82867058: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286705C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82867060: 4B9891E1  bl 0x821f0240
	ctx.lr = 0x82867064;
	sub_821F0240(ctx, base);
	// 82867064: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82867068: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8286706C: 4B973955  bl 0x821da9c0
	ctx.lr = 0x82867070;
	sub_821DA9C0(ctx, base);
	// 82867070: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82867074: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82867078: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8286707C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82867080: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82867084: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82867088: 4BA1CCA9  bl 0x82283d30
	ctx.lr = 0x8286708C;
	sub_82283D30(ctx, base);
	// 8286708C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82867090: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82867094: 4BA0BFC5  bl 0x82273058
	ctx.lr = 0x82867098;
	sub_82273058(ctx, base);
	// 82867098: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8286709C: 4B9ADD3D  bl 0x82214dd8
	ctx.lr = 0x828670A0;
	sub_82214DD8(ctx, base);
	// 828670A0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828670A4: 4B9ADD35  bl 0x82214dd8
	ctx.lr = 0x828670A8;
	sub_82214DD8(ctx, base);
	// 828670A8: 81710014  lwz r11, 0x14(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(20 as u32) ) } as u64;
	// 828670AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828670B0: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 828670B4: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 828670B8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828670BC: 4B9C5E15  bl 0x8222ced0
	ctx.lr = 0x828670C0;
	sub_8222CED0(ctx, base);
	// 828670C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828670C4: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828670C8: 4B989179  bl 0x821f0240
	ctx.lr = 0x828670CC;
	sub_821F0240(ctx, base);
	// 828670CC: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 828670D0: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828670D4: 4B9738ED  bl 0x821da9c0
	ctx.lr = 0x828670D8;
	sub_821DA9C0(ctx, base);
	// 828670D8: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828670DC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828670E0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828670E4: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 828670E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828670EC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828670F0: 4BA1CC41  bl 0x82283d30
	ctx.lr = 0x828670F4;
	sub_82283D30(ctx, base);
	// 828670F4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828670F8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828670FC: 4BA0BF5D  bl 0x82273058
	ctx.lr = 0x82867100;
	sub_82273058(ctx, base);
	// 82867100: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82867104: 4B9ADCD5  bl 0x82214dd8
	ctx.lr = 0x82867108;
	sub_82214DD8(ctx, base);
	// 82867108: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 8286710C: 4B9ADCCD  bl 0x82214dd8
	ctx.lr = 0x82867110;
	sub_82214DD8(ctx, base);
	// 82867110: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867118: 419A0018  beq cr6, 0x82867130
	if ctx.cr[6].eq {
	pc = 0x82867130; continue 'dispatch;
	}
	// 8286711C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867120: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82867124: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 82867128: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8286712C: 41980008  blt cr6, 0x82867134
	if ctx.cr[6].lt {
	pc = 0x82867134; continue 'dispatch;
	}
	pc = 0x82867130; continue 'dispatch;
            }
            0x82867130 => {
    //   block [0x82867130..0x82867134)
	// 82867130: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867134; continue 'dispatch;
            }
            0x82867134 => {
    //   block [0x82867134..0x82867164)
	// 82867134: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82867138: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 8286713C: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82867140: 4BA8E809  bl 0x822f5948
	ctx.lr = 0x82867144;
	sub_822F5948(ctx, base);
	// 82867144: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286714C: 419A0018  beq cr6, 0x82867164
	if ctx.cr[6].eq {
	pc = 0x82867164; continue 'dispatch;
	}
	// 82867150: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867154: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82867158: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 8286715C: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82867160: 41980008  blt cr6, 0x82867168
	if ctx.cr[6].lt {
	pc = 0x82867168; continue 'dispatch;
	}
	pc = 0x82867164; continue 'dispatch;
            }
            0x82867164 => {
    //   block [0x82867164..0x82867168)
	// 82867164: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867168; continue 'dispatch;
            }
            0x82867168 => {
    //   block [0x82867168..0x828671A8)
	// 82867168: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 8286716C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82867170: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82867174: 4BA8E7D5  bl 0x822f5948
	ctx.lr = 0x82867178;
	sub_822F5948(ctx, base);
	// 82867178: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8286717C: 4B9B80DD  bl 0x8221f258
	ctx.lr = 0x82867180;
	sub_8221F258(ctx, base);
	// 82867180: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82867184: 419A0024  beq cr6, 0x828671a8
	if ctx.cr[6].eq {
	pc = 0x828671A8; continue 'dispatch;
	}
	// 82867188: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 8286718C: 80E10080  lwz r7, 0x80(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82867190: 80A10078  lwz r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82867194: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82867198: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286719C: 4BEFA905  bl 0x82761aa0
	ctx.lr = 0x828671A0;
	sub_82761AA0(ctx, base);
	// 828671A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828671A4: 48000008  b 0x828671ac
	pc = 0x828671AC; continue 'dispatch;
            }
            0x828671A8 => {
    //   block [0x828671A8..0x828671AC)
	// 828671A8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	pc = 0x828671AC; continue 'dispatch;
            }
            0x828671AC => {
    //   block [0x828671AC..0x828671CC)
	// 828671AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828671B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828671B4: 419A0018  beq cr6, 0x828671cc
	if ctx.cr[6].eq {
	pc = 0x828671CC; continue 'dispatch;
	}
	// 828671B8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828671BC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828671C0: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 828671C4: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828671C8: 41980008  blt cr6, 0x828671d0
	if ctx.cr[6].lt {
	pc = 0x828671D0; continue 'dispatch;
	}
	pc = 0x828671CC; continue 'dispatch;
            }
            0x828671CC => {
    //   block [0x828671CC..0x828671D0)
	// 828671CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828671D0; continue 'dispatch;
            }
            0x828671D0 => {
    //   block [0x828671D0..0x8286720C)
	// 828671D0: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828671D4: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 828671D8: 4BA0BE81  bl 0x82273058
	ctx.lr = 0x828671DC;
	sub_82273058(ctx, base);
	// 828671DC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828671E0: 4B9B8079  bl 0x8221f258
	ctx.lr = 0x828671E4;
	sub_8221F258(ctx, base);
	// 828671E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828671E8: 419A0070  beq cr6, 0x82867258
	if ctx.cr[6].eq {
	pc = 0x82867258; continue 'dispatch;
	}
	// 828671EC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828671F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828671F4: 419A0018  beq cr6, 0x8286720c
	if ctx.cr[6].eq {
	pc = 0x8286720C; continue 'dispatch;
	}
	// 828671F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828671FC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82867200: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 82867204: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82867208: 41980008  blt cr6, 0x82867210
	if ctx.cr[6].lt {
	pc = 0x82867210; continue 'dispatch;
	}
	pc = 0x8286720C; continue 'dispatch;
            }
            0x8286720C => {
    //   block [0x8286720C..0x82867210)
	// 8286720C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867210; continue 'dispatch;
            }
            0x82867210 => {
    //   block [0x82867210..0x82867234)
	// 82867210: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867214: 7CEAD82E  lwzx r7, r10, r27
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82867218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286721C: 419A0018  beq cr6, 0x82867234
	if ctx.cr[6].eq {
	pc = 0x82867234; continue 'dispatch;
	}
	// 82867220: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867224: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82867228: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 8286722C: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82867230: 41980008  blt cr6, 0x82867238
	if ctx.cr[6].lt {
	pc = 0x82867238; continue 'dispatch;
	}
	pc = 0x82867234; continue 'dispatch;
            }
            0x82867234 => {
    //   block [0x82867234..0x82867238)
	// 82867234: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867238; continue 'dispatch;
            }
            0x82867238 => {
    //   block [0x82867238..0x82867258)
	// 82867238: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 8286723C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82867240: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82867244: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82867248: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8286724C: 4BEFA855  bl 0x82761aa0
	ctx.lr = 0x82867250;
	sub_82761AA0(ctx, base);
	// 82867250: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82867254: 48000008  b 0x8286725c
	pc = 0x8286725C; continue 'dispatch;
            }
            0x82867258 => {
    //   block [0x82867258..0x8286725C)
	// 82867258: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	pc = 0x8286725C; continue 'dispatch;
            }
            0x8286725C => {
    //   block [0x8286725C..0x8286727C)
	// 8286725C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867264: 419A0018  beq cr6, 0x8286727c
	if ctx.cr[6].eq {
	pc = 0x8286727C; continue 'dispatch;
	}
	// 82867268: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286726C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82867270: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 82867274: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82867278: 41980008  blt cr6, 0x82867280
	if ctx.cr[6].lt {
	pc = 0x82867280; continue 'dispatch;
	}
	pc = 0x8286727C; continue 'dispatch;
            }
            0x8286727C => {
    //   block [0x8286727C..0x82867280)
	// 8286727C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867280; continue 'dispatch;
            }
            0x82867280 => {
    //   block [0x82867280..0x828672AC)
	// 82867280: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82867284: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82867288: 4BA0BDD1  bl 0x82273058
	ctx.lr = 0x8286728C;
	sub_82273058(ctx, base);
	// 8286728C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867294: 419A0018  beq cr6, 0x828672ac
	if ctx.cr[6].eq {
	pc = 0x828672AC; continue 'dispatch;
	}
	// 82867298: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286729C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828672A0: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 828672A4: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828672A8: 41980008  blt cr6, 0x828672b0
	if ctx.cr[6].lt {
	pc = 0x828672B0; continue 'dispatch;
	}
	pc = 0x828672AC; continue 'dispatch;
            }
            0x828672AC => {
    //   block [0x828672AC..0x828672B0)
	// 828672AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828672B0; continue 'dispatch;
            }
            0x828672B0 => {
    //   block [0x828672B0..0x828672D4)
	// 828672B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828672B4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828672B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828672BC: 419A0018  beq cr6, 0x828672d4
	if ctx.cr[6].eq {
	pc = 0x828672D4; continue 'dispatch;
	}
	// 828672C0: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828672C4: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 828672C8: 7CE8C3D6  divw r7, r8, r24
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[24].s32;
	// 828672CC: 7F1A3840  cmplw cr6, r26, r7
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828672D0: 41980008  blt cr6, 0x828672d8
	if ctx.cr[6].lt {
	pc = 0x828672D8; continue 'dispatch;
	}
	pc = 0x828672D4; continue 'dispatch;
            }
            0x828672D4 => {
    //   block [0x828672D4..0x828672D8)
	// 828672D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828672D8; continue 'dispatch;
            }
            0x828672D8 => {
    //   block [0x828672D8..0x82867314)
	// 828672D8: 7FAADA14  add r29, r10, r27
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 828672DC: 83CB000C  lwz r30, 0xc(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828672E0: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828672E4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828672E8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828672EC: 419A0028  beq cr6, 0x82867314
	if ctx.cr[6].eq {
	pc = 0x82867314; continue 'dispatch;
	}
	// 828672F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828672F4: 4B950825  bl 0x821b7b18
	ctx.lr = 0x828672F8;
	sub_821B7B18(ctx, base);
	// 828672F8: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828672FC: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82867300: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82867304: 419A0010  beq cr6, 0x82867314
	if ctx.cr[6].eq {
	pc = 0x82867314; continue 'dispatch;
	}
	// 82867308: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286730C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82867310: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82867314; continue 'dispatch;
            }
            0x82867314 => {
    //   block [0x82867314..0x82867324)
	// 82867314: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82867318: 4B950801  bl 0x821b7b18
	ctx.lr = 0x8286731C;
	sub_821B7B18(ctx, base);
	// 8286731C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82867320: 4B9507F9  bl 0x821b7b18
	ctx.lr = 0x82867324;
	sub_821B7B18(ctx, base);
	pc = 0x82867324; continue 'dispatch;
            }
            0x82867324 => {
    //   block [0x82867324..0x82867430)
	// 82867324: 81710014  lwz r11, 0x14(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(20 as u32) ) } as u64;
	// 82867328: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 8286732C: 894B0008  lbz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867330: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82867334: 419A02F0  beq cr6, 0x82867624
	if ctx.cr[6].eq {
	pc = 0x82867624; continue 'dispatch;
	}
	// 82867338: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286733C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867340: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82867344: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82867348: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 8286734C: 93210088  stw r25, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[25].u32 ) };
	// 82867350: 9321008C  stw r25, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[25].u32 ) };
	// 82867354: 4B9C5B7D  bl 0x8222ced0
	ctx.lr = 0x82867358;
	sub_8222CED0(ctx, base);
	// 82867358: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286735C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82867360: 4B988EE1  bl 0x821f0240
	ctx.lr = 0x82867364;
	sub_821F0240(ctx, base);
	// 82867364: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82867368: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 8286736C: 4B973655  bl 0x821da9c0
	ctx.lr = 0x82867370;
	sub_821DA9C0(ctx, base);
	// 82867370: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82867374: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82867378: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8286737C: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82867380: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82867384: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82867388: 4BA1C9A9  bl 0x82283d30
	ctx.lr = 0x8286738C;
	sub_82283D30(ctx, base);
	// 8286738C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82867390: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82867394: 4BA0BCC5  bl 0x82273058
	ctx.lr = 0x82867398;
	sub_82273058(ctx, base);
	// 82867398: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 8286739C: 4B9ADA3D  bl 0x82214dd8
	ctx.lr = 0x828673A0;
	sub_82214DD8(ctx, base);
	// 828673A0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828673A4: 4B9ADA35  bl 0x82214dd8
	ctx.lr = 0x828673A8;
	sub_82214DD8(ctx, base);
	// 828673A8: 81710014  lwz r11, 0x14(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(20 as u32) ) } as u64;
	// 828673AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828673B0: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 828673B4: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 828673B8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828673BC: 4B9C5B15  bl 0x8222ced0
	ctx.lr = 0x828673C0;
	sub_8222CED0(ctx, base);
	// 828673C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828673C4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828673C8: 4B988E79  bl 0x821f0240
	ctx.lr = 0x828673CC;
	sub_821F0240(ctx, base);
	// 828673CC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828673D0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828673D4: 4B9735ED  bl 0x821da9c0
	ctx.lr = 0x828673D8;
	sub_821DA9C0(ctx, base);
	// 828673D8: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828673DC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828673E0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828673E4: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 828673E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828673EC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828673F0: 4BA1C941  bl 0x82283d30
	ctx.lr = 0x828673F4;
	sub_82283D30(ctx, base);
	// 828673F4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828673F8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828673FC: 4BA0BC5D  bl 0x82273058
	ctx.lr = 0x82867400;
	sub_82273058(ctx, base);
	// 82867400: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82867404: 4B9AD9D5  bl 0x82214dd8
	ctx.lr = 0x82867408;
	sub_82214DD8(ctx, base);
	// 82867408: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 8286740C: 4B9AD9CD  bl 0x82214dd8
	ctx.lr = 0x82867410;
	sub_82214DD8(ctx, base);
	// 82867410: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867414: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867418: 419A0018  beq cr6, 0x82867430
	if ctx.cr[6].eq {
	pc = 0x82867430; continue 'dispatch;
	}
	// 8286741C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867420: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82867424: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 82867428: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8286742C: 41980008  blt cr6, 0x82867434
	if ctx.cr[6].lt {
	pc = 0x82867434; continue 'dispatch;
	}
	pc = 0x82867430; continue 'dispatch;
            }
            0x82867430 => {
    //   block [0x82867430..0x82867434)
	// 82867430: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867434; continue 'dispatch;
            }
            0x82867434 => {
    //   block [0x82867434..0x82867464)
	// 82867434: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82867438: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8286743C: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82867440: 4BA8E509  bl 0x822f5948
	ctx.lr = 0x82867444;
	sub_822F5948(ctx, base);
	// 82867444: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286744C: 419A0018  beq cr6, 0x82867464
	if ctx.cr[6].eq {
	pc = 0x82867464; continue 'dispatch;
	}
	// 82867450: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867454: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82867458: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 8286745C: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82867460: 41980008  blt cr6, 0x82867468
	if ctx.cr[6].lt {
	pc = 0x82867468; continue 'dispatch;
	}
	pc = 0x82867464; continue 'dispatch;
            }
            0x82867464 => {
    //   block [0x82867464..0x82867468)
	// 82867464: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867468; continue 'dispatch;
            }
            0x82867468 => {
    //   block [0x82867468..0x828674A8)
	// 82867468: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 8286746C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82867470: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82867474: 4BA8E4D5  bl 0x822f5948
	ctx.lr = 0x82867478;
	sub_822F5948(ctx, base);
	// 82867478: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8286747C: 4B9B7DDD  bl 0x8221f258
	ctx.lr = 0x82867480;
	sub_8221F258(ctx, base);
	// 82867480: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82867484: 419A0024  beq cr6, 0x828674a8
	if ctx.cr[6].eq {
	pc = 0x828674A8; continue 'dispatch;
	}
	// 82867488: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 8286748C: 80E10088  lwz r7, 0x88(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82867490: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82867494: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82867498: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286749C: 4BEFA605  bl 0x82761aa0
	ctx.lr = 0x828674A0;
	sub_82761AA0(ctx, base);
	// 828674A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828674A4: 48000008  b 0x828674ac
	pc = 0x828674AC; continue 'dispatch;
            }
            0x828674A8 => {
    //   block [0x828674A8..0x828674AC)
	// 828674A8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	pc = 0x828674AC; continue 'dispatch;
            }
            0x828674AC => {
    //   block [0x828674AC..0x828674CC)
	// 828674AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828674B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828674B4: 419A0018  beq cr6, 0x828674cc
	if ctx.cr[6].eq {
	pc = 0x828674CC; continue 'dispatch;
	}
	// 828674B8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828674BC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828674C0: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 828674C4: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828674C8: 41980008  blt cr6, 0x828674d0
	if ctx.cr[6].lt {
	pc = 0x828674D0; continue 'dispatch;
	}
	pc = 0x828674CC; continue 'dispatch;
            }
            0x828674CC => {
    //   block [0x828674CC..0x828674D0)
	// 828674CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828674D0; continue 'dispatch;
            }
            0x828674D0 => {
    //   block [0x828674D0..0x8286750C)
	// 828674D0: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828674D4: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 828674D8: 4BA0BB81  bl 0x82273058
	ctx.lr = 0x828674DC;
	sub_82273058(ctx, base);
	// 828674DC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828674E0: 4B9B7D79  bl 0x8221f258
	ctx.lr = 0x828674E4;
	sub_8221F258(ctx, base);
	// 828674E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828674E8: 419A0070  beq cr6, 0x82867558
	if ctx.cr[6].eq {
	pc = 0x82867558; continue 'dispatch;
	}
	// 828674EC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828674F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828674F4: 419A0018  beq cr6, 0x8286750c
	if ctx.cr[6].eq {
	pc = 0x8286750C; continue 'dispatch;
	}
	// 828674F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828674FC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82867500: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 82867504: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82867508: 41980008  blt cr6, 0x82867510
	if ctx.cr[6].lt {
	pc = 0x82867510; continue 'dispatch;
	}
	pc = 0x8286750C; continue 'dispatch;
            }
            0x8286750C => {
    //   block [0x8286750C..0x82867510)
	// 8286750C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867510; continue 'dispatch;
            }
            0x82867510 => {
    //   block [0x82867510..0x82867534)
	// 82867510: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867514: 7CEAD82E  lwzx r7, r10, r27
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82867518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286751C: 419A0018  beq cr6, 0x82867534
	if ctx.cr[6].eq {
	pc = 0x82867534; continue 'dispatch;
	}
	// 82867520: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867524: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82867528: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 8286752C: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82867530: 41980008  blt cr6, 0x82867538
	if ctx.cr[6].lt {
	pc = 0x82867538; continue 'dispatch;
	}
	pc = 0x82867534; continue 'dispatch;
            }
            0x82867534 => {
    //   block [0x82867534..0x82867538)
	// 82867534: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867538; continue 'dispatch;
            }
            0x82867538 => {
    //   block [0x82867538..0x82867558)
	// 82867538: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 8286753C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82867540: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82867544: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82867548: 80AB0020  lwz r5, 0x20(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8286754C: 4BEFA555  bl 0x82761aa0
	ctx.lr = 0x82867550;
	sub_82761AA0(ctx, base);
	// 82867550: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82867554: 48000008  b 0x8286755c
	pc = 0x8286755C; continue 'dispatch;
            }
            0x82867558 => {
    //   block [0x82867558..0x8286755C)
	// 82867558: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	pc = 0x8286755C; continue 'dispatch;
            }
            0x8286755C => {
    //   block [0x8286755C..0x8286757C)
	// 8286755C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867564: 419A0018  beq cr6, 0x8286757c
	if ctx.cr[6].eq {
	pc = 0x8286757C; continue 'dispatch;
	}
	// 82867568: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286756C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82867570: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 82867574: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82867578: 41980008  blt cr6, 0x82867580
	if ctx.cr[6].lt {
	pc = 0x82867580; continue 'dispatch;
	}
	pc = 0x8286757C; continue 'dispatch;
            }
            0x8286757C => {
    //   block [0x8286757C..0x82867580)
	// 8286757C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867580; continue 'dispatch;
            }
            0x82867580 => {
    //   block [0x82867580..0x828675AC)
	// 82867580: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82867584: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 82867588: 4BA0BAD1  bl 0x82273058
	ctx.lr = 0x8286758C;
	sub_82273058(ctx, base);
	// 8286758C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867594: 419A0018  beq cr6, 0x828675ac
	if ctx.cr[6].eq {
	pc = 0x828675AC; continue 'dispatch;
	}
	// 82867598: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286759C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828675A0: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 828675A4: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828675A8: 41980008  blt cr6, 0x828675b0
	if ctx.cr[6].lt {
	pc = 0x828675B0; continue 'dispatch;
	}
	pc = 0x828675AC; continue 'dispatch;
            }
            0x828675AC => {
    //   block [0x828675AC..0x828675B0)
	// 828675AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828675B0; continue 'dispatch;
            }
            0x828675B0 => {
    //   block [0x828675B0..0x828675D4)
	// 828675B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828675B4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828675B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828675BC: 419A0018  beq cr6, 0x828675d4
	if ctx.cr[6].eq {
	pc = 0x828675D4; continue 'dispatch;
	}
	// 828675C0: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828675C4: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 828675C8: 7CE8C3D6  divw r7, r8, r24
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[24].s32;
	// 828675CC: 7F1A3840  cmplw cr6, r26, r7
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828675D0: 41980008  blt cr6, 0x828675d8
	if ctx.cr[6].lt {
	pc = 0x828675D8; continue 'dispatch;
	}
	pc = 0x828675D4; continue 'dispatch;
            }
            0x828675D4 => {
    //   block [0x828675D4..0x828675D8)
	// 828675D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828675D8; continue 'dispatch;
            }
            0x828675D8 => {
    //   block [0x828675D8..0x82867614)
	// 828675D8: 7FAADA14  add r29, r10, r27
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 828675DC: 83CB001C  lwz r30, 0x1c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828675E0: 838B0018  lwz r28, 0x18(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828675E4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828675E8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828675EC: 419A0028  beq cr6, 0x82867614
	if ctx.cr[6].eq {
	pc = 0x82867614; continue 'dispatch;
	}
	// 828675F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828675F4: 4B950525  bl 0x821b7b18
	ctx.lr = 0x828675F8;
	sub_821B7B18(ctx, base);
	// 828675F8: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828675FC: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82867600: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82867604: 419A0010  beq cr6, 0x82867614
	if ctx.cr[6].eq {
	pc = 0x82867614; continue 'dispatch;
	}
	// 82867608: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286760C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82867610: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82867614; continue 'dispatch;
            }
            0x82867614 => {
    //   block [0x82867614..0x82867624)
	// 82867614: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82867618: 4B950501  bl 0x821b7b18
	ctx.lr = 0x8286761C;
	sub_821B7B18(ctx, base);
	// 8286761C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82867620: 4B9504F9  bl 0x821b7b18
	ctx.lr = 0x82867624;
	sub_821B7B18(ctx, base);
	pc = 0x82867624; continue 'dispatch;
            }
            0x82867624 => {
    //   block [0x82867624..0x82867644)
	// 82867624: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82867628: 4B9504F1  bl 0x821b7b18
	ctx.lr = 0x8286762C;
	sub_821B7B18(ctx, base);
	// 8286762C: 81710018  lwz r11, 0x18(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(24 as u32) ) } as u64;
	// 82867630: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82867634: 3AF70014  addi r23, r23, 0x14
	ctx.r[23].s64 = ctx.r[23].s64 + 20;
	// 82867638: 3B7B003C  addi r27, r27, 0x3c
	ctx.r[27].s64 = ctx.r[27].s64 + 60;
	// 8286763C: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82867640: 4198F928  blt cr6, 0x82866f68
	if ctx.cr[6].lt {
	pc = 0x82866F68; continue 'dispatch;
	}
	pc = 0x82867644; continue 'dispatch;
            }
            0x82867644 => {
    //   block [0x82867644..0x82867658)
	// 82867644: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82867648: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 8286764C: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 82867650: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82867654: 48441DD4  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            0x82867658 => {
    //   block [0x82867658..0x8286766C)
	// 82867658: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8286765C: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 82867660: CBC1FF68  lfd f30, -0x98(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 82867664: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82867668: 48441DC0  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82867670 size=564
    let mut pc: u32 = 0x82867670;
    'dispatch: loop {
        match pc {
            0x82867670 => {
    //   block [0x82867670..0x828676F0)
	// 82867670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867674: 48441D91  bl 0x82ca9404
	ctx.lr = 0x82867678;
	sub_82CA93D0(ctx, base);
	// 82867678: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286767C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82867680: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82867684: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82867688: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286768C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82867690: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82867694: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82867698: 4B9C5839  bl 0x8222ced0
	ctx.lr = 0x8286769C;
	sub_8222CED0(ctx, base);
	// 8286769C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828676A0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828676A4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828676A8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828676AC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828676B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828676B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828676B8: 4BA1C679  bl 0x82283d30
	ctx.lr = 0x828676BC;
	sub_82283D30(ctx, base);
	// 828676BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828676C0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828676C4: 4BA0B995  bl 0x82273058
	ctx.lr = 0x828676C8;
	sub_82273058(ctx, base);
	// 828676C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828676CC: 4B9AD70D  bl 0x82214dd8
	ctx.lr = 0x828676D0;
	sub_82214DD8(ctx, base);
	// 828676D0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828676D4: 409A0024  bne cr6, 0x828676f8
	if !ctx.cr[6].eq {
	pc = 0x828676F8; continue 'dispatch;
	}
	// 828676D8: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828676DC: 4BEF924D  bl 0x82760928
	ctx.lr = 0x828676E0;
	sub_82760928(ctx, base);
	// 828676E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828676E4: 419A000C  beq cr6, 0x828676f0
	if ctx.cr[6].eq {
	pc = 0x828676F0; continue 'dispatch;
	}
	// 828676E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828676EC: 99630025  stb r11, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	pc = 0x828676F0; continue 'dispatch;
            }
            0x828676F0 => {
    //   block [0x828676F0..0x828676F8)
	// 828676F0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828676F4: 419A01A8  beq cr6, 0x8286789c
	if ctx.cr[6].eq {
	pc = 0x8286789C; continue 'dispatch;
	}
	pc = 0x828676F8; continue 'dispatch;
            }
            0x828676F8 => {
    //   block [0x828676F8..0x82867738)
	// 828676F8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828676FC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82867700: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82867704: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82867708: 419A00F4  beq cr6, 0x828677fc
	if ctx.cr[6].eq {
	pc = 0x828677FC; continue 'dispatch;
	}
	// 8286770C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82867710: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82867714: 419A0024  beq cr6, 0x82867738
	if ctx.cr[6].eq {
	pc = 0x82867738; continue 'dispatch;
	}
	// 82867718: 894A0061  lbz r10, 0x61(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(97 as u32) ) } as u64;
	// 8286771C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82867720: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82867724: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82867728: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286772C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82867730: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82867734: 480000CC  b 0x82867800
	pc = 0x82867800; continue 'dispatch;
            }
            0x82867738 => {
    //   block [0x82867738..0x82867754)
	// 82867738: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286773C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82867740: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82867744: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82867748: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286774C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82867750: 40810054  ble 0x828677a4
	if !ctx.cr[0].gt {
	pc = 0x828677A4; continue 'dispatch;
	}
	pc = 0x82867754; continue 'dispatch;
            }
            0x82867754 => {
    //   block [0x82867754..0x82867774)
	// 82867754: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82867758: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286775C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82867760: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867764: 2F070061  cmpwi cr6, r7, 0x61
	ctx.cr[6].compare_i32(ctx.r[7].s32, 97, &mut ctx.xer);
	// 82867768: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286776C: 41980008  blt cr6, 0x82867774
	if ctx.cr[6].lt {
	pc = 0x82867774; continue 'dispatch;
	}
	// 82867770: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82867774; continue 'dispatch;
            }
            0x82867774 => {
    //   block [0x82867774..0x82867790)
	// 82867774: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82867778: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286777C: 419A0014  beq cr6, 0x82867790
	if ctx.cr[6].eq {
	pc = 0x82867790; continue 'dispatch;
	}
	// 82867780: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82867784: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82867788: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286778C: 4800000C  b 0x82867798
	pc = 0x82867798; continue 'dispatch;
            }
            0x82867790 => {
    //   block [0x82867790..0x82867798)
	// 82867790: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82867794: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82867798; continue 'dispatch;
            }
            0x82867798 => {
    //   block [0x82867798..0x828677A4)
	// 82867798: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286779C: 4199FFB8  bgt cr6, 0x82867754
	if ctx.cr[6].gt {
	pc = 0x82867754; continue 'dispatch;
	}
	// 828677A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828677A4; continue 'dispatch;
            }
            0x828677A4 => {
    //   block [0x828677A4..0x828677C0)
	// 828677A4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828677A8: 419A0040  beq cr6, 0x828677e8
	if ctx.cr[6].eq {
	pc = 0x828677E8; continue 'dispatch;
	}
	// 828677AC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828677B0: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 828677B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828677B8: 41990008  bgt cr6, 0x828677c0
	if ctx.cr[6].gt {
	pc = 0x828677C0; continue 'dispatch;
	}
	// 828677BC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828677C0; continue 'dispatch;
            }
            0x828677C0 => {
    //   block [0x828677C0..0x828677E8)
	// 828677C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828677C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828677C8: 409A0020  bne cr6, 0x828677e8
	if !ctx.cr[6].eq {
	pc = 0x828677E8; continue 'dispatch;
	}
	// 828677CC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828677D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828677D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828677D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828677DC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828677E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828677E4: 4800001C  b 0x82867800
	pc = 0x82867800; continue 'dispatch;
            }
            0x828677E8 => {
    //   block [0x828677E8..0x828677FC)
	// 828677E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828677EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828677F0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828677F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828677F8: 48000008  b 0x82867800
	pc = 0x82867800; continue 'dispatch;
            }
            0x828677FC => {
    //   block [0x828677FC..0x82867800)
	// 828677FC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82867800; continue 'dispatch;
            }
            0x82867800 => {
    //   block [0x82867800..0x82867840)
	// 82867800: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82867804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867808: 419A0094  beq cr6, 0x8286789c
	if ctx.cr[6].eq {
	pc = 0x8286789C; continue 'dispatch;
	}
	// 8286780C: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867810: 4BEF9829  bl 0x82761038
	ctx.lr = 0x82867814;
	sub_82761038(ctx, base);
	// 82867814: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867818: FCE00890  fmr f7, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[7].f64 = ctx.f[1].f64;
	// 8286781C: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82867820: 4BA6BE29  bl 0x822d3648
	ctx.lr = 0x82867824;
	sub_822D3648(ctx, base);
	// 82867824: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82867828: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 8286782C: C1AB9484  lfs f13, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82867830: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 82867834: C00A3710  lfs f0, 0x3710(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82867838: 419A0008  beq cr6, 0x82867840
	if ctx.cr[6].eq {
	pc = 0x82867840; continue 'dispatch;
	}
	// 8286783C: EC070824  fdivs f0, f7, f1
	ctx.f[0].f64 = ((ctx.f[7].f64 / ctx.f[1].f64) as f32) as f64;
	pc = 0x82867840; continue 'dispatch;
            }
            0x82867840 => {
    //   block [0x82867840..0x8286789C)
	// 82867840: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82867844: 41980058  blt cr6, 0x8286789c
	if ctx.cr[6].lt {
	pc = 0x8286789C; continue 'dispatch;
	}
	// 82867848: 2F1D0006  cmpwi cr6, r29, 6
	ctx.cr[6].compare_i32(ctx.r[29].s32, 6, &mut ctx.xer);
	// 8286784C: 40980050  bge cr6, 0x8286789c
	if !ctx.cr[6].lt {
	pc = 0x8286789C; continue 'dispatch;
	}
	// 82867850: FD800050  fneg f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82867854: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82867858: 395D000C  addi r10, r29, 0xc
	ctx.r[10].s64 = ctx.r[29].s64 + 12;
	// 8286785C: 392B0E68  addi r9, r11, 0xe68
	ctx.r[9].s64 = ctx.r[11].s64 + 3688;
	// 82867860: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82867864: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82867868: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 8286786C: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 82867870: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 82867874: 2F1D0006  cmpwi cr6, r29, 6
	ctx.cr[6].compare_i32(ctx.r[29].s32, 6, &mut ctx.xer);
	// 82867878: 7CC42B78  or r4, r6, r5
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 8286787C: 7D69242E  lfsx f11, r9, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82867880: FD4B036E  fsel f10, f11, f13, f0
	ctx.f[10].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 82867884: 7D48FD2E  stfsx f10, r8, r31
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 82867888: 40980014  bge cr6, 0x8286789c
	if !ctx.cr[6].lt {
	pc = 0x8286789C; continue 'dispatch;
	}
	// 8286788C: 397D000C  addi r11, r29, 0xc
	ctx.r[11].s64 = ctx.r[29].s64 + 12;
	// 82867890: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82867894: 7C0AFC2E  lfsx f0, r10, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82867898: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	pc = 0x8286789C; continue 'dispatch;
            }
            0x8286789C => {
    //   block [0x8286789C..0x828678A4)
	// 8286789C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828678A0: 48441BB4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828678A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828678A8 size=204
    let mut pc: u32 = 0x828678A8;
    'dispatch: loop {
        match pc {
            0x828678A8 => {
    //   block [0x828678A8..0x82867974)
	// 828678A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828678AC: 48441B5D  bl 0x82ca9408
	ctx.lr = 0x828678B0;
	sub_82CA93D0(ctx, base);
	// 828678B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828678B4: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 828678B8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828678BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828678C0: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 828678C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828678C8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828678CC: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828678D0: 3BDF0054  addi r30, r31, 0x54
	ctx.r[30].s64 = ctx.r[31].s64 + 84;
	// 828678D4: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828678D8: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 828678DC: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828678E0: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 828678E4: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 828678E8: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82867978 size=236
    let mut pc: u32 = 0x82867978;
    'dispatch: loop {
        match pc {
            0x82867978 => {
    //   block [0x82867978..0x828679B0)
	// 82867978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286797C: 48441A91  bl 0x82ca940c
	ctx.lr = 0x82867980;
	sub_82CA93D0(ctx, base);
	// 82867980: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867984: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82867988: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8286798C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867990: 419A0044  beq cr6, 0x828679d4
	if ctx.cr[6].eq {
	pc = 0x828679D4; continue 'dispatch;
	}
	// 82867994: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 82867998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286799C: 419A0014  beq cr6, 0x828679b0
	if ctx.cr[6].eq {
	pc = 0x828679B0; continue 'dispatch;
	}
	// 828679A0: 815D0030  lwz r10, 0x30(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 828679A4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828679A8: 7D2A1E71  srawi. r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828679AC: 40820008  bne 0x828679b4
	if !ctx.cr[0].eq {
	pc = 0x828679B4; continue 'dispatch;
	}
	pc = 0x828679B0; continue 'dispatch;
            }
            0x828679B0 => {
    //   block [0x828679B0..0x828679B4)
	// 828679B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828679B4; continue 'dispatch;
            }
            0x828679B4 => {
    //   block [0x828679B4..0x828679D4)
	// 828679B4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828679B8: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828679BC: 4BA6BC8D  bl 0x822d3648
	ctx.lr = 0x828679C0;
	sub_822D3648(ctx, base);
	// 828679C0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828679C4: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 828679C8: C00AFE50  lfs f0, -0x1b0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828679CC: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 828679D0: 4800000C  b 0x828679dc
	pc = 0x828679DC; continue 'dispatch;
            }
            0x828679D4 => {
    //   block [0x828679D4..0x828679DC)
	// 828679D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828679D8: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x828679DC; continue 'dispatch;
            }
            0x828679DC => {
    //   block [0x828679DC..0x828679F8)
	// 828679DC: D01D0038  stfs f0, 0x38(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828679E0: 83FD002C  lwz r31, 0x2c(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 828679E4: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 828679E8: 3BDD0028  addi r30, r29, 0x28
	ctx.r[30].s64 = ctx.r[29].s64 + 40;
	// 828679EC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828679F0: 40990008  ble cr6, 0x828679f8
	if !ctx.cr[6].gt {
	pc = 0x828679F8; continue 'dispatch;
	}
	// 828679F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828679F8; continue 'dispatch;
            }
            0x828679F8 => {
    //   block [0x828679F8..0x82867A0C)
	// 828679F8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828679FC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867A00: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82867A04: 40990008  ble cr6, 0x82867a0c
	if !ctx.cr[6].gt {
	pc = 0x82867A0C; continue 'dispatch;
	}
	// 82867A08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867A0C; continue 'dispatch;
            }
            0x82867A0C => {
    //   block [0x82867A0C..0x82867A18)
	// 82867A0C: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82867A10: 419A0008  beq cr6, 0x82867a18
	if ctx.cr[6].eq {
	pc = 0x82867A18; continue 'dispatch;
	}
	// 82867A14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867A18; continue 'dispatch;
            }
            0x82867A18 => {
    //   block [0x82867A18..0x82867A2C)
	// 82867A18: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82867A1C: 419A0040  beq cr6, 0x82867a5c
	if ctx.cr[6].eq {
	pc = 0x82867A5C; continue 'dispatch;
	}
	// 82867A20: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82867A24: 41980008  blt cr6, 0x82867a2c
	if ctx.cr[6].lt {
	pc = 0x82867A2C; continue 'dispatch;
	}
	// 82867A28: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867A2C; continue 'dispatch;
            }
            0x82867A2C => {
    //   block [0x82867A2C..0x82867A54)
	// 82867A2C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867A30: C03D0038  lfs f1, 0x38(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82867A34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867A38: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82867A3C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82867A40: 4E800421  bctrl
	ctx.lr = 0x82867A44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867A44: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867A48: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82867A4C: 41980008  blt cr6, 0x82867a54
	if ctx.cr[6].lt {
	pc = 0x82867A54; continue 'dispatch;
	}
	// 82867A50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x82867A54 => {
    //   block [0x82867A54..0x82867A5C)
	// 82867A54: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82867A58: 4BFFFFA0  b 0x828679f8
	pc = 0x828679F8; continue 'dispatch;
            }
            0x82867A5C => {
    //   block [0x82867A5C..0x82867A64)
	// 82867A5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82867A60: 484419FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867A68 size=88
    let mut pc: u32 = 0x82867A68;
    'dispatch: loop {
        match pc {
            0x82867A68 => {
    //   block [0x82867A68..0x82867AC0)
	// 82867A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867A6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867A70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82867A74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867A78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82867A7C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82867A80: 4BB74DA9  bl 0x823dc828
	ctx.lr = 0x82867A84;
	sub_823DC828(ctx, base);
	// 82867A84: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82867A88: 4B950091  bl 0x821b7b18
	ctx.lr = 0x82867A8C;
	sub_821B7B18(ctx, base);
	// 82867A8C: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82867A90: 4B950089  bl 0x821b7b18
	ctx.lr = 0x82867A94;
	sub_821B7B18(ctx, base);
	// 82867A94: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82867A98: 4B950081  bl 0x821b7b18
	ctx.lr = 0x82867A9C;
	sub_821B7B18(ctx, base);
	// 82867A9C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82867AA0: 4B950079  bl 0x821b7b18
	ctx.lr = 0x82867AA4;
	sub_821B7B18(ctx, base);
	// 82867AA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867AA8: 4B950071  bl 0x821b7b18
	ctx.lr = 0x82867AAC;
	sub_821B7B18(ctx, base);
	// 82867AAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82867AB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82867AB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82867AB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82867ABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867AC0 size=300
    let mut pc: u32 = 0x82867AC0;
    'dispatch: loop {
        match pc {
            0x82867AC0 => {
    //   block [0x82867AC0..0x82867AEC)
	// 82867AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867AC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867AC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82867ACC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867AD0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867AD4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82867AD8: 3920003C  li r9, 0x3c
	ctx.r[9].s64 = 60;
	// 82867ADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867AE0: 409A000C  bne cr6, 0x82867aec
	if !ctx.cr[6].eq {
	pc = 0x82867AEC; continue 'dispatch;
	}
	// 82867AE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82867AE8: 48000010  b 0x82867af8
	pc = 0x82867AF8; continue 'dispatch;
            }
            0x82867AEC => {
    //   block [0x82867AEC..0x82867AF8)
	// 82867AEC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867AF0: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82867AF4: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82867AF8; continue 'dispatch;
            }
            0x82867AF8 => {
    //   block [0x82867AF8..0x82867B10)
	// 82867AF8: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82867AFC: 4098004C  bge cr6, 0x82867b48
	if !ctx.cr[6].lt {
	pc = 0x82867B48; continue 'dispatch;
	}
	// 82867B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867B04: 409A000C  bne cr6, 0x82867b10
	if !ctx.cr[6].eq {
	pc = 0x82867B10; continue 'dispatch;
	}
	// 82867B08: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82867B0C: 48000010  b 0x82867b1c
	pc = 0x82867B1C; continue 'dispatch;
            }
            0x82867B10 => {
    //   block [0x82867B10..0x82867B1C)
	// 82867B10: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867B14: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82867B18: 7D284BD6  divw r9, r8, r9
	ctx.r[9].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82867B1C; continue 'dispatch;
            }
            0x82867B1C => {
    //   block [0x82867B1C..0x82867B2C)
	// 82867B1C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867B20: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82867B24: 40990008  ble cr6, 0x82867b2c
	if !ctx.cr[6].gt {
	pc = 0x82867B2C; continue 'dispatch;
	}
	// 82867B28: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867B2C; continue 'dispatch;
            }
            0x82867B2C => {
    //   block [0x82867B2C..0x82867B48)
	// 82867B2C: 7CA92050  subf r5, r9, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82867B30: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82867B34: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82867B38: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82867B3C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82867B40: 480001E1  bl 0x82867d20
	ctx.lr = 0x82867B44;
	sub_82867D20(ctx, base);
	// 82867B44: 4800008C  b 0x82867bd0
	pc = 0x82867BD0; continue 'dispatch;
            }
            0x82867B48 => {
    //   block [0x82867B48..0x82867B70)
	// 82867B48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867B4C: 419A0084  beq cr6, 0x82867bd0
	if ctx.cr[6].eq {
	pc = 0x82867BD0; continue 'dispatch;
	}
	// 82867B50: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867B54: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82867B58: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 82867B5C: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82867B60: 40980070  bge cr6, 0x82867bd0
	if !ctx.cr[6].lt {
	pc = 0x82867BD0; continue 'dispatch;
	}
	// 82867B64: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82867B68: 40990008  ble cr6, 0x82867b70
	if !ctx.cr[6].gt {
	pc = 0x82867B70; continue 'dispatch;
	}
	// 82867B6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867B70; continue 'dispatch;
            }
            0x82867B70 => {
    //   block [0x82867B70..0x82867B84)
	// 82867B70: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82867B74: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82867B78: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82867B7C: 40990008  ble cr6, 0x82867b84
	if !ctx.cr[6].gt {
	pc = 0x82867B84; continue 'dispatch;
	}
	// 82867B80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867B84; continue 'dispatch;
            }
            0x82867B84 => {
    //   block [0x82867B84..0x82867BB4)
	// 82867B84: 1D44003C  mulli r10, r4, 0x3c
	ctx.r[10].s32 = ((ctx.r[4].s32 as i64 * 60 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82867B88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82867B8C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867B90: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82867B94: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82867B98: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82867B9C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82867BA0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82867BA4: 41990010  bgt cr6, 0x82867bb4
	if ctx.cr[6].gt {
	pc = 0x82867BB4; continue 'dispatch;
	}
	// 82867BA8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867BAC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82867BB0: 40980008  bge cr6, 0x82867bb8
	if !ctx.cr[6].lt {
	pc = 0x82867BB8; continue 'dispatch;
	}
	pc = 0x82867BB4; continue 'dispatch;
            }
            0x82867BB4 => {
    //   block [0x82867BB4..0x82867BB8)
	// 82867BB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867BB8; continue 'dispatch;
            }
            0x82867BB8 => {
    //   block [0x82867BB8..0x82867BD0)
	// 82867BB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82867BBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82867BC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82867BC4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82867BC8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82867BCC: 48000025  bl 0x82867bf0
	ctx.lr = 0x82867BD0;
	sub_82867BF0(ctx, base);
	pc = 0x82867BD0; continue 'dispatch;
            }
            0x82867BD0 => {
    //   block [0x82867BD0..0x82867BEC)
	// 82867BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867BD4: 4BFFFE95  bl 0x82867a68
	ctx.lr = 0x82867BD8;
	sub_82867A68(ctx, base);
	// 82867BD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82867BDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82867BE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82867BE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82867BE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867BF0 size=172
    let mut pc: u32 = 0x82867BF0;
    'dispatch: loop {
        match pc {
            0x82867BF0 => {
    //   block [0x82867BF0..0x82867C28)
	// 82867BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867BF4: 48441809  bl 0x82ca93fc
	ctx.lr = 0x82867BF8;
	sub_82CA93D0(ctx, base);
	// 82867BF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867BFC: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82867C00: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82867C04: FB2100B0  std r25, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[25].u64 ) };
	// 82867C08: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82867C0C: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82867C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867C14: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82867C18: 419A0010  beq cr6, 0x82867c28
	if ctx.cr[6].eq {
	pc = 0x82867C28; continue 'dispatch;
	}
	// 82867C1C: 814100B8  lwz r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82867C20: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82867C24: 419A0008  beq cr6, 0x82867c2c
	if ctx.cr[6].eq {
	pc = 0x82867C2C; continue 'dispatch;
	}
	pc = 0x82867C28; continue 'dispatch;
            }
            0x82867C28 => {
    //   block [0x82867C28..0x82867C2C)
	// 82867C28: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82867C2C; continue 'dispatch;
            }
            0x82867C2C => {
    //   block [0x82867C2C..0x82867C60)
	// 82867C2C: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82867C30: 83E100BC  lwz r31, 0xbc(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82867C34: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82867C38: 419A0054  beq cr6, 0x82867c8c
	if ctx.cr[6].eq {
	pc = 0x82867C8C; continue 'dispatch;
	}
	// 82867C3C: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867C40: 3960003C  li r11, 0x3c
	ctx.r[11].s64 = 60;
	// 82867C44: 7D3FF050  subf r9, r31, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82867C48: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82867C4C: 7D095BD6  divw r8, r9, r11
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 82867C50: 1D68003C  mulli r11, r8, 0x3c
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * 60 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82867C54: 7F6B5214  add r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82867C58: 419A0020  beq cr6, 0x82867c78
	if ctx.cr[6].eq {
	pc = 0x82867C78; continue 'dispatch;
	}
	// 82867C5C: 7F9F5050  subf r28, r31, r10
	ctx.r[28].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	pc = 0x82867C60; continue 'dispatch;
            }
            0x82867C60 => {
    //   block [0x82867C60..0x82867C78)
	// 82867C60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82867C64: 7C7CFA14  add r3, r28, r31
	ctx.r[3].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 82867C68: 48000629  bl 0x82868290
	ctx.lr = 0x82867C6C;
	sub_82868290(ctx, base);
	// 82867C6C: 3BFF003C  addi r31, r31, 0x3c
	ctx.r[31].s64 = ctx.r[31].s64 + 60;
	// 82867C70: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82867C74: 409AFFEC  bne cr6, 0x82867c60
	if !ctx.cr[6].eq {
	pc = 0x82867C60; continue 'dispatch;
	}
	pc = 0x82867C78; continue 'dispatch;
            }
            0x82867C78 => {
    //   block [0x82867C78..0x82867C8C)
	// 82867C78: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82867C7C: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867C80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82867C84: 4800001D  bl 0x82867ca0
	ctx.lr = 0x82867C88;
	sub_82867CA0(ctx, base);
	// 82867C88: 937D0008  stw r27, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82867C8C; continue 'dispatch;
            }
            0x82867C8C => {
    //   block [0x82867C8C..0x82867C9C)
	// 82867C8C: FB3A0000  std r25, 0(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[25].u64 ) };
	// 82867C90: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82867C94: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82867C98: 484417B4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867CA0 size=124
    let mut pc: u32 = 0x82867CA0;
    'dispatch: loop {
        match pc {
            0x82867CA0 => {
    //   block [0x82867CA0..0x82867CC4)
	// 82867CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867CA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867CA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82867CAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82867CB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867CB4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82867CB8: 7F04F040  cmplw cr6, r4, r30
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82867CBC: 419A0048  beq cr6, 0x82867d04
	if ctx.cr[6].eq {
	pc = 0x82867D04; continue 'dispatch;
	}
	// 82867CC0: 3BE40020  addi r31, r4, 0x20
	ctx.r[31].s64 = ctx.r[4].s64 + 32;
	pc = 0x82867CC4; continue 'dispatch;
            }
            0x82867CC4 => {
    //   block [0x82867CC4..0x82867D04)
	// 82867CC4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82867CC8: 4BB74B61  bl 0x823dc828
	ctx.lr = 0x82867CCC;
	sub_823DC828(ctx, base);
	// 82867CCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867CD0: 4B94FE49  bl 0x821b7b18
	ctx.lr = 0x82867CD4;
	sub_821B7B18(ctx, base);
	// 82867CD4: 387FFFF8  addi r3, r31, -8
	ctx.r[3].s64 = ctx.r[31].s64 + -8;
	// 82867CD8: 4B94FE41  bl 0x821b7b18
	ctx.lr = 0x82867CDC;
	sub_821B7B18(ctx, base);
	// 82867CDC: 387FFFF0  addi r3, r31, -0x10
	ctx.r[3].s64 = ctx.r[31].s64 + -16;
	// 82867CE0: 4B94FE39  bl 0x821b7b18
	ctx.lr = 0x82867CE4;
	sub_821B7B18(ctx, base);
	// 82867CE4: 387FFFE8  addi r3, r31, -0x18
	ctx.r[3].s64 = ctx.r[31].s64 + -24;
	// 82867CE8: 4B94FE31  bl 0x821b7b18
	ctx.lr = 0x82867CEC;
	sub_821B7B18(ctx, base);
	// 82867CEC: 387FFFE0  addi r3, r31, -0x20
	ctx.r[3].s64 = ctx.r[31].s64 + -32;
	// 82867CF0: 4B94FE29  bl 0x821b7b18
	ctx.lr = 0x82867CF4;
	sub_821B7B18(ctx, base);
	// 82867CF4: 3BFF003C  addi r31, r31, 0x3c
	ctx.r[31].s64 = ctx.r[31].s64 + 60;
	// 82867CF8: 397FFFE0  addi r11, r31, -0x20
	ctx.r[11].s64 = ctx.r[31].s64 + -32;
	// 82867CFC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82867D00: 409AFFC4  bne cr6, 0x82867cc4
	if !ctx.cr[6].eq {
	pc = 0x82867CC4; continue 'dispatch;
	}
	pc = 0x82867D04; continue 'dispatch;
            }
            0x82867D04 => {
    //   block [0x82867D04..0x82867D1C)
	// 82867D04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82867D08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82867D0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82867D10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82867D14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82867D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867D20 size=940
    let mut pc: u32 = 0x82867D20;
    'dispatch: loop {
        match pc {
            0x82867D20 => {
    //   block [0x82867D20..0x82867D5C)
	// 82867D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867D24: 484416D1  bl 0x82ca93f4
	ctx.lr = 0x82867D28;
	sub_82CA93D0(ctx, base);
	// 82867D28: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867D2C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82867D30: F88100F8  std r4, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[4].u64 ) };
	// 82867D34: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82867D38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82867D3C: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82867D40: 48000401  bl 0x82868140
	ctx.lr = 0x82867D44;
	sub_82868140(ctx, base);
	// 82867D44: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867D48: 3AE0003C  li r23, 0x3c
	ctx.r[23].s64 = 60;
	// 82867D4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82867D50: 409A000C  bne cr6, 0x82867d5c
	if !ctx.cr[6].eq {
	pc = 0x82867D5C; continue 'dispatch;
	}
	// 82867D54: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82867D58: 48000010  b 0x82867d68
	pc = 0x82867D68; continue 'dispatch;
            }
            0x82867D5C => {
    //   block [0x82867D5C..0x82867D68)
	// 82867D5C: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82867D60: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82867D64: 7D09BBD6  divw r8, r9, r23
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[23].s32;
	pc = 0x82867D68; continue 'dispatch;
            }
            0x82867D68 => {
    //   block [0x82867D68..0x82867D80)
	// 82867D68: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82867D6C: 419A0350  beq cr6, 0x828680bc
	if ctx.cr[6].eq {
	pc = 0x828680BC; continue 'dispatch;
	}
	// 82867D70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82867D74: 409A000C  bne cr6, 0x82867d80
	if !ctx.cr[6].eq {
	pc = 0x82867D80; continue 'dispatch;
	}
	// 82867D78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82867D7C: 48000010  b 0x82867d8c
	pc = 0x82867D8C; continue 'dispatch;
            }
            0x82867D80 => {
    //   block [0x82867D80..0x82867D8C)
	// 82867D80: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867D84: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82867D88: 7D69BBD6  divw r11, r9, r23
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[23].s32;
	pc = 0x82867D8C; continue 'dispatch;
            }
            0x82867D8C => {
    //   block [0x82867D8C..0x82867DB4)
	// 82867D8C: 3D200444  lis r9, 0x444
	ctx.r[9].s64 = 71565312;
	// 82867D90: 61294444  ori r9, r9, 0x4444
	ctx.r[9].u64 = ctx.r[9].u64 | 17476;
	// 82867D94: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82867D98: 7F07C040  cmplw cr6, r7, r24
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82867D9C: 40980018  bge cr6, 0x82867db4
	if !ctx.cr[6].lt {
	pc = 0x82867DB4; continue 'dispatch;
	}
	// 82867DA0: 4BC8CD31  bl 0x824f4ad0
	ctx.lr = 0x82867DA4;
	sub_824F4AD0(ctx, base);
	// 82867DA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82867DA8: 4BFFFCC1  bl 0x82867a68
	ctx.lr = 0x82867DAC;
	sub_82867A68(ctx, base);
	// 82867DAC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82867DB0: 48441694  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82867DB4 => {
    //   block [0x82867DB4..0x82867DC4)
	// 82867DB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82867DB8: 409A000C  bne cr6, 0x82867dc4
	if !ctx.cr[6].eq {
	pc = 0x82867DC4; continue 'dispatch;
	}
	// 82867DBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82867DC0: 48000010  b 0x82867dd0
	pc = 0x82867DD0; continue 'dispatch;
            }
            0x82867DC4 => {
    //   block [0x82867DC4..0x82867DD0)
	// 82867DC4: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867DC8: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82867DCC: 7D67BBD6  divw r11, r7, r23
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[23].s32;
	pc = 0x82867DD0; continue 'dispatch;
            }
            0x82867DD0 => {
    //   block [0x82867DD0..0x82867DF4)
	// 82867DD0: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82867DD4: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82867DD8: 4098018C  bge cr6, 0x82867f64
	if !ctx.cr[6].lt {
	pc = 0x82867F64; continue 'dispatch;
	}
	// 82867DDC: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82867DE0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82867DE4: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82867DE8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82867DEC: 41980008  blt cr6, 0x82867df4
	if ctx.cr[6].lt {
	pc = 0x82867DF4; continue 'dispatch;
	}
	// 82867DF0: 7F4B4214  add r26, r11, r8
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	pc = 0x82867DF4; continue 'dispatch;
            }
            0x82867DF4 => {
    //   block [0x82867DF4..0x82867E04)
	// 82867DF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82867DF8: 409A000C  bne cr6, 0x82867e04
	if !ctx.cr[6].eq {
	pc = 0x82867E04; continue 'dispatch;
	}
	// 82867DFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82867E00: 48000010  b 0x82867e10
	pc = 0x82867E10; continue 'dispatch;
            }
            0x82867E04 => {
    //   block [0x82867E04..0x82867E10)
	// 82867E04: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867E08: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82867E0C: 7D69BBD6  divw r11, r9, r23
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[23].s32;
	pc = 0x82867E10; continue 'dispatch;
            }
            0x82867E10 => {
    //   block [0x82867E10..0x82867E2C)
	// 82867E10: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82867E14: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82867E18: 40980024  bge cr6, 0x82867e3c
	if !ctx.cr[6].lt {
	pc = 0x82867E3C; continue 'dispatch;
	}
	// 82867E1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82867E20: 409A000C  bne cr6, 0x82867e2c
	if !ctx.cr[6].eq {
	pc = 0x82867E2C; continue 'dispatch;
	}
	// 82867E24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82867E28: 48000010  b 0x82867e38
	pc = 0x82867E38; continue 'dispatch;
            }
            0x82867E2C => {
    //   block [0x82867E2C..0x82867E38)
	// 82867E2C: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867E30: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82867E34: 7D6ABBD6  divw r11, r10, r23
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	pc = 0x82867E38; continue 'dispatch;
            }
            0x82867E38 => {
    //   block [0x82867E38..0x82867E3C)
	// 82867E38: 7F4BC214  add r26, r11, r24
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	pc = 0x82867E3C; continue 'dispatch;
            }
            0x82867E3C => {
    //   block [0x82867E3C..0x82867E60)
	// 82867E3C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82867E40: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82867E44: 4800028D  bl 0x828680d0
	ctx.lr = 0x82867E48;
	sub_828680D0(ctx, base);
	// 82867E48: 83D90004  lwz r30, 4(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867E4C: 838100FC  lwz r28, 0xfc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82867E50: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82867E54: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82867E58: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82867E5C: 419A0028  beq cr6, 0x82867e84
	if ctx.cr[6].eq {
	pc = 0x82867E84; continue 'dispatch;
	}
	pc = 0x82867E60; continue 'dispatch;
            }
            0x82867E60 => {
    //   block [0x82867E60..0x82867E74)
	// 82867E60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82867E64: 419A0010  beq cr6, 0x82867e74
	if ctx.cr[6].eq {
	pc = 0x82867E74; continue 'dispatch;
	}
	// 82867E68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82867E6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867E70: 480002D1  bl 0x82868140
	ctx.lr = 0x82867E74;
	sub_82868140(ctx, base);
	pc = 0x82867E74; continue 'dispatch;
            }
            0x82867E74 => {
    //   block [0x82867E74..0x82867E84)
	// 82867E74: 3BDE003C  addi r30, r30, 0x3c
	ctx.r[30].s64 = ctx.r[30].s64 + 60;
	// 82867E78: 3BFF003C  addi r31, r31, 0x3c
	ctx.r[31].s64 = ctx.r[31].s64 + 60;
	// 82867E7C: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82867E80: 409AFFE0  bne cr6, 0x82867e60
	if !ctx.cr[6].eq {
	pc = 0x82867E60; continue 'dispatch;
	}
	pc = 0x82867E84; continue 'dispatch;
            }
            0x82867E84 => {
    //   block [0x82867E84..0x82867E94)
	// 82867E84: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82867E88: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82867E8C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82867E90: 419A0024  beq cr6, 0x82867eb4
	if ctx.cr[6].eq {
	pc = 0x82867EB4; continue 'dispatch;
	}
	pc = 0x82867E94; continue 'dispatch;
            }
            0x82867E94 => {
    //   block [0x82867E94..0x82867EA8)
	// 82867E94: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82867E98: 419A0010  beq cr6, 0x82867ea8
	if ctx.cr[6].eq {
	pc = 0x82867EA8; continue 'dispatch;
	}
	// 82867E9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82867EA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82867EA4: 4800029D  bl 0x82868140
	ctx.lr = 0x82867EA8;
	sub_82868140(ctx, base);
	pc = 0x82867EA8; continue 'dispatch;
            }
            0x82867EA8 => {
    //   block [0x82867EA8..0x82867EB4)
	// 82867EA8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82867EAC: 3BDE003C  addi r30, r30, 0x3c
	ctx.r[30].s64 = ctx.r[30].s64 + 60;
	// 82867EB0: 4082FFE4  bne 0x82867e94
	if !ctx.cr[0].eq {
	pc = 0x82867E94; continue 'dispatch;
	}
	pc = 0x82867EB4; continue 'dispatch;
            }
            0x82867EB4 => {
    //   block [0x82867EB4..0x82867ED4)
	// 82867EB4: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867EB8: 1D78003C  mulli r11, r24, 0x3c
	ctx.r[11].s32 = ((ctx.r[24].s32 as i64 * 60 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82867EBC: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82867EC0: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82867EC4: 419A0034  beq cr6, 0x82867ef8
	if ctx.cr[6].eq {
	pc = 0x82867EF8; continue 'dispatch;
	}
	// 82867EC8: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82867ECC: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 82867ED0: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82867ED4; continue 'dispatch;
            }
            0x82867ED4 => {
    //   block [0x82867ED4..0x82867EE8)
	// 82867ED4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82867ED8: 419A0010  beq cr6, 0x82867ee8
	if ctx.cr[6].eq {
	pc = 0x82867EE8; continue 'dispatch;
	}
	// 82867EDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82867EE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82867EE4: 4800025D  bl 0x82868140
	ctx.lr = 0x82867EE8;
	sub_82868140(ctx, base);
	pc = 0x82867EE8; continue 'dispatch;
            }
            0x82867EE8 => {
    //   block [0x82867EE8..0x82867EF8)
	// 82867EE8: 3BFF003C  addi r31, r31, 0x3c
	ctx.r[31].s64 = ctx.r[31].s64 + 60;
	// 82867EEC: 3BDE003C  addi r30, r30, 0x3c
	ctx.r[30].s64 = ctx.r[30].s64 + 60;
	// 82867EF0: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82867EF4: 409AFFE0  bne cr6, 0x82867ed4
	if !ctx.cr[6].eq {
	pc = 0x82867ED4; continue 'dispatch;
	}
	pc = 0x82867EF8; continue 'dispatch;
            }
            0x82867EF8 => {
    //   block [0x82867EF8..0x82867F0C)
	// 82867EF8: 80990004  lwz r4, 4(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867EFC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82867F00: 409A000C  bne cr6, 0x82867f0c
	if !ctx.cr[6].eq {
	pc = 0x82867F0C; continue 'dispatch;
	}
	// 82867F04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82867F08: 48000010  b 0x82867f18
	pc = 0x82867F18; continue 'dispatch;
            }
            0x82867F0C => {
    //   block [0x82867F0C..0x82867F18)
	// 82867F0C: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867F10: 7D445850  subf r10, r4, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82867F14: 7D6ABBD6  divw r11, r10, r23
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	pc = 0x82867F18; continue 'dispatch;
            }
            0x82867F18 => {
    //   block [0x82867F18..0x82867F38)
	// 82867F18: 7FEBC214  add r31, r11, r24
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82867F1C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82867F20: 419A0018  beq cr6, 0x82867f38
	if ctx.cr[6].eq {
	pc = 0x82867F38; continue 'dispatch;
	}
	// 82867F24: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82867F28: 80B90008  lwz r5, 8(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867F2C: 4BFFFD75  bl 0x82867ca0
	ctx.lr = 0x82867F30;
	sub_82867CA0(ctx, base);
	// 82867F30: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867F34: 4B9B3E05  bl 0x8221bd38
	ctx.lr = 0x82867F38;
	sub_8221BD38(ctx, base);
	pc = 0x82867F38; continue 'dispatch;
            }
            0x82867F38 => {
    //   block [0x82867F38..0x82867F64)
	// 82867F38: 1D7F003C  mulli r11, r31, 0x3c
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 60 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82867F3C: 93790004  stw r27, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82867F40: 1D5A003C  mulli r10, r26, 0x3c
	ctx.r[10].s32 = ((ctx.r[26].s32 as i64 * 60 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82867F44: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82867F48: 7D2BDA14  add r9, r11, r27
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82867F4C: 9159000C  stw r10, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82867F50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82867F54: 91390008  stw r9, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82867F58: 4BFFFB11  bl 0x82867a68
	ctx.lr = 0x82867F5C;
	sub_82867A68(ctx, base);
	// 82867F5C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82867F60: 484414E4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82867F64 => {
    //   block [0x82867F64..0x82867F90)
	// 82867F64: 836100FC  lwz r27, 0xfc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82867F68: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867F6C: 7D7BE850  subf r11, r27, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[27].s64;
	// 82867F70: 7D4BBBD6  divw r10, r11, r23
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	// 82867F74: 7F0AC040  cmplw cr6, r10, r24
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82867F78: 409800B8  bge cr6, 0x82868030
	if !ctx.cr[6].lt {
	pc = 0x82868030; continue 'dispatch;
	}
	// 82867F7C: 1F98003C  mulli r28, r24, 0x3c
	ctx.r[28].s32 = ((ctx.r[24].s32 as i64 * 60 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 82867F80: 7FFCDA14  add r31, r28, r27
	ctx.r[31].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 82867F84: 7F1BE840  cmplw cr6, r27, r29
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82867F88: 419A002C  beq cr6, 0x82867fb4
	if ctx.cr[6].eq {
	pc = 0x82867FB4; continue 'dispatch;
	}
	// 82867F8C: 7FDCF850  subf r30, r28, r31
	ctx.r[30].s64 = ctx.r[31].s64 - ctx.r[28].s64;
	pc = 0x82867F90; continue 'dispatch;
            }
            0x82867F90 => {
    //   block [0x82867F90..0x82867FA4)
	// 82867F90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82867F94: 419A0010  beq cr6, 0x82867fa4
	if ctx.cr[6].eq {
	pc = 0x82867FA4; continue 'dispatch;
	}
	// 82867F98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82867F9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867FA0: 480001A1  bl 0x82868140
	ctx.lr = 0x82867FA4;
	sub_82868140(ctx, base);
	pc = 0x82867FA4; continue 'dispatch;
            }
            0x82867FA4 => {
    //   block [0x82867FA4..0x82867FB4)
	// 82867FA4: 3BDE003C  addi r30, r30, 0x3c
	ctx.r[30].s64 = ctx.r[30].s64 + 60;
	// 82867FA8: 3BFF003C  addi r31, r31, 0x3c
	ctx.r[31].s64 = ctx.r[31].s64 + 60;
	// 82867FAC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82867FB0: 409AFFE0  bne cr6, 0x82867f90
	if !ctx.cr[6].eq {
	pc = 0x82867F90; continue 'dispatch;
	}
	pc = 0x82867FB4; continue 'dispatch;
            }
            0x82867FB4 => {
    //   block [0x82867FB4..0x82867FCC)
	// 82867FB4: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867FB8: 7D5B5850  subf r10, r27, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 82867FBC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82867FC0: 7D2ABBD6  divw r9, r10, r23
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[23].s32;
	// 82867FC4: 7FE9C051  subf. r31, r9, r24
	ctx.r[31].s64 = ctx.r[24].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82867FC8: 41820024  beq 0x82867fec
	if ctx.cr[0].eq {
	pc = 0x82867FEC; continue 'dispatch;
	}
	pc = 0x82867FCC; continue 'dispatch;
            }
            0x82867FCC => {
    //   block [0x82867FCC..0x82867FE0)
	// 82867FCC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82867FD0: 419A0010  beq cr6, 0x82867fe0
	if ctx.cr[6].eq {
	pc = 0x82867FE0; continue 'dispatch;
	}
	// 82867FD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82867FD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82867FDC: 48000165  bl 0x82868140
	ctx.lr = 0x82867FE0;
	sub_82868140(ctx, base);
	pc = 0x82867FE0; continue 'dispatch;
            }
            0x82867FE0 => {
    //   block [0x82867FE0..0x82867FEC)
	// 82867FE0: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82867FE4: 3BDE003C  addi r30, r30, 0x3c
	ctx.r[30].s64 = ctx.r[30].s64 + 60;
	// 82867FE8: 4082FFE4  bne 0x82867fcc
	if !ctx.cr[0].eq {
	pc = 0x82867FCC; continue 'dispatch;
	}
	pc = 0x82867FEC; continue 'dispatch;
            }
            0x82867FEC => {
    //   block [0x82867FEC..0x82868008)
	// 82867FEC: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867FF0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82867FF4: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82867FF8: 7FDC5850  subf r30, r28, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82867FFC: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82868000: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82868004: 419A00B8  beq cr6, 0x828680bc
	if ctx.cr[6].eq {
	pc = 0x828680BC; continue 'dispatch;
	}
	pc = 0x82868008; continue 'dispatch;
            }
            0x82868008 => {
    //   block [0x82868008..0x82868030)
	// 82868008: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286800C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868010: 48000281  bl 0x82868290
	ctx.lr = 0x82868014;
	sub_82868290(ctx, base);
	// 82868014: 3BFF003C  addi r31, r31, 0x3c
	ctx.r[31].s64 = ctx.r[31].s64 + 60;
	// 82868018: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8286801C: 409AFFEC  bne cr6, 0x82868008
	if !ctx.cr[6].eq {
	pc = 0x82868008; continue 'dispatch;
	}
	// 82868020: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868024: 4BFFFA45  bl 0x82867a68
	ctx.lr = 0x82868028;
	sub_82867A68(ctx, base);
	// 82868028: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8286802C: 48441418  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82868030 => {
    //   block [0x82868030..0x82868048)
	// 82868030: 1F58003C  mulli r26, r24, 0x3c
	ctx.r[26].s32 = ((ctx.r[24].s32 as i64 * 60 as i64) as i32);
	ctx.r[26].s64 = ctx.r[26].s32 as i64;
	// 82868034: 7FFAE850  subf r31, r26, r29
	ctx.r[31].s64 = ctx.r[29].s64 - ctx.r[26].s64;
	// 82868038: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 8286803C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82868040: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82868044: 419A0028  beq cr6, 0x8286806c
	if ctx.cr[6].eq {
	pc = 0x8286806C; continue 'dispatch;
	}
	pc = 0x82868048; continue 'dispatch;
            }
            0x82868048 => {
    //   block [0x82868048..0x8286805C)
	// 82868048: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8286804C: 419A0010  beq cr6, 0x8286805c
	if ctx.cr[6].eq {
	pc = 0x8286805C; continue 'dispatch;
	}
	// 82868050: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82868054: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82868058: 480000E9  bl 0x82868140
	ctx.lr = 0x8286805C;
	sub_82868140(ctx, base);
	pc = 0x8286805C; continue 'dispatch;
            }
            0x8286805C => {
    //   block [0x8286805C..0x8286806C)
	// 8286805C: 3B9C003C  addi r28, r28, 0x3c
	ctx.r[28].s64 = ctx.r[28].s64 + 60;
	// 82868060: 3BDE003C  addi r30, r30, 0x3c
	ctx.r[30].s64 = ctx.r[30].s64 + 60;
	// 82868064: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82868068: 409AFFE0  bne cr6, 0x82868048
	if !ctx.cr[6].eq {
	pc = 0x82868048; continue 'dispatch;
	}
	pc = 0x8286806C; continue 'dispatch;
            }
            0x8286806C => {
    //   block [0x8286806C..0x8286807C)
	// 8286806C: 93D90008  stw r30, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82868070: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82868074: 419A0020  beq cr6, 0x82868094
	if ctx.cr[6].eq {
	pc = 0x82868094; continue 'dispatch;
	}
	// 82868078: 7FDFE850  subf r30, r31, r29
	ctx.r[30].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	pc = 0x8286807C; continue 'dispatch;
            }
            0x8286807C => {
    //   block [0x8286807C..0x82868094)
	// 8286807C: 3BFFFFC4  addi r31, r31, -0x3c
	ctx.r[31].s64 = ctx.r[31].s64 + -60;
	// 82868080: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82868084: 7C7FF214  add r3, r31, r30
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 82868088: 48000209  bl 0x82868290
	ctx.lr = 0x8286808C;
	sub_82868290(ctx, base);
	// 8286808C: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82868090: 409AFFEC  bne cr6, 0x8286807c
	if !ctx.cr[6].eq {
	pc = 0x8286807C; continue 'dispatch;
	}
	pc = 0x82868094; continue 'dispatch;
            }
            0x82868094 => {
    //   block [0x82868094..0x828680A4)
	// 82868094: 7FDADA14  add r30, r26, r27
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 82868098: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8286809C: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828680A0: 419A001C  beq cr6, 0x828680bc
	if ctx.cr[6].eq {
	pc = 0x828680BC; continue 'dispatch;
	}
	pc = 0x828680A4; continue 'dispatch;
            }
            0x828680A4 => {
    //   block [0x828680A4..0x828680BC)
	// 828680A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828680A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828680AC: 480001E5  bl 0x82868290
	ctx.lr = 0x828680B0;
	sub_82868290(ctx, base);
	// 828680B0: 3BFF003C  addi r31, r31, 0x3c
	ctx.r[31].s64 = ctx.r[31].s64 + 60;
	// 828680B4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828680B8: 409AFFEC  bne cr6, 0x828680a4
	if !ctx.cr[6].eq {
	pc = 0x828680A4; continue 'dispatch;
	}
	pc = 0x828680BC; continue 'dispatch;
            }
            0x828680BC => {
    //   block [0x828680BC..0x828680CC)
	// 828680BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828680C0: 4BFFF9A9  bl 0x82867a68
	ctx.lr = 0x828680C4;
	sub_82867A68(ctx, base);
	// 828680C4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828680C8: 4844137C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828680D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828680D0 size=112
    let mut pc: u32 = 0x828680D0;
    'dispatch: loop {
        match pc {
            0x828680D0 => {
    //   block [0x828680D0..0x82868124)
	// 828680D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828680D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828680D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828680DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828680E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828680E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828680E8: 419A003C  beq cr6, 0x82868124
	if ctx.cr[6].eq {
	pc = 0x82868124; continue 'dispatch;
	}
	// 828680EC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 828680F0: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 828680F4: 2B0A003C  cmplwi cr6, r10, 0x3c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 60 as u32, &mut ctx.xer);
	// 828680F8: 4098002C  bge cr6, 0x82868124
	if !ctx.cr[6].lt {
	pc = 0x82868124; continue 'dispatch;
	}
	// 828680FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82868100: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82868104: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 82868108: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286810C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868110: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82868114: 4BA89D0D  bl 0x822f1e20
	ctx.lr = 0x82868118;
	sub_822F1E20(ctx, base);
	// 82868118: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 8286811C: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82868120: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82868124; continue 'dispatch;
            }
            0x82868124 => {
    //   block [0x82868124..0x82868140)
	// 82868124: 1C7F003C  mulli r3, r31, 0x3c
	ctx.r[3].s32 = ((ctx.r[31].s32 as i64 * 60 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82868128: 4B9B7131  bl 0x8221f258
	ctx.lr = 0x8286812C;
	sub_8221F258(ctx, base);
	// 8286812C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82868130: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82868134: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82868138: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286813C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82868140 size=336
    let mut pc: u32 = 0x82868140;
    'dispatch: loop {
        match pc {
            0x82868140 => {
    //   block [0x82868140..0x82868174)
	// 82868140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82868148: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286814C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82868150: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868154: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82868158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286815C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868160: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82868164: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82868168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286816C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82868170: 419A0020  beq cr6, 0x82868190
	if ctx.cr[6].eq {
	pc = 0x82868190; continue 'dispatch;
	}
	pc = 0x82868174; continue 'dispatch;
            }
            0x82868174 => {
    //   block [0x82868174..0x82868190)
	// 82868174: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82868178: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286817C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82868180: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82868184: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82868188: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286818C: 4082FFE8  bne 0x82868174
	if !ctx.cr[0].eq {
	pc = 0x82868174; continue 'dispatch;
	}
	pc = 0x82868190; continue 'dispatch;
            }
            0x82868190 => {
    //   block [0x82868190..0x828681A8)
	// 82868190: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82868194: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82868198: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8286819C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828681A0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828681A4: 419A0020  beq cr6, 0x828681c4
	if ctx.cr[6].eq {
	pc = 0x828681C4; continue 'dispatch;
	}
	pc = 0x828681A8; continue 'dispatch;
            }
            0x828681A8 => {
    //   block [0x828681A8..0x828681C4)
	// 828681A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828681AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828681B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828681B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828681B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828681BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828681C0: 4082FFE8  bne 0x828681a8
	if !ctx.cr[0].eq {
	pc = 0x828681A8; continue 'dispatch;
	}
	pc = 0x828681C4; continue 'dispatch;
            }
            0x828681C4 => {
    //   block [0x828681C4..0x828681DC)
	// 828681C4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828681C8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828681CC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828681D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828681D4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 828681D8: 419A0020  beq cr6, 0x828681f8
	if ctx.cr[6].eq {
	pc = 0x828681F8; continue 'dispatch;
	}
	pc = 0x828681DC; continue 'dispatch;
            }
            0x828681DC => {
    //   block [0x828681DC..0x828681F8)
	// 828681DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828681E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828681E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828681E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828681EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828681F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828681F4: 4082FFE8  bne 0x828681dc
	if !ctx.cr[0].eq {
	pc = 0x828681DC; continue 'dispatch;
	}
	pc = 0x828681F8; continue 'dispatch;
            }
            0x828681F8 => {
    //   block [0x828681F8..0x82868210)
	// 828681F8: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828681FC: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82868200: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82868204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82868208: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8286820C: 419A0020  beq cr6, 0x8286822c
	if ctx.cr[6].eq {
	pc = 0x8286822C; continue 'dispatch;
	}
	pc = 0x82868210; continue 'dispatch;
            }
            0x82868210 => {
    //   block [0x82868210..0x8286822C)
	// 82868210: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82868214: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868218: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286821C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82868220: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82868224: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868228: 4082FFE8  bne 0x82868210
	if !ctx.cr[0].eq {
	pc = 0x82868210; continue 'dispatch;
	}
	pc = 0x8286822C; continue 'dispatch;
            }
            0x8286822C => {
    //   block [0x8286822C..0x82868244)
	// 8286822C: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82868230: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82868234: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82868238: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286823C: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82868240: 419A0020  beq cr6, 0x82868260
	if ctx.cr[6].eq {
	pc = 0x82868260; continue 'dispatch;
	}
	pc = 0x82868244; continue 'dispatch;
            }
            0x82868244 => {
    //   block [0x82868244..0x82868260)
	// 82868244: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82868248: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286824C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82868250: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82868254: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82868258: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286825C: 4082FFE8  bne 0x82868244
	if !ctx.cr[0].eq {
	pc = 0x82868244; continue 'dispatch;
	}
	pc = 0x82868260; continue 'dispatch;
            }
            0x82868260 => {
    //   block [0x82868260..0x82868290)
	// 82868260: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 82868264: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82868268: 48041FE1  bl 0x828aa248
	ctx.lr = 0x8286826C;
	sub_828AA248(ctx, base);
	// 8286826C: C01E0038  lfs f0, 0x38(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82868270: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82868274: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868278: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286827C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82868280: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82868284: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82868288: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286828C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82868290 size=344
    let mut pc: u32 = 0x82868290;
    'dispatch: loop {
        match pc {
            0x82868290 => {
    //   block [0x82868290..0x828682D8)
	// 82868290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868294: 48441171  bl 0x82ca9404
	ctx.lr = 0x82868298;
	sub_82CA93D0(ctx, base);
	// 82868298: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286829C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828682A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828682A4: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828682A8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828682AC: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828682B0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828682B4: 419A0024  beq cr6, 0x828682d8
	if ctx.cr[6].eq {
	pc = 0x828682D8; continue 'dispatch;
	}
	// 828682B8: 4B94F861  bl 0x821b7b18
	ctx.lr = 0x828682BC;
	sub_821B7B18(ctx, base);
	// 828682BC: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828682C0: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828682C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828682C8: 419A0010  beq cr6, 0x828682d8
	if ctx.cr[6].eq {
	pc = 0x828682D8; continue 'dispatch;
	}
	// 828682CC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828682D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828682D4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x828682D8; continue 'dispatch;
            }
            0x828682D8 => {
    //   block [0x828682D8..0x82868314)
	// 828682D8: 83BF000C  lwz r29, 0xc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828682DC: 3B9E0008  addi r28, r30, 8
	ctx.r[28].s64 = ctx.r[30].s64 + 8;
	// 828682E0: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828682E4: 837F0008  lwz r27, 8(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828682E8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828682EC: 419A0028  beq cr6, 0x82868314
	if ctx.cr[6].eq {
	pc = 0x82868314; continue 'dispatch;
	}
	// 828682F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828682F4: 4B94F825  bl 0x821b7b18
	ctx.lr = 0x828682F8;
	sub_821B7B18(ctx, base);
	// 828682F8: 937C0000  stw r27, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828682FC: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82868300: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82868304: 419A0010  beq cr6, 0x82868314
	if ctx.cr[6].eq {
	pc = 0x82868314; continue 'dispatch;
	}
	// 82868308: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286830C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82868310: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82868314; continue 'dispatch;
            }
            0x82868314 => {
    //   block [0x82868314..0x82868350)
	// 82868314: 83BF0014  lwz r29, 0x14(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82868318: 3B9E0010  addi r28, r30, 0x10
	ctx.r[28].s64 = ctx.r[30].s64 + 16;
	// 8286831C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82868320: 837F0010  lwz r27, 0x10(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82868324: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82868328: 419A0028  beq cr6, 0x82868350
	if ctx.cr[6].eq {
	pc = 0x82868350; continue 'dispatch;
	}
	// 8286832C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82868330: 4B94F7E9  bl 0x821b7b18
	ctx.lr = 0x82868334;
	sub_821B7B18(ctx, base);
	// 82868334: 937C0000  stw r27, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82868338: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8286833C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82868340: 419A0010  beq cr6, 0x82868350
	if ctx.cr[6].eq {
	pc = 0x82868350; continue 'dispatch;
	}
	// 82868344: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868348: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8286834C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82868350; continue 'dispatch;
            }
            0x82868350 => {
    //   block [0x82868350..0x8286838C)
	// 82868350: 83BF001C  lwz r29, 0x1c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82868354: 3B9E0018  addi r28, r30, 0x18
	ctx.r[28].s64 = ctx.r[30].s64 + 24;
	// 82868358: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8286835C: 837F0018  lwz r27, 0x18(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82868360: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82868364: 419A0028  beq cr6, 0x8286838c
	if ctx.cr[6].eq {
	pc = 0x8286838C; continue 'dispatch;
	}
	// 82868368: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286836C: 4B94F7AD  bl 0x821b7b18
	ctx.lr = 0x82868370;
	sub_821B7B18(ctx, base);
	// 82868370: 937C0000  stw r27, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82868374: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82868378: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8286837C: 419A0010  beq cr6, 0x8286838c
	if ctx.cr[6].eq {
	pc = 0x8286838C; continue 'dispatch;
	}
	// 82868380: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868384: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82868388: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8286838C; continue 'dispatch;
            }
            0x8286838C => {
    //   block [0x8286838C..0x828683C8)
	// 8286838C: 83BF0024  lwz r29, 0x24(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82868390: 3B9E0020  addi r28, r30, 0x20
	ctx.r[28].s64 = ctx.r[30].s64 + 32;
	// 82868394: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82868398: 837F0020  lwz r27, 0x20(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8286839C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828683A0: 419A0028  beq cr6, 0x828683c8
	if ctx.cr[6].eq {
	pc = 0x828683C8; continue 'dispatch;
	}
	// 828683A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828683A8: 4B94F771  bl 0x821b7b18
	ctx.lr = 0x828683AC;
	sub_821B7B18(ctx, base);
	// 828683AC: 937C0000  stw r27, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828683B0: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828683B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828683B8: 419A0010  beq cr6, 0x828683c8
	if ctx.cr[6].eq {
	pc = 0x828683C8; continue 'dispatch;
	}
	// 828683BC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828683C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828683C4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x828683C8; continue 'dispatch;
            }
            0x828683C8 => {
    //   block [0x828683C8..0x828683E8)
	// 828683C8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 828683CC: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 828683D0: 4BD16DA9  bl 0x8257f178
	ctx.lr = 0x828683D4;
	sub_8257F178(ctx, base);
	// 828683D4: C01F0038  lfs f0, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828683D8: D01E0038  stfs f0, 0x38(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828683DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828683E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828683E4: 48441070  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828683E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828683E8 size=8
    let mut pc: u32 = 0x828683E8;
    'dispatch: loop {
        match pc {
            0x828683E8 => {
    //   block [0x828683E8..0x828683F0)
	// 828683E8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828683EC: 4BFFE424  b 0x82866810
	sub_82866810(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828683F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828683F0 size=8
    let mut pc: u32 = 0x828683F0;
    'dispatch: loop {
        match pc {
            0x828683F0 => {
    //   block [0x828683F0..0x828683F8)
	// 828683F0: 3860002A  li r3, 0x2a
	ctx.r[3].s64 = 42;
	// 828683F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828683F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828683F8 size=60
    let mut pc: u32 = 0x828683F8;
    'dispatch: loop {
        match pc {
            0x828683F8 => {
    //   block [0x828683F8..0x82868434)
	// 828683F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828683FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82868400: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82868404: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868408: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8286840C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82868410: 388BFD28  addi r4, r11, -0x2d8
	ctx.r[4].s64 = ctx.r[11].s64 + -728;
	// 82868414: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82868418: 4B9C4AB9  bl 0x8222ced0
	ctx.lr = 0x8286841C;
	sub_8222CED0(ctx, base);
	// 8286841C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868420: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82868424: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82868428: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286842C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82868430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82868438 size=476
    let mut pc: u32 = 0x82868438;
    'dispatch: loop {
        match pc {
            0x82868438 => {
    //   block [0x82868438..0x82868548)
	// 82868438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286843C: 48440FCD  bl 0x82ca9408
	ctx.lr = 0x82868440;
	sub_82CA93D0(ctx, base);
	// 82868440: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82868444: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82868448: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 8286844C: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 82868450: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 82868454: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 82868458: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 8286845C: 9421FB50  stwu r1, -0x4b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1200 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868460: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82868464: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82868468: 394104D0  addi r10, r1, 0x4d0
	ctx.r[10].s64 = ctx.r[1].s64 + 1232;
	// 8286846C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82868470: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82868474: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82868478: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8286847C: 80A10060  lwz r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82868480: 4B95E3D1  bl 0x821c6850
	ctx.lr = 0x82868484;
	sub_821C6850(ctx, base);
	// 82868484: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 82868488: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8286848C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82868490: 38A9802C  addi r5, r9, -0x7fd4
	ctx.r[5].s64 = ctx.r[9].s64 + -32724;
	// 82868494: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82868498: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8286849C: 80880060  lwz r4, 0x60(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(96 as u32) ) } as u64;
	// 828684A0: 4B98D821  bl 0x821f5cc0
	ctx.lr = 0x828684A4;
	sub_821F5CC0(ctx, base);
	// 828684A4: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828684A8: 4B9B6DB1  bl 0x8221f258
	ctx.lr = 0x828684AC;
	sub_8221F258(ctx, base);
	// 828684AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828684B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828684B4: 419A0094  beq cr6, 0x82868548
	if ctx.cr[6].eq {
	pc = 0x82868548; continue 'dispatch;
	}
	// 828684B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828684BC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828684C0: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 828684C4: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 828684C8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828684CC: C3EB9490  lfs f31, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828684D0: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 828684D4: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828684D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	pc = 0x82868548; continue 'dispatch;
            }
            0x82868548 => {
    //   block [0x82868548..0x82868614)
	// 82868548: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8286854C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82868550: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82868554: 419A0014  beq cr6, 0x82868568
	if ctx.cr[6].eq {
	pc = 0x82868568; continue 'dispatch;
	}
	// 82868558: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286855C: 4819C765  bl 0x82a04cc0
	ctx.lr = 0x82868560;
	sub_82A04CC0(ctx, base);
	// 82868560: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82868564: 4800000C  b 0x82868570
	pc = 0x82868570; continue 'dispatch;
	// 82868568: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8286856C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82868570: 57AB07BC  rlwinm r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 82868574: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868578: 419A0010  beq cr6, 0x82868588
	if ctx.cr[6].eq {
	pc = 0x82868588; continue 'dispatch;
	}
	// 8286857C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868580: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 82868584: 4B95E275  bl 0x821c67f8
	ctx.lr = 0x82868588;
	sub_821C67F8(ctx, base);
	// 82868588: 57AB07FE  clrlwi r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 8286858C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868590: 419A000C  beq cr6, 0x8286859c
	if ctx.cr[6].eq {
	pc = 0x8286859C; continue 'dispatch;
	}
	// 82868594: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82868598: 4B9AC841  bl 0x82214dd8
	ctx.lr = 0x8286859C;
	sub_82214DD8(ctx, base);
	// 8286859C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828685A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828685A4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828685A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828685AC: 419A0020  beq cr6, 0x828685cc
	if ctx.cr[6].eq {
	pc = 0x828685CC; continue 'dispatch;
	}
	// 828685B0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828685B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828685B8: 7D60F828  lwarx r11, 0, r31
	// lwarx
	let ea = ctx.r[31].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828685BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828685C0: 7D60F92D  stwcx. r11, 0, r31
	// stwcx.
	let addr = ctx.r[31].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828685C4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828685C8: 4082FFE8  bne 0x828685b0
	if !ctx.cr[0].eq {
	pc = 0x828685B0; continue 'dispatch;
	}
	// 828685CC: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828685D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828685D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828685D8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828685DC: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828685E0: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828685E4: 4BAE81FD  bl 0x823507e0
	ctx.lr = 0x828685E8;
	sub_823507E0(ctx, base);
	// 828685E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828685EC: 4B94F52D  bl 0x821b7b18
	ctx.lr = 0x828685F0;
	sub_821B7B18(ctx, base);
	// 828685F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828685F4: 4B94F525  bl 0x821b7b18
	ctx.lr = 0x828685F8;
	sub_821B7B18(ctx, base);
	// 828685F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828685FC: 4B94F51D  bl 0x821b7b18
	ctx.lr = 0x82868600;
	sub_821B7B18(ctx, base);
	// 82868600: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82868604: 4B9C96B5  bl 0x82231cb8
	ctx.lr = 0x82868608;
	sub_82231CB8(ctx, base);
	// 82868608: 382104B0  addi r1, r1, 0x4b0
	ctx.r[1].s64 = ctx.r[1].s64 + 1200;
	// 8286860C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82868610: 48440E48  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82868618 size=316
    let mut pc: u32 = 0x82868618;
    'dispatch: loop {
        match pc {
            0x82868618 => {
    //   block [0x82868618..0x82868644)
	// 82868618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286861C: 48440DF1  bl 0x82ca940c
	ctx.lr = 0x82868620;
	sub_82CA93D0(ctx, base);
	// 82868620: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82868624: 546605BE  clrlwi r6, r3, 0x16
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000003FFu64;
	// 82868628: 390B1094  addi r8, r11, 0x1094
	ctx.r[8].s64 = ctx.r[11].s64 + 4244;
	// 8286862C: 7C7F5670  srawi r31, r3, 0xa
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 10) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[3].s32 >> 10) as i64;
	// 82868630: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82868634: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 82868638: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 8286863C: 3860000A  li r3, 0xa
	ctx.r[3].s64 = 10;
	// 82868640: 39680010  addi r11, r8, 0x10
	ctx.r[11].s64 = ctx.r[8].s64 + 16;
	pc = 0x82868644; continue 'dispatch;
            }
            0x82868644 => {
    //   block [0x82868644..0x82868654)
	// 82868644: 7F0A1800  cmpw cr6, r10, r3
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82868648: 4099000C  ble cr6, 0x82868654
	if !ctx.cr[6].gt {
	pc = 0x82868654; continue 'dispatch;
	}
	// 8286864C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82868650: 48000034  b 0x82868684
	pc = 0x82868684; continue 'dispatch;
            }
            0x82868654 => {
    //   block [0x82868654..0x82868664)
	// 82868654: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82868658: 2B03000C  cmplwi cr6, r3, 0xc
	ctx.cr[6].compare_u32(ctx.r[3].u32, 12 as u32, &mut ctx.xer);
	// 8286865C: 40990008  ble cr6, 0x82868664
	if !ctx.cr[6].gt {
	pc = 0x82868664; continue 'dispatch;
	}
	// 82868660: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	pc = 0x82868664; continue 'dispatch;
            }
            0x82868664 => {
    //   block [0x82868664..0x82868684)
	// 82868664: 7FCA4850  subf r30, r10, r9
	ctx.r[30].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82868668: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286866C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82868670: 57DE103A  slwi r30, r30, 2
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82868674: 7D29402E  lwzx r9, r9, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82868678: 7FDE402E  lwzx r30, r30, r8
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8286867C: 7FDEE9D6  mullw r30, r30, r29
	ctx.r[30].s32 = ((ctx.r[30].s32 as i64 * ctx.r[29].s32 as i64) as i32);
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	// 82868680: 7D29F3D6  divw r9, r9, r30
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[30].s32;
	pc = 0x82868684; continue 'dispatch;
            }
            0x82868684 => {
    //   block [0x82868684..0x828686A8)
	// 82868684: 7F064800  cmpw cr6, r6, r9
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82868688: 41980020  blt cr6, 0x828686a8
	if ctx.cr[6].lt {
	pc = 0x828686A8; continue 'dispatch;
	}
	// 8286868C: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82868690: 90A70000  stw r5, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82868694: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82868698: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 8286869C: 7CC93050  subf r6, r9, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 828686A0: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 828686A4: 419A0014  beq cr6, 0x828686b8
	if ctx.cr[6].eq {
	pc = 0x828686B8; continue 'dispatch;
	}
	pc = 0x828686A8; continue 'dispatch;
            }
            0x828686A8 => {
    //   block [0x828686A8..0x828686B8)
	// 828686A8: 3863FFFF  addi r3, r3, -1
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	// 828686AC: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 828686B0: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 828686B4: 4199FF90  bgt cr6, 0x82868644
	if ctx.cr[6].gt {
	pc = 0x82868644; continue 'dispatch;
	}
	pc = 0x828686B8; continue 'dispatch;
            }
            0x828686B8 => {
    //   block [0x828686B8..0x82868754)
	// 828686B8: 7FEB3E70  srawi r11, r31, 7
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 7) as i64;
	// 828686BC: 57EA067E  clrlwi r10, r31, 0x19
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x0000007Fu64;
	// 828686C0: 7D693E70  srawi r9, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 7) as i64;
	// 828686C4: 5568067E  clrlwi r8, r11, 0x19
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 828686C8: 5527067E  clrlwi r7, r9, 0x19
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x0000007Fu64;
	// 828686CC: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 828686D0: 20A7007F  subfic r5, r7, 0x7f
	ctx.xer.ca = ctx.r[7].u32 <= 127 as u32;
	ctx.r[5].s64 = (127 as i64) - ctx.r[7].s64;
	// 828686D4: 7CE307B4  extsw r3, r7
	ctx.r[3].s64 = ctx.r[7].s32 as i64;
	// 828686D8: F8C1FFD0  std r6, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[6].u64 ) };
	// 828686DC: 7D682850  subf r11, r8, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	// 828686E0: C801FFD0  lfd f0, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828686E4: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 828686E8: F861FFD0  std r3, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[3].u64 ) };
	// 828686EC: C9A1FFD0  lfd f13, -0x30(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828686F0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828686F4: F901FFD0  std r8, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[8].u64 ) };
	// 828686F8: C981FFD0  lfd f12, -0x30(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828686FC: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 82868700: FD20069C  fcfid f9, f0
	ctx.f[9].f64 = (ctx.f[0].s64 as f64);
	// 82868704: F8E1FFD0  std r7, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[7].u64 ) };
	// 82868708: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8286870C: FD006E9C  fcfid f8, f13
	ctx.f[8].f64 = (ctx.f[13].s64 as f64);
	// 82868710: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 82868714: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82868718: FCE05E9C  fcfid f7, f11
	ctx.f[7].f64 = (ctx.f[11].s64 as f64);
	// 8286871C: FCC05018  frsp f6, f10
	ctx.f[6].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82868720: C0060FF4  lfs f0, 0xff4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4084 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82868724: FCA04818  frsp f5, f9
	ctx.f[5].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82868728: FC804018  frsp f4, f8
	ctx.f[4].f64 = (ctx.f[8].f64 as f32) as f64;
	// 8286872C: FC603818  frsp f3, f7
	ctx.f[3].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82868730: EC460032  fmuls f2, f6, f0
	ctx.f[2].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82868734: D0440010  stfs f2, 0x10(r4)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82868738: EC250032  fmuls f1, f5, f0
	ctx.f[1].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 8286873C: D0240014  stfs f1, 0x14(r4)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82868740: EDA40032  fmuls f13, f4, f0
	ctx.f[13].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82868744: D1A40018  stfs f13, 0x18(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82868748: ED830032  fmuls f12, f3, f0
	ctx.f[12].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 8286874C: D184001C  stfs f12, 0x1c(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82868750: 48440D0C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868758 size=168
    let mut pc: u32 = 0x82868758;
    'dispatch: loop {
        match pc {
            0x82868758 => {
    //   block [0x82868758..0x82868798)
	// 82868758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286875C: 48440CB1  bl 0x82ca940c
	ctx.lr = 0x82868760;
	sub_82CA93D0(ctx, base);
	// 82868760: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868764: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82868768: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8286876C: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82868770: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82868774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82868778: 419A0020  beq cr6, 0x82868798
	if ctx.cr[6].eq {
	pc = 0x82868798; continue 'dispatch;
	}
	// 8286877C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868780: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82868784: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82868788: 4E800421  bctrl
	ctx.lr = 0x8286878C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286878C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82868790: 4B94F389  bl 0x821b7b18
	ctx.lr = 0x82868794;
	sub_821B7B18(ctx, base);
	// 82868794: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x82868798 => {
    //   block [0x82868798..0x828687C4)
	// 82868798: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286879C: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 828687A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828687A4: 419A0020  beq cr6, 0x828687c4
	if ctx.cr[6].eq {
	pc = 0x828687C4; continue 'dispatch;
	}
	// 828687A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828687AC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828687B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828687B4: 4E800421  bctrl
	ctx.lr = 0x828687B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828687B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828687BC: 4B94F35D  bl 0x821b7b18
	ctx.lr = 0x828687C0;
	sub_821B7B18(ctx, base);
	// 828687C0: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x828687C4 => {
    //   block [0x828687C4..0x828687EC)
	// 828687C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828687C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828687CC: 419A0020  beq cr6, 0x828687ec
	if ctx.cr[6].eq {
	pc = 0x828687EC; continue 'dispatch;
	}
	// 828687D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828687D4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828687D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828687DC: 4E800421  bctrl
	ctx.lr = 0x828687E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828687E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828687E4: 4B94F335  bl 0x821b7b18
	ctx.lr = 0x828687E8;
	sub_821B7B18(ctx, base);
	// 828687E8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x828687EC => {
    //   block [0x828687EC..0x82868800)
	// 828687EC: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828687F0: 4B94F329  bl 0x821b7b18
	ctx.lr = 0x828687F4;
	sub_821B7B18(ctx, base);
	// 828687F4: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 828687F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828687FC: 48440C60  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868800 size=612
    let mut pc: u32 = 0x82868800;
    'dispatch: loop {
        match pc {
            0x82868800 => {
    //   block [0x82868800..0x82868938)
	// 82868800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868804: 48440C05  bl 0x82ca9408
	ctx.lr = 0x82868808;
	sub_82CA93D0(ctx, base);
	// 82868808: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286880C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82868810: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82868814: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82868818: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8286881C: 3B9D0004  addi r28, r29, 4
	ctx.r[28].s64 = ctx.r[29].s64 + 4;
	// 82868820: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82868824: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82868828: 4BA44851  bl 0x822ad078
	ctx.lr = 0x8286882C;
	sub_822AD078(ctx, base);
	// 8286882C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868830: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82868834: 419A0228  beq cr6, 0x82868a5c
	if ctx.cr[6].eq {
	pc = 0x82868A5C; continue 'dispatch;
	}
	// 82868838: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286883C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82868840: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82868844: 4E800421  bctrl
	ctx.lr = 0x82868848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82868848: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 8286884C: 409A0210  bne cr6, 0x82868a5c
	if !ctx.cr[6].eq {
	pc = 0x82868A5C; continue 'dispatch;
	}
	// 82868850: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868858: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286885C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82868860: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82868864: 4E800421  bctrl
	ctx.lr = 0x82868868;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82868868: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286886C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82868870: 419A01EC  beq cr6, 0x82868a5c
	if ctx.cr[6].eq {
	pc = 0x82868A5C; continue 'dispatch;
	}
	// 82868874: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868878: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286887C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82868880: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82868884: 4E800421  bctrl
	ctx.lr = 0x82868888;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82868888: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286888C: 419A01D0  beq cr6, 0x82868a5c
	if ctx.cr[6].eq {
	pc = 0x82868A5C; continue 'dispatch;
	}
	// 82868890: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868894: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868898: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286889C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828688A0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828688A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828688A8: 4E800421  bctrl
	ctx.lr = 0x828688AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828688AC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828688B0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828688B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828688B8: 80E90018  lwz r7, 0x18(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 828688BC: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828688C0: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 828688C4: 4E800421  bctrl
	ctx.lr = 0x828688C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828688C8: 3CC0820F  lis r6, -0x7df1
	ctx.r[6].s64 = -2112946176;
	// 828688CC: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 828688D0: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 828688D4: 38A62B60  addi r5, r6, 0x2b60
	ctx.r[5].s64 = ctx.r[6].s64 + 11104;
	// 828688D8: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 828688DC: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 828688E0: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 828688E4: 9BC10078  stb r30, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u8 ) };
	// 828688E8: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 828688EC: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828688F0: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 828688F4: 41980044  blt cr6, 0x82868938
	if ctx.cr[6].lt {
	pc = 0x82868938; continue 'dispatch;
	}
	// 828688F8: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828688FC: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82868900: 393F0004  addi r9, r31, 4
	ctx.r[9].s64 = ctx.r[31].s64 + 4;
	// 82868904: 3903FFFC  addi r8, r3, -4
	ctx.r[8].s64 = ctx.r[3].s64 + -4;
	// 82868908: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 8286890C: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82868910: 88DF0001  lbz r6, 1(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 82868914: 98CA0001  stb r6, 1(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(1 as u32), ctx.r[6].u8 ) };
	// 82868918: 88BF0002  lbz r5, 2(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 8286891C: 98AA0002  stb r5, 2(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[5].u8 ) };
	// 82868920: 889F0003  lbz r4, 3(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 82868924: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82868928: 988A0003  stb r4, 3(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(3 as u32), ctx.r[4].u8 ) };
	// 8286892C: 91010074  stw r8, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	// 82868930: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82868934: 48000014  b 0x82868948
	pc = 0x82868948; continue 'dispatch;
            }
            0x82868938 => {
    //   block [0x82868938..0x82868948)
	// 82868938: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8286893C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82868940: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82868944: 481B85A5  bl 0x82a20ee8
	ctx.lr = 0x82868948;
	sub_82A20EE8(ctx, base);
	pc = 0x82868948; continue 'dispatch;
            }
            0x82868948 => {
    //   block [0x82868948..0x82868980)
	// 82868948: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8286894C: 89410078  lbz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82868950: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82868954: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82868958: 419A0028  beq cr6, 0x82868980
	if ctx.cr[6].eq {
	pc = 0x82868980; continue 'dispatch;
	}
	// 8286895C: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82868960: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82868964: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 82868968: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8286896C: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82868970: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82868974: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82868978: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	// 8286897C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82868980; continue 'dispatch;
            }
            0x82868980 => {
    //   block [0x82868980..0x828689AC)
	// 82868980: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82868984: 419800D8  blt cr6, 0x82868a5c
	if ctx.cr[6].lt {
	pc = 0x82868A5C; continue 'dispatch;
	}
	// 82868988: 2F1F0E10  cmpwi cr6, r31, 0xe10
	ctx.cr[6].compare_i32(ctx.r[31].s32, 3600, &mut ctx.xer);
	// 8286898C: 419900D0  bgt cr6, 0x82868a5c
	if ctx.cr[6].gt {
	pc = 0x82868A5C; continue 'dispatch;
	}
	// 82868990: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82868994: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82868998: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286899C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828689A0: 4BA446D9  bl 0x822ad078
	ctx.lr = 0x828689A4;
	sub_822AD078(ctx, base);
	// 828689A4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828689A8: 409900B4  ble cr6, 0x82868a5c
	if !ctx.cr[6].gt {
	pc = 0x82868A5C; continue 'dispatch;
	}
	pc = 0x828689AC; continue 'dispatch;
            }
            0x828689AC => {
    //   block [0x828689AC..0x82868A00)
	// 828689AC: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828689B0: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 828689B4: 4198004C  blt cr6, 0x82868a00
	if ctx.cr[6].lt {
	pc = 0x82868A00; continue 'dispatch;
	}
	// 828689B8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828689BC: 3921005C  addi r9, r1, 0x5c
	ctx.r[9].s64 = ctx.r[1].s64 + 92;
	// 828689C0: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828689C4: 38EAFFFC  addi r7, r10, -4
	ctx.r[7].s64 = ctx.r[10].s64 + -4;
	// 828689C8: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 828689CC: 38A80004  addi r5, r8, 4
	ctx.r[5].s64 = ctx.r[8].s64 + 4;
	// 828689D0: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828689D4: 98890000  stb r4, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 828689D8: 886B0001  lbz r3, 1(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 828689DC: 98690001  stb r3, 1(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(1 as u32), ctx.r[3].u8 ) };
	// 828689E0: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 828689E4: 99490002  stb r10, 2(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 828689E8: 890B0003  lbz r8, 3(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828689EC: 90C1006C  stw r6, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[6].u32 ) };
	// 828689F0: 90E10074  stw r7, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[7].u32 ) };
	// 828689F4: 90A10064  stw r5, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[5].u32 ) };
	// 828689F8: 99090003  stb r8, 3(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(3 as u32), ctx.r[8].u8 ) };
	// 828689FC: 48000014  b 0x82868a10
	pc = 0x82868A10; continue 'dispatch;
            }
            0x82868A00 => {
    //   block [0x82868A00..0x82868A10)
	// 82868A00: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82868A04: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82868A08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82868A0C: 481B84DD  bl 0x82a20ee8
	ctx.lr = 0x82868A10;
	sub_82A20EE8(ctx, base);
	pc = 0x82868A10; continue 'dispatch;
            }
            0x82868A10 => {
    //   block [0x82868A10..0x82868A44)
	// 82868A10: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82868A14: 89210078  lbz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82868A18: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82868A1C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82868A20: 419A0024  beq cr6, 0x82868a44
	if ctx.cr[6].eq {
	pc = 0x82868A44; continue 'dispatch;
	}
	// 82868A24: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82868A28: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82868A2C: 8921005F  lbz r9, 0x5f(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 82868A30: 8901005C  lbz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82868A34: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82868A38: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82868A3C: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82868A40: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82868A44; continue 'dispatch;
            }
            0x82868A44 => {
    //   block [0x82868A44..0x82868A5C)
	// 82868A44: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82868A48: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82868A4C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82868A50: 7D5E592E  stwx r10, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82868A54: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82868A58: 4082FF54  bne 0x828689ac
	if !ctx.cr[0].eq {
	pc = 0x828689AC; continue 'dispatch;
	}
	pc = 0x82868A5C; continue 'dispatch;
            }
            0x82868A5C => {
    //   block [0x82868A5C..0x82868A64)
	// 82868A5C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82868A60: 484409F8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82868A68 size=296
    let mut pc: u32 = 0x82868A68;
    'dispatch: loop {
        match pc {
            0x82868A68 => {
    //   block [0x82868A68..0x82868A8C)
	// 82868A68: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82868A6C: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82868A70: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82868A74: 38EBF058  addi r7, r11, -0xfa8
	ctx.r[7].s64 = ctx.r[11].s64 + -4008;
	// 82868A78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82868A7C: 38C87088  addi r6, r8, 0x7088
	ctx.r[6].s64 = ctx.r[8].s64 + 28808;
	// 82868A80: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82868A84: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82868A88: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	pc = 0x82868A8C; continue 'dispatch;
            }
            0x82868A8C => {
    //   block [0x82868A8C..0x82868AE8)
	// 82868A8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82868A90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868A94: 7D402828  lwarx r10, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82868A98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82868A9C: 7D40292D  stwcx. r10, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82868AA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868AA4: 4082FFE8  bne 0x82868a8c
	if !ctx.cr[0].eq {
	pc = 0x82868A8C; continue 'dispatch;
	}
	// 82868AA8: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82868AAC: 9963000D  stb r11, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[11].u8 ) };
	// 82868AB0: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82868AB4: 39046138  addi r8, r4, 0x6138
	ctx.r[8].s64 = ctx.r[4].s64 + 24888;
	// 82868AB8: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82868ABC: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82868AC0: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82868AC4: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82868AC8: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82868ACC: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82868AD0: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82868AD4: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82868AD8: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82868ADC: 9963003C  stb r11, 0x3c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82868AE0: 9963003D  stb r11, 0x3d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(61 as u32), ctx.r[11].u8 ) };
	// 82868AE4: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	pc = 0x82868AE8; continue 'dispatch;
            }
            0x82868AE8 => {
    //   block [0x82868AE8..0x82868B90)
	// 82868AE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82868AEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868AF0: 7D403028  lwarx r10, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82868AF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82868AF8: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82868AFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868B00: 4082FFE8  bne 0x82868ae8
	if !ctx.cr[0].eq {
	pc = 0x82868AE8; continue 'dispatch;
	}
	// 82868B04: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 82868B08: 39430068  addi r10, r3, 0x68
	ctx.r[10].s64 = ctx.r[3].s64 + 104;
	// 82868B0C: 38C79484  addi r6, r7, -0x6b7c
	ctx.r[6].s64 = ctx.r[7].s64 + -27516;
	// 82868B10: C006000C  lfs f0, 0xc(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82868B14: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82868B18: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82868B1C: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82868B20: C0079484  lfs f0, -0x6b7c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82868B24: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82868B28: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82868B2C: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82868B30: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82868B34: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82868B38: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82868B3C: 91630068  stw r11, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82868B40: 91630070  stw r11, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82868B44: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82868B48: 91630078  stw r11, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82868B4C: 9963007C  stb r11, 0x7c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 82868B50: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82868B54: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82868B58: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82868B5C: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82868B60: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82868B64: 91630094  stw r11, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82868B68: 91630098  stw r11, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82868B6C: 9163009C  stw r11, 0x9c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82868B70: 916300A0  stw r11, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82868B74: 916300A4  stw r11, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82868B78: 916300A8  stw r11, 0xa8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82868B7C: 916300AC  stw r11, 0xac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82868B80: 916300B0  stw r11, 0xb0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82868B84: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82868B88: 996300B4  stb r11, 0xb4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), ctx.r[11].u8 ) };
	// 82868B8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868B90 size=112
    let mut pc: u32 = 0x82868B90;
    'dispatch: loop {
        match pc {
            0x82868B90 => {
    //   block [0x82868B90..0x82868BBC)
	// 82868B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82868B98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82868B9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82868BA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868BA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82868BA8: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82868BAC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82868BB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82868BB4: 419A0008  beq cr6, 0x82868bbc
	if ctx.cr[6].eq {
	pc = 0x82868BBC; continue 'dispatch;
	}
	// 82868BB8: 4B9B3181  bl 0x8221bd38
	ctx.lr = 0x82868BBC;
	sub_8221BD38(ctx, base);
	pc = 0x82868BBC; continue 'dispatch;
            }
            0x82868BBC => {
    //   block [0x82868BBC..0x82868BE8)
	// 82868BBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82868BC0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82868BC4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82868BC8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82868BCC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868BD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82868BD4: 419A0014  beq cr6, 0x82868be8
	if ctx.cr[6].eq {
	pc = 0x82868BE8; continue 'dispatch;
	}
	// 82868BD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868BDC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82868BE0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82868BE4: 4E800421  bctrl
	ctx.lr = 0x82868BE8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82868BE8 => {
    //   block [0x82868BE8..0x82868C00)
	// 82868BE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82868BEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82868BF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82868BF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82868BF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82868BFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868C00 size=364
    let mut pc: u32 = 0x82868C00;
    'dispatch: loop {
        match pc {
            0x82868C00 => {
    //   block [0x82868C00..0x82868C24)
	// 82868C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868C04: 48440805  bl 0x82ca9408
	ctx.lr = 0x82868C08;
	sub_82CA93D0(ctx, base);
	// 82868C08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868C0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82868C10: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82868C14: 807F00B0  lwz r3, 0xb0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82868C18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82868C1C: 419A0040  beq cr6, 0x82868c5c
	if ctx.cr[6].eq {
	pc = 0x82868C5C; continue 'dispatch;
	}
	// 82868C20: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82868C24; continue 'dispatch;
            }
            0x82868C24 => {
    //   block [0x82868C24..0x82868C58)
	// 82868C24: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82868C28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868C2C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82868C30: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82868C34: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82868C38: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868C3C: 4082FFE8  bne 0x82868c24
	if !ctx.cr[0].eq {
	pc = 0x82868C24; continue 'dispatch;
	}
	// 82868C40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868C44: 409A0014  bne cr6, 0x82868c58
	if !ctx.cr[6].eq {
	pc = 0x82868C58; continue 'dispatch;
	}
	// 82868C48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868C4C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82868C50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82868C54: 4E800421  bctrl
	ctx.lr = 0x82868C58;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82868C58 => {
    //   block [0x82868C58..0x82868C5C)
	// 82868C58: 939F00B0  stw r28, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[28].u32 ) };
	pc = 0x82868C5C; continue 'dispatch;
            }
            0x82868C5C => {
    //   block [0x82868C5C..0x82868C74)
	// 82868C5C: 387F00A8  addi r3, r31, 0xa8
	ctx.r[3].s64 = ctx.r[31].s64 + 168;
	// 82868C60: 4B94EEB9  bl 0x821b7b18
	ctx.lr = 0x82868C64;
	sub_821B7B18(ctx, base);
	// 82868C64: 3BDF00A0  addi r30, r31, 0xa0
	ctx.r[30].s64 = ctx.r[31].s64 + 160;
	// 82868C68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82868C6C: 4B94EEAD  bl 0x821b7b18
	ctx.lr = 0x82868C70;
	sub_821B7B18(ctx, base);
	// 82868C70: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	pc = 0x82868C74; continue 'dispatch;
            }
            0x82868C74 => {
    //   block [0x82868C74..0x82868CB0)
	// 82868C74: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 82868C78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82868C7C: 4B94EE9D  bl 0x821b7b18
	ctx.lr = 0x82868C80;
	sub_821B7B18(ctx, base);
	// 82868C80: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82868C84: 4080FFF0  bge 0x82868c74
	if !ctx.cr[0].lt {
	pc = 0x82868C74; continue 'dispatch;
	}
	// 82868C88: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 82868C8C: 4BFFFF05  bl 0x82868b90
	ctx.lr = 0x82868C90;
	sub_82868B90(ctx, base);
	// 82868C90: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82868C94: 4B94EE85  bl 0x821b7b18
	ctx.lr = 0x82868C98;
	sub_821B7B18(ctx, base);
	// 82868C98: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 82868C9C: 4B94EE7D  bl 0x821b7b18
	ctx.lr = 0x82868CA0;
	sub_821B7B18(ctx, base);
	// 82868CA0: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82868CA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82868CA8: 419A0040  beq cr6, 0x82868ce8
	if ctx.cr[6].eq {
	pc = 0x82868CE8; continue 'dispatch;
	}
	// 82868CAC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82868CB0; continue 'dispatch;
            }
            0x82868CB0 => {
    //   block [0x82868CB0..0x82868CE4)
	// 82868CB0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82868CB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868CB8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82868CBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82868CC0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82868CC4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868CC8: 4082FFE8  bne 0x82868cb0
	if !ctx.cr[0].eq {
	pc = 0x82868CB0; continue 'dispatch;
	}
	// 82868CCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868CD0: 409A0014  bne cr6, 0x82868ce4
	if !ctx.cr[6].eq {
	pc = 0x82868CE4; continue 'dispatch;
	}
	// 82868CD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868CD8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82868CDC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82868CE0: 4E800421  bctrl
	ctx.lr = 0x82868CE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82868CE4 => {
    //   block [0x82868CE4..0x82868CE8)
	// 82868CE4: 939F0054  stw r28, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x82868CE8; continue 'dispatch;
            }
            0x82868CE8 => {
    //   block [0x82868CE8..0x82868D00)
	// 82868CE8: 387F004C  addi r3, r31, 0x4c
	ctx.r[3].s64 = ctx.r[31].s64 + 76;
	// 82868CEC: 4B94EE2D  bl 0x821b7b18
	ctx.lr = 0x82868CF0;
	sub_821B7B18(ctx, base);
	// 82868CF0: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82868CF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82868CF8: 419A0040  beq cr6, 0x82868d38
	if ctx.cr[6].eq {
	pc = 0x82868D38; continue 'dispatch;
	}
	// 82868CFC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82868D00; continue 'dispatch;
            }
            0x82868D00 => {
    //   block [0x82868D00..0x82868D34)
	// 82868D00: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82868D04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868D08: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82868D0C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82868D10: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82868D14: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868D18: 4082FFE8  bne 0x82868d00
	if !ctx.cr[0].eq {
	pc = 0x82868D00; continue 'dispatch;
	}
	// 82868D1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868D20: 409A0014  bne cr6, 0x82868d34
	if !ctx.cr[6].eq {
	pc = 0x82868D34; continue 'dispatch;
	}
	// 82868D24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868D28: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82868D2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82868D30: 4E800421  bctrl
	ctx.lr = 0x82868D34;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82868D34 => {
    //   block [0x82868D34..0x82868D38)
	// 82868D34: 939F0048  stw r28, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	pc = 0x82868D38; continue 'dispatch;
            }
            0x82868D38 => {
    //   block [0x82868D38..0x82868D6C)
	// 82868D38: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 82868D3C: 4B9AC09D  bl 0x82214dd8
	ctx.lr = 0x82868D40;
	sub_82214DD8(ctx, base);
	// 82868D40: 387F002C  addi r3, r31, 0x2c
	ctx.r[3].s64 = ctx.r[31].s64 + 44;
	// 82868D44: 4BB73AE5  bl 0x823dc828
	ctx.lr = 0x82868D48;
	sub_823DC828(ctx, base);
	// 82868D48: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82868D4C: 4BB73ADD  bl 0x823dc828
	ctx.lr = 0x82868D50;
	sub_823DC828(ctx, base);
	// 82868D50: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82868D54: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82868D58: 394BF058  addi r10, r11, -0xfa8
	ctx.r[10].s64 = ctx.r[11].s64 + -4008;
	// 82868D5C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82868D60: 4B9AC079  bl 0x82214dd8
	ctx.lr = 0x82868D64;
	sub_82214DD8(ctx, base);
	// 82868D64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82868D68: 484406F0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868D70 size=72
    let mut pc: u32 = 0x82868D70;
    'dispatch: loop {
        match pc {
            0x82868D70 => {
    //   block [0x82868D70..0x82868D9C)
	// 82868D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868D74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82868D78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82868D7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868D80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82868D84: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82868D88: 419A0014  beq cr6, 0x82868d9c
	if ctx.cr[6].eq {
	pc = 0x82868D9C; continue 'dispatch;
	}
	// 82868D8C: 897F00B4  lbz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82868D90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82868D94: 409A0008  bne cr6, 0x82868d9c
	if !ctx.cr[6].eq {
	pc = 0x82868D9C; continue 'dispatch;
	}
	// 82868D98: 48000071  bl 0x82868e08
	ctx.lr = 0x82868D9C;
	sub_82868E08(ctx, base);
	pc = 0x82868D9C; continue 'dispatch;
            }
            0x82868D9C => {
    //   block [0x82868D9C..0x82868DB8)
	// 82868D9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82868DA0: 997F007C  stb r11, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 82868DA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82868DA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82868DAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82868DB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82868DB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868DB8 size=80
    let mut pc: u32 = 0x82868DB8;
    'dispatch: loop {
        match pc {
            0x82868DB8 => {
    //   block [0x82868DB8..0x82868E08)
	// 82868DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82868DC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82868DC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868DC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82868DCC: 387F002C  addi r3, r31, 0x2c
	ctx.r[3].s64 = ctx.r[31].s64 + 44;
	// 82868DD0: 4BD16809  bl 0x8257f5d8
	ctx.lr = 0x82868DD4;
	sub_8257F5D8(ctx, base);
	// 82868DD4: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82868DD8: 4BD16801  bl 0x8257f5d8
	ctx.lr = 0x82868DDC;
	sub_8257F5D8(ctx, base);
	// 82868DDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868DE0: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82868DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868DE8: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82868DEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82868DF0: 4E800421  bctrl
	ctx.lr = 0x82868DF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82868DF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82868DF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82868DFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82868E00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82868E04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82868E08 size=1240
    let mut pc: u32 = 0x82868E08;
    'dispatch: loop {
        match pc {
            0x82868E08 => {
    //   block [0x82868E08..0x82868EBC)
	// 82868E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868E0C: 484405C5  bl 0x82ca93d0
	ctx.lr = 0x82868E10;
	sub_82CA93D0(ctx, base);
	// 82868E10: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82868E14: 48444EC5  bl 0x82cadcd8
	ctx.lr = 0x82868E18;
	sub_82CADCA0(ctx, base);
	// 82868E18: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868E1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82868E20: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82868E24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82868E28: 93C10174  stw r30, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[30].u32 ) };
	// 82868E2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868E30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82868E34: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868E38: 9B5E003C  stb r26, 0x3c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[26].u8 ) };
	// 82868E3C: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82868E40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82868E44: 4E800421  bctrl
	ctx.lr = 0x82868E48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82868E48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82868E4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82868E50: 4B933799  bl 0x8219c5e8
	ctx.lr = 0x82868E54;
	sub_8219C5E8(ctx, base);
	// 82868E54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868E58: 4B9ABF81  bl 0x82214dd8
	ctx.lr = 0x82868E5C;
	sub_82214DD8(ctx, base);
	// 82868E5C: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82868E60: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82868E64: 419A046C  beq cr6, 0x828692d0
	if ctx.cr[6].eq {
	pc = 0x828692D0; continue 'dispatch;
	}
	// 82868E68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82868E6C: 4B94968D  bl 0x821b24f8
	ctx.lr = 0x82868E70;
	sub_821B24F8(ctx, base);
	// 82868E70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82868E74: 481976AD  bl 0x82a00520
	ctx.lr = 0x82868E78;
	sub_82A00520(ctx, base);
	// 82868E78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82868E7C: 909E0018  stw r4, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 82868E80: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82868E84: 419A044C  beq cr6, 0x828692d0
	if ctx.cr[6].eq {
	pc = 0x828692D0; continue 'dispatch;
	}
	// 82868E88: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82868E8C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82868E90: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82868E94: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82868E98: 419A0078  beq cr6, 0x82868f10
	if ctx.cr[6].eq {
	pc = 0x82868F10; continue 'dispatch;
	}
	// 82868E9C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82868EA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82868EA4: 409A0064  bne cr6, 0x82868f08
	if !ctx.cr[6].eq {
	pc = 0x82868F08; continue 'dispatch;
	}
	// 82868EA8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82868EAC: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82868EB0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82868EB4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868EB8: 40810050  ble 0x82868f08
	if !ctx.cr[0].gt {
	pc = 0x82868F08; continue 'dispatch;
	}
            }
            0x82868EBC => {
    //   block [0x82868EBC..0x82868EDC)
	// 82868EBC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82868EC0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82868EC4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82868EC8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868ECC: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 82868ED0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82868ED4: 41980008  blt cr6, 0x82868edc
	if ctx.cr[6].lt {
	pc = 0x82868EDC; continue 'dispatch;
	}
	// 82868ED8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x82868EDC; continue 'dispatch;
            }
            0x82868EDC => {
    //   block [0x82868EDC..0x82868EF8)
	// 82868EDC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82868EE0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82868EE4: 419A0014  beq cr6, 0x82868ef8
	if ctx.cr[6].eq {
	pc = 0x82868EF8; continue 'dispatch;
	}
	// 82868EE8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82868EEC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82868EF0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82868EF4: 4800000C  b 0x82868f00
	pc = 0x82868F00; continue 'dispatch;
            }
            0x82868EF8 => {
    //   block [0x82868EF8..0x82868F00)
	// 82868EF8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82868EFC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82868F00; continue 'dispatch;
            }
            0x82868F00 => {
    //   block [0x82868F00..0x82868F08)
	// 82868F00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868F04: 4199FFB8  bgt cr6, 0x82868ebc
	if ctx.cr[6].gt {
	pc = 0x82868EBC; continue 'dispatch;
	}
	pc = 0x82868F08; continue 'dispatch;
            }
            0x82868F08 => {
    //   block [0x82868F08..0x82868F10)
	// 82868F08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82868F0C: 48000008  b 0x82868f14
	pc = 0x82868F14; continue 'dispatch;
            }
            0x82868F10 => {
    //   block [0x82868F10..0x82868F14)
	// 82868F10: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82868F14; continue 'dispatch;
            }
            0x82868F14 => {
    //   block [0x82868F14..0x82868FAC)
	// 82868F14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82868F18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82868F1C: 419A03B4  beq cr6, 0x828692d0
	if ctx.cr[6].eq {
	pc = 0x828692D0; continue 'dispatch;
	}
	// 82868F20: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82868F24: 48197A6D  bl 0x82a00990
	ctx.lr = 0x82868F28;
	sub_82A00990(ctx, base);
	// 82868F28: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82868F2C: 81C10090  lwz r14, 0x90(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82868F30: 7F0E5840  cmplw cr6, r14, r11
	ctx.cr[6].compare_u32(ctx.r[14].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82868F34: 419A0394  beq cr6, 0x828692c8
	if ctx.cr[6].eq {
	pc = 0x828692C8; continue 'dispatch;
	}
	// 82868F38: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82868F3C: 3FE0820E  lis r31, -0x7df2
	ctx.r[31].s64 = -2113011712;
	// 82868F40: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82868F44: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82868F48: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 82868F4C: C3899484  lfs f28, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82868F50: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 82868F54: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 82868F58: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 82868F5C: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 82868F60: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 82868F64: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 82868F68: 3BFFFD88  addi r31, r31, -0x278
	ctx.r[31].s64 = ctx.r[31].s64 + -632;
	// 82868F6C: 394AFD3C  addi r10, r10, -0x2c4
	ctx.r[10].s64 = ctx.r[10].s64 + -708;
	// 82868F70: 396BAA38  addi r11, r11, -0x55c8
	ctx.r[11].s64 = ctx.r[11].s64 + -21960;
	// 82868F74: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82868F78: 3DE08332  lis r15, -0x7cce
	ctx.r[15].s64 = -2093875200;
	// 82868F7C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82868F80: 3EC0834C  lis r22, -0x7cb4
	ctx.r[22].s64 = -2092171264;
	// 82868F84: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82868F88: 3EA0834C  lis r21, -0x7cb4
	ctx.r[21].s64 = -2092171264;
	// 82868F8C: 3E00820A  lis r16, -0x7df6
	ctx.r[16].s64 = -2113273856;
	// 82868F90: 3B25FDBC  addi r25, r5, -0x244
	ctx.r[25].s64 = ctx.r[5].s64 + -580;
	// 82868F94: 3B04FDA0  addi r24, r4, -0x260
	ctx.r[24].s64 = ctx.r[4].s64 + -608;
	// 82868F98: 3AE3FD98  addi r23, r3, -0x268
	ctx.r[23].s64 = ctx.r[3].s64 + -616;
	// 82868F9C: 3A86FD7C  addi r20, r6, -0x284
	ctx.r[20].s64 = ctx.r[6].s64 + -644;
	// 82868FA0: 3A67FD70  addi r19, r7, -0x290
	ctx.r[19].s64 = ctx.r[7].s64 + -656;
	// 82868FA4: 3A48FD60  addi r18, r8, -0x2a0
	ctx.r[18].s64 = ctx.r[8].s64 + -672;
	// 82868FA8: 3A29FD4C  addi r17, r9, -0x2b4
	ctx.r[17].s64 = ctx.r[9].s64 + -692;
	pc = 0x82868FAC; continue 'dispatch;
            }
            0x82868FAC => {
    //   block [0x82868FAC..0x828690D4)
	// 82868FAC: 55CB083C  slwi r11, r14, 1
	ctx.r[11].u32 = ctx.r[14].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82868FB0: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82868FB4: 7D2E5A14  add r9, r14, r11
	ctx.r[9].u64 = ctx.r[14].u64 + ctx.r[11].u64;
	// 82868FB8: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82868FBC: 7CE8502E  lwzx r7, r8, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82868FC0: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 82868FC4: 409A02F0  bne cr6, 0x828692b4
	if !ctx.cr[6].eq {
	pc = 0x828692B4; continue 'dispatch;
	}
	// 82868FC8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82868FCC: 48197EAD  bl 0x82a00e78
	ctx.lr = 0x82868FD0;
	sub_82A00E78(ctx, base);
	// 82868FD0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82868FD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82868FD8: 806B6DA0  lwz r3, 0x6da0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 82868FDC: 4B97B275  bl 0x821e4250
	ctx.lr = 0x82868FE0;
	sub_821E4250(ctx, base);
	// 82868FE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82868FE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82868FE8: 419A02CC  beq cr6, 0x828692b4
	if ctx.cr[6].eq {
	pc = 0x828692B4; continue 'dispatch;
	}
	// 82868FEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82868FF0: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82868FF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82868FF8: 4BF1A421  bl 0x82783418
	ctx.lr = 0x82868FFC;
	sub_82783418(ctx, base);
	// 82868FFC: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82869000: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82869004: 419A02B0  beq cr6, 0x828692b4
	if ctx.cr[6].eq {
	pc = 0x828692B4; continue 'dispatch;
	}
	// 82869008: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286900C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82869010: 4BB56811  bl 0x823bf820
	ctx.lr = 0x82869014;
	sub_823BF820(ctx, base);
	// 82869014: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82869018: 57CB05EE  rlwinm r11, r30, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8286901C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869020: 419A0294  beq cr6, 0x828692b4
	if ctx.cr[6].eq {
	pc = 0x828692B4; continue 'dispatch;
	}
	// 82869024: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 82869028: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286902C: 4B92DB55  bl 0x82196b80
	ctx.lr = 0x82869030;
	sub_82196B80(ctx, base);
	// 82869030: C80F9660  lfd f0, -0x69a0(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[15].u32.wrapping_add(-27040 as u32) ) };
	// 82869034: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 82869038: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8286903C: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82869040: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82869044: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 82869048: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8286904C: D9A10070  stfd f13, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[13].u64 ) };
	// 82869050: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82869054: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82869058: 4B92DB29  bl 0x82196b80
	ctx.lr = 0x8286905C;
	sub_82196B80(ctx, base);
	// 8286905C: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82869060: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82869064: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82869068: 4B92DB19  bl 0x82196b80
	ctx.lr = 0x8286906C;
	sub_82196B80(ctx, base);
	// 8286906C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82869070: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82869074: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82869078: 4B92DB09  bl 0x82196b80
	ctx.lr = 0x8286907C;
	sub_82196B80(ctx, base);
	// 8286907C: C0109A80  lfs f0, -0x6580(r16)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82869080: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82869084: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82869088: 4099022C  ble cr6, 0x828692b4
	if !ctx.cr[6].gt {
	pc = 0x828692B4; continue 'dispatch;
	}
	// 8286908C: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82869090: 4B9B61C9  bl 0x8221f258
	ctx.lr = 0x82869094;
	sub_8221F258(ctx, base);
	// 82869094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82869098: 419A003C  beq cr6, 0x828690d4
	if ctx.cr[6].eq {
	pc = 0x828690D4; continue 'dispatch;
	}
	// 8286909C: 397F0009  addi r11, r31, 9
	ctx.r[11].s64 = ctx.r[31].s64 + 9;
	// 828690A0: D383000C  stfs f28, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828690A4: 57CA067E  clrlwi r10, r30, 0x19
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x0000007Fu64;
	// 828690A8: D3E30010  stfs f31, 0x10(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828690AC: D3C30014  stfs f30, 0x14(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828690B0: 93830000  stw r28, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828690B4: D3A30018  stfs f29, 0x18(r3)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828690B8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828690BC: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 828690C0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828690C4: 93430024  stw r26, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[26].u32 ) };
	// 828690C8: 93430028  stw r26, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[26].u32 ) };
	// 828690CC: 9343002C  stw r26, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
	// 828690D0: 48000008  b 0x828690d8
	pc = 0x828690D8; continue 'dispatch;
            }
            0x828690D4 => {
    //   block [0x828690D4..0x828690D8)
	// 828690D4: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	pc = 0x828690D8; continue 'dispatch;
            }
            0x828690D8 => {
    //   block [0x828690D8..0x82869114)
	// 828690D8: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 828690DC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828690E0: 419A0034  beq cr6, 0x82869114
	if ctx.cr[6].eq {
	pc = 0x82869114; continue 'dispatch;
	}
	// 828690E4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828690E8: 4B9B6171  bl 0x8221f258
	ctx.lr = 0x828690EC;
	sub_8221F258(ctx, base);
	// 828690EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828690F0: 419A0024  beq cr6, 0x82869114
	if ctx.cr[6].eq {
	pc = 0x82869114; continue 'dispatch;
	}
	// 828690F4: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 828690F8: 93630008  stw r27, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828690FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82869100: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82869104: 392BAE58  addi r9, r11, -0x51a8
	ctx.r[9].s64 = ctx.r[11].s64 + -20904;
	// 82869108: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8286910C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82869110: 48000008  b 0x82869118
	pc = 0x82869118; continue 'dispatch;
            }
            0x82869114 => {
    //   block [0x82869114..0x82869118)
	// 82869114: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	pc = 0x82869118; continue 'dispatch;
            }
            0x82869118 => {
    //   block [0x82869118..0x82869170)
	// 82869118: 81410174  lwz r10, 0x174(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 8286911C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82869120: 386A001C  addi r3, r10, 0x1c
	ctx.r[3].s64 = ctx.r[10].s64 + 28;
	// 82869124: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82869128: 917B0004  stw r11, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8286912C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82869130: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82869134: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82869138: 4BA8C811  bl 0x822f5948
	ctx.lr = 0x8286913C;
	sub_822F5948(ctx, base);
	// 8286913C: 81753A84  lwz r11, 0x3a84(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(14980 as u32) ) } as u64;
	// 82869140: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82869144: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82869148: 409A0028  bne cr6, 0x82869170
	if !ctx.cr[6].eq {
	pc = 0x82869170; continue 'dispatch;
	}
	// 8286914C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82869150: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82869154: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82869158: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 8286915C: 91753A84  stw r11, 0x3a84(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(14980 as u32), ctx.r[11].u32 ) };
	// 82869160: 4B98ABF9  bl 0x821f3d58
	ctx.lr = 0x82869164;
	sub_821F3D58(ctx, base);
	// 82869164: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82869168: 93D63A88  stw r30, 0x3a88(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(14984 as u32), ctx.r[30].u32 ) };
	// 8286916C: 48000008  b 0x82869174
	pc = 0x82869174; continue 'dispatch;
            }
            0x82869170 => {
    //   block [0x82869170..0x82869174)
	// 82869170: 83D63A88  lwz r30, 0x3a88(r22)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(14984 as u32) ) } as u64;
	pc = 0x82869174; continue 'dispatch;
            }
            0x82869174 => {
    //   block [0x82869174..0x82869194)
	// 82869174: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82869178: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286917C: 4B960D0D  bl 0x821c9e88
	ctx.lr = 0x82869180;
	sub_821C9E88(ctx, base);
	// 82869180: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82869184: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82869188: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8286918C: 419A011C  beq cr6, 0x828692a8
	if ctx.cr[6].eq {
	pc = 0x828692A8; continue 'dispatch;
	}
	// 82869190: 3BFB0020  addi r31, r27, 0x20
	ctx.r[31].s64 = ctx.r[27].s64 + 32;
	pc = 0x82869194; continue 'dispatch;
            }
            0x82869194 => {
    //   block [0x82869194..0x82869208)
	// 82869194: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82869198: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8286919C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828691A0: 4B95D6C1  bl 0x821c6860
	ctx.lr = 0x828691A4;
	sub_821C6860(ctx, base);
	// 828691A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828691A8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828691AC: 4B97119D  bl 0x821da348
	ctx.lr = 0x828691B0;
	sub_821DA348(ctx, base);
	// 828691B0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828691B4: 4B949345  bl 0x821b24f8
	ctx.lr = 0x828691B8;
	sub_821B24F8(ctx, base);
	// 828691B8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828691BC: 7C6E1B78  mr r14, r3
	ctx.r[14].u64 = ctx.r[3].u64;
	// 828691C0: 4B92D9C1  bl 0x82196b80
	ctx.lr = 0x828691C4;
	sub_82196B80(ctx, base);
	// 828691C4: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 828691C8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828691CC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828691D0: 4B92D9B1  bl 0x82196b80
	ctx.lr = 0x828691D4;
	sub_82196B80(ctx, base);
	// 828691D4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828691D8: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 828691DC: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 828691E0: 4B92D9A1  bl 0x82196b80
	ctx.lr = 0x828691E4;
	sub_82196B80(ctx, base);
	// 828691E4: D03B000C  stfs f1, 0xc(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828691E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828691EC: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 828691F0: D3C1009C  stfs f30, 0x9c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 828691F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828691F8: D02100A0  stfs f1, 0xa0(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 828691FC: 409A000C  bne cr6, 0x82869208
	if !ctx.cr[6].eq {
	pc = 0x82869208; continue 'dispatch;
	}
	// 82869200: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82869204: 48000014  b 0x82869218
	pc = 0x82869218; continue 'dispatch;
            }
            0x82869208 => {
    //   block [0x82869208..0x82869218)
	// 82869208: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286920C: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 82869210: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82869214: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82869218; continue 'dispatch;
            }
            0x82869218 => {
    //   block [0x82869218..0x8286925C)
	// 82869218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286921C: 419A004C  beq cr6, 0x82869268
	if ctx.cr[6].eq {
	pc = 0x82869268; continue 'dispatch;
	}
	// 82869220: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82869224: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 82869228: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 8286922C: 7CC743D6  divw r6, r7, r8
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	// 82869230: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82869234: 40980034  bge cr6, 0x82869268
	if !ctx.cr[6].lt {
	pc = 0x82869268; continue 'dispatch;
	}
	// 82869238: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286923C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869240: 419A001C  beq cr6, 0x8286925c
	if ctx.cr[6].eq {
	pc = 0x8286925C; continue 'dispatch;
	}
	// 82869244: 81410098  lwz r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82869248: 8121009C  lwz r9, 0x9c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8286924C: 810100A0  lwz r8, 0xa0(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82869250: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82869254: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82869258: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x8286925C; continue 'dispatch;
            }
            0x8286925C => {
    //   block [0x8286925C..0x82869268)
	// 8286925C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82869260: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82869264: 48000034  b 0x82869298
	pc = 0x82869298; continue 'dispatch;
            }
            0x82869268 => {
    //   block [0x82869268..0x82869278)
	// 82869268: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286926C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82869270: 40990008  ble cr6, 0x82869278
	if !ctx.cr[6].gt {
	pc = 0x82869278; continue 'dispatch;
	}
	// 82869274: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82869278; continue 'dispatch;
            }
            0x82869278 => {
    //   block [0x82869278..0x82869298)
	// 82869278: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 8286927C: 38C10098  addi r6, r1, 0x98
	ctx.r[6].s64 = ctx.r[1].s64 + 152;
	// 82869280: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82869284: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82869288: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8286928C: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82869290: 4BEF95D9  bl 0x82762868
	ctx.lr = 0x82869294;
	sub_82762868(ctx, base);
	// 82869294: 83D63A88  lwz r30, 0x3a88(r22)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(14984 as u32) ) } as u64;
	pc = 0x82869298; continue 'dispatch;
            }
            0x82869298 => {
    //   block [0x82869298..0x828692A8)
	// 82869298: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8286929C: 7F1CD040  cmplw cr6, r28, r26
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828692A0: 409AFEF4  bne cr6, 0x82869194
	if !ctx.cr[6].eq {
	pc = 0x82869194; continue 'dispatch;
	}
	// 828692A4: 81C10090  lwz r14, 0x90(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	pc = 0x828692A8; continue 'dispatch;
            }
            0x828692A8 => {
    //   block [0x828692A8..0x828692B4)
	// 828692A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828692AC: 4B94E86D  bl 0x821b7b18
	ctx.lr = 0x828692B0;
	sub_821B7B18(ctx, base);
	// 828692B0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	pc = 0x828692B4; continue 'dispatch;
            }
            0x828692B4 => {
    //   block [0x828692B4..0x828692C8)
	// 828692B4: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828692B8: 39CE0001  addi r14, r14, 1
	ctx.r[14].s64 = ctx.r[14].s64 + 1;
	// 828692BC: 91C10090  stw r14, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[14].u32 ) };
	// 828692C0: 7F0E5840  cmplw cr6, r14, r11
	ctx.cr[6].compare_u32(ctx.r[14].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828692C4: 409AFCE8  bne cr6, 0x82868fac
	if !ctx.cr[6].eq {
	pc = 0x82868FAC; continue 'dispatch;
	}
	pc = 0x828692C8; continue 'dispatch;
            }
            0x828692C8 => {
    //   block [0x828692C8..0x828692D0)
	// 828692C8: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 828692CC: 4B9B2A6D  bl 0x8221bd38
	ctx.lr = 0x828692D0;
	sub_8221BD38(ctx, base);
	pc = 0x828692D0; continue 'dispatch;
            }
            0x828692D0 => {
    //   block [0x828692D0..0x828692E0)
	// 828692D0: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 828692D4: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 828692D8: 48444A4D  bl 0x82cadd24
	ctx.lr = 0x828692DC;
	sub_82CADCEC(ctx, base);
	// 828692DC: 48440144  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828692E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828692E0 size=960
    let mut pc: u32 = 0x828692E0;
    'dispatch: loop {
        match pc {
            0x828692E0 => {
    //   block [0x828692E0..0x8286933C)
	// 828692E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828692E4: 48440121  bl 0x82ca9404
	ctx.lr = 0x828692E8;
	sub_82CA93D0(ctx, base);
	// 828692E8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828692EC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828692F0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828692F4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828692F8: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 828692FC: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869300: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82869304: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 82869308: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286930C: 419A00F4  beq cr6, 0x82869400
	if ctx.cr[6].eq {
	pc = 0x82869400; continue 'dispatch;
	}
	// 82869310: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82869314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869318: 419A0024  beq cr6, 0x8286933c
	if ctx.cr[6].eq {
	pc = 0x8286933C; continue 'dispatch;
	}
	// 8286931C: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 82869320: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82869324: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82869328: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286932C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869330: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82869334: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82869338: 480000CC  b 0x82869404
	pc = 0x82869404; continue 'dispatch;
            }
            0x8286933C => {
    //   block [0x8286933C..0x82869358)
	// 8286933C: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82869340: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82869344: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82869348: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 8286934C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82869350: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869354: 40810054  ble 0x828693a8
	if !ctx.cr[0].gt {
	pc = 0x828693A8; continue 'dispatch;
	}
	pc = 0x82869358; continue 'dispatch;
            }
            0x82869358 => {
    //   block [0x82869358..0x82869378)
	// 82869358: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286935C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82869360: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82869364: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869368: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8286936C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82869370: 41980008  blt cr6, 0x82869378
	if ctx.cr[6].lt {
	pc = 0x82869378; continue 'dispatch;
	}
	// 82869374: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82869378; continue 'dispatch;
            }
            0x82869378 => {
    //   block [0x82869378..0x82869394)
	// 82869378: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286937C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82869380: 419A0014  beq cr6, 0x82869394
	if ctx.cr[6].eq {
	pc = 0x82869394; continue 'dispatch;
	}
	// 82869384: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82869388: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286938C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82869390: 4800000C  b 0x8286939c
	pc = 0x8286939C; continue 'dispatch;
            }
            0x82869394 => {
    //   block [0x82869394..0x8286939C)
	// 82869394: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82869398: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286939C; continue 'dispatch;
            }
            0x8286939C => {
    //   block [0x8286939C..0x828693A8)
	// 8286939C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828693A0: 4199FFB8  bgt cr6, 0x82869358
	if ctx.cr[6].gt {
	pc = 0x82869358; continue 'dispatch;
	}
	// 828693A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828693A8; continue 'dispatch;
            }
            0x828693A8 => {
    //   block [0x828693A8..0x828693C4)
	// 828693A8: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828693AC: 419A0040  beq cr6, 0x828693ec
	if ctx.cr[6].eq {
	pc = 0x828693EC; continue 'dispatch;
	}
	// 828693B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828693B4: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 828693B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828693BC: 41990008  bgt cr6, 0x828693c4
	if ctx.cr[6].gt {
	pc = 0x828693C4; continue 'dispatch;
	}
	// 828693C0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828693C4; continue 'dispatch;
            }
            0x828693C4 => {
    //   block [0x828693C4..0x828693EC)
	// 828693C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828693C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828693CC: 409A0020  bne cr6, 0x828693ec
	if !ctx.cr[6].eq {
	pc = 0x828693EC; continue 'dispatch;
	}
	// 828693D0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828693D4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828693D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828693DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828693E0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828693E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828693E8: 4800001C  b 0x82869404
	pc = 0x82869404; continue 'dispatch;
            }
            0x828693EC => {
    //   block [0x828693EC..0x82869400)
	// 828693EC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828693F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828693F4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828693F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828693FC: 48000008  b 0x82869404
	pc = 0x82869404; continue 'dispatch;
            }
            0x82869400 => {
    //   block [0x82869400..0x82869404)
	// 82869400: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82869404; continue 'dispatch;
            }
            0x82869404 => {
    //   block [0x82869404..0x8286944C)
	// 82869404: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82869408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286940C: 419A0284  beq cr6, 0x82869690
	if ctx.cr[6].eq {
	pc = 0x82869690; continue 'dispatch;
	}
	// 82869410: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82869414: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82869418: 5569D7FE  rlwinm r9, r11, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 8286941C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82869420: 419A00E4  beq cr6, 0x82869504
	if ctx.cr[6].eq {
	pc = 0x82869504; continue 'dispatch;
	}
	// 82869424: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82869428: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286942C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869430: 419A001C  beq cr6, 0x8286944c
	if ctx.cr[6].eq {
	pc = 0x8286944C; continue 'dispatch;
	}
	// 82869434: 896B0006  lbz r11, 6(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82869438: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8286943C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82869440: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82869444: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869448: 480000C0  b 0x82869508
	pc = 0x82869508; continue 'dispatch;
            }
            0x8286944C => {
    //   block [0x8286944C..0x82869464)
	// 8286944C: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82869450: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82869454: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82869458: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286945C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869460: 40810054  ble 0x828694b4
	if !ctx.cr[0].gt {
	pc = 0x828694B4; continue 'dispatch;
	}
	pc = 0x82869464; continue 'dispatch;
            }
            0x82869464 => {
    //   block [0x82869464..0x82869484)
	// 82869464: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82869468: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286946C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82869470: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869474: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 82869478: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286947C: 41980008  blt cr6, 0x82869484
	if ctx.cr[6].lt {
	pc = 0x82869484; continue 'dispatch;
	}
	// 82869480: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82869484; continue 'dispatch;
            }
            0x82869484 => {
    //   block [0x82869484..0x828694A0)
	// 82869484: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82869488: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286948C: 419A0014  beq cr6, 0x828694a0
	if ctx.cr[6].eq {
	pc = 0x828694A0; continue 'dispatch;
	}
	// 82869490: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82869494: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82869498: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286949C: 4800000C  b 0x828694a8
	pc = 0x828694A8; continue 'dispatch;
            }
            0x828694A0 => {
    //   block [0x828694A0..0x828694A8)
	// 828694A0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828694A4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828694A8; continue 'dispatch;
            }
            0x828694A8 => {
    //   block [0x828694A8..0x828694B4)
	// 828694A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828694AC: 4199FFB8  bgt cr6, 0x82869464
	if ctx.cr[6].gt {
	pc = 0x82869464; continue 'dispatch;
	}
	// 828694B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828694B4; continue 'dispatch;
            }
            0x828694B4 => {
    //   block [0x828694B4..0x828694D0)
	// 828694B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828694B8: 419A003C  beq cr6, 0x828694f4
	if ctx.cr[6].eq {
	pc = 0x828694F4; continue 'dispatch;
	}
	// 828694BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828694C0: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 828694C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828694C8: 41990008  bgt cr6, 0x828694d0
	if ctx.cr[6].gt {
	pc = 0x828694D0; continue 'dispatch;
	}
	// 828694CC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828694D0; continue 'dispatch;
            }
            0x828694D0 => {
    //   block [0x828694D0..0x828694F4)
	// 828694D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828694D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828694D8: 409A001C  bne cr6, 0x828694f4
	if !ctx.cr[6].eq {
	pc = 0x828694F4; continue 'dispatch;
	}
	// 828694DC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828694E0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828694E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828694E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828694EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828694F0: 48000018  b 0x82869508
	pc = 0x82869508; continue 'dispatch;
            }
            0x828694F4 => {
    //   block [0x828694F4..0x82869504)
	// 828694F4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828694F8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828694FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82869500: 48000008  b 0x82869508
	pc = 0x82869508; continue 'dispatch;
            }
            0x82869504 => {
    //   block [0x82869504..0x82869508)
	// 82869504: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82869508; continue 'dispatch;
            }
            0x82869508 => {
    //   block [0x82869508..0x82869590)
	// 82869508: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286950C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869510: 419A0180  beq cr6, 0x82869690
	if ctx.cr[6].eq {
	pc = 0x82869690; continue 'dispatch;
	}
	// 82869514: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82869518: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 8286951C: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82869520: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82869524: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82869528: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8286952C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82869530: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82869534: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82869538: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 8286953C: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82869540: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82869544: 9BC10089  stb r30, 0x89(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(137 as u32), ctx.r[30].u8 ) };
	// 82869548: 93C10090  stw r30, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 8286954C: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 82869550: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 82869554: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 82869558: 93C100A4  stw r30, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 8286955C: 93C100A8  stw r30, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 82869560: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869564: 80AA0094  lwz r5, 0x94(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(148 as u32) ) } as u64;
	// 82869568: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8286956C: 80CA001C  lwz r6, 0x1c(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82869570: 48000949  bl 0x82869eb8
	ctx.lr = 0x82869574;
	sub_82869EB8(ctx, base);
	// 82869574: 815B0030  lwz r10, 0x30(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 82869578: 813B0034  lwz r9, 0x34(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 8286957C: 3BFB002C  addi r31, r27, 0x2c
	ctx.r[31].s64 = ctx.r[27].s64 + 44;
	// 82869580: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82869584: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82869588: 40990008  ble cr6, 0x82869590
	if !ctx.cr[6].gt {
	pc = 0x82869590; continue 'dispatch;
	}
	// 8286958C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82869590; continue 'dispatch;
            }
            0x82869590 => {
    //   block [0x82869590..0x828695AC)
	// 82869590: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869594: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869598: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8286959C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828695A0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828695A4: 40990008  ble cr6, 0x828695ac
	if !ctx.cr[6].gt {
	pc = 0x828695AC; continue 'dispatch;
	}
	// 828695A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828695AC; continue 'dispatch;
            }
            0x828695AC => {
    //   block [0x828695AC..0x828695B4)
	// 828695AC: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828695B0: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x828695B4; continue 'dispatch;
            }
            0x828695B4 => {
    //   block [0x828695B4..0x828695C0)
	// 828695B4: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828695B8: 40990008  ble cr6, 0x828695c0
	if !ctx.cr[6].gt {
	pc = 0x828695C0; continue 'dispatch;
	}
	// 828695BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828695C0; continue 'dispatch;
            }
            0x828695C0 => {
    //   block [0x828695C0..0x828695CC)
	// 828695C0: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828695C4: 419A0008  beq cr6, 0x828695cc
	if ctx.cr[6].eq {
	pc = 0x828695CC; continue 'dispatch;
	}
	// 828695C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828695CC; continue 'dispatch;
            }
            0x828695CC => {
    //   block [0x828695CC..0x828695E8)
	// 828695CC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828695D0: 419A005C  beq cr6, 0x8286962c
	if ctx.cr[6].eq {
	pc = 0x8286962C; continue 'dispatch;
	}
	// 828695D4: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828695D8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828695DC: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 828695E0: 41980008  blt cr6, 0x828695e8
	if ctx.cr[6].lt {
	pc = 0x828695E8; continue 'dispatch;
	}
	// 828695E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828695E8; continue 'dispatch;
            }
            0x828695E8 => {
    //   block [0x828695E8..0x8286960C)
	// 828695E8: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828695EC: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828695F0: 80650018  lwz r3, 0x18(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 828695F4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828695F8: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828695FC: 41980018  blt cr6, 0x82869614
	if ctx.cr[6].lt {
	pc = 0x82869614; continue 'dispatch;
	}
	// 82869600: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82869604: 41980008  blt cr6, 0x8286960c
	if ctx.cr[6].lt {
	pc = 0x8286960C; continue 'dispatch;
	}
	// 82869608: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8286960C; continue 'dispatch;
            }
            0x8286960C => {
    //   block [0x8286960C..0x82869614)
	// 8286960C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82869610: 4BFFFFA4  b 0x828695b4
	pc = 0x828695B4; continue 'dispatch;
            }
            0x82869614 => {
    //   block [0x82869614..0x8286962C)
	// 82869614: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82869618: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8286961C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82869620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869624: 4BA8D3DD  bl 0x822f6a00
	ctx.lr = 0x82869628;
	sub_822F6A00(ctx, base);
	// 82869628: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	pc = 0x8286962C; continue 'dispatch;
            }
            0x8286962C => {
    //   block [0x8286962C..0x82869644)
	// 8286962C: 54CB063E  clrlwi r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82869630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869634: 409A0010  bne cr6, 0x82869644
	if !ctx.cr[6].eq {
	pc = 0x82869644; continue 'dispatch;
	}
	// 82869638: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8286963C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82869640: 4BA8C309  bl 0x822f5948
	ctx.lr = 0x82869644;
	sub_822F5948(ctx, base);
	pc = 0x82869644; continue 'dispatch;
            }
            0x82869644 => {
    //   block [0x82869644..0x82869670)
	// 82869644: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82869648: 4B9B5C11  bl 0x8221f258
	ctx.lr = 0x8286964C;
	sub_8221F258(ctx, base);
	// 8286964C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82869650: 419A0020  beq cr6, 0x82869670
	if ctx.cr[6].eq {
	pc = 0x82869670; continue 'dispatch;
	}
	// 82869654: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869658: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8286965C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82869660: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869664: 4BEF8775  bl 0x82761dd8
	ctx.lr = 0x82869668;
	sub_82761DD8(ctx, base);
	// 82869668: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286966C: 48000008  b 0x82869674
	pc = 0x82869674; continue 'dispatch;
            }
            0x82869670 => {
    //   block [0x82869670..0x82869674)
	// 82869670: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x82869674; continue 'dispatch;
            }
            0x82869674 => {
    //   block [0x82869674..0x82869690)
	// 82869674: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869678: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 8286967C: 4BA099DD  bl 0x82273058
	ctx.lr = 0x82869680;
	sub_82273058(ctx, base);
	// 82869680: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82869684: 480001DD  bl 0x82869860
	ctx.lr = 0x82869688;
	sub_82869860(ctx, base);
	// 82869688: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8286968C: 4BF9E0C5  bl 0x82807750
	ctx.lr = 0x82869690;
	sub_82807750(ctx, base);
	pc = 0x82869690; continue 'dispatch;
            }
            0x82869690 => {
    //   block [0x82869690..0x828696A0)
	// 82869690: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82869694: 4B94E485  bl 0x821b7b18
	ctx.lr = 0x82869698;
	sub_821B7B18(ctx, base);
	// 82869698: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8286969C: 4843FDB8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828696A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828696A0 size=444
    let mut pc: u32 = 0x828696A0;
    'dispatch: loop {
        match pc {
            0x828696A0 => {
    //   block [0x828696A0..0x828696E8)
	// 828696A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828696A4: 4843FD61  bl 0x82ca9404
	ctx.lr = 0x828696A8;
	sub_82CA93D0(ctx, base);
	// 828696A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828696AC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828696B0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828696B4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828696B8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828696BC: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 828696C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828696C4: 419A0078  beq cr6, 0x8286973c
	if ctx.cr[6].eq {
	pc = 0x8286973C; continue 'dispatch;
	}
	// 828696C8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828696CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828696D0: 409A0064  bne cr6, 0x82869734
	if !ctx.cr[6].eq {
	pc = 0x82869734; continue 'dispatch;
	}
	// 828696D4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828696D8: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828696DC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828696E0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828696E4: 40810050  ble 0x82869734
	if !ctx.cr[0].gt {
	pc = 0x82869734; continue 'dispatch;
	}
	pc = 0x828696E8; continue 'dispatch;
            }
            0x828696E8 => {
    //   block [0x828696E8..0x82869708)
	// 828696E8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828696EC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828696F0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828696F4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828696F8: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828696FC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82869700: 41980008  blt cr6, 0x82869708
	if ctx.cr[6].lt {
	pc = 0x82869708; continue 'dispatch;
	}
	// 82869704: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82869708; continue 'dispatch;
            }
            0x82869708 => {
    //   block [0x82869708..0x82869724)
	// 82869708: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286970C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82869710: 419A0014  beq cr6, 0x82869724
	if ctx.cr[6].eq {
	pc = 0x82869724; continue 'dispatch;
	}
	// 82869714: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82869718: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286971C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82869720: 4800000C  b 0x8286972c
	pc = 0x8286972C; continue 'dispatch;
            }
            0x82869724 => {
    //   block [0x82869724..0x8286972C)
	// 82869724: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82869728: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286972C; continue 'dispatch;
            }
            0x8286972C => {
    //   block [0x8286972C..0x82869734)
	// 8286972C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869730: 4199FFB8  bgt cr6, 0x828696e8
	if ctx.cr[6].gt {
	pc = 0x828696E8; continue 'dispatch;
	}
	pc = 0x82869734; continue 'dispatch;
            }
            0x82869734 => {
    //   block [0x82869734..0x8286973C)
	// 82869734: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82869738: 48000008  b 0x82869740
	pc = 0x82869740; continue 'dispatch;
            }
            0x8286973C => {
    //   block [0x8286973C..0x82869740)
	// 8286973C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82869740; continue 'dispatch;
            }
            0x82869740 => {
    //   block [0x82869740..0x82869764)
	// 82869740: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82869744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869748: 419A0104  beq cr6, 0x8286984c
	if ctx.cr[6].eq {
	pc = 0x8286984C; continue 'dispatch;
	}
	// 8286974C: 83FB0030  lwz r31, 0x30(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 82869750: 3BBB002C  addi r29, r27, 0x2c
	ctx.r[29].s64 = ctx.r[27].s64 + 44;
	// 82869754: 817B0034  lwz r11, 0x34(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 82869758: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8286975C: 40990008  ble cr6, 0x82869764
	if !ctx.cr[6].gt {
	pc = 0x82869764; continue 'dispatch;
	}
	// 82869760: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82869764; continue 'dispatch;
            }
            0x82869764 => {
    //   block [0x82869764..0x8286976C)
	// 82869764: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82869768: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	pc = 0x8286976C; continue 'dispatch;
            }
            0x8286976C => {
    //   block [0x8286976C..0x82869770)
	// 8286976C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	pc = 0x82869770; continue 'dispatch;
            }
            0x82869770 => {
    //   block [0x82869770..0x82869784)
	// 82869770: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869774: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869778: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8286977C: 40990008  ble cr6, 0x82869784
	if !ctx.cr[6].gt {
	pc = 0x82869784; continue 'dispatch;
	}
	// 82869780: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82869784; continue 'dispatch;
            }
            0x82869784 => {
    //   block [0x82869784..0x82869794)
	// 82869784: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82869788: 419A000C  beq cr6, 0x82869794
	if ctx.cr[6].eq {
	pc = 0x82869794; continue 'dispatch;
	}
	// 8286978C: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82869790: 419A0008  beq cr6, 0x82869798
	if ctx.cr[6].eq {
	pc = 0x82869798; continue 'dispatch;
	}
	pc = 0x82869794; continue 'dispatch;
            }
            0x82869794 => {
    //   block [0x82869794..0x82869798)
	// 82869794: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82869798; continue 'dispatch;
            }
            0x82869798 => {
    //   block [0x82869798..0x828697AC)
	// 82869798: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8286979C: 419A00A8  beq cr6, 0x82869844
	if ctx.cr[6].eq {
	pc = 0x82869844; continue 'dispatch;
	}
	// 828697A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828697A4: 409A0008  bne cr6, 0x828697ac
	if !ctx.cr[6].eq {
	pc = 0x828697AC; continue 'dispatch;
	}
	// 828697A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828697AC; continue 'dispatch;
            }
            0x828697AC => {
    //   block [0x828697AC..0x828697BC)
	// 828697AC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828697B0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828697B4: 41980008  blt cr6, 0x828697bc
	if ctx.cr[6].lt {
	pc = 0x828697BC; continue 'dispatch;
	}
	// 828697B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828697BC; continue 'dispatch;
            }
            0x828697BC => {
    //   block [0x828697BC..0x828697D8)
	// 828697BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828697C0: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828697C4: 7F034800  cmpw cr6, r3, r9
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828697C8: 409A0068  bne cr6, 0x82869830
	if !ctx.cr[6].eq {
	pc = 0x82869830; continue 'dispatch;
	}
	// 828697CC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828697D0: 41980008  blt cr6, 0x828697d8
	if ctx.cr[6].lt {
	pc = 0x828697D8; continue 'dispatch;
	}
	// 828697D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828697D8; continue 'dispatch;
            }
            0x828697D8 => {
    //   block [0x828697D8..0x828697FC)
	// 828697D8: 4BFFEF81  bl 0x82868758
	ctx.lr = 0x828697DC;
	sub_82868758(ctx, base);
	// 828697DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828697E0: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828697E4: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828697E8: 48301291  bl 0x82b6aa78
	ctx.lr = 0x828697EC;
	sub_82B6AA78(ctx, base);
	// 828697EC: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828697F0: 3BFEFFF8  addi r31, r30, -8
	ctx.r[31].s64 = ctx.r[30].s64 + -8;
	// 828697F4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828697F8: 419A0018  beq cr6, 0x82869810
	if ctx.cr[6].eq {
	pc = 0x82869810; continue 'dispatch;
	}
	pc = 0x828697FC; continue 'dispatch;
            }
            0x828697FC => {
    //   block [0x828697FC..0x82869810)
	// 828697FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82869800: 4B94E319  bl 0x821b7b18
	ctx.lr = 0x82869804;
	sub_821B7B18(ctx, base);
	// 82869804: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82869808: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8286980C: 409AFFF0  bne cr6, 0x828697fc
	if !ctx.cr[6].eq {
	pc = 0x828697FC; continue 'dispatch;
	}
	pc = 0x82869810; continue 'dispatch;
            }
            0x82869810 => {
    //   block [0x82869810..0x82869830)
	// 82869810: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82869814: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869818: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 8286981C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82869820: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82869824: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82869828: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8286982C: 4BFFFF44  b 0x82869770
	pc = 0x82869770; continue 'dispatch;
            }
            0x82869830 => {
    //   block [0x82869830..0x8286983C)
	// 82869830: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82869834: 41980008  blt cr6, 0x8286983c
	if ctx.cr[6].lt {
	pc = 0x8286983C; continue 'dispatch;
	}
	// 82869838: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8286983C; continue 'dispatch;
            }
            0x8286983C => {
    //   block [0x8286983C..0x82869844)
	// 8286983C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82869840: 4BFFFF2C  b 0x8286976c
	pc = 0x8286976C; continue 'dispatch;
            }
            0x82869844 => {
    //   block [0x82869844..0x8286984C)
	// 82869844: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82869848: 48000019  bl 0x82869860
	ctx.lr = 0x8286984C;
	sub_82869860(ctx, base);
	pc = 0x8286984C; continue 'dispatch;
            }
            0x8286984C => {
    //   block [0x8286984C..0x8286985C)
	// 8286984C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82869850: 4B94E2C9  bl 0x821b7b18
	ctx.lr = 0x82869854;
	sub_821B7B18(ctx, base);
	// 82869854: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82869858: 4843FBFC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82869860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82869860 size=1624
    let mut pc: u32 = 0x82869860;
    'dispatch: loop {
        match pc {
            0x82869860 => {
    //   block [0x82869860..0x828698B8)
	// 82869860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82869864: 4843FB91  bl 0x82ca93f4
	ctx.lr = 0x82869868;
	sub_82CA93D0(ctx, base);
	// 82869868: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286986C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82869870: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82869874: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	// 82869878: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286987C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82869880: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82869884: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82869888: 419A00F4  beq cr6, 0x8286997c
	if ctx.cr[6].eq {
	pc = 0x8286997C; continue 'dispatch;
	}
	// 8286988C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82869890: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82869894: 419A0024  beq cr6, 0x828698b8
	if ctx.cr[6].eq {
	pc = 0x828698B8; continue 'dispatch;
	}
	// 82869898: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 8286989C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828698A0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828698A4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828698A8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828698AC: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 828698B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828698B4: 480000CC  b 0x82869980
	pc = 0x82869980; continue 'dispatch;
            }
            0x828698B8 => {
    //   block [0x828698B8..0x828698D4)
	// 828698B8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828698BC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828698C0: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 828698C4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828698C8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828698CC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828698D0: 40810054  ble 0x82869924
	if !ctx.cr[0].gt {
	pc = 0x82869924; continue 'dispatch;
	}
	pc = 0x828698D4; continue 'dispatch;
            }
            0x828698D4 => {
    //   block [0x828698D4..0x828698F4)
	// 828698D4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828698D8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828698DC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828698E0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828698E4: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828698E8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828698EC: 41980008  blt cr6, 0x828698f4
	if ctx.cr[6].lt {
	pc = 0x828698F4; continue 'dispatch;
	}
	// 828698F0: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	pc = 0x828698F4; continue 'dispatch;
            }
            0x828698F4 => {
    //   block [0x828698F4..0x82869910)
	// 828698F4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828698F8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828698FC: 419A0014  beq cr6, 0x82869910
	if ctx.cr[6].eq {
	pc = 0x82869910; continue 'dispatch;
	}
	// 82869900: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82869904: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82869908: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286990C: 4800000C  b 0x82869918
	pc = 0x82869918; continue 'dispatch;
            }
            0x82869910 => {
    //   block [0x82869910..0x82869918)
	// 82869910: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82869914: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82869918; continue 'dispatch;
            }
            0x82869918 => {
    //   block [0x82869918..0x82869924)
	// 82869918: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286991C: 4199FFB8  bgt cr6, 0x828698d4
	if ctx.cr[6].gt {
	pc = 0x828698D4; continue 'dispatch;
	}
	// 82869920: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82869924; continue 'dispatch;
            }
            0x82869924 => {
    //   block [0x82869924..0x82869940)
	// 82869924: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82869928: 419A0040  beq cr6, 0x82869968
	if ctx.cr[6].eq {
	pc = 0x82869968; continue 'dispatch;
	}
	// 8286992C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869930: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82869934: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82869938: 41990008  bgt cr6, 0x82869940
	if ctx.cr[6].gt {
	pc = 0x82869940; continue 'dispatch;
	}
	// 8286993C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x82869940; continue 'dispatch;
            }
            0x82869940 => {
    //   block [0x82869940..0x82869968)
	// 82869940: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82869944: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869948: 409A0020  bne cr6, 0x82869968
	if !ctx.cr[6].eq {
	pc = 0x82869968; continue 'dispatch;
	}
	// 8286994C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82869950: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82869954: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82869958: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286995C: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 82869960: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82869964: 4800001C  b 0x82869980
	pc = 0x82869980; continue 'dispatch;
            }
            0x82869968 => {
    //   block [0x82869968..0x8286997C)
	// 82869968: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286996C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869970: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 82869974: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82869978: 48000008  b 0x82869980
	pc = 0x82869980; continue 'dispatch;
            }
            0x8286997C => {
    //   block [0x8286997C..0x82869980)
	// 8286997C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x82869980; continue 'dispatch;
            }
            0x82869980 => {
    //   block [0x82869980..0x828699A8)
	// 82869980: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82869984: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869988: 419A0528  beq cr6, 0x82869eb0
	if ctx.cr[6].eq {
	pc = 0x82869EB0; continue 'dispatch;
	}
	// 8286998C: 83F90030  lwz r31, 0x30(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 82869990: 3B99002C  addi r28, r25, 0x2c
	ctx.r[28].s64 = ctx.r[25].s64 + 44;
	// 82869994: 81790034  lwz r11, 0x34(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(52 as u32) ) } as u64;
	// 82869998: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 8286999C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828699A0: 40990008  ble cr6, 0x828699a8
	if !ctx.cr[6].gt {
	pc = 0x828699A8; continue 'dispatch;
	}
	// 828699A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828699A8; continue 'dispatch;
            }
            0x828699A8 => {
    //   block [0x828699A8..0x828699B0)
	// 828699A8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 828699AC: 3B6A4248  addi r27, r10, 0x4248
	ctx.r[27].s64 = ctx.r[10].s64 + 16968;
	pc = 0x828699B0; continue 'dispatch;
            }
            0x828699B0 => {
    //   block [0x828699B0..0x828699C4)
	// 828699B0: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828699B4: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828699B8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828699BC: 40990008  ble cr6, 0x828699c4
	if !ctx.cr[6].gt {
	pc = 0x828699C4; continue 'dispatch;
	}
	// 828699C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828699C4; continue 'dispatch;
            }
            0x828699C4 => {
    //   block [0x828699C4..0x828699D0)
	// 828699C4: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828699C8: 419A0008  beq cr6, 0x828699d0
	if ctx.cr[6].eq {
	pc = 0x828699D0; continue 'dispatch;
	}
	// 828699CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828699D0; continue 'dispatch;
            }
            0x828699D0 => {
    //   block [0x828699D0..0x828699E4)
	// 828699D0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828699D4: 419A01F8  beq cr6, 0x82869bcc
	if ctx.cr[6].eq {
	pc = 0x82869BCC; continue 'dispatch;
	}
	// 828699D8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828699DC: 41980008  blt cr6, 0x828699e4
	if ctx.cr[6].lt {
	pc = 0x828699E4; continue 'dispatch;
	}
	// 828699E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828699E4; continue 'dispatch;
            }
            0x828699E4 => {
    //   block [0x828699E4..0x82869A00)
	// 828699E4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828699E8: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 828699EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828699F0: 419A0048  beq cr6, 0x82869a38
	if ctx.cr[6].eq {
	pc = 0x82869A38; continue 'dispatch;
	}
	// 828699F4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828699F8: 41980008  blt cr6, 0x82869a00
	if ctx.cr[6].lt {
	pc = 0x82869A00; continue 'dispatch;
	}
	// 828699FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82869A00; continue 'dispatch;
            }
            0x82869A00 => {
    //   block [0x82869A00..0x82869A24)
	// 82869A00: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82869A04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869A08: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869A0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82869A10: 4E800421  bctrl
	ctx.lr = 0x82869A14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82869A14: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869A18: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82869A1C: 41980008  blt cr6, 0x82869a24
	if ctx.cr[6].lt {
	pc = 0x82869A24; continue 'dispatch;
	}
	// 82869A20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x82869A24 => {
    //   block [0x82869A24..0x82869A38)
	// 82869A24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869A28: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 82869A2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869A30: 4B94E0E9  bl 0x821b7b18
	ctx.lr = 0x82869A34;
	sub_821B7B18(ctx, base);
	// 82869A34: 931E0000  stw r24, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	pc = 0x82869A38; continue 'dispatch;
            }
            0x82869A38 => {
    //   block [0x82869A38..0x82869A68)
	// 82869A38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82869A3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82869A40: 419A0068  beq cr6, 0x82869aa8
	if ctx.cr[6].eq {
	pc = 0x82869AA8; continue 'dispatch;
	}
	// 82869A44: 4B9B5815  bl 0x8221f258
	ctx.lr = 0x82869A48;
	sub_8221F258(ctx, base);
	// 82869A48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82869A4C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82869A50: 419A0134  beq cr6, 0x82869b84
	if ctx.cr[6].eq {
	pc = 0x82869B84; continue 'dispatch;
	}
	// 82869A54: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869A58: 83BD0010  lwz r29, 0x10(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82869A5C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82869A60: 41980008  blt cr6, 0x82869a68
	if ctx.cr[6].lt {
	pc = 0x82869A68; continue 'dispatch;
	}
	// 82869A64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82869A68; continue 'dispatch;
            }
            0x82869A68 => {
    //   block [0x82869A68..0x82869AA8)
	// 82869A68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869A6C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82869A70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869A74: 82EB0008  lwz r23, 8(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869A78: 4BEF7049  bl 0x82760ac0
	ctx.lr = 0x82869A7C;
	sub_82760AC0(ctx, base);
	// 82869A7C: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82869A80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869A84: 4BA1A4E5  bl 0x82283f68
	ctx.lr = 0x82869A88;
	sub_82283F68(ctx, base);
	// 82869A88: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82869A8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869A90: 4BEF8579  bl 0x82762008
	ctx.lr = 0x82869A94;
	sub_82762008(ctx, base);
	// 82869A94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82869A98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869A9C: 4BEF8685  bl 0x82762120
	ctx.lr = 0x82869AA0;
	sub_82762120(ctx, base);
	// 82869AA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82869AA4: 480000E4  b 0x82869b88
	pc = 0x82869B88; continue 'dispatch;
            }
            0x82869AA8 => {
    //   block [0x82869AA8..0x82869AD8)
	// 82869AA8: 81790060  lwz r11, 0x60(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(96 as u32) ) } as u64;
	// 82869AAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869AB0: 419A0068  beq cr6, 0x82869b18
	if ctx.cr[6].eq {
	pc = 0x82869B18; continue 'dispatch;
	}
	// 82869AB4: 4B9B57A5  bl 0x8221f258
	ctx.lr = 0x82869AB8;
	sub_8221F258(ctx, base);
	// 82869AB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82869ABC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82869AC0: 419A00C4  beq cr6, 0x82869b84
	if ctx.cr[6].eq {
	pc = 0x82869B84; continue 'dispatch;
	}
	// 82869AC4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869AC8: 83B90060  lwz r29, 0x60(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(96 as u32) ) } as u64;
	// 82869ACC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82869AD0: 41980008  blt cr6, 0x82869ad8
	if ctx.cr[6].lt {
	pc = 0x82869AD8; continue 'dispatch;
	}
	// 82869AD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82869AD8; continue 'dispatch;
            }
            0x82869AD8 => {
    //   block [0x82869AD8..0x82869B18)
	// 82869AD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869ADC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82869AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869AE4: 82EB0008  lwz r23, 8(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869AE8: 4BEF6FD9  bl 0x82760ac0
	ctx.lr = 0x82869AEC;
	sub_82760AC0(ctx, base);
	// 82869AEC: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82869AF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869AF4: 4BA1A475  bl 0x82283f68
	ctx.lr = 0x82869AF8;
	sub_82283F68(ctx, base);
	// 82869AF8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82869AFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869B00: 4BEF8509  bl 0x82762008
	ctx.lr = 0x82869B04;
	sub_82762008(ctx, base);
	// 82869B04: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82869B08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869B0C: 4BEF8615  bl 0x82762120
	ctx.lr = 0x82869B10;
	sub_82762120(ctx, base);
	// 82869B10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82869B14: 48000074  b 0x82869b88
	pc = 0x82869B88; continue 'dispatch;
            }
            0x82869B18 => {
    //   block [0x82869B18..0x82869B38)
	// 82869B18: 4B9B5741  bl 0x8221f258
	ctx.lr = 0x82869B1C;
	sub_8221F258(ctx, base);
	// 82869B1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82869B20: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82869B24: 419A0060  beq cr6, 0x82869b84
	if ctx.cr[6].eq {
	pc = 0x82869B84; continue 'dispatch;
	}
	// 82869B28: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869B2C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82869B30: 41980008  blt cr6, 0x82869b38
	if ctx.cr[6].lt {
	pc = 0x82869B38; continue 'dispatch;
	}
	// 82869B34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82869B38; continue 'dispatch;
            }
            0x82869B38 => {
    //   block [0x82869B38..0x82869B4C)
	// 82869B38: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869B3C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82869B40: 83AA0008  lwz r29, 8(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869B44: 41980008  blt cr6, 0x82869b4c
	if ctx.cr[6].lt {
	pc = 0x82869B4C; continue 'dispatch;
	}
	// 82869B48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82869B4C; continue 'dispatch;
            }
            0x82869B4C => {
    //   block [0x82869B4C..0x82869B84)
	// 82869B4C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82869B50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869B54: 4BEF6F6D  bl 0x82760ac0
	ctx.lr = 0x82869B58;
	sub_82760AC0(ctx, base);
	// 82869B58: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82869B5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869B60: 4BA1A409  bl 0x82283f68
	ctx.lr = 0x82869B64;
	sub_82283F68(ctx, base);
	// 82869B64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82869B68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869B6C: 4BEF849D  bl 0x82762008
	ctx.lr = 0x82869B70;
	sub_82762008(ctx, base);
	// 82869B70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82869B74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869B78: 4BEF85A9  bl 0x82762120
	ctx.lr = 0x82869B7C;
	sub_82762120(ctx, base);
	// 82869B7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82869B80: 48000008  b 0x82869b88
	pc = 0x82869B88; continue 'dispatch;
            }
            0x82869B84 => {
    //   block [0x82869B84..0x82869B88)
	// 82869B84: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	pc = 0x82869B88; continue 'dispatch;
            }
            0x82869B88 => {
    //   block [0x82869B88..0x82869B98)
	// 82869B88: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869B8C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82869B90: 41980008  blt cr6, 0x82869b98
	if ctx.cr[6].lt {
	pc = 0x82869B98; continue 'dispatch;
	}
	// 82869B94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82869B98; continue 'dispatch;
            }
            0x82869B98 => {
    //   block [0x82869B98..0x82869BB4)
	// 82869B98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869B9C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82869BA0: 4BA094B9  bl 0x82273058
	ctx.lr = 0x82869BA4;
	sub_82273058(ctx, base);
	// 82869BA4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869BA8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82869BAC: 41980008  blt cr6, 0x82869bb4
	if ctx.cr[6].lt {
	pc = 0x82869BB4; continue 'dispatch;
	}
	// 82869BB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82869BB4; continue 'dispatch;
            }
            0x82869BB4 => {
    //   block [0x82869BB4..0x82869BC4)
	// 82869BB4: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869BB8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82869BBC: 41980008  blt cr6, 0x82869bc4
	if ctx.cr[6].lt {
	pc = 0x82869BC4; continue 'dispatch;
	}
	// 82869BC0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82869BC4; continue 'dispatch;
            }
            0x82869BC4 => {
    //   block [0x82869BC4..0x82869BCC)
	// 82869BC4: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82869BC8: 4BFFFDE8  b 0x828699b0
	pc = 0x828699B0; continue 'dispatch;
            }
            0x82869BCC => {
    //   block [0x82869BCC..0x82869BF8)
	// 82869BCC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82869BD0: 419A027C  beq cr6, 0x82869e4c
	if ctx.cr[6].eq {
	pc = 0x82869E4C; continue 'dispatch;
	}
	// 82869BD4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82869BD8: 4B9B5681  bl 0x8221f258
	ctx.lr = 0x82869BDC;
	sub_8221F258(ctx, base);
	// 82869BDC: 3FE0820A  lis r31, -0x7df6
	ctx.r[31].s64 = -2113273856;
	// 82869BE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82869BE4: 419A0014  beq cr6, 0x82869bf8
	if ctx.cr[6].eq {
	pc = 0x82869BF8; continue 'dispatch;
	}
	// 82869BE8: C03FB730  lfs f1, -0x48d0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-18640 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82869BEC: 4BA21F55  bl 0x8228bb40
	ctx.lr = 0x82869BF0;
	sub_8228BB40(ctx, base);
	// 82869BF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82869BF4: 48000008  b 0x82869bfc
	pc = 0x82869BFC; continue 'dispatch;
            }
            0x82869BF8 => {
    //   block [0x82869BF8..0x82869BFC)
	// 82869BF8: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	pc = 0x82869BFC; continue 'dispatch;
            }
            0x82869BFC => {
    //   block [0x82869BFC..0x82869C1C)
	// 82869BFC: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82869C00: 4B9B5659  bl 0x8221f258
	ctx.lr = 0x82869C04;
	sub_8221F258(ctx, base);
	// 82869C04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82869C08: 419A0014  beq cr6, 0x82869c1c
	if ctx.cr[6].eq {
	pc = 0x82869C1C; continue 'dispatch;
	}
	// 82869C0C: C03FB730  lfs f1, -0x48d0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-18640 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82869C10: 4B9BFB29  bl 0x82229738
	ctx.lr = 0x82869C14;
	sub_82229738(ctx, base);
	// 82869C14: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82869C18: 48000008  b 0x82869c20
	pc = 0x82869C20; continue 'dispatch;
            }
            0x82869C1C => {
    //   block [0x82869C1C..0x82869C20)
	// 82869C1C: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	pc = 0x82869C20; continue 'dispatch;
            }
            0x82869C20 => {
    //   block [0x82869C20..0x82869C40)
	// 82869C20: 83F90048  lwz r31, 0x48(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(72 as u32) ) } as u64;
	// 82869C24: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82869C28: 419A0030  beq cr6, 0x82869c58
	if ctx.cr[6].eq {
	pc = 0x82869C58; continue 'dispatch;
	}
	// 82869C2C: 809D0010  lwz r4, 0x10(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82869C30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82869C34: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82869C38: 409A0008  bne cr6, 0x82869c40
	if !ctx.cr[6].eq {
	pc = 0x82869C40; continue 'dispatch;
	}
	// 82869C3C: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82869C40; continue 'dispatch;
            }
            0x82869C40 => {
    //   block [0x82869C40..0x82869C58)
	// 82869C40: 4B9F5F21  bl 0x8225fb60
	ctx.lr = 0x82869C44;
	sub_8225FB60(ctx, base);
	// 82869C44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82869C48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82869C4C: 4BCF8F8D  bl 0x82562bd8
	ctx.lr = 0x82869C50;
	sub_82562BD8(ctx, base);
	// 82869C50: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82869C54: 4843F7F0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82869C58 => {
    //   block [0x82869C58..0x82869CA4)
	// 82869C58: 80BD0010  lwz r5, 0x10(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82869C5C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82869C60: 3900001F  li r8, 0x1f
	ctx.r[8].s64 = 31;
	// 82869C64: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82869C68: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 82869C6C: 38C00080  li r6, 0x80
	ctx.r[6].s64 = 128;
	// 82869C70: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82869C74: 419A00EC  beq cr6, 0x82869d60
	if ctx.cr[6].eq {
	pc = 0x82869D60; continue 'dispatch;
	}
	// 82869C78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869C7C: 4BCF943D  bl 0x825630b8
	ctx.lr = 0x82869C80;
	sub_825630B8(ctx, base);
	// 82869C80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82869C84: 81790048  lwz r11, 0x48(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(72 as u32) ) } as u64;
	// 82869C88: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869C8C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82869C90: 419A007C  beq cr6, 0x82869d0c
	if ctx.cr[6].eq {
	pc = 0x82869D0C; continue 'dispatch;
	}
	// 82869C94: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82869C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82869C9C: 419A0040  beq cr6, 0x82869cdc
	if ctx.cr[6].eq {
	pc = 0x82869CDC; continue 'dispatch;
	}
	// 82869CA0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82869CA4; continue 'dispatch;
            }
            0x82869CA4 => {
    //   block [0x82869CA4..0x82869CD8)
	// 82869CA4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82869CA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869CAC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82869CB0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82869CB4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82869CB8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869CBC: 4082FFE8  bne 0x82869ca4
	if !ctx.cr[0].eq {
	pc = 0x82869CA4; continue 'dispatch;
	}
	// 82869CC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869CC4: 409A0014  bne cr6, 0x82869cd8
	if !ctx.cr[6].eq {
	pc = 0x82869CD8; continue 'dispatch;
	}
	// 82869CC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869CCC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869CD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82869CD4: 4E800421  bctrl
	ctx.lr = 0x82869CD8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82869CD8 => {
    //   block [0x82869CD8..0x82869CDC)
	// 82869CD8: 93190048  stw r24, 0x48(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(72 as u32), ctx.r[24].u32 ) };
	pc = 0x82869CDC; continue 'dispatch;
            }
            0x82869CDC => {
    //   block [0x82869CDC..0x82869CF0)
	// 82869CDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869CE4: 91790048  stw r11, 0x48(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82869CE8: 419A0024  beq cr6, 0x82869d0c
	if ctx.cr[6].eq {
	pc = 0x82869D0C; continue 'dispatch;
	}
	// 82869CEC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82869CF0; continue 'dispatch;
            }
            0x82869CF0 => {
    //   block [0x82869CF0..0x82869D0C)
	// 82869CF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82869CF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869CF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82869CFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82869D00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82869D04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869D08: 4082FFE8  bne 0x82869cf0
	if !ctx.cr[0].eq {
	pc = 0x82869CF0; continue 'dispatch;
	}
	pc = 0x82869D0C; continue 'dispatch;
            }
            0x82869D0C => {
    //   block [0x82869D0C..0x82869D20)
	// 82869D0C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82869D10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869D14: 419A019C  beq cr6, 0x82869eb0
	if ctx.cr[6].eq {
	pc = 0x82869EB0; continue 'dispatch;
	}
	// 82869D18: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82869D1C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82869D20; continue 'dispatch;
            }
            0x82869D20 => {
    //   block [0x82869D20..0x82869D60)
	// 82869D20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82869D24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869D28: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82869D2C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82869D30: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82869D34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869D38: 4082FFE8  bne 0x82869d20
	if !ctx.cr[0].eq {
	pc = 0x82869D20; continue 'dispatch;
	}
	// 82869D3C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82869D40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869D44: 409A016C  bne cr6, 0x82869eb0
	if !ctx.cr[6].eq {
	pc = 0x82869EB0; continue 'dispatch;
	}
	// 82869D48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869D4C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869D50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82869D54: 4E800421  bctrl
	ctx.lr = 0x82869D58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82869D58: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82869D5C: 4843F6E8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82869D60 => {
    //   block [0x82869D60..0x82869D90)
	// 82869D60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82869D64: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82869D68: 4BCF9351  bl 0x825630b8
	ctx.lr = 0x82869D6C;
	sub_825630B8(ctx, base);
	// 82869D6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82869D70: 81790048  lwz r11, 0x48(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(72 as u32) ) } as u64;
	// 82869D74: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869D78: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82869D7C: 419A007C  beq cr6, 0x82869df8
	if ctx.cr[6].eq {
	pc = 0x82869DF8; continue 'dispatch;
	}
	// 82869D80: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82869D84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82869D88: 419A0040  beq cr6, 0x82869dc8
	if ctx.cr[6].eq {
	pc = 0x82869DC8; continue 'dispatch;
	}
	// 82869D8C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82869D90; continue 'dispatch;
            }
            0x82869D90 => {
    //   block [0x82869D90..0x82869DC4)
	// 82869D90: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82869D94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869D98: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82869D9C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82869DA0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82869DA4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869DA8: 4082FFE8  bne 0x82869d90
	if !ctx.cr[0].eq {
	pc = 0x82869D90; continue 'dispatch;
	}
	// 82869DAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869DB0: 409A0014  bne cr6, 0x82869dc4
	if !ctx.cr[6].eq {
	pc = 0x82869DC4; continue 'dispatch;
	}
	// 82869DB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869DB8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869DBC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82869DC0: 4E800421  bctrl
	ctx.lr = 0x82869DC4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82869DC4 => {
    //   block [0x82869DC4..0x82869DC8)
	// 82869DC4: 93190048  stw r24, 0x48(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(72 as u32), ctx.r[24].u32 ) };
	pc = 0x82869DC8; continue 'dispatch;
            }
            0x82869DC8 => {
    //   block [0x82869DC8..0x82869DDC)
	// 82869DC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869DCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869DD0: 91790048  stw r11, 0x48(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82869DD4: 419A0024  beq cr6, 0x82869df8
	if ctx.cr[6].eq {
	pc = 0x82869DF8; continue 'dispatch;
	}
	// 82869DD8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82869DDC; continue 'dispatch;
            }
            0x82869DDC => {
    //   block [0x82869DDC..0x82869DF8)
	// 82869DDC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82869DE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869DE4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82869DE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82869DEC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82869DF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869DF4: 4082FFE8  bne 0x82869ddc
	if !ctx.cr[0].eq {
	pc = 0x82869DDC; continue 'dispatch;
	}
	pc = 0x82869DF8; continue 'dispatch;
            }
            0x82869DF8 => {
    //   block [0x82869DF8..0x82869E0C)
	// 82869DF8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82869DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869E00: 419A00B0  beq cr6, 0x82869eb0
	if ctx.cr[6].eq {
	pc = 0x82869EB0; continue 'dispatch;
	}
	// 82869E04: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82869E08: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82869E0C; continue 'dispatch;
            }
            0x82869E0C => {
    //   block [0x82869E0C..0x82869E4C)
	// 82869E0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82869E10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869E14: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82869E18: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82869E1C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82869E20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869E24: 4082FFE8  bne 0x82869e0c
	if !ctx.cr[0].eq {
	pc = 0x82869E0C; continue 'dispatch;
	}
	// 82869E28: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82869E2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869E30: 409A0080  bne cr6, 0x82869eb0
	if !ctx.cr[6].eq {
	pc = 0x82869EB0; continue 'dispatch;
	}
	// 82869E34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869E38: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869E3C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82869E40: 4E800421  bctrl
	ctx.lr = 0x82869E44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82869E44: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82869E48: 4843F5FC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82869E4C => {
    //   block [0x82869E4C..0x82869E74)
	// 82869E4C: 80990048  lwz r4, 0x48(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(72 as u32) ) } as u64;
	// 82869E50: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82869E54: 419A005C  beq cr6, 0x82869eb0
	if ctx.cr[6].eq {
	pc = 0x82869EB0; continue 'dispatch;
	}
	// 82869E58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82869E5C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82869E60: 4BCF94E9  bl 0x82563348
	ctx.lr = 0x82869E64;
	sub_82563348(ctx, base);
	// 82869E64: 80790048  lwz r3, 0x48(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(72 as u32) ) } as u64;
	// 82869E68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82869E6C: 419A0040  beq cr6, 0x82869eac
	if ctx.cr[6].eq {
	pc = 0x82869EAC; continue 'dispatch;
	}
	// 82869E70: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82869E74; continue 'dispatch;
            }
            0x82869E74 => {
    //   block [0x82869E74..0x82869EA8)
	// 82869E74: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82869E78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869E7C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82869E80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82869E84: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82869E88: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869E8C: 4082FFE8  bne 0x82869e74
	if !ctx.cr[0].eq {
	pc = 0x82869E74; continue 'dispatch;
	}
	// 82869E90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869E94: 409A0014  bne cr6, 0x82869ea8
	if !ctx.cr[6].eq {
	pc = 0x82869EA8; continue 'dispatch;
	}
	// 82869E98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869E9C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869EA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82869EA4: 4E800421  bctrl
	ctx.lr = 0x82869EA8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82869EA8 => {
    //   block [0x82869EA8..0x82869EAC)
	// 82869EA8: 93190048  stw r24, 0x48(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(72 as u32), ctx.r[24].u32 ) };
	pc = 0x82869EAC; continue 'dispatch;
            }
            0x82869EAC => {
    //   block [0x82869EAC..0x82869EB0)
	// 82869EAC: 93190048  stw r24, 0x48(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(72 as u32), ctx.r[24].u32 ) };
	pc = 0x82869EB0; continue 'dispatch;
            }
            0x82869EB0 => {
    //   block [0x82869EB0..0x82869EB8)
	// 82869EB0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82869EB4: 4843F590  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82869EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82869EB8 size=2476
    let mut pc: u32 = 0x82869EB8;
    'dispatch: loop {
        match pc {
            0x82869EB8 => {
    //   block [0x82869EB8..0x82869F34)
	// 82869EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82869EBC: 4843F539  bl 0x82ca93f4
	ctx.lr = 0x82869EC0;
	sub_82CA93D0(ctx, base);
	// 82869EC0: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82869EC4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82869EC8: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82869ECC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82869ED0: 3B780014  addi r27, r24, 0x14
	ctx.r[27].s64 = ctx.r[24].s64 + 20;
	// 82869ED4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82869ED8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82869EDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82869EE0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82869EE4: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 82869EE8: 48314211  bl 0x82b7e0f8
	ctx.lr = 0x82869EEC;
	sub_82B7E0F8(ctx, base);
	// 82869EEC: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869EF0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82869EF4: 7FB9EB78  mr r25, r29
	ctx.r[25].u64 = ctx.r[29].u64;
	// 82869EF8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82869EFC: 89460024  lbz r10, 0x24(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 82869F00: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82869F04: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82869F08: 419A00E8  beq cr6, 0x82869ff0
	if ctx.cr[6].eq {
	pc = 0x82869FF0; continue 'dispatch;
	}
	// 82869F0C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 82869F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869F14: 419A0020  beq cr6, 0x82869f34
	if ctx.cr[6].eq {
	pc = 0x82869F34; continue 'dispatch;
	}
	// 82869F18: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82869F1C: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82869F20: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82869F24: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82869F28: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82869F2C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869F30: 480000C4  b 0x82869ff4
	pc = 0x82869FF4; continue 'dispatch;
            }
            0x82869F34 => {
    //   block [0x82869F34..0x82869F50)
	// 82869F34: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82869F38: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82869F3C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82869F40: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82869F44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82869F48: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869F4C: 40810054  ble 0x82869fa0
	if !ctx.cr[0].gt {
	pc = 0x82869FA0; continue 'dispatch;
	}
	pc = 0x82869F50; continue 'dispatch;
            }
            0x82869F50 => {
    //   block [0x82869F50..0x82869F70)
	// 82869F50: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82869F54: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82869F58: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82869F5C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869F60: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 82869F64: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82869F68: 41980008  blt cr6, 0x82869f70
	if ctx.cr[6].lt {
	pc = 0x82869F70; continue 'dispatch;
	}
	// 82869F6C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82869F70; continue 'dispatch;
            }
            0x82869F70 => {
    //   block [0x82869F70..0x82869F8C)
	// 82869F70: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82869F74: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82869F78: 419A0014  beq cr6, 0x82869f8c
	if ctx.cr[6].eq {
	pc = 0x82869F8C; continue 'dispatch;
	}
	// 82869F7C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82869F80: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82869F84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82869F88: 4800000C  b 0x82869f94
	pc = 0x82869F94; continue 'dispatch;
            }
            0x82869F8C => {
    //   block [0x82869F8C..0x82869F94)
	// 82869F8C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82869F90: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82869F94; continue 'dispatch;
            }
            0x82869F94 => {
    //   block [0x82869F94..0x82869FA0)
	// 82869F94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869F98: 4199FFB8  bgt cr6, 0x82869f50
	if ctx.cr[6].gt {
	pc = 0x82869F50; continue 'dispatch;
	}
	// 82869F9C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82869FA0; continue 'dispatch;
            }
            0x82869FA0 => {
    //   block [0x82869FA0..0x82869FBC)
	// 82869FA0: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82869FA4: 419A003C  beq cr6, 0x82869fe0
	if ctx.cr[6].eq {
	pc = 0x82869FE0; continue 'dispatch;
	}
	// 82869FA8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869FAC: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 82869FB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82869FB4: 41990008  bgt cr6, 0x82869fbc
	if ctx.cr[6].gt {
	pc = 0x82869FBC; continue 'dispatch;
	}
	// 82869FB8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82869FBC; continue 'dispatch;
            }
            0x82869FBC => {
    //   block [0x82869FBC..0x82869FE0)
	// 82869FBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82869FC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869FC4: 409A001C  bne cr6, 0x82869fe0
	if !ctx.cr[6].eq {
	pc = 0x82869FE0; continue 'dispatch;
	}
	// 82869FC8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82869FCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82869FD0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82869FD4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82869FD8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869FDC: 48000018  b 0x82869ff4
	pc = 0x82869FF4; continue 'dispatch;
            }
            0x82869FE0 => {
    //   block [0x82869FE0..0x82869FF0)
	// 82869FE0: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82869FE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82869FE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869FEC: 48000008  b 0x82869ff4
	pc = 0x82869FF4; continue 'dispatch;
            }
            0x82869FF0 => {
    //   block [0x82869FF0..0x82869FF4)
	// 82869FF0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x82869FF4; continue 'dispatch;
            }
            0x82869FF4 => {
    //   block [0x82869FF4..0x8286A010)
	// 82869FF4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82869FF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82869FFC: 419A0014  beq cr6, 0x8286a010
	if ctx.cr[6].eq {
	pc = 0x8286A010; continue 'dispatch;
	}
	// 8286A000: 896B003C  lbz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 8286A004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A008: 419A0008  beq cr6, 0x8286a010
	if ctx.cr[6].eq {
	pc = 0x8286A010; continue 'dispatch;
	}
	// 8286A00C: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	pc = 0x8286A010; continue 'dispatch;
            }
            0x8286A010 => {
    //   block [0x8286A010..0x8286A070)
	// 8286A010: 81460028  lwz r10, 0x28(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(40 as u32) ) } as u64;
	// 8286A014: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8286A018: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8286A01C: 554817FE  rlwinm r8, r10, 2, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 8286A020: 3B8BC25C  addi r28, r11, -0x3da4
	ctx.r[28].s64 = ctx.r[11].s64 + -15780;
	// 8286A024: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8286A028: C3E99490  lfs f31, -0x6b70(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8286A02C: 409A0604  bne cr6, 0x8286a630
	if !ctx.cr[6].eq {
	pc = 0x8286A630; continue 'dispatch;
	}
	// 8286A030: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8286A034: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 8286A038: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 8286A03C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8286A040: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8286A044: 419A00E8  beq cr6, 0x8286a12c
	if ctx.cr[6].eq {
	pc = 0x8286A12C; continue 'dispatch;
	}
	// 8286A048: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286A04C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A050: 419A0020  beq cr6, 0x8286a070
	if ctx.cr[6].eq {
	pc = 0x8286A070; continue 'dispatch;
	}
	// 8286A054: 894B003C  lbz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 8286A058: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286A05C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8286A060: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286A064: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8286A068: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286A06C: 480000C4  b 0x8286a130
	pc = 0x8286A130; continue 'dispatch;
            }
            0x8286A070 => {
    //   block [0x8286A070..0x8286A08C)
	// 8286A070: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286A074: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286A078: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8286A07C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8286A080: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286A084: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286A088: 40810054  ble 0x8286a0dc
	if !ctx.cr[0].gt {
	pc = 0x8286A0DC; continue 'dispatch;
	}
	pc = 0x8286A08C; continue 'dispatch;
            }
            0x8286A08C => {
    //   block [0x8286A08C..0x8286A0AC)
	// 8286A08C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286A090: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286A094: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8286A098: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A09C: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 8286A0A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286A0A4: 41980008  blt cr6, 0x8286a0ac
	if ctx.cr[6].lt {
	pc = 0x8286A0AC; continue 'dispatch;
	}
	// 8286A0A8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8286A0AC; continue 'dispatch;
            }
            0x8286A0AC => {
    //   block [0x8286A0AC..0x8286A0C8)
	// 8286A0AC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286A0B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286A0B4: 419A0014  beq cr6, 0x8286a0c8
	if ctx.cr[6].eq {
	pc = 0x8286A0C8; continue 'dispatch;
	}
	// 8286A0B8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286A0BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286A0C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286A0C4: 4800000C  b 0x8286a0d0
	pc = 0x8286A0D0; continue 'dispatch;
            }
            0x8286A0C8 => {
    //   block [0x8286A0C8..0x8286A0D0)
	// 8286A0C8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286A0CC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286A0D0; continue 'dispatch;
            }
            0x8286A0D0 => {
    //   block [0x8286A0D0..0x8286A0DC)
	// 8286A0D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286A0D4: 4199FFB8  bgt cr6, 0x8286a08c
	if ctx.cr[6].gt {
	pc = 0x8286A08C; continue 'dispatch;
	}
	// 8286A0D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8286A0DC; continue 'dispatch;
            }
            0x8286A0DC => {
    //   block [0x8286A0DC..0x8286A0F8)
	// 8286A0DC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8286A0E0: 419A003C  beq cr6, 0x8286a11c
	if ctx.cr[6].eq {
	pc = 0x8286A11C; continue 'dispatch;
	}
	// 8286A0E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A0E8: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 8286A0EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286A0F0: 41990008  bgt cr6, 0x8286a0f8
	if ctx.cr[6].gt {
	pc = 0x8286A0F8; continue 'dispatch;
	}
	// 8286A0F4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8286A0F8; continue 'dispatch;
            }
            0x8286A0F8 => {
    //   block [0x8286A0F8..0x8286A11C)
	// 8286A0F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286A0FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A100: 409A001C  bne cr6, 0x8286a11c
	if !ctx.cr[6].eq {
	pc = 0x8286A11C; continue 'dispatch;
	}
	// 8286A104: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8286A108: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8286A10C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8286A110: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286A114: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286A118: 48000018  b 0x8286a130
	pc = 0x8286A130; continue 'dispatch;
            }
            0x8286A11C => {
    //   block [0x8286A11C..0x8286A12C)
	// 8286A11C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286A120: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8286A124: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286A128: 48000008  b 0x8286a130
	pc = 0x8286A130; continue 'dispatch;
            }
            0x8286A12C => {
    //   block [0x8286A12C..0x8286A130)
	// 8286A12C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x8286A130; continue 'dispatch;
            }
            0x8286A130 => {
    //   block [0x8286A130..0x8286A16C)
	// 8286A130: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8286A134: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286A138: 419A0048  beq cr6, 0x8286a180
	if ctx.cr[6].eq {
	pc = 0x8286A180; continue 'dispatch;
	}
	// 8286A13C: 816B00AC  lwz r11, 0xac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 8286A140: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8286A144: 419A0028  beq cr6, 0x8286a16c
	if ctx.cr[6].eq {
	pc = 0x8286A16C; continue 'dispatch;
	}
	// 8286A148: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 8286A14C: 419A0020  beq cr6, 0x8286a16c
	if ctx.cr[6].eq {
	pc = 0x8286A16C; continue 'dispatch;
	}
	// 8286A150: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8286A154: 419A0018  beq cr6, 0x8286a16c
	if ctx.cr[6].eq {
	pc = 0x8286A16C; continue 'dispatch;
	}
	// 8286A158: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 8286A15C: 419A0010  beq cr6, 0x8286a16c
	if ctx.cr[6].eq {
	pc = 0x8286A16C; continue 'dispatch;
	}
	// 8286A160: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8286A164: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8286A168: 409A0008  bne cr6, 0x8286a170
	if !ctx.cr[6].eq {
	pc = 0x8286A170; continue 'dispatch;
	}
	pc = 0x8286A16C; continue 'dispatch;
            }
            0x8286A16C => {
    //   block [0x8286A16C..0x8286A170)
	// 8286A16C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x8286A170; continue 'dispatch;
            }
            0x8286A170 => {
    //   block [0x8286A170..0x8286A180)
	// 8286A170: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286A174: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A178: 419A0008  beq cr6, 0x8286a180
	if ctx.cr[6].eq {
	pc = 0x8286A180; continue 'dispatch;
	}
	// 8286A17C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	pc = 0x8286A180; continue 'dispatch;
            }
            0x8286A180 => {
    //   block [0x8286A180..0x8286A248)
	// 8286A180: 574B07FE  clrlwi r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	// 8286A184: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A188: 419A00C0  beq cr6, 0x8286a248
	if ctx.cr[6].eq {
	pc = 0x8286A248; continue 'dispatch;
	}
	// 8286A18C: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 8286A190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A194: 409A00B4  bne cr6, 0x8286a248
	if !ctx.cr[6].eq {
	pc = 0x8286A248; continue 'dispatch;
	}
	// 8286A198: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 8286A19C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A1A0: 409A00A8  bne cr6, 0x8286a248
	if !ctx.cr[6].eq {
	pc = 0x8286A248; continue 'dispatch;
	}
	// 8286A1A4: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 8286A1A8: 894BEBB0  lbz r10, -0x1450(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5200 as u32) ) } as u64;
	// 8286A1AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286A1B0: 419A0098  beq cr6, 0x8286a248
	if ctx.cr[6].eq {
	pc = 0x8286A248; continue 'dispatch;
	}
	// 8286A1B4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8286A1B8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A1BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A1C0: 48314151  bl 0x82b7e310
	ctx.lr = 0x8286A1C4;
	sub_82B7E310(ctx, base);
	// 8286A1C4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8286A1C8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A1CC: 388BFE38  addi r4, r11, -0x1c8
	ctx.r[4].s64 = ctx.r[11].s64 + -456;
	// 8286A1D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A1D4: 4B9C2CFD  bl 0x8222ced0
	ctx.lr = 0x8286A1D8;
	sub_8222CED0(ctx, base);
	// 8286A1D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A1DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A1E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A1E4: 4831412D  bl 0x82b7e310
	ctx.lr = 0x8286A1E8;
	sub_82B7E310(ctx, base);
	// 8286A1E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A1EC: 4B9AABED  bl 0x82214dd8
	ctx.lr = 0x8286A1F0;
	sub_82214DD8(ctx, base);
	// 8286A1F0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8286A1F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A1F8: 388A0738  addi r4, r10, 0x738
	ctx.r[4].s64 = ctx.r[10].s64 + 1848;
	// 8286A1FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A200: 4B9C2CD1  bl 0x8222ced0
	ctx.lr = 0x8286A204;
	sub_8222CED0(ctx, base);
	// 8286A204: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A208: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A20C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286A210: 483141E9  bl 0x82b7e3f8
	ctx.lr = 0x8286A214;
	sub_82B7E3F8(ctx, base);
	// 8286A214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A218: 4B9AABC1  bl 0x82214dd8
	ctx.lr = 0x8286A21C;
	sub_82214DD8(ctx, base);
	// 8286A21C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 8286A220: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A224: 38890728  addi r4, r9, 0x728
	ctx.r[4].s64 = ctx.r[9].s64 + 1832;
	// 8286A228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A22C: 4B9C2CA5  bl 0x8222ced0
	ctx.lr = 0x8286A230;
	sub_8222CED0(ctx, base);
	// 8286A230: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A234: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A238: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286A23C: 483141BD  bl 0x82b7e3f8
	ctx.lr = 0x8286A240;
	sub_82B7E3F8(ctx, base);
	// 8286A240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A244: 4B9AAB95  bl 0x82214dd8
	ctx.lr = 0x8286A248;
	sub_82214DD8(ctx, base);
	pc = 0x8286A248; continue 'dispatch;
            }
            0x8286A248 => {
    //   block [0x8286A248..0x8286A2D0)
	// 8286A248: 574B07BC  rlwinm r11, r26, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 8286A24C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A250: 419A0080  beq cr6, 0x8286a2d0
	if ctx.cr[6].eq {
	pc = 0x8286A2D0; continue 'dispatch;
	}
	// 8286A254: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 8286A258: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A25C: 409A0074  bne cr6, 0x8286a2d0
	if !ctx.cr[6].eq {
	pc = 0x8286A2D0; continue 'dispatch;
	}
	// 8286A260: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 8286A264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A268: 409A0068  bne cr6, 0x8286a2d0
	if !ctx.cr[6].eq {
	pc = 0x8286A2D0; continue 'dispatch;
	}
	// 8286A26C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 8286A270: 894BEBB1  lbz r10, -0x144f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5199 as u32) ) } as u64;
	// 8286A274: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286A278: 419A0058  beq cr6, 0x8286a2d0
	if ctx.cr[6].eq {
	pc = 0x8286A2D0; continue 'dispatch;
	}
	// 8286A27C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8286A280: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A284: 388BC254  addi r4, r11, -0x3dac
	ctx.r[4].s64 = ctx.r[11].s64 + -15788;
	// 8286A288: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A28C: 48314085  bl 0x82b7e310
	ctx.lr = 0x8286A290;
	sub_82B7E310(ctx, base);
	// 8286A290: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 8286A294: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A298: 388AFE50  addi r4, r10, -0x1b0
	ctx.r[4].s64 = ctx.r[10].s64 + -432;
	// 8286A29C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A2A0: 4B9C2C31  bl 0x8222ced0
	ctx.lr = 0x8286A2A4;
	sub_8222CED0(ctx, base);
	// 8286A2A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A2A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A2AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A2B0: 48314061  bl 0x82b7e310
	ctx.lr = 0x8286A2B4;
	sub_82B7E310(ctx, base);
	// 8286A2B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A2B8: 4B9AAB21  bl 0x82214dd8
	ctx.lr = 0x8286A2BC;
	sub_82214DD8(ctx, base);
	// 8286A2BC: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8286A2C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A2C4: 3889C258  addi r4, r9, -0x3da8
	ctx.r[4].s64 = ctx.r[9].s64 + -15784;
	// 8286A2C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A2CC: 48314045  bl 0x82b7e310
	ctx.lr = 0x8286A2D0;
	sub_82B7E310(ctx, base);
	pc = 0x8286A2D0; continue 'dispatch;
            }
            0x8286A2D0 => {
    //   block [0x8286A2D0..0x8286A318)
	// 8286A2D0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286A2D4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 8286A2D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A2DC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8286A2E0: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 8286A2E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8286A2E8: 419A00F4  beq cr6, 0x8286a3dc
	if ctx.cr[6].eq {
	pc = 0x8286A3DC; continue 'dispatch;
	}
	// 8286A2EC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286A2F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286A2F4: 419A0024  beq cr6, 0x8286a318
	if ctx.cr[6].eq {
	pc = 0x8286A318; continue 'dispatch;
	}
	// 8286A2F8: 894A007A  lbz r10, 0x7a(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(122 as u32) ) } as u64;
	// 8286A2FC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286A300: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8286A304: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286A308: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286A30C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286A310: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286A314: 480000CC  b 0x8286a3e0
	pc = 0x8286A3E0; continue 'dispatch;
            }
            0x8286A318 => {
    //   block [0x8286A318..0x8286A334)
	// 8286A318: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286A31C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286A320: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8286A324: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8286A328: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286A32C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286A330: 40810054  ble 0x8286a384
	if !ctx.cr[0].gt {
	pc = 0x8286A384; continue 'dispatch;
	}
	pc = 0x8286A334; continue 'dispatch;
            }
            0x8286A334 => {
    //   block [0x8286A334..0x8286A354)
	// 8286A334: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286A338: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286A33C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8286A340: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A344: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 8286A348: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286A34C: 41980008  blt cr6, 0x8286a354
	if ctx.cr[6].lt {
	pc = 0x8286A354; continue 'dispatch;
	}
	// 8286A350: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8286A354; continue 'dispatch;
            }
            0x8286A354 => {
    //   block [0x8286A354..0x8286A370)
	// 8286A354: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286A358: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286A35C: 419A0014  beq cr6, 0x8286a370
	if ctx.cr[6].eq {
	pc = 0x8286A370; continue 'dispatch;
	}
	// 8286A360: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286A364: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286A368: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286A36C: 4800000C  b 0x8286a378
	pc = 0x8286A378; continue 'dispatch;
            }
            0x8286A370 => {
    //   block [0x8286A370..0x8286A378)
	// 8286A370: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286A374: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286A378; continue 'dispatch;
            }
            0x8286A378 => {
    //   block [0x8286A378..0x8286A384)
	// 8286A378: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286A37C: 4199FFB8  bgt cr6, 0x8286a334
	if ctx.cr[6].gt {
	pc = 0x8286A334; continue 'dispatch;
	}
	// 8286A380: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8286A384; continue 'dispatch;
            }
            0x8286A384 => {
    //   block [0x8286A384..0x8286A3A0)
	// 8286A384: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8286A388: 419A0040  beq cr6, 0x8286a3c8
	if ctx.cr[6].eq {
	pc = 0x8286A3C8; continue 'dispatch;
	}
	// 8286A38C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A390: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 8286A394: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286A398: 41990008  bgt cr6, 0x8286a3a0
	if ctx.cr[6].gt {
	pc = 0x8286A3A0; continue 'dispatch;
	}
	// 8286A39C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8286A3A0; continue 'dispatch;
            }
            0x8286A3A0 => {
    //   block [0x8286A3A0..0x8286A3C8)
	// 8286A3A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286A3A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A3A8: 409A0020  bne cr6, 0x8286a3c8
	if !ctx.cr[6].eq {
	pc = 0x8286A3C8; continue 'dispatch;
	}
	// 8286A3AC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8286A3B0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8286A3B4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286A3B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286A3BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286A3C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286A3C4: 4800001C  b 0x8286a3e0
	pc = 0x8286A3E0; continue 'dispatch;
            }
            0x8286A3C8 => {
    //   block [0x8286A3C8..0x8286A3DC)
	// 8286A3C8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286A3CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286A3D0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286A3D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286A3D8: 48000008  b 0x8286a3e0
	pc = 0x8286A3E0; continue 'dispatch;
            }
            0x8286A3DC => {
    //   block [0x8286A3DC..0x8286A3E0)
	// 8286A3DC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8286A3E0; continue 'dispatch;
            }
            0x8286A3E0 => {
    //   block [0x8286A3E0..0x8286A3FC)
	// 8286A3E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286A3E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A3E8: 419A0014  beq cr6, 0x8286a3fc
	if ctx.cr[6].eq {
	pc = 0x8286A3FC; continue 'dispatch;
	}
	// 8286A3EC: 4B95862D  bl 0x821c2a18
	ctx.lr = 0x8286A3F0;
	sub_821C2A18(ctx, base);
	// 8286A3F0: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 8286A3F4: 40990008  ble cr6, 0x8286a3fc
	if !ctx.cr[6].gt {
	pc = 0x8286A3FC; continue 'dispatch;
	}
	// 8286A3F8: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x8286A3FC; continue 'dispatch;
            }
            0x8286A3FC => {
    //   block [0x8286A3FC..0x8286A510)
	// 8286A3FC: 574B077A  rlwinm r11, r26, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 8286A400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A404: 419A010C  beq cr6, 0x8286a510
	if ctx.cr[6].eq {
	pc = 0x8286A510; continue 'dispatch;
	}
	// 8286A408: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 8286A40C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A410: 409A0100  bne cr6, 0x8286a510
	if !ctx.cr[6].eq {
	pc = 0x8286A510; continue 'dispatch;
	}
	// 8286A414: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8286A418: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A41C: 388BC250  addi r4, r11, -0x3db0
	ctx.r[4].s64 = ctx.r[11].s64 + -15792;
	// 8286A420: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A424: 48313EED  bl 0x82b7e310
	ctx.lr = 0x8286A428;
	sub_82B7E310(ctx, base);
	// 8286A428: 57EA063E  clrlwi r10, r31, 0x18
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 8286A42C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286A430: 409A00E0  bne cr6, 0x8286a510
	if !ctx.cr[6].eq {
	pc = 0x8286A510; continue 'dispatch;
	}
	// 8286A434: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8286A438: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A43C: 388BFE60  addi r4, r11, -0x1a0
	ctx.r[4].s64 = ctx.r[11].s64 + -416;
	// 8286A440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A444: 4B9C2A8D  bl 0x8222ced0
	ctx.lr = 0x8286A448;
	sub_8222CED0(ctx, base);
	// 8286A448: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A44C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A450: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A454: 48313EBD  bl 0x82b7e310
	ctx.lr = 0x8286A458;
	sub_82B7E310(ctx, base);
	// 8286A458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A45C: 4B9AA97D  bl 0x82214dd8
	ctx.lr = 0x8286A460;
	sub_82214DD8(ctx, base);
	// 8286A460: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 8286A464: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A468: 388AFE8C  addi r4, r10, -0x174
	ctx.r[4].s64 = ctx.r[10].s64 + -372;
	// 8286A46C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A470: 4B9C2A61  bl 0x8222ced0
	ctx.lr = 0x8286A474;
	sub_8222CED0(ctx, base);
	// 8286A474: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A478: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A47C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A480: 48313E91  bl 0x82b7e310
	ctx.lr = 0x8286A484;
	sub_82B7E310(ctx, base);
	// 8286A484: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A488: 4B9AA951  bl 0x82214dd8
	ctx.lr = 0x8286A48C;
	sub_82214DD8(ctx, base);
	// 8286A48C: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 8286A490: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A494: 3889FEB0  addi r4, r9, -0x150
	ctx.r[4].s64 = ctx.r[9].s64 + -336;
	// 8286A498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A49C: 4B9C2A35  bl 0x8222ced0
	ctx.lr = 0x8286A4A0;
	sub_8222CED0(ctx, base);
	// 8286A4A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A4A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A4A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A4AC: 48313E65  bl 0x82b7e310
	ctx.lr = 0x8286A4B0;
	sub_82B7E310(ctx, base);
	// 8286A4B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A4B4: 4B9AA925  bl 0x82214dd8
	ctx.lr = 0x8286A4B8;
	sub_82214DD8(ctx, base);
	// 8286A4B8: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 8286A4BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A4C0: 3888FED4  addi r4, r8, -0x12c
	ctx.r[4].s64 = ctx.r[8].s64 + -300;
	// 8286A4C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A4C8: 4B9C2A09  bl 0x8222ced0
	ctx.lr = 0x8286A4CC;
	sub_8222CED0(ctx, base);
	// 8286A4CC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A4D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A4D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A4D8: 48313E39  bl 0x82b7e310
	ctx.lr = 0x8286A4DC;
	sub_82B7E310(ctx, base);
	// 8286A4DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A4E0: 4B9AA8F9  bl 0x82214dd8
	ctx.lr = 0x8286A4E4;
	sub_82214DD8(ctx, base);
	// 8286A4E4: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 8286A4E8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A4EC: 3887FEEC  addi r4, r7, -0x114
	ctx.r[4].s64 = ctx.r[7].s64 + -276;
	// 8286A4F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A4F4: 4B9C29DD  bl 0x8222ced0
	ctx.lr = 0x8286A4F8;
	sub_8222CED0(ctx, base);
	// 8286A4F8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A4FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A500: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A504: 48313E0D  bl 0x82b7e310
	ctx.lr = 0x8286A508;
	sub_82B7E310(ctx, base);
	// 8286A508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A50C: 4B9AA8CD  bl 0x82214dd8
	ctx.lr = 0x8286A510;
	sub_82214DD8(ctx, base);
	pc = 0x8286A510; continue 'dispatch;
            }
            0x8286A510 => {
    //   block [0x8286A510..0x8286A554)
	// 8286A510: 574B0738  rlwinm r11, r26, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 8286A514: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A518: 419A0094  beq cr6, 0x8286a5ac
	if ctx.cr[6].eq {
	pc = 0x8286A5AC; continue 'dispatch;
	}
	// 8286A51C: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 8286A520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A524: 409A0030  bne cr6, 0x8286a554
	if !ctx.cr[6].eq {
	pc = 0x8286A554; continue 'dispatch;
	}
	// 8286A528: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8286A52C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A530: 388BFF10  addi r4, r11, -0xf0
	ctx.r[4].s64 = ctx.r[11].s64 + -240;
	// 8286A534: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A538: 4B9C2999  bl 0x8222ced0
	ctx.lr = 0x8286A53C;
	sub_8222CED0(ctx, base);
	// 8286A53C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A540: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A544: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A548: 48313DC9  bl 0x82b7e310
	ctx.lr = 0x8286A54C;
	sub_82B7E310(ctx, base);
	// 8286A54C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A550: 4B9AA889  bl 0x82214dd8
	ctx.lr = 0x8286A554;
	sub_82214DD8(ctx, base);
	pc = 0x8286A554; continue 'dispatch;
            }
            0x8286A554 => {
    //   block [0x8286A554..0x8286A5AC)
	// 8286A554: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8286A558: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A55C: 388BFF24  addi r4, r11, -0xdc
	ctx.r[4].s64 = ctx.r[11].s64 + -220;
	// 8286A560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A564: 4B9C296D  bl 0x8222ced0
	ctx.lr = 0x8286A568;
	sub_8222CED0(ctx, base);
	// 8286A568: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A56C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A570: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A574: 48313D9D  bl 0x82b7e310
	ctx.lr = 0x8286A578;
	sub_82B7E310(ctx, base);
	// 8286A578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A57C: 4B9AA85D  bl 0x82214dd8
	ctx.lr = 0x8286A580;
	sub_82214DD8(ctx, base);
	// 8286A580: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 8286A584: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A588: 388AF364  addi r4, r10, -0xc9c
	ctx.r[4].s64 = ctx.r[10].s64 + -3228;
	// 8286A58C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A590: 4B9C2941  bl 0x8222ced0
	ctx.lr = 0x8286A594;
	sub_8222CED0(ctx, base);
	// 8286A594: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A598: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A59C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286A5A0: 48313E59  bl 0x82b7e3f8
	ctx.lr = 0x8286A5A4;
	sub_82B7E3F8(ctx, base);
	// 8286A5A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A5A8: 4B9AA831  bl 0x82214dd8
	ctx.lr = 0x8286A5AC;
	sub_82214DD8(ctx, base);
	pc = 0x8286A5AC; continue 'dispatch;
            }
            0x8286A5AC => {
    //   block [0x8286A5AC..0x8286A610)
	// 8286A5AC: 574B06F6  rlwinm r11, r26, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 8286A5B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A5B4: 419A005C  beq cr6, 0x8286a610
	if ctx.cr[6].eq {
	pc = 0x8286A610; continue 'dispatch;
	}
	// 8286A5B8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8286A5BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A5C0: 388BFF34  addi r4, r11, -0xcc
	ctx.r[4].s64 = ctx.r[11].s64 + -204;
	// 8286A5C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A5C8: 4B9C2909  bl 0x8222ced0
	ctx.lr = 0x8286A5CC;
	sub_8222CED0(ctx, base);
	// 8286A5CC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A5D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A5D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A5D8: 48313D39  bl 0x82b7e310
	ctx.lr = 0x8286A5DC;
	sub_82B7E310(ctx, base);
	// 8286A5DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A5E0: 4B9AA7F9  bl 0x82214dd8
	ctx.lr = 0x8286A5E4;
	sub_82214DD8(ctx, base);
	// 8286A5E4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 8286A5E8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286A5EC: 388ADBD8  addi r4, r10, -0x2428
	ctx.r[4].s64 = ctx.r[10].s64 + -9256;
	// 8286A5F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A5F4: 4B9C28DD  bl 0x8222ced0
	ctx.lr = 0x8286A5F8;
	sub_8222CED0(ctx, base);
	// 8286A5F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A5FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A600: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286A604: 48313DF5  bl 0x82b7e3f8
	ctx.lr = 0x8286A608;
	sub_82B7E3F8(ctx, base);
	// 8286A608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A60C: 4B9AA7CD  bl 0x82214dd8
	ctx.lr = 0x8286A610;
	sub_82214DD8(ctx, base);
	pc = 0x8286A610; continue 'dispatch;
            }
            0x8286A610 => {
    //   block [0x8286A610..0x8286A630)
	// 8286A610: 574B06B4  rlwinm r11, r26, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 8286A614: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A618: 419A0018  beq cr6, 0x8286a630
	if ctx.cr[6].eq {
	pc = 0x8286A630; continue 'dispatch;
	}
	// 8286A61C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8286A620: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286A624: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A628: 388BC240  addi r4, r11, -0x3dc0
	ctx.r[4].s64 = ctx.r[11].s64 + -15808;
	// 8286A62C: 48313DCD  bl 0x82b7e3f8
	ctx.lr = 0x8286A630;
	sub_82B7E3F8(ctx, base);
	pc = 0x8286A630; continue 'dispatch;
            }
            0x8286A630 => {
    //   block [0x8286A630..0x8286A81C)
	// 8286A630: 574B0672  rlwinm r11, r26, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 8286A634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A638: 419A01E4  beq cr6, 0x8286a81c
	if ctx.cr[6].eq {
	pc = 0x8286A81C; continue 'dispatch;
	}
	// 8286A63C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8286A640: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286A644: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A648: 3BEBC23C  addi r31, r11, -0x3dc4
	ctx.r[31].s64 = ctx.r[11].s64 + -15812;
	// 8286A64C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286A650: 48313DA9  bl 0x82b7e3f8
	ctx.lr = 0x8286A654;
	sub_82B7E3F8(ctx, base);
	// 8286A654: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286A658: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A65C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A660: 48313CB1  bl 0x82b7e310
	ctx.lr = 0x8286A664;
	sub_82B7E310(ctx, base);
	// 8286A664: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8286A668: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A66C: 388AC248  addi r4, r10, -0x3db8
	ctx.r[4].s64 = ctx.r[10].s64 + -15800;
	// 8286A670: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A674: 48313C9D  bl 0x82b7e310
	ctx.lr = 0x8286A678;
	sub_82B7E310(ctx, base);
	// 8286A678: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8286A67C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A680: 3889C24C  addi r4, r9, -0x3db4
	ctx.r[4].s64 = ctx.r[9].s64 + -15796;
	// 8286A684: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A688: 48313C89  bl 0x82b7e310
	ctx.lr = 0x8286A68C;
	sub_82B7E310(ctx, base);
	// 8286A68C: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 8286A690: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A694: 3888C268  addi r4, r8, -0x3d98
	ctx.r[4].s64 = ctx.r[8].s64 + -15768;
	// 8286A698: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A69C: 48313C75  bl 0x82b7e310
	ctx.lr = 0x8286A6A0;
	sub_82B7E310(ctx, base);
	// 8286A6A0: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8286A6A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A6A8: 3887C26C  addi r4, r7, -0x3d94
	ctx.r[4].s64 = ctx.r[7].s64 + -15764;
	// 8286A6AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A6B0: 48313C61  bl 0x82b7e310
	ctx.lr = 0x8286A6B4;
	sub_82B7E310(ctx, base);
	// 8286A6B4: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 8286A6B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A6BC: 3886C270  addi r4, r6, -0x3d90
	ctx.r[4].s64 = ctx.r[6].s64 + -15760;
	// 8286A6C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A6C4: 48313C4D  bl 0x82b7e310
	ctx.lr = 0x8286A6C8;
	sub_82B7E310(ctx, base);
	// 8286A6C8: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 8286A6CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A6D0: 3884C274  addi r4, r4, -0x3d8c
	ctx.r[4].s64 = ctx.r[4].s64 + -15756;
	// 8286A6D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A6D8: 48313C39  bl 0x82b7e310
	ctx.lr = 0x8286A6DC;
	sub_82B7E310(ctx, base);
	// 8286A6DC: 3C60834A  lis r3, -0x7cb6
	ctx.r[3].s64 = -2092302336;
	// 8286A6E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A6E4: 3883C278  addi r4, r3, -0x3d88
	ctx.r[4].s64 = ctx.r[3].s64 + -15752;
	// 8286A6E8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A6EC: 48313C25  bl 0x82b7e310
	ctx.lr = 0x8286A6F0;
	sub_82B7E310(ctx, base);
	// 8286A6F0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8286A6F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A6F8: 388BC27C  addi r4, r11, -0x3d84
	ctx.r[4].s64 = ctx.r[11].s64 + -15748;
	// 8286A6FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A700: 48313C11  bl 0x82b7e310
	ctx.lr = 0x8286A704;
	sub_82B7E310(ctx, base);
	// 8286A704: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8286A708: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A70C: 388AC280  addi r4, r10, -0x3d80
	ctx.r[4].s64 = ctx.r[10].s64 + -15744;
	// 8286A710: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A714: 48313BFD  bl 0x82b7e310
	ctx.lr = 0x8286A718;
	sub_82B7E310(ctx, base);
	// 8286A718: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8286A71C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A720: 3889C284  addi r4, r9, -0x3d7c
	ctx.r[4].s64 = ctx.r[9].s64 + -15740;
	// 8286A724: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A728: 48313BE9  bl 0x82b7e310
	ctx.lr = 0x8286A72C;
	sub_82B7E310(ctx, base);
	// 8286A72C: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 8286A730: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A734: 3888C288  addi r4, r8, -0x3d78
	ctx.r[4].s64 = ctx.r[8].s64 + -15736;
	// 8286A738: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A73C: 48313BD5  bl 0x82b7e310
	ctx.lr = 0x8286A740;
	sub_82B7E310(ctx, base);
	// 8286A740: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8286A744: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A748: 3887C28C  addi r4, r7, -0x3d74
	ctx.r[4].s64 = ctx.r[7].s64 + -15732;
	// 8286A74C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A750: 48313BC1  bl 0x82b7e310
	ctx.lr = 0x8286A754;
	sub_82B7E310(ctx, base);
	// 8286A754: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 8286A758: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A75C: 3886C290  addi r4, r6, -0x3d70
	ctx.r[4].s64 = ctx.r[6].s64 + -15728;
	// 8286A760: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A764: 48313BAD  bl 0x82b7e310
	ctx.lr = 0x8286A768;
	sub_82B7E310(ctx, base);
	// 8286A768: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 8286A76C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A770: 3884C294  addi r4, r4, -0x3d6c
	ctx.r[4].s64 = ctx.r[4].s64 + -15724;
	// 8286A774: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A778: 48313B99  bl 0x82b7e310
	ctx.lr = 0x8286A77C;
	sub_82B7E310(ctx, base);
	// 8286A77C: 3C60834A  lis r3, -0x7cb6
	ctx.r[3].s64 = -2092302336;
	// 8286A780: 3883C298  addi r4, r3, -0x3d68
	ctx.r[4].s64 = ctx.r[3].s64 + -15720;
	// 8286A784: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A788: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A78C: 48313B85  bl 0x82b7e310
	ctx.lr = 0x8286A790;
	sub_82B7E310(ctx, base);
	// 8286A790: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8286A794: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A798: 388BC29C  addi r4, r11, -0x3d64
	ctx.r[4].s64 = ctx.r[11].s64 + -15716;
	// 8286A79C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A7A0: 48313B71  bl 0x82b7e310
	ctx.lr = 0x8286A7A4;
	sub_82B7E310(ctx, base);
	// 8286A7A4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8286A7A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A7AC: 388AC2A0  addi r4, r10, -0x3d60
	ctx.r[4].s64 = ctx.r[10].s64 + -15712;
	// 8286A7B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A7B4: 48313B5D  bl 0x82b7e310
	ctx.lr = 0x8286A7B8;
	sub_82B7E310(ctx, base);
	// 8286A7B8: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8286A7BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A7C0: 3889C2A4  addi r4, r9, -0x3d5c
	ctx.r[4].s64 = ctx.r[9].s64 + -15708;
	// 8286A7C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A7C8: 48313B49  bl 0x82b7e310
	ctx.lr = 0x8286A7CC;
	sub_82B7E310(ctx, base);
	// 8286A7CC: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 8286A7D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A7D4: 3888C2A8  addi r4, r8, -0x3d58
	ctx.r[4].s64 = ctx.r[8].s64 + -15704;
	// 8286A7D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A7DC: 48313B35  bl 0x82b7e310
	ctx.lr = 0x8286A7E0;
	sub_82B7E310(ctx, base);
	// 8286A7E0: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8286A7E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A7E8: 3887C2AC  addi r4, r7, -0x3d54
	ctx.r[4].s64 = ctx.r[7].s64 + -15700;
	// 8286A7EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A7F0: 48313B21  bl 0x82b7e310
	ctx.lr = 0x8286A7F4;
	sub_82B7E310(ctx, base);
	// 8286A7F4: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 8286A7F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A7FC: 3886C2B0  addi r4, r6, -0x3d50
	ctx.r[4].s64 = ctx.r[6].s64 + -15696;
	// 8286A800: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A804: 48313B0D  bl 0x82b7e310
	ctx.lr = 0x8286A808;
	sub_82B7E310(ctx, base);
	// 8286A808: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 8286A80C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A810: 3884C2B4  addi r4, r4, -0x3d4c
	ctx.r[4].s64 = ctx.r[4].s64 + -15692;
	// 8286A814: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A818: 48313AF9  bl 0x82b7e310
	ctx.lr = 0x8286A81C;
	sub_82B7E310(ctx, base);
	pc = 0x8286A81C; continue 'dispatch;
            }
            0x8286A81C => {
    //   block [0x8286A81C..0x8286A844)
	// 8286A81C: 56EB063E  clrlwi r11, r23, 0x18
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	// 8286A820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A824: 419A0020  beq cr6, 0x8286a844
	if ctx.cr[6].eq {
	pc = 0x8286A844; continue 'dispatch;
	}
	// 8286A828: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 8286A82C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A830: 409A0014  bne cr6, 0x8286a844
	if !ctx.cr[6].eq {
	pc = 0x8286A844; continue 'dispatch;
	}
	// 8286A834: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8286A838: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286A83C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A840: 48313AD1  bl 0x82b7e310
	ctx.lr = 0x8286A844;
	sub_82B7E310(ctx, base);
	pc = 0x8286A844; continue 'dispatch;
            }
            0x8286A844 => {
    //   block [0x8286A844..0x8286A864)
	// 8286A844: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A848: 389B0028  addi r4, r27, 0x28
	ctx.r[4].s64 = ctx.r[27].s64 + 40;
	// 8286A84C: 38780004  addi r3, r24, 4
	ctx.r[3].s64 = ctx.r[24].s64 + 4;
	// 8286A850: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286A854: 4BEF7E65  bl 0x827626b8
	ctx.lr = 0x8286A858;
	sub_827626B8(ctx, base);
	// 8286A858: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8286A85C: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 8286A860: 4843EBE4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286A868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286A868 size=536
    let mut pc: u32 = 0x8286A868;
    'dispatch: loop {
        match pc {
            0x8286A868 => {
    //   block [0x8286A868..0x8286A8C0)
	// 8286A868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286A86C: 4843EBA1  bl 0x82ca940c
	ctx.lr = 0x8286A870;
	sub_82CA93D0(ctx, base);
	// 8286A870: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286A874: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8286A878: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8286A87C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A880: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286A884: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8286A888: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 8286A88C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8286A890: 419A00F4  beq cr6, 0x8286a984
	if ctx.cr[6].eq {
	pc = 0x8286A984; continue 'dispatch;
	}
	// 8286A894: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286A898: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286A89C: 419A0024  beq cr6, 0x8286a8c0
	if ctx.cr[6].eq {
	pc = 0x8286A8C0; continue 'dispatch;
	}
	// 8286A8A0: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 8286A8A4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286A8A8: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8286A8AC: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8286A8B0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286A8B4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286A8B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286A8BC: 480000CC  b 0x8286a988
	pc = 0x8286A988; continue 'dispatch;
            }
            0x8286A8C0 => {
    //   block [0x8286A8C0..0x8286A8DC)
	// 8286A8C0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286A8C4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286A8C8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8286A8CC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8286A8D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286A8D4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286A8D8: 40810054  ble 0x8286a92c
	if !ctx.cr[0].gt {
	pc = 0x8286A92C; continue 'dispatch;
	}
	pc = 0x8286A8DC; continue 'dispatch;
            }
            0x8286A8DC => {
    //   block [0x8286A8DC..0x8286A8FC)
	// 8286A8DC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286A8E0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286A8E4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286A8E8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A8EC: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8286A8F0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286A8F4: 41980008  blt cr6, 0x8286a8fc
	if ctx.cr[6].lt {
	pc = 0x8286A8FC; continue 'dispatch;
	}
	// 8286A8F8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x8286A8FC; continue 'dispatch;
            }
            0x8286A8FC => {
    //   block [0x8286A8FC..0x8286A918)
	// 8286A8FC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286A900: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286A904: 419A0014  beq cr6, 0x8286a918
	if ctx.cr[6].eq {
	pc = 0x8286A918; continue 'dispatch;
	}
	// 8286A908: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286A90C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286A910: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286A914: 4800000C  b 0x8286a920
	pc = 0x8286A920; continue 'dispatch;
            }
            0x8286A918 => {
    //   block [0x8286A918..0x8286A920)
	// 8286A918: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286A91C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286A920; continue 'dispatch;
            }
            0x8286A920 => {
    //   block [0x8286A920..0x8286A92C)
	// 8286A920: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286A924: 4199FFB8  bgt cr6, 0x8286a8dc
	if ctx.cr[6].gt {
	pc = 0x8286A8DC; continue 'dispatch;
	}
	// 8286A928: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8286A92C; continue 'dispatch;
            }
            0x8286A92C => {
    //   block [0x8286A92C..0x8286A948)
	// 8286A92C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8286A930: 419A0040  beq cr6, 0x8286a970
	if ctx.cr[6].eq {
	pc = 0x8286A970; continue 'dispatch;
	}
	// 8286A934: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A938: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8286A93C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286A940: 41990008  bgt cr6, 0x8286a948
	if ctx.cr[6].gt {
	pc = 0x8286A948; continue 'dispatch;
	}
	// 8286A944: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8286A948; continue 'dispatch;
            }
            0x8286A948 => {
    //   block [0x8286A948..0x8286A970)
	// 8286A948: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286A94C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A950: 409A0020  bne cr6, 0x8286a970
	if !ctx.cr[6].eq {
	pc = 0x8286A970; continue 'dispatch;
	}
	// 8286A954: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8286A958: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8286A95C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286A960: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286A964: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286A968: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286A96C: 4800001C  b 0x8286a988
	pc = 0x8286A988; continue 'dispatch;
            }
            0x8286A970 => {
    //   block [0x8286A970..0x8286A984)
	// 8286A970: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286A974: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286A978: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286A97C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286A980: 48000008  b 0x8286a988
	pc = 0x8286A988; continue 'dispatch;
            }
            0x8286A984 => {
    //   block [0x8286A984..0x8286A988)
	// 8286A984: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8286A988; continue 'dispatch;
            }
            0x8286A988 => {
    //   block [0x8286A988..0x8286A9B8)
	// 8286A988: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286A98C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286A990: 419A00E8  beq cr6, 0x8286aa78
	if ctx.cr[6].eq {
	pc = 0x8286AA78; continue 'dispatch;
	}
	// 8286A994: 809E0054  lwz r4, 0x54(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286A998: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8286A99C: 419A0058  beq cr6, 0x8286a9f4
	if ctx.cr[6].eq {
	pc = 0x8286A9F4; continue 'dispatch;
	}
	// 8286A9A0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286A9A4: 4BCF89A5  bl 0x82563348
	ctx.lr = 0x8286A9A8;
	sub_82563348(ctx, base);
	// 8286A9A8: 807E0054  lwz r3, 0x54(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286A9AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286A9B0: 419A0040  beq cr6, 0x8286a9f0
	if ctx.cr[6].eq {
	pc = 0x8286A9F0; continue 'dispatch;
	}
	// 8286A9B4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8286A9B8; continue 'dispatch;
            }
            0x8286A9B8 => {
    //   block [0x8286A9B8..0x8286A9EC)
	// 8286A9B8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8286A9BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286A9C0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8286A9C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286A9C8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286A9CC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286A9D0: 4082FFE8  bne 0x8286a9b8
	if !ctx.cr[0].eq {
	pc = 0x8286A9B8; continue 'dispatch;
	}
	// 8286A9D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286A9D8: 409A0014  bne cr6, 0x8286a9ec
	if !ctx.cr[6].eq {
	pc = 0x8286A9EC; continue 'dispatch;
	}
	// 8286A9DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A9E0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286A9E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286A9E8: 4E800421  bctrl
	ctx.lr = 0x8286A9EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8286A9EC => {
    //   block [0x8286A9EC..0x8286A9F0)
	// 8286A9EC: 93BE0054  stw r29, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x8286A9F0; continue 'dispatch;
            }
            0x8286A9F0 => {
    //   block [0x8286A9F0..0x8286A9F4)
	// 8286A9F0: 93BE0054  stw r29, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x8286A9F4; continue 'dispatch;
            }
            0x8286A9F4 => {
    //   block [0x8286A9F4..0x8286AA20)
	// 8286A9F4: 807E004C  lwz r3, 0x4c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286A9F8: 3BFE004C  addi r31, r30, 0x4c
	ctx.r[31].s64 = ctx.r[30].s64 + 76;
	// 8286A9FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286AA00: 419A0020  beq cr6, 0x8286aa20
	if ctx.cr[6].eq {
	pc = 0x8286AA20; continue 'dispatch;
	}
	// 8286AA04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AA08: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286AA0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286AA10: 4E800421  bctrl
	ctx.lr = 0x8286AA14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286AA14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286AA18: 4B94D101  bl 0x821b7b18
	ctx.lr = 0x8286AA1C;
	sub_821B7B18(ctx, base);
	// 8286AA1C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8286AA20 => {
    //   block [0x8286AA20..0x8286AA4C)
	// 8286AA20: 807E0058  lwz r3, 0x58(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 8286AA24: 3BFE0058  addi r31, r30, 0x58
	ctx.r[31].s64 = ctx.r[30].s64 + 88;
	// 8286AA28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286AA2C: 419A0020  beq cr6, 0x8286aa4c
	if ctx.cr[6].eq {
	pc = 0x8286AA4C; continue 'dispatch;
	}
	// 8286AA30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AA34: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286AA38: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286AA3C: 4E800421  bctrl
	ctx.lr = 0x8286AA40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286AA40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286AA44: 4B94D0D5  bl 0x821b7b18
	ctx.lr = 0x8286AA48;
	sub_821B7B18(ctx, base);
	// 8286AA48: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8286AA4C => {
    //   block [0x8286AA4C..0x8286AA78)
	// 8286AA4C: 807E0060  lwz r3, 0x60(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 8286AA50: 3BFE0060  addi r31, r30, 0x60
	ctx.r[31].s64 = ctx.r[30].s64 + 96;
	// 8286AA54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286AA58: 419A0020  beq cr6, 0x8286aa78
	if ctx.cr[6].eq {
	pc = 0x8286AA78; continue 'dispatch;
	}
	// 8286AA5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AA60: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286AA64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286AA68: 4E800421  bctrl
	ctx.lr = 0x8286AA6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286AA6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286AA70: 4B94D0A9  bl 0x821b7b18
	ctx.lr = 0x8286AA74;
	sub_821B7B18(ctx, base);
	// 8286AA74: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
            }
            0x8286AA78 => {
    //   block [0x8286AA78..0x8286AA80)
	// 8286AA78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8286AA7C: 4843E9E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286AA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286AA80 size=688
    let mut pc: u32 = 0x8286AA80;
    'dispatch: loop {
        match pc {
            0x8286AA80 => {
    //   block [0x8286AA80..0x8286AAD8)
	// 8286AA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286AA84: 4843E981  bl 0x82ca9404
	ctx.lr = 0x8286AA88;
	sub_82CA93D0(ctx, base);
	// 8286AA88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286AA8C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8286AA90: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8286AA94: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 8286AA98: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286AA9C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8286AAA0: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 8286AAA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8286AAA8: 419A00F4  beq cr6, 0x8286ab9c
	if ctx.cr[6].eq {
	pc = 0x8286AB9C; continue 'dispatch;
	}
	// 8286AAAC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286AAB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286AAB4: 419A0024  beq cr6, 0x8286aad8
	if ctx.cr[6].eq {
	pc = 0x8286AAD8; continue 'dispatch;
	}
	// 8286AAB8: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 8286AABC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286AAC0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8286AAC4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286AAC8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286AACC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8286AAD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286AAD4: 480000CC  b 0x8286aba0
	pc = 0x8286ABA0; continue 'dispatch;
            }
            0x8286AAD8 => {
    //   block [0x8286AAD8..0x8286AAF4)
	// 8286AAD8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286AADC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286AAE0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 8286AAE4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8286AAE8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286AAEC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286AAF0: 40810054  ble 0x8286ab44
	if !ctx.cr[0].gt {
	pc = 0x8286AB44; continue 'dispatch;
	}
	pc = 0x8286AAF4; continue 'dispatch;
            }
            0x8286AAF4 => {
    //   block [0x8286AAF4..0x8286AB14)
	// 8286AAF4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286AAF8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286AAFC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286AB00: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AB04: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8286AB08: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286AB0C: 41980008  blt cr6, 0x8286ab14
	if ctx.cr[6].lt {
	pc = 0x8286AB14; continue 'dispatch;
	}
	// 8286AB10: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x8286AB14; continue 'dispatch;
            }
            0x8286AB14 => {
    //   block [0x8286AB14..0x8286AB30)
	// 8286AB14: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286AB18: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286AB1C: 419A0014  beq cr6, 0x8286ab30
	if ctx.cr[6].eq {
	pc = 0x8286AB30; continue 'dispatch;
	}
	// 8286AB20: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286AB24: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286AB28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286AB2C: 4800000C  b 0x8286ab38
	pc = 0x8286AB38; continue 'dispatch;
            }
            0x8286AB30 => {
    //   block [0x8286AB30..0x8286AB38)
	// 8286AB30: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286AB34: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286AB38; continue 'dispatch;
            }
            0x8286AB38 => {
    //   block [0x8286AB38..0x8286AB44)
	// 8286AB38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286AB3C: 4199FFB8  bgt cr6, 0x8286aaf4
	if ctx.cr[6].gt {
	pc = 0x8286AAF4; continue 'dispatch;
	}
	// 8286AB40: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8286AB44; continue 'dispatch;
            }
            0x8286AB44 => {
    //   block [0x8286AB44..0x8286AB60)
	// 8286AB44: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8286AB48: 419A0040  beq cr6, 0x8286ab88
	if ctx.cr[6].eq {
	pc = 0x8286AB88; continue 'dispatch;
	}
	// 8286AB4C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AB50: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8286AB54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286AB58: 41990008  bgt cr6, 0x8286ab60
	if ctx.cr[6].gt {
	pc = 0x8286AB60; continue 'dispatch;
	}
	// 8286AB5C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8286AB60; continue 'dispatch;
            }
            0x8286AB60 => {
    //   block [0x8286AB60..0x8286AB88)
	// 8286AB60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286AB64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286AB68: 409A0020  bne cr6, 0x8286ab88
	if !ctx.cr[6].eq {
	pc = 0x8286AB88; continue 'dispatch;
	}
	// 8286AB6C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8286AB70: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8286AB74: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286AB78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286AB7C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8286AB80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286AB84: 4800001C  b 0x8286aba0
	pc = 0x8286ABA0; continue 'dispatch;
            }
            0x8286AB88 => {
    //   block [0x8286AB88..0x8286AB9C)
	// 8286AB88: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286AB8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286AB90: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8286AB94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286AB98: 48000008  b 0x8286aba0
	pc = 0x8286ABA0; continue 'dispatch;
            }
            0x8286AB9C => {
    //   block [0x8286AB9C..0x8286ABA0)
	// 8286AB9C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x8286ABA0; continue 'dispatch;
            }
            0x8286ABA0 => {
    //   block [0x8286ABA0..0x8286ABC4)
	// 8286ABA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286ABA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286ABA8: 419A0180  beq cr6, 0x8286ad28
	if ctx.cr[6].eq {
	pc = 0x8286AD28; continue 'dispatch;
	}
	// 8286ABAC: 809C0048  lwz r4, 0x48(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286ABB0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8286ABB4: 419A0010  beq cr6, 0x8286abc4
	if ctx.cr[6].eq {
	pc = 0x8286ABC4; continue 'dispatch;
	}
	// 8286ABB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286ABBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286ABC0: 4BCF8789  bl 0x82563348
	ctx.lr = 0x8286ABC4;
	sub_82563348(ctx, base);
	pc = 0x8286ABC4; continue 'dispatch;
            }
            0x8286ABC4 => {
    //   block [0x8286ABC4..0x8286ABDC)
	// 8286ABC4: 83DC0030  lwz r30, 0x30(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 8286ABC8: 3BFC002C  addi r31, r28, 0x2c
	ctx.r[31].s64 = ctx.r[28].s64 + 44;
	// 8286ABCC: 817C0034  lwz r11, 0x34(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 8286ABD0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8286ABD4: 40990008  ble cr6, 0x8286abdc
	if !ctx.cr[6].gt {
	pc = 0x8286ABDC; continue 'dispatch;
	}
	// 8286ABD8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8286ABDC; continue 'dispatch;
            }
            0x8286ABDC => {
    //   block [0x8286ABDC..0x8286ABF0)
	// 8286ABDC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286ABE0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286ABE4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8286ABE8: 40990008  ble cr6, 0x8286abf0
	if !ctx.cr[6].gt {
	pc = 0x8286ABF0; continue 'dispatch;
	}
	// 8286ABEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8286ABF0; continue 'dispatch;
            }
            0x8286ABF0 => {
    //   block [0x8286ABF0..0x8286ABFC)
	// 8286ABF0: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8286ABF4: 419A0008  beq cr6, 0x8286abfc
	if ctx.cr[6].eq {
	pc = 0x8286ABFC; continue 'dispatch;
	}
	// 8286ABF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8286ABFC; continue 'dispatch;
            }
            0x8286ABFC => {
    //   block [0x8286ABFC..0x8286AC10)
	// 8286ABFC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8286AC00: 419A0030  beq cr6, 0x8286ac30
	if ctx.cr[6].eq {
	pc = 0x8286AC30; continue 'dispatch;
	}
	// 8286AC04: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8286AC08: 41980008  blt cr6, 0x8286ac10
	if ctx.cr[6].lt {
	pc = 0x8286AC10; continue 'dispatch;
	}
	// 8286AC0C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8286AC10; continue 'dispatch;
            }
            0x8286AC10 => {
    //   block [0x8286AC10..0x8286AC28)
	// 8286AC10: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AC14: 4BFFDB45  bl 0x82868758
	ctx.lr = 0x8286AC18;
	sub_82868758(ctx, base);
	// 8286AC18: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286AC1C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8286AC20: 41980008  blt cr6, 0x8286ac28
	if ctx.cr[6].lt {
	pc = 0x8286AC28; continue 'dispatch;
	}
	// 8286AC24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8286AC28; continue 'dispatch;
            }
            0x8286AC28 => {
    //   block [0x8286AC28..0x8286AC30)
	// 8286AC28: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 8286AC2C: 4BFFFFB0  b 0x8286abdc
	pc = 0x8286ABDC; continue 'dispatch;
            }
            0x8286AC30 => {
    //   block [0x8286AC30..0x8286AC70)
	// 8286AC30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286AC34: 4BD149A5  bl 0x8257f5d8
	ctx.lr = 0x8286AC38;
	sub_8257F5D8(ctx, base);
	// 8286AC38: 387C001C  addi r3, r28, 0x1c
	ctx.r[3].s64 = ctx.r[28].s64 + 28;
	// 8286AC3C: 4BD1499D  bl 0x8257f5d8
	ctx.lr = 0x8286AC40;
	sub_8257F5D8(ctx, base);
	// 8286AC40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286AC44: 4BFFFC25  bl 0x8286a868
	ctx.lr = 0x8286AC48;
	sub_8286A868(ctx, base);
	// 8286AC48: 809C00B0  lwz r4, 0xb0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(176 as u32) ) } as u64;
	// 8286AC4C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8286AC50: 419A00D8  beq cr6, 0x8286ad28
	if ctx.cr[6].eq {
	pc = 0x8286AD28; continue 'dispatch;
	}
	// 8286AC54: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286AC58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286AC5C: 4BCF86ED  bl 0x82563348
	ctx.lr = 0x8286AC60;
	sub_82563348(ctx, base);
	// 8286AC60: 807C00B0  lwz r3, 0xb0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(176 as u32) ) } as u64;
	// 8286AC64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286AC68: 419A0040  beq cr6, 0x8286aca8
	if ctx.cr[6].eq {
	pc = 0x8286ACA8; continue 'dispatch;
	}
	// 8286AC6C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8286AC70; continue 'dispatch;
            }
            0x8286AC70 => {
    //   block [0x8286AC70..0x8286ACA4)
	// 8286AC70: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8286AC74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286AC78: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8286AC7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286AC80: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286AC84: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286AC88: 4082FFE8  bne 0x8286ac70
	if !ctx.cr[0].eq {
	pc = 0x8286AC70; continue 'dispatch;
	}
	// 8286AC8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286AC90: 409A0014  bne cr6, 0x8286aca4
	if !ctx.cr[6].eq {
	pc = 0x8286ACA4; continue 'dispatch;
	}
	// 8286AC94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AC98: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286AC9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286ACA0: 4E800421  bctrl
	ctx.lr = 0x8286ACA4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8286ACA4 => {
    //   block [0x8286ACA4..0x8286ACA8)
	// 8286ACA4: 937C00B0  stw r27, 0xb0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(176 as u32), ctx.r[27].u32 ) };
	pc = 0x8286ACA8; continue 'dispatch;
            }
            0x8286ACA8 => {
    //   block [0x8286ACA8..0x8286ACB4)
	// 8286ACA8: 3BFC0080  addi r31, r28, 0x80
	ctx.r[31].s64 = ctx.r[28].s64 + 128;
	// 8286ACAC: 937C00B0  stw r27, 0xb0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(176 as u32), ctx.r[27].u32 ) };
	// 8286ACB0: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	pc = 0x8286ACB4; continue 'dispatch;
            }
            0x8286ACB4 => {
    //   block [0x8286ACB4..0x8286AD28)
	// 8286ACB4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286ACB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286ACBC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286ACC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286ACC4: 4E800421  bctrl
	ctx.lr = 0x8286ACC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286ACC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286ACCC: 4B94CE4D  bl 0x821b7b18
	ctx.lr = 0x8286ACD0;
	sub_821B7B18(ctx, base);
	// 8286ACD0: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 8286ACD4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8286ACD8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 8286ACDC: 4082FFD8  bne 0x8286acb4
	if !ctx.cr[0].eq {
	pc = 0x8286ACB4; continue 'dispatch;
	}
	// 8286ACE0: 807C00A0  lwz r3, 0xa0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(160 as u32) ) } as u64;
	// 8286ACE4: 3BFC00A0  addi r31, r28, 0xa0
	ctx.r[31].s64 = ctx.r[28].s64 + 160;
	// 8286ACE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286ACEC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286ACF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286ACF4: 4E800421  bctrl
	ctx.lr = 0x8286ACF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286ACF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286ACFC: 4B94CE1D  bl 0x821b7b18
	ctx.lr = 0x8286AD00;
	sub_821B7B18(ctx, base);
	// 8286AD00: 937C00A0  stw r27, 0xa0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(160 as u32), ctx.r[27].u32 ) };
	// 8286AD04: 807C00A8  lwz r3, 0xa8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 8286AD08: 3BFC00A8  addi r31, r28, 0xa8
	ctx.r[31].s64 = ctx.r[28].s64 + 168;
	// 8286AD0C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AD10: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286AD14: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8286AD18: 4E800421  bctrl
	ctx.lr = 0x8286AD1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286AD1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286AD20: 4B94CDF9  bl 0x821b7b18
	ctx.lr = 0x8286AD24;
	sub_821B7B18(ctx, base);
	// 8286AD24: 937C00A8  stw r27, 0xa8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(168 as u32), ctx.r[27].u32 ) };
            }
            0x8286AD28 => {
    //   block [0x8286AD28..0x8286AD30)
	// 8286AD28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8286AD2C: 4843E728  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286AD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286AD30 size=96
    let mut pc: u32 = 0x8286AD30;
    'dispatch: loop {
        match pc {
            0x8286AD30 => {
    //   block [0x8286AD30..0x8286AD74)
	// 8286AD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286AD34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286AD38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286AD3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286AD40: 81630068  lwz r11, 0x68(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 8286AD44: 3BE30068  addi r31, r3, 0x68
	ctx.r[31].s64 = ctx.r[3].s64 + 104;
	// 8286AD48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286AD4C: 419A0030  beq cr6, 0x8286ad7c
	if ctx.cr[6].eq {
	pc = 0x8286AD7C; continue 'dispatch;
	}
	// 8286AD50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286AD54: 480000B5  bl 0x8286ae08
	ctx.lr = 0x8286AD58;
	sub_8286AE08(ctx, base);
	// 8286AD58: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AD5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286AD60: 419A0014  beq cr6, 0x8286ad74
	if ctx.cr[6].eq {
	pc = 0x8286AD74; continue 'dispatch;
	}
	// 8286AD64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AD68: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286AD6C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286AD70: 4E800421  bctrl
	ctx.lr = 0x8286AD74;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8286AD74 => {
    //   block [0x8286AD74..0x8286AD7C)
	// 8286AD74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8286AD78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8286AD7C; continue 'dispatch;
            }
            0x8286AD7C => {
    //   block [0x8286AD7C..0x8286AD90)
	// 8286AD7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8286AD80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286AD84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286AD88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286AD8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286AD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286AD90 size=116
    let mut pc: u32 = 0x8286AD90;
    'dispatch: loop {
        match pc {
            0x8286AD90 => {
    //   block [0x8286AD90..0x8286ADC8)
	// 8286AD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286AD94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286AD98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286AD9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286ADA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286ADA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8286ADA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286ADAC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8286ADB0: 419A0018  beq cr6, 0x8286adc8
	if ctx.cr[6].eq {
	pc = 0x8286ADC8; continue 'dispatch;
	}
	// 8286ADB4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286ADB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286ADBC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286ADC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286ADC4: 4E800421  bctrl
	ctx.lr = 0x8286ADC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8286ADC8 => {
    //   block [0x8286ADC8..0x8286ADE4)
	// 8286ADC8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286ADCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286ADD0: 419A0014  beq cr6, 0x8286ade4
	if ctx.cr[6].eq {
	pc = 0x8286ADE4; continue 'dispatch;
	}
	// 8286ADD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286ADD8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286ADDC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286ADE0: 4E800421  bctrl
	ctx.lr = 0x8286ADE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8286ADE4 => {
    //   block [0x8286ADE4..0x8286AE04)
	// 8286ADE4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8286ADE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286ADEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286ADF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286ADF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286ADF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286ADFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286AE00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286AE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286AE08 size=76
    let mut pc: u32 = 0x8286AE08;
    'dispatch: loop {
        match pc {
            0x8286AE08 => {
    //   block [0x8286AE08..0x8286AE40)
	// 8286AE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286AE0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286AE10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286AE14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286AE18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286AE1C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AE20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286AE24: 419A001C  beq cr6, 0x8286ae40
	if ctx.cr[6].eq {
	pc = 0x8286AE40; continue 'dispatch;
	}
	// 8286AE28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AE2C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286AE30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286AE34: 4E800421  bctrl
	ctx.lr = 0x8286AE38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286AE38: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8286AE3C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
            }
            0x8286AE40 => {
    //   block [0x8286AE40..0x8286AE54)
	// 8286AE40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8286AE44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286AE48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286AE4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286AE50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286AE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286AE58 size=100
    let mut pc: u32 = 0x8286AE58;
    'dispatch: loop {
        match pc {
            0x8286AE58 => {
    //   block [0x8286AE58..0x8286AE8C)
	// 8286AE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286AE5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286AE60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286AE64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286AE68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286AE6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8286AE70: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8286AE74: 419A0030  beq cr6, 0x8286aea4
	if ctx.cr[6].eq {
	pc = 0x8286AEA4; continue 'dispatch;
	}
	// 8286AE78: 807E0024  lwz r3, 0x24(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 8286AE7C: 3BFE0020  addi r31, r30, 0x20
	ctx.r[31].s64 = ctx.r[30].s64 + 32;
	// 8286AE80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286AE84: 419A0008  beq cr6, 0x8286ae8c
	if ctx.cr[6].eq {
	pc = 0x8286AE8C; continue 'dispatch;
	}
	// 8286AE88: 4B9B0EB1  bl 0x8221bd38
	ctx.lr = 0x8286AE8C;
	sub_8221BD38(ctx, base);
	pc = 0x8286AE8C; continue 'dispatch;
            }
            0x8286AE8C => {
    //   block [0x8286AE8C..0x8286AEA4)
	// 8286AE8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8286AE90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286AE94: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8286AE98: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8286AE9C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8286AEA0: 4B9B0E99  bl 0x8221bd38
	ctx.lr = 0x8286AEA4;
	sub_8221BD38(ctx, base);
	pc = 0x8286AEA4; continue 'dispatch;
            }
            0x8286AEA4 => {
    //   block [0x8286AEA4..0x8286AEBC)
	// 8286AEA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286AEA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286AEAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286AEB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286AEB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286AEB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286AEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286AEC0 size=88
    let mut pc: u32 = 0x8286AEC0;
    'dispatch: loop {
        match pc {
            0x8286AEC0 => {
    //   block [0x8286AEC0..0x8286AF04)
	// 8286AEC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286AEC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286AEC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286AECC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286AED0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286AED4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8286AED8: 419A002C  beq cr6, 0x8286af04
	if ctx.cr[6].eq {
	pc = 0x8286AF04; continue 'dispatch;
	}
	// 8286AEDC: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 8286AEE0: 4B94CC39  bl 0x821b7b18
	ctx.lr = 0x8286AEE4;
	sub_821B7B18(ctx, base);
	// 8286AEE4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 8286AEE8: 4B94CC31  bl 0x821b7b18
	ctx.lr = 0x8286AEEC;
	sub_821B7B18(ctx, base);
	// 8286AEEC: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 8286AEF0: 4B94CC29  bl 0x821b7b18
	ctx.lr = 0x8286AEF4;
	sub_821B7B18(ctx, base);
	// 8286AEF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286AEF8: 4B94CC21  bl 0x821b7b18
	ctx.lr = 0x8286AEFC;
	sub_821B7B18(ctx, base);
	// 8286AEFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286AF00: 4B9B0E39  bl 0x8221bd38
	ctx.lr = 0x8286AF04;
	sub_8221BD38(ctx, base);
	pc = 0x8286AF04; continue 'dispatch;
            }
            0x8286AF04 => {
    //   block [0x8286AF04..0x8286AF18)
	// 8286AF04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8286AF08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286AF0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286AF10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286AF14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286AF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8286AF18 size=8
    let mut pc: u32 = 0x8286AF18;
    'dispatch: loop {
        match pc {
            0x8286AF18 => {
    //   block [0x8286AF18..0x8286AF20)
	// 8286AF18: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 8286AF1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286AF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286AF20 size=180
    let mut pc: u32 = 0x8286AF20;
    'dispatch: loop {
        match pc {
            0x8286AF20 => {
    //   block [0x8286AF20..0x8286AF54)
	// 8286AF20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286AF24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286AF28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286AF2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286AF30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286AF34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286AF38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8286AF3C: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 8286AF40: 4B94CBD9  bl 0x821b7b18
	ctx.lr = 0x8286AF44;
	sub_821B7B18(ctx, base);
	// 8286AF44: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8286AF48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286AF4C: 419A0044  beq cr6, 0x8286af90
	if ctx.cr[6].eq {
	pc = 0x8286AF90; continue 'dispatch;
	}
	// 8286AF50: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8286AF54; continue 'dispatch;
            }
            0x8286AF54 => {
    //   block [0x8286AF54..0x8286AF88)
	// 8286AF54: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8286AF58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286AF5C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8286AF60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286AF64: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286AF68: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286AF6C: 4082FFE8  bne 0x8286af54
	if !ctx.cr[0].eq {
	pc = 0x8286AF54; continue 'dispatch;
	}
	// 8286AF70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286AF74: 409A0014  bne cr6, 0x8286af88
	if !ctx.cr[6].eq {
	pc = 0x8286AF88; continue 'dispatch;
	}
	// 8286AF78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AF7C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286AF80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286AF84: 4E800421  bctrl
	ctx.lr = 0x8286AF88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8286AF88 => {
    //   block [0x8286AF88..0x8286AF90)
	// 8286AF88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8286AF8C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x8286AF90; continue 'dispatch;
            }
            0x8286AF90 => {
    //   block [0x8286AF90..0x8286AFBC)
	// 8286AF90: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8286AF94: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 8286AF98: 394BF058  addi r10, r11, -0xfa8
	ctx.r[10].s64 = ctx.r[11].s64 + -4008;
	// 8286AF9C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8286AFA0: 4B9A9E39  bl 0x82214dd8
	ctx.lr = 0x8286AFA4;
	sub_82214DD8(ctx, base);
	// 8286AFA4: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8286AFA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286AFAC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8286AFB0: 419A000C  beq cr6, 0x8286afbc
	if ctx.cr[6].eq {
	pc = 0x8286AFBC; continue 'dispatch;
	}
	// 8286AFB4: 4B9B0D85  bl 0x8221bd38
	ctx.lr = 0x8286AFB8;
	sub_8221BD38(ctx, base);
	// 8286AFB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8286AFBC; continue 'dispatch;
            }
            0x8286AFBC => {
    //   block [0x8286AFBC..0x8286AFD4)
	// 8286AFBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286AFC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286AFC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286AFC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286AFCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286AFD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286AFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8286AFD8 size=952
    let mut pc: u32 = 0x8286AFD8;
    'dispatch: loop {
        match pc {
            0x8286AFD8 => {
    //   block [0x8286AFD8..0x8286B030)
	// 8286AFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286AFDC: 4843E429  bl 0x82ca9404
	ctx.lr = 0x8286AFE0;
	sub_82CA93D0(ctx, base);
	// 8286AFE0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286AFE4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8286AFE8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8286AFEC: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 8286AFF0: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286AFF4: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 8286AFF8: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 8286AFFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286B000: 419A00F4  beq cr6, 0x8286b0f4
	if ctx.cr[6].eq {
	pc = 0x8286B0F4; continue 'dispatch;
	}
	// 8286B004: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286B008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B00C: 419A0024  beq cr6, 0x8286b030
	if ctx.cr[6].eq {
	pc = 0x8286B030; continue 'dispatch;
	}
	// 8286B010: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 8286B014: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286B018: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8286B01C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286B020: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B024: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8286B028: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B02C: 480000CC  b 0x8286b0f8
	pc = 0x8286B0F8; continue 'dispatch;
            }
            0x8286B030 => {
    //   block [0x8286B030..0x8286B04C)
	// 8286B030: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286B034: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286B038: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8286B03C: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 8286B040: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8286B044: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B048: 40810054  ble 0x8286b09c
	if !ctx.cr[0].gt {
	pc = 0x8286B09C; continue 'dispatch;
	}
	pc = 0x8286B04C; continue 'dispatch;
            }
            0x8286B04C => {
    //   block [0x8286B04C..0x8286B06C)
	// 8286B04C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286B050: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286B054: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286B058: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B05C: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8286B060: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286B064: 41980008  blt cr6, 0x8286b06c
	if ctx.cr[6].lt {
	pc = 0x8286B06C; continue 'dispatch;
	}
	// 8286B068: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8286B06C; continue 'dispatch;
            }
            0x8286B06C => {
    //   block [0x8286B06C..0x8286B088)
	// 8286B06C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286B070: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286B074: 419A0014  beq cr6, 0x8286b088
	if ctx.cr[6].eq {
	pc = 0x8286B088; continue 'dispatch;
	}
	// 8286B078: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286B07C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286B080: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286B084: 4800000C  b 0x8286b090
	pc = 0x8286B090; continue 'dispatch;
            }
            0x8286B088 => {
    //   block [0x8286B088..0x8286B090)
	// 8286B088: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286B08C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286B090; continue 'dispatch;
            }
            0x8286B090 => {
    //   block [0x8286B090..0x8286B09C)
	// 8286B090: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B094: 4199FFB8  bgt cr6, 0x8286b04c
	if ctx.cr[6].gt {
	pc = 0x8286B04C; continue 'dispatch;
	}
	// 8286B098: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8286B09C; continue 'dispatch;
            }
            0x8286B09C => {
    //   block [0x8286B09C..0x8286B0B8)
	// 8286B09C: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8286B0A0: 419A0040  beq cr6, 0x8286b0e0
	if ctx.cr[6].eq {
	pc = 0x8286B0E0; continue 'dispatch;
	}
	// 8286B0A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B0A8: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8286B0AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B0B0: 41990008  bgt cr6, 0x8286b0b8
	if ctx.cr[6].gt {
	pc = 0x8286B0B8; continue 'dispatch;
	}
	// 8286B0B4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8286B0B8; continue 'dispatch;
            }
            0x8286B0B8 => {
    //   block [0x8286B0B8..0x8286B0E0)
	// 8286B0B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286B0BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B0C0: 409A0020  bne cr6, 0x8286b0e0
	if !ctx.cr[6].eq {
	pc = 0x8286B0E0; continue 'dispatch;
	}
	// 8286B0C4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8286B0C8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8286B0CC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8286B0D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B0D4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8286B0D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B0DC: 4800001C  b 0x8286b0f8
	pc = 0x8286B0F8; continue 'dispatch;
            }
            0x8286B0E0 => {
    //   block [0x8286B0E0..0x8286B0F4)
	// 8286B0E0: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8286B0E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B0E8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8286B0EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B0F0: 48000008  b 0x8286b0f8
	pc = 0x8286B0F8; continue 'dispatch;
            }
            0x8286B0F4 => {
    //   block [0x8286B0F4..0x8286B0F8)
	// 8286B0F4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8286B0F8; continue 'dispatch;
            }
            0x8286B0F8 => {
    //   block [0x8286B0F8..0x8286B140)
	// 8286B0F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286B0FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B100: 419A0288  beq cr6, 0x8286b388
	if ctx.cr[6].eq {
	pc = 0x8286B388; continue 'dispatch;
	}
	// 8286B104: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 8286B108: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 8286B10C: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 8286B110: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286B114: 419A00E8  beq cr6, 0x8286b1fc
	if ctx.cr[6].eq {
	pc = 0x8286B1FC; continue 'dispatch;
	}
	// 8286B118: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286B11C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B120: 419A0020  beq cr6, 0x8286b140
	if ctx.cr[6].eq {
	pc = 0x8286B140; continue 'dispatch;
	}
	// 8286B124: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8286B128: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286B12C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8286B130: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286B134: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B138: 83C90004  lwz r30, 4(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B13C: 480000C4  b 0x8286b200
	pc = 0x8286B200; continue 'dispatch;
            }
            0x8286B140 => {
    //   block [0x8286B140..0x8286B15C)
	// 8286B140: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286B144: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286B148: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8286B14C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8286B150: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8286B154: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B158: 40810054  ble 0x8286b1ac
	if !ctx.cr[0].gt {
	pc = 0x8286B1AC; continue 'dispatch;
	}
	pc = 0x8286B15C; continue 'dispatch;
            }
            0x8286B15C => {
    //   block [0x8286B15C..0x8286B17C)
	// 8286B15C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286B160: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286B164: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286B168: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B16C: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 8286B170: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286B174: 41980008  blt cr6, 0x8286b17c
	if ctx.cr[6].lt {
	pc = 0x8286B17C; continue 'dispatch;
	}
	// 8286B178: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8286B17C; continue 'dispatch;
            }
            0x8286B17C => {
    //   block [0x8286B17C..0x8286B198)
	// 8286B17C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286B180: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286B184: 419A0014  beq cr6, 0x8286b198
	if ctx.cr[6].eq {
	pc = 0x8286B198; continue 'dispatch;
	}
	// 8286B188: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286B18C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286B190: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286B194: 4800000C  b 0x8286b1a0
	pc = 0x8286B1A0; continue 'dispatch;
            }
            0x8286B198 => {
    //   block [0x8286B198..0x8286B1A0)
	// 8286B198: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286B19C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286B1A0; continue 'dispatch;
            }
            0x8286B1A0 => {
    //   block [0x8286B1A0..0x8286B1AC)
	// 8286B1A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B1A4: 4199FFB8  bgt cr6, 0x8286b15c
	if ctx.cr[6].gt {
	pc = 0x8286B15C; continue 'dispatch;
	}
	// 8286B1A8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8286B1AC; continue 'dispatch;
            }
            0x8286B1AC => {
    //   block [0x8286B1AC..0x8286B1C8)
	// 8286B1AC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8286B1B0: 419A003C  beq cr6, 0x8286b1ec
	if ctx.cr[6].eq {
	pc = 0x8286B1EC; continue 'dispatch;
	}
	// 8286B1B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B1B8: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 8286B1BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B1C0: 41990008  bgt cr6, 0x8286b1c8
	if ctx.cr[6].gt {
	pc = 0x8286B1C8; continue 'dispatch;
	}
	// 8286B1C4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8286B1C8; continue 'dispatch;
            }
            0x8286B1C8 => {
    //   block [0x8286B1C8..0x8286B1EC)
	// 8286B1C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286B1CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B1D0: 409A001C  bne cr6, 0x8286b1ec
	if !ctx.cr[6].eq {
	pc = 0x8286B1EC; continue 'dispatch;
	}
	// 8286B1D4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8286B1D8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8286B1DC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8286B1E0: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B1E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B1E8: 48000018  b 0x8286b200
	pc = 0x8286B200; continue 'dispatch;
            }
            0x8286B1EC => {
    //   block [0x8286B1EC..0x8286B1FC)
	// 8286B1EC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286B1F0: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B1F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B1F8: 48000008  b 0x8286b200
	pc = 0x8286B200; continue 'dispatch;
            }
            0x8286B1FC => {
    //   block [0x8286B1FC..0x8286B200)
	// 8286B1FC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8286B200; continue 'dispatch;
            }
            0x8286B200 => {
    //   block [0x8286B200..0x8286B294)
	// 8286B200: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286B204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B208: 419A0180  beq cr6, 0x8286b388
	if ctx.cr[6].eq {
	pc = 0x8286B388; continue 'dispatch;
	}
	// 8286B20C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8286B210: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286B214: 388B222C  addi r4, r11, 0x222c
	ctx.r[4].s64 = ctx.r[11].s64 + 8748;
	// 8286B218: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8286B21C: 4B9C1CB5  bl 0x8222ced0
	ctx.lr = 0x8286B220;
	sub_8222CED0(ctx, base);
	// 8286B220: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8286B224: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8286B228: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286B22C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8286B230: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286B234: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286B238: 4BA18AF9  bl 0x82283d30
	ctx.lr = 0x8286B23C;
	sub_82283D30(ctx, base);
	// 8286B23C: 3BFB0014  addi r31, r27, 0x14
	ctx.r[31].s64 = ctx.r[27].s64 + 20;
	// 8286B240: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286B244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286B248: 4BA07E11  bl 0x82273058
	ctx.lr = 0x8286B24C;
	sub_82273058(ctx, base);
	// 8286B24C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8286B250: 4B9A9B89  bl 0x82214dd8
	ctx.lr = 0x8286B254;
	sub_82214DD8(ctx, base);
	// 8286B254: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286B258: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286B25C: 809B0014  lwz r4, 0x14(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8286B260: 4BBB6B69  bl 0x82421dc8
	ctx.lr = 0x8286B264;
	sub_82421DC8(ctx, base);
	// 8286B264: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8286B268: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286B26C: 419A011C  beq cr6, 0x8286b388
	if ctx.cr[6].eq {
	pc = 0x8286B388; continue 'dispatch;
	}
	// 8286B270: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8286B274: 4B9B3FE5  bl 0x8221f258
	ctx.lr = 0x8286B278;
	sub_8221F258(ctx, base);
	// 8286B278: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286B27C: 419A0018  beq cr6, 0x8286b294
	if ctx.cr[6].eq {
	pc = 0x8286B294; continue 'dispatch;
	}
	// 8286B280: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8286B284: C02BB730  lfs f1, -0x48d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18640 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8286B288: 4BA208B9  bl 0x8228bb40
	ctx.lr = 0x8286B28C;
	sub_8228BB40(ctx, base);
	// 8286B28C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8286B290: 48000008  b 0x8286b298
	pc = 0x8286B298; continue 'dispatch;
            }
            0x8286B294 => {
    //   block [0x8286B294..0x8286B298)
	// 8286B294: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8286B298; continue 'dispatch;
            }
            0x8286B298 => {
    //   block [0x8286B298..0x8286B2D4)
	// 8286B298: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8286B29C: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B2A0: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 8286B2A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8286B2A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286B2AC: 4B962E95  bl 0x821ce140
	ctx.lr = 0x8286B2B0;
	sub_821CE140(ctx, base);
	// 8286B2B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286B2B4: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8286B2B8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B2BC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8286B2C0: 419A007C  beq cr6, 0x8286b33c
	if ctx.cr[6].eq {
	pc = 0x8286B33C; continue 'dispatch;
	}
	// 8286B2C4: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8286B2C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286B2CC: 419A0040  beq cr6, 0x8286b30c
	if ctx.cr[6].eq {
	pc = 0x8286B30C; continue 'dispatch;
	}
	// 8286B2D0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8286B2D4; continue 'dispatch;
            }
            0x8286B2D4 => {
    //   block [0x8286B2D4..0x8286B308)
	// 8286B2D4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8286B2D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B2DC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8286B2E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286B2E4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286B2E8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B2EC: 4082FFE8  bne 0x8286b2d4
	if !ctx.cr[0].eq {
	pc = 0x8286B2D4; continue 'dispatch;
	}
	// 8286B2F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B2F4: 409A0014  bne cr6, 0x8286b308
	if !ctx.cr[6].eq {
	pc = 0x8286B308; continue 'dispatch;
	}
	// 8286B2F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B2FC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B300: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286B304: 4E800421  bctrl
	ctx.lr = 0x8286B308;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8286B308 => {
    //   block [0x8286B308..0x8286B30C)
	// 8286B308: 939B0010  stw r28, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	pc = 0x8286B30C; continue 'dispatch;
            }
            0x8286B30C => {
    //   block [0x8286B30C..0x8286B320)
	// 8286B30C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B314: 917B0010  stw r11, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8286B318: 419A0024  beq cr6, 0x8286b33c
	if ctx.cr[6].eq {
	pc = 0x8286B33C; continue 'dispatch;
	}
	// 8286B31C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x8286B320; continue 'dispatch;
            }
            0x8286B320 => {
    //   block [0x8286B320..0x8286B33C)
	// 8286B320: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8286B324: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B328: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286B32C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8286B330: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286B334: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B338: 4082FFE8  bne 0x8286b320
	if !ctx.cr[0].eq {
	pc = 0x8286B320; continue 'dispatch;
	}
	pc = 0x8286B33C; continue 'dispatch;
            }
            0x8286B33C => {
    //   block [0x8286B33C..0x8286B350)
	// 8286B33C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8286B340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B344: 419A0044  beq cr6, 0x8286b388
	if ctx.cr[6].eq {
	pc = 0x8286B388; continue 'dispatch;
	}
	// 8286B348: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286B34C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x8286B350; continue 'dispatch;
            }
            0x8286B350 => {
    //   block [0x8286B350..0x8286B388)
	// 8286B350: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8286B354: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B358: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286B35C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8286B360: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286B364: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B368: 4082FFE8  bne 0x8286b350
	if !ctx.cr[0].eq {
	pc = 0x8286B350; continue 'dispatch;
	}
	// 8286B36C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8286B370: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B374: 409A0014  bne cr6, 0x8286b388
	if !ctx.cr[6].eq {
	pc = 0x8286B388; continue 'dispatch;
	}
	// 8286B378: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B37C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B380: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286B384: 4E800421  bctrl
	ctx.lr = 0x8286B388;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8286B388 => {
    //   block [0x8286B388..0x8286B390)
	// 8286B388: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8286B38C: 4843E0C8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8286B390 size=1180
    let mut pc: u32 = 0x8286B390;
    'dispatch: loop {
        match pc {
            0x8286B390 => {
    //   block [0x8286B390..0x8286B404)
	// 8286B390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286B394: 4843E071  bl 0x82ca9404
	ctx.lr = 0x8286B398;
	sub_82CA93D0(ctx, base);
	// 8286B398: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8286B39C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286B3A0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8286B3A4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8286B3A8: C96B9660  lfd f11, -0x69a0(r11)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 8286B3AC: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B3B0: 4B99C441  bl 0x822077f0
	ctx.lr = 0x8286B3B4;
	sub_822077F0(ctx, base);
	// 8286B3B4: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B3B8: FC015824  fdiv f0, f1, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64 / ctx.f[11].f64;
	// 8286B3BC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8286B3C0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 8286B3C4: 81460024  lwz r10, 0x24(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 8286B3C8: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 8286B3CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8286B3D0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8286B3D4: 419A00F4  beq cr6, 0x8286b4c8
	if ctx.cr[6].eq {
	pc = 0x8286B4C8; continue 'dispatch;
	}
	// 8286B3D8: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286B3DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B3E0: 419A0024  beq cr6, 0x8286b404
	if ctx.cr[6].eq {
	pc = 0x8286B404; continue 'dispatch;
	}
	// 8286B3E4: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 8286B3E8: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286B3EC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8286B3F0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286B3F4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B3F8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8286B3FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B400: 480000CC  b 0x8286b4cc
	pc = 0x8286B4CC; continue 'dispatch;
            }
            0x8286B404 => {
    //   block [0x8286B404..0x8286B420)
	// 8286B404: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286B408: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286B40C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8286B410: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 8286B414: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286B418: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B41C: 40810054  ble 0x8286b470
	if !ctx.cr[0].gt {
	pc = 0x8286B470; continue 'dispatch;
	}
	pc = 0x8286B420; continue 'dispatch;
            }
            0x8286B420 => {
    //   block [0x8286B420..0x8286B440)
	// 8286B420: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286B424: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286B428: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286B42C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B430: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 8286B434: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286B438: 41980008  blt cr6, 0x8286b440
	if ctx.cr[6].lt {
	pc = 0x8286B440; continue 'dispatch;
	}
	// 8286B43C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8286B440; continue 'dispatch;
            }
            0x8286B440 => {
    //   block [0x8286B440..0x8286B45C)
	// 8286B440: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286B444: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286B448: 419A0014  beq cr6, 0x8286b45c
	if ctx.cr[6].eq {
	pc = 0x8286B45C; continue 'dispatch;
	}
	// 8286B44C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286B450: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286B454: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286B458: 4800000C  b 0x8286b464
	pc = 0x8286B464; continue 'dispatch;
            }
            0x8286B45C => {
    //   block [0x8286B45C..0x8286B464)
	// 8286B45C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286B460: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286B464; continue 'dispatch;
            }
            0x8286B464 => {
    //   block [0x8286B464..0x8286B470)
	// 8286B464: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B468: 4199FFB8  bgt cr6, 0x8286b420
	if ctx.cr[6].gt {
	pc = 0x8286B420; continue 'dispatch;
	}
	// 8286B46C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8286B470; continue 'dispatch;
            }
            0x8286B470 => {
    //   block [0x8286B470..0x8286B48C)
	// 8286B470: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 8286B474: 419A0040  beq cr6, 0x8286b4b4
	if ctx.cr[6].eq {
	pc = 0x8286B4B4; continue 'dispatch;
	}
	// 8286B478: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B47C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8286B480: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B484: 41990008  bgt cr6, 0x8286b48c
	if ctx.cr[6].gt {
	pc = 0x8286B48C; continue 'dispatch;
	}
	// 8286B488: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8286B48C; continue 'dispatch;
            }
            0x8286B48C => {
    //   block [0x8286B48C..0x8286B4B4)
	// 8286B48C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286B490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B494: 409A0020  bne cr6, 0x8286b4b4
	if !ctx.cr[6].eq {
	pc = 0x8286B4B4; continue 'dispatch;
	}
	// 8286B498: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8286B49C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8286B4A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286B4A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B4A8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8286B4AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B4B0: 4800001C  b 0x8286b4cc
	pc = 0x8286B4CC; continue 'dispatch;
            }
            0x8286B4B4 => {
    //   block [0x8286B4B4..0x8286B4C8)
	// 8286B4B4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8286B4B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B4BC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8286B4C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B4C4: 48000008  b 0x8286b4cc
	pc = 0x8286B4CC; continue 'dispatch;
            }
            0x8286B4C8 => {
    //   block [0x8286B4C8..0x8286B4CC)
	// 8286B4C8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8286B4CC; continue 'dispatch;
            }
            0x8286B4CC => {
    //   block [0x8286B4CC..0x8286B518)
	// 8286B4CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286B4D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B4D4: 419A034C  beq cr6, 0x8286b820
	if ctx.cr[6].eq {
	pc = 0x8286B820; continue 'dispatch;
	}
	// 8286B4D8: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 8286B4DC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 8286B4E0: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 8286B4E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286B4E8: 419A00F4  beq cr6, 0x8286b5dc
	if ctx.cr[6].eq {
	pc = 0x8286B5DC; continue 'dispatch;
	}
	// 8286B4EC: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286B4F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B4F4: 419A0024  beq cr6, 0x8286b518
	if ctx.cr[6].eq {
	pc = 0x8286B518; continue 'dispatch;
	}
	// 8286B4F8: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8286B4FC: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286B500: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8286B504: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286B508: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B50C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8286B510: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B514: 480000CC  b 0x8286b5e0
	pc = 0x8286B5E0; continue 'dispatch;
            }
            0x8286B518 => {
    //   block [0x8286B518..0x8286B534)
	// 8286B518: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286B51C: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286B520: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8286B524: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8286B528: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286B52C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B530: 40810054  ble 0x8286b584
	if !ctx.cr[0].gt {
	pc = 0x8286B584; continue 'dispatch;
	}
	pc = 0x8286B534; continue 'dispatch;
            }
            0x8286B534 => {
    //   block [0x8286B534..0x8286B554)
	// 8286B534: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286B538: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286B53C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286B540: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B544: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 8286B548: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286B54C: 41980008  blt cr6, 0x8286b554
	if ctx.cr[6].lt {
	pc = 0x8286B554; continue 'dispatch;
	}
	// 8286B550: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8286B554; continue 'dispatch;
            }
            0x8286B554 => {
    //   block [0x8286B554..0x8286B570)
	// 8286B554: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286B558: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286B55C: 419A0014  beq cr6, 0x8286b570
	if ctx.cr[6].eq {
	pc = 0x8286B570; continue 'dispatch;
	}
	// 8286B560: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286B564: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286B568: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286B56C: 4800000C  b 0x8286b578
	pc = 0x8286B578; continue 'dispatch;
            }
            0x8286B570 => {
    //   block [0x8286B570..0x8286B578)
	// 8286B570: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286B574: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286B578; continue 'dispatch;
            }
            0x8286B578 => {
    //   block [0x8286B578..0x8286B584)
	// 8286B578: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B57C: 4199FFB8  bgt cr6, 0x8286b534
	if ctx.cr[6].gt {
	pc = 0x8286B534; continue 'dispatch;
	}
	// 8286B580: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8286B584; continue 'dispatch;
            }
            0x8286B584 => {
    //   block [0x8286B584..0x8286B5A0)
	// 8286B584: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8286B588: 419A0040  beq cr6, 0x8286b5c8
	if ctx.cr[6].eq {
	pc = 0x8286B5C8; continue 'dispatch;
	}
	// 8286B58C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B590: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 8286B594: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B598: 41990008  bgt cr6, 0x8286b5a0
	if ctx.cr[6].gt {
	pc = 0x8286B5A0; continue 'dispatch;
	}
	// 8286B59C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8286B5A0; continue 'dispatch;
            }
            0x8286B5A0 => {
    //   block [0x8286B5A0..0x8286B5C8)
	// 8286B5A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286B5A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B5A8: 409A0020  bne cr6, 0x8286b5c8
	if !ctx.cr[6].eq {
	pc = 0x8286B5C8; continue 'dispatch;
	}
	// 8286B5AC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8286B5B0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8286B5B4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286B5B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B5BC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8286B5C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B5C4: 4800001C  b 0x8286b5e0
	pc = 0x8286B5E0; continue 'dispatch;
            }
            0x8286B5C8 => {
    //   block [0x8286B5C8..0x8286B5DC)
	// 8286B5C8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286B5CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B5D0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8286B5D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B5D8: 48000008  b 0x8286b5e0
	pc = 0x8286B5E0; continue 'dispatch;
            }
            0x8286B5DC => {
    //   block [0x8286B5DC..0x8286B5E0)
	// 8286B5DC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8286B5E0; continue 'dispatch;
            }
            0x8286B5E0 => {
    //   block [0x8286B5E0..0x8286B670)
	// 8286B5E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286B5E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B5E8: 419A0238  beq cr6, 0x8286b820
	if ctx.cr[6].eq {
	pc = 0x8286B820; continue 'dispatch;
	}
	// 8286B5EC: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8286B5F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B5F4: 419A00B8  beq cr6, 0x8286b6ac
	if ctx.cr[6].eq {
	pc = 0x8286B6AC; continue 'dispatch;
	}
	// 8286B5F8: 807B0014  lwz r3, 0x14(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8286B5FC: 3BFB0014  addi r31, r27, 0x14
	ctx.r[31].s64 = ctx.r[27].s64 + 20;
	// 8286B600: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8286B604: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B608: EFED002A  fadds f31, f13, f0
	ctx.f[31].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8286B60C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8286B610: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286B614: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286B618: 4E800421  bctrl
	ctx.lr = 0x8286B61C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286B61C: 807B0014  lwz r3, 0x14(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8286B620: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8286B624: 4BA68025  bl 0x822d3648
	ctx.lr = 0x8286B628;
	sub_822D3648(ctx, base);
	// 8286B628: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 8286B62C: 41980080  blt cr6, 0x8286b6ac
	if ctx.cr[6].lt {
	pc = 0x8286B6AC; continue 'dispatch;
	}
	// 8286B630: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B634: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B638: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286B63C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286B640: 4E800421  bctrl
	ctx.lr = 0x8286B644;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286B644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286B648: 4B94C4D1  bl 0x821b7b18
	ctx.lr = 0x8286B64C;
	sub_821B7B18(ctx, base);
	// 8286B64C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8286B650: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286B654: 809B0010  lwz r4, 0x10(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8286B658: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286B65C: 4BA429C5  bl 0x822ae020
	ctx.lr = 0x8286B660;
	sub_822AE020(ctx, base);
	// 8286B660: 807B0010  lwz r3, 0x10(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8286B664: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286B668: 419A0040  beq cr6, 0x8286b6a8
	if ctx.cr[6].eq {
	pc = 0x8286B6A8; continue 'dispatch;
	}
	// 8286B66C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
            }
            0x8286B670 => {
    //   block [0x8286B670..0x8286B6A4)
	// 8286B670: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8286B674: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B678: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8286B67C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286B680: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286B684: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B688: 4082FFE8  bne 0x8286b670
	if !ctx.cr[0].eq {
	pc = 0x8286B670; continue 'dispatch;
	}
	// 8286B68C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B690: 409A0014  bne cr6, 0x8286b6a4
	if !ctx.cr[6].eq {
	pc = 0x8286B6A4; continue 'dispatch;
	}
	// 8286B694: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B698: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B69C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286B6A0: 4E800421  bctrl
	ctx.lr = 0x8286B6A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8286B6A4 => {
    //   block [0x8286B6A4..0x8286B6A8)
	// 8286B6A4: 939B0010  stw r28, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	pc = 0x8286B6A8; continue 'dispatch;
            }
            0x8286B6A8 => {
    //   block [0x8286B6A8..0x8286B6AC)
	// 8286B6A8: 939B0010  stw r28, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	pc = 0x8286B6AC; continue 'dispatch;
            }
            0x8286B6AC => {
    //   block [0x8286B6AC..0x8286B730)
	// 8286B6AC: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8286B6B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B6B4: 409A016C  bne cr6, 0x8286b820
	if !ctx.cr[6].eq {
	pc = 0x8286B820; continue 'dispatch;
	}
	// 8286B6B8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8286B6BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286B6C0: 388B222C  addi r4, r11, 0x222c
	ctx.r[4].s64 = ctx.r[11].s64 + 8748;
	// 8286B6C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286B6C8: 4B9C1809  bl 0x8222ced0
	ctx.lr = 0x8286B6CC;
	sub_8222CED0(ctx, base);
	// 8286B6CC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8286B6D0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8286B6D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286B6D8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8286B6DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286B6E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286B6E4: 4BA1864D  bl 0x82283d30
	ctx.lr = 0x8286B6E8;
	sub_82283D30(ctx, base);
	// 8286B6E8: 3BFB0014  addi r31, r27, 0x14
	ctx.r[31].s64 = ctx.r[27].s64 + 20;
	// 8286B6EC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286B6F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286B6F4: 4BA07965  bl 0x82273058
	ctx.lr = 0x8286B6F8;
	sub_82273058(ctx, base);
	// 8286B6F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286B6FC: 4B9A96DD  bl 0x82214dd8
	ctx.lr = 0x8286B700;
	sub_82214DD8(ctx, base);
	// 8286B700: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8286B704: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286B708: 419A0118  beq cr6, 0x8286b820
	if ctx.cr[6].eq {
	pc = 0x8286B820; continue 'dispatch;
	}
	// 8286B70C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8286B710: 4B9B3B49  bl 0x8221f258
	ctx.lr = 0x8286B714;
	sub_8221F258(ctx, base);
	// 8286B714: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286B718: 419A0018  beq cr6, 0x8286b730
	if ctx.cr[6].eq {
	pc = 0x8286B730; continue 'dispatch;
	}
	// 8286B71C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8286B720: C02BB730  lfs f1, -0x48d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18640 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8286B724: 4BA2041D  bl 0x8228bb40
	ctx.lr = 0x8286B728;
	sub_8228BB40(ctx, base);
	// 8286B728: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8286B72C: 48000008  b 0x8286b734
	pc = 0x8286B734; continue 'dispatch;
            }
            0x8286B730 => {
    //   block [0x8286B730..0x8286B734)
	// 8286B730: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x8286B734; continue 'dispatch;
            }
            0x8286B734 => {
    //   block [0x8286B734..0x8286B76C)
	// 8286B734: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8286B738: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B73C: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 8286B740: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8286B744: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8286B748: 4B9629F9  bl 0x821ce140
	ctx.lr = 0x8286B74C;
	sub_821CE140(ctx, base);
	// 8286B74C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286B750: 807B0010  lwz r3, 0x10(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8286B754: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B758: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8286B75C: 419A0078  beq cr6, 0x8286b7d4
	if ctx.cr[6].eq {
	pc = 0x8286B7D4; continue 'dispatch;
	}
	// 8286B760: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286B764: 419A0040  beq cr6, 0x8286b7a4
	if ctx.cr[6].eq {
	pc = 0x8286B7A4; continue 'dispatch;
	}
	// 8286B768: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8286B76C; continue 'dispatch;
            }
            0x8286B76C => {
    //   block [0x8286B76C..0x8286B7A0)
	// 8286B76C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8286B770: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B774: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8286B778: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286B77C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286B780: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B784: 4082FFE8  bne 0x8286b76c
	if !ctx.cr[0].eq {
	pc = 0x8286B76C; continue 'dispatch;
	}
	// 8286B788: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B78C: 409A0014  bne cr6, 0x8286b7a0
	if !ctx.cr[6].eq {
	pc = 0x8286B7A0; continue 'dispatch;
	}
	// 8286B790: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B794: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B798: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286B79C: 4E800421  bctrl
	ctx.lr = 0x8286B7A0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8286B7A0 => {
    //   block [0x8286B7A0..0x8286B7A4)
	// 8286B7A0: 939B0010  stw r28, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	pc = 0x8286B7A4; continue 'dispatch;
            }
            0x8286B7A4 => {
    //   block [0x8286B7A4..0x8286B7B8)
	// 8286B7A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B7A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B7AC: 917B0010  stw r11, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8286B7B0: 419A0024  beq cr6, 0x8286b7d4
	if ctx.cr[6].eq {
	pc = 0x8286B7D4; continue 'dispatch;
	}
	// 8286B7B4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x8286B7B8; continue 'dispatch;
            }
            0x8286B7B8 => {
    //   block [0x8286B7B8..0x8286B7D4)
	// 8286B7B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8286B7BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B7C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286B7C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8286B7C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286B7CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B7D0: 4082FFE8  bne 0x8286b7b8
	if !ctx.cr[0].eq {
	pc = 0x8286B7B8; continue 'dispatch;
	}
	pc = 0x8286B7D4; continue 'dispatch;
            }
            0x8286B7D4 => {
    //   block [0x8286B7D4..0x8286B7E8)
	// 8286B7D4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8286B7D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B7DC: 419A0044  beq cr6, 0x8286b820
	if ctx.cr[6].eq {
	pc = 0x8286B820; continue 'dispatch;
	}
	// 8286B7E0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286B7E4: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x8286B7E8; continue 'dispatch;
            }
            0x8286B7E8 => {
    //   block [0x8286B7E8..0x8286B820)
	// 8286B7E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8286B7EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B7F0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286B7F4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8286B7F8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286B7FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286B800: 4082FFE8  bne 0x8286b7e8
	if !ctx.cr[0].eq {
	pc = 0x8286B7E8; continue 'dispatch;
	}
	// 8286B804: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8286B808: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B80C: 409A0014  bne cr6, 0x8286b820
	if !ctx.cr[6].eq {
	pc = 0x8286B820; continue 'dispatch;
	}
	// 8286B810: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B814: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B818: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286B81C: 4E800421  bctrl
	ctx.lr = 0x8286B820;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8286B820 => {
    //   block [0x8286B820..0x8286B82C)
	// 8286B820: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8286B824: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8286B828: 4843DC2C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8286B830 size=8
    let mut pc: u32 = 0x8286B830;
    'dispatch: loop {
        match pc {
            0x8286B830 => {
    //   block [0x8286B830..0x8286B838)
	// 8286B830: 3860002B  li r3, 0x2b
	ctx.r[3].s64 = 43;
	// 8286B834: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8286B838 size=8
    let mut pc: u32 = 0x8286B838;
    'dispatch: loop {
        match pc {
            0x8286B838 => {
    //   block [0x8286B838..0x8286B840)
	// 8286B838: 38600007  li r3, 7
	ctx.r[3].s64 = 7;
	// 8286B83C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286B840 size=60
    let mut pc: u32 = 0x8286B840;
    'dispatch: loop {
        match pc {
            0x8286B840 => {
    //   block [0x8286B840..0x8286B87C)
	// 8286B840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286B844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286B848: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286B84C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286B850: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8286B854: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286B858: 388B6680  addi r4, r11, 0x6680
	ctx.r[4].s64 = ctx.r[11].s64 + 26240;
	// 8286B85C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286B860: 4B9C1671  bl 0x8222ced0
	ctx.lr = 0x8286B864;
	sub_8222CED0(ctx, base);
	// 8286B864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286B868: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8286B86C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286B870: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286B874: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286B878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286B880 size=80
    let mut pc: u32 = 0x8286B880;
    'dispatch: loop {
        match pc {
            0x8286B880 => {
    //   block [0x8286B880..0x8286B8B8)
	// 8286B880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286B884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286B888: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286B88C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286B890: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286B894: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286B898: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8286B89C: 4BFFD365  bl 0x82868c00
	ctx.lr = 0x8286B8A0;
	sub_82868C00(ctx, base);
	// 8286B8A0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8286B8A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286B8A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B8AC: 419A000C  beq cr6, 0x8286b8b8
	if ctx.cr[6].eq {
	pc = 0x8286B8B8; continue 'dispatch;
	}
	// 8286B8B0: 4B9B0489  bl 0x8221bd38
	ctx.lr = 0x8286B8B4;
	sub_8221BD38(ctx, base);
	// 8286B8B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8286B8B8; continue 'dispatch;
            }
            0x8286B8B8 => {
    //   block [0x8286B8B8..0x8286B8D0)
	// 8286B8B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286B8BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286B8C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286B8C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286B8C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286B8CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B8D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8286B8D0 size=12
    let mut pc: u32 = 0x8286B8D0;
    'dispatch: loop {
        match pc {
            0x8286B8D0 => {
    //   block [0x8286B8D0..0x8286B8DC)
	// 8286B8D0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8286B8D4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8286B8D8: 4BFFD530  b 0x82868e08
	sub_82868E08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8286B8E0 size=8
    let mut pc: u32 = 0x8286B8E0;
    'dispatch: loop {
        match pc {
            0x8286B8E0 => {
    //   block [0x8286B8E0..0x8286B8E8)
	// 8286B8E0: 38600033  li r3, 0x33
	ctx.r[3].s64 = 51;
	// 8286B8E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286B8E8 size=720
    let mut pc: u32 = 0x8286B8E8;
    'dispatch: loop {
        match pc {
            0x8286B8E8 => {
    //   block [0x8286B8E8..0x8286B944)
	// 8286B8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286B8EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286B8F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286B8F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286B8F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286B8FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B900: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8286B904: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 8286B908: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8286B90C: 552877FE  rlwinm r8, r9, 0xe, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0003FFFFu64;
	// 8286B910: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8286B914: 419A00F4  beq cr6, 0x8286ba08
	if ctx.cr[6].eq {
	pc = 0x8286BA08; continue 'dispatch;
	}
	// 8286B918: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286B91C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286B920: 419A0024  beq cr6, 0x8286b944
	if ctx.cr[6].eq {
	pc = 0x8286B944; continue 'dispatch;
	}
	// 8286B924: 894A0012  lbz r10, 0x12(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 8286B928: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286B92C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8286B930: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286B934: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B938: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8286B93C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B940: 480000CC  b 0x8286ba0c
	pc = 0x8286BA0C; continue 'dispatch;
            }
            0x8286B944 => {
    //   block [0x8286B944..0x8286B960)
	// 8286B944: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286B948: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286B94C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8286B950: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8286B954: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8286B958: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B95C: 40810054  ble 0x8286b9b0
	if !ctx.cr[0].gt {
	pc = 0x8286B9B0; continue 'dispatch;
	}
	pc = 0x8286B960; continue 'dispatch;
            }
            0x8286B960 => {
    //   block [0x8286B960..0x8286B980)
	// 8286B960: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286B964: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286B968: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286B96C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B970: 2F070012  cmpwi cr6, r7, 0x12
	ctx.cr[6].compare_i32(ctx.r[7].s32, 18, &mut ctx.xer);
	// 8286B974: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286B978: 41980008  blt cr6, 0x8286b980
	if ctx.cr[6].lt {
	pc = 0x8286B980; continue 'dispatch;
	}
	// 8286B97C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x8286B980; continue 'dispatch;
            }
            0x8286B980 => {
    //   block [0x8286B980..0x8286B99C)
	// 8286B980: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286B984: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286B988: 419A0014  beq cr6, 0x8286b99c
	if ctx.cr[6].eq {
	pc = 0x8286B99C; continue 'dispatch;
	}
	// 8286B98C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286B990: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286B994: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286B998: 4800000C  b 0x8286b9a4
	pc = 0x8286B9A4; continue 'dispatch;
            }
            0x8286B99C => {
    //   block [0x8286B99C..0x8286B9A4)
	// 8286B99C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286B9A0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286B9A4; continue 'dispatch;
            }
            0x8286B9A4 => {
    //   block [0x8286B9A4..0x8286B9B0)
	// 8286B9A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B9A8: 4199FFB8  bgt cr6, 0x8286b960
	if ctx.cr[6].gt {
	pc = 0x8286B960; continue 'dispatch;
	}
	// 8286B9AC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8286B9B0; continue 'dispatch;
            }
            0x8286B9B0 => {
    //   block [0x8286B9B0..0x8286B9CC)
	// 8286B9B0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8286B9B4: 419A0040  beq cr6, 0x8286b9f4
	if ctx.cr[6].eq {
	pc = 0x8286B9F4; continue 'dispatch;
	}
	// 8286B9B8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B9BC: 2F0B0012  cmpwi cr6, r11, 0x12
	ctx.cr[6].compare_i32(ctx.r[11].s32, 18, &mut ctx.xer);
	// 8286B9C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B9C4: 41990008  bgt cr6, 0x8286b9cc
	if ctx.cr[6].gt {
	pc = 0x8286B9CC; continue 'dispatch;
	}
	// 8286B9C8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8286B9CC; continue 'dispatch;
            }
            0x8286B9CC => {
    //   block [0x8286B9CC..0x8286B9F4)
	// 8286B9CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286B9D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B9D4: 409A0020  bne cr6, 0x8286b9f4
	if !ctx.cr[6].eq {
	pc = 0x8286B9F4; continue 'dispatch;
	}
	// 8286B9D8: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8286B9DC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8286B9E0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8286B9E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B9E8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8286B9EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286B9F0: 4800001C  b 0x8286ba0c
	pc = 0x8286BA0C; continue 'dispatch;
            }
            0x8286B9F4 => {
    //   block [0x8286B9F4..0x8286BA08)
	// 8286B9F4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286B9F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B9FC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8286BA00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286BA04: 48000008  b 0x8286ba0c
	pc = 0x8286BA0C; continue 'dispatch;
            }
            0x8286BA08 => {
    //   block [0x8286BA08..0x8286BA0C)
	// 8286BA08: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8286BA0C; continue 'dispatch;
            }
            0x8286BA0C => {
    //   block [0x8286BA0C..0x8286BA1C)
	// 8286BA0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286BA10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286BA14: 419A0008  beq cr6, 0x8286ba1c
	if ctx.cr[6].eq {
	pc = 0x8286BA1C; continue 'dispatch;
	}
	// 8286BA18: 9BCA0034  stb r30, 0x34(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(52 as u32), ctx.r[30].u8 ) };
	pc = 0x8286BA1C; continue 'dispatch;
            }
            0x8286BA1C => {
    //   block [0x8286BA1C..0x8286BA60)
	// 8286BA1C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286BA20: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 8286BA24: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8286BA28: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 8286BA2C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8286BA30: 419A00F4  beq cr6, 0x8286bb24
	if ctx.cr[6].eq {
	pc = 0x8286BB24; continue 'dispatch;
	}
	// 8286BA34: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286BA38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286BA3C: 419A0024  beq cr6, 0x8286ba60
	if ctx.cr[6].eq {
	pc = 0x8286BA60; continue 'dispatch;
	}
	// 8286BA40: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 8286BA44: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286BA48: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8286BA4C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8286BA50: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286BA54: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8286BA58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286BA5C: 480000CC  b 0x8286bb28
	pc = 0x8286BB28; continue 'dispatch;
            }
            0x8286BA60 => {
    //   block [0x8286BA60..0x8286BA7C)
	// 8286BA60: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286BA64: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286BA68: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8286BA6C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8286BA70: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8286BA74: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286BA78: 40810054  ble 0x8286bacc
	if !ctx.cr[0].gt {
	pc = 0x8286BACC; continue 'dispatch;
	}
	pc = 0x8286BA7C; continue 'dispatch;
            }
            0x8286BA7C => {
    //   block [0x8286BA7C..0x8286BA9C)
	// 8286BA7C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286BA80: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286BA84: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286BA88: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286BA8C: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 8286BA90: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286BA94: 41980008  blt cr6, 0x8286ba9c
	if ctx.cr[6].lt {
	pc = 0x8286BA9C; continue 'dispatch;
	}
	// 8286BA98: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x8286BA9C; continue 'dispatch;
            }
            0x8286BA9C => {
    //   block [0x8286BA9C..0x8286BAB8)
	// 8286BA9C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286BAA0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286BAA4: 419A0014  beq cr6, 0x8286bab8
	if ctx.cr[6].eq {
	pc = 0x8286BAB8; continue 'dispatch;
	}
	// 8286BAA8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286BAAC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286BAB0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286BAB4: 4800000C  b 0x8286bac0
	pc = 0x8286BAC0; continue 'dispatch;
            }
            0x8286BAB8 => {
    //   block [0x8286BAB8..0x8286BAC0)
	// 8286BAB8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286BABC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286BAC0; continue 'dispatch;
            }
            0x8286BAC0 => {
    //   block [0x8286BAC0..0x8286BACC)
	// 8286BAC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286BAC4: 4199FFB8  bgt cr6, 0x8286ba7c
	if ctx.cr[6].gt {
	pc = 0x8286BA7C; continue 'dispatch;
	}
	// 8286BAC8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8286BACC; continue 'dispatch;
            }
            0x8286BACC => {
    //   block [0x8286BACC..0x8286BAE8)
	// 8286BACC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8286BAD0: 419A0040  beq cr6, 0x8286bb10
	if ctx.cr[6].eq {
	pc = 0x8286BB10; continue 'dispatch;
	}
	// 8286BAD4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286BAD8: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 8286BADC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286BAE0: 41990008  bgt cr6, 0x8286bae8
	if ctx.cr[6].gt {
	pc = 0x8286BAE8; continue 'dispatch;
	}
	// 8286BAE4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8286BAE8; continue 'dispatch;
            }
            0x8286BAE8 => {
    //   block [0x8286BAE8..0x8286BB10)
	// 8286BAE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286BAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286BAF0: 409A0020  bne cr6, 0x8286bb10
	if !ctx.cr[6].eq {
	pc = 0x8286BB10; continue 'dispatch;
	}
	// 8286BAF4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8286BAF8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8286BAFC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8286BB00: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286BB04: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8286BB08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286BB0C: 4800001C  b 0x8286bb28
	pc = 0x8286BB28; continue 'dispatch;
            }
            0x8286BB10 => {
    //   block [0x8286BB10..0x8286BB24)
	// 8286BB10: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286BB14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286BB18: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8286BB1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286BB20: 48000008  b 0x8286bb28
	pc = 0x8286BB28; continue 'dispatch;
            }
            0x8286BB24 => {
    //   block [0x8286BB24..0x8286BB28)
	// 8286BB24: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8286BB28; continue 'dispatch;
            }
            0x8286BB28 => {
    //   block [0x8286BB28..0x8286BB98)
	// 8286BB28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286BB2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286BB30: 419A0070  beq cr6, 0x8286bba0
	if ctx.cr[6].eq {
	pc = 0x8286BBA0; continue 'dispatch;
	}
	// 8286BB34: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8286BB38: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8286BB3C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8286BB40: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 8286BB44: 388B0E20  addi r4, r11, 0xe20
	ctx.r[4].s64 = ctx.r[11].s64 + 3616;
	// 8286BB48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8286BB4C: 4B9C1385  bl 0x8222ced0
	ctx.lr = 0x8286BB50;
	sub_8222CED0(ctx, base);
	// 8286BB50: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8286BB54: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8286BB58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286BB5C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8286BB60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286BB64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286BB68: 4BA181C9  bl 0x82283d30
	ctx.lr = 0x8286BB6C;
	sub_82283D30(ctx, base);
	// 8286BB6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286BB70: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286BB74: 4BA074E5  bl 0x82273058
	ctx.lr = 0x8286BB78;
	sub_82273058(ctx, base);
	// 8286BB78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8286BB7C: 4B9A925D  bl 0x82214dd8
	ctx.lr = 0x8286BB80;
	sub_82214DD8(ctx, base);
	// 8286BB80: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8286BB84: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8286BB88: 419A0010  beq cr6, 0x8286bb98
	if ctx.cr[6].eq {
	pc = 0x8286BB98; continue 'dispatch;
	}
	// 8286BB8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8286BB90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286BB94: 4BBB6235  bl 0x82421dc8
	ctx.lr = 0x8286BB98;
	sub_82421DC8(ctx, base);
	pc = 0x8286BB98; continue 'dispatch;
            }
            0x8286BB98 => {
    //   block [0x8286BB98..0x8286BBA0)
	// 8286BB98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286BB9C: 4B94BF7D  bl 0x821b7b18
	ctx.lr = 0x8286BBA0;
	sub_821B7B18(ctx, base);
	pc = 0x8286BBA0; continue 'dispatch;
            }
            0x8286BBA0 => {
    //   block [0x8286BBA0..0x8286BBB8)
	// 8286BBA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8286BBA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286BBA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286BBAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286BBB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286BBB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286BBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8286BBB8 size=296
    let mut pc: u32 = 0x8286BBB8;
    'dispatch: loop {
        match pc {
            0x8286BBB8 => {
    //   block [0x8286BBB8..0x8286BBFC)
	// 8286BBB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286BBBC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8286BBC0: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8286BBC4: 552877FE  rlwinm r8, r9, 0xe, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0003FFFFu64;
	// 8286BBC8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8286BBCC: 419A00F8  beq cr6, 0x8286bcc4
	if ctx.cr[6].eq {
	pc = 0x8286BCC4; continue 'dispatch;
	}
	// 8286BBD0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286BBD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286BBD8: 419A0024  beq cr6, 0x8286bbfc
	if ctx.cr[6].eq {
	pc = 0x8286BBFC; continue 'dispatch;
	}
	// 8286BBDC: 894A0012  lbz r10, 0x12(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 8286BBE0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286BBE4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8286BBE8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286BBEC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286BBF0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8286BBF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286BBF8: 480000D0  b 0x8286bcc8
	pc = 0x8286BCC8; continue 'dispatch;
            }
            0x8286BBFC => {
    //   block [0x8286BBFC..0x8286BC1C)
	// 8286BBFC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8286BC00: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8286BC04: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286BC08: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 8286BC0C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8286BC10: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 8286BC14: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286BC18: 40810054  ble 0x8286bc6c
	if !ctx.cr[0].gt {
	pc = 0x8286BC6C; continue 'dispatch;
	}
	pc = 0x8286BC1C; continue 'dispatch;
            }
            0x8286BC1C => {
    //   block [0x8286BC1C..0x8286BC3C)
	// 8286BC1C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8286BC20: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8286BC24: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8286BC28: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286BC2C: 2F070012  cmpwi cr6, r7, 0x12
	ctx.cr[6].compare_i32(ctx.r[7].s32, 18, &mut ctx.xer);
	// 8286BC30: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8286BC34: 41980008  blt cr6, 0x8286bc3c
	if ctx.cr[6].lt {
	pc = 0x8286BC3C; continue 'dispatch;
	}
	// 8286BC38: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8286BC3C; continue 'dispatch;
            }
            0x8286BC3C => {
    //   block [0x8286BC3C..0x8286BC58)
	// 8286BC3C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8286BC40: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8286BC44: 419A0014  beq cr6, 0x8286bc58
	if ctx.cr[6].eq {
	pc = 0x8286BC58; continue 'dispatch;
	}
	// 8286BC48: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8286BC4C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8286BC50: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8286BC54: 4800000C  b 0x8286bc60
	pc = 0x8286BC60; continue 'dispatch;
            }
            0x8286BC58 => {
    //   block [0x8286BC58..0x8286BC60)
	// 8286BC58: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8286BC5C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8286BC60; continue 'dispatch;
            }
            0x8286BC60 => {
    //   block [0x8286BC60..0x8286BC6C)
	// 8286BC60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286BC64: 4199FFB8  bgt cr6, 0x8286bc1c
	if ctx.cr[6].gt {
	pc = 0x8286BC1C; continue 'dispatch;
	}
	// 8286BC68: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x8286BC6C; continue 'dispatch;
            }
            0x8286BC6C => {
    //   block [0x8286BC6C..0x8286BC88)
	// 8286BC6C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8286BC70: 419A0040  beq cr6, 0x8286bcb0
	if ctx.cr[6].eq {
	pc = 0x8286BCB0; continue 'dispatch;
	}
	// 8286BC74: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286BC78: 2F0B0012  cmpwi cr6, r11, 0x12
	ctx.cr[6].compare_i32(ctx.r[11].s32, 18, &mut ctx.xer);
	// 8286BC7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286BC80: 41990008  bgt cr6, 0x8286bc88
	if ctx.cr[6].gt {
	pc = 0x8286BC88; continue 'dispatch;
	}
	// 8286BC84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8286BC88; continue 'dispatch;
            }
            0x8286BC88 => {
    //   block [0x8286BC88..0x8286BCB0)
	// 8286BC88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286BC8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286BC90: 409A0020  bne cr6, 0x8286bcb0
	if !ctx.cr[6].eq {
	pc = 0x8286BCB0; continue 'dispatch;
	}
	// 8286BC94: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286BC98: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 8286BC9C: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 8286BCA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286BCA4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8286BCA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286BCAC: 4800001C  b 0x8286bcc8
	pc = 0x8286BCC8; continue 'dispatch;
            }
            0x8286BCB0 => {
    //   block [0x8286BCB0..0x8286BCC4)
	// 8286BCB0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8286BCB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286BCB8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8286BCBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286BCC0: 48000008  b 0x8286bcc8
	pc = 0x8286BCC8; continue 'dispatch;
            }
            0x8286BCC4 => {
    //   block [0x8286BCC4..0x8286BCC8)
	// 8286BCC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8286BCC8; continue 'dispatch;
            }
            0x8286BCC8 => {
    //   block [0x8286BCC8..0x8286BCE0)
	// 8286BCC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8286BCCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286BCD0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8286BCD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286BCD8: 996A0034  stb r11, 0x34(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 8286BCDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286BCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8286BCE0 size=8
    let mut pc: u32 = 0x8286BCE0;
    'dispatch: loop {
        match pc {
            0x8286BCE0 => {
    //   block [0x8286BCE0..0x8286BCE8)
	// 8286BCE0: 38600011  li r3, 0x11
	ctx.r[3].s64 = 17;
	// 8286BCE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286BCE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286BCE8 size=96
    let mut pc: u32 = 0x8286BCE8;
    'dispatch: loop {
        match pc {
            0x8286BCE8 => {
    //   block [0x8286BCE8..0x8286BD30)
	// 8286BCE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286BCEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286BCF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286BCF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286BCF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286BCFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286BD00: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8286BD04: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 8286BD08: 394BF058  addi r10, r11, -0xfa8
	ctx.r[10].s64 = ctx.r[11].s64 + -4008;
	// 8286BD0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8286BD10: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8286BD14: 4B9A90C5  bl 0x82214dd8
	ctx.lr = 0x8286BD18;
	sub_82214DD8(ctx, base);
	// 8286BD18: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8286BD1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286BD20: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8286BD24: 419A000C  beq cr6, 0x8286bd30
	if ctx.cr[6].eq {
	pc = 0x8286BD30; continue 'dispatch;
	}
	// 8286BD28: 4B9B0011  bl 0x8221bd38
	ctx.lr = 0x8286BD2C;
	sub_8221BD38(ctx, base);
	// 8286BD2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8286BD30; continue 'dispatch;
            }
            0x8286BD30 => {
    //   block [0x8286BD30..0x8286BD48)
	// 8286BD30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286BD34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286BD38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286BD3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286BD40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286BD44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


